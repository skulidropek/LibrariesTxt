[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public enum Microsoft.Identity.Client.AadAuthorityAudience : Enum {
    public int value__;
    public static AadAuthorityAudience None;
    public static AadAuthorityAudience AzureAdMyOrg;
    public static AadAuthorityAudience AzureAdAndPersonalMicrosoftAccount;
    public static AadAuthorityAudience AzureAdMultipleOrgs;
    public static AadAuthorityAudience PersonalMicrosoftAccount;
}
public abstract class Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1 : BaseAbstractAcquireTokenParameterBuilder`1<T> {
    internal AbstractAcquireTokenParameterBuilder`1(IServiceBundle serviceBundle);
    protected T WithScopes(IEnumerable`1<string> scopes);
    public T WithClaims(string claims);
    public T WithExtraQueryParameters(string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(string authorityUri, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(string cloudInstanceUri, string tenant, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API has been deprecated. You can override the tenant ID in the request using WithTenantId. See https://aka.ms/msal-net-authority-override ")]
public T WithAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority);
    public T WithTenantId(string tenantId);
    public T WithTenantIdFromAuthority(Uri authorityUri);
    public T WithAdfsAuthority(string authorityUri, bool validateAuthority);
    public T WithB2CAuthority(string authorityUri);
    internal T WithAuthenticationScheme(IAuthenticationScheme scheme);
}
public abstract class Microsoft.Identity.Client.AbstractApplicationBuilder`1 : BaseAbstractApplicationBuilder`1<T> {
    internal AbstractApplicationBuilder`1(ApplicationConfiguration configuration);
    [ObsoleteAttribute("This method name has a typo, please use WithInstanceDiscoveryMetadata instead", "False")]
[EditorBrowsableAttribute("1")]
public T WithInstanceDicoveryMetadata(string instanceDiscoveryJson);
    public T WithInstanceDiscoveryMetadata(string instanceDiscoveryJson);
    [ObsoleteAttribute("This method name has a typo, please use WithInstanceDiscoveryMetadata instead", "False")]
[EditorBrowsableAttribute("1")]
public T WithInstanceDicoveryMetadata(Uri instanceDiscoveryUri);
    public T WithInstanceDiscoveryMetadata(Uri instanceDiscoveryUri);
    internal T WithPlatformProxy(IPlatformProxy platformProxy);
    [EditorBrowsableAttribute("1")]
public T WithCacheOptions(CacheOptions options);
    internal T WithUserTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal);
    public T WithLegacyCacheCompatibility(bool enableLegacyCacheCompatibility);
    public T WithClientId(string clientId);
    public T WithRedirectUri(string redirectUri);
    public T WithTenantId(string tenantId);
    protected T WithOptions(ApplicationOptions applicationOptions);
    public T WithExtraQueryParameters(IDictionary`2<string, string> extraQueryParameters);
    public T WithExtraQueryParameters(string extraQueryParameters);
    public T WithClientCapabilities(IEnumerable`1<string> clientCapabilities);
    public T WithInstanceDiscovery(bool enableInstanceDiscovery);
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public T WithTelemetry(ITelemetryConfig telemetryConfig);
    internal virtual void Validate();
    internal virtual ApplicationConfiguration BuildConfiguration();
    public T WithAuthority(Uri authorityUri, bool validateAuthority);
    public T WithAuthority(string authorityUri, bool validateAuthority);
    public T WithAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority);
    public T WithAuthority(string cloudInstanceUri, string tenant, bool validateAuthority);
    public T WithAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority);
    public T WithAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority);
    public T WithAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority);
    public T WithAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority);
    public T WithAdfsAuthority(string authorityUri, bool validateAuthority);
    public T WithB2CAuthority(string authorityUri);
}
public abstract class Microsoft.Identity.Client.AbstractClientAppBaseAcquireTokenParameterBuilder`1 : AbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IClientApplicationBaseExecutor <ClientApplicationBaseExecutor>k__BackingField;
    internal IClientApplicationBaseExecutor ClientApplicationBaseExecutor { get; }
    internal AbstractClientAppBaseAcquireTokenParameterBuilder`1(IClientApplicationBaseExecutor clientApplicationBaseExecutor);
    [CompilerGeneratedAttribute]
internal IClientApplicationBaseExecutor get_ClientApplicationBaseExecutor();
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
}
[EditorBrowsableAttribute("1")]
public abstract class Microsoft.Identity.Client.AbstractConfidentialClientAcquireTokenParameterBuilder`1 : AbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IConfidentialClientApplicationExecutor <ConfidentialClientApplicationExecutor>k__BackingField;
    internal IConfidentialClientApplicationExecutor ConfidentialClientApplicationExecutor { get; }
    internal AbstractConfidentialClientAcquireTokenParameterBuilder`1(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    [CompilerGeneratedAttribute]
internal IConfidentialClientApplicationExecutor get_ConfidentialClientApplicationExecutor();
    public T WithProofOfPossession(PoPAuthenticationConfiguration popAuthenticationConfiguration);
}
[EditorBrowsableAttribute("1")]
public abstract class Microsoft.Identity.Client.AbstractManagedIdentityAcquireTokenParameterBuilder`1 : BaseAbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IManagedIdentityApplicationExecutor <ManagedIdentityApplicationExecutor>k__BackingField;
    internal IManagedIdentityApplicationExecutor ManagedIdentityApplicationExecutor { get; }
    internal AbstractManagedIdentityAcquireTokenParameterBuilder`1(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor);
    [CompilerGeneratedAttribute]
internal IManagedIdentityApplicationExecutor get_ManagedIdentityApplicationExecutor();
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
}
public abstract class Microsoft.Identity.Client.AbstractPublicClientAcquireTokenParameterBuilder`1 : AbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IPublicClientApplicationExecutor <PublicClientApplicationExecutor>k__BackingField;
    internal IPublicClientApplicationExecutor PublicClientApplicationExecutor { get; }
    internal AbstractPublicClientAcquireTokenParameterBuilder`1(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal IPublicClientApplicationExecutor get_PublicClientApplicationExecutor();
}
internal class Microsoft.Identity.Client.Account : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountSource>k__BackingField;
    [CompilerGeneratedAttribute]
private AccountId <HomeAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TenantProfile> <TenantProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <WamAccountIds>k__BackingField;
    public string Username { get; }
    public string Environment { get; }
    public string AccountSource { get; }
    public AccountId HomeAccountId { get; }
    public IEnumerable`1<TenantProfile> TenantProfiles { get; }
    internal IDictionary`2<string, string> WamAccountIds { get; }
    public Account(string homeAccountId, string username, string environment, string accountsource, IDictionary`2<string, string> wamAccountIds, IEnumerable`1<TenantProfile> tenantProfiles);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Username();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Environment();
    [CompilerGeneratedAttribute]
public string get_AccountSource();
    [CompilerGeneratedAttribute]
public sealed virtual AccountId get_HomeAccountId();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TenantProfile> get_TenantProfiles();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_WamAccountIds();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.AccountExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TenantProfile> GetTenantProfiles(IAccount account);
}
public class Microsoft.Identity.Client.AccountId : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    public string Identifier { get; }
    public string ObjectId { get; }
    public string TenantId { get; }
    public AccountId(string identifier, string objectId, string tenantId);
    public AccountId(string adfsIdentifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public string get_ObjectId();
    [CompilerGeneratedAttribute]
public string get_TenantId();
    internal static AccountId ParseFromString(string str);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ConditionalAttribute("DEBUG")]
private void ValidateId();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenByAuthorizationCodeParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByAuthorizationCodeParameters <Parameters>k__BackingField;
    private AcquireTokenByAuthorizationCodeParameters Parameters { get; }
    internal AcquireTokenByAuthorizationCodeParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByAuthorizationCodeParameters get_Parameters();
    internal static AcquireTokenByAuthorizationCodeParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, string authorizationCode);
    private AcquireTokenByAuthorizationCodeParameterBuilder WithAuthorizationCode(string authorizationCode);
    internal virtual ApiIds CalculateApiEventId();
    protected virtual void Validate();
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithSendX5C(bool withSendX5C);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithPkceCodeVerifier(string pkceCodeVerifier);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithCcsRoutingHint(string userName);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithSpaAuthorizationCode(bool requestSpaAuthorizationCode);
}
public class Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenByIntegratedWindowsAuthParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByIntegratedWindowsAuthParameters <Parameters>k__BackingField;
    private AcquireTokenByIntegratedWindowsAuthParameters Parameters { get; }
    internal AcquireTokenByIntegratedWindowsAuthParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByIntegratedWindowsAuthParameters get_Parameters();
    internal static AcquireTokenByIntegratedWindowsAuthParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes);
    public AcquireTokenByIntegratedWindowsAuthParameterBuilder WithUsername(string username);
    public AcquireTokenByIntegratedWindowsAuthParameterBuilder WithFederationMetadata(string federationMetadata);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder : AbstractClientAppBaseAcquireTokenParameterBuilder`1<AcquireTokenByRefreshTokenParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByRefreshTokenParameters <Parameters>k__BackingField;
    private AcquireTokenByRefreshTokenParameters Parameters { get; }
    internal AcquireTokenByRefreshTokenParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByRefreshTokenParameters get_Parameters();
    internal static AcquireTokenByRefreshTokenParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable`1<string> scopes, string refreshToken);
    internal AcquireTokenByRefreshTokenParameterBuilder WithRefreshToken(string refreshToken);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
    [EditorBrowsableAttribute("1")]
public AcquireTokenByRefreshTokenParameterBuilder WithSendX5C(bool withSendX5C);
}
public class Microsoft.Identity.Client.AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByUsernamePasswordParameters <Parameters>k__BackingField;
    private AcquireTokenByUsernamePasswordParameters Parameters { get; }
    internal AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, string username, string password);
    [CompilerGeneratedAttribute]
private AcquireTokenByUsernamePasswordParameters get_Parameters();
    internal static AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, string username, string password);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
    protected virtual void Validate();
}
public class Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenByUsernamePasswordParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByUsernamePasswordParameters <Parameters>k__BackingField;
    private AcquireTokenByUsernamePasswordParameters Parameters { get; }
    internal AcquireTokenByUsernamePasswordParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByUsernamePasswordParameters get_Parameters();
    internal static AcquireTokenByUsernamePasswordParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes, string username, string password);
    public AcquireTokenByUsernamePasswordParameterBuilder WithFederationMetadata(string federationMetadata);
    [EditorBrowsableAttribute("1")]
public AcquireTokenByUsernamePasswordParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri);
    private AcquireTokenByUsernamePasswordParameterBuilder WithUsername(string username);
    private AcquireTokenByUsernamePasswordParameterBuilder WithPassword(string password);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenForClientParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenForClientParameters <Parameters>k__BackingField;
    private AcquireTokenForClientParameters Parameters { get; }
    internal AcquireTokenForClientParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenForClientParameters get_Parameters();
    internal static AcquireTokenForClientParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes);
    public AcquireTokenForClientParameterBuilder WithForceRefresh(bool forceRefresh);
    public AcquireTokenForClientParameterBuilder WithSendX5C(bool withSendX5C);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithAzureRegion on the ConfidentialClientApplicationBuilder object", "True")]
public AcquireTokenForClientParameterBuilder WithAzureRegion(bool useAzureRegion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithAzureRegion on the ConfidentialClientApplicationBuilder object", "True")]
public AcquireTokenForClientParameterBuilder WithPreferredAzureRegion(bool useAzureRegion, string regionUsedIfAutoDetectFails, bool fallbackToGlobal);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.AcquireTokenForManagedIdentityParameterBuilder : AbstractManagedIdentityAcquireTokenParameterBuilder`1<AcquireTokenForManagedIdentityParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenForManagedIdentityParameters <Parameters>k__BackingField;
    private AcquireTokenForManagedIdentityParameters Parameters { get; }
    internal AcquireTokenForManagedIdentityParameterBuilder(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenForManagedIdentityParameters get_Parameters();
    internal static AcquireTokenForManagedIdentityParameterBuilder Create(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor, string resource);
    private AcquireTokenForManagedIdentityParameterBuilder WithResource(string resource);
    public AcquireTokenForManagedIdentityParameterBuilder WithForceRefresh(bool forceRefresh);
    public AcquireTokenForManagedIdentityParameterBuilder WithClaims(string claims);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenInteractiveParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenInteractiveParameters <Parameters>k__BackingField;
    private AcquireTokenInteractiveParameters Parameters { get; }
    internal AcquireTokenInteractiveParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenInteractiveParameters get_Parameters();
    internal void SetCustomWebUi(ICustomWebUi customWebUi);
    internal static AcquireTokenInteractiveParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes);
    internal AcquireTokenInteractiveParameterBuilder WithCurrentSynchronizationContext();
    internal AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindowFunc(Func`1<object> parentActivityOrWindowFunc);
    public AcquireTokenInteractiveParameterBuilder WithUseEmbeddedWebView(bool useEmbeddedWebView);
    public AcquireTokenInteractiveParameterBuilder WithSystemWebViewOptions(SystemWebViewOptions options);
    [EditorBrowsableAttribute("1")]
public AcquireTokenInteractiveParameterBuilder WithEmbeddedWebViewOptions(EmbeddedWebViewOptions options);
    public AcquireTokenInteractiveParameterBuilder WithLoginHint(string loginHint);
    public AcquireTokenInteractiveParameterBuilder WithAccount(IAccount account);
    public AcquireTokenInteractiveParameterBuilder WithExtraScopesToConsent(IEnumerable`1<string> extraScopesToConsent);
    public AcquireTokenInteractiveParameterBuilder WithPrompt(Prompt prompt);
    [EditorBrowsableAttribute("1")]
public AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindow(object parent);
    private AcquireTokenInteractiveParameterBuilder WithParentObject(object parent);
    [CLSCompliantAttribute("False")]
public AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindow(UIViewController viewController);
    [EditorBrowsableAttribute("1")]
public AcquireTokenInteractiveParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri);
    protected virtual void Validate();
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenOnBehalfOfParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenOnBehalfOfParameters <Parameters>k__BackingField;
    internal AcquireTokenOnBehalfOfParameters Parameters { get; }
    internal AcquireTokenOnBehalfOfParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    [CompilerGeneratedAttribute]
internal AcquireTokenOnBehalfOfParameters get_Parameters();
    internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, UserAssertion userAssertion);
    internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, UserAssertion userAssertion, string cacheKey);
    internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, string cacheKey);
    private AcquireTokenOnBehalfOfParameterBuilder WithUserAssertion(UserAssertion userAssertion);
    private AcquireTokenOnBehalfOfParameterBuilder WithCacheKey(string cacheKey);
    public AcquireTokenOnBehalfOfParameterBuilder WithSendX5C(bool withSendX5C);
    public AcquireTokenOnBehalfOfParameterBuilder WithForceRefresh(bool forceRefresh);
    public AcquireTokenOnBehalfOfParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier);
    public AcquireTokenOnBehalfOfParameterBuilder WithCcsRoutingHint(string userName);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenSilentParameterBuilder : AbstractClientAppBaseAcquireTokenParameterBuilder`1<AcquireTokenSilentParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenSilentParameters <Parameters>k__BackingField;
    private AcquireTokenSilentParameters Parameters { get; }
    internal AcquireTokenSilentParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenSilentParameters get_Parameters();
    internal static AcquireTokenSilentParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable`1<string> scopes, IAccount account);
    internal static AcquireTokenSilentParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable`1<string> scopes, string loginHint);
    private AcquireTokenSilentParameterBuilder WithAccount(IAccount account);
    private AcquireTokenSilentParameterBuilder WithLoginHint(string loginHint);
    public AcquireTokenSilentParameterBuilder WithForceRefresh(bool forceRefresh);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
    [EditorBrowsableAttribute("1")]
public AcquireTokenSilentParameterBuilder WithSendX5C(bool withSendX5C);
    [EditorBrowsableAttribute("1")]
public AcquireTokenSilentParameterBuilder WithProofOfPossession(PoPAuthenticationConfiguration popAuthenticationConfiguration);
    [EditorBrowsableAttribute("1")]
public AcquireTokenSilentParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri);
}
public class Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenWithDeviceCodeParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenWithDeviceCodeParameters <Parameters>k__BackingField;
    private AcquireTokenWithDeviceCodeParameters Parameters { get; }
    internal AcquireTokenWithDeviceCodeParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenWithDeviceCodeParameters get_Parameters();
    internal static AcquireTokenWithDeviceCodeParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    public AcquireTokenWithDeviceCodeParameterBuilder WithDeviceCodeResultCallback(Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
    protected virtual void Validate();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Advanced.AcquireTokenParameterBuilderExtensions : object {
    [ExtensionAttribute]
public static T WithExtraHttpHeaders(AbstractAcquireTokenParameterBuilder`1<T> builder, IDictionary`2<string, string> extraHttpHeaders);
}
internal abstract class Microsoft.Identity.Client.ApiConfig.Executors.AbstractExecutor : object {
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    public IServiceBundle ServiceBundle { get; }
    protected AbstractExecutor(IServiceBundle serviceBundle);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceBundle get_ServiceBundle();
    protected RequestContext CreateRequestContextAndLogVersionInfo(Guid correlationId, CancellationToken userCancellationToken);
}
internal class Microsoft.Identity.Client.ApiConfig.Executors.ClientApplicationBaseExecutor : AbstractExecutor {
    private ClientApplicationBase _clientApplicationBase;
    public ClientApplicationBaseExecutor(IServiceBundle serviceBundle, ClientApplicationBase clientApplicationBase);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ClientApplicationBaseExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenSilentParameters silentParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ClientApplicationBaseExecutor/<ExecuteAsync>d__3")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByRefreshTokenParameters refreshTokenParameters, CancellationToken cancellationToken);
}
internal static class Microsoft.Identity.Client.ApiConfig.Executors.ClientExecutorFactory : object {
    public static IPublicClientApplicationExecutor CreatePublicClientExecutor(PublicClientApplication publicClientApplication);
    [EditorBrowsableAttribute("1")]
public static IConfidentialClientApplicationExecutor CreateConfidentialClientExecutor(ConfidentialClientApplication confidentialClientApplication);
    [EditorBrowsableAttribute("1")]
public static IManagedIdentityApplicationExecutor CreateManagedIdentityExecutor(ManagedIdentityApplication managedIdentityApplication);
    public static IClientApplicationBaseExecutor CreateClientApplicationBaseExecutor(ClientApplicationBase clientApplicationBase);
}
[EditorBrowsableAttribute("1")]
internal class Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor : AbstractExecutor {
    private ConfidentialClientApplication _confidentialClientApplication;
    public ConfidentialClientExecutor(IServiceBundle serviceBundle, ConfidentialClientApplication confidentialClientApplication);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__3")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__4")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__5")]
public sealed virtual Task`1<Uri> ExecuteAsync(AcquireTokenCommonParameters commonParameters, GetAuthorizationRequestUrlParameters authorizationRequestUrlParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__6")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IClientApplicationBaseExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenSilentParameters silentParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByRefreshTokenParameters byRefreshTokenParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IConfidentialClientApplicationExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<Uri> ExecuteAsync(AcquireTokenCommonParameters commonParameters, GetAuthorizationRequestUrlParameters authorizationRequestUrlParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IManagedIdentityApplicationExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IPublicClientApplicationExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenInteractiveParameters interactiveParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenWithDeviceCodeParameters withDeviceCodeParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
}
[EditorBrowsableAttribute("1")]
internal class Microsoft.Identity.Client.ApiConfig.Executors.ManagedIdentityExecutor : AbstractExecutor {
    private ManagedIdentityApplication _managedIdentityApplication;
    public ManagedIdentityExecutor(IServiceBundle serviceBundle, ManagedIdentityApplication managedIdentityApplication);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ManagedIdentityExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor : AbstractExecutor {
    private PublicClientApplication _publicClientApplication;
    public PublicClientExecutor(IServiceBundle serviceBundle, PublicClientApplication publicClientApplication);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenInteractiveParameters interactiveParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__3")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenWithDeviceCodeParameters deviceCodeParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__4")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__5")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
}
internal abstract class Microsoft.Identity.Client.ApiConfig.Parameters.AbstractAcquireTokenByUsernameParameters : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMetadata>k__BackingField;
    public string Username { get; public set; }
    public string FederationMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMetadata();
    [CompilerGeneratedAttribute]
public void set_FederationMetadata(string value);
}
internal abstract class Microsoft.Identity.Client.ApiConfig.Parameters.AbstractAcquireTokenConfidentialClientParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SendX5C>k__BackingField;
    public Nullable`1<bool> SendX5C { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(Nullable`1<bool> value);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByAuthorizationCodeParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private string <AuthorizationCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PkceCodeVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaCode>k__BackingField;
    public string AuthorizationCode { get; public set; }
    public string PkceCodeVerifier { get; public set; }
    public bool SpaCode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AuthorizationCode();
    [CompilerGeneratedAttribute]
public void set_AuthorizationCode(string value);
    [CompilerGeneratedAttribute]
public string get_PkceCodeVerifier();
    [CompilerGeneratedAttribute]
public void set_PkceCodeVerifier(string value);
    [CompilerGeneratedAttribute]
public bool get_SpaCode();
    [CompilerGeneratedAttribute]
public void set_SpaCode(bool value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByIntegratedWindowsAuthParameters : AbstractAcquireTokenByUsernameParameters {
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByRefreshTokenParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    public string RefreshToken { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByUsernamePasswordParameters : AbstractAcquireTokenByUsernameParameters {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SendX5C>k__BackingField;
    public string Password { get; public set; }
    public Nullable`1<bool> SendX5C { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(Nullable`1<bool> value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenCommonParameters : object {
    [CompilerGeneratedAttribute]
private ApiIds <ApiId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <UserProvidedCorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCorrelationIdFromUser>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraQueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorityInfo <AuthorityOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private IAuthenticationScheme <AuthenticationScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraHttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private PoPAuthenticationConfiguration <PopAuthenticationConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<OnBeforeTokenRequestData, Task> <OnBeforeTokenRequestHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <MtlsCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AdditionalCacheParameters>k__BackingField;
    public ApiIds ApiId { get; public set; }
    public Guid CorrelationId { get; public set; }
    public Guid UserProvidedCorrelationId { get; public set; }
    public bool UseCorrelationIdFromUser { get; public set; }
    public IEnumerable`1<string> Scopes { get; public set; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; public set; }
    public string Claims { get; public set; }
    public AuthorityInfo AuthorityOverride { get; public set; }
    public IAuthenticationScheme AuthenticationScheme { get; public set; }
    public IDictionary`2<string, string> ExtraHttpHeaders { get; public set; }
    public PoPAuthenticationConfiguration PopAuthenticationConfiguration { get; public set; }
    public Func`2<OnBeforeTokenRequestData, Task> OnBeforeTokenRequestHandler { get; internal set; }
    public X509Certificate2 MtlsCertificate { get; internal set; }
    public List`1<string> AdditionalCacheParameters { get; public set; }
    [CompilerGeneratedAttribute]
public ApiIds get_ApiId();
    [CompilerGeneratedAttribute]
public void set_ApiId(ApiIds value);
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_UserProvidedCorrelationId();
    [CompilerGeneratedAttribute]
public void set_UserProvidedCorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_UseCorrelationIdFromUser();
    [CompilerGeneratedAttribute]
public void set_UseCorrelationIdFromUser(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtraQueryParameters();
    [CompilerGeneratedAttribute]
public void set_ExtraQueryParameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
    [CompilerGeneratedAttribute]
public AuthorityInfo get_AuthorityOverride();
    [CompilerGeneratedAttribute]
public void set_AuthorityOverride(AuthorityInfo value);
    [CompilerGeneratedAttribute]
public IAuthenticationScheme get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
public void set_AuthenticationScheme(IAuthenticationScheme value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtraHttpHeaders();
    [CompilerGeneratedAttribute]
public void set_ExtraHttpHeaders(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public PoPAuthenticationConfiguration get_PopAuthenticationConfiguration();
    [CompilerGeneratedAttribute]
public void set_PopAuthenticationConfiguration(PoPAuthenticationConfiguration value);
    [CompilerGeneratedAttribute]
public Func`2<OnBeforeTokenRequestData, Task> get_OnBeforeTokenRequestHandler();
    [CompilerGeneratedAttribute]
internal void set_OnBeforeTokenRequestHandler(Func`2<OnBeforeTokenRequestData, Task> value);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_MtlsCertificate();
    [CompilerGeneratedAttribute]
internal void set_MtlsCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public List`1<string> get_AdditionalCacheParameters();
    [CompilerGeneratedAttribute]
public void set_AdditionalCacheParameters(List`1<string> value);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenForClientParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    public bool ForceRefresh { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenForManagedIdentityParameters : object {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    public bool ForceRefresh { get; public set; }
    public string Resource { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenInteractiveParameters : object {
    [CompilerGeneratedAttribute]
private Prompt <Prompt>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreUIParent <UiParent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExtraScopesToConsent>k__BackingField;
    [CompilerGeneratedAttribute]
private WebViewPreference <UseEmbeddedWebView>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private ICustomWebUi <CustomWebUi>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeVerifier>k__BackingField;
    public Prompt Prompt { get; public set; }
    public CoreUIParent UiParent { get; }
    public IEnumerable`1<string> ExtraScopesToConsent { get; public set; }
    public WebViewPreference UseEmbeddedWebView { get; public set; }
    public string LoginHint { get; public set; }
    public IAccount Account { get; public set; }
    public ICustomWebUi CustomWebUi { get; public set; }
    public string CodeVerifier { get; public set; }
    [CompilerGeneratedAttribute]
public Prompt get_Prompt();
    [CompilerGeneratedAttribute]
public void set_Prompt(Prompt value);
    [CompilerGeneratedAttribute]
public CoreUIParent get_UiParent();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExtraScopesToConsent();
    [CompilerGeneratedAttribute]
public void set_ExtraScopesToConsent(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public WebViewPreference get_UseEmbeddedWebView();
    [CompilerGeneratedAttribute]
public void set_UseEmbeddedWebView(WebViewPreference value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public ICustomWebUi get_CustomWebUi();
    [CompilerGeneratedAttribute]
public void set_CustomWebUi(ICustomWebUi value);
    [CompilerGeneratedAttribute]
public string get_CodeVerifier();
    [CompilerGeneratedAttribute]
public void set_CodeVerifier(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenOnBehalfOfParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private UserAssertion <UserAssertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongRunningOboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchInCacheForLongRunningObo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    public UserAssertion UserAssertion { get; public set; }
    public string LongRunningOboCacheKey { get; public set; }
    public bool SearchInCacheForLongRunningObo { get; public set; }
    public bool ForceRefresh { get; public set; }
    [CompilerGeneratedAttribute]
public UserAssertion get_UserAssertion();
    [CompilerGeneratedAttribute]
public void set_UserAssertion(UserAssertion value);
    [CompilerGeneratedAttribute]
public string get_LongRunningOboCacheKey();
    [CompilerGeneratedAttribute]
public void set_LongRunningOboCacheKey(string value);
    [CompilerGeneratedAttribute]
public bool get_SearchInCacheForLongRunningObo();
    [CompilerGeneratedAttribute]
public void set_SearchInCacheForLongRunningObo(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenSilentParameters : object {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SendX5C>k__BackingField;
    public bool ForceRefresh { get; public set; }
    public string LoginHint { get; public set; }
    public IAccount Account { get; public set; }
    public Nullable`1<bool> SendX5C { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(Nullable`1<bool> value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenWithDeviceCodeParameters : object {
    [CompilerGeneratedAttribute]
private Func`2<DeviceCodeResult, Task> <DeviceCodeResultCallback>k__BackingField;
    public Func`2<DeviceCodeResult, Task> DeviceCodeResultCallback { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<DeviceCodeResult, Task> get_DeviceCodeResultCallback();
    [CompilerGeneratedAttribute]
public void set_DeviceCodeResultCallback(Func`2<DeviceCodeResult, Task> value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.GetAuthorizationRequestUrlParameters : object {
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExtraScopesToConsent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyValuePair`2<string, string>> <CcsRoutingHint>k__BackingField;
    [CompilerGeneratedAttribute]
private Prompt <Prompt>k__BackingField;
    public string RedirectUri { get; public set; }
    public IAccount Account { get; public set; }
    public IEnumerable`1<string> ExtraScopesToConsent { get; public set; }
    public string LoginHint { get; public set; }
    public string CodeVerifier { get; public set; }
    public Nullable`1<KeyValuePair`2<string, string>> CcsRoutingHint { get; public set; }
    public Prompt Prompt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExtraScopesToConsent();
    [CompilerGeneratedAttribute]
public void set_ExtraScopesToConsent(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public string get_CodeVerifier();
    [CompilerGeneratedAttribute]
public void set_CodeVerifier(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyValuePair`2<string, string>> get_CcsRoutingHint();
    [CompilerGeneratedAttribute]
public void set_CcsRoutingHint(Nullable`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
public Prompt get_Prompt();
    [CompilerGeneratedAttribute]
public void set_Prompt(Prompt value);
    public AcquireTokenInteractiveParameters ToInteractiveParameters();
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal interface Microsoft.Identity.Client.ApiConfig.Parameters.IAcquireTokenParameters {
    public abstract virtual void LogParameters(ILoggerAdapter logger);
}
internal enum Microsoft.Identity.Client.ApiConfig.Parameters.WebViewPreference : Enum {
    public int value__;
    public static WebViewPreference NotSpecified;
    public static WebViewPreference Embedded;
    public static WebViewPreference System;
}
public class Microsoft.Identity.Client.AppConfig.ManagedIdentityId : object {
    [CompilerGeneratedAttribute]
private string <UserAssignedId>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedIdentityIdType <IdType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserAssigned>k__BackingField;
    [CompilerGeneratedAttribute]
private static ManagedIdentityId <SystemAssigned>k__BackingField;
    internal string UserAssignedId { get; private set; }
    internal ManagedIdentityIdType IdType { get; }
    internal bool IsUserAssigned { get; }
    public static ManagedIdentityId SystemAssigned { get; }
    private ManagedIdentityId(ManagedIdentityIdType idType);
    private static ManagedIdentityId();
    [CompilerGeneratedAttribute]
internal string get_UserAssignedId();
    [CompilerGeneratedAttribute]
private void set_UserAssignedId(string value);
    [CompilerGeneratedAttribute]
internal ManagedIdentityIdType get_IdType();
    [CompilerGeneratedAttribute]
internal bool get_IsUserAssigned();
    [CompilerGeneratedAttribute]
public static ManagedIdentityId get_SystemAssigned();
    public static ManagedIdentityId WithUserAssignedClientId(string clientId);
    public static ManagedIdentityId WithUserAssignedResourceId(string resourceId);
    public static ManagedIdentityId WithUserAssignedObjectId(string objectId);
}
internal enum Microsoft.Identity.Client.AppConfig.ManagedIdentityIdType : Enum {
    public int value__;
    public static ManagedIdentityIdType SystemAssigned;
    public static ManagedIdentityIdType ClientId;
    public static ManagedIdentityIdType ResourceId;
    public static ManagedIdentityIdType ObjectId;
}
internal enum Microsoft.Identity.Client.AppConfig.MsalClientType : Enum {
    public int value__;
    public static MsalClientType ConfidentialClient;
    public static MsalClientType PublicClient;
    public static MsalClientType ManagedIdentityClient;
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.AppConfig.PoPAuthenticationConfiguration : object {
    [CompilerGeneratedAttribute]
private HttpMethod <HttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IPoPCryptoProvider <PopCryptoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SignHttpRequest>k__BackingField;
    public HttpMethod HttpMethod { get; public set; }
    public string HttpHost { get; public set; }
    public string HttpPath { get; public set; }
    public IPoPCryptoProvider PopCryptoProvider { get; public set; }
    public string Nonce { get; public set; }
    public bool SignHttpRequest { get; public set; }
    public PoPAuthenticationConfiguration(HttpRequestMessage httpRequestMessage);
    public PoPAuthenticationConfiguration(Uri requestUri);
    [CompilerGeneratedAttribute]
public HttpMethod get_HttpMethod();
    [CompilerGeneratedAttribute]
public void set_HttpMethod(HttpMethod value);
    [CompilerGeneratedAttribute]
public string get_HttpHost();
    [CompilerGeneratedAttribute]
public void set_HttpHost(string value);
    [CompilerGeneratedAttribute]
public string get_HttpPath();
    [CompilerGeneratedAttribute]
public void set_HttpPath(string value);
    [CompilerGeneratedAttribute]
public IPoPCryptoProvider get_PopCryptoProvider();
    [CompilerGeneratedAttribute]
public void set_PopCryptoProvider(IPoPCryptoProvider value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
public void set_Nonce(string value);
    [CompilerGeneratedAttribute]
public bool get_SignHttpRequest();
    [CompilerGeneratedAttribute]
public void set_SignHttpRequest(bool value);
}
public abstract class Microsoft.Identity.Client.ApplicationBase : object {
    internal static string DefaultAuthority;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    internal IServiceBundle ServiceBundle { get; }
    internal ApplicationBase(ApplicationConfiguration config);
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApplicationBase/<CreateRequestParametersAsync>d__5")]
internal virtual Task`1<AuthenticationRequestParameters> CreateRequestParametersAsync(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache);
    internal static void GuardMobileFrameworks();
}
internal class Microsoft.Identity.Client.ApplicationConfiguration : object {
    private string _clientName;
    private string _clientVersion;
    [CompilerGeneratedAttribute]
private Func`1<object> <ParentActivityOrWindowFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IosKeychainSecurityGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBrokerEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWebviewSsoPolicyEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private BrokerOptions <BrokerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> <BrokerCreatorFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IWebUIFactory> <WebUiFactoryCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KerberosServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private KerberosTicketContainer <TicketContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryConfig <TelemetryConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpManager <HttpManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlatformProxy <PlatformProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheOptions <AccessorOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Authority <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePiiLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IMsalHttpClientFactory <HttpClientFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedTokenLifetimeEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private LogCallback <LoggingCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraQueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRecommendedDefaultRedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExperimentalFeaturesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ClientCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendX5C>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyCacheCompatibilityEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheSynchronizationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MultiCloudSupportEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetryOnServerErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ManagedIdentityId <ManagedIdentityId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsManagedIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfidentialClient>k__BackingField;
    public Func`2<AppTokenProviderParameters, Task`1<AppTokenProviderResult>> AppTokenProvider;
    [CompilerGeneratedAttribute]
private IClientCredential <ClientCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AzureRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceDiscoveryResponse <CustomInstanceDiscoveryMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CustomInstanceDiscoveryMetadataUri>k__BackingField;
    [CompilerGeneratedAttribute]
private AadAuthorityAudience <AadAuthorityAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureCloudInstance <AzureCloudInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAuthority>k__BackingField;
    [CompilerGeneratedAttribute]
private ILegacyCachePersistence <UserTokenLegacyCachePersistenceForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <UserTokenCacheInternalForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <AppTokenCacheInternalForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeviceAuthManager <DeviceAuthManagerForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstanceDiscoveryEnabled>k__BackingField;
    public string ClientName { get; internal set; }
    public string ClientVersion { get; internal set; }
    public Func`1<object> ParentActivityOrWindowFunc { get; internal set; }
    public string IosKeychainSecurityGroup { get; internal set; }
    public bool IsBrokerEnabled { get; internal set; }
    public bool IsWebviewSsoPolicyEnabled { get; internal set; }
    public BrokerOptions BrokerOptions { get; public set; }
    public Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> BrokerCreatorFunc { get; public set; }
    public Func`1<IWebUIFactory> WebUiFactoryCreator { get; public set; }
    public string KerberosServicePrincipalName { get; public set; }
    public KerberosTicketContainer TicketContainer { get; public set; }
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.")]
[EditorBrowsableAttribute("1")]
public ITelemetryConfig TelemetryConfig { get; internal set; }
    public IHttpManager HttpManager { get; internal set; }
    public IPlatformProxy PlatformProxy { get; internal set; }
    public CacheOptions AccessorOptions { get; public set; }
    public Authority Authority { get; internal set; }
    public string ClientId { get; internal set; }
    public string RedirectUri { get; internal set; }
    public bool EnablePiiLogging { get; internal set; }
    public LogLevel LogLevel { get; internal set; }
    public bool IsDefaultPlatformLoggingEnabled { get; internal set; }
    public IMsalHttpClientFactory HttpClientFactory { get; internal set; }
    public bool IsExtendedTokenLifetimeEnabled { get; public set; }
    public LogCallback LoggingCallback { get; internal set; }
    public IIdentityLogger IdentityLogger { get; internal set; }
    public string Component { get; internal set; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; internal set; }
    public bool UseRecommendedDefaultRedirectUri { get; internal set; }
    public bool ExperimentalFeaturesEnabled { get; public set; }
    public IEnumerable`1<string> ClientCapabilities { get; public set; }
    public bool SendX5C { get; internal set; }
    public bool LegacyCacheCompatibilityEnabled { get; internal set; }
    public bool CacheSynchronizationEnabled { get; internal set; }
    public bool MultiCloudSupportEnabled { get; public set; }
    public bool RetryOnServerErrors { get; public set; }
    public ManagedIdentityId ManagedIdentityId { get; internal set; }
    public bool IsManagedIdentity { get; }
    public bool IsConfidentialClient { get; }
    public bool IsPublicClient { get; }
    public IClientCredential ClientCredential { get; internal set; }
    public string ClientSecret { get; }
    public X509Certificate2 ClientCredentialCertificate { get; }
    public string AzureRegion { get; public set; }
    public string TenantId { get; internal set; }
    public InstanceDiscoveryResponse CustomInstanceDiscoveryMetadata { get; public set; }
    public Uri CustomInstanceDiscoveryMetadataUri { get; public set; }
    public AadAuthorityAudience AadAuthorityAudience { get; public set; }
    public AzureCloudInstance AzureCloudInstance { get; public set; }
    public string Instance { get; public set; }
    public bool ValidateAuthority { get; public set; }
    public ILegacyCachePersistence UserTokenLegacyCachePersistenceForTest { get; public set; }
    public ITokenCacheInternal UserTokenCacheInternalForTest { get; public set; }
    public ITokenCacheInternal AppTokenCacheInternalForTest { get; public set; }
    public IDeviceAuthManager DeviceAuthManagerForTest { get; public set; }
    public bool IsInstanceDiscoveryEnabled { get; internal set; }
    public ApplicationConfiguration(MsalClientType applicationType);
    public sealed virtual string get_ClientName();
    internal void set_ClientName(string value);
    public sealed virtual string get_ClientVersion();
    internal void set_ClientVersion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<object> get_ParentActivityOrWindowFunc();
    [CompilerGeneratedAttribute]
internal void set_ParentActivityOrWindowFunc(Func`1<object> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_IosKeychainSecurityGroup();
    [CompilerGeneratedAttribute]
internal void set_IosKeychainSecurityGroup(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsBrokerEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsBrokerEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWebviewSsoPolicyEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsWebviewSsoPolicyEnabled(bool value);
    [CompilerGeneratedAttribute]
public BrokerOptions get_BrokerOptions();
    [CompilerGeneratedAttribute]
public void set_BrokerOptions(BrokerOptions value);
    [CompilerGeneratedAttribute]
public Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> get_BrokerCreatorFunc();
    [CompilerGeneratedAttribute]
public void set_BrokerCreatorFunc(Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> value);
    [CompilerGeneratedAttribute]
public Func`1<IWebUIFactory> get_WebUiFactoryCreator();
    [CompilerGeneratedAttribute]
public void set_WebUiFactoryCreator(Func`1<IWebUIFactory> value);
    [CompilerGeneratedAttribute]
public string get_KerberosServicePrincipalName();
    [CompilerGeneratedAttribute]
public void set_KerberosServicePrincipalName(string value);
    [CompilerGeneratedAttribute]
public KerberosTicketContainer get_TicketContainer();
    [CompilerGeneratedAttribute]
public void set_TicketContainer(KerberosTicketContainer value);
    [CompilerGeneratedAttribute]
public sealed virtual ITelemetryConfig get_TelemetryConfig();
    [CompilerGeneratedAttribute]
internal void set_TelemetryConfig(ITelemetryConfig value);
    [CompilerGeneratedAttribute]
public IHttpManager get_HttpManager();
    [CompilerGeneratedAttribute]
internal void set_HttpManager(IHttpManager value);
    [CompilerGeneratedAttribute]
public IPlatformProxy get_PlatformProxy();
    [CompilerGeneratedAttribute]
internal void set_PlatformProxy(IPlatformProxy value);
    [CompilerGeneratedAttribute]
public CacheOptions get_AccessorOptions();
    [CompilerGeneratedAttribute]
public void set_AccessorOptions(CacheOptions value);
    [CompilerGeneratedAttribute]
public Authority get_Authority();
    [CompilerGeneratedAttribute]
internal void set_Authority(Authority value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientId();
    [CompilerGeneratedAttribute]
internal void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RedirectUri();
    [CompilerGeneratedAttribute]
internal void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnablePiiLogging();
    [CompilerGeneratedAttribute]
internal void set_EnablePiiLogging(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
internal void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsDefaultPlatformLoggingEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMsalHttpClientFactory get_HttpClientFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpClientFactory(IMsalHttpClientFactory value);
    [CompilerGeneratedAttribute]
public bool get_IsExtendedTokenLifetimeEnabled();
    [CompilerGeneratedAttribute]
public void set_IsExtendedTokenLifetimeEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual LogCallback get_LoggingCallback();
    [CompilerGeneratedAttribute]
internal void set_LoggingCallback(LogCallback value);
    [CompilerGeneratedAttribute]
public IIdentityLogger get_IdentityLogger();
    [CompilerGeneratedAttribute]
internal void set_IdentityLogger(IIdentityLogger value);
    [CompilerGeneratedAttribute]
public string get_Component();
    [CompilerGeneratedAttribute]
internal void set_Component(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtraQueryParameters();
    [CompilerGeneratedAttribute]
internal void set_ExtraQueryParameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_UseRecommendedDefaultRedirectUri();
    [CompilerGeneratedAttribute]
internal void set_UseRecommendedDefaultRedirectUri(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExperimentalFeaturesEnabled();
    [CompilerGeneratedAttribute]
public void set_ExperimentalFeaturesEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_ClientCapabilities();
    [CompilerGeneratedAttribute]
public void set_ClientCapabilities(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_SendX5C();
    [CompilerGeneratedAttribute]
internal void set_SendX5C(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LegacyCacheCompatibilityEnabled();
    [CompilerGeneratedAttribute]
internal void set_LegacyCacheCompatibilityEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheSynchronizationEnabled();
    [CompilerGeneratedAttribute]
internal void set_CacheSynchronizationEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_MultiCloudSupportEnabled();
    [CompilerGeneratedAttribute]
public void set_MultiCloudSupportEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_RetryOnServerErrors();
    [CompilerGeneratedAttribute]
public void set_RetryOnServerErrors(bool value);
    [CompilerGeneratedAttribute]
public ManagedIdentityId get_ManagedIdentityId();
    [CompilerGeneratedAttribute]
internal void set_ManagedIdentityId(ManagedIdentityId value);
    [CompilerGeneratedAttribute]
public bool get_IsManagedIdentity();
    [CompilerGeneratedAttribute]
public bool get_IsConfidentialClient();
    public bool get_IsPublicClient();
    [CompilerGeneratedAttribute]
public IClientCredential get_ClientCredential();
    [CompilerGeneratedAttribute]
internal void set_ClientCredential(IClientCredential value);
    public sealed virtual string get_ClientSecret();
    public sealed virtual X509Certificate2 get_ClientCredentialCertificate();
    [CompilerGeneratedAttribute]
public string get_AzureRegion();
    [CompilerGeneratedAttribute]
public void set_AzureRegion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public InstanceDiscoveryResponse get_CustomInstanceDiscoveryMetadata();
    [CompilerGeneratedAttribute]
public void set_CustomInstanceDiscoveryMetadata(InstanceDiscoveryResponse value);
    [CompilerGeneratedAttribute]
public Uri get_CustomInstanceDiscoveryMetadataUri();
    [CompilerGeneratedAttribute]
public void set_CustomInstanceDiscoveryMetadataUri(Uri value);
    [CompilerGeneratedAttribute]
public AadAuthorityAudience get_AadAuthorityAudience();
    [CompilerGeneratedAttribute]
public void set_AadAuthorityAudience(AadAuthorityAudience value);
    [CompilerGeneratedAttribute]
public AzureCloudInstance get_AzureCloudInstance();
    [CompilerGeneratedAttribute]
public void set_AzureCloudInstance(AzureCloudInstance value);
    [CompilerGeneratedAttribute]
public string get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(string value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAuthority();
    [CompilerGeneratedAttribute]
public void set_ValidateAuthority(bool value);
    [CompilerGeneratedAttribute]
public ILegacyCachePersistence get_UserTokenLegacyCachePersistenceForTest();
    [CompilerGeneratedAttribute]
public void set_UserTokenLegacyCachePersistenceForTest(ILegacyCachePersistence value);
    [CompilerGeneratedAttribute]
public ITokenCacheInternal get_UserTokenCacheInternalForTest();
    [CompilerGeneratedAttribute]
public void set_UserTokenCacheInternalForTest(ITokenCacheInternal value);
    [CompilerGeneratedAttribute]
public ITokenCacheInternal get_AppTokenCacheInternalForTest();
    [CompilerGeneratedAttribute]
public void set_AppTokenCacheInternalForTest(ITokenCacheInternal value);
    [CompilerGeneratedAttribute]
public IDeviceAuthManager get_DeviceAuthManagerForTest();
    [CompilerGeneratedAttribute]
public void set_DeviceAuthManagerForTest(IDeviceAuthManager value);
    [CompilerGeneratedAttribute]
public bool get_IsInstanceDiscoveryEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsInstanceDiscoveryEnabled(bool value);
}
public abstract class Microsoft.Identity.Client.ApplicationOptions : BaseApplicationOptions {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private AadAuthorityAudience <AadAuthorityAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureCloudInstance <AzureCloudInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ClientCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyCacheCompatibilityEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KerberosServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private KerberosTicketContainer <TicketContainer>k__BackingField;
    public string ClientId { get; public set; }
    public string TenantId { get; public set; }
    public AadAuthorityAudience AadAuthorityAudience { get; public set; }
    public string Instance { get; public set; }
    public AzureCloudInstance AzureCloudInstance { get; public set; }
    public string RedirectUri { get; public set; }
    public string ClientName { get; public set; }
    public string ClientVersion { get; public set; }
    public IEnumerable`1<string> ClientCapabilities { get; public set; }
    public bool LegacyCacheCompatibilityEnabled { get; public set; }
    public string KerberosServicePrincipalName { get; public set; }
    public KerberosTicketContainer TicketContainer { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public AadAuthorityAudience get_AadAuthorityAudience();
    [CompilerGeneratedAttribute]
public void set_AadAuthorityAudience(AadAuthorityAudience value);
    [CompilerGeneratedAttribute]
public string get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(string value);
    [CompilerGeneratedAttribute]
public AzureCloudInstance get_AzureCloudInstance();
    [CompilerGeneratedAttribute]
public void set_AzureCloudInstance(AzureCloudInstance value);
    [CompilerGeneratedAttribute]
public string get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
public void set_ClientVersion(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ClientCapabilities();
    [CompilerGeneratedAttribute]
public void set_ClientCapabilities(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_LegacyCacheCompatibilityEnabled();
    [CompilerGeneratedAttribute]
public void set_LegacyCacheCompatibilityEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_KerberosServicePrincipalName();
    [CompilerGeneratedAttribute]
public void set_KerberosServicePrincipalName(string value);
    [CompilerGeneratedAttribute]
public KerberosTicketContainer get_TicketContainer();
    [CompilerGeneratedAttribute]
public void set_TicketContainer(KerberosTicketContainer value);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.AssertionRequestOptions : object {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    public CancellationToken CancellationToken { get; public set; }
    public string ClientID { get; public set; }
    public string TokenEndpoint { get; public set; }
    public string Claims { get; public set; }
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public string get_ClientID();
    [CompilerGeneratedAttribute]
public void set_ClientID(string value);
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
}
[CLSCompliantAttribute("False")]
public static class Microsoft.Identity.Client.AuthenticationContinuationHelper : object {
    [CompilerGeneratedAttribute]
private static ILoggerAdapter <LastRequestLogger>k__BackingField;
    internal static ILoggerAdapter LastRequestLogger { get; internal set; }
    [CompilerGeneratedAttribute]
internal static ILoggerAdapter get_LastRequestLogger();
    [CompilerGeneratedAttribute]
internal static void set_LastRequestLogger(ILoggerAdapter value);
    public static bool SetAuthenticationContinuationEventArgs(NSUrl url);
    public static bool IsBrokerResponse(string sourceApplication);
    public static void SetBrokerContinuationEventArgs(NSUrl url);
}
public class Microsoft.Identity.Client.AuthenticationHeaderParser : object {
    private static Lazy`1<IMsalHttpClientFactory> _httpClientFactory;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<WwwAuthenticateParameters> <WwwAuthenticateParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationInfoParameters <AuthenticationInfoParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopNonce>k__BackingField;
    public IReadOnlyList`1<WwwAuthenticateParameters> WwwAuthenticateParameters { get; private set; }
    public AuthenticationInfoParameters AuthenticationInfoParameters { get; private set; }
    public string PopNonce { get; private set; }
    private static AuthenticationHeaderParser();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<WwwAuthenticateParameters> get_WwwAuthenticateParameters();
    [CompilerGeneratedAttribute]
private void set_WwwAuthenticateParameters(IReadOnlyList`1<WwwAuthenticateParameters> value);
    [CompilerGeneratedAttribute]
public AuthenticationInfoParameters get_AuthenticationInfoParameters();
    [CompilerGeneratedAttribute]
private void set_AuthenticationInfoParameters(AuthenticationInfoParameters value);
    [CompilerGeneratedAttribute]
public string get_PopNonce();
    [CompilerGeneratedAttribute]
private void set_PopNonce(string value);
    public static Task`1<AuthenticationHeaderParser> ParseAuthenticationHeadersAsync(string resourceUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.AuthenticationHeaderParser/<ParseAuthenticationHeadersAsync>d__14")]
public static Task`1<AuthenticationHeaderParser> ParseAuthenticationHeadersAsync(string resourceUri, HttpClient httpClient, CancellationToken cancellationToken);
    public static AuthenticationHeaderParser ParseAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders);
    internal static HttpClient GetHttpClient();
    internal static KeyValuePair`2<string, string> CreateKeyValuePair(string paramValue, string authScheme);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Identity.Client.AuthenticationInfoParameters : object {
    private static string AuthenticationInfoKey;
    [CompilerGeneratedAttribute]
private string <NextNonce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <RawParameters>k__BackingField;
    public string NextNonce { get; private set; }
    public string Item { get; }
    internal IDictionary`2<string, string> RawParameters { get; private set; }
    [CompilerGeneratedAttribute]
public string get_NextNonce();
    [CompilerGeneratedAttribute]
private void set_NextNonce(string value);
    public string get_Item(string key);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_RawParameters();
    [CompilerGeneratedAttribute]
private void set_RawParameters(IDictionary`2<string, string> value);
    public static AuthenticationInfoParameters CreateFromResponseHeaders(HttpResponseHeaders httpResponseHeaders);
}
public class Microsoft.Identity.Client.AuthenticationResult : object {
    private IAuthenticationScheme _authenticationScheme;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedLifeTimeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExtendedExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpaAuthCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <AdditionalResponseParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiEvent <ApiEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationResultMetadata <AuthenticationResultMetadata>k__BackingField;
    public string AccessToken { get; }
    [ObsoleteAttribute("This feature has been deprecated", "False")]
[EditorBrowsableAttribute("1")]
public bool IsExtendedLifeTimeToken { get; }
    public string UniqueId { get; }
    public DateTimeOffset ExpiresOn { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This feature has been deprecated", "False")]
public DateTimeOffset ExtendedExpiresOn { get; }
    public string TenantId { get; }
    public IAccount Account { get; }
    public string IdToken { get; }
    public IEnumerable`1<string> Scopes { get; }
    public Guid CorrelationId { get; }
    public string TokenType { get; }
    public string SpaAuthCode { get; }
    public IReadOnlyDictionary`2<string, string> AdditionalResponseParameters { get; }
    public ClaimsPrincipal ClaimsPrincipal { get; }
    internal ApiEvent ApiEvent { get; }
    public AuthenticationResultMetadata AuthenticationResultMetadata { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use Account instead (See https://aka.ms/msal-net-2-released)", "True")]
public IUser User { get; }
    public AuthenticationResult(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, IAccount account, string idToken, IEnumerable`1<string> scopes, Guid correlationId, string tokenType, AuthenticationResultMetadata authenticationResultMetadata, ClaimsPrincipal claimsPrincipal, string spaAuthCode, IReadOnlyDictionary`2<string, string> additionalResponseParameters);
    [EditorBrowsableAttribute("1")]
public AuthenticationResult(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, IAccount account, string idToken, IEnumerable`1<string> scopes, Guid correlationId, AuthenticationResultMetadata authenticationResultMetadata, string tokenType);
    internal AuthenticationResult(MsalAccessTokenCacheItem msalAccessTokenCacheItem, MsalIdTokenCacheItem msalIdTokenCacheItem, IAuthenticationScheme authenticationScheme, Guid correlationID, TokenSource tokenSource, ApiEvent apiEvent, Account account, string spaAuthCode, IReadOnlyDictionary`2<string, string> additionalResponseParameters);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public bool get_IsExtendedLifeTimeToken();
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExtendedExpiresOn();
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public string get_IdToken();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public string get_SpaAuthCode();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_AdditionalResponseParameters();
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
internal ApiEvent get_ApiEvent();
    [CompilerGeneratedAttribute]
public AuthenticationResultMetadata get_AuthenticationResultMetadata();
    public string CreateAuthorizationHeader();
    public IUser get_User();
}
public class Microsoft.Identity.Client.AuthenticationResultMetadata : object {
    [CompilerGeneratedAttribute]
private TokenSource <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationTotalInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInCacheInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInHttpInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <RefreshOn>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheRefreshReason <CacheRefreshReason>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheLevel <CacheLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private RegionDetails <RegionDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Telemetry>k__BackingField;
    public TokenSource TokenSource { get; }
    public string TokenEndpoint { get; public set; }
    public long DurationTotalInMs { get; public set; }
    public long DurationInCacheInMs { get; public set; }
    public long DurationInHttpInMs { get; public set; }
    public Nullable`1<DateTimeOffset> RefreshOn { get; public set; }
    public CacheRefreshReason CacheRefreshReason { get; public set; }
    public CacheLevel CacheLevel { get; public set; }
    public RegionDetails RegionDetails { get; public set; }
    public string Telemetry { get; public set; }
    public AuthenticationResultMetadata(TokenSource tokenSource);
    [CompilerGeneratedAttribute]
public TokenSource get_TokenSource();
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public long get_DurationTotalInMs();
    [CompilerGeneratedAttribute]
public void set_DurationTotalInMs(long value);
    [CompilerGeneratedAttribute]
public long get_DurationInCacheInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInCacheInMs(long value);
    [CompilerGeneratedAttribute]
public long get_DurationInHttpInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInHttpInMs(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_RefreshOn();
    [CompilerGeneratedAttribute]
public void set_RefreshOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public CacheRefreshReason get_CacheRefreshReason();
    [CompilerGeneratedAttribute]
public void set_CacheRefreshReason(CacheRefreshReason value);
    [CompilerGeneratedAttribute]
public CacheLevel get_CacheLevel();
    [CompilerGeneratedAttribute]
public void set_CacheLevel(CacheLevel value);
    [CompilerGeneratedAttribute]
public RegionDetails get_RegionDetails();
    [CompilerGeneratedAttribute]
public void set_RegionDetails(RegionDetails value);
    [CompilerGeneratedAttribute]
public string get_Telemetry();
    [CompilerGeneratedAttribute]
public void set_Telemetry(string value);
}
internal class Microsoft.Identity.Client.AuthorityInfo : object {
    [CompilerGeneratedAttribute]
private Uri <CanonicalAuthority>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorityType <AuthorityType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserRealmUriPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAuthority>k__BackingField;
    public string Host { get; }
    public Uri CanonicalAuthority { get; }
    internal AuthorityType AuthorityType { get; }
    public string UserRealmUriPrefix { get; }
    public bool ValidateAuthority { get; }
    internal bool IsInstanceDiscoverySupported { get; }
    internal bool IsWsTrustFlowSupported { get; }
    internal bool CanBeTenanted { get; }
    internal bool IsClientInfoSupported { get; }
    internal bool IsSha2CredentialSupported { get; }
    internal bool IsDefaultAuthority { get; }
    public AuthorityInfo(AuthorityType authorityType, string authority, bool validateAuthority);
    public AuthorityInfo(AuthorityType authorityType, Uri authorityUri, bool validateAuthority);
    public AuthorityInfo(AuthorityInfo other);
    private AuthorityInfo(Uri canonicalAuthority, AuthorityType authorityType, string userRealmUriPrefix, bool validateAuthority);
    public string get_Host();
    [CompilerGeneratedAttribute]
public Uri get_CanonicalAuthority();
    [CompilerGeneratedAttribute]
internal AuthorityType get_AuthorityType();
    [CompilerGeneratedAttribute]
public string get_UserRealmUriPrefix();
    [CompilerGeneratedAttribute]
public bool get_ValidateAuthority();
    internal bool get_IsInstanceDiscoverySupported();
    internal bool get_IsWsTrustFlowSupported();
    internal bool get_CanBeTenanted();
    internal bool get_IsClientInfoSupported();
    internal bool get_IsSha2CredentialSupported();
    internal static AuthorityInfo FromAuthorityUri(string authorityUri, bool validateAuthority);
    private static Uri TransformIfCiamAuthority(Uri authorityUri);
    internal static AuthorityInfo FromAadAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(string cloudInstanceUri, string tenant, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority);
    internal static AuthorityInfo FromAdfsAuthority(string authorityUri, bool validateAuthority);
    internal static AuthorityInfo FromB2CAuthority(string authorityUri);
    internal static AuthorityInfo FromGenericAuthority(string authorityUri);
    internal static string GetCloudUrl(AzureCloudInstance azureCloudInstance);
    internal static string GetAadAuthorityAudienceValue(AadAuthorityAudience authorityAudience, string tenantId);
    internal static string CanonicalizeAuthorityUri(string uri);
    internal bool get_IsDefaultAuthority();
    internal Authority CreateAuthority();
    private static Uri ValidateAndCreateAuthorityUri(string authority, Nullable`1<AuthorityType> authorityType);
    private static string GetAuthorityUri(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, string tenantId);
    internal static string GetFirstPathSegment(Uri authority);
    internal static string GetSecondPathSegment(Uri authority);
    private static AuthorityType GetAuthorityType(Uri authorityUri);
    private static bool IsCiamAuthority(Uri authorityUri);
    private static String[] GetPathSegments(string absolutePath);
}
internal enum Microsoft.Identity.Client.AuthorityType : Enum {
    public int value__;
    public static AuthorityType Aad;
    public static AuthorityType Adfs;
    public static AuthorityType B2C;
    public static AuthorityType Dsts;
    public static AuthorityType Generic;
    public static AuthorityType Ciam;
}
internal class Microsoft.Identity.Client.AuthScheme.AuthSchemeHelper : object {
    public static bool StoreTokenTypeInCacheKey(string tokenType);
}
internal class Microsoft.Identity.Client.AuthScheme.Bearer.BearerAuthenticationScheme : object {
    internal static string BearerTokenType;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string AccessTokenType { get; }
    public string KeyId { get; }
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_AccessTokenType();
    public sealed virtual string get_KeyId();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetTokenRequestParams();
}
internal interface Microsoft.Identity.Client.AuthScheme.IAuthenticationScheme {
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string KeyId { get; }
    public string AccessTokenType { get; }
    public abstract virtual TokenType get_TelemetryTokenType();
    public abstract virtual string get_AuthorizationHeaderPrefix();
    public abstract virtual IReadOnlyDictionary`2<string, string> GetTokenRequestParams();
    public abstract virtual string get_KeyId();
    public abstract virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public abstract virtual string get_AccessTokenType();
}
internal class Microsoft.Identity.Client.AuthScheme.PoP.InMemoryCryptoProvider : object {
    internal static int RsaKeySize;
    private RSA _signingKey;
    [CompilerGeneratedAttribute]
private string <CannonicalPublicKeyJwk>k__BackingField;
    public string CannonicalPublicKeyJwk { get; private set; }
    public string CryptographicAlgorithm { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_CannonicalPublicKeyJwk();
    [CompilerGeneratedAttribute]
private void set_CannonicalPublicKeyJwk(string value);
    public sealed virtual string get_CryptographicAlgorithm();
    private void InitializeSigningKey();
    public sealed virtual Byte[] Sign(Byte[] payload);
    private static string ComputeCanonicalJwk(RSAParameters rsaPublicKey);
    internal RSAParameters GetPublicKeyParameters();
}
public interface Microsoft.Identity.Client.AuthScheme.PoP.IPoPCryptoProvider {
    public string CannonicalPublicKeyJwk { get; }
    public string CryptographicAlgorithm { get; }
    public abstract virtual string get_CannonicalPublicKeyJwk();
    public abstract virtual string get_CryptographicAlgorithm();
    public abstract virtual Byte[] Sign(Byte[] data);
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.JsonWebAlgorithmsKeyTypes : object {
    public static string EllipticCurve;
    public static string RSA;
    public static string Octet;
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.JsonWebKeyParameterNames : object {
    public static string Alg;
    public static string Crv;
    public static string D;
    public static string DP;
    public static string DQ;
    public static string E;
    public static string K;
    public static string KeyOps;
    public static string Keys;
    public static string Kid;
    public static string Kty;
    public static string N;
    public static string Oth;
    public static string P;
    public static string Q;
    public static string R;
    public static string T;
    public static string QI;
    public static string Use;
    public static string X5c;
    public static string X5t;
    public static string X5tS256;
    public static string X5u;
    public static string X;
    public static string Y;
    public static string EC;
}
internal class Microsoft.Identity.Client.AuthScheme.PoP.PopAuthenticationScheme : object {
    private PoPAuthenticationConfiguration _popAuthenticationConfiguration;
    private IPoPCryptoProvider _popCryptoProvider;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string AccessTokenType { get; }
    public string KeyId { get; }
    public PopAuthenticationScheme(PoPAuthenticationConfiguration popAuthenticationConfiguration, IServiceBundle serviceBundle);
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_AccessTokenType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyId();
    public sealed virtual IReadOnlyDictionary`2<string, string> GetTokenRequestParams();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    private JObject CreateBody(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    private static string CreateSimpleNonce();
    private string ComputeReqCnf();
    private static Byte[] ComputeThumbprint(string canonicalJwk);
    private string CreateJWS(string payload, string header);
}
internal class Microsoft.Identity.Client.AuthScheme.PoP.PopBrokerAuthenticationScheme : object {
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string KeyId { get; }
    public string AccessTokenType { get; }
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_KeyId();
    public sealed virtual string get_AccessTokenType();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetTokenRequestParams();
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.PoPClaimTypes : object {
    public static string At;
    public static string HttpMethod;
    public static string Ts;
    public static string Host;
    public static string Path;
    public static string Query;
    public static string Cnf;
    public static string JWK;
    public static string Nonce;
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.PoPProviderFactory : object {
    private static InMemoryCryptoProvider s_currentProvider;
    private static DateTime s_providerExpiration;
    [CompilerGeneratedAttribute]
private static TimeSpan <KeyRotationInterval>k__BackingField;
    private static object s_lock;
    [CompilerGeneratedAttribute]
private static ITimeService <TimeService>k__BackingField;
    public static TimeSpan KeyRotationInterval { get; }
    internal static ITimeService TimeService { get; internal set; }
    private static PoPProviderFactory();
    [CompilerGeneratedAttribute]
public static TimeSpan get_KeyRotationInterval();
    [CompilerGeneratedAttribute]
internal static ITimeService get_TimeService();
    [CompilerGeneratedAttribute]
internal static void set_TimeService(ITimeService value);
    public static InMemoryCryptoProvider GetOrCreateProvider();
    public static void Reset();
}
internal class Microsoft.Identity.Client.AuthScheme.SSHCertificates.SSHCertAuthenticationScheme : object {
    internal static string SSHCertTokenType;
    private string _jwk;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string AccessTokenType { get; }
    public string KeyId { get; }
    public SSHCertAuthenticationScheme(string keyId, string jwk);
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_AccessTokenType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyId();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetTokenRequestParams();
}
internal enum Microsoft.Identity.Client.AuthScheme.TokenType : Enum {
    public int value__;
    public static TokenType Bearer;
    public static TokenType Pop;
    public static TokenType SshCert;
    public static TokenType External;
}
public enum Microsoft.Identity.Client.AzureCloudInstance : Enum {
    public int value__;
    public static AzureCloudInstance None;
    public static AzureCloudInstance AzurePublic;
    public static AzureCloudInstance AzureChina;
    public static AzureCloudInstance AzureGermany;
    public static AzureCloudInstance AzureUsGovernment;
}
public abstract class Microsoft.Identity.Client.BaseAbstractAcquireTokenParameterBuilder`1 : object {
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private AcquireTokenCommonParameters <CommonParameters>k__BackingField;
    internal IServiceBundle ServiceBundle { get; }
    internal AcquireTokenCommonParameters CommonParameters { get; }
    internal BaseAbstractAcquireTokenParameterBuilder`1(IServiceBundle serviceBundle);
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    [CompilerGeneratedAttribute]
internal AcquireTokenCommonParameters get_CommonParameters();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    internal abstract virtual ApiIds CalculateApiEventId();
    public Task`1<AuthenticationResult> ExecuteAsync();
    public T WithCorrelationId(Guid correlationId);
    public T WithExtraQueryParameters(Dictionary`2<string, string> extraQueryParameters);
    protected virtual void Validate();
    internal void ValidateAndCalculateApiId();
    internal void ValidateUseOfExperimentalFeature(string memberName);
}
public abstract class Microsoft.Identity.Client.BaseAbstractApplicationBuilder`1 : object {
    [CompilerGeneratedAttribute]
private ApplicationConfiguration <Config>k__BackingField;
    internal ApplicationConfiguration Config { get; }
    internal BaseAbstractApplicationBuilder`1(ApplicationConfiguration configuration);
    [CompilerGeneratedAttribute]
internal ApplicationConfiguration get_Config();
    public T WithHttpClientFactory(IMsalHttpClientFactory httpClientFactory);
    public T WithHttpClientFactory(IMsalHttpClientFactory httpClientFactory, bool retryOnceOn5xx);
    internal T WithHttpManager(IHttpManager httpManager);
    public T WithLogging(LogCallback loggingCallback, Nullable`1<LogLevel> logLevel, Nullable`1<bool> enablePiiLogging, Nullable`1<bool> enableDefaultPlatformLogging);
    public T WithLogging(IIdentityLogger identityLogger, bool enablePiiLogging);
    public T WithDebugLoggingCallback(LogLevel logLevel, bool enablePiiLogging, bool withDefaultPlatformLoggingEnabled);
    protected T WithOptions(BaseApplicationOptions applicationOptions);
    public T WithExperimentalFeatures(bool enableExperimentalFeatures);
    public T WithClientName(string clientName);
    public T WithClientVersion(string clientVersion);
    internal virtual ApplicationConfiguration BuildConfiguration();
    internal void ResolveAuthority();
    private string GetAuthorityAudience();
    private string GetAuthorityInstance();
    internal void ValidateUseOfExperimentalFeature(string memberName);
    internal static string GetValueIfNotEmpty(string original, string value);
}
public abstract class Microsoft.Identity.Client.BaseApplicationOptions : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePiiLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    public LogLevel LogLevel { get; public set; }
    public bool EnablePiiLogging { get; public set; }
    public bool IsDefaultPlatformLoggingEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public bool get_EnablePiiLogging();
    [CompilerGeneratedAttribute]
public void set_EnablePiiLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public void set_IsDefaultPlatformLoggingEnabled(bool value);
}
public class Microsoft.Identity.Client.BrokerOptions : object {
    [CompilerGeneratedAttribute]
private OperatingSystems <EnabledOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MsaPassthrough>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ListOperatingSystemAccounts>k__BackingField;
    public OperatingSystems EnabledOn { get; }
    public string Title { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool MsaPassthrough { get; public set; }
    public bool ListOperatingSystemAccounts { get; public set; }
    public BrokerOptions(OperatingSystems enabledOn);
    internal static BrokerOptions CreateFromWindowsOptions(WindowsBrokerOptions winOptions);
    [CompilerGeneratedAttribute]
public OperatingSystems get_EnabledOn();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public bool get_MsaPassthrough();
    [CompilerGeneratedAttribute]
public void set_MsaPassthrough(bool value);
    [CompilerGeneratedAttribute]
public bool get_ListOperatingSystemAccounts();
    [CompilerGeneratedAttribute]
public void set_ListOperatingSystemAccounts(bool value);
    internal bool IsBrokerEnabledOnCurrentOs();
}
internal static class Microsoft.Identity.Client.Cache.AdalCacheOperations : object {
    private static int SchemaVersion;
    private static string Delimiter;
    public static Byte[] Serialize(ILoggerAdapter logger, IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> tokenCacheDictionary);
    public static IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> Deserialize(ILoggerAdapter logger, Byte[] state);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Cache.AdalResult : object {
    [CompilerGeneratedAttribute]
private AdalUserInfo <UserInfo>k__BackingField;
    [JsonPropertyAttribute]
public AdalUserInfo UserInfo { get; internal set; }
    [CompilerGeneratedAttribute]
public AdalUserInfo get_UserInfo();
    [CompilerGeneratedAttribute]
internal void set_UserInfo(AdalUserInfo value);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Cache.AdalResultWrapper : object {
    [CompilerGeneratedAttribute]
private AdalResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceInResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAssertionHash>k__BackingField;
    [JsonPropertyAttribute]
public AdalResult Result { get; public set; }
    [JsonPropertyAttribute]
public string RawClientInfo { get; public set; }
    [JsonPropertyAttribute]
public string RefreshToken { get; public set; }
    internal bool IsMultipleResourceRefreshToken { get; }
    [JsonPropertyAttribute]
internal string ResourceInResponse { get; internal set; }
    [JsonPropertyAttribute]
public string UserAssertionHash { get; public set; }
    [CompilerGeneratedAttribute]
public AdalResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(AdalResult value);
    [CompilerGeneratedAttribute]
public string get_RawClientInfo();
    [CompilerGeneratedAttribute]
public void set_RawClientInfo(string value);
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    internal bool get_IsMultipleResourceRefreshToken();
    [CompilerGeneratedAttribute]
internal string get_ResourceInResponse();
    [CompilerGeneratedAttribute]
internal void set_ResourceInResponse(string value);
    public static AdalResultWrapper Deserialize(string serializedObject);
    public string Serialize();
    [CompilerGeneratedAttribute]
public string get_UserAssertionHash();
    [CompilerGeneratedAttribute]
public void set_UserAssertionHash(string value);
    internal AdalResultWrapper Clone();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Identity.Client.Cache.AdalTokenCacheKey : object {
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayableId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenSubjectType <TokenSubjectType>k__BackingField;
    public string Authority { get; }
    public string Resource { get; }
    public string ClientId { get; }
    public string UniqueId { get; }
    public string DisplayableId { get; }
    public TokenSubjectType TokenSubjectType { get; }
    private string DebuggerDisplay { get; }
    internal AdalTokenCacheKey(string authority, string resource, string clientId, TokenSubjectType tokenSubjectType, AdalUserInfo adalUserInfo);
    internal AdalTokenCacheKey(string authority, string resource, string clientId, TokenSubjectType tokenSubjectType, string uniqueId, string displayableId);
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public string get_DisplayableId();
    [CompilerGeneratedAttribute]
public TokenSubjectType get_TokenSubjectType();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AdalTokenCacheKey other);
    public virtual int GetHashCode();
    private bool ClientIdEquals(string otherClientId);
    private bool DisplayableIdEquals(string otherDisplayableId);
    private string get_DebuggerDisplay();
}
internal class Microsoft.Identity.Client.Cache.AdalUserForMsalEntry : object {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AdalUserInfo <UserInfo>k__BackingField;
    public string ClientId { get; }
    public string Authority { get; }
    public string ClientInfo { get; }
    public AdalUserInfo UserInfo { get; }
    public AdalUserForMsalEntry(string clientId, string authority, string clientInfo, AdalUserInfo userInfo);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
public string get_ClientInfo();
    [CompilerGeneratedAttribute]
public AdalUserInfo get_UserInfo();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Cache.AdalUserInfo : object {
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayableId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PasswordExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PasswordChangeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdentityProvider>k__BackingField;
    [JsonPropertyAttribute]
public string UniqueId { get; internal set; }
    [JsonPropertyAttribute]
public string DisplayableId { get; internal set; }
    [JsonPropertyAttribute]
public string GivenName { get; internal set; }
    [JsonPropertyAttribute]
public string FamilyName { get; internal set; }
    [JsonPropertyAttribute]
public Nullable`1<DateTimeOffset> PasswordExpiresOn { get; internal set; }
    [JsonPropertyAttribute]
public Uri PasswordChangeUrl { get; internal set; }
    [JsonPropertyAttribute]
public string IdentityProvider { get; internal set; }
    public AdalUserInfo(AdalUserInfo other);
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
internal void set_UniqueId(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayableId();
    [CompilerGeneratedAttribute]
internal void set_DisplayableId(string value);
    [CompilerGeneratedAttribute]
public string get_GivenName();
    [CompilerGeneratedAttribute]
internal void set_GivenName(string value);
    [CompilerGeneratedAttribute]
public string get_FamilyName();
    [CompilerGeneratedAttribute]
internal void set_FamilyName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PasswordExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_PasswordExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Uri get_PasswordChangeUrl();
    [CompilerGeneratedAttribute]
internal void set_PasswordChangeUrl(Uri value);
    [CompilerGeneratedAttribute]
public string get_IdentityProvider();
    [CompilerGeneratedAttribute]
internal void set_IdentityProvider(string value);
}
internal class Microsoft.Identity.Client.Cache.AdalUsersForMsal : object {
    private IEnumerable`1<AdalUserForMsalEntry> _userEntries;
    public AdalUsersForMsal(IEnumerable`1<AdalUserForMsalEntry> userEntries);
    public IDictionary`2<string, AdalUserInfo> GetUsersWithClientInfo(IEnumerable`1<string> envAliases);
    public IEnumerable`1<AdalUserInfo> GetUsersWithoutClientInfo(IEnumerable`1<string> envAliases);
    public ISet`1<string> GetAdalUserEnvironments();
}
internal enum Microsoft.Identity.Client.Cache.CacheAuthorityType : Enum {
    public int value__;
    public static CacheAuthorityType AAD;
    public static CacheAuthorityType MSA;
    public static CacheAuthorityType MSSTS;
    public static CacheAuthorityType OTHER;
}
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v3 and ADAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.Cache.CacheData : object {
    [CompilerGeneratedAttribute]
private Byte[] <AdalV3State>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <UnifiedState>k__BackingField;
    public Byte[] AdalV3State { get; public set; }
    public Byte[] UnifiedState { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_AdalV3State();
    [CompilerGeneratedAttribute]
public void set_AdalV3State(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_UnifiedState();
    [CompilerGeneratedAttribute]
public void set_UnifiedState(Byte[] value);
}
internal static class Microsoft.Identity.Client.Cache.CacheFallbackOperations : object {
    internal static string DifferentEnvError;
    internal static string DifferentAuthorityError;
    public static void WriteAdalRefreshToken(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, MsalRefreshTokenCacheItem rtItem, MsalIdTokenCacheItem idItem, string authority, string uniqueId, string scope);
    public static AdalUsersForMsal GetAllAdalUsersForMsal(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, string clientId);
    public static void RemoveAdalUser(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, string clientId, string displayableId, string accountOrUserId);
    private static void RemoveEntriesWithMatchingName(ILoggerAdapter logger, string clientId, string displayableId, IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> adalCache);
    private static void RemoveEntriesWithMatchingId(string clientId, string accountOrUserId, IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> adalCache);
    public static MsalRefreshTokenCacheItem GetRefreshToken(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, IEnumerable`1<string> environmentAliases, string clientId, IAccount account);
    private static string GetHomeAccountId(AdalResultWrapper adalResultWrapper);
}
internal static class Microsoft.Identity.Client.Cache.CacheKeyFactory : object {
    public static string GetKeyFromRequest(AuthenticationRequestParameters requestParameters);
    public static string GetExternalCacheKeyFromResponse(AuthenticationRequestParameters requestParameters, string homeAccountIdFromResponse);
    public static string GetInternalPartitionKeyFromResponse(AuthenticationRequestParameters requestParameters, string homeAccountIdFromResponse);
    private static bool GetOboOrAppKey(AuthenticationRequestParameters requestParameters, String& key);
    public static string GetClientCredentialKey(string clientId, string tenantId, string popKid);
    public static string GetOboKey(string oboCacheKey, UserAssertion userAssertion);
    public static string GetOboKey(string oboCacheKey, string homeAccountId);
    public static string GetKeyFromCachedItem(MsalAccessTokenCacheItem accessTokenCacheItem);
    public static string GetKeyFromCachedItem(MsalRefreshTokenCacheItem refreshTokenCacheItem);
    public static string GetIdTokenKeyFromCachedItem(MsalAccessTokenCacheItem accessTokenCacheItem);
    public static string GetKeyFromAccount(MsalAccountCacheItem accountCacheItem);
    public static string GetKeyFromCachedItem(MsalIdTokenCacheItem idTokenCacheItem);
    public static string GetKeyFromCachedItem(MsalAccountCacheItem accountCacheItem);
}
public enum Microsoft.Identity.Client.Cache.CacheLevel : Enum {
    public int value__;
    public static CacheLevel None;
    public static CacheLevel Unknown;
    public static CacheLevel L1Cache;
    public static CacheLevel L2Cache;
}
internal class Microsoft.Identity.Client.Cache.CacheSessionManager : object {
    private AuthenticationRequestParameters _requestParams;
    private bool _cacheRefreshedForRead;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <TokenCacheInternal>k__BackingField;
    public RequestContext RequestContext { get; }
    public ITokenCacheInternal TokenCacheInternal { get; }
    public CacheSessionManager(ITokenCacheInternal tokenCacheInternal, AuthenticationRequestParameters requestParams);
    [CompilerGeneratedAttribute]
public sealed virtual RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public sealed virtual ITokenCacheInternal get_TokenCacheInternal();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<FindAccessTokenAsync>d__9")]
public sealed virtual Task`1<MsalAccessTokenCacheItem> FindAccessTokenAsync();
    public sealed virtual Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(MsalTokenResponse tokenResponse);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<GetAccountAssociatedWithAccessTokenAsync>d__11")]
public sealed virtual Task`1<Account> GetAccountAssociatedWithAccessTokenAsync(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<GetIdTokenCacheItemAsync>d__12")]
public sealed virtual Task`1<MsalIdTokenCacheItem> GetIdTokenCacheItemAsync(MsalAccessTokenCacheItem accessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<FindFamilyRefreshTokenAsync>d__13")]
public sealed virtual Task`1<MsalRefreshTokenCacheItem> FindFamilyRefreshTokenAsync(string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<FindRefreshTokenAsync>d__14")]
public sealed virtual Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<IsAppFociMemberAsync>d__15")]
public sealed virtual Task`1<Nullable`1<bool>> IsAppFociMemberAsync(string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<GetAccountsAsync>d__16")]
public sealed virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<RefreshCacheForReadOperationsAsync>d__17")]
private Task RefreshCacheForReadOperationsAsync();
    [CompilerGeneratedAttribute]
private string <RefreshCacheForReadOperationsAsync>b__17_0();
}
internal interface Microsoft.Identity.Client.Cache.ICacheSessionManager {
    public RequestContext RequestContext { get; }
    public ITokenCacheInternal TokenCacheInternal { get; }
    public abstract virtual RequestContext get_RequestContext();
    public abstract virtual ITokenCacheInternal get_TokenCacheInternal();
    public abstract virtual Task`1<MsalAccessTokenCacheItem> FindAccessTokenAsync();
    public abstract virtual Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(MsalTokenResponse tokenResponse);
    public abstract virtual Task`1<MsalIdTokenCacheItem> GetIdTokenCacheItemAsync(MsalAccessTokenCacheItem accessTokenCacheItem);
    public abstract virtual Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenAsync();
    public abstract virtual Task`1<MsalRefreshTokenCacheItem> FindFamilyRefreshTokenAsync(string familyId);
    public abstract virtual Task`1<Nullable`1<bool>> IsAppFociMemberAsync(string familyId);
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    public abstract virtual Task`1<Account> GetAccountAssociatedWithAccessTokenAsync(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
}
internal interface Microsoft.Identity.Client.Cache.ILegacyCachePersistence {
    public abstract virtual Byte[] LoadCache();
    public abstract virtual void WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.Cache.Items.CacheSerializationContract : object {
    private static IEnumerable`1<string> s_knownPropertyNames;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalAccessTokenCacheItem> <AccessTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalRefreshTokenCacheItem> <RefreshTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalIdTokenCacheItem> <IdTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalAccountCacheItem> <Accounts>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalAppMetadataCacheItem> <AppMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JToken> <UnknownNodes>k__BackingField;
    public Dictionary`2<string, MsalAccessTokenCacheItem> AccessTokens { get; public set; }
    public Dictionary`2<string, MsalRefreshTokenCacheItem> RefreshTokens { get; public set; }
    public Dictionary`2<string, MsalIdTokenCacheItem> IdTokens { get; public set; }
    public Dictionary`2<string, MsalAccountCacheItem> Accounts { get; public set; }
    public Dictionary`2<string, MsalAppMetadataCacheItem> AppMetadata { get; public set; }
    public IDictionary`2<string, JToken> UnknownNodes { get; }
    public CacheSerializationContract(IDictionary`2<string, JToken> unknownNodes);
    private static CacheSerializationContract();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalAccessTokenCacheItem> get_AccessTokens();
    [CompilerGeneratedAttribute]
public void set_AccessTokens(Dictionary`2<string, MsalAccessTokenCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalRefreshTokenCacheItem> get_RefreshTokens();
    [CompilerGeneratedAttribute]
public void set_RefreshTokens(Dictionary`2<string, MsalRefreshTokenCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalIdTokenCacheItem> get_IdTokens();
    [CompilerGeneratedAttribute]
public void set_IdTokens(Dictionary`2<string, MsalIdTokenCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalAccountCacheItem> get_Accounts();
    [CompilerGeneratedAttribute]
public void set_Accounts(Dictionary`2<string, MsalAccountCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalAppMetadataCacheItem> get_AppMetadata();
    [CompilerGeneratedAttribute]
public void set_AppMetadata(Dictionary`2<string, MsalAppMetadataCacheItem> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JToken> get_UnknownNodes();
    internal static CacheSerializationContract FromJsonString(string json);
    private static IDictionary`2<string, JToken> ExtractUnknownNodes(JObject root);
    internal string ToJsonString();
    [IteratorStateMachineAttribute("Microsoft.Identity.Client.Cache.Items.CacheSerializationContract/<<FromJsonString>g__GetElement|25_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<JObject> <FromJsonString>g__GetElement|25_0(JObject root, string key);
}
internal class Microsoft.Identity.Client.Cache.Items.MsalAccessTokenCacheItem : MsalCredentialCacheItemBase {
    private String[] _extraKeyParts;
    private string _credentialDescriptor;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ScopeSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScopeString>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExtendedExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <RefreshOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CachedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedLifeTimeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <PersistedCacheParameters>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    internal string TenantId { get; private set; }
    internal string OboCacheKey { get; internal set; }
    internal string KeyId { get; }
    internal string TokenType { get; }
    internal HashSet`1<string> ScopeSet { get; }
    internal string ScopeString { get; }
    internal DateTimeOffset ExpiresOn { get; private set; }
    internal DateTimeOffset ExtendedExpiresOn { get; private set; }
    internal Nullable`1<DateTimeOffset> RefreshOn { get; private set; }
    internal DateTimeOffset CachedAt { get; private set; }
    public bool IsExtendedLifeTimeToken { get; public set; }
    internal string CacheKey { get; private set; }
    internal IDictionary`2<string, string> PersistedCacheParameters { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalAccessTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string tenantId, string homeAccountId, string keyId, string oboCacheKey, IEnumerable`1<string> persistedCacheParameters);
    internal MsalAccessTokenCacheItem(string preferredCacheEnv, string clientId, string scopes, string tenantId, string secret, DateTimeOffset cachedAt, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string rawClientInfo, string homeAccountId, string keyId, Nullable`1<DateTimeOffset> refreshOn, string tokenType, string oboCacheKey);
    private MsalAccessTokenCacheItem(string scopes, DateTimeOffset cachedAt, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, Nullable`1<DateTimeOffset> refreshOn, string tenantId, string keyId, string tokenType);
    internal MsalAccessTokenCacheItem WithExpiresOn(DateTimeOffset expiresOn);
    internal void InitCacheKey();
    internal string ToLogString(bool piiEnabled);
    private IiOSKey InitiOSKey();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
internal string get_OboCacheKey();
    [CompilerGeneratedAttribute]
internal void set_OboCacheKey(string value);
    [CompilerGeneratedAttribute]
internal string get_KeyId();
    [CompilerGeneratedAttribute]
internal string get_TokenType();
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_ScopeSet();
    [CompilerGeneratedAttribute]
internal string get_ScopeString();
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_ExtendedExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExtendedExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTimeOffset> get_RefreshOn();
    [CompilerGeneratedAttribute]
private void set_RefreshOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_CachedAt();
    [CompilerGeneratedAttribute]
private void set_CachedAt(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public bool get_IsExtendedLifeTimeToken();
    [CompilerGeneratedAttribute]
public void set_IsExtendedLifeTimeToken(bool value);
    [CompilerGeneratedAttribute]
internal string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_PersistedCacheParameters();
    [CompilerGeneratedAttribute]
private void set_PersistedCacheParameters(IDictionary`2<string, string> value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalAccessTokenCacheItem FromJsonString(string json);
    internal static MsalAccessTokenCacheItem FromJObject(JObject j);
    internal virtual JObject ToJObject();
    internal string ToJsonString();
    internal MsalIdTokenCacheItem GetIdTokenItem();
    internal bool IsExpiredWithBuffer();
}
[DebuggerDisplayAttribute("{PreferredUsername} {base.Environment}")]
internal class Microsoft.Identity.Client.Cache.Items.MsalAccountCacheItem : MsalCacheItemBase {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorityType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <WamAccountIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    internal string TenantId { get; internal set; }
    internal string PreferredUsername { get; internal set; }
    internal string Name { get; internal set; }
    internal string GivenName { get; internal set; }
    internal string FamilyName { get; internal set; }
    internal string LocalAccountId { get; internal set; }
    internal string AccountSource { get; internal set; }
    internal string AuthorityType { get; internal set; }
    internal IDictionary`2<string, string> WamAccountIds { get; internal set; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalAccountCacheItem(string preferredCacheEnv, string clientInfo, string homeAccountId, string accountSource, IdToken idToken, string preferredUsername, string tenantId, IDictionary`2<string, string> wamAccountIds);
    internal MsalAccountCacheItem(string environment, string localAccountId, string rawClientInfo, string homeAccountId, string accountSource, string name, string preferredUsername, string tenantId, string givenName, string familyName, IDictionary`2<string, string> wamAccountIds);
    internal MsalAccountCacheItem(string environment, string tenantId, string homeAccountId, string accountSource, string preferredUsername);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
internal string get_PreferredUsername();
    [CompilerGeneratedAttribute]
internal void set_PreferredUsername(string value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_GivenName();
    [CompilerGeneratedAttribute]
internal void set_GivenName(string value);
    [CompilerGeneratedAttribute]
internal string get_FamilyName();
    [CompilerGeneratedAttribute]
internal void set_FamilyName(string value);
    [CompilerGeneratedAttribute]
internal string get_LocalAccountId();
    [CompilerGeneratedAttribute]
internal void set_LocalAccountId(string value);
    [CompilerGeneratedAttribute]
internal string get_AccountSource();
    [CompilerGeneratedAttribute]
internal void set_AccountSource(string value);
    [CompilerGeneratedAttribute]
internal string get_AuthorityType();
    [CompilerGeneratedAttribute]
internal void set_AuthorityType(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_WamAccountIds();
    [CompilerGeneratedAttribute]
internal void set_WamAccountIds(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    private void Init(string environment, string localAccountId, string rawClientInfo, string homeAccountId, string accountSource, string name, string preferredUsername, string tenantId, string givenName, string familyName, IDictionary`2<string, string> wamAccountIds);
    internal void InitCacheKey();
    private IiOSKey InitiOSKey();
    internal static MsalAccountCacheItem FromJsonString(string json);
    internal static MsalAccountCacheItem FromJObject(JObject j);
    internal virtual JObject ToJObject();
    internal string ToJsonString();
}
internal class Microsoft.Identity.Client.Cache.Items.MsalAppMetadataCacheItem : MsalItemWithAdditionalFields {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    public string ClientId { get; }
    public string Environment { get; }
    public string FamilyId { get; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    public MsalAppMetadataCacheItem(string clientId, string preferredCacheEnv, string familyId);
    private void InitCacheKey();
    private IiOSKey InitiOSKey();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_Environment();
    [CompilerGeneratedAttribute]
public string get_FamilyId();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalAppMetadataCacheItem FromJsonString(string json);
    internal static MsalAppMetadataCacheItem FromJObject(JObject j);
    internal string ToJsonString();
    internal virtual JObject ToJObject();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MsalAppMetadataCacheItem other);
    public virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("env: {Environment} accountId: {HomeAccountId}")]
internal abstract class Microsoft.Identity.Client.Cache.Items.MsalCacheItemBase : MsalItemWithAdditionalFields {
    [CompilerGeneratedAttribute]
private string <HomeAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawClientInfo>k__BackingField;
    internal string HomeAccountId { get; internal set; }
    internal string Environment { get; internal set; }
    internal string RawClientInfo { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_HomeAccountId();
    [CompilerGeneratedAttribute]
internal void set_HomeAccountId(string value);
    [CompilerGeneratedAttribute]
internal string get_Environment();
    [CompilerGeneratedAttribute]
internal void set_Environment(string value);
    [CompilerGeneratedAttribute]
internal string get_RawClientInfo();
    [CompilerGeneratedAttribute]
internal void set_RawClientInfo(string value);
    internal virtual void PopulateFieldsFromJObject(JObject j);
    internal virtual JObject ToJObject();
}
internal class Microsoft.Identity.Client.Cache.Items.MsalCredentialCacheItemBase : MsalCacheItemBase {
    [CompilerGeneratedAttribute]
private string <CredentialType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    internal string CredentialType { get; internal set; }
    public string ClientId { get; public set; }
    public string Secret { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_CredentialType();
    [CompilerGeneratedAttribute]
internal void set_CredentialType(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_Secret();
    [CompilerGeneratedAttribute]
public void set_Secret(string value);
    internal virtual void PopulateFieldsFromJObject(JObject j);
    internal virtual JObject ToJObject();
}
internal class Microsoft.Identity.Client.Cache.Items.MsalIdTokenCacheItem : MsalCredentialCacheItemBase {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    private Lazy`1<IdToken> idTokenLazy;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    internal string TenantId { get; internal set; }
    internal IdToken IdToken { get; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalIdTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string tenantId, string homeAccountId);
    internal MsalIdTokenCacheItem(string preferredCacheEnv, string clientId, string secret, string rawClientInfo, string homeAccountId, string tenantId);
    internal void InitCacheKey();
    private IiOSKey InitiOSKey();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    internal IdToken get_IdToken();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalIdTokenCacheItem FromJsonString(string json);
    internal static MsalIdTokenCacheItem FromJObject(JObject j);
    internal virtual JObject ToJObject();
    internal string ToJsonString();
    internal string GetUsername();
    [CompilerGeneratedAttribute]
private IdToken <.ctor>b__0_0();
}
internal abstract class Microsoft.Identity.Client.Cache.Items.MsalItemWithAdditionalFields : object {
    [CompilerGeneratedAttribute]
private string <AdditionalFieldsJson>k__BackingField;
    internal string AdditionalFieldsJson { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_AdditionalFieldsJson();
    [CompilerGeneratedAttribute]
internal void set_AdditionalFieldsJson(string value);
    internal virtual void PopulateFieldsFromJObject(JObject j);
    internal virtual JObject ToJObject();
    internal static void SetItemIfValueNotNull(JObject json, string key, JToken value);
    internal static void SetItemIfValueNotNullOrDefault(JObject json, string key, JToken value, string defaultValue);
    private static void SetValueIfFilterMatches(JObject json, string key, JToken value, Func`2<string, bool> filter);
}
internal class Microsoft.Identity.Client.Cache.Items.MsalRefreshTokenCacheItem : MsalCredentialCacheItemBase {
    [CompilerGeneratedAttribute]
private string <FamilyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    public string FamilyId { get; public set; }
    internal string OboCacheKey { get; internal set; }
    public bool IsFRT { get; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalRefreshTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string homeAccountId);
    internal MsalRefreshTokenCacheItem(string preferredCacheEnv, string clientId, string secret, string rawClientInfo, string familyId, string homeAccountId);
    internal void InitCacheKey();
    internal string ToLogString(bool piiEnabled);
    private IiOSKey InitiOSKey();
    private string GetiOSGeneric();
    public string GetiOSService();
    [CompilerGeneratedAttribute]
public string get_FamilyId();
    [CompilerGeneratedAttribute]
public void set_FamilyId(string value);
    [CompilerGeneratedAttribute]
internal string get_OboCacheKey();
    [CompilerGeneratedAttribute]
internal void set_OboCacheKey(string value);
    public bool get_IsFRT();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalRefreshTokenCacheItem FromJsonString(string json);
    internal static MsalRefreshTokenCacheItem FromJObject(JObject j);
    internal virtual JObject ToJObject();
    internal string ToJsonString();
    [CompilerGeneratedAttribute]
private IiOSKey <InitCacheKey>b__3_0();
}
internal interface Microsoft.Identity.Client.Cache.ITokenCacheAccessor {
    public abstract virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public abstract virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public abstract virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public abstract virtual void SaveAccount(MsalAccountCacheItem item);
    public abstract virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public abstract virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public abstract virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public abstract virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public abstract virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public abstract virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public abstract virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public abstract virtual void DeleteAccount(MsalAccountCacheItem item);
    public abstract virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalAccountCacheItem> GetAllAccounts(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public abstract virtual void SetiOSKeychainSecurityGroup(string keychainSecurityGroup);
    public abstract virtual void Clear(ILoggerAdapter requestlogger);
    public abstract virtual bool HasAccessOrRefreshTokens();
}
internal interface Microsoft.Identity.Client.Cache.ITokenCacheSerializable {
    public abstract virtual IDictionary`2<string, JToken> Deserialize(Byte[] bytes, bool clearExistingCacheData);
    public abstract virtual Byte[] Serialize(IDictionary`2<string, JToken> additionalNodes);
}
internal interface Microsoft.Identity.Client.Cache.Keys.IiOSKey {
    public string iOSAccount { get; }
    public string iOSGeneric { get; }
    public string iOSService { get; }
    public int iOSType { get; }
    public abstract virtual string get_iOSAccount();
    public abstract virtual string get_iOSGeneric();
    public abstract virtual string get_iOSService();
    public abstract virtual int get_iOSType();
}
internal class Microsoft.Identity.Client.Cache.Keys.IosKey : ValueType {
    [CompilerGeneratedAttribute]
private string <iOSAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <iOSGeneric>k__BackingField;
    [CompilerGeneratedAttribute]
private string <iOSService>k__BackingField;
    [CompilerGeneratedAttribute]
private int <iOSType>k__BackingField;
    public string iOSAccount { get; }
    public string iOSGeneric { get; }
    public string iOSService { get; }
    public int iOSType { get; }
    internal IosKey(string iOSAccount, string iOSService, string iOSGeneric, int iOSType);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_iOSAccount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_iOSGeneric();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_iOSService();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual int get_iOSType();
}
internal class Microsoft.Identity.Client.Cache.Keys.MsalCacheKeys : object {
    public static char CacheKeyDelimiter;
    internal static Dictionary`2<string, int> iOSAuthorityTypeToAttrType;
    private static MsalCacheKeys();
    public static string GetCredentialKey(string homeAccountId, string environment, string keyDescriptor, string clientId, string tenantId, string scopes, String[] additionalKeys);
    public static string GetiOSAccountKey(string homeAccountId, string environment);
    public static string GetiOSServiceKey(string keyDescriptor, string clientId, string tenantId, string scopes, String[] extraKeyParts);
    public static string GetiOSGenericKey(string keyDescriptor, string clientId, string tenantId);
}
internal static class Microsoft.Identity.Client.Cache.StorageJsonKeys : object {
    public static string HomeAccountId;
    public static string Environment;
    public static string Realm;
    public static string LocalAccountId;
    public static string Username;
    public static string AuthorityType;
    public static string AlternativeAccountId;
    public static string GivenName;
    public static string FamilyName;
    public static string MiddleName;
    public static string Name;
    public static string AvatarUrl;
    public static string CredentialType;
    public static string ClientId;
    public static string Secret;
    public static string Target;
    public static string CachedAt;
    public static string ExpiresOn;
    public static string RefreshOn;
    public static string ExtendedExpiresOn;
    public static string ClientInfo;
    public static string FamilyId;
    public static string AppMetadata;
    public static string KeyId;
    public static string TokenType;
    public static string WamAccountIds;
    public static string AccountSource;
    public static string UserAssertionHash;
    public static string ExtendedExpiresOn_MsalCompat;
}
internal static class Microsoft.Identity.Client.Cache.StorageJsonValues : object {
    public static string AuthorityTypeAdfs;
    public static string AuthorityTypeMsa;
    public static string AuthorityTypeMsSts;
    public static string AuthorityTypeOther;
    public static string TokenTypeBearer;
    public static string CredentialTypeRefreshToken;
    public static string CredentialTypeAccessToken;
    public static string CredentialTypeAccessTokenWithAuthScheme;
    public static string CredentialTypeIdToken;
    public static string AccountRootKey;
    public static string CredentialTypeOther;
    public static string AppMetadata;
}
internal class Microsoft.Identity.Client.Cache.TokenCacheDictionarySerializer : object {
    private static string AccessTokenKey;
    private static string RefreshTokenKey;
    private static string IdTokenKey;
    private static string AccountKey;
    private ITokenCacheAccessor _accessor;
    public TokenCacheDictionarySerializer(ITokenCacheAccessor accessor);
    public sealed virtual Byte[] Serialize(IDictionary`2<string, JToken> unknownNodes);
    public sealed virtual IDictionary`2<string, JToken> Deserialize(Byte[] bytes, bool clearExistingCacheData);
}
internal class Microsoft.Identity.Client.Cache.TokenCacheJsonSerializer : object {
    private ITokenCacheAccessor _accessor;
    public TokenCacheJsonSerializer(ITokenCacheAccessor accessor);
    public sealed virtual Byte[] Serialize(IDictionary`2<string, JToken> unknownNodes);
    public sealed virtual IDictionary`2<string, JToken> Deserialize(Byte[] bytes, bool clearExistingCacheData);
}
internal enum Microsoft.Identity.Client.Cache.TokenSubjectType : Enum {
    public int value__;
    public static TokenSubjectType User;
    public static TokenSubjectType Client;
    public static TokenSubjectType UserPlusClient;
}
public class Microsoft.Identity.Client.CacheOptions : object {
    [CompilerGeneratedAttribute]
private bool <UseSharedCache>k__BackingField;
    public static CacheOptions EnableSharedCacheOptions { get; }
    public bool UseSharedCache { get; public set; }
    public CacheOptions(bool useSharedCache);
    public static CacheOptions get_EnableSharedCacheOptions();
    [CompilerGeneratedAttribute]
public bool get_UseSharedCache();
    [CompilerGeneratedAttribute]
public void set_UseSharedCache(bool value);
}
public enum Microsoft.Identity.Client.CacheRefreshReason : Enum {
    public int value__;
    public static CacheRefreshReason NotApplicable;
    public static CacheRefreshReason ForceRefreshOrClaims;
    public static CacheRefreshReason NoCachedAccessToken;
    public static CacheRefreshReason Expired;
    public static CacheRefreshReason ProactivelyRefreshed;
}
public abstract class Microsoft.Identity.Client.ClientApplicationBase : ApplicationBase {
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <UserTokenCacheInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SliceParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAuthority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    public IAppConfig AppConfig { get; }
    public ITokenCache UserTokenCache { get; }
    internal ITokenCacheInternal UserTokenCacheInternal { get; }
    public string Authority { get; }
    internal AuthorityInfo AuthorityInfo { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use GetAccountsAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public IEnumerable`1<IUser> Users { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithComponent on AbstractApplicationBuilder<T> to configure this instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public string Component { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ExtraQueryParameters on each call instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public string SliceParameters { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Can be set on AbstractApplicationBuilder<T>.WithAuthority as needed.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public bool ValidateAuthority { get; public set; }
    [ObsoleteAttribute("Should be set using AbstractApplicationBuilder<T>.WithRedirectUri and can be viewed with ClientApplicationBase.AppConfig.RedirectUri.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public string RedirectUri { get; public set; }
    [ObsoleteAttribute("Use AppConfig.ClientId instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public string ClientId { get; }
    internal ClientApplicationBase(ApplicationConfiguration config);
    public sealed virtual IAppConfig get_AppConfig();
    public sealed virtual ITokenCache get_UserTokenCache();
    [CompilerGeneratedAttribute]
internal ITokenCacheInternal get_UserTokenCacheInternal();
    public sealed virtual string get_Authority();
    internal AuthorityInfo get_AuthorityInfo();
    public sealed virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    public Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(string userFlow);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsAsync>d__15")]
public Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(string userFlow, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountAsync>d__16")]
public Task`1<IAccount> GetAccountAsync(string accountId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountAsync>d__17")]
public sealed virtual Task`1<IAccount> GetAccountAsync(string accountId);
    public sealed virtual Task RemoveAsync(IAccount account);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<RemoveAsync>d__19")]
public Task RemoveAsync(IAccount account, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsInternalAsync>d__20")]
private Task`1<IEnumerable`1<IAccount>> GetAccountsInternalAsync(ApiIds apiId, string homeAccountIdFilter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsFromBrokerAsync>d__21")]
private Task`1<IEnumerable`1<IAccount>> GetAccountsFromBrokerAsync(string homeAccountIdFilter, ICacheSessionManager cacheSessionManager, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<FilterBrokerAccountsByEnvAsync>d__22")]
private Task`1<IEnumerable`1<IAccount>> FilterBrokerAccountsByEnvAsync(IEnumerable`1<IAccount> brokerAccounts, CancellationToken cancellationToken);
    private IEnumerable`1<IAccount> MergeAccounts(IEnumerable`1<IAccount> cacheAccounts, IEnumerable`1<IAccount> brokerAccounts);
    internal RequestContext CreateRequestContext(Guid correlationId, CancellationToken cancellationToken);
    public sealed virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, IAccount account);
    public sealed virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, string loginHint);
    public sealed virtual IEnumerable`1<IUser> get_Users();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAccountAsync instead and pass IAccount.HomeAccountId.Identifier (See https://aka.ms/msal-net-2-released)", "True")]
public sealed virtual IUser GetUser(string identifier);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use RemoveAccountAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public sealed virtual void Remove(IUser user);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Component();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Component(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SliceParameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SliceParameters(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ValidateAuthority();
    [CompilerGeneratedAttribute]
public void set_ValidateAuthority(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RedirectUri();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RedirectUri(string value);
    public sealed virtual string get_ClientId();
    [ObsoleteAttribute("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account, string authority, bool forceRefresh);
    [ObsoleteAttribute("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.ConfidentialClientApplication : ClientApplicationBase {
    public static string AttemptRegionDiscovery;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <AppTokenCacheInternal>k__BackingField;
    public ITokenCache AppTokenCache { get; }
    public X509Certificate2 Certificate { get; }
    internal ITokenCacheInternal AppTokenCacheInternal { get; }
    internal ConfidentialClientApplication(ApplicationConfiguration configuration);
    public sealed virtual AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(IEnumerable`1<string> scopes, string authorizationCode);
    public sealed virtual AcquireTokenForClientParameterBuilder AcquireTokenForClient(IEnumerable`1<string> scopes);
    public sealed virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    public sealed virtual AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(IEnumerable`1<string> scopes, string userToken, String& longRunningProcessSessionKey);
    public sealed virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(IEnumerable`1<string> scopes, string longRunningProcessSessionKey);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ConfidentialClientApplication/<StopLongRunningProcessInWebApiAsync>d__7")]
public Task`1<bool> StopLongRunningProcessInWebApiAsync(string longRunningProcessSessionKey, CancellationToken cancellationToken);
    public sealed virtual GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(IEnumerable`1<string> scopes);
    private sealed virtual override AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder Microsoft.Identity.Client.IByUsernameAndPassword.AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, string password);
    private sealed virtual override AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(IEnumerable`1<string> scopes, string refreshToken);
    public sealed virtual ITokenCache get_AppTokenCache();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
internal ITokenCacheInternal get_AppTokenCacheInternal();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ConfidentialClientApplication/<CreateRequestParametersAsync>d__19")]
internal virtual Task`1<AuthenticationRequestParameters> CreateRequestParametersAsync(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<AuthenticationResult> AcquireTokenByAuthorizationCodeAsync(string authorizationCode, IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(IEnumerable`1<string> scopes, string refreshToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<Uri> GetAuthorizationRequestUrlAsync(IEnumerable`1<string> scopes, string loginHint, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public Task`1<Uri> GetAuthorizationRequestUrlAsync(IEnumerable`1<string> scopes, string redirectUri, string loginHint, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<AuthenticationRequestParameters> <>n__0(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.ConfidentialClientApplicationBuilder : AbstractApplicationBuilder`1<ConfidentialClientApplicationBuilder> {
    internal ConfidentialClientApplicationBuilder(ApplicationConfiguration configuration);
    [EditorBrowsableAttribute("1")]
public static ConfidentialClientApplicationBuilder CreateWithApplicationOptions(ConfidentialClientApplicationOptions options);
    [EditorBrowsableAttribute("1")]
public static ConfidentialClientApplicationBuilder Create(string clientId);
    public ConfidentialClientApplicationBuilder WithCertificate(X509Certificate2 certificate);
    public ConfidentialClientApplicationBuilder WithCertificate(X509Certificate2 certificate, bool sendX5C);
    public ConfidentialClientApplicationBuilder WithClientClaims(X509Certificate2 certificate, IDictionary`2<string, string> claimsToSign, bool mergeWithDefaultClaims);
    public ConfidentialClientApplicationBuilder WithClientClaims(X509Certificate2 certificate, IDictionary`2<string, string> claimsToSign, bool mergeWithDefaultClaims, bool sendX5C);
    public ConfidentialClientApplicationBuilder WithClientSecret(string clientSecret);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This method is not recommended. Use overload with Func<AssertionRequestOptions, Task<string>> instead, and return a non-expired assertion, which can be a Federated Credential. See https://aka.ms/msal-net-client-assertion", "False")]
public ConfidentialClientApplicationBuilder WithClientAssertion(string signedClientAssertion);
    [EditorBrowsableAttribute("1")]
public ConfidentialClientApplicationBuilder WithClientAssertion(Func`1<string> clientAssertionDelegate);
    [EditorBrowsableAttribute("1")]
public ConfidentialClientApplicationBuilder WithClientAssertion(Func`2<CancellationToken, Task`1<string>> clientAssertionAsyncDelegate);
    public ConfidentialClientApplicationBuilder WithClientAssertion(Func`2<AssertionRequestOptions, Task`1<string>> clientAssertionAsyncDelegate);
    public ConfidentialClientApplicationBuilder WithAzureRegion(string azureRegion);
    public ConfidentialClientApplicationBuilder WithCacheSynchronization(bool enableCacheSynchronization);
    [ObsoleteAttribute("This method has been renamed to WithOidcAuthority.", "False")]
[EditorBrowsableAttribute("1")]
public ConfidentialClientApplicationBuilder WithGenericAuthority(string authorityUri);
    public ConfidentialClientApplicationBuilder WithOidcAuthority(string authorityUri);
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "True")]
[EditorBrowsableAttribute("1")]
public ConfidentialClientApplicationBuilder WithTelemetryClient(ITelemetryClient[] telemetryClients);
    internal ConfidentialClientApplicationBuilder WithAppTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal);
    internal virtual void Validate();
    public IConfidentialClientApplication Build();
    internal ConfidentialClientApplication BuildConcrete();
}
public class Microsoft.Identity.Client.ConfidentialClientApplicationOptions : ApplicationOptions {
    [CompilerGeneratedAttribute]
private string <ClientSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AzureRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCacheSynchronization>k__BackingField;
    public string ClientSecret { get; public set; }
    public string AzureRegion { get; public set; }
    public bool EnableCacheSynchronization { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientSecret();
    [CompilerGeneratedAttribute]
public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public string get_AzureRegion();
    [CompilerGeneratedAttribute]
public void set_AzureRegion(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableCacheSynchronization();
    [CompilerGeneratedAttribute]
public void set_EnableCacheSynchronization(bool value);
}
internal interface Microsoft.Identity.Client.Core.ILoggerAdapter {
    public bool PiiLoggingEnabled { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    public IIdentityLogger IdentityLogger { get; }
    public abstract virtual bool get_PiiLoggingEnabled();
    public abstract virtual bool get_IsDefaultPlatformLoggingEnabled();
    public abstract virtual string get_ClientName();
    public abstract virtual string get_ClientVersion();
    public abstract virtual IIdentityLogger get_IdentityLogger();
    public abstract virtual bool IsLoggingEnabled(LogLevel logLevel);
    public abstract virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public abstract virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public abstract virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Core.MsalLoggerExtensions : object {
    [ExtensionAttribute]
public static void Always(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void AlwaysPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void Error(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void ErrorPiiWithPrefix(ILoggerAdapter logger, Exception exWithPii, string prefix);
    [ExtensionAttribute]
public static void ErrorPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void ErrorPii(ILoggerAdapter logger, Exception exWithPii);
    [ExtensionAttribute]
public static void Warning(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void WarningPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void WarningPii(ILoggerAdapter logger, Exception exWithPii);
    [ExtensionAttribute]
public static void WarningPiiWithPrefix(ILoggerAdapter logger, Exception exWithPii, string prefix);
    [ExtensionAttribute]
public static void Info(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void Info(ILoggerAdapter logger, Func`1<string> messageProducer);
    [ExtensionAttribute]
public static void InfoPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void InfoPii(ILoggerAdapter logger, Func`1<string> messageWithPiiProducer, Func`1<string> messageScrubbedProducer);
    [ExtensionAttribute]
public static void InfoPii(ILoggerAdapter logger, Exception exWithPii);
    [ExtensionAttribute]
public static void Verbose(ILoggerAdapter logger, Func`1<string> messageProducer);
    [ExtensionAttribute]
public static void VerbosePii(ILoggerAdapter logger, Func`1<string> messageWithPiiProducer, Func`1<string> messageScrubbedProducer);
}
public class Microsoft.Identity.Client.DeviceCodeResult : object {
    [CompilerGeneratedAttribute]
private string <UserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Scopes>k__BackingField;
    public string UserCode { get; }
    public string DeviceCode { get; }
    public string VerificationUrl { get; }
    public DateTimeOffset ExpiresOn { get; }
    public long Interval { get; }
    public string Message { get; }
    public string ClientId { get; }
    public IReadOnlyCollection`1<string> Scopes { get; }
    internal DeviceCodeResult(string userCode, string deviceCode, string verificationUrl, DateTimeOffset expiresOn, long interval, string message, string clientId, ISet`1<string> scopes);
    [CompilerGeneratedAttribute]
public string get_UserCode();
    [CompilerGeneratedAttribute]
public string get_DeviceCode();
    [CompilerGeneratedAttribute]
public string get_VerificationUrl();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public long get_Interval();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Scopes();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.EmbeddedWebViewOptions : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebView2BrowserExecutableFolder>k__BackingField;
    public string Title { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("In case when WebView2 is not available, MSAL.NET will fallback to legacy WebView.", "True")]
public string WebView2BrowserExecutableFolder { get; public set; }
    internal static EmbeddedWebViewOptions GetDefaultOptions();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_WebView2BrowserExecutableFolder();
    [CompilerGeneratedAttribute]
public void set_WebView2BrowserExecutableFolder(string value);
    internal void LogParameters(ILoggerAdapter logger);
    internal static void ValidatePlatformAvailability();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__10_0();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AbstractConfidentialClientAcquireTokenParameterBuilderExtension : object {
    [ExtensionAttribute]
public static AbstractAcquireTokenParameterBuilder`1<T> OnBeforeTokenRequest(AbstractAcquireTokenParameterBuilder`1<T> builder, Func`2<OnBeforeTokenRequestData, Task> onBeforeTokenRequestHandler);
    [ExtensionAttribute]
public static AbstractAcquireTokenParameterBuilder`1<T> WithProofOfPosessionKeyId(AbstractAcquireTokenParameterBuilder`1<T> builder, string keyId, string expectedTokenTypeFromAad);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AcquireTokenForClientBuilderExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static AcquireTokenForClientParameterBuilder WithProofOfPosessionKeyId(AcquireTokenForClientParameterBuilder builder, string keyId, string expectedTokenTypeFromAad);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AcquireTokenInteractiveParameterBuilderExtensions : object {
    [ExtensionAttribute]
public static AcquireTokenInteractiveParameterBuilder WithCustomWebUi(AcquireTokenInteractiveParameterBuilder builder, ICustomWebUi customWebUi);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AcquireTokenOnBehalfOfParameterBuilderExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static AcquireTokenOnBehalfOfParameterBuilder WithSearchInCacheForLongRunningProcess(AcquireTokenOnBehalfOfParameterBuilder builder, bool searchInCache);
}
public class Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IEnumerable`1<string> Scopes { get; internal set; }
    public string CorrelationId { get; internal set; }
    public string Claims { get; internal set; }
    public string TenantId { get; internal set; }
    public CancellationToken CancellationToken { get; internal set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
internal void set_Scopes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
internal void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
internal void set_Claims(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal void set_CancellationToken(CancellationToken value);
}
public class Microsoft.Identity.Client.Extensibility.AppTokenProviderResult : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpiresInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RefreshInSeconds>k__BackingField;
    public string AccessToken { get; public set; }
    public long ExpiresInSeconds { get; public set; }
    public Nullable`1<long> RefreshInSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public long get_ExpiresInSeconds();
    [CompilerGeneratedAttribute]
public void set_ExpiresInSeconds(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RefreshInSeconds();
    [CompilerGeneratedAttribute]
public void set_RefreshInSeconds(Nullable`1<long> value);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationBuilderExtensions : object {
    [ExtensionAttribute]
public static ConfidentialClientApplicationBuilder WithAppTokenProvider(ConfidentialClientApplicationBuilder builder, Func`2<AppTokenProviderParameters, Task`1<AppTokenProviderResult>> appTokenProvider);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions/<StopLongRunningProcessInWebApiAsync>d__0")]
[ExtensionAttribute]
public static Task`1<bool> StopLongRunningProcessInWebApiAsync(ILongRunningWebApi clientApp, string longRunningProcessSessionKey, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Extensibility.ExternalBoundTokenScheme : object {
    private string _keyId;
    private string _tokenType;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string KeyId { get; }
    public string AccessTokenType { get; }
    public ExternalBoundTokenScheme(string keyId, string expectedTokenTypeFromEsts);
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_KeyId();
    public sealed virtual string get_AccessTokenType();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetTokenRequestParams();
}
public interface Microsoft.Identity.Client.Extensibility.ICustomWebUi {
    public abstract virtual Task`1<Uri> AcquireAuthorizationCodeAsync(Uri authorizationUri, Uri redirectUri, CancellationToken cancellationToken);
}
public class Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <BodyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IDictionary`2<string, string> BodyParameters { get; }
    public IDictionary`2<string, string> Headers { get; }
    public Uri RequestUri { get; public set; }
    public CancellationToken CancellationToken { get; }
    public OnBeforeTokenRequestData(IDictionary`2<string, string> bodyParameters, IDictionary`2<string, string> headers, Uri requestUri, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_BodyParameters();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public Uri get_RequestUri();
    [CompilerGeneratedAttribute]
public void set_RequestUri(Uri value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<GetAuthorizationRequestUrlParameterBuilder> {
    [CompilerGeneratedAttribute]
private GetAuthorizationRequestUrlParameters <Parameters>k__BackingField;
    private GetAuthorizationRequestUrlParameters Parameters { get; }
    internal GetAuthorizationRequestUrlParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationexecutor);
    [CompilerGeneratedAttribute]
private GetAuthorizationRequestUrlParameters get_Parameters();
    internal static GetAuthorizationRequestUrlParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes);
    public GetAuthorizationRequestUrlParameterBuilder WithRedirectUri(string redirectUri);
    public GetAuthorizationRequestUrlParameterBuilder WithLoginHint(string loginHint);
    public GetAuthorizationRequestUrlParameterBuilder WithAccount(IAccount account);
    public GetAuthorizationRequestUrlParameterBuilder WithExtraScopesToConsent(IEnumerable`1<string> extraScopesToConsent);
    public GetAuthorizationRequestUrlParameterBuilder WithPkce(String& codeVerifier);
    public GetAuthorizationRequestUrlParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier);
    public GetAuthorizationRequestUrlParameterBuilder WithPrompt(Prompt prompt);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public Task`1<Uri> ExecuteAsync(CancellationToken cancellationToken);
    public Task`1<Uri> ExecuteAsync();
    internal virtual ApiIds CalculateApiEventId();
}
internal static class Microsoft.Identity.Client.Http.HttpClientConfig : object {
    public static long MaxResponseContentBufferSizeInBytes;
    public static int MaxConnections;
    public static TimeSpan ConnectionLifeTime;
    private static HttpClientConfig();
    public static void ConfigureRequestHeadersAndSize(HttpClient httpClient);
}
internal class Microsoft.Identity.Client.Http.HttpManager : object {
    protected IMsalHttpClientFactory _httpClientFactory;
    private IRetryPolicy _retryPolicy;
    [CompilerGeneratedAttribute]
private long <LastRequestDurationInMs>k__BackingField;
    public long LastRequestDurationInMs { get; private set; }
    public HttpManager(IMsalHttpClientFactory httpClientFactory, IRetryPolicy retryPolicy);
    [CompilerGeneratedAttribute]
public sealed virtual long get_LastRequestDurationInMs();
    [CompilerGeneratedAttribute]
private void set_LastRequestDurationInMs(long value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendRequestAsync>d__7")]
public sealed virtual Task`1<HttpResponse> SendRequestAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, bool doNotThrow, X509Certificate2 bindingCertificate, HttpClient customHttpClient, CancellationToken cancellationToken, int retryCount);
    private HttpClient GetHttpClient(X509Certificate2 x509Certificate2, HttpClient customHttpClient);
    private static HttpRequestMessage CreateRequestMessage(Uri endpoint, IDictionary`2<string, string> headers);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<ExecuteAsync>d__10")]
private Task`1<HttpResponse> ExecuteAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, HttpMethod method, X509Certificate2 bindingCertificate, HttpClient customHttpClient, ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<CloneHttpContentAsync>d__11")]
protected static Task`1<HttpContent> CloneHttpContentAsync(HttpContent httpContent);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<CreateResponseAsync>d__12")]
internal static Task`1<HttpResponse> CreateResponseAsync(HttpResponseMessage response);
}
internal class Microsoft.Identity.Client.Http.HttpManagerFactory : object {
    public static IHttpManager GetHttpManager(IMsalHttpClientFactory httpClientFactory, bool withRetry, bool isManagedIdentity);
}
internal class Microsoft.Identity.Client.Http.HttpResponse : object {
    [CompilerGeneratedAttribute]
private HttpResponseHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    public HttpResponseHeaders Headers { get; public set; }
    public IDictionary`2<string, string> HeadersAsDictionary { get; }
    public HttpStatusCode StatusCode { get; public set; }
    public string UserAgent { get; public set; }
    public string Body { get; public set; }
    [CompilerGeneratedAttribute]
public HttpResponseHeaders get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(HttpResponseHeaders value);
    public IDictionary`2<string, string> get_HeadersAsDictionary();
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
}
internal static class Microsoft.Identity.Client.Http.HttpRetryConditions : object {
    public static bool ManagedIdentity(HttpResponse response, Exception exception);
    public static bool Sts(HttpResponse response, Exception exception);
}
internal interface Microsoft.Identity.Client.Http.IHttpManager {
    public long LastRequestDurationInMs { get; }
    public abstract virtual long get_LastRequestDurationInMs();
    public abstract virtual Task`1<HttpResponse> SendRequestAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, bool doNotThrow, X509Certificate2 mtlsCertificate, HttpClient customHttpClient, CancellationToken cancellationToken, int retryCount);
}
internal interface Microsoft.Identity.Client.Http.IRetryPolicy {
    public int DelayInMilliseconds { get; }
    public abstract virtual int get_DelayInMilliseconds();
    public abstract virtual bool pauseForRetry(HttpResponse response, Exception exception, int retryCount);
}
internal class Microsoft.Identity.Client.Http.LinearRetryPolicy : object {
    private int _maxRetries;
    private Func`3<HttpResponse, Exception, bool> _retryCondition;
    [CompilerGeneratedAttribute]
private int <DelayInMilliseconds>k__BackingField;
    public int DelayInMilliseconds { get; private set; }
    public LinearRetryPolicy(int delayMilliseconds, int maxRetries, Func`3<HttpResponse, Exception, bool> retryCondition);
    [CompilerGeneratedAttribute]
private void set_DelayInMilliseconds(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_DelayInMilliseconds();
    public sealed virtual bool pauseForRetry(HttpResponse response, Exception exception, int retryCount);
}
internal class Microsoft.Identity.Client.Http.NoRetryPolicy : object {
    public int DelayInMilliseconds { get; }
    public sealed virtual int get_DelayInMilliseconds();
    public sealed virtual bool pauseForRetry(HttpResponse response, Exception exception, int retryCount);
}
internal class Microsoft.Identity.Client.Http.RedirectUriHelper : object {
    public static void Validate(Uri redirectUri, bool usesSystemBrowser);
    public static void ValidateIosBrokerRedirectUri(Uri redirectUri, string bundleId, ILoggerAdapter logger);
}
public interface Microsoft.Identity.Client.IAccount {
    public string Username { get; }
    public string Environment { get; }
    public AccountId HomeAccountId { get; }
    public abstract virtual string get_Username();
    public abstract virtual string get_Environment();
    public abstract virtual AccountId get_HomeAccountId();
}
public interface Microsoft.Identity.Client.IAppConfig {
    public string ClientId { get; }
    public bool EnablePiiLogging { get; }
    public IMsalHttpClientFactory HttpClientFactory { get; }
    public LogLevel LogLevel { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string RedirectUri { get; }
    public string TenantId { get; }
    public LogCallback LoggingCallback { get; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; }
    public bool IsBrokerEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public ITelemetryConfig TelemetryConfig { get; }
    public bool ExperimentalFeaturesEnabled { get; }
    public IEnumerable`1<string> ClientCapabilities { get; }
    public bool LegacyCacheCompatibilityEnabled { get; }
    [EditorBrowsableAttribute("1")]
public string ClientSecret { get; }
    [EditorBrowsableAttribute("1")]
public X509Certificate2 ClientCredentialCertificate { get; }
    public Func`1<object> ParentActivityOrWindowFunc { get; }
    public string IosKeychainSecurityGroup { get; }
    public abstract virtual string get_ClientId();
    public abstract virtual bool get_EnablePiiLogging();
    public abstract virtual IMsalHttpClientFactory get_HttpClientFactory();
    public abstract virtual LogLevel get_LogLevel();
    public abstract virtual bool get_IsDefaultPlatformLoggingEnabled();
    public abstract virtual string get_RedirectUri();
    public abstract virtual string get_TenantId();
    public abstract virtual LogCallback get_LoggingCallback();
    public abstract virtual IDictionary`2<string, string> get_ExtraQueryParameters();
    public abstract virtual bool get_IsBrokerEnabled();
    public abstract virtual string get_ClientName();
    public abstract virtual string get_ClientVersion();
    public abstract virtual ITelemetryConfig get_TelemetryConfig();
    public abstract virtual bool get_ExperimentalFeaturesEnabled();
    public abstract virtual IEnumerable`1<string> get_ClientCapabilities();
    public abstract virtual bool get_LegacyCacheCompatibilityEnabled();
    public abstract virtual string get_ClientSecret();
    public abstract virtual X509Certificate2 get_ClientCredentialCertificate();
    public abstract virtual Func`1<object> get_ParentActivityOrWindowFunc();
    public abstract virtual string get_IosKeychainSecurityGroup();
}
public interface Microsoft.Identity.Client.IApplicationBase {
}
public interface Microsoft.Identity.Client.IByRefreshToken {
    public abstract virtual AcquireTokenByRefreshTokenParameterBuilder AcquireTokenByRefreshToken(IEnumerable`1<string> scopes, string refreshToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByRefreshTokenAsync(IEnumerable`1<string> scopes, string refreshToken);
}
public interface Microsoft.Identity.Client.IByUsernameAndPassword {
    public abstract virtual AcquireTokenByUsernameAndPasswordConfidentialParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, string password);
}
public interface Microsoft.Identity.Client.IClientApplicationBase {
    public IAppConfig AppConfig { get; }
    public ITokenCache UserTokenCache { get; }
    public string Authority { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use GetAccountsAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public IEnumerable`1<IUser> Users { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithComponent on AbstractApplicationBuilder<T> to configure this instead.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public string Component { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ExtraQueryParameters on each call instead.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public string SliceParameters { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Can be set on AbstractApplicationBuilder<T>.WithAuthority as needed.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public bool ValidateAuthority { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Should be set using AbstractApplicationBuilder<T>.WithRedirectUri and can be viewed with ClientApplicationBase.AppConfig.RedirectUri. See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public string RedirectUri { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AppConfig.ClientId instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public string ClientId { get; }
    public abstract virtual IAppConfig get_AppConfig();
    public abstract virtual ITokenCache get_UserTokenCache();
    public abstract virtual string get_Authority();
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    public abstract virtual Task`1<IAccount> GetAccountAsync(string identifier);
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(string userFlow);
    public abstract virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, IAccount account);
    public abstract virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, string loginHint);
    public abstract virtual Task RemoveAsync(IAccount account);
    public abstract virtual IEnumerable`1<IUser> get_Users();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAccountAsync instead and pass IAccount.HomeAccountId.Identifier (See https://aka.ms/msal-net-2-released)", "True")]
public abstract virtual IUser GetUser(string identifier);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use RemoveAccountAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public abstract virtual void Remove(IUser user);
    public abstract virtual string get_Component();
    public abstract virtual void set_Component(string value);
    public abstract virtual string get_SliceParameters();
    public abstract virtual void set_SliceParameters(string value);
    public abstract virtual bool get_ValidateAuthority();
    public abstract virtual string get_RedirectUri();
    public abstract virtual void set_RedirectUri(string value);
    [ObsoleteAttribute("Use AcquireTokenSilent instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account, string authority, bool forceRefresh);
    public abstract virtual string get_ClientId();
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.IConfidentialClientApplication {
    public ITokenCache AppTokenCache { get; }
    public abstract virtual ITokenCache get_AppTokenCache();
    public abstract virtual AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(IEnumerable`1<string> scopes, string authorizationCode);
    public abstract virtual AcquireTokenForClientParameterBuilder AcquireTokenForClient(IEnumerable`1<string> scopes);
    public abstract virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    public abstract virtual GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("In confidential client apps use AcquireTokenSilent(scopes, account) instead.")]
[EditorBrowsableAttribute("1")]
public abstract virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, string loginHint);
    [ObsoleteAttribute("Use GetAccountAsync(identifier) in web apps and web APIs, and use a token cache serializer for better security and performance. See https://aka.ms/msal-net-cca-token-cache-serialization.")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
}
public interface Microsoft.Identity.Client.ILongRunningWebApi {
    public abstract virtual AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(IEnumerable`1<string> scopes, string userToken, String& longRunningProcessSessionKey);
    public abstract virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(IEnumerable`1<string> scopes, string longRunningProcessSessionKey);
}
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.IManagedIdentityApplication {
    public abstract virtual AcquireTokenForManagedIdentityParameterBuilder AcquireTokenForManagedIdentity(string resource);
}
public interface Microsoft.Identity.Client.IMsalHttpClientFactory {
    public abstract virtual HttpClient GetHttpClient();
}
internal interface Microsoft.Identity.Client.IMsalMtlsHttpClientFactory {
    public abstract virtual HttpClient GetHttpClient(X509Certificate2 x509Certificate2);
}
internal class Microsoft.Identity.Client.Instance.AadAuthority : Authority {
    public static string DefaultTrustedHost;
    public static string AADCanonicalAuthorityTemplate;
    private static string TokenEndpointTemplate;
    private static string DeviceCodeEndpointTemplate;
    private static string AuthorizationEndpointTemplate;
    private static ISet`1<string> s_tenantlessTenantNames;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal string TenantId { get; }
    internal AadAuthority(AuthorityInfo authorityInfo);
    private static AadAuthority();
    [CompilerGeneratedAttribute]
internal virtual string get_TenantId();
    internal bool IsWorkAndSchoolOnly();
    internal bool IsConsumers();
    internal static bool IsConsumers(string tenantId);
    internal bool IsCommonOrganizationsOrConsumersTenant();
    internal static bool IsCommonOrganizationsOrConsumersTenant(string tenantId);
    internal bool IsOrganizationsTenantWithMsaPassthroughEnabled(bool isMsaPassthrough, string accountTenantId);
    internal bool IsCommonOrOrganizationsTenant();
    internal static bool IsCommonOrOrganizationsTenant(string tenantId);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Instance.AdfsAuthority : Authority {
    private static string TokenEndpointTemplate;
    private static string AuthorizationEndpointTemplate;
    private static string DeviceCodeEndpointTemplate;
    internal string TenantId { get; }
    public AdfsAuthority(AuthorityInfo authorityInfo);
    internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal virtual string get_TenantId();
}
[DebuggerDisplayAttribute("{AuthorityInfo.CanonicalAuthority}")]
internal abstract class Microsoft.Identity.Client.Instance.Authority : object {
    [CompilerGeneratedAttribute]
private AuthorityInfo <AuthorityInfo>k__BackingField;
    public AuthorityInfo AuthorityInfo { get; }
    internal string TenantId { get; }
    protected Authority(AuthorityInfo authorityInfo);
    [CompilerGeneratedAttribute]
public AuthorityInfo get_AuthorityInfo();
    public static Task`1<Authority> CreateAuthorityForRequestAsync(RequestContext requestContext, AuthorityInfo requestAuthorityInfo, IAccount account);
    public static Authority CreateAuthority(string authority, bool validateAuthority);
    public static Authority CreateAuthority(AuthorityInfo authorityInfo);
    internal static Authority CreateAuthorityWithTenant(AuthorityInfo authorityInfo, string tenantId);
    internal static Authority CreateAuthorityWithEnvironment(AuthorityInfo authorityInfo, string environment);
    internal abstract virtual string get_TenantId();
    internal abstract virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal abstract virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal abstract virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal abstract virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    internal static string GetEnvironment(string authority);
}
internal class Microsoft.Identity.Client.Instance.AuthorityManager : object {
    private static ConcurrentHashSet`1<string> s_validatedEnvironments;
    private RequestContext _requestContext;
    private Authority _initialAuthority;
    private Authority _currentAuthority;
    private bool _instanceDiscoveryAndValidationExecuted;
    private InstanceDiscoveryMetadataEntry _metadata;
    public Authority OriginalAuthority { get; }
    public Authority Authority { get; }
    public AuthorityManager(RequestContext requestContext, Authority initialAuthority);
    private static AuthorityManager();
    public Authority get_OriginalAuthority();
    public Authority get_Authority();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.AuthorityManager/<GetInstanceDiscoveryEntryAsync>d__11")]
public Task`1<InstanceDiscoveryMetadataEntry> GetInstanceDiscoveryEntryAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.AuthorityManager/<RunInstanceDiscoveryAndValidationAsync>d__12")]
public Task RunInstanceDiscoveryAndValidationAsync();
    public static void ClearValidationCache();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.AuthorityManager/<ValidateAuthorityAsync>d__14")]
private Task ValidateAuthorityAsync(Authority authority);
}
internal class Microsoft.Identity.Client.Instance.B2CAuthority : AadAuthority {
    public static string Prefix;
    public static string B2CCanonicalAuthorityTemplate;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal string TenantId { get; }
    internal B2CAuthority(AuthorityInfo authorityInfo);
    [CompilerGeneratedAttribute]
internal virtual string get_TenantId();
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
}
internal class Microsoft.Identity.Client.Instance.CiamAuthority : AadAuthority {
    internal CiamAuthority(AuthorityInfo authorityInfo);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal static Uri TransformAuthority(Uri ciamAuthority);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.IInstanceDiscoveryManager {
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo authorityinfo, IEnumerable`1<string> existingEnvironmentsInCache, RequestContext requestContext);
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryAsync(AuthorityInfo authorityinfo, RequestContext requestContext, bool forceValidation);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.IKnownMetadataProvider {
    public abstract virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, IEnumerable`1<string> existingEnvironmentsInCache, ILoggerAdapter logger);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.INetworkCacheMetadataProvider {
    public abstract virtual void AddMetadata(string environment, InstanceDiscoveryMetadataEntry entry);
    public abstract virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, ILoggerAdapter logger);
    public abstract virtual void Clear();
}
internal interface Microsoft.Identity.Client.Instance.Discovery.INetworkMetadataProvider {
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager : object {
    private IHttpManager _httpManager;
    private IUserMetadataProvider _userMetadataProvider;
    private IKnownMetadataProvider _knownMetadataProvider;
    private INetworkCacheMetadataProvider _networkCacheMetadataProvider;
    private INetworkMetadataProvider _networkMetadataProvider;
    private IRegionDiscoveryProvider _regionDiscoveryProvider;
    public InstanceDiscoveryManager(IHttpManager httpManager, bool shouldClearCaches, InstanceDiscoveryResponse userProvidedInstanceDiscoveryResponse, Uri userProvidedInstanceDiscoveryUri);
    public InstanceDiscoveryManager(IHttpManager httpManager, bool shouldClearCaches, IUserMetadataProvider userMetadataProvider, Uri userProvidedInstanceDiscoveryUri, IKnownMetadataProvider knownMetadataProvider, INetworkCacheMetadataProvider networkCacheMetadataProvider, INetworkMetadataProvider networkMetadataProvider, IRegionDiscoveryProvider regionDiscoveryProvider);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager/<GetMetadataEntryTryAvoidNetworkAsync>d__8")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo authorityInfo, IEnumerable`1<string> existingEnvironmentsInCache, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager/<GetMetadataEntryAsync>d__9")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryAsync(AuthorityInfo authorityInfo, RequestContext requestContext, bool forceValidation);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager/<FetchNetworkMetadataOrFallbackAsync>d__10")]
private Task`1<InstanceDiscoveryMetadataEntry> FetchNetworkMetadataOrFallbackAsync(RequestContext requestContext, Uri authorityUri);
    internal void AddTestValueToStaticProvider(string environment, InstanceDiscoveryMetadataEntry entry);
    private static InstanceDiscoveryMetadataEntry CreateEntryForSingleAuthority(Uri authority);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryMetadataEntry : object {
    [CompilerGeneratedAttribute]
private string <PreferredNetwork>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredCache>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    [JsonPropertyAttribute("preferred_network")]
public string PreferredNetwork { get; public set; }
    [JsonPropertyAttribute("preferred_cache")]
public string PreferredCache { get; public set; }
    [JsonPropertyAttribute("aliases")]
public String[] Aliases { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PreferredNetwork();
    [CompilerGeneratedAttribute]
public void set_PreferredNetwork(string value);
    [CompilerGeneratedAttribute]
public string get_PreferredCache();
    [CompilerGeneratedAttribute]
public void set_PreferredCache(string value);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
public void set_Aliases(String[] value);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryResponse : OAuth2ResponseBase {
    [CompilerGeneratedAttribute]
private string <TenantDiscoveryEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceDiscoveryMetadataEntry[] <Metadata>k__BackingField;
    [JsonPropertyAttribute("tenant_discovery_endpoint")]
public string TenantDiscoveryEndpoint { get; public set; }
    [JsonPropertyAttribute("metadata")]
public InstanceDiscoveryMetadataEntry[] Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TenantDiscoveryEndpoint();
    [CompilerGeneratedAttribute]
public void set_TenantDiscoveryEndpoint(string value);
    [CompilerGeneratedAttribute]
public InstanceDiscoveryMetadataEntry[] get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(InstanceDiscoveryMetadataEntry[] value);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.IUserMetadataProvider {
    public abstract virtual InstanceDiscoveryMetadataEntry GetMetadataOrThrow(string environment, ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.Instance.Discovery.KnownMetadataProvider : object {
    private static IDictionary`2<string, InstanceDiscoveryMetadataEntry> s_knownEntries;
    private static ISet`1<string> s_knownEnvironments;
    private static ISet`1<string> s_knownPublicEnvironments;
    private static KnownMetadataProvider();
    public static bool IsPublicEnvironment(string environment);
    public sealed virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, IEnumerable`1<string> existingEnvironmentsInCache, ILoggerAdapter logger);
    public static bool IsKnownEnvironment(string environment);
    public static bool TryGetKnownEnviromentPreferredNetwork(string environment, String& preferredNetworkEnvironment);
    public static IDictionary`2<string, InstanceDiscoveryMetadataEntry> GetAllEntriesForTest();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddToKnownCache|3_0(InstanceDiscoveryMetadataEntry entry);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddToPublicEnvironment|3_1(InstanceDiscoveryMetadataEntry entry);
}
internal class Microsoft.Identity.Client.Instance.Discovery.NetworkCacheMetadataProvider : object {
    private static ConcurrentDictionary`2<string, InstanceDiscoveryMetadataEntry> s_cache;
    private static NetworkCacheMetadataProvider();
    public sealed virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, ILoggerAdapter logger);
    public sealed virtual void AddMetadata(string environment, InstanceDiscoveryMetadataEntry entry);
    public sealed virtual void Clear();
}
internal class Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider : object {
    private IHttpManager _httpManager;
    private INetworkCacheMetadataProvider _networkCacheMetadataProvider;
    private Uri _userProvidedInstanceDiscoveryUri;
    public NetworkMetadataProvider(IHttpManager httpManager, INetworkCacheMetadataProvider networkCacheMetadataProvider, Uri userProvidedInstanceDiscoveryUri);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider/<GetMetadataAsync>d__4")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
    private void CacheInstanceDiscoveryMetadata(InstanceDiscoveryResponse instanceDiscoveryResponse);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider/<FetchAllDiscoveryMetadataAsync>d__6")]
private Task`1<InstanceDiscoveryResponse> FetchAllDiscoveryMetadataAsync(Uri authority, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider/<SendInstanceDiscoveryRequestAsync>d__7")]
private Task`1<InstanceDiscoveryResponse> SendInstanceDiscoveryRequestAsync(Uri authority, RequestContext requestContext);
    private Uri ComputeHttpEndpoint(Uri authority, RequestContext requestContext);
    private static string BuildAuthorizeEndpoint(Uri authority);
    private static string GetTenant(Uri uri);
}
internal class Microsoft.Identity.Client.Instance.Discovery.UserMetadataProvider : object {
    private IDictionary`2<string, InstanceDiscoveryMetadataEntry> _entries;
    public UserMetadataProvider(InstanceDiscoveryResponse instanceDiscoveryResponse);
    public sealed virtual InstanceDiscoveryMetadataEntry GetMetadataOrThrow(string environment, ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.Instance.DstsAuthority : Authority {
    public static string DstsCanonicalAuthorityTemplate;
    private static string TokenEndpointTemplate;
    private static string AuthorizationEndpointTemplate;
    private static string DeviceCodeEndpointTemplate;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal string TenantId { get; }
    public DstsAuthority(AuthorityInfo authorityInfo);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    [CompilerGeneratedAttribute]
internal virtual string get_TenantId();
}
internal class Microsoft.Identity.Client.Instance.GenericAuthority : Authority {
    internal string TenantId { get; }
    internal GenericAuthority(AuthorityInfo authorityInfo);
    internal virtual string get_TenantId();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.GenericAuthority/<GetTokenEndpointAsync>d__3")]
internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.GenericAuthority/<GetAuthorizationEndpointAsync>d__4")]
internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Oidc.OidcMetadata : object {
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorizationEndpoint>k__BackingField;
    [JsonPropertyAttribute("token_endpoint")]
public string TokenEndpoint { get; public set; }
    [JsonPropertyAttribute("authorization_endpoint")]
public string AuthorizationEndpoint { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public string get_AuthorizationEndpoint();
    [CompilerGeneratedAttribute]
public void set_AuthorizationEndpoint(string value);
}
internal static class Microsoft.Identity.Client.Instance.Oidc.OidcRetrieverWithCache : object {
    private static ConcurrentDictionary`2<string, OidcMetadata> s_cache;
    private static SemaphoreSlim s_lockOidcRetrieval;
    private static OidcRetrieverWithCache();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Oidc.OidcRetrieverWithCache/<GetOidcAsync>d__2")]
public static Task`1<OidcMetadata> GetOidcAsync(string authority, RequestContext requestContext);
    public static void ResetCacheForTest();
}
internal class Microsoft.Identity.Client.Instance.Validation.AadAuthorityValidator : object {
    private RequestContext _requestContext;
    public AadAuthorityValidator(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Validation.AadAuthorityValidator/<ValidateAuthorityAsync>d__2")]
public sealed virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
internal class Microsoft.Identity.Client.Instance.Validation.AdfsAuthorityValidator : object {
    private RequestContext _requestContext;
    public AdfsAuthorityValidator(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Validation.AdfsAuthorityValidator/<ValidateAuthorityAsync>d__2")]
public sealed virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Validation.AdfsWebFingerResponse : OAuth2ResponseBase {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LinksList> <Links>k__BackingField;
    [JsonPropertyAttribute("subject")]
public string Subject { get; public set; }
    [JsonPropertyAttribute("links")]
public List`1<LinksList> Links { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public List`1<LinksList> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<LinksList> value);
}
internal class Microsoft.Identity.Client.Instance.Validation.AdfsWebFingerResponseClaim : OAuth2ResponseBaseClaim {
    public static string Subject;
    public static string Links;
    public static string Rel;
    public static string Href;
}
internal interface Microsoft.Identity.Client.Instance.Validation.IAuthorityValidator {
    public abstract virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Validation.LinksList : object {
    [CompilerGeneratedAttribute]
private string <Rel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Href>k__BackingField;
    [JsonPropertyAttribute("rel")]
public string Rel { get; public set; }
    [JsonPropertyAttribute("href")]
public string Href { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Rel();
    [CompilerGeneratedAttribute]
public void set_Rel(string value);
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public void set_Href(string value);
}
internal class Microsoft.Identity.Client.Instance.Validation.NullAuthorityValidator : object {
    public sealed virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
internal class Microsoft.Identity.Client.Internal.AuthCodeRequestComponent : object {
    private AuthenticationRequestParameters _requestParams;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private IServiceBundle _serviceBundle;
    public AuthCodeRequestComponent(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<FetchAuthCodeAndPkceVerifierAsync>d__4")]
public sealed virtual Task`1<Tuple`2<AuthorizationResult, string>> FetchAuthCodeAndPkceVerifierAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<GetAuthorizationUriWithoutPkceAsync>d__5")]
public sealed virtual Task`1<Uri> GetAuthorizationUriWithoutPkceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<GetAuthorizationUriWithPkceAsync>d__6")]
public Task`1<Uri> GetAuthorizationUriWithPkceAsync(string codeVerifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<FetchAuthCodeAndPkceInternalAsync>d__7")]
private Task`1<Tuple`2<AuthorizationResult, string>> FetchAuthCodeAndPkceInternalAsync(IWebUI webUi, CancellationToken cancellationToken);
    private Tuple`2<Uri, string> CreateAuthorizationUriWithCodeChallenge(string authEndpoint, string codeVerifier);
    private Tuple`3<Uri, string, string> CreateAuthorizationUri(string authEndpoint, bool addPkceAndState);
    private UriBuilder CreateInteractiveRequestParameters(string authEndpoint, IDictionary`2<string, string> requestParameters);
    private Dictionary`2<string, string> CreateAuthorizationRequestParameters(Uri redirectUriOverride);
    private static void CheckForDuplicateQueryParameters(IDictionary`2<string, string> queryParamsDictionary, IDictionary`2<string, string> requestParameters);
    private void VerifyAuthorizationResult(AuthorizationResult authorizationResult, string originalState);
    private IWebUI CreateWebAuthenticationDialog();
}
internal class Microsoft.Identity.Client.Internal.Broker.BrokerInteractiveRequestComponent : object {
    [CompilerGeneratedAttribute]
private IBroker <Broker>k__BackingField;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private string _optionalBrokerInstallUrl;
    private AuthenticationRequestParameters _authenticationRequestParameters;
    private IServiceBundle _serviceBundle;
    private ILoggerAdapter _logger;
    internal IBroker Broker { get; }
    public BrokerInteractiveRequestComponent(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters, IBroker broker, string optionalBrokerInstallUrl);
    [CompilerGeneratedAttribute]
internal IBroker get_Broker();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Broker.BrokerInteractiveRequestComponent/<FetchTokensAsync>d__9")]
public sealed virtual Task`1<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
    internal void ValidateResponseFromBroker(MsalTokenResponse msalTokenResponse);
    public static bool IsBrokerRequiredAuthCode(string authCode, String& installationUri);
    private static string ExtractAppLink(string authCode);
}
internal class Microsoft.Identity.Client.Internal.Broker.BrokerParameter : object {
    public static string Authority;
    public static string ClientId;
    public static string Scope;
    public static string ExtraOidcScopes;
    public static string OidcScopesValue;
    public static string RedirectUri;
    public static string BrokerKey;
    public static string ClientVersion;
    public static string MsgProtocolVersion;
    public static string MsgProtocolVersion3;
    public static string SkipCache;
    public static string AppLink;
    public static string IsSilentBrokerRequest;
    public static string CorrelationId;
    public static string ExtraQp;
    public static string HomeAccountId;
    public static string LocalAccountId;
    public static string Username;
    public static string IntuneEnrollmentIds;
    public static string IntuneMamResource;
    public static string ClientCapabilities;
    public static string ClientAppName;
    public static string ClientAppVersion;
    public static string Claims;
    public static string ExtraConsentScopes;
    public static string Prompt;
    public static string BrokerAccountName;
    public static string ForceRefresh;
    public static string Force;
    public static string BrokerInstallUrl;
    public static string UriSchemeBrokerV2;
    public static string UriSchemeBrokerV3;
    public static string AuthCodePrefixForEmbeddedWebviewBrokerInstallRequired;
}
internal static class Microsoft.Identity.Client.Internal.Broker.BrokerResponseConst : object {
    public static string ErrorMetadata;
    public static string BrokerErrorDomain;
    public static string BrokerErrorCode;
    public static string BrokerErrorDescription;
    public static string BrokerSubError;
    public static string BrokerHttpHeaders;
    public static string BrokerHttpBody;
    public static string BrokerHttpStatusCode;
    public static string BrokerErrorMessage;
    public static string Authority;
    public static string AccessToken;
    public static string ClientId;
    public static string RefreshToken;
    public static string IdToken;
    public static string Bearer;
    public static string CorrelationId;
    public static string Scope;
    public static string AndroidScopes;
    public static string ExpiresOn;
    public static string ExtendedExpiresOn;
    public static string ClientInfo;
    public static string Account;
    public static string HomeAccountId;
    public static string LocalAccountId;
    public static string TenantId;
    public static string UserName;
    public static string iOSBrokerNonce;
    public static string iOSBrokerTenantId;
    public static string Environment;
    public static string iOSBrokerUserCancellationErrorCode;
    public static string iOSBrokerProtectionPoliciesRequiredErrorCode;
    public static string TokenType;
    public static string AndroidNoTokenFound;
    public static string AndroidNoAccountFound;
    public static string AndroidUnauthorizedClient;
    public static string AndroidInvalidRefreshToken;
    public static string AndroidProtectionPolicyRequired;
}
internal interface Microsoft.Identity.Client.Internal.Broker.IBroker {
    public bool IsPopSupported { get; }
    public abstract virtual bool IsBrokerInstalledAndInvokable(AuthorityType authorityType);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters);
    public abstract virtual IReadOnlyDictionary`2<string, string> GetSsoPolicyHeaders();
    public abstract virtual void HandleInstallUrl(string appLink);
    public abstract virtual Task`1<IReadOnlyList`1<IAccount>> GetAccountsAsync(string clientId, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager);
    public abstract virtual Task RemoveAccountAsync(ApplicationConfiguration appConfig, IAccount account);
    public abstract virtual bool get_IsPopSupported();
}
internal interface Microsoft.Identity.Client.Internal.Broker.ITokenRequestComponent {
    public abstract virtual Task`1<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.Broker.NullBroker : object {
    private ILoggerAdapter _logger;
    public bool IsPopSupported { get; }
    public NullBroker(ILoggerAdapter logger);
    public sealed virtual bool get_IsPopSupported();
    public virtual bool IsBrokerInstalledAndInvokable(AuthorityType authorityType);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public sealed virtual void HandleInstallUrl(string appLink);
    public sealed virtual Task RemoveAccountAsync(ApplicationConfiguration appConfig, IAccount account);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public sealed virtual Task`1<IReadOnlyList`1<IAccount>> GetAccountsAsync(string clientID, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetSsoPolicyHeaders();
}
internal static class Microsoft.Identity.Client.Internal.ClaimsHelper : object {
    private static string AccessTokenClaim;
    private static string XmsClientCapability;
    internal static string GetMergedClaimsAndClientCapabilities(string claims, IEnumerable`1<string> clientCapabilities);
    internal static JObject MergeClaimsIntoCapabilityJson(string claims, JObject capabilitiesJson);
    private static JObject CreateClientCapabilitiesRequestJson(IEnumerable`1<string> clientCapabilities);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.CertificateAndClaimsClientCredential : object {
    private IDictionary`2<string, string> _claimsToSign;
    private bool _appendDefaultClaims;
    private string _base64EncodedThumbprint;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public X509Certificate2 Certificate { get; }
    public AssertionType AssertionType { get; }
    public CertificateAndClaimsClientCredential(X509Certificate2 certificate, IDictionary`2<string, string> claimsToSign, bool appendDefaultClaims);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    public sealed virtual AssertionType get_AssertionType();
    public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2AndPss, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.CertificateClientCredential : CertificateAndClaimsClientCredential {
    public CertificateClientCredential(X509Certificate2 certificate);
}
internal interface Microsoft.Identity.Client.Internal.ClientCredential.IClientCredential {
    public AssertionType AssertionType { get; }
    public abstract virtual AssertionType get_AssertionType();
    public abstract virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.SecretStringClientCredential : object {
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    internal string Secret { get; }
    public AssertionType AssertionType { get; }
    public SecretStringClientCredential(string secret);
    [CompilerGeneratedAttribute]
internal string get_Secret();
    public sealed virtual AssertionType get_AssertionType();
    public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.SignedAssertionClientCredential : object {
    private string _signedAssertion;
    public AssertionType AssertionType { get; }
    public SignedAssertionClientCredential(string signedAssertion);
    public sealed virtual AssertionType get_AssertionType();
    public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.SignedAssertionDelegateClientCredential : object {
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<string>> <_signedAssertionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<AssertionRequestOptions, Task`1<string>> <_signedAssertionWithInfoDelegate>k__BackingField;
    internal Func`2<CancellationToken, Task`1<string>> _signedAssertionDelegate { get; }
    internal Func`2<AssertionRequestOptions, Task`1<string>> _signedAssertionWithInfoDelegate { get; }
    public AssertionType AssertionType { get; }
    [EditorBrowsableAttribute("1")]
public SignedAssertionDelegateClientCredential(Func`2<CancellationToken, Task`1<string>> signedAssertionDelegate);
    public SignedAssertionDelegateClientCredential(Func`2<AssertionRequestOptions, Task`1<string>> signedAssertionDelegate);
    [CompilerGeneratedAttribute]
internal Func`2<CancellationToken, Task`1<string>> get__signedAssertionDelegate();
    [CompilerGeneratedAttribute]
internal Func`2<AssertionRequestOptions, Task`1<string>> get__signedAssertionWithInfoDelegate();
    public sealed virtual AssertionType get_AssertionType();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.ClientCredential.SignedAssertionDelegateClientCredential/<AddConfidentialClientParametersAsync>d__10")]
public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, bool useSha2, CancellationToken cancellationToken);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Internal.ClientInfo : object {
    [CompilerGeneratedAttribute]
private string <UniqueObjectIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueTenantIdentifier>k__BackingField;
    [JsonPropertyAttribute("uid")]
public string UniqueObjectIdentifier { get; public set; }
    [JsonPropertyAttribute("utid")]
public string UniqueTenantIdentifier { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UniqueObjectIdentifier();
    [CompilerGeneratedAttribute]
public void set_UniqueObjectIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueTenantIdentifier();
    [CompilerGeneratedAttribute]
public void set_UniqueTenantIdentifier(string value);
    public static ClientInfo CreateFromJson(string clientInfo);
    public string ToAccountIdentifier();
}
internal static class Microsoft.Identity.Client.Internal.ClientInfoClaim : object {
    public static string UniqueIdentifier;
    public static string UniqueTenantIdentifier;
}
internal static class Microsoft.Identity.Client.Internal.Constants : object {
    public static string MsAppScheme;
    public static int ExpirationMarginInMinutes;
    public static int CodeVerifierLength;
    public static int CodeVerifierByteSize;
    public static string DefaultRedirectUri;
    public static string NativeClientRedirectUri;
    public static string LocalHostRedirectUri;
    public static string DefaultConfidentialClientRedirectUri;
    public static string DefaultRealm;
    public static string MsaTenantId;
    public static string ConsumerTenant;
    public static string OrganizationsTenant;
    public static string CommonTenant;
    public static string UserRealmMsaDomainName;
    public static string CcsRoutingHintHeader;
    public static string AadThrottledErrorCode;
    public static int DefaultJitterRangeInSeconds;
    public static TimeSpan AccessTokenExpirationBuffer;
    public static string EnableSpaAuthCode;
    public static string PoPTokenType;
    public static string PoPAuthHeaderPrefix;
    public static string RequestConfirmation;
    public static string BearerAuthHeaderPrefix;
    public static string ManagedIdentityClientId;
    public static string ManagedIdentityObjectId;
    public static string ManagedIdentityResourceId;
    public static string ManagedIdentityDefaultClientId;
    public static string ManagedIdentityDefaultTenant;
    public static string CiamAuthorityHostSuffix;
    public static int CallerSdkIdMaxLength;
    public static int CallerSdkVersionMaxLength;
    public static string WellKnownOpenIdConfigurationPath;
    public static string OpenIdConfigurationEndpoint;
    public static string Tenant;
    public static string TenantId;
    private static Constants();
    public static string FormatEnterpriseRegistrationOnPremiseUri(string domain);
    public static string FormatEnterpriseRegistrationInternetUri(string domain);
    public static string FormatAdfsWebFingerUrl(string host, string resource);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Internal.DeviceCodeResponse : OAuth2ResponseBase {
    [CompilerGeneratedAttribute]
private string <UserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUri>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonPropertyAttribute("user_code")]
public string UserCode { get; public set; }
    [JsonPropertyAttribute("device_code")]
public string DeviceCode { get; public set; }
    [JsonPropertyAttribute("verification_url")]
public string VerificationUrl { get; public set; }
    [JsonPropertyAttribute("verification_uri")]
public string VerificationUri { get; public set; }
    [JsonPropertyAttribute("expires_in")]
public long ExpiresIn { get; public set; }
    [JsonPropertyAttribute("interval")]
public long Interval { get; public set; }
    [JsonPropertyAttribute("message")]
public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UserCode();
    [CompilerGeneratedAttribute]
public void set_UserCode(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceCode();
    [CompilerGeneratedAttribute]
public void set_DeviceCode(string value);
    [CompilerGeneratedAttribute]
public string get_VerificationUrl();
    [CompilerGeneratedAttribute]
public void set_VerificationUrl(string value);
    [CompilerGeneratedAttribute]
public string get_VerificationUri();
    [CompilerGeneratedAttribute]
public void set_VerificationUri(string value);
    [CompilerGeneratedAttribute]
public long get_ExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExpiresIn(long value);
    [CompilerGeneratedAttribute]
public long get_Interval();
    [CompilerGeneratedAttribute]
public void set_Interval(long value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public DeviceCodeResult GetResult(string clientId, ISet`1<string> scopes);
}
internal interface Microsoft.Identity.Client.Internal.IAuthCodeRequestComponent {
    public abstract virtual Task`1<Tuple`2<AuthorizationResult, string>> FetchAuthCodeAndPkceVerifierAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Uri> GetAuthorizationUriWithoutPkceAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.IdToken : object {
    private static string DefaultIssuser;
    [CompilerGeneratedAttribute]
private string <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField;
    public string ObjectId { get; private set; }
    public string Subject { get; private set; }
    public string TenantId { get; private set; }
    public string PreferredUsername { get; private set; }
    public string Name { get; private set; }
    public string Email { get; private set; }
    public string Upn { get; private set; }
    public string GivenName { get; private set; }
    public string FamilyName { get; private set; }
    public ClaimsPrincipal ClaimsPrincipal { get; private set; }
    [CompilerGeneratedAttribute]
public string get_ObjectId();
    [CompilerGeneratedAttribute]
private void set_ObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_PreferredUsername();
    [CompilerGeneratedAttribute]
private void set_PreferredUsername(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Email();
    [CompilerGeneratedAttribute]
private void set_Email(string value);
    [CompilerGeneratedAttribute]
public string get_Upn();
    [CompilerGeneratedAttribute]
private void set_Upn(string value);
    [CompilerGeneratedAttribute]
public string get_GivenName();
    [CompilerGeneratedAttribute]
private void set_GivenName(string value);
    [CompilerGeneratedAttribute]
public string get_FamilyName();
    [CompilerGeneratedAttribute]
private void set_FamilyName(string value);
    public string GetUniqueId();
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
private void set_ClaimsPrincipal(ClaimsPrincipal value);
    private static IdToken ClaimsToToken(List`1<Claim> claims);
    public static IdToken Parse(string idToken);
    private static List`1<Claim> GetClaimsFromRawToken(Dictionary`2<string, object> idTokenClaims);
    private static void AddClaimsFromJToken(List`1<Claim> claims, string claimType, JToken jtoken, string issuer);
    private static void AddDefaultClaimFromJToken(List`1<Claim> claims, string claimType, JToken jtoken, string issuer);
    private static string GetClaimValueType(object obj);
    [CompilerGeneratedAttribute]
internal static string <ClaimsToToken>g__FindClaim|42_0(List`1<Claim> claims, string type);
}
internal static class Microsoft.Identity.Client.Internal.IdTokenClaim : object {
    public static string Issuer;
    public static string ObjectId;
    public static string Subject;
    public static string TenantId;
    public static string Version;
    public static string PreferredUsername;
    public static string Name;
    public static string Email;
    public static string HomeObjectId;
    public static string GivenName;
    public static string FamilyName;
    public static string Upn;
}
internal interface Microsoft.Identity.Client.Internal.IServiceBundle {
    public ApplicationConfiguration Config { get; }
    public ILoggerAdapter ApplicationLogger { get; }
    public IHttpManager HttpManager { get; }
    public IInstanceDiscoveryManager InstanceDiscoveryManager { get; }
    public IPlatformProxy PlatformProxy { get; }
    public IWsTrustWebRequestManager WsTrustWebRequestManager { get; }
    public IDeviceAuthManager DeviceAuthManager { get; }
    public IThrottlingProvider ThrottlingManager { get; }
    public IHttpTelemetryManager HttpTelemetryManager { get; }
    public abstract virtual ApplicationConfiguration get_Config();
    public abstract virtual ILoggerAdapter get_ApplicationLogger();
    public abstract virtual IHttpManager get_HttpManager();
    public abstract virtual IInstanceDiscoveryManager get_InstanceDiscoveryManager();
    public abstract virtual IPlatformProxy get_PlatformProxy();
    public abstract virtual IWsTrustWebRequestManager get_WsTrustWebRequestManager();
    public abstract virtual IDeviceAuthManager get_DeviceAuthManager();
    public abstract virtual IThrottlingProvider get_ThrottlingManager();
    public abstract virtual IHttpTelemetryManager get_HttpTelemetryManager();
    public abstract virtual void SetPlatformProxyForTest(IPlatformProxy platformProxy);
}
internal static class Microsoft.Identity.Client.Internal.JsonClaimValueTypes : object {
    public static string Json;
    public static string JsonArray;
    public static string JsonNull;
}
internal class Microsoft.Identity.Client.Internal.JsonWebToken : object {
    private static int MaxTokenLength;
    public static long JwtToAadLifetimeInSeconds;
    private IDictionary`2<string, string> _claimsToSign;
    private ICryptographyManager _cryptographyManager;
    private string _clientId;
    private string _audience;
    private bool _appendDefaultClaims;
    public JsonWebToken(ICryptographyManager cryptographyManager, string clientId, string audience);
    public JsonWebToken(ICryptographyManager cryptographyManager, string clientId, string audience, IDictionary`2<string, string> claimsToSign, bool appendDefaultClaims);
    private string CreateJsonPayload();
    public string Sign(X509Certificate2 certificate, bool sendX5C, bool useSha2AndPss);
    private static string CreateJsonHeader(X509Certificate2 certificate, bool sendX5C, bool useSha2AndPss);
    private static string ComputeCertThumbprint(X509Certificate2 certificate, bool useSha2);
    private string CreateJwtHeaderAndBody(X509Certificate2 certificate, bool addX5C, bool useSha2AndPss);
}
internal class Microsoft.Identity.Client.Internal.JsonWebTokenConstants : object {
    public static string Algorithm;
    public static string Type;
    public static string KeyId;
    public static string X509CertificateThumbprint;
    public static string X509CertificatePublicCertValue;
}
internal class Microsoft.Identity.Client.Internal.Logger.CallbackIdentityLogger : object {
    private LogCallback _logCallback;
    private string _correlationId;
    private string _clientInformation;
    private bool _piiLoggingEnabled;
    private LogLevel _minLogLevel;
    public CallbackIdentityLogger(LogCallback logCallback, string correlationId, string clientName, string clientVersion, bool enablePiiLogging, LogLevel minLogLevel);
    public sealed virtual bool IsEnabled(EventLogLevel eventLevel);
    public sealed virtual void Log(LogEntry entry);
    private static LogLevel GetLogLevel(EventLogLevel eventLogLevel);
}
internal class Microsoft.Identity.Client.Internal.Logger.CallbackIdentityLoggerAdapter : object {
    private string _correlationId;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    public bool PiiLoggingEnabled { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    public IIdentityLogger IdentityLogger { get; }
    internal CallbackIdentityLoggerAdapter(Guid correlationId, string clientName, string clientVersion, LogLevel logLevel, bool enablePiiLogging, bool isDefaultPlatformLoggingEnabled, LogCallback loggingCallback);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientVersion();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityLogger get_IdentityLogger();
    public sealed virtual bool IsLoggingEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public static ILoggerAdapter Create(Guid correlationId, ApplicationConfiguration config, bool isDefaultPlatformLoggingEnabled);
    public sealed virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public sealed virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
internal class Microsoft.Identity.Client.Internal.Logger.DurationLogHelper : object {
    private ILoggerAdapter _logger;
    private string _measuredBlockName;
    private LogLevel _logLevel;
    private long _startMilliseconds;
    public DurationLogHelper(ILoggerAdapter logger, string measuredBlockName, LogLevel logLevel);
    public sealed virtual void Dispose();
}
internal class Microsoft.Identity.Client.Internal.Logger.IdentityLogger : object {
    private IIdentityLogger _identityLogger;
    private string _correlationId;
    private string _clientInformation;
    private bool _piiLoggingEnabled;
    internal IdentityLogger(IIdentityLogger identityLogger, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging);
    public sealed virtual bool IsEnabled(EventLogLevel eventLevel);
    public sealed virtual void Log(LogEntry entry);
}
internal class Microsoft.Identity.Client.Internal.Logger.IdentityLoggerAdapter : object {
    private string _correlationId;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    public bool PiiLoggingEnabled { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    public IIdentityLogger IdentityLogger { get; }
    internal IdentityLoggerAdapter(IIdentityLogger identityLogger, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientVersion();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityLogger get_IdentityLogger();
    public static ILoggerAdapter Create(Guid correlationId, ApplicationConfiguration config);
    public sealed virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public sealed virtual bool IsLoggingEnabled(LogLevel logLevel);
    public sealed virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public sealed virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
internal class Microsoft.Identity.Client.Internal.Logger.LoggerHelper : object {
    private static Lazy`1<string> s_msalVersionLazy;
    private static Lazy`1<string> s_runtimeVersionLazy;
    private static Lazy`1<ILoggerAdapter> s_nullLogger;
    private static Lazy`1<string> s_osLazy;
    private static Lazy`1<string> s_skuLazy;
    public static ILoggerAdapter NullLogger { get; }
    private static LoggerHelper();
    public static string GetClientInfo(string clientName, string clientVersion);
    public static ILoggerAdapter CreateLogger(Guid correlationId, ApplicationConfiguration config);
    public static ILoggerAdapter get_NullLogger();
    public static string FormatLogMessage(string message, bool piiEnabled, string correlationId, string clientInformation);
    internal static string GetPiiScrubbedExceptionDetails(Exception ex);
    public static DurationLogHelper LogBlockDuration(ILoggerAdapter logger, string measuredBlockName, LogLevel logLevel);
    public static DurationLogHelper LogMethodDuration(ILoggerAdapter logger, LogLevel logLevel, string methodName, string filePath);
    public static EventLogLevel GetEventLogLevel(LogLevel logLevel);
    public static string GetMessageToLog(string messageWithPii, string messageScrubbed, bool piiLoggingEnabled);
}
internal class Microsoft.Identity.Client.Internal.Logger.NullLogger : object {
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    public string ClientName { get; }
    public string ClientVersion { get; }
    public Guid CorrelationId { get; }
    public bool PiiLoggingEnabled { get; }
    public string ClientInformation { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public IIdentityLogger IdentityLogger { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientVersion();
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public string get_ClientInformation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityLogger get_IdentityLogger();
    public sealed virtual bool IsLoggingEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public sealed virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public sealed virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
internal static class Microsoft.Identity.Client.Internal.MsalIdHelper : object {
    private static Lazy`1<string> s_msalVersion;
    private static MsalIdHelper();
    public static Dictionary`2<string, string> GetMsalIdParameters(ILoggerAdapter logger);
    public static string GetMsalVersion();
}
internal static class Microsoft.Identity.Client.Internal.MsalIdParameter : object {
    public static string Product;
    public static string Version;
    public static string OS;
    public static string DeviceModel;
}
internal class Microsoft.Identity.Client.Internal.RequestContext : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerAdapter <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiEvent <ApiEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <UserCancellationToken>k__BackingField;
    public Guid CorrelationId { get; }
    public ILoggerAdapter Logger { get; }
    public IServiceBundle ServiceBundle { get; }
    public ApiEvent ApiEvent { get; public set; }
    public CancellationToken UserCancellationToken { get; }
    public RequestContext(IServiceBundle serviceBundle, Guid correlationId, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public ILoggerAdapter get_Logger();
    [CompilerGeneratedAttribute]
public IServiceBundle get_ServiceBundle();
    [CompilerGeneratedAttribute]
public ApiEvent get_ApiEvent();
    [CompilerGeneratedAttribute]
public void set_ApiEvent(ApiEvent value);
    [CompilerGeneratedAttribute]
public CancellationToken get_UserCancellationToken();
}
internal class Microsoft.Identity.Client.Internal.Requests.AuthCodeExchangeComponent : object {
    private AuthenticationRequestParameters _requestParams;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private string _authorizationCode;
    private string _pkceCodeVerifier;
    private TokenClient _tokenClient;
    private string _clientInfo;
    public AuthCodeExchangeComponent(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters, string authorizationCode, string pkceCodeVerifier, string clientInfo);
    public sealed virtual Task`1<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters();
    private void AddCcsHeadersToTokenClient();
}
internal class Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters : object {
    private IServiceBundle _serviceBundle;
    private AcquireTokenCommonParameters _commonParameters;
    private string _loginHint;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorityManager <AuthorityManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheSessionManager <CacheSessionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraQueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClaimsAndClientCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendX5C>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HomeAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private UserAssertion <UserAssertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongRunningOboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyValuePair`2<string, string>> <CcsRoutingHint>k__BackingField;
    public ApplicationConfiguration AppConfig { get; }
    public ApiIds ApiId { get; }
    public RequestContext RequestContext { get; }
    public AuthorityManager AuthorityManager { get; public set; }
    public Authority Authority { get; }
    public AuthorityInfo AuthorityInfo { get; }
    public AuthorityInfo AuthorityOverride { get; }
    public ICacheSessionManager CacheSessionManager { get; }
    public HashSet`1<string> Scope { get; }
    public Uri RedirectUri { get; public set; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; }
    public string ClaimsAndClientCapabilities { get; private set; }
    public Guid CorrelationId { get; }
    public X509Certificate2 MtlsCertificate { get; }
    public string Claims { get; }
    public IAuthenticationScheme AuthenticationScheme { get; }
    public IEnumerable`1<string> PersistedCacheParameters { get; }
    public bool SendX5C { get; public set; }
    public string LoginHint { get; public set; }
    public IAccount Account { get; public set; }
    public string HomeAccountId { get; }
    public Func`2<OnBeforeTokenRequestData, Task> OnBeforeTokenRequestHandler { get; }
    public IDictionary`2<string, string> ExtraHttpHeaders { get; }
    public bool IsClientCredentialRequest { get; }
    public PoPAuthenticationConfiguration PopAuthenticationConfiguration { get; }
    public UserAssertion UserAssertion { get; public set; }
    public string LongRunningOboCacheKey { get; public set; }
    public Nullable`1<KeyValuePair`2<string, string>> CcsRoutingHint { get; public set; }
    public AuthenticationRequestParameters(IServiceBundle serviceBundle, ITokenCacheInternal tokenCache, AcquireTokenCommonParameters commonParameters, RequestContext requestContext, Authority initialAuthority, string homeAccountId);
    public ApplicationConfiguration get_AppConfig();
    public ApiIds get_ApiId();
    [CompilerGeneratedAttribute]
public RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public AuthorityManager get_AuthorityManager();
    [CompilerGeneratedAttribute]
public void set_AuthorityManager(AuthorityManager value);
    public Authority get_Authority();
    public AuthorityInfo get_AuthorityInfo();
    public AuthorityInfo get_AuthorityOverride();
    [CompilerGeneratedAttribute]
public ICacheSessionManager get_CacheSessionManager();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Scope();
    [CompilerGeneratedAttribute]
public Uri get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(Uri value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtraQueryParameters();
    [CompilerGeneratedAttribute]
public string get_ClaimsAndClientCapabilities();
    [CompilerGeneratedAttribute]
private void set_ClaimsAndClientCapabilities(string value);
    public Guid get_CorrelationId();
    public X509Certificate2 get_MtlsCertificate();
    public string get_Claims();
    public IAuthenticationScheme get_AuthenticationScheme();
    public IEnumerable`1<string> get_PersistedCacheParameters();
    [CompilerGeneratedAttribute]
public bool get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(bool value);
    public string get_LoginHint();
    public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public string get_HomeAccountId();
    public Func`2<OnBeforeTokenRequestData, Task> get_OnBeforeTokenRequestHandler();
    public IDictionary`2<string, string> get_ExtraHttpHeaders();
    public bool get_IsClientCredentialRequest();
    public PoPAuthenticationConfiguration get_PopAuthenticationConfiguration();
    [CompilerGeneratedAttribute]
public UserAssertion get_UserAssertion();
    [CompilerGeneratedAttribute]
public void set_UserAssertion(UserAssertion value);
    [CompilerGeneratedAttribute]
public string get_LongRunningOboCacheKey();
    [CompilerGeneratedAttribute]
public void set_LongRunningOboCacheKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyValuePair`2<string, string>> get_CcsRoutingHint();
    [CompilerGeneratedAttribute]
public void set_CcsRoutingHint(Nullable`1<KeyValuePair`2<string, string>> value);
    public void LogParameters();
}
internal class Microsoft.Identity.Client.Internal.Requests.BrokerSilentStrategy : object {
    internal AuthenticationRequestParameters _authenticationRequestParameters;
    protected IServiceBundle _serviceBundle;
    private AcquireTokenSilentParameters _silentParameters;
    private SilentRequest _silentRequest;
    [CompilerGeneratedAttribute]
private IBroker <Broker>k__BackingField;
    private ILoggerAdapter _logger;
    internal IBroker Broker { get; }
    public BrokerSilentStrategy(SilentRequest request, IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters, IBroker broker);
    [CompilerGeneratedAttribute]
internal IBroker get_Broker();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.BrokerSilentStrategy/<ExecuteAsync>d__9")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.BrokerSilentStrategy/<SendTokenRequestToBrokerAsync>d__10")]
private Task`1<MsalTokenResponse> SendTokenRequestToBrokerAsync();
    internal void ValidateResponseFromBroker(MsalTokenResponse msalTokenResponse);
}
internal class Microsoft.Identity.Client.Internal.Requests.ByRefreshTokenRequest : RequestBase {
    private AcquireTokenByRefreshTokenParameters _refreshTokenParameters;
    public ByRefreshTokenRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByRefreshTokenParameters refreshTokenParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ByRefreshTokenRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private static Dictionary`2<string, string> GetBodyParameters(string refreshTokenSecret);
}
internal class Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest : RequestBase {
    private AcquireTokenForClientParameters _clientParameters;
    private static SemaphoreSlim s_semaphoreSlim;
    public ClientCredentialRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenForClientParameters clientParameters);
    private static ClientCredentialRequest();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<ExecuteAsync>d__3")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<GetAccessTokenAsync>d__4")]
private Task`1<AuthenticationResult> GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<SendTokenRequestToAppTokenProviderAsync>d__5")]
private Task`1<AuthenticationResult> SendTokenRequestToAppTokenProviderAsync(ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<GetCachedAccessTokenAsync>d__6")]
private Task`1<MsalAccessTokenCacheItem> GetCachedAccessTokenAsync();
    private AuthenticationResult CreateAuthenticationResultFromCache(MsalAccessTokenCacheItem cachedAccessTokenItem);
    protected virtual SortedSet`1<string> GetOverriddenScopes(ISet`1<string> inputScopes);
    private Dictionary`2<string, string> GetBodyParameters();
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.Requests.ConfidentialAuthCodeRequest : RequestBase {
    private AcquireTokenByAuthorizationCodeParameters _authorizationCodeParameters;
    public ConfidentialAuthCodeRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ConfidentialAuthCodeRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters();
}
internal class Microsoft.Identity.Client.Internal.Requests.DeviceCodeRequest : RequestBase {
    private AcquireTokenWithDeviceCodeParameters _deviceCodeParameters;
    public DeviceCodeRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenWithDeviceCodeParameters deviceCodeParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.DeviceCodeRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.DeviceCodeRequest/<WaitForTokenResponseAsync>d__3")]
private Task`1<MsalTokenResponse> WaitForTokenResponseAsync(DeviceCodeResult deviceCodeResult, CancellationToken cancellationToken);
    private static Dictionary`2<string, string> GetBodyParameters(DeviceCodeResult deviceCodeResult);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest : RequestBase {
    private CommonNonInteractiveHandler _commonNonInteractiveHandler;
    private AcquireTokenByIntegratedWindowsAuthParameters _integratedWindowsAuthParameters;
    public IntegratedWindowsAuthRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest/<ExecuteAsync>d__3")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest/<FetchAssertionFromWsTrustAsync>d__5")]
private Task`1<UserAssertion> FetchAssertionFromWsTrustAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest/<UpdateUsernameAsync>d__6")]
private Task UpdateUsernameAsync();
    private static Dictionary`2<string, string> GetAdditionalBodyParameters(UserAssertion userAssertion);
}
internal class Microsoft.Identity.Client.Internal.Requests.InteractiveRequest : RequestBase {
    private AuthenticationRequestParameters _requestParams;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private IServiceBundle _serviceBundle;
    private ILoggerAdapter _logger;
    private static string InstanceAwareParam;
    private IAuthCodeRequestComponent _authCodeRequestComponentOverride;
    private ITokenRequestComponent _authCodeExchangeComponentOverride;
    private ITokenRequestComponent _brokerInteractiveComponent;
    public InteractiveRequest(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters, IAuthCodeRequestComponent authCodeRequestComponentOverride, ITokenRequestComponent authCodeExchangeComponentOverride, ITokenRequestComponent brokerExchangeComponentOverride);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<ExecuteAsync>d__9")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<FetchTokensFromBrokerAsync>d__10")]
private Task`1<MsalTokenResponse> FetchTokensFromBrokerAsync(string brokerInstallUrl, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<GetTokenResponseAsync>d__11")]
private Task`1<MsalTokenResponse> GetTokenResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<RunBrokerWithInstallUriAsync>d__12")]
private Task`1<MsalTokenResponse> RunBrokerWithInstallUriAsync(string brokerInstallUri, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest : RequestBase {
    private AcquireTokenForManagedIdentityParameters _managedIdentityParameters;
    private static SemaphoreSlim s_semaphoreSlim;
    public ManagedIdentityAuthRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters);
    private static ManagedIdentityAuthRequest();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest/<ExecuteAsync>d__3")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest/<GetAccessTokenAsync>d__4")]
private Task`1<AuthenticationResult> GetAccessTokenAsync(CancellationToken cancellationToken, ILoggerAdapter logger);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest/<SendTokenRequestForManagedIdentityAsync>d__5")]
private Task`1<AuthenticationResult> SendTokenRequestForManagedIdentityAsync(ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest/<GetCachedAccessTokenAsync>d__6")]
private Task`1<MsalAccessTokenCacheItem> GetCachedAccessTokenAsync();
    private AuthenticationResult CreateAuthenticationResultFromCache(MsalAccessTokenCacheItem cachedAccessTokenItem);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest : RequestBase {
    private AcquireTokenOnBehalfOfParameters _onBehalfOfParameters;
    private string _ccsRoutingHint;
    public OnBehalfOfRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest/<ExecuteAsync>d__3")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest/<RefreshRtOrFetchNewAccessTokenAsync>d__4")]
private Task`1<AuthenticationResult> RefreshRtOrFetchNewAccessTokenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest/<FetchNewAccessTokenAsync>d__5")]
private Task`1<AuthenticationResult> FetchNewAccessTokenAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters();
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal abstract class Microsoft.Identity.Client.Internal.Requests.RequestBase : object {
    [CompilerGeneratedAttribute]
private AuthenticationRequestParameters <AuthenticationRequestParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    internal AuthenticationRequestParameters AuthenticationRequestParameters { get; }
    internal ICacheSessionManager CacheManager { get; }
    internal IServiceBundle ServiceBundle { get; }
    protected RequestBase(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, IAcquireTokenParameters acquireTokenParameters);
    [CompilerGeneratedAttribute]
internal AuthenticationRequestParameters get_AuthenticationRequestParameters();
    internal ICacheSessionManager get_CacheManager();
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    protected virtual SortedSet`1<string> GetOverriddenScopes(ISet`1<string> inputScopes);
    protected abstract virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<RunAsync>d__11")]
public Task`1<AuthenticationResult> RunAsync(CancellationToken cancellationToken);
    private void LogSuccessTelemetryToOtel(AuthenticationResult authenticationResult, ApiEvent apiEvent, long durationInUs);
    private void LogFailureTelemetryToOtel(string errorCodeToLog, ApiEvent apiEvent, CacheRefreshReason cacheRefreshReason);
    private Tuple`2<string, string> ParseScopesForTelemetry();
    private CacheLevel GetCacheLevel(AuthenticationResult authenticationResult);
    private static void LogMetricsFromAuthResult(AuthenticationResult authenticationResult, ILoggerAdapter logger);
    private void UpdateTelemetry(long elapsedMilliseconds, ApiEvent apiEvent, AuthenticationResult authenticationResult);
    protected virtual void EnrichTelemetryApiEvent(ApiEvent apiEvent);
    private ApiEvent InitializeApiEvent(string accountId);
    private void UpdateCallerSdkDetails(ApiEvent apiEvent);
    private AssertionType GetAssertionType();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<CacheTokenResponseAndCreateAuthenticationResultAsync>d__22")]
protected Task`1<AuthenticationResult> CacheTokenResponseAndCreateAuthenticationResultAsync(MsalTokenResponse msalTokenResponse);
    protected virtual void ValidateAccountIdentifiers(ClientInfo fromServer);
    protected Task ResolveAuthorityAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<SendTokenRequestAsync>d__25")]
internal Task`1<MsalTokenResponse> SendTokenRequestAsync(IDictionary`2<string, string> additionalBodyParameters, CancellationToken cancellationToken);
    protected Task`1<MsalTokenResponse> SendTokenRequestAsync(string tokenEndpoint, IDictionary`2<string, string> additionalBodyParameters, CancellationToken cancellationToken);
    private void InjectPcaSsoPolicyHeader(TokenClient tokenClient);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
    protected Nullable`1<KeyValuePair`2<string, string>> GetCcsUpnHeader(string upnHeader);
    private void LogRequestStarted(AuthenticationRequestParameters authenticationRequestParameters);
    private void LogReturnedToken(AuthenticationResult result);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<HandleTokenRefreshErrorAsync>d__32")]
internal Task`1<AuthenticationResult> HandleTokenRefreshErrorAsync(MsalServiceException e, MsalAccessTokenCacheItem cachedAccessTokenItem);
    private static RegionDetails CreateRegionDetails(ApiEvent apiEvent);
}
internal class Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy : object {
    [CompilerGeneratedAttribute]
private AuthenticationRequestParameters <AuthenticationRequestParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    private AcquireTokenSilentParameters _silentParameters;
    private static string TheOnlyFamilyId;
    private SilentRequest _silentRequest;
    private AuthenticationRequestParameters AuthenticationRequestParameters { get; }
    private ICacheSessionManager CacheManager { get; }
    protected IServiceBundle ServiceBundle { get; }
    public CacheSilentStrategy(SilentRequest request, IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters);
    [CompilerGeneratedAttribute]
private AuthenticationRequestParameters get_AuthenticationRequestParameters();
    private ICacheSessionManager get_CacheManager();
    [CompilerGeneratedAttribute]
protected IServiceBundle get_ServiceBundle();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<ExecuteAsync>d__12")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private void ThrowIfCurrentBrokerAccount();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<RefreshRtOrFailAsync>d__14")]
private Task`1<AuthenticationResult> RefreshRtOrFailAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<CreateAuthenticationResultAsync>d__15")]
private Task`1<AuthenticationResult> CreateAuthenticationResultAsync(MsalAccessTokenCacheItem cachedAccessTokenItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<TryGetTokenUsingFociAsync>d__16")]
private Task`1<MsalTokenResponse> TryGetTokenUsingFociAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<FindRefreshTokenOrFailAsync>d__17")]
private Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenOrFailAsync();
}
internal interface Microsoft.Identity.Client.Internal.Requests.Silent.ISilentAuthRequestStrategy {
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest : RequestBase {
    private AcquireTokenSilentParameters _silentParameters;
    private ISilentAuthRequestStrategy _clientStrategy;
    private Lazy`1<ISilentAuthRequestStrategy> _brokerStrategyLazy;
    private ILoggerAdapter _logger;
    public SilentRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters, ISilentAuthRequestStrategy clientStrategyOverride, ISilentAuthRequestStrategy brokerStrategyOverride);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<ExecuteAsync>d__5")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    internal Task`1<AuthenticationResult> CacheTokenResponseAndCreateAuthenticationResultAsync(MsalTokenResponse response);
    internal Task`1<AuthenticationResult> ExecuteTestAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<UpdateRequestWithAccountAsync>d__8")]
private Task UpdateRequestWithAccountAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<GetSingleAccountForLoginHintAsync>d__9")]
private Task`1<IAccount> GetSingleAccountForLoginHintAsync(string loginHint);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<GetAccountFromParamsOrLoginHintAsync>d__10")]
private Task`1<IAccount> GetAccountFromParamsOrLoginHintAsync(IAccount account, string loginHint);
    protected virtual void ValidateAccountIdentifiers(ClientInfo fromServer);
}
internal class Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest : RequestBase {
    private CommonNonInteractiveHandler _commonNonInteractiveHandler;
    private AcquireTokenByUsernamePasswordParameters _usernamePasswordParameters;
    private AuthenticationRequestParameters _requestParameters;
    private ILoggerAdapter _logger;
    public UsernamePasswordRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<ExecuteAsync>d__5")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<GetTokenResponseAsync>d__6")]
private Task`1<MsalTokenResponse> GetTokenResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<FetchAssertionFromWsTrustAsync>d__7")]
private Task`1<UserAssertion> FetchAssertionFromWsTrustAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<UpdateUsernameAsync>d__8")]
private Task UpdateUsernameAsync();
    private Dictionary`2<string, string> GetAdditionalBodyParameters(UserAssertion userAssertion);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.ServiceBundle : object {
    [CompilerGeneratedAttribute]
private ILoggerAdapter <ApplicationLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpManager <HttpManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceDiscoveryManager <InstanceDiscoveryManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IWsTrustWebRequestManager <WsTrustWebRequestManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlatformProxy <PlatformProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationConfiguration <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeviceAuthManager <DeviceAuthManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpTelemetryManager <HttpTelemetryManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IThrottlingProvider <ThrottlingManager>k__BackingField;
    public ILoggerAdapter ApplicationLogger { get; }
    public IHttpManager HttpManager { get; }
    public IInstanceDiscoveryManager InstanceDiscoveryManager { get; }
    public IWsTrustWebRequestManager WsTrustWebRequestManager { get; }
    public IPlatformProxy PlatformProxy { get; private set; }
    public ApplicationConfiguration Config { get; }
    public IDeviceAuthManager DeviceAuthManager { get; }
    public IHttpTelemetryManager HttpTelemetryManager { get; }
    public IThrottlingProvider ThrottlingManager { get; }
    internal ServiceBundle(ApplicationConfiguration config, bool shouldClearCaches);
    [CompilerGeneratedAttribute]
public sealed virtual ILoggerAdapter get_ApplicationLogger();
    [CompilerGeneratedAttribute]
public sealed virtual IHttpManager get_HttpManager();
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceDiscoveryManager get_InstanceDiscoveryManager();
    [CompilerGeneratedAttribute]
public sealed virtual IWsTrustWebRequestManager get_WsTrustWebRequestManager();
    [CompilerGeneratedAttribute]
public sealed virtual IPlatformProxy get_PlatformProxy();
    [CompilerGeneratedAttribute]
private void set_PlatformProxy(IPlatformProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual ApplicationConfiguration get_Config();
    [CompilerGeneratedAttribute]
public sealed virtual IDeviceAuthManager get_DeviceAuthManager();
    [CompilerGeneratedAttribute]
public sealed virtual IHttpTelemetryManager get_HttpTelemetryManager();
    [CompilerGeneratedAttribute]
public sealed virtual IThrottlingProvider get_ThrottlingManager();
    public static ServiceBundle Create(ApplicationConfiguration config);
    public sealed virtual void SetPlatformProxyForTest(IPlatformProxy platformProxy);
}
internal static class Microsoft.Identity.Client.Internal.SilentRequestHelper : object {
    internal static string MamEnrollmentIdKey;
    internal static string ProactiveRefreshServiceError;
    internal static string ProactiveRefreshGeneralError;
    internal static string ProactiveRefreshCancellationError;
    private static Random s_random;
    private static SilentRequestHelper();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.SilentRequestHelper/<RefreshAccessTokenAsync>d__4")]
internal static Task`1<MsalTokenResponse> RefreshAccessTokenAsync(MsalRefreshTokenCacheItem msalRefreshTokenItem, RequestBase request, AuthenticationRequestParameters authenticationRequestParameters, CancellationToken cancellationToken);
    private static Dictionary`2<string, string> GetBodyParameters(string refreshTokenSecret);
    internal static bool NeedsRefresh(MsalAccessTokenCacheItem oldAccessToken);
    internal static bool NeedsRefresh(MsalAccessTokenCacheItem oldAccessToken, Nullable`1& refreshOnWithJitter);
    internal static void ProcessFetchInBackground(MsalAccessTokenCacheItem oldAccessToken, Func`1<Task`1<AuthenticationResult>> fetchAction, ILoggerAdapter logger, IServiceBundle serviceBundle, ApiIds apiId, string callerSdkId, string callerSdkVersion);
    private static Nullable`1<DateTimeOffset> GetRefreshOnWithJitter(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
}
internal static class Microsoft.Identity.Client.Internal.XmlNamespace : object {
    public static XNamespace Wsdl;
    public static XNamespace Wsp;
    public static XNamespace Http;
    public static XNamespace Sp;
    public static XNamespace Sp2005;
    public static XNamespace Wsu;
    public static XNamespace Soap12;
    public static XNamespace Wsa10;
    public static XNamespace Trust;
    public static XNamespace Trust2005;
    public static XNamespace Issue;
    public static XNamespace Issue2005;
    public static XNamespace SoapEnvelope;
    private static XmlNamespace();
}
public class Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException : MsalServiceException {
    [CompilerGeneratedAttribute]
private string <Upn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountUserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorityUrl>k__BackingField;
    public string Upn { get; public set; }
    public string AccountUserId { get; public set; }
    public string TenantId { get; public set; }
    public string AuthorityUrl { get; public set; }
    public IntuneAppProtectionPolicyRequiredException(string errorCode, string errorMessage);
    [CompilerGeneratedAttribute]
public string get_Upn();
    [CompilerGeneratedAttribute]
public void set_Upn(string value);
    [CompilerGeneratedAttribute]
public string get_AccountUserId();
    [CompilerGeneratedAttribute]
public void set_AccountUserId(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_AuthorityUrl();
    [CompilerGeneratedAttribute]
public void set_AuthorityUrl(string value);
}
public interface Microsoft.Identity.Client.IPublicClientApplication {
    public bool IsSystemWebViewAvailable { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use iOSKeychainSecurityGroup instead (See https://aka.ms/msal-net-ios-keychain-security-group)", "True")]
public string KeychainSecurityGroup { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration", "True")]
public string iOSKeychainSecurityGroup { get; public set; }
    public abstract virtual bool get_IsSystemWebViewAvailable();
    public abstract virtual AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(IEnumerable`1<string> scopes);
    public abstract virtual AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    public abstract virtual AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password) instead.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, SecureString password);
    public abstract virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, string password);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenByUsernamePassword instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(IEnumerable`1<string> scopes, string username, SecureString securePassword);
    [ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes, string username);
    public abstract virtual string get_KeychainSecurityGroup();
    public abstract virtual string get_iOSKeychainSecurityGroup();
    public abstract virtual void set_iOSKeychainSecurityGroup(string value);
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.ITelemetryConfig {
    public TelemetryAudienceType AudienceType { get; }
    public string SessionId { get; }
    public Action`1<ITelemetryEventPayload> DispatchAction { get; }
    public abstract virtual TelemetryAudienceType get_AudienceType();
    public abstract virtual string get_SessionId();
    public abstract virtual Action`1<ITelemetryEventPayload> get_DispatchAction();
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.ITelemetryEventPayload {
    public string Name { get; }
    public IReadOnlyDictionary`2<string, bool> BoolValues { get; }
    public IReadOnlyDictionary`2<string, long> Int64Values { get; }
    public IReadOnlyDictionary`2<string, int> IntValues { get; }
    public IReadOnlyDictionary`2<string, string> StringValues { get; }
    public abstract virtual string get_Name();
    public abstract virtual IReadOnlyDictionary`2<string, bool> get_BoolValues();
    public abstract virtual IReadOnlyDictionary`2<string, long> get_Int64Values();
    public abstract virtual IReadOnlyDictionary`2<string, int> get_IntValues();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_StringValues();
    public abstract virtual string ToJsonString();
}
public interface Microsoft.Identity.Client.ITokenCache {
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetBeforeAccess(TokenCacheCallback beforeAccess);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetAfterAccess(TokenCacheCallback afterAccess);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetBeforeWrite(TokenCacheCallback beforeWrite);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetBeforeAccessAsync(Func`2<TokenCacheNotificationArgs, Task> beforeAccess);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetAfterAccessAsync(Func`2<TokenCacheNotificationArgs, Task> afterAccess);
    [EditorBrowsableAttribute("1")]
public abstract virtual void SetBeforeWriteAsync(Func`2<TokenCacheNotificationArgs, Task> beforeWrite);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.SerializeMsalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] SerializeMsalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.DeserializeMsalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.SerializeMsalV2 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] SerializeMsalV2();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.DeserializeMsalV2 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeMsalV2(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.SerializeAdalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] SerializeAdalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.DeserializeAdalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeAdalV3(Byte[] adalV3State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] Serialize();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void Deserialize(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual CacheData SerializeUnifiedAndAdalCache();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeUnifiedAndAdalCache(CacheData cacheData);
}
internal interface Microsoft.Identity.Client.ITokenCacheInternal {
    public OptionalSemaphoreSlim Semaphore { get; }
    public ILegacyCachePersistence LegacyPersistence { get; }
    public ITokenCacheAccessor Accessor { get; }
    public bool IsApplicationCache { get; }
    public abstract virtual OptionalSemaphoreSlim get_Semaphore();
    public abstract virtual ILegacyCachePersistence get_LegacyPersistence();
    public abstract virtual ITokenCacheAccessor get_Accessor();
    public abstract virtual Task RemoveAccountAsync(IAccount account, AuthenticationRequestParameters requestParameters);
    public abstract virtual Task`1<bool> StopLongRunningOboProcessAsync(string longRunningOboCacheKey, AuthenticationRequestParameters requestParameters);
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(AuthenticationRequestParameters requestParameters);
    public abstract virtual Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(AuthenticationRequestParameters requestParams, MsalTokenResponse response);
    public abstract virtual Task`1<MsalAccessTokenCacheItem> FindAccessTokenAsync(AuthenticationRequestParameters requestParams);
    public abstract virtual MsalIdTokenCacheItem GetIdTokenCacheItem(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public abstract virtual Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenAsync(AuthenticationRequestParameters requestParams, string familyId);
    public abstract virtual Task`1<Account> GetAccountAssociatedWithAccessTokenAsync(AuthenticationRequestParameters requestParameters, MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public abstract virtual Task`1<Nullable`1<bool>> IsFociMemberAsync(AuthenticationRequestParameters requestParams, string familyId);
    public abstract virtual void SetIosKeychainSecurityGroup(string securityGroup);
    public abstract virtual Task OnAfterAccessAsync(TokenCacheNotificationArgs args);
    public abstract virtual Task OnBeforeAccessAsync(TokenCacheNotificationArgs args);
    public abstract virtual Task OnBeforeWriteAsync(TokenCacheNotificationArgs args);
    public abstract virtual bool get_IsApplicationCache();
    public abstract virtual bool HasTokensNoLocks();
    public abstract virtual bool IsAppSubscribedToSerializationEvents();
}
public interface Microsoft.Identity.Client.ITokenCacheSerializer {
    public abstract virtual Byte[] SerializeMsalV3();
    public abstract virtual void DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    public abstract virtual Byte[] SerializeAdalV3();
    public abstract virtual void DeserializeAdalV3(Byte[] adalV3State);
    [ObsoleteAttribute("Support for the MSAL v2 token cache format will be dropped in the next major version", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Byte[] SerializeMsalV2();
    [ObsoleteAttribute("Support for the MSAL v2 token cache format will be dropped in the next major version", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void DeserializeMsalV2(Byte[] msalV2State);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use IAccount instead (See https://aka.ms/msal-net-2-released)", "True")]
public interface Microsoft.Identity.Client.IUser {
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.Username instead (See https://aka.ms/msal-net-2-released)", "True")]
public string DisplayableId { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.Username instead (See https://aka.ms/msal-net-2-released)", "True")]
public string Name { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.Environment instead to get the Identity Provider host (See https://aka.ms/msal-net-2-released)", "True")]
public string IdentityProvider { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.HomeAccountId.Identifier instead to get the user identifier (See https://aka.ms/msal-net-2-released)", "True")]
public string Identifier { get; }
    public abstract virtual string get_DisplayableId();
    public abstract virtual string get_Name();
    public abstract virtual string get_IdentityProvider();
    public abstract virtual string get_Identifier();
}
public enum Microsoft.Identity.Client.Kerberos.KerberosKeyTypes : Enum {
    public int value__;
    public static KerberosKeyTypes None;
    public static KerberosKeyTypes DecCbcCrc;
    public static KerberosKeyTypes DesCbcMd5;
    public static KerberosKeyTypes Aes128CtsHmacSha196;
    public static KerberosKeyTypes Aes256CtsHmacSha196;
}
public class Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket : object {
    [CompilerGeneratedAttribute]
private string <ClientKey>k__BackingField;
    [CompilerGeneratedAttribute]
private KerberosKeyTypes <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KerberosMessageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Realm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [JsonPropertyAttribute("clientKey")]
public string ClientKey { get; public set; }
    [JsonPropertyAttribute("keyType")]
public KerberosKeyTypes KeyType { get; public set; }
    [JsonPropertyAttribute("messageBuffer")]
public string KerberosMessageBuffer { get; public set; }
    [JsonPropertyAttribute("error")]
public string ErrorMessage { get; public set; }
    [JsonPropertyAttribute("realm")]
public string Realm { get; public set; }
    [JsonPropertyAttribute("sn")]
public string ServicePrincipalName { get; public set; }
    [JsonPropertyAttribute("cn")]
public string ClientName { get; public set; }
    public KerberosSupplementalTicket(string errorMessage);
    [CompilerGeneratedAttribute]
public string get_ClientKey();
    [CompilerGeneratedAttribute]
public void set_ClientKey(string value);
    [CompilerGeneratedAttribute]
public KerberosKeyTypes get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(KerberosKeyTypes value);
    [CompilerGeneratedAttribute]
public string get_KerberosMessageBuffer();
    [CompilerGeneratedAttribute]
public void set_KerberosMessageBuffer(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public string get_Realm();
    [CompilerGeneratedAttribute]
public void set_Realm(string value);
    [CompilerGeneratedAttribute]
public string get_ServicePrincipalName();
    [CompilerGeneratedAttribute]
public void set_ServicePrincipalName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    public virtual string ToString();
}
public static class Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager : object {
    private static int DefaultLogonId;
    private static string KerberosClaimType;
    private static string IdTokenAsRepTemplate;
    private static string AccessTokenAsRepTemplate;
    public static KerberosSupplementalTicket FromIdToken(string idToken);
    public static void SaveToWindowsTicketCache(KerberosSupplementalTicket ticket);
    public static void SaveToWindowsTicketCache(KerberosSupplementalTicket ticket, long logonId);
    public static Byte[] GetKerberosTicketFromWindowsTicketCache(string servicePrincipalName);
    public static Byte[] GetKerberosTicketFromWindowsTicketCache(string servicePrincipalName, long logonId);
    public static Byte[] GetKrbCred(KerberosSupplementalTicket ticket);
    internal static string GetKerberosTicketClaim(string servicePrincipalName, KerberosTicketContainer ticketContainer);
}
public enum Microsoft.Identity.Client.Kerberos.KerberosTicketContainer : Enum {
    public int value__;
    public static KerberosTicketContainer IdToken;
    public static KerberosTicketContainer AccessToken;
}
internal static class Microsoft.Identity.Client.KeyTokens : object {
    public static string MSAL;
}
public class Microsoft.Identity.Client.LogCallback : MulticastDelegate {
    public LogCallback(object object, IntPtr method);
    public virtual void Invoke(LogLevel level, string message, bool containsPii);
    public virtual IAsyncResult BeginInvoke(LogLevel level, string message, bool containsPii, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public class Microsoft.Identity.Client.Logger : object {
    [CompilerGeneratedAttribute]
private static bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <DefaultLoggingEnabled>k__BackingField;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
unknown static LogCallback LogCallback {public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static LogLevel Level { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static bool PiiLoggingEnabled { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static bool DefaultLoggingEnabled { get; public set; }
    public static void set_LogCallback(LogCallback value);
    public static LogLevel get_Level();
    public static void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public static bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public static void set_PiiLoggingEnabled(bool value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultLoggingEnabled();
    [CompilerGeneratedAttribute]
public static void set_DefaultLoggingEnabled(bool value);
}
public enum Microsoft.Identity.Client.LogLevel : Enum {
    public int value__;
    public static LogLevel Always;
    public static LogLevel Error;
    public static LogLevel Warning;
    public static LogLevel Info;
    public static LogLevel Verbose;
}
internal static class Microsoft.Identity.Client.LogMessages : object {
    public static string BeginningAcquireByRefreshToken;
    public static string NoScopesProvidedForRefreshTokenRequest;
    public static string CustomWebUiAcquiringAuthorizationCode;
    public static string CustomWebUiRedirectUriMatched;
    public static string CustomWebUiOperationCancelled;
    public static string CustomWebUiCallingAcquireAuthorizationCodeNoPii;
    public static string ClientAssertionDoesNotExistOrNearExpiry;
    public static string ReusingTheUnexpiredClientAssertion;
    public static string ResolvingAuthorityEndpointsTrue;
    public static string ResolvingAuthorityEndpointsFalse;
    public static string CheckMsalTokenResponseReturnedFromBroker;
    public static string UnknownErrorReturnedInBrokerResponse;
    public static string BrokerInvocationRequired;
    public static string AddBrokerInstallUrlToPayload;
    public static string BrokerInvocationNotRequired;
    public static string CanInvokeBrokerAcquireTokenWithBroker;
    public static string AuthenticationWithBrokerDidNotSucceed;
    public static string UserCancelledAuthentication;
    public static string AuthorizationResultWasNotSuccessful;
    public static string WsTrustRequestFailed;
    public static string ErrorReturnedInBrokerResponse(string error);
    public static string UsingXScopesForRefreshTokenRequest(int numScopes);
    public static string CustomWebUiCallingAcquireAuthorizationCodePii(Uri authorizationUri, Uri redirectUri);
}
internal abstract class Microsoft.Identity.Client.ManagedIdentity.AbstractManagedIdentity : object {
    protected RequestContext _requestContext;
    internal static string TimeoutError;
    internal ManagedIdentitySource _sourceType;
    private static string ManagedIdentityPrefix;
    protected AbstractManagedIdentity(RequestContext requestContext, ManagedIdentitySource sourceType);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.AbstractManagedIdentity/<AuthenticateAsync>d__5")]
public virtual Task`1<ManagedIdentityResponse> AuthenticateAsync(AcquireTokenForManagedIdentityParameters parameters, CancellationToken cancellationToken);
    internal virtual HttpClient GetHttpClientWithSslValidation(RequestContext requestContext);
    protected virtual Task`1<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
    protected abstract virtual ManagedIdentityRequest CreateRequest(string resource);
    protected ManagedIdentityResponse GetSuccessfulResponse(HttpResponse response);
    internal string GetMessageFromErrorResponse(HttpResponse response);
    private string ExtractErrorMessageFromManagedIdentityErrorResponse(ManagedIdentityErrorResponse managedIdentityErrorResponse);
    private string TryGetMessageFromNestedErrorResponse(string response);
    private void HandleException(Exception ex, ManagedIdentitySource managedIdentitySource, string additionalInfo);
    private static void CreateAndThrowException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource source);
}
internal class Microsoft.Identity.Client.ManagedIdentity.AppServiceManagedIdentitySource : AbstractManagedIdentity {
    private static string AppServiceMsiApiVersion;
    private static string SecretHeaderName;
    private Uri _endpoint;
    private string _secret;
    private AppServiceManagedIdentitySource(RequestContext requestContext, Uri endpoint, string secret);
    public static AbstractManagedIdentity Create(RequestContext requestContext);
    private static bool TryValidateEnvVars(string msiEndpoint, ILoggerAdapter logger, Uri& endpointUri);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
}
internal class Microsoft.Identity.Client.ManagedIdentity.AzureArcManagedIdentitySource : AbstractManagedIdentity {
    private static string ArcApiVersion;
    private static string AzureArc;
    private Uri _endpoint;
    private AzureArcManagedIdentitySource(Uri endpoint, RequestContext requestContext);
    public static AbstractManagedIdentity Create(RequestContext requestContext);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.AzureArcManagedIdentitySource/<HandleResponseAsync>d__6")]
protected virtual Task`1<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
    private void ValidateSplitChallenge(String[] splitChallenge);
    private MsalException CreateManagedIdentityException(string errorCode, string errorMessage);
    private bool IsValidPath(string path);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ManagedIdentityResponse> <>n__0(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ManagedIdentity.CloudShellManagedIdentitySource : AbstractManagedIdentity {
    private Uri _endpoint;
    private static string CloudShell;
    private CloudShellManagedIdentitySource(Uri endpoint, RequestContext requestContext);
    public static AbstractManagedIdentity Create(RequestContext requestContext);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
}
internal class Microsoft.Identity.Client.ManagedIdentity.EnvironmentVariables : object {
    public static string IdentityEndpoint { get; }
    public static string IdentityHeader { get; }
    public static string PodIdentityEndpoint { get; }
    public static string ImdsEndpoint { get; }
    public static string MsiEndpoint { get; }
    public static string IdentityServerThumbprint { get; }
    public static string get_IdentityEndpoint();
    public static string get_IdentityHeader();
    public static string get_PodIdentityEndpoint();
    public static string get_ImdsEndpoint();
    public static string get_MsiEndpoint();
    public static string get_IdentityServerThumbprint();
}
internal class Microsoft.Identity.Client.ManagedIdentity.ImdsManagedIdentitySource : AbstractManagedIdentity {
    private static Uri s_imdsEndpoint;
    private static string ImdsTokenPath;
    private static string ImdsApiVersion;
    private static string DefaultMessage;
    internal static string IdentityUnavailableError;
    internal static string GatewayError;
    private Uri _imdsEndpoint;
    internal ImdsManagedIdentitySource(RequestContext requestContext);
    private static ImdsManagedIdentitySource();
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.ImdsManagedIdentitySource/<HandleResponseAsync>d__9")]
protected virtual Task`1<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
    internal static string CreateRequestFailedMessage(HttpResponse response, string message);
    [CompilerGeneratedAttribute]
private string <.ctor>b__7_2();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ManagedIdentityResponse> <>n__0(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityClient : object {
    private static string WindowsHimdsFilePath;
    private static string LinuxHimdsFilePath;
    private AbstractManagedIdentity _identitySource;
    public ManagedIdentityClient(RequestContext requestContext);
    internal Task`1<ManagedIdentityResponse> SendTokenRequestForManagedIdentityAsync(AcquireTokenForManagedIdentityParameters parameters, CancellationToken cancellationToken);
    private static AbstractManagedIdentity SelectManagedIdentitySource(RequestContext requestContext);
    internal static ManagedIdentitySource GetManagedIdentitySource(ILoggerAdapter logger);
    private static bool ValidateAzureArcEnvironment(string identityEndpoint, string imdsEndpoint, ILoggerAdapter logger);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityErrorResponse : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [JsonPropertyAttribute("message")]
public string Message { get; public set; }
    [JsonPropertyAttribute("correlationId")]
public string CorrelationId { get; public set; }
    [JsonPropertyAttribute("error")]
public string Error { get; public set; }
    [JsonPropertyAttribute("error_description")]
public string ErrorDescription { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public void set_ErrorDescription(string value);
}
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityRequest : object {
    private Uri _baseEndpoint;
    [CompilerGeneratedAttribute]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <BodyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <QueryParameters>k__BackingField;
    public HttpMethod Method { get; }
    public IDictionary`2<string, string> Headers { get; }
    public IDictionary`2<string, string> BodyParameters { get; }
    public IDictionary`2<string, string> QueryParameters { get; }
    public ManagedIdentityRequest(HttpMethod method, Uri endpoint);
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_BodyParameters();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_QueryParameters();
    public Uri ComputeUri();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [JsonPropertyAttribute("access_token")]
public string AccessToken { get; public set; }
    [JsonPropertyAttribute("expires_on")]
public string ExpiresOn { get; public set; }
    [JsonPropertyAttribute("resource")]
public string Resource { get; public set; }
    [JsonPropertyAttribute("token_type")]
public string TokenType { get; public set; }
    [JsonPropertyAttribute("client_id")]
public string ClientId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public string get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(string value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
}
public enum Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource : Enum {
    public int value__;
    public static ManagedIdentitySource None;
    public static ManagedIdentitySource Imds;
    public static ManagedIdentitySource AppService;
    public static ManagedIdentitySource AzureArc;
    public static ManagedIdentitySource CloudShell;
    public static ManagedIdentitySource ServiceFabric;
    public static ManagedIdentitySource DefaultToImds;
}
internal class Microsoft.Identity.Client.ManagedIdentity.ServiceFabricManagedIdentitySource : AbstractManagedIdentity {
    private static string ServiceFabricMsiApiVersion;
    private Uri _endpoint;
    private string _identityHeaderValue;
    internal static Lazy`1<HttpClient> _httpClientLazy;
    private ServiceFabricManagedIdentitySource(RequestContext requestContext, Uri endpoint, string identityHeaderValue);
    public static AbstractManagedIdentity Create(RequestContext requestContext);
    internal virtual HttpClient GetHttpClientWithSslValidation(RequestContext requestContext);
    internal HttpClientHandler CreateHandlerWithSslValidation(ILoggerAdapter logger);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.ManagedIdentityApplication : ApplicationBase {
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <AppTokenCacheInternal>k__BackingField;
    internal ITokenCacheInternal AppTokenCacheInternal { get; }
    internal ManagedIdentityApplication(ApplicationConfiguration configuration);
    [CompilerGeneratedAttribute]
internal ITokenCacheInternal get_AppTokenCacheInternal();
    public sealed virtual AcquireTokenForManagedIdentityParameterBuilder AcquireTokenForManagedIdentity(string resource);
    public static ManagedIdentitySource GetManagedIdentitySource();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.ManagedIdentityApplicationBuilder : BaseAbstractApplicationBuilder`1<ManagedIdentityApplicationBuilder> {
    internal ManagedIdentityApplicationBuilder(ApplicationConfiguration configuration);
    [EditorBrowsableAttribute("1")]
public static ManagedIdentityApplicationBuilder Create(ManagedIdentityId managedIdentityId);
    private static ApplicationConfiguration BuildConfiguration(ManagedIdentityId managedIdentityId);
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "True")]
[EditorBrowsableAttribute("1")]
public ManagedIdentityApplicationBuilder WithTelemetryClient(ITelemetryClient[] telemetryClients);
    internal ManagedIdentityApplicationBuilder WithAppTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal);
    public ManagedIdentityApplicationBuilder WithClientCapabilities(IEnumerable`1<string> clientCapabilities);
    public IManagedIdentityApplication Build();
    internal ManagedIdentityApplication BuildConcrete();
    private void DefaultConfiguration();
    private void ComputeClientIdForCaching();
}
public class Microsoft.Identity.Client.Metrics : object {
    private static long _totalAccessTokensFromIdP;
    private static long _totalAccessTokensFromCache;
    private static long _totalAccessTokensFromBroker;
    private static long _totalDurationInMs;
    public static long TotalAccessTokensFromIdP { get; internal set; }
    public static long TotalAccessTokensFromCache { get; internal set; }
    public static long TotalAccessTokensFromBroker { get; internal set; }
    public static long TotalDurationInMs { get; internal set; }
    public static long get_TotalAccessTokensFromIdP();
    internal static void set_TotalAccessTokensFromIdP(long value);
    public static long get_TotalAccessTokensFromCache();
    internal static void set_TotalAccessTokensFromCache(long value);
    public static long get_TotalAccessTokensFromBroker();
    internal static void set_TotalAccessTokensFromBroker(long value);
    public static long get_TotalDurationInMs();
    internal static void set_TotalDurationInMs(long value);
    internal static void IncrementTotalAccessTokensFromIdP();
    internal static void IncrementTotalAccessTokensFromCache();
    internal static void IncrementTotalAccessTokensFromBroker();
    internal static void IncrementTotalDurationInMs(long requestDurationInMs);
}
internal static class Microsoft.Identity.Client.MigrationHelper : object {
    public static NotImplementedException CreateMsalNet3BreakingChangesException();
}
public class Microsoft.Identity.Client.MsalClaimsChallengeException : MsalUiRequiredException {
    public MsalClaimsChallengeException(string errorCode, string errorMessage);
    public MsalClaimsChallengeException(string errorCode, string errorMessage, Exception innerException);
    public MsalClaimsChallengeException(string errorCode, string errorMessage, Exception innerException, UiRequiredExceptionClassification classification);
}
public class Microsoft.Identity.Client.MsalClientException : MsalException {
    public MsalClientException(string errorCode);
    public MsalClientException(string errorCode, string errorMessage);
    public MsalClientException(string errorCode, string errorMessage, Exception innerException);
}
public static class Microsoft.Identity.Client.MsalError : object {
    public static string InvalidGrantError;
    public static string InteractionRequired;
    public static string NoTokensFoundError;
    public static string UserNullError;
    public static string UserAssertionNullError;
    public static string CurrentBrokerAccount;
    public static string NoAccountForLoginHint;
    public static string MultipleAccountsForLoginHint;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This error code is not in use")]
public static string TokenCacheNullError;
    public static string NoPromptFailedError;
    public static string ServiceNotAvailable;
    public static string RequestTimeout;
    public static string RequestThrottled;
    public static string UpnRequired;
    public static string MissingPassiveAuthEndpoint;
    public static string InvalidAuthority;
    public static string InvalidAuthorityType;
    public static string UnauthorizedClient;
    public static string UnknownError;
    public static string UnknownBrokerError;
    public static string WamFailedToSignout;
    public static string AuthenticationFailed;
    public static string AuthorityValidationFailed;
    public static string InvalidOwnerWindowType;
    public static string EncodedTokenTooLong;
    public static string UserMismatch;
    public static string FailedToRefreshToken;
    public static string FailedToAcquireTokenSilentlyFromBroker;
    public static string RedirectUriValidationFailed;
    public static string AuthenticationUiFailed;
    public static string InternalError;
    public static string AccessingWsMetadataExchangeFailed;
    public static string FederatedServiceReturnedError;
    public static string UserRealmDiscoveryFailed;
    public static string RopcDoesNotSupportMsaAccounts;
    public static string MissingFederationMetadataUrl;
    public static string ParsingWsMetadataExchangeFailed;
    public static string WsTrustEndpointNotFoundInMetadataDocument;
    public static string ParsingWsTrustResponseFailed;
    public static string IntegratedWindowsAuthenticationFailed;
    public static string UnknownUserType;
    public static string UnknownUser;
    public static string GetUserNameFailed;
    public static string PasswordRequiredForManagedUserError;
    public static string InvalidRequest;
    public static string UapCannotFindDomainUser;
    public static string UapCannotFindUpn;
    public static string NonParsableOAuthError;
    public static string CodeExpired;
    public static string IntegratedWindowsAuthNotSupportedForManagedUser;
    public static string ActivityRequired;
    public static string BrokerResponseHashMismatch;
    public static string BrokerResponseReturnedError;
    public static string BrokerNonceMismatch;
    public static string CannotInvokeBroker;
    public static string NoAndroidBrokerAccountFound;
    public static string NoAndroidBrokerInstalledOnDevice;
    public static string NullIntentReturnedFromAndroidBroker;
    public static string AndroidBrokerSignatureVerificationFailed;
    public static string AndroidBrokerOperationFailed;
    public static string NoUsernameOrAccountIDProvidedForSilentAndroidBrokerAuthentication;
    public static string HttpStatusNotFound;
    public static string HttpStatusCodeNotOk;
    public static string CustomWebUiReturnedInvalidUri;
    public static string CustomWebUiRedirectUriMismatch;
    public static string AccessDenied;
    public static string CannotAccessUserInformationOrUserNotDomainJoined;
    public static string DefaultRedirectUriIsInvalid;
    public static string NoRedirectUri;
    public static string MultipleTokensMatchedError;
    public static string NonHttpsRedirectNotSupported;
    [ObsoleteAttribute("MSAL no longer throws this error - it will allow the HttpClient exceptions to propagate. App developers may write their own logic for detecting access to the network issues, for example by using Xamarin.Essentials. ")]
[EditorBrowsableAttribute("1")]
public static string NetworkNotAvailableError;
    public static string B2CAuthorityHostMismatch;
    public static string AuthorityHostMismatch;
    public static string DuplicateQueryParameterError;
    public static string AuthenticationUiFailedError;
    public static string AuthenticationCanceledError;
    public static string JsonParseError;
    public static string InvalidJwtError;
    public static string StateMismatchError;
    public static string TenantDiscoveryFailedError;
    public static string PlatformNotSupported;
    public static string InvalidAuthorizationUri;
    public static string LoopbackRedirectUri;
    public static string LoopbackResponseUriMismatch;
    public static string LinuxXdgOpen;
    public static string WebviewUnavailable;
    public static string SystemWebviewOptionsNotApplicable;
    public static string ClientCredentialAuthenticationTypesAreMutuallyExclusive;
    public static string ClientCredentialAuthenticationTypeMustBeDefined;
    internal static string BasicAction;
    internal static string AdditionalAction;
    internal static string MessageOnly;
    internal static string UserPasswordExpired;
    internal static string ConsentRequired;
    internal static string BadToken;
    internal static string TokenExpired;
    internal static string ProtectionPolicyRequired;
    internal static string ClientMismatch;
    internal static string DeviceAuthenticationFailed;
    public static string InvalidInstance;
    public static string InvalidUserInstanceMetadata;
    public static string ValidateAuthorityOrCustomMetadata;
    public static string NoClientId;
    public static string TelemetryConfigOrTelemetryCallback;
    public static string InvalidClient;
    public static string SSHCertUsedAsHttpHeader;
    public static string WABError;
    public static string TokenTypeMismatch;
    public static string AccessTokenTypeMissing;
    public static string ExperimentalFeature;
    public static string BrokerApplicationRequired;
    public static string FailedToGetBrokerResponse;
    public static string InvalidJsonClaimsFormat;
    public static string AuthorityTypeMismatch;
    public static string AuthorityTenantSpecifiedTwice;
    public static string CustomMetadataInstanceOrUri;
    public static string ScopesRequired;
    public static string CertWithoutPrivateKey;
    public static string CertificateNotRsa;
    public static string DeviceCertificateNotFound;
    public static string InvalidAdalCacheMultipleRTs;
    public static string RegionDiscoveryFailed;
    public static string RegionDiscoveryNotEnabled;
    public static string BrokerDoesNotSupportPop;
    public static string BrokerRequiredForPop;
    public static string AdfsNotSupportedWithBroker;
    public static string NonceRequiredForPopOnPCA;
    public static string CannotAccessPublisherKeyChain;
    public static string MissingEntitlements;
    public static string UIViewControllerRequiredForiOSBroker;
    public static string WritingApplicationTokenToKeychainFailed;
    public static string ReadingApplicationTokenFromKeychainFailed;
    public static string BrokerKeySaveFailed;
    public static string BrokerKeyFetchFailed;
    public static string WamUiThread;
    public static string WamNoB2C;
    public static string WamInteractiveError;
    public static string WamPickerError;
    public static string WamScopesRequired;
    public static string WebView2NotInstalled;
    public static string WebView2LoaderNotFound;
    public static string RegionalAuthorityValidation;
    public static string RegionDiscoveryWithCustomInstanceMetadata;
    public static string HttpListenerError;
    public static string InitializeProcessSecurityError;
    public static string StaticCacheWithExternalSerialization;
    public static string TenantOverrideNonAad;
    public static string RegionalAndAuthorityOverride;
    public static string OboCacheKeyNotInCacheError;
    public static string InvalidTokenProviderResponseValue;
    public static string UnableToParseAuthenticationHeader;
    public static string InvalidManagedIdentityResponse;
    public static string ManagedIdentityRequestFailed;
    public static string ManagedIdentityUnreachableNetwork;
    public static string UnknownManagedIdentityError;
    public static string InvalidManagedIdentityEndpoint;
    public static string ExactlyOneScopeExpected;
    public static string UserAssignedManagedIdentityNotSupported;
    public static string UserAssignedManagedIdentityNotConfigurableAtRuntime;
    public static string CombinedUserAppCacheNotSupported;
    public static string SetCiamAuthorityAtRequestLevelNotSupported;
    public static string CryptographicError;
}
internal static class Microsoft.Identity.Client.MsalErrorMessage : object {
    public static string AccessingMetadataDocumentFailed;
    public static string AssemblyNotFoundTemplate;
    public static string AssemblyLoadFailedTemplate;
    public static string AuthenticationUiFailed;
    public static string DeprecatedAuthorityError;
    public static string CertificateKeySizeTooSmallTemplate;
    public static string EmailAddressSuffixMismatch;
    public static string EncodedTokenTooLong;
    public static string FailedToAcquireTokenSilently;
    public static string FailedToRefreshToken;
    public static string IdentityProtocolLoginUrlNull;
    public static string IdentityProtocolMismatch;
    public static string IdentityProviderRequestFailed;
    public static string InvalidArgumentLength;
    public static string InvalidAuthenticateHeaderFormat;
    public static string InvalidAuthorityTypeTemplate;
    public static string InvalidCredentialType;
    public static string InvalidFormatParameterTemplate;
    public static string InvalidTokenCacheKeyFormat;
    public static string MissingAuthenticateHeader;
    public static string MultipleTokensMatched;
    public static string NullParameterTemplate;
    public static string ParsingMetadataDocumentFailed;
    public static string ParsingWsTrustResponseFailed;
    public static string PasswordRequiredForManagedUserError;
    public static string LoginHintNullForUiOption;
    public static string ServiceReturnedError;
    public static string BrokerResponseHashMismatch;
    public static string BrokerNonceMismatch;
    public static string StsMetadataRequestFailed;
    public static string StsTokenRequestFailed;
    public static string UnauthorizedHttpStatusCodeExpected;
    internal static string iOSBrokerKeyFetchFailed;
    public static string UnauthorizedResponseExpected;
    public static string UnexpectedAuthorityValidList;
    public static string UnsupportedUserType;
    public static string UnsupportedMultiRefreshToken;
    public static string UserMismatch;
    public static string UserCredentialAssertionTypeEmpty;
    public static string NoPromptFailedErrorMessage;
    public static string StateMismatchErrorMessage;
    public static string UserRealmDiscoveryFailed;
    public static string RopcDoesNotSupportMsaAccounts;
    public static string WsTrustEndpointNotFoundInMetadataDocument;
    public static string GetUserNameFailed;
    public static string MissingFederationMetadataUrl;
    public static string SpecifyAnyUser;
    public static string IntegratedAuthFailed;
    public static string DuplicateQueryParameterTemplate;
    public static string DeviceCertificateNotFoundTemplate;
    public static string MsalUiRequiredMessage;
    public static string UserMismatchSaveToken;
    public static string IwaNotSupportedForManagedUser;
    public static string ActivityRequired;
    public static string BrokerResponseReturnedError;
    public static string BrokerResponseError;
    public static string CannotInvokeBroker;
    public static string CannotInvokeBrokerForPop;
    public static string BrokerDoesNotSupportPop;
    public static string BrokerRequiredForPop;
    public static string NonceRequiredForPop;
    public static string AdfsNotSupportedWithBroker;
    public static string NullIntentReturnedFromBroker;
    public static string NoAccountForLoginHint;
    public static string MultipleAccountsForLoginHint;
    public static string UnknownUser;
    public static string HttpRequestUnsuccessful;
    public static string AuthorityInvalidUriFormat;
    public static string AuthorityNotSupported;
    public static string AuthorityValidationFailed;
    public static string AuthorityUriInsecure;
    public static string AuthorityUriInvalidPath;
    public static string B2cAuthorityUriInvalidPath;
    public static string DstsAuthorityUriInvalidPath;
    public static string UnsupportedAuthorityValidation;
    public static string AuthenticationCanceled;
    public static string AuthenticationCanceledAndroid;
    public static string Unknown;
    public static string AuthorizationServerInvalidResponse;
    public static string NonHttpsRedirectNotSupported;
    public static string IDTokenMustHaveTwoParts;
    public static string FailedToParseIDToken;
    public static string InvalidAuthorityOpenId;
    public static string UpnRequiredForAuthorityValidation;
    public static string CannotFindTheAuthEndpoint;
    public static string PlatformNotSupported;
    public static string FederatedServiceReturnedErrorTemplate;
    public static string ParsingWsTrustResponseFailedErrorTemplate;
    public static string UnknownUserType;
    public static string ParsingWsTrustResponseFailedDueToConfiguration;
    public static string InternalErrorCacheEmptyUsername;
    public static string InternalErrorCacheEmptyIdentifier;
    public static string NonParsableOAuthError;
    public static string CannotAccessPublisherKeyChain;
    public static string MissingEntitlements;
    public static string AndroidActivityNotFound;
    public static string DefaultRedirectUriIsInvalid;
    public static string RedirectUriContainsFragment;
    public static string NoRedirectUri;
    public static string ClientApplicationBaseExecutorNotImplemented;
    public static string ActivityRequiredForParentObjectAndroid;
    public static string LoggingCallbackAlreadySet;
    public static string TelemetryCallbackAlreadySet;
    public static string NoClientIdWasSpecified;
    public static string AdfsNotCurrentlySupportedAuthorityType;
    public static string TenantIdAndAadAuthorityInstanceAreMutuallyExclusive;
    public static string InstanceAndAzureCloudInstanceAreMutuallyExclusive;
    public static string NoRefreshTokenProvided;
    public static string AadThrottledError;
    public static string NoTokensFoundError;
    public static string NoRefreshTokenInResponse;
    public static string ConfidentialClientDoesntImplementIConfidentialClientApplicationExecutor;
    public static string ClientCredentialAuthenticationTypesAreMutuallyExclusive;
    public static string ClientCredentialAuthenticationTypeMustBeDefined;
    public static string TelemetryClassIsObsolete;
    public static string LoggingClassIsObsolete;
    public static string AuthorityDoesNotHaveTwoSegments;
    public static string DstsAuthorityDoesNotHaveThreeSegments;
    public static string AzureAdMyOrgRequiresSpecifyingATenant;
    public static string CustomWebUiReturnedInvalidUri;
    public static string InteractiveAuthNotSupported;
    public static string CustomWebUiAuthorizationCodeFailed;
    public static string TokenCacheJsonSerializerFailedParse;
    public static string TokenCacheDictionarySerializerFailedParse;
    public static string BrokerNotSupportedOnThisPlatform;
    public static string MsalExceptionFailedToParse;
    public static string AdfsDeviceFlowNotSupported;
    public static string MatsAndTelemetryCallbackCannotBeConfiguredSimultaneously;
    public static string AkaMsmsalnet3BreakingChanges;
    public static string B2CAuthorityHostMisMatch;
    public static string TokenCacheSetCallbackFunctionalityNotAvailableFromWithinCallback;
    public static string EmbeddedWebviewDefaultBrowser;
    public static string AuthorizeEndpointWasNotFoundInTheOpenIdConfiguration;
    public static string TokenEndpointWasNotFoundInTheOpenIdConfiguration;
    public static string IssuerWasNotFoundInTheOpenIdConfiguration;
    public static string InvalidUserInstanceMetadata;
    public static string UIViewControllerIsRequiredToInvokeiOSBroker;
    public static string WritingApplicationTokenToKeychainFailed;
    public static string ReadingApplicationTokenFromKeychainFailed;
    public static string ValidateAuthorityOrCustomMetadata;
    public static string InvalidClient;
    public static string SSHCertUsedAsHttpHeader;
    public static string BrokerApplicationRequired;
    public static string RegionDiscoveryFailed;
    public static string RegionDiscoveryFailedWithTimeout;
    public static string RegionDiscoveryNotAvailable;
    public static string RegionDiscoveryWithCustomInstanceMetadata;
    public static string NoAndroidBrokerAccountFound;
    public static string AndroidBrokerCannotBeInvoked;
    public static string CustomMetadataInstanceOrUri;
    public static string ScopesRequired;
    public static string InvalidAdalCacheMultipleRTs;
    public static string AccessTokenTypeMissing;
    public static string LinuxOpenToolFailed;
    public static string LinuxOpenAsSudoNotSupported;
    public static string WebView2LoaderNotFound;
    public static string AuthenticationFailedWamElevatedProcess;
    public static string CcsRoutingHintMissing;
    public static string StaticCacheWithExternalSerialization;
    public static string ClientCredentialWrongAuthority;
    public static string OnBehalfOfWrongAuthority;
    public static string TenantOverrideNonAad;
    public static string RegionalAndAuthorityOverride;
    public static string OboCacheKeyNotInCache;
    public static string MultiCloudSupportUnavailable;
    public static string RequestFailureErrorMessage;
    public static string RequestFailureErrorMessagePii;
    public static string UnableToParseAuthenticationHeader;
    public static string ManagedIdentityNoResponseReceived;
    public static string ManagedIdentityInvalidResponse;
    public static string ManagedIdentityUnexpectedResponse;
    public static string ManagedIdentityExactlyOneScopeExpected;
    public static string ManagedIdentityUnexpectedErrorResponse;
    public static string ManagedIdentityEndpointInvalidUriError;
    public static string ManagedIdentityNoChallengeError;
    public static string ManagedIdentityInvalidChallenge;
    public static string ManagedIdentityInvalidFile;
    public static string ManagedIdentityPlatformNotSupported;
    public static string ManagedIdentityUserAssignedNotSupported;
    public static string ManagedIdentityUserAssignedNotConfigurableAtRuntime;
    public static string CombinedUserAppCacheNotSupported;
    public static string JsonParseErrorMessage;
    public static string SetCiamAuthorityAtRequestLevelNotSupported;
    public static string ClaimsChallenge;
    public static string CryptographicError;
    public static string iOSBrokerKeySaveFailed(string keyChainResult);
    public static string InvalidRedirectUriReceived(string invalidRedirectUri);
    public static string RedirectUriMismatch(string expectedUri, string actualUri);
    public static string AuthorityTypeMismatch(AuthorityType appAuthorityType, AuthorityType requestAuthorityType);
    public static string ExperimentalFeature(string methodName);
    public static string NoUserInstanceMetadataEntry(string environment);
    public static string WABError(string status, string errorDetail, string responseData);
    public static string TokenTypeMismatch(string requestTokenType, string responseTokenType);
    public static string InvalidJsonClaimsFormat(string claims);
    public static string CertMustHavePrivateKey(string certificateName);
    public static string CertMustBeRsa(string certificateFriendlyName);
    public static string InitializeProcessSecurityError(string errorCode);
    public static string InvalidTokenProviderResponseValue(string invalidValueName);
}
public class Microsoft.Identity.Client.MsalException : Exception {
    public static string BrokerErrorContext;
    public static string BrokerErrorTag;
    public static string BrokerErrorStatus;
    public static string BrokerErrorCode;
    public static string BrokerTelemetry;
    public static string ManagedIdentitySource;
    private string _errorCode;
    [CompilerGeneratedAttribute]
private bool <IsRetryable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <AdditionalExceptionData>k__BackingField;
    public bool IsRetryable { get; public set; }
    public string ErrorCode { get; private set; }
    public string CorrelationId { get; public set; }
    public IReadOnlyDictionary`2<string, string> AdditionalExceptionData { get; public set; }
    public MsalException(string errorCode);
    public MsalException(string errorCode, string errorMessage);
    public MsalException(string errorCode, string errorMessage, Exception innerException);
    [CompilerGeneratedAttribute]
public bool get_IsRetryable();
    [CompilerGeneratedAttribute]
public void set_IsRetryable(bool value);
    public string get_ErrorCode();
    private void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_AdditionalExceptionData();
    [CompilerGeneratedAttribute]
public void set_AdditionalExceptionData(IReadOnlyDictionary`2<string, string> value);
    public virtual string ToString();
    internal virtual void PopulateJson(JObject jObject);
    internal virtual void PopulateObjectFromJson(JObject jObject);
    public string ToJsonString();
    public static MsalException FromJsonString(string json);
}
[ObsoleteAttribute("MsalManagedIdentityException is deprecated and will be removed in a future release. Catch MsalServiceException instead.", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.MsalManagedIdentityException : MsalServiceException {
    [CompilerGeneratedAttribute]
private ManagedIdentitySource <ManagedIdentitySource>k__BackingField;
    public ManagedIdentitySource ManagedIdentitySource { get; }
    public MsalManagedIdentityException(string errorCode, string errorMessage, ManagedIdentitySource source);
    public MsalManagedIdentityException(string errorCode, string errorMessage, ManagedIdentitySource source, int statusCode);
    public MsalManagedIdentityException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource source, int statusCode);
    public MsalManagedIdentityException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource source);
    [CompilerGeneratedAttribute]
public ManagedIdentitySource get_ManagedIdentitySource();
    protected virtual void UpdateIsRetryable();
}
public class Microsoft.Identity.Client.MsalServiceException : MsalException {
    private static string ClaimsKey;
    private static string ResponseBodyKey;
    private static string CorrelationIdKey;
    private static string SubErrorKey;
    private int _statusCode;
    private string _responseBody;
    private HttpResponseHeaders _headers;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubError>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ErrorCodes>k__BackingField;
    public int StatusCode { get; internal set; }
    public string Claims { get; internal set; }
    public string ResponseBody { get; public set; }
    public HttpResponseHeaders Headers { get; public set; }
    internal string SubError { get; internal set; }
    internal String[] ErrorCodes { get; internal set; }
    public MsalServiceException(string errorCode, string errorMessage);
    public MsalServiceException(string errorCode, string errorMessage, int statusCode);
    public MsalServiceException(string errorCode, string errorMessage, Exception innerException);
    public MsalServiceException(string errorCode, string errorMessage, int statusCode, Exception innerException);
    public MsalServiceException(string errorCode, string errorMessage, int statusCode, string claims, Exception innerException);
    public int get_StatusCode();
    internal void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
internal void set_Claims(string value);
    public string get_ResponseBody();
    public void set_ResponseBody(string value);
    public HttpResponseHeaders get_Headers();
    public void set_Headers(HttpResponseHeaders value);
    [CompilerGeneratedAttribute]
internal string get_SubError();
    [CompilerGeneratedAttribute]
internal void set_SubError(string value);
    [CompilerGeneratedAttribute]
internal String[] get_ErrorCodes();
    [CompilerGeneratedAttribute]
internal void set_ErrorCodes(String[] value);
    protected virtual void UpdateIsRetryable();
    public virtual string ToString();
    internal virtual void PopulateJson(JObject jObject);
    internal virtual void PopulateObjectFromJson(JObject jObject);
}
internal class Microsoft.Identity.Client.MsalServiceExceptionFactory : object {
    private static ISet`1<string> s_nonUiSubErrors;
    private static MsalServiceExceptionFactory();
    internal static MsalServiceException FromHttpResponse(string errorCode, string errorMessage, HttpResponse httpResponse, Exception innerException);
    private static bool IsThrottled(OAuth2ResponseBase oAuth2Response);
    internal static MsalServiceException FromBrokerResponse(MsalTokenResponse msalTokenResponse, string errorMessage);
    internal static MsalServiceException FromImdsResponse(string errorCode, string errorMessage, HttpResponse httpResponse, Exception innerException);
    internal static MsalException CreateManagedIdentityException(string errorCode, string errorMessage, Exception innerException, ManagedIdentitySource managedIdentitySource, Nullable`1<int> statusCode);
    private static MsalException DecorateExceptionWithManagedIdentitySource(MsalException exception, ManagedIdentitySource managedIdentitySource);
    internal static MsalThrottledServiceException FromThrottledAuthenticationResponse(HttpResponse httpResponse);
    private static void SetHttpExceptionData(MsalServiceException ex, HttpResponse httpResponse);
    private static bool IsInteractionRequired(string errorCode);
    private static bool IsInvalidGrant(string errorCode, string subErrorCode);
    private static bool IsAppProtectionPolicyRequired(string errorCode, string subErrorCode);
    private static bool IsInvalidGrantSubError(string subError);
}
public class Microsoft.Identity.Client.MsalThrottledServiceException : MsalServiceException {
    [CompilerGeneratedAttribute]
private MsalServiceException <OriginalServiceException>k__BackingField;
    public MsalServiceException OriginalServiceException { get; }
    public MsalThrottledServiceException(MsalServiceException originalException);
    [CompilerGeneratedAttribute]
public MsalServiceException get_OriginalServiceException();
}
public class Microsoft.Identity.Client.MsalThrottledUiRequiredException : MsalUiRequiredException {
    [CompilerGeneratedAttribute]
private MsalUiRequiredException <OriginalServiceException>k__BackingField;
    public MsalUiRequiredException OriginalServiceException { get; }
    public MsalThrottledUiRequiredException(MsalUiRequiredException originalException);
    [CompilerGeneratedAttribute]
public MsalUiRequiredException get_OriginalServiceException();
}
public class Microsoft.Identity.Client.MsalUiRequiredException : MsalServiceException {
    private UiRequiredExceptionClassification _classification;
    public UiRequiredExceptionClassification Classification { get; }
    public MsalUiRequiredException(string errorCode, string errorMessage);
    public MsalUiRequiredException(string errorCode, string errorMessage, Exception innerException);
    public MsalUiRequiredException(string errorCode, string errorMessage, Exception innerException, UiRequiredExceptionClassification classification);
    public UiRequiredExceptionClassification get_Classification();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.DeviceAuthHeader : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <X5c>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alg>k__BackingField;
    [JsonPropertyAttribute("x5c")]
public IList`1<string> X5c { get; public set; }
    [JsonPropertyAttribute("typ")]
public string Type { get; public set; }
    [JsonPropertyAttribute("alg")]
public string Alg { get; private set; }
    public DeviceAuthHeader(string base64EncodedCertificate);
    [CompilerGeneratedAttribute]
public IList`1<string> get_X5c();
    [CompilerGeneratedAttribute]
public void set_X5c(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Alg();
    [CompilerGeneratedAttribute]
private void set_Alg(string value);
}
internal class Microsoft.Identity.Client.OAuth2.DeviceAuthJWTResponse : object {
    private DeviceAuthHeader _header;
    private DeviceAuthPayload _payload;
    public DeviceAuthJWTResponse(string audience, string nonce, string base64EncodedCertificate);
    public string GetResponseToSign();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.DeviceAuthPayload : object {
    private Lazy`1<long> _defaultDeviceAuthJWTTimeSpan;
    [CompilerGeneratedAttribute]
private long <Iat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Audience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [JsonPropertyAttribute("iat")]
public long Iat { get; public set; }
    [JsonPropertyAttribute("aud")]
public string Audience { get; public set; }
    [JsonPropertyAttribute("nonce")]
public string Nonce { get; private set; }
    public DeviceAuthPayload(string audience, string nonce);
    [CompilerGeneratedAttribute]
public long get_Iat();
    [CompilerGeneratedAttribute]
public void set_Iat(long value);
    [CompilerGeneratedAttribute]
public string get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(string value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
private void set_Nonce(string value);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.MsalTokenResponse : OAuth2ResponseBase {
    private static string iOSBrokerErrorMetadata;
    private static string iOSBrokerHomeAccountId;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdToken>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExtendedExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RefreshIn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpaAuthCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorityUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountUserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WamAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenSource <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponse <HttpResponse>k__BackingField;
    [JsonPropertyAttribute("token_type")]
public string TokenType { get; public set; }
    [JsonPropertyAttribute("access_token")]
public string AccessToken { get; public set; }
    [JsonPropertyAttribute("refresh_token")]
public string RefreshToken { get; public set; }
    [JsonPropertyAttribute("scope")]
public string Scope { get; public set; }
    [JsonPropertyAttribute("client_info")]
public string ClientInfo { get; public set; }
    [JsonPropertyAttribute("id_token")]
public string IdToken { get; public set; }
    [JsonPropertyAttribute("expires_in")]
public long ExpiresIn { get; public set; }
    [JsonPropertyAttribute("ext_expires_in")]
public long ExtendedExpiresIn { get; public set; }
    [JsonPropertyAttribute("refresh_in")]
public Nullable`1<long> RefreshIn { get; public set; }
    [JsonPropertyAttribute("foci")]
public string FamilyId { get; public set; }
    [JsonPropertyAttribute("spa_code")]
public string SpaAuthCode { get; public set; }
    [JsonPropertyAttribute("authority")]
public string AuthorityUrl { get; public set; }
    public string TenantId { get; public set; }
    public string Upn { get; public set; }
    public string AccountUserId { get; public set; }
    public string WamAccountId { get; public set; }
    public TokenSource TokenSource { get; public set; }
    public HttpResponse HttpResponse { get; public set; }
    public IReadOnlyDictionary`2<string, string> CreateExtensionDataStringMap();
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_ClientInfo();
    [CompilerGeneratedAttribute]
public void set_ClientInfo(string value);
    [CompilerGeneratedAttribute]
public string get_IdToken();
    [CompilerGeneratedAttribute]
public void set_IdToken(string value);
    [CompilerGeneratedAttribute]
public long get_ExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExpiresIn(long value);
    [CompilerGeneratedAttribute]
public long get_ExtendedExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExtendedExpiresIn(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RefreshIn();
    [CompilerGeneratedAttribute]
public void set_RefreshIn(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_FamilyId();
    [CompilerGeneratedAttribute]
public void set_FamilyId(string value);
    [CompilerGeneratedAttribute]
public string get_SpaAuthCode();
    [CompilerGeneratedAttribute]
public void set_SpaAuthCode(string value);
    [CompilerGeneratedAttribute]
public string get_AuthorityUrl();
    [CompilerGeneratedAttribute]
public void set_AuthorityUrl(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_Upn();
    [CompilerGeneratedAttribute]
public void set_Upn(string value);
    [CompilerGeneratedAttribute]
public string get_AccountUserId();
    [CompilerGeneratedAttribute]
public void set_AccountUserId(string value);
    [CompilerGeneratedAttribute]
public string get_WamAccountId();
    [CompilerGeneratedAttribute]
public void set_WamAccountId(string value);
    [CompilerGeneratedAttribute]
public TokenSource get_TokenSource();
    [CompilerGeneratedAttribute]
public void set_TokenSource(TokenSource value);
    [CompilerGeneratedAttribute]
public HttpResponse get_HttpResponse();
    [CompilerGeneratedAttribute]
public void set_HttpResponse(HttpResponse value);
    internal static MsalTokenResponse CreateFromiOSBrokerResponse(Dictionary`2<string, string> responseDictionary);
    internal static MsalTokenResponse CreateFromManagedIdentityResponse(ManagedIdentityResponse managedIdentityResponse);
    private static Nullable`1<long> InferManagedIdentityRefreshInValue(long expiresIn);
    private static void ValidateManagedIdentityResult(ManagedIdentityResponse response);
    internal static MsalTokenResponse CreateFromAppProviderResponse(AppTokenProviderResult tokenProviderResponse);
    private static Nullable`1<long> EstimateRefreshIn(long expiresInSeconds);
    private static void ValidateTokenProviderResult(AppTokenProviderResult TokenProviderResult);
    private static void HandleInvalidExternalValueError(string nameOfValue);
    internal static MsalTokenResponse CreateFromAndroidBrokerResponse(string jsonResponse, string correlationId);
    public void Log(ILoggerAdapter logger, LogLevel logLevel);
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2AssertionType : object {
    public static string JwtBearer;
}
internal class Microsoft.Identity.Client.OAuth2.OAuth2Client : object {
    private Dictionary`2<string, string> _headers;
    private Dictionary`2<string, string> _queryParameters;
    private IDictionary`2<string, string> _bodyParameters;
    private IHttpManager _httpManager;
    private X509Certificate2 _mtlsCertificate;
    public OAuth2Client(ILoggerAdapter logger, IHttpManager httpManager, X509Certificate2 mtlsCertificate);
    public void AddQueryParameter(string key, string value);
    public void AddBodyParameter(string key, string value);
    internal void AddHeader(string key, string value);
    internal IReadOnlyDictionary`2<string, string> GetBodyParameters();
    public Task`1<InstanceDiscoveryResponse> DiscoverAadInstanceAsync(Uri endpoint, RequestContext requestContext);
    public Task`1<OidcMetadata> DiscoverOidcMetadataAsync(Uri endpoint, RequestContext requestContext);
    internal Task`1<MsalTokenResponse> GetTokenAsync(Uri endPoint, RequestContext requestContext, bool addCommonHeaders, Func`2<OnBeforeTokenRequestData, Task> onBeforePostRequestHandler);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.OAuth2Client/<ExecuteRequestAsync>d__13`1")]
internal Task`1<T> ExecuteRequestAsync(Uri endPoint, HttpMethod method, RequestContext requestContext, bool expectErrorsOn200OK, bool addCommonHeaders, Func`2<OnBeforeTokenRequestData, Task> onBeforePostRequestData);
    internal void AddBodyParameter(KeyValuePair`2<string, string> kvp);
    private void AddCommonHeaders(RequestContext requestContext);
    public static T CreateResponse(HttpResponse response, RequestContext requestContext);
    private static void ThrowServerException(HttpResponse response, RequestContext requestContext);
    private static MsalServiceException ExtractErrorsFromTheResponse(HttpResponse response, Boolean& shouldLogAsError);
    private Uri AddExtraQueryParams(Uri endPoint);
    private static void VerifyCorrelationIdHeaderInResponse(IDictionary`2<string, string> headers, RequestContext requestContext);
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Error : object {
    public static string LoginRequired;
    public static string AuthorizationPending;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2GrantType : object {
    public static string AuthorizationCode;
    public static string RefreshToken;
    public static string ClientCredentials;
    public static string Saml11Bearer;
    public static string Saml20Bearer;
    public static string JwtBearer;
    public static string Password;
    public static string DeviceCode;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Header : object {
    public static string CorrelationId;
    public static string RequestCorrelationIdInResponse;
    public static string AppName;
    public static string AppVer;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Parameter : object {
    public static string ResponseType;
    public static string GrantType;
    public static string ClientId;
    public static string ClientSecret;
    public static string ClientAssertion;
    public static string ClientAssertionType;
    public static string RefreshToken;
    public static string RedirectUri;
    public static string Resource;
    public static string Code;
    public static string DeviceCode;
    public static string Scope;
    public static string Assertion;
    public static string RequestedTokenUse;
    public static string Username;
    public static string Password;
    public static string LoginHint;
    public static string CorrelationId;
    public static string State;
    public static string CodeChallengeMethod;
    public static string CodeChallenge;
    public static string PkceCodeVerifier;
    public static string LoginReq;
    public static string DomainReq;
    public static string Prompt;
    public static string ClientInfo;
    public static string Claims;
    public static string TokenType;
    public static string RequestConfirmation;
    public static string SpaCode;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2RequestedTokenUse : object {
    public static string OnBehalfOf;
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.OAuth2ResponseBase : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ErrorCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [JsonPropertyAttribute("error")]
public string Error { get; public set; }
    [JsonPropertyAttribute("suberror")]
public string SubError { get; public set; }
    [JsonPropertyAttribute("error_description")]
public string ErrorDescription { get; public set; }
    [JsonPropertyAttribute("error_codes")]
public String[] ErrorCodes { get; public set; }
    [JsonPropertyAttribute("correlation_id")]
public string CorrelationId { get; public set; }
    [JsonPropertyAttribute("claims")]
public string Claims { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_SubError();
    [CompilerGeneratedAttribute]
public void set_SubError(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public void set_ErrorDescription(string value);
    [CompilerGeneratedAttribute]
public String[] get_ErrorCodes();
    [CompilerGeneratedAttribute]
public void set_ErrorCodes(String[] value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
}
internal class Microsoft.Identity.Client.OAuth2.OAuth2ResponseBaseClaim : object {
    public static string Claims;
    public static string Error;
    public static string SubError;
    public static string ErrorDescription;
    public static string ErrorCodes;
    public static string CorrelationId;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2ResponseType : object {
    public static string Code;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Value : object {
    public static string CodeChallengeMethodValue;
    public static string ScopeOpenId;
    public static string ScopeOfflineAccess;
    public static string ScopeProfile;
    public static HashSet`1<string> ReservedScopes;
    private static OAuth2Value();
}
internal class Microsoft.Identity.Client.OAuth2.PromptValue : object {
    public static string Login;
    public static string RefreshSession;
    public static string AttemptNone;
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.HttpStatusProvider : object {
    internal static TimeSpan s_throttleDuration;
    [CompilerGeneratedAttribute]
private ThrottlingCache <ThrottlingCache>k__BackingField;
    internal ThrottlingCache ThrottlingCache { get; }
    private static HttpStatusProvider();
    [CompilerGeneratedAttribute]
internal ThrottlingCache get_ThrottlingCache();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void ResetCache();
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    private static bool IsRequestSupported(AuthenticationRequestParameters requestParameters);
}
internal interface Microsoft.Identity.Client.OAuth2.Throttling.IThrottlingProvider {
    public abstract virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    public abstract virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public abstract virtual void ResetCache();
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.RetryAfterProvider : object {
    [CompilerGeneratedAttribute]
private ThrottlingCache <ThrottlingCache>k__BackingField;
    internal static TimeSpan MaxRetryAfter;
    internal ThrottlingCache ThrottlingCache { get; }
    private static RetryAfterProvider();
    [CompilerGeneratedAttribute]
internal ThrottlingCache get_ThrottlingCache();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void ResetCache();
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    public static bool TryGetRetryAfterValue(HttpResponseHeaders headers, TimeSpan& retryAfterTimespan);
    private static TimeSpan GetSafeValue(TimeSpan headerValue);
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.SingletonThrottlingManager : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IThrottlingProvider> <ThrottlingProviders>k__BackingField;
    private static Lazy`1<SingletonThrottlingManager> lazyPrivateCtor;
    public IEnumerable`1<IThrottlingProvider> ThrottlingProviders { get; }
    private static SingletonThrottlingManager();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IThrottlingProvider> get_ThrottlingProviders();
    public static SingletonThrottlingManager GetInstance();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    public sealed virtual void ResetCache();
}
internal static class Microsoft.Identity.Client.OAuth2.Throttling.ThrottleCommon : object {
    public static string ThrottleRetryAfterHeaderName;
    public static string ThrottleRetryAfterHeaderValue;
    internal static char KeyDelimiter;
    public static string GetRequestStrictThumbprint(IReadOnlyDictionary`2<string, string> bodyParams, string authority, string homeAccountId);
    public static void TryThrowServiceException(string thumbprint, ThrottlingCache cache, ILoggerAdapter logger, string providerName);
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.ThrottlingCache : object {
    internal static int DefaultCleanupIntervalMs;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanupInProgress;
    private static object _padlock;
    private TimeSpan s_cleanupCacheInterval;
    private DateTimeOffset _lastCleanupTime;
    private ConcurrentDictionary`2<string, ThrottlingCacheEntry> _cache;
    internal ConcurrentDictionary`2<string, ThrottlingCacheEntry> CacheForTest { get; }
    public ThrottlingCache(Nullable`1<int> customCleanupIntervalMs);
    private static ThrottlingCache();
    public void AddAndCleanup(string key, ThrottlingCacheEntry entry, ILoggerAdapter logger);
    public bool TryGetOrRemoveExpired(string key, ILoggerAdapter logger, MsalServiceException& ex);
    public void Clear();
    public bool IsEmpty();
    internal ConcurrentDictionary`2<string, ThrottlingCacheEntry> get_CacheForTest();
    private void CleanCache(ILoggerAdapter logger);
    private void CleanupCacheNoLocks();
    [CompilerGeneratedAttribute]
private string <CleanCache>b__13_1();
    [CompilerGeneratedAttribute]
private string <CleanCache>b__13_2();
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.ThrottlingCacheEntry : object {
    [CompilerGeneratedAttribute]
private MsalServiceException <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationTime>k__BackingField;
    public MsalServiceException Exception { get; }
    public DateTimeOffset CreationTime { get; }
    public DateTimeOffset ExpirationTime { get; }
    public bool IsExpired { get; }
    public ThrottlingCacheEntry(MsalServiceException exception, TimeSpan lifetime);
    public ThrottlingCacheEntry(MsalServiceException exception, DateTimeOffset creationTime, DateTimeOffset expirationTime);
    [CompilerGeneratedAttribute]
public MsalServiceException get_Exception();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreationTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpirationTime();
    public bool get_IsExpired();
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.UiRequiredProvider : object {
    internal static TimeSpan s_uiRequiredExpiration;
    [CompilerGeneratedAttribute]
private ThrottlingCache <ThrottlingCache>k__BackingField;
    internal ThrottlingCache ThrottlingCache { get; }
    private static UiRequiredProvider();
    [CompilerGeneratedAttribute]
internal ThrottlingCache get_ThrottlingCache();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void ResetCache();
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    private void TryThrowException(string thumbprint, ILoggerAdapter logger);
    private static bool IsRequestSupported(AuthenticationRequestParameters requestParams);
    private static string GetRequestStrictThumbprint(IReadOnlyDictionary`2<string, string> bodyParams, string authority, ICryptographyManager crypto);
}
internal class Microsoft.Identity.Client.OAuth2.TokenClient : object {
    private AuthenticationRequestParameters _requestParams;
    private IServiceBundle _serviceBundle;
    private OAuth2Client _oAuth2Client;
    public TokenClient(AuthenticationRequestParameters requestParams);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.TokenClient/<SendTokenRequestAsync>d__4")]
public Task`1<MsalTokenResponse> SendTokenRequestAsync(IDictionary`2<string, string> additionalBodyParameters, string scopeOverride, string tokenEndpointOverride, CancellationToken cancellationToken);
    private void AddThrottlingHeader();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.TokenClient/<AddBodyParamsAndHeadersAsync>d__6")]
private Task AddBodyParamsAndHeadersAsync(IDictionary`2<string, string> additionalBodyParameters, string scopes, CancellationToken cancellationToken);
    private void AddClaims();
    private void AddExtraHttpHeaders();
    public void AddHeaderToClient(string name, string value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.TokenClient/<SendHttpAndClearTelemetryAsync>d__10")]
private Task`1<MsalTokenResponse> SendHttpAndClearTelemetryAsync(string tokenEndpoint, ILoggerAdapter logger);
    private static string GetDefaultScopes(ISet`1<string> inputScope);
}
internal class Microsoft.Identity.Client.OAuth2.TokenResponseClaim : OAuth2ResponseBaseClaim {
    public static string Code;
    public static string TokenType;
    public static string AccessToken;
    public static string RefreshToken;
    public static string IdToken;
    public static string Scope;
    public static string ClientInfo;
    public static string ExpiresIn;
    public static string CloudInstanceHost;
    public static string CreatedOn;
    public static string ExtendedExpiresIn;
    public static string Authority;
    public static string FamilyId;
    public static string RefreshIn;
    public static string ErrorSubcode;
    public static string ErrorSubcodeCancel;
    public static string TenantId;
    public static string Upn;
    public static string LocalAccountId;
    public static string SpaCode;
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.OsCapabilitiesExtensions : object {
    [ExtensionAttribute]
public static bool IsSystemWebViewAvailable(IPublicClientApplication publicClientApplication);
    [ExtensionAttribute]
public static bool IsEmbeddedWebViewAvailable(IPublicClientApplication publicClientApplication);
    [ExtensionAttribute]
public static bool IsUserInteractive(IPublicClientApplication publicClientApplication);
    [ExtensionAttribute]
public static X509Certificate2 GetCertificate(IConfidentialClientApplication confidentialClientApplication);
}
internal static class Microsoft.Identity.Client.Platforms.iOS.BrokerConstants : object {
    public static string ChallengeResponseHeader;
    public static string ChallengeResponseType;
    public static string ChallengeResponseToken;
    public static string ChallengeResponseContext;
    public static string ChallengeResponseVersion;
    public static string BrowserExtPrefix;
    public static string BrowserExtInstallPrefix;
    public static string DeviceAuthChallengeRedirect;
    public static string ChallengeHeaderKey;
    public static string ChallengeHeaderValue;
}
internal static class Microsoft.Identity.Client.Platforms.iOS.BrokerKeyHelper : object {
    internal static Byte[] GetOrCreateBrokerKey(ILoggerAdapter logger);
    private static Byte[] CreateAndStoreBrokerKey(ILoggerAdapter logger);
    private static bool TryGetBrokerKey(Byte[]& brokerKey);
    internal static string DecryptBrokerResponse(string encryptedBrokerResponse, ILoggerAdapter logger);
    private static Aes CreateSymmetricAlgorithm(Byte[] key);
}
internal class Microsoft.Identity.Client.Platforms.iOS.CoreCustomUrlProtocol : NSUrlProtocol {
    private NSUrlConnection connection;
    [ExportAttribute("initWithRequest:cachedResponse:client:")]
public CoreCustomUrlProtocol(NSUrlRequest request, NSCachedUrlResponse cachedResponse, INSUrlProtocolClient client);
    [ExportAttribute("canInitWithRequest:")]
public static bool canInitWithRequest(NSUrlRequest request);
    [ExportAttribute("canonicalRequestForRequest:")]
public static NSUrlRequest GetCanonicalRequest(NSUrlRequest request);
    public virtual void StartLoading();
    public virtual void StopLoading();
}
internal class Microsoft.Identity.Client.Platforms.iOS.EmbeddedWebview.EmbeddedWebUI : WebviewBase {
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreUIParent <CoreUIParent>k__BackingField;
    public RequestContext RequestContext { get; internal set; }
    public CoreUIParent CoreUIParent { get; public set; }
    [CompilerGeneratedAttribute]
public RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
internal void set_RequestContext(RequestContext value);
    [CompilerGeneratedAttribute]
public CoreUIParent get_CoreUIParent();
    [CompilerGeneratedAttribute]
public void set_CoreUIParent(CoreUIParent value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.iOS.EmbeddedWebview.EmbeddedWebUI/<AcquireAuthorizationAsync>d__8")]
public virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public static void SetAuthorizationResult(AuthorizationResult authorizationResultInput);
    public void Authenticate(Uri authorizationUri, Uri redirectUri, RequestContext requestContext);
    private static void CallbackMethod(AuthorizationResult result);
    public virtual Uri UpdateRedirectUri(Uri redirectUri);
}
[RegisterAttribute("MsalAuthenticationAgentUINavigationController")]
internal class Microsoft.Identity.Client.Platforms.iOS.EmbeddedWebview.MsalAuthenticationAgentUINavigationController : UINavigationController {
    private string url;
    private string callback;
    private ReturnCodeCallback callbackMethod;
    private UIStatusBarStyle preferredStatusBarStyle;
    public MsalAuthenticationAgentUINavigationController(string url, string callback, ReturnCodeCallback callbackMethod, UIStatusBarStyle preferredStatusBarStyle);
    public virtual void DidReceiveMemoryWarning();
    public virtual void ViewDidLoad();
    public virtual UIStatusBarStyle PreferredStatusBarStyle();
}
[RegisterAttribute("MsalAuthenticationAgentUIViewController")]
internal class Microsoft.Identity.Client.Platforms.iOS.EmbeddedWebview.MsalAuthenticationAgentUIViewController : UIViewController {
    private string _url;
    private WKWebView _wkWebView;
    [CompilerGeneratedAttribute]
private ReturnCodeCallback <CallbackMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Callback>k__BackingField;
    public ReturnCodeCallback CallbackMethod { get; }
    public string Callback { get; }
    public MsalAuthenticationAgentUIViewController(string url, string callback, ReturnCodeCallback callbackMethod);
    [CompilerGeneratedAttribute]
public ReturnCodeCallback get_CallbackMethod();
    [CompilerGeneratedAttribute]
public string get_Callback();
    public virtual void ViewDidLoad();
    protected WKWebView PrepareWKWebView();
    private void EvaluateJava();
    private static void HandleWKJavascriptEvaluationResult(NSObject result, NSError err);
    public void CancelAuthentication(object sender, EventArgs e);
    public virtual void DismissViewController(bool animated, Action completionHandler);
    [CompilerGeneratedAttribute]
private void <CancelAuthentication>b__14_0();
}
[RegisterAttribute("MsalUniversalView")]
internal class Microsoft.Identity.Client.Platforms.iOS.EmbeddedWebview.MsalUniversalView : UIView {
    public MsalUniversalView(CGRect bounds);
    private void Initialize();
}
internal class Microsoft.Identity.Client.Platforms.iOS.EmbeddedWebview.WKWebNavigationDelegate : WKNavigationDelegate {
    private static string AboutBlankUri;
    private static string AboutSrcDocUri;
    private MsalAuthenticationAgentUIViewController _authenticationAgentUIViewController;
    public WKWebNavigationDelegate(MsalAuthenticationAgentUIViewController authUIViewController);
    public virtual void DecidePolicy(WKWebView webView, WKNavigationAction navigationAction, Action`1<WKNavigationActionPolicy> decisionHandler);
}
internal class Microsoft.Identity.Client.Platforms.iOS.IntuneEnrollmentIdHelper : object {
    private static string EnrollmentIdKey;
    private static string Intune_MamResourceKey;
    internal static string GetEnrollmentId(ILoggerAdapter logger);
    internal static string GetRawEnrollmentId();
    internal static string GetRawMamResources();
}
internal class Microsoft.Identity.Client.Platforms.iOS.iOSBroker : NSObject {
    private static SemaphoreSlim s_brokerResponseReady;
    private static NSUrl s_brokerResponse;
    private ILoggerAdapter _logger;
    private ICryptographyManager _cryptoManager;
    private CoreUIParent _uIParent;
    private string _brokerRequestNonce;
    private bool _brokerV3Installed;
    public bool IsPopSupported { get; }
    public iOSBroker(ILoggerAdapter logger, ICryptographyManager cryptoManager, CoreUIParent uIParent);
    public sealed virtual bool get_IsPopSupported();
    public sealed virtual bool IsBrokerInstalledAndInvokable(AuthorityType authorityType);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.iOS.iOSBroker/<AcquireTokenInteractiveAsync>d__11")]
public sealed virtual Task`1<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);
    private void ValidateRedirectUri(Uri redirectUri);
    private Dictionary`2<string, string> CreateBrokerRequestDictionary(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);
    public sealed virtual void HandleInstallUrl(string appLink);
    private void AddCommunicationParams(Dictionary`2<string, string> brokerRequest);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.iOS.iOSBroker/<InvokeIosBrokerAsync>d__16")]
private Task InvokeIosBrokerAsync(Dictionary`2<string, string> brokerPayload);
    private MsalTokenResponse ProcessBrokerResponse();
    private MsalTokenResponse ResultFromBrokerResponse(Dictionary`2<string, string> responseDictionary);
    private bool IsBrokerInstalled(string brokerUriScheme);
    private bool ValidateBrokerResponseNonceWithRequestNonce(Dictionary`2<string, string> brokerResponseDictionary);
    private void TryWriteBrokerApplicationTokenToKeychain(string clientId, string applicationToken);
    private string TryReadBrokerApplicationTokenFromKeychain(Dictionary`2<string, string> brokerPayload);
    public static void SetBrokerResponse(NSUrl responseUrl);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetSsoPolicyHeaders();
    public sealed virtual Task RemoveAccountAsync(ApplicationConfiguration applicationConfiguration, IAccount account);
    public sealed virtual Task`1<IReadOnlyList`1<IAccount>> GetAccountsAsync(string clientID, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters);
}
internal class Microsoft.Identity.Client.Platforms.iOS.iOSBrokerConstants : object {
    public static string ChallengeResponseHeader;
    public static string ChallengeResponseType;
    public static string ChallengeResponseToken;
    public static string ChallengeResponseContext;
    public static string ChallengeResponseVersion;
    public static string BrowserExtPrefix;
    public static string BrowserExtInstallPrefix;
    public static string DeviceAuthChallengeRedirect;
    public static string ChallengeHeaderKey;
    public static string ChallengeHeaderValue;
    public static string BrokerKey;
    public static string MsgProtocolVer;
    public static string Claims;
    public static string SkipCache;
    public static string InvokeV3Broker;
    public static string InvokeV2Broker;
    public static string Code;
    public static string BrokerError;
    public static string Error;
    public static string ErrorDescription;
    public static string ExpectedHash;
    public static string EncryptedResponsed;
    public static string BrokerNonce;
    public static string IdentifyiOSBrokerFromResponseUrl;
    public static string BrokerKeyService;
    public static string BrokerKeyAccount;
    public static string BrokerKeyLabel;
    public static string BrokerKeyComment;
    public static string BrokerKeyStorageDescription;
    public static string LocalSettingsContainerName;
    public static string InvokeIosBrokerAppLink;
    public static string InvokeTheIosBroker;
    public static string FailedToSaveBrokerKey;
    public static string UiParentIsNullCannotInvokeBroker;
    public static string CallerViewControllerIsNullCannotInvokeBroker;
    public static string CanInvokeBroker;
    public static string CanInvokeBrokerReturnsFalseMessage;
    public static string iOSBrokerv2Installed;
    public static string iOSBrokerv3Installed;
    public static string BrokerPayloadContainsInstallUrl;
    public static string StartingActionViewActivity;
    public static string BrokerResponseContainsError;
    public static string ProcessBrokerResponse;
    public static string BrokerPayloadPii;
    public static string BrokerPayloadNoPii;
    public static string BrokerResponseValuesPii;
    public static string AttemptToSaveBrokerApplicationToken;
    public static string SecStatusCodeFromTryGetBrokerApplicationToken;
    public static string iOSBroker;
    public static string ApplicationToken;
}
internal class Microsoft.Identity.Client.Platforms.iOS.iOSFeatureFlags : object {
    public bool IsFociEnabled { get; }
    public sealed virtual bool get_IsFociEnabled();
}
internal class Microsoft.Identity.Client.Platforms.iOS.IosHttpClientFactory : object {
    public sealed virtual HttpClient GetHttpClient();
}
internal class Microsoft.Identity.Client.Platforms.iOS.iOSLegacyCachePersistence : object {
    private static string NAME;
    private static string LocalSettingsContainerName;
    private string _keychainGroup;
    private ILoggerAdapter _logger;
    public iOSLegacyCachePersistence(ILoggerAdapter logger);
    private string GetBundleId();
    public void SetKeychainSecurityGroup(string keychainSecurityGroup);
    private sealed virtual override Byte[] Microsoft.Identity.Client.Cache.ILegacyCachePersistence.LoadCache();
    private sealed virtual override void Microsoft.Identity.Client.Cache.ILegacyCachePersistence.WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.Platforms.iOS.iOSPlatformProxy : AbstractPlatformProxy {
    internal static string IosDefaultRedirectUriTemplate;
    public bool LegacyCacheRequiresSerialization { get; }
    public iOSPlatformProxy(ILoggerAdapter logger);
    public virtual Task`1<string> GetUserPrincipalNameAsync();
    protected virtual string InternalGetProcessorArchitecture();
    protected virtual string InternalGetOperatingSystem();
    protected virtual string InternalGetDeviceModel();
    public virtual string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri);
    protected virtual string InternalGetProductName();
    protected virtual string InternalGetCallingApplicationName();
    protected virtual string InternalGetCallingApplicationVersion();
    protected virtual string InternalGetDeviceId();
    public virtual ILegacyCachePersistence CreateLegacyCachePersistence();
    public virtual ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions tokenCacheAccessorOptions, bool isApplicationTokenCache);
    protected virtual IWebUIFactory CreateWebUiFactory();
    protected virtual ICryptographyManager InternalGetCryptographyManager();
    protected virtual IPlatformLogger InternalGetPlatformLogger();
    protected virtual IFeatureFlags CreateFeatureFlags();
    public virtual IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent);
    public virtual bool CanBrokerSupportSilentAuth();
    public virtual IMsalHttpClientFactory CreateDefaultHttpClientFactory();
    public virtual bool get_LegacyCacheRequiresSerialization();
}
internal class Microsoft.Identity.Client.Platforms.iOS.iOSTokenCacheAccessor : object {
    public static string CacheKeyDelimiter;
    private static bool _defaultSyncSetting;
    private static SecAccessible _defaultAccessiblityPolicy;
    private static string TeamIdKey;
    private static string DefaultKeychainAccessGroup;
    private string _keychainGroup;
    private RequestContext _requestContext;
    public iOSTokenCacheAccessor(RequestContext requestContext);
    public sealed virtual void SetiOSKeychainSecurityGroup(string keychainSecurityGroup);
    private string GetTeamId();
    public sealed virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void SaveAccount(MsalAccountCacheItem item);
    public sealed virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public sealed virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public sealed virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void DeleteAccount(MsalAccountCacheItem item);
    public sealed virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public sealed virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public sealed virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public sealed virtual List`1<MsalAccountCacheItem> GetAllAccounts(string optionalPartitionKey, ILoggerAdapter requestlogger);
    internal SecStatusCode TryGetBrokerApplicationToken(string clientId, String& appToken);
    private string GetPayload(IiOSKey key);
    private ICollection`1<string> GetPayloadAsString(int type);
    private SecStatusCode Save(IiOSKey key, string payload);
    internal SecStatusCode SaveBrokerApplicationToken(string clientIdAsKey, string applicationToken);
    private SecStatusCode Remove(IiOSKey key);
    private SecStatusCode Update(SecRecord updatedRecord);
    private void RemoveByType(int type);
    public sealed virtual void Clear(ILoggerAdapter requestlogger);
    public sealed virtual bool HasAccessOrRefreshTokens();
    public MsalAppMetadataCacheItem ReadAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public void WriteAppMetadata(MsalAppMetadataCacheItem appMetadata);
    public sealed virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public sealed virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public sealed virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
}
internal class Microsoft.Identity.Client.Platforms.iOS.IosWebUIFactory : object {
    public bool IsSystemWebViewAvailable { get; }
    public bool IsUserInteractive { get; }
    public bool IsEmbeddedWebViewAvailable { get; }
    public sealed virtual bool get_IsSystemWebViewAvailable();
    public sealed virtual bool get_IsUserInteractive();
    public sealed virtual bool get_IsEmbeddedWebViewAvailable();
    public sealed virtual IWebUI CreateAuthenticationDialog(CoreUIParent coreUIParent, WebViewPreference useEmbeddedWebView, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Platforms.iOS.SystemWebview.ASWebAuthenticationPresentationContextProviderWindow : NSObject {
    public sealed virtual UIWindow GetPresentationAnchor(ASWebAuthenticationSession session);
}
internal class Microsoft.Identity.Client.Platforms.iOS.SystemWebview.SystemWebUI : WebviewBase {
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemWebViewOptions <WebViewOptions>k__BackingField;
    public RequestContext RequestContext { get; public set; }
    internal SystemWebViewOptions WebViewOptions { get; internal set; }
    [CompilerGeneratedAttribute]
public RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public void set_RequestContext(RequestContext value);
    [CompilerGeneratedAttribute]
internal SystemWebViewOptions get_WebViewOptions();
    [CompilerGeneratedAttribute]
internal void set_WebViewOptions(SystemWebViewOptions value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.iOS.SystemWebview.SystemWebUI/<AcquireAuthorizationAsync>d__8")]
public virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public void Authenticate(Uri authorizationUri, Uri redirectUri, RequestContext requestContext);
    public void ProcessCompletionHandlerError(NSError error);
    [ExportAttribute("safariViewControllerDidFinish:")]
public void DidFinish(SFSafariViewController controller);
    public virtual Uri UpdateRedirectUri(Uri redirectUri);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <Authenticate>b__9_0(NSUrl callbackUrl, NSError error);
    [CompilerGeneratedAttribute]
private void <Authenticate>b__9_1();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <Authenticate>b__9_2(NSUrl callbackUrl, NSError error);
    [CompilerGeneratedAttribute]
private void <Authenticate>b__9_3();
}
internal abstract class Microsoft.Identity.Client.Platforms.iOS.WebviewBase : NSObject {
    protected static SemaphoreSlim s_returnedUriReady;
    protected static AuthorizationResult s_authorizationResult;
    protected static UIViewController s_viewController;
    protected SFSafariViewController safariViewController;
    protected SFAuthenticationSession sfAuthenticationSession;
    protected ASWebAuthenticationSession asWebAuthenticationSession;
    [NativeIntegerAttribute]
protected IntPtr taskId;
    protected NSObject didEnterBackgroundNotification;
    protected NSObject willEnterForegroundNotification;
    public abstract virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public static bool ContinueAuthentication(string url, ILoggerAdapter logger);
    protected void OnMoveToBackground(NSNotification notification);
    protected void OnMoveToForeground(NSNotification notification);
    protected virtual void Dispose(bool disposing);
    public abstract virtual Uri UpdateRedirectUri(Uri redirectUri);
    [CompilerGeneratedAttribute]
private void <OnMoveToBackground>b__12_0();
}
internal static class Microsoft.Identity.Client.PlatformsCommon.Factories.PlatformProxyFactory : object {
    public static IPlatformProxy CreatePlatformProxy(ILoggerAdapter logger);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.ICryptographyManager {
    public abstract virtual string CreateBase64UrlEncodedSha256Hash(string input);
    public abstract virtual string GenerateCodeVerifier();
    public abstract virtual string CreateSha256Hash(string input);
    public abstract virtual Byte[] CreateSha256HashBytes(string input);
    public abstract virtual Byte[] SignWithCertificate(string message, X509Certificate2 certificate, RSASignaturePadding signaturePadding);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IDeviceAuthManager {
    public abstract virtual bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders headers, Uri endpointUri, String& responseHeader);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IFeatureFlags {
    public bool IsFociEnabled { get; }
    public abstract virtual bool get_IsFociEnabled();
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IPlatformLogger {
    public abstract virtual void Always(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Warning(string message);
    public abstract virtual void Verbose(string message);
    public abstract virtual void Information(string message);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IPlatformProxy {
    public bool LegacyCacheRequiresSerialization { get; }
    public ICryptographyManager CryptographyManager { get; }
    public IPlatformLogger PlatformLogger { get; }
    public IOtelInstrumentation OtelInstrumentation { get; }
    public bool BrokerSupportsWamAccounts { get; }
    public abstract virtual string GetDeviceModel();
    public abstract virtual string GetOperatingSystem();
    public abstract virtual string GetProcessorArchitecture();
    public abstract virtual Task`1<string> GetUserPrincipalNameAsync();
    public abstract virtual string GetCallingApplicationName();
    public abstract virtual string GetCallingApplicationVersion();
    public abstract virtual string GetDeviceId();
    public abstract virtual string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri);
    public abstract virtual string GetProductName();
    public abstract virtual string GetRuntimeVersion();
    public abstract virtual ILegacyCachePersistence CreateLegacyCachePersistence();
    public abstract virtual bool get_LegacyCacheRequiresSerialization();
    public abstract virtual ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions accessorOptions, bool isApplicationTokenCache);
    public abstract virtual ICryptographyManager get_CryptographyManager();
    public abstract virtual IPlatformLogger get_PlatformLogger();
    public abstract virtual IOtelInstrumentation get_OtelInstrumentation();
    public abstract virtual IWebUIFactory GetWebUiFactory(ApplicationConfiguration appConfig);
    public abstract virtual IPoPCryptoProvider GetDefaultPoPCryptoProvider();
    public abstract virtual IFeatureFlags GetFeatureFlags();
    public abstract virtual void SetFeatureFlags(IFeatureFlags featureFlags);
    public abstract virtual Task StartDefaultOsBrowserAsync(string url, bool isBrokerConfigured);
    public abstract virtual IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent);
    public abstract virtual IDeviceAuthManager CreateDeviceAuthManager();
    public abstract virtual bool CanBrokerSupportSilentAuth();
    public abstract virtual bool get_BrokerSupportsWamAccounts();
    public abstract virtual IMsalHttpClientFactory CreateDefaultHttpClientFactory();
}
internal abstract class Microsoft.Identity.Client.PlatformsCommon.Shared.AbstractPlatformProxy : object {
    public static string MacOsDescriptionForSTS;
    public static string LinuxOSDescriptionForSTS;
    private Lazy`1<string> _callingApplicationName;
    private Lazy`1<string> _callingApplicationVersion;
    private Lazy`1<ICryptographyManager> _cryptographyManager;
    private Lazy`1<string> _deviceId;
    private Lazy`1<string> _deviceModel;
    private Lazy`1<string> _operatingSystem;
    private Lazy`1<IPlatformLogger> _platformLogger;
    private Lazy`1<string> _processorArchitecture;
    private Lazy`1<string> _productName;
    private Lazy`1<string> _runtimeVersion;
    private Lazy`1<IOtelInstrumentation> _otelInstrumentation;
    [CompilerGeneratedAttribute]
private IFeatureFlags <OverloadFeatureFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerAdapter <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheAccessor <UserTokenCacheAccessorForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheAccessor <AppTokenCacheAccessorForTest>k__BackingField;
    protected IFeatureFlags OverloadFeatureFlags { get; protected set; }
    protected ILoggerAdapter Logger { get; }
    public ITokenCacheAccessor UserTokenCacheAccessorForTest { get; public set; }
    public ITokenCacheAccessor AppTokenCacheAccessorForTest { get; public set; }
    public ICryptographyManager CryptographyManager { get; }
    public IPlatformLogger PlatformLogger { get; }
    public IOtelInstrumentation OtelInstrumentation { get; }
    public bool BrokerSupportsWamAccounts { get; }
    public bool LegacyCacheRequiresSerialization { get; }
    protected AbstractPlatformProxy(ILoggerAdapter logger);
    private IOtelInstrumentation InternalGetOtelInstrumentation();
    [CompilerGeneratedAttribute]
protected IFeatureFlags get_OverloadFeatureFlags();
    [CompilerGeneratedAttribute]
protected void set_OverloadFeatureFlags(IFeatureFlags value);
    [CompilerGeneratedAttribute]
protected ILoggerAdapter get_Logger();
    public sealed virtual IWebUIFactory GetWebUiFactory(ApplicationConfiguration appConfig);
    public sealed virtual string GetDeviceModel();
    public sealed virtual string GetOperatingSystem();
    public sealed virtual string GetProcessorArchitecture();
    public abstract virtual Task`1<string> GetUserPrincipalNameAsync();
    public sealed virtual string GetCallingApplicationName();
    public sealed virtual string GetCallingApplicationVersion();
    public sealed virtual string GetDeviceId();
    public abstract virtual string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri);
    public sealed virtual string GetProductName();
    public sealed virtual string GetRuntimeVersion();
    public abstract virtual ILegacyCachePersistence CreateLegacyCachePersistence();
    [CompilerGeneratedAttribute]
public ITokenCacheAccessor get_UserTokenCacheAccessorForTest();
    [CompilerGeneratedAttribute]
public void set_UserTokenCacheAccessorForTest(ITokenCacheAccessor value);
    [CompilerGeneratedAttribute]
public ITokenCacheAccessor get_AppTokenCacheAccessorForTest();
    [CompilerGeneratedAttribute]
public void set_AppTokenCacheAccessorForTest(ITokenCacheAccessor value);
    public virtual ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions tokenCacheAccessorOptions, bool isApplicationTokenCache);
    public sealed virtual ICryptographyManager get_CryptographyManager();
    public sealed virtual IPlatformLogger get_PlatformLogger();
    public sealed virtual IOtelInstrumentation get_OtelInstrumentation();
    protected abstract virtual IWebUIFactory CreateWebUiFactory();
    protected abstract virtual IFeatureFlags CreateFeatureFlags();
    protected abstract virtual string InternalGetDeviceModel();
    protected abstract virtual string InternalGetOperatingSystem();
    protected abstract virtual string InternalGetProcessorArchitecture();
    protected abstract virtual string InternalGetCallingApplicationName();
    protected abstract virtual string InternalGetCallingApplicationVersion();
    protected abstract virtual string InternalGetDeviceId();
    protected abstract virtual string InternalGetProductName();
    protected abstract virtual ICryptographyManager InternalGetCryptographyManager();
    protected abstract virtual IPlatformLogger InternalGetPlatformLogger();
    protected virtual string InternalGetRuntimeVersion();
    public virtual IFeatureFlags GetFeatureFlags();
    public sealed virtual void SetFeatureFlags(IFeatureFlags featureFlags);
    public virtual Task StartDefaultOsBrowserAsync(string url, bool IBrokerConfigured);
    public virtual IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent);
    public virtual bool CanBrokerSupportSilentAuth();
    public virtual bool get_BrokerSupportsWamAccounts();
    public virtual IPoPCryptoProvider GetDefaultPoPCryptoProvider();
    public virtual IDeviceAuthManager CreateDeviceAuthManager();
    public virtual IMsalHttpClientFactory CreateDefaultHttpClientFactory();
    public virtual bool get_LegacyCacheRequiresSerialization();
}
[PreserveAttribute]
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.CommonCryptographyManager : object {
    private static ConcurrentDictionary`2<string, RSA> s_certificateToRsaMap;
    private static int s_maximumMapSize;
    [CompilerGeneratedAttribute]
private ILoggerAdapter <Logger>k__BackingField;
    protected ILoggerAdapter Logger { get; }
    public CommonCryptographyManager(ILoggerAdapter logger);
    private static CommonCryptographyManager();
    [CompilerGeneratedAttribute]
protected ILoggerAdapter get_Logger();
    public sealed virtual string CreateBase64UrlEncodedSha256Hash(string input);
    public sealed virtual string GenerateCodeVerifier();
    public sealed virtual string CreateSha256Hash(string input);
    public sealed virtual Byte[] CreateSha256HashBytes(string input);
    public virtual Byte[] SignWithCertificate(string message, X509Certificate2 certificate, RSASignaturePadding signaturePadding);
    [CompilerGeneratedAttribute]
internal static Byte[] <SignWithCertificate>g__SignDataAndCacheProvider|10_0(string message, <>c__DisplayClass10_0& );
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.ConsolePlatformLogger : object {
    public sealed virtual void Always(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Warning(string message);
    public sealed virtual void Verbose(string message);
    public sealed virtual void Information(string message);
}
internal static class Microsoft.Identity.Client.PlatformsCommon.Shared.DesktopOsHelper : object {
    private static Lazy`1<bool> s_wamSupportedOSLazy;
    private static Lazy`1<string> s_winVersionLazy;
    private static DesktopOsHelper();
    public static bool IsWindows();
    public static bool IsLinux();
    public static bool IsMac();
    private static bool IsWamSupportedOSInternal();
    private static string GetWindowsVersionStringInternal();
    public static string GetWindowsVersionString();
    public static bool IsWin10OrServerEquivalent();
    public static bool IsUserInteractive();
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.DeviceAuthHelper : object {
    public static IDictionary`2<string, string> ParseChallengeData(HttpResponseHeaders responseHeaders);
    public static bool IsDeviceAuthChallenge(HttpResponseHeaders responseHeaders);
    public static string GetBypassChallengeResponse(HttpResponseHeaders responseHeaders);
    public static string GetBypassChallengeResponse(Dictionary`2<string, string> response);
    public static bool CanOSPerformPKeyAuth();
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.DeviceAuthManager : object {
    private ICryptographyManager _cryptographyManager;
    public DeviceAuthManager(ICryptographyManager cryptographyManager);
    public sealed virtual bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders responseHeaders, Uri endpointUri, String& responseHeader);
    private static DeviceAuthJWTResponse GetDeviceAuthJwtResponse(string submitUrl, string nonce, X509Certificate2 certificate);
    private static void FormatResponseHeader(Byte[] signedResponse, IDictionary`2<string, string> challengeData, string responseToSign, String& responseHeader);
    private static X509Certificate2 FindCertificate(IDictionary`2<string, string> challengeData);
    private static X509Certificate2 FindCertificateByCertAuthorities(IDictionary`2<string, string> challengeData, X509Certificate2Collection certCollection);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.EventSourcePlatformLogger : object {
    [CompilerGeneratedAttribute]
private static MsalEventSource <MsalEventSource>k__BackingField;
    internal static MsalEventSource MsalEventSource { get; }
    private static EventSourcePlatformLogger();
    [CompilerGeneratedAttribute]
internal static MsalEventSource get_MsalEventSource();
    public sealed virtual void Always(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Warning(string message);
    public sealed virtual void Verbose(string message);
    public sealed virtual void Information(string message);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.InMemoryLegacyCachePersistance : object {
    private Byte[] data;
    public sealed virtual Byte[] LoadCache();
    public sealed virtual void WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.InMemoryPartitionedAppTokenCacheAccessor : object {
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> AccessTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> AppMetadataDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> s_accessTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> s_appMetadataDictionary;
    protected ILoggerAdapter _logger;
    private CacheOptions _tokenCacheAccessorOptions;
    public InMemoryPartitionedAppTokenCacheAccessor(ILoggerAdapter logger, CacheOptions tokenCacheAccessorOptions);
    private static InMemoryPartitionedAppTokenCacheAccessor();
    public sealed virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void SaveAccount(MsalAccountCacheItem item);
    public sealed virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public sealed virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public sealed virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public sealed virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public sealed virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void DeleteAccount(MsalAccountCacheItem item);
    public virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalAccountCacheItem> GetAllAccounts(string partitionKey, ILoggerAdapter requestlogger);
    public sealed virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public sealed virtual void SetiOSKeychainSecurityGroup(string keychainSecurityGroup);
    public virtual void Clear(ILoggerAdapter requestlogger);
    public virtual bool HasAccessOrRefreshTokens();
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.InMemoryPartitionedUserTokenCacheAccessor : object {
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> AccessTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalRefreshTokenCacheItem>> RefreshTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalIdTokenCacheItem>> IdTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccountCacheItem>> AccountCacheDictionary;
    internal ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> AppMetadataDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> s_accessTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalRefreshTokenCacheItem>> s_refreshTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalIdTokenCacheItem>> s_idTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccountCacheItem>> s_accountCacheDictionary;
    private static ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> s_appMetadataDictionary;
    protected ILoggerAdapter _logger;
    private CacheOptions _tokenCacheAccessorOptions;
    public InMemoryPartitionedUserTokenCacheAccessor(ILoggerAdapter logger, CacheOptions tokenCacheAccessorOptions);
    private static InMemoryPartitionedUserTokenCacheAccessor();
    public sealed virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void SaveAccount(MsalAccountCacheItem item);
    public sealed virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public sealed virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public sealed virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public sealed virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public sealed virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void DeleteAccount(MsalAccountCacheItem item);
    public virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalAccountCacheItem> GetAllAccounts(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public sealed virtual void SetiOSKeychainSecurityGroup(string keychainSecurityGroup);
    public virtual void Clear(ILoggerAdapter requestlogger);
    public virtual bool HasAccessOrRefreshTokens();
}
[EventSourceAttribute]
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.MsalEventSource : EventSource {
    [EventAttribute("1")]
internal void Verbose(string message);
    [EventAttribute("2")]
internal void Information(string message);
    [EventAttribute("3")]
internal void Warning(string message);
    [EventAttribute("4")]
internal void Error(string message);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.NullDeviceAuthManager : object {
    public sealed virtual bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders headers, Uri endpointUri, String& responseHeader);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.NullLegacyCachePersistence : object {
    public sealed virtual Byte[] LoadCache();
    public sealed virtual void WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.PKeyAuthConstants : object {
    public static string DeviceAuthHeaderName;
    public static string DeviceAuthHeaderValue;
    public static string WwwAuthenticateHeader;
    public static string PKeyAuthName;
    public static string ChallengeResponseContext;
    public static string ChallengeResponseVersion;
    public static string PKeyAuthBypassReponseFormat;
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.SimpleHttpClientFactory : object {
    private static ConcurrentDictionary`2<string, HttpClient> s_httpClientPool;
    private static object s_cacheLock;
    private static SimpleHttpClientFactory();
    private static HttpClient CreateHttpClient();
    private static HttpClient CreateMtlsHttpClient(X509Certificate2 bindingCertificate);
    public sealed virtual HttpClient GetHttpClient();
    public sealed virtual HttpClient GetHttpClient(X509Certificate2 x509Certificate2);
    private static void CheckAndManageCache();
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Identity.Client.PreserveAttribute : Attribute {
    public bool Conditional;
    public bool AllMembers;
}
public class Microsoft.Identity.Client.Prompt : ValueType {
    public static Prompt SelectAccount;
    public static Prompt ForceLogin;
    public static Prompt Consent;
    public static Prompt NoPrompt;
    public static Prompt Create;
    internal static Prompt NotSpecified;
    [CompilerGeneratedAttribute]
private string <PromptValue>k__BackingField;
    internal string PromptValue { get; }
    private Prompt(string promptValue);
    private static Prompt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_PromptValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Prompt x, Prompt y);
    public static bool op_Inequality(Prompt x, Prompt y);
}
public class Microsoft.Identity.Client.PublicClientApplication : ClientApplicationBase {
    private static string CurrentOSAccountDescriptor;
    private static IAccount s_currentOsAccount;
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use iOSKeychainSecurityGroup instead (See https://aka.ms/msal-net-ios-keychain-security-group)", "True")]
public string KeychainSecurityGroup { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration", "True")]
public string iOSKeychainSecurityGroup { get; public set; }
    public static IAccount OperatingSystemAccount { get; }
    public bool IsSystemWebViewAvailable { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public PublicClientApplication(string clientId);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public PublicClientApplication(string clientId, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public PublicClientApplication(string clientId, string authority, TokenCache userTokenCache);
    internal PublicClientApplication(ApplicationConfiguration configuration);
    private static PublicClientApplication();
    public sealed virtual string get_KeychainSecurityGroup();
    public sealed virtual string get_iOSKeychainSecurityGroup();
    public sealed virtual void set_iOSKeychainSecurityGroup(string value);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenByUsernamePassword instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(IEnumerable`1<string> scopes, string username, SecureString securePassword);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(IEnumerable`1<string> scopes, string refreshToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes, string username);
    public static IAccount get_OperatingSystemAccount();
    internal static bool IsOperatingSystemAccount(IAccount account);
    public sealed virtual bool get_IsSystemWebViewAvailable();
    public bool IsEmbeddedWebViewAvailable();
    public bool IsUserInteractive();
    [ObsoleteAttribute("This method is obsolete. Applications should rely on the library automatically falling back to a browser if the broker is not available. ", "False")]
public bool IsBrokerAvailable();
    [CLSCompliantAttribute("False")]
public sealed virtual AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(IEnumerable`1<string> scopes);
    public sealed virtual AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    private sealed virtual override AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(IEnumerable`1<string> scopes, string refreshToken);
    public sealed virtual AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password) instead.", "False")]
[EditorBrowsableAttribute("1")]
public sealed virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, SecureString password);
    public sealed virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, string password);
    public bool IsProofOfPossessionSupportedByClient();
}
public class Microsoft.Identity.Client.PublicClientApplicationBuilder : AbstractApplicationBuilder`1<PublicClientApplicationBuilder> {
    internal PublicClientApplicationBuilder(ApplicationConfiguration configuration);
    public static PublicClientApplicationBuilder CreateWithApplicationOptions(PublicClientApplicationOptions options);
    public static PublicClientApplicationBuilder Create(string clientId);
    internal PublicClientApplicationBuilder WithUserTokenLegacyCachePersistenceForTest(ILegacyCachePersistence legacyCachePersistence);
    public PublicClientApplicationBuilder WithDefaultRedirectUri();
    [EditorBrowsableAttribute("1")]
public PublicClientApplicationBuilder WithMultiCloudSupport(bool enableMultiCloudSupport);
    public PublicClientApplicationBuilder WithIosKeychainSecurityGroup(string keychainSecurityGroup);
    public PublicClientApplicationBuilder WithBroker(bool enableBroker);
    [EditorBrowsableAttribute("1")]
public PublicClientApplicationBuilder WithWindowsBrokerOptions(WindowsBrokerOptions options);
    [EditorBrowsableAttribute("1")]
public PublicClientApplicationBuilder WithParentActivityOrWindow(Func`1<object> parentActivityOrWindowFunc);
    private PublicClientApplicationBuilder WithParentFunc(Func`1<object> parentFunc);
    public PublicClientApplicationBuilder WithOidcAuthority(string authorityUri);
    [CLSCompliantAttribute("False")]
public PublicClientApplicationBuilder WithParentActivityOrWindow(Func`1<UIViewController> viewControllerFunc);
    public PublicClientApplicationBuilder WithKerberosTicketClaim(string servicePrincipalName, KerberosTicketContainer ticketContainer);
    [ObsoleteAttribute("This method is obsolete. Applications should rely on the library automatically falling back to a browser if the broker is not available. ", "False")]
public bool IsBrokerAvailable();
    public IPublicClientApplication Build();
    internal PublicClientApplication BuildConcrete();
    internal virtual void Validate();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.PublicClientApplicationExtensions : object {
    [ExtensionAttribute]
public static bool IsProofOfPossessionSupportedByClient(IPublicClientApplication app);
}
public class Microsoft.Identity.Client.PublicClientApplicationOptions : ApplicationOptions {
}
internal interface Microsoft.Identity.Client.Region.IRegionDiscoveryProvider {
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
}
internal interface Microsoft.Identity.Client.Region.IRegionManager {
    public abstract virtual Task`1<string> GetAzureRegionAsync(RequestContext requestContext);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Region.LocalImdsErrorResponse : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <NewestVersions>k__BackingField;
    [JsonPropertyAttribute("error")]
public string Error { get; public set; }
    [JsonPropertyAttribute("newest-versions")]
public List`1<string> NewestVersions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_NewestVersions();
    [CompilerGeneratedAttribute]
public void set_NewestVersions(List`1<string> value);
}
internal enum Microsoft.Identity.Client.Region.RegionAutodetectionSource : Enum {
    public int value__;
    public static RegionAutodetectionSource None;
    public static RegionAutodetectionSource FailedAutoDiscovery;
    public static RegionAutodetectionSource Cache;
    public static RegionAutodetectionSource EnvVariable;
    public static RegionAutodetectionSource Imds;
}
internal class Microsoft.Identity.Client.Region.RegionDiscoveryProvider : object {
    private IRegionManager _regionManager;
    public static string PublicEnvForRegional;
    public RegionDiscoveryProvider(IHttpManager httpManager, bool clearCache);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionDiscoveryProvider/<GetMetadataAsync>d__3")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
    private static InstanceDiscoveryMetadataEntry CreateEntry(string originalEnv, string regionalEnv);
    private static string GetRegionalizedEnvironment(Uri authority, string region, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Region.RegionManager : object {
    private static string ImdsEndpoint;
    private static string DefaultApiVersion;
    private IHttpManager _httpManager;
    private int _imdsCallTimeoutMs;
    private static SemaphoreSlim _lockDiscover;
    private static string s_autoDiscoveredRegion;
    private static bool s_failedAutoDiscovery;
    private static string s_regionDiscoveryDetails;
    public RegionManager(IHttpManager httpManager, int imdsCallTimeout, bool shouldClearStaticCache);
    private static RegionManager();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<GetAzureRegionAsync>d__10")]
public sealed virtual Task`1<string> GetAzureRegionAsync(RequestContext requestContext);
    private static bool IsAutoDiscoveryRequested(string azureRegionConfig);
    private static void RecordTelemetry(ApiEvent apiEvent, string azureRegionConfig, RegionInfo discoveredRegion);
    private static bool IsTelemetryRecorded(ApiEvent apiEvent);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<DiscoverAndCacheAsync>d__14")]
private Task`1<RegionInfo> DiscoverAndCacheAsync(ILoggerAdapter logger, CancellationToken requestCancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<DiscoverAsync>d__15")]
private Task`1<RegionInfo> DiscoverAsync(ILoggerAdapter logger, CancellationToken requestCancellationToken);
    private static RegionInfo GetCachedRegion(ILoggerAdapter logger);
    private static bool ValidateRegion(string region, string source, ILoggerAdapter logger);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<GetImdsUriApiVersionAsync>d__18")]
private Task`1<string> GetImdsUriApiVersionAsync(ILoggerAdapter logger, Dictionary`2<string, string> headers, CancellationToken userCancellationToken);
    private static Uri BuildImdsUri(string apiVersion);
    private CancellationToken GetCancellationToken(CancellationToken userCancellationToken);
}
public enum Microsoft.Identity.Client.Region.RegionOutcome : Enum {
    public int value__;
    public static RegionOutcome None;
    public static RegionOutcome UserProvidedValid;
    public static RegionOutcome UserProvidedAutodetectionFailed;
    public static RegionOutcome UserProvidedInvalid;
    public static RegionOutcome AutodetectSuccess;
    public static RegionOutcome FallbackToGlobal;
}
public class Microsoft.Identity.Client.RegionDetails : object {
    [CompilerGeneratedAttribute]
private RegionOutcome <RegionOutcome>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AutoDetectionError>k__BackingField;
    public RegionOutcome RegionOutcome { get; }
    public string RegionUsed { get; }
    public string AutoDetectionError { get; }
    public RegionDetails(RegionOutcome regionOutcome, string regionUsed, string autoDetectionError);
    [CompilerGeneratedAttribute]
public RegionOutcome get_RegionOutcome();
    [CompilerGeneratedAttribute]
public string get_RegionUsed();
    [CompilerGeneratedAttribute]
public string get_AutoDetectionError();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.SSHCertificates.SSHExtensions : object {
    [ExtensionAttribute]
public static AcquireTokenInteractiveParameterBuilder WithSSHCertificateAuthenticationScheme(AcquireTokenInteractiveParameterBuilder builder, string publicKeyJwk, string keyId);
    [ExtensionAttribute]
public static AcquireTokenSilentParameterBuilder WithSSHCertificateAuthenticationScheme(AcquireTokenSilentParameterBuilder builder, string publicKeyJwk, string keyId);
}
public class Microsoft.Identity.Client.SystemWebViewOptions : object {
    [CompilerGeneratedAttribute]
private string <HtmlMessageSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HtmlMessageError>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BrowserRedirectSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BrowserRedirectError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <iOSHidePrivacyPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Uri, Task> <OpenBrowserAsync>k__BackingField;
    public string HtmlMessageSuccess { get; public set; }
    public string HtmlMessageError { get; public set; }
    public Uri BrowserRedirectSuccess { get; public set; }
    public Uri BrowserRedirectError { get; public set; }
    public bool iOSHidePrivacyPrompt { get; public set; }
    public Func`2<Uri, Task> OpenBrowserAsync { get; public set; }
    [CompilerGeneratedAttribute]
public string get_HtmlMessageSuccess();
    [CompilerGeneratedAttribute]
public void set_HtmlMessageSuccess(string value);
    [CompilerGeneratedAttribute]
public string get_HtmlMessageError();
    [CompilerGeneratedAttribute]
public void set_HtmlMessageError(string value);
    [CompilerGeneratedAttribute]
public Uri get_BrowserRedirectSuccess();
    [CompilerGeneratedAttribute]
public void set_BrowserRedirectSuccess(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_BrowserRedirectError();
    [CompilerGeneratedAttribute]
public void set_BrowserRedirectError(Uri value);
    [CompilerGeneratedAttribute]
public bool get_iOSHidePrivacyPrompt();
    [CompilerGeneratedAttribute]
public void set_iOSHidePrivacyPrompt(bool value);
    [CompilerGeneratedAttribute]
public Func`2<Uri, Task> get_OpenBrowserAsync();
    [CompilerGeneratedAttribute]
public void set_OpenBrowserAsync(Func`2<Uri, Task> value);
    internal void LogParameters(ILoggerAdapter logger);
    internal static void ValidatePlatformAvailability();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.SystemWebViewOptions/<OpenWithEdgeBrowserAsync>d__27")]
public static Task OpenWithEdgeBrowserAsync(Uri uri);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.SystemWebViewOptions/<OpenWithChromeEdgeBrowserAsync>d__28")]
public static Task OpenWithChromeEdgeBrowserAsync(Uri uri);
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_0();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_1();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_2();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_3();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_4();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_5();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_6();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_7();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public class Microsoft.Identity.Client.Telemetry : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public bool TelemetryOnFailureOnly { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static Telemetry GetInstance();
    public bool get_TelemetryOnFailureOnly();
    public void set_TelemetryOnFailureOnly(bool value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public void RegisterReceiver(Receiver r);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public bool HasRegisteredReceiver();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
private sealed virtual override void Microsoft.Identity.Client.TelemetryCore.ITelemetryReceiver.HandleTelemetryEvents(List`1<Dictionary`2<string, string>> events);
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public enum Microsoft.Identity.Client.TelemetryAudienceType : Enum {
    public int value__;
    public static TelemetryAudienceType PreProduction;
    public static TelemetryAudienceType Production;
}
internal enum Microsoft.Identity.Client.TelemetryCore.AssertionType : Enum {
    public int value__;
    public static AssertionType None;
    public static AssertionType CertificateWithoutSni;
    public static AssertionType CertificateWithSni;
    public static AssertionType Secret;
    public static AssertionType ClientAssertion;
    public static AssertionType ManagedIdentity;
}
internal class Microsoft.Identity.Client.TelemetryCore.Http.HttpHeaderSanitizer : object {
    private static String[] s_headerEncodingTable;
    private static HttpHeaderSanitizer();
    public static string SanitizeHeader(string value);
    private static bool HeaderValueNeedsEncoding(string value);
}
internal class Microsoft.Identity.Client.TelemetryCore.Http.HttpTelemetryManager : object {
    public sealed virtual string GetCurrentRequestHeader(ApiEvent eventInProgress);
}
internal interface Microsoft.Identity.Client.TelemetryCore.IHttpTelemetryManager {
    public abstract virtual string GetCurrentRequestHeader(ApiEvent currentApiEvent);
}
internal class Microsoft.Identity.Client.TelemetryCore.Internal.Events.ApiEvent : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiIds <ApiId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAccessTokenCacheHit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionUsed>k__BackingField;
    private Nullable`1<RegionAutodetectionSource> _regionAutodetectionSource;
    private Nullable`1<RegionOutcome> _regionOutcome;
    [CompilerGeneratedAttribute]
private string <AutoDetectedRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionDiscoveryFailureReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTokenCacheSerialized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLegacyCacheEnabled>k__BackingField;
    private Nullable`1<CacheRefreshReason> _cacheInfo;
    [CompilerGeneratedAttribute]
private long <DurationInHttpInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInCacheInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TokenType> <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private AssertionType <AssertionType>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheLevel <CacheLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MsalRuntimeTelemetry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallerSdkApiId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CallerSdkVersion>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public ApiIds ApiId { get; public set; }
    public string ApiIdString { get; }
    public string TokenEndpoint { get; public set; }
    public bool IsAccessTokenCacheHit { get; public set; }
    public string ApiErrorCode { get; public set; }
    public string RegionUsed { get; public set; }
    public RegionAutodetectionSource RegionAutodetectionSource { get; public set; }
    public string RegionAutodetectionSourceString { get; }
    public RegionOutcome RegionOutcome { get; public set; }
    public string RegionOutcomeString { get; }
    public string AutoDetectedRegion { get; internal set; }
    public string RegionDiscoveryFailureReason { get; public set; }
    public bool IsTokenCacheSerialized { get; public set; }
    public char IsTokenCacheSerializedString { get; }
    public bool IsLegacyCacheEnabled { get; public set; }
    public char IsLegacyCacheEnabledString { get; }
    public CacheRefreshReason CacheInfo { get; public set; }
    public string CacheInfoString { get; }
    public long DurationInHttpInMs { get; public set; }
    public long DurationInCacheInMs { get; public set; }
    public Nullable`1<TokenType> TokenType { get; public set; }
    public string TokenTypeString { get; }
    public AssertionType AssertionType { get; public set; }
    public CacheLevel CacheLevel { get; public set; }
    public string MsalRuntimeTelemetry { get; public set; }
    public string CallerSdkApiId { get; public set; }
    public string CallerSdkVersion { get; public set; }
    public ApiEvent(Guid correlationId);
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public ApiIds get_ApiId();
    [CompilerGeneratedAttribute]
public void set_ApiId(ApiIds value);
    public string get_ApiIdString();
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAccessTokenCacheHit();
    [CompilerGeneratedAttribute]
public void set_IsAccessTokenCacheHit(bool value);
    [CompilerGeneratedAttribute]
public string get_ApiErrorCode();
    [CompilerGeneratedAttribute]
public void set_ApiErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_RegionUsed();
    [CompilerGeneratedAttribute]
public void set_RegionUsed(string value);
    public RegionAutodetectionSource get_RegionAutodetectionSource();
    public void set_RegionAutodetectionSource(RegionAutodetectionSource value);
    public string get_RegionAutodetectionSourceString();
    public RegionOutcome get_RegionOutcome();
    public void set_RegionOutcome(RegionOutcome value);
    public string get_RegionOutcomeString();
    [CompilerGeneratedAttribute]
public string get_AutoDetectedRegion();
    [CompilerGeneratedAttribute]
internal void set_AutoDetectedRegion(string value);
    [CompilerGeneratedAttribute]
public string get_RegionDiscoveryFailureReason();
    [CompilerGeneratedAttribute]
public void set_RegionDiscoveryFailureReason(string value);
    [CompilerGeneratedAttribute]
public bool get_IsTokenCacheSerialized();
    [CompilerGeneratedAttribute]
public void set_IsTokenCacheSerialized(bool value);
    public char get_IsTokenCacheSerializedString();
    [CompilerGeneratedAttribute]
public bool get_IsLegacyCacheEnabled();
    [CompilerGeneratedAttribute]
public void set_IsLegacyCacheEnabled(bool value);
    public char get_IsLegacyCacheEnabledString();
    public CacheRefreshReason get_CacheInfo();
    public void set_CacheInfo(CacheRefreshReason value);
    public string get_CacheInfoString();
    [CompilerGeneratedAttribute]
public long get_DurationInHttpInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInHttpInMs(long value);
    [CompilerGeneratedAttribute]
public long get_DurationInCacheInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInCacheInMs(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<TokenType> get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(Nullable`1<TokenType> value);
    public string get_TokenTypeString();
    [CompilerGeneratedAttribute]
public AssertionType get_AssertionType();
    [CompilerGeneratedAttribute]
public void set_AssertionType(AssertionType value);
    [CompilerGeneratedAttribute]
public CacheLevel get_CacheLevel();
    [CompilerGeneratedAttribute]
public void set_CacheLevel(CacheLevel value);
    [CompilerGeneratedAttribute]
public string get_MsalRuntimeTelemetry();
    [CompilerGeneratedAttribute]
public void set_MsalRuntimeTelemetry(string value);
    [CompilerGeneratedAttribute]
public string get_CallerSdkApiId();
    [CompilerGeneratedAttribute]
public void set_CallerSdkApiId(string value);
    [CompilerGeneratedAttribute]
public string get_CallerSdkVersion();
    [CompilerGeneratedAttribute]
public void set_CallerSdkVersion(string value);
    public static bool IsLongRunningObo(ApiIds apiId);
    public static bool IsOnBehalfOfRequest(ApiIds apiId);
}
internal interface Microsoft.Identity.Client.TelemetryCore.ITelemetryReceiver {
    public abstract virtual void HandleTelemetryEvents(List`1<Dictionary`2<string, string>> events);
}
internal interface Microsoft.Identity.Client.TelemetryCore.OpenTelemetry.IOtelInstrumentation {
    internal abstract virtual void LogSuccessMetrics(string platform, ApiIds apiId, string callerSdkId, string callerSdkVersion, CacheLevel cacheLevel, long totalDurationInUs, AuthenticationResultMetadata authResultMetadata, ILoggerAdapter logger);
    internal abstract virtual void IncrementSuccessCounter(string platform, ApiIds apiId, string callerSdkId, string callerSdkVersion, TokenSource tokenSource, CacheRefreshReason cacheRefreshReason, CacheLevel cacheLevel, ILoggerAdapter logger);
    internal abstract virtual void LogFailureMetrics(string platform, string errorCode, ApiIds apiId, string callerSdkId, string callerSdkVersion, CacheRefreshReason cacheRefreshReason);
}
internal class Microsoft.Identity.Client.TelemetryCore.OpenTelemetry.NullOtelInstrumentation : object {
    public sealed virtual void LogSuccessMetrics(string platform, ApiIds apiId, string callerSdkId, string callerSdkVersion, CacheLevel cacheLevel, long totalDurationInUs, AuthenticationResultMetadata authResultMetadata, ILoggerAdapter logger);
    public sealed virtual void LogFailureMetrics(string platform, string errorCode, ApiIds apiId, string callerSdkId, string callerSdkVersion, CacheRefreshReason cacheRefreshReason);
    private sealed virtual override void Microsoft.Identity.Client.TelemetryCore.OpenTelemetry.IOtelInstrumentation.IncrementSuccessCounter(string platform, ApiIds apiId, string callerSdkId, string callerSdkVersion, TokenSource tokenSource, CacheRefreshReason cacheRefreshReason, CacheLevel cacheLevel, ILoggerAdapter logger);
}
public class Microsoft.Identity.Client.TelemetryCore.TelemetryClient.TelemetryData : object {
    [CompilerGeneratedAttribute]
private CacheLevel <CacheLevel>k__BackingField;
    public CacheLevel CacheLevel { get; public set; }
    [CompilerGeneratedAttribute]
public CacheLevel get_CacheLevel();
    [CompilerGeneratedAttribute]
public void set_CacheLevel(CacheLevel value);
}
internal static class Microsoft.Identity.Client.TelemetryCore.TelemetryConstants : object {
    public static char HttpTelemetrySchemaVersion;
    public static char HttpTelemetryPipe;
    public static string XClientCurrentTelemetry;
    public static string False;
    public static string True;
    public static char One;
    public static char Zero;
    public static char CommaDelimiter;
    public static string PlatformFields;
    public static string AcquireTokenEventName;
    public static string ConfigurationUpdateEventName;
    public static string MsalVersion;
    public static string RemainingLifetime;
    public static string TokenType;
    public static string TokenSource;
    public static string CacheInfoTelemetry;
    public static string CacheRefreshReason;
    public static string ErrorCode;
    public static string StsErrorCode;
    public static string ErrorMessage;
    public static string Duration;
    public static string DurationInUs;
    public static string Succeeded;
    public static string DurationInCache;
    public static string DurationInHttp;
    public static string ActivityId;
    public static string Resource;
    public static string RefreshOn;
    public static string CacheLevel;
    public static string AssertionType;
    public static string Endpoint;
    public static string Scopes;
    public static string ClientId;
    public static string Platform;
    public static string ApiId;
    public static string IsProactiveRefresh;
    public static string CallerSdkId;
    public static string CallerSdkVersion;
}
public class Microsoft.Identity.Client.TenantProfile : object {
    private MsalIdTokenCacheItem _msalIdTokenCacheItem;
    public string Oid { get; }
    public string TenantId { get; }
    public ClaimsPrincipal ClaimsPrincipal { get; }
    public bool IsHomeTenant { get; }
    internal TenantProfile(MsalIdTokenCacheItem msalIdTokenCacheItem);
    public string get_Oid();
    public string get_TenantId();
    public ClaimsPrincipal get_ClaimsPrincipal();
    public bool get_IsHomeTenant();
}
public class Microsoft.Identity.Client.TokenCache : object {
    internal static int ExpirationTooLongInDays;
    private IFeatureFlags _featureFlags;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasStateChanged;
    [CompilerGeneratedAttribute]
private ITokenCacheAccessor <Accessor>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private ILegacyCachePersistence <LegacyCachePersistence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAppTokenCache>k__BackingField;
    private OptionalSemaphoreSlim _semaphoreSlim;
    [CompilerGeneratedAttribute]
private TokenCacheCallback <BeforeAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCacheCallback <BeforeWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCacheCallback <AfterAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TokenCacheNotificationArgs, Task> <AsyncBeforeAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TokenCacheNotificationArgs, Task> <AsyncAfterAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TokenCacheNotificationArgs, Task> <AsyncBeforeWrite>k__BackingField;
    private IDictionary`2<string, JToken> _unknownNodes;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use the equivalent flag TokenCacheNotificationArgs.HasStateChanged, which indicates if the operation triggering the notification is modifying the cache or not. Setting the flag is not required.")]
public bool HasStateChanged { get; public set; }
    internal ITokenCacheAccessor Accessor { get; internal set; }
    internal IServiceBundle ServiceBundle { get; }
    internal ILegacyCachePersistence LegacyCachePersistence { get; }
    internal string ClientId { get; }
    private ITokenCacheAccessor Microsoft.Identity.Client.ITokenCacheInternal.Accessor { get; }
    private ILegacyCachePersistence Microsoft.Identity.Client.ITokenCacheInternal.LegacyPersistence { get; }
    internal bool IsAppTokenCache { get; }
    private bool Microsoft.Identity.Client.ITokenCacheInternal.IsApplicationCache { get; }
    private OptionalSemaphoreSlim Microsoft.Identity.Client.ITokenCacheInternal.Semaphore { get; }
    internal TokenCacheCallback BeforeAccess { get; internal set; }
    internal TokenCacheCallback BeforeWrite { get; internal set; }
    internal TokenCacheCallback AfterAccess { get; internal set; }
    internal Func`2<TokenCacheNotificationArgs, Task> AsyncBeforeAccess { get; internal set; }
    internal Func`2<TokenCacheNotificationArgs, Task> AsyncAfterAccess { get; internal set; }
    internal Func`2<TokenCacheNotificationArgs, Task> AsyncBeforeWrite { get; internal set; }
    internal TokenCache(IServiceBundle serviceBundle, bool isApplicationTokenCache, ILegacyCachePersistence legacyCachePersistenceForTest);
    public bool get_HasStateChanged();
    public void set_HasStateChanged(bool value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual CacheData SerializeUnifiedAndAdalCache();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual void DeserializeUnifiedAndAdalCache(CacheData cacheData);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual Byte[] Serialize();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual void Deserialize(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual Byte[] SerializeAdalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual void DeserializeAdalV3(Byte[] adalV3State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual Byte[] SerializeMsalV2();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual void DeserializeMsalV2(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual Byte[] SerializeMsalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual void DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    [CompilerGeneratedAttribute]
internal ITokenCacheAccessor get_Accessor();
    [CompilerGeneratedAttribute]
internal void set_Accessor(ITokenCacheAccessor value);
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    [CompilerGeneratedAttribute]
internal ILegacyCachePersistence get_LegacyCachePersistence();
    internal string get_ClientId();
    private sealed virtual override ITokenCacheAccessor Microsoft.Identity.Client.ITokenCacheInternal.get_Accessor();
    private sealed virtual override ILegacyCachePersistence Microsoft.Identity.Client.ITokenCacheInternal.get_LegacyPersistence();
    [CompilerGeneratedAttribute]
internal bool get_IsAppTokenCache();
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.get_IsApplicationCache();
    private sealed virtual override OptionalSemaphoreSlim Microsoft.Identity.Client.ITokenCacheInternal.get_Semaphore();
    public sealed virtual void SetIosKeychainSecurityGroup(string securityGroup);
    private void UpdateAppMetadata(string clientId, string environment, string familyId);
    private void DeleteAccessTokensWithIntersectingScopes(AuthenticationRequestParameters requestParams, IEnumerable`1<string> environmentAliases, string tenantId, HashSet`1<string> scopeSet, string homeAccountId, string tokenType);
    private static string GetAccessTokenExpireLogMessageContent(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    private bool RtMatchesAccount(MsalRefreshTokenCacheItem rtItem, MsalAccountCacheItem account);
    private static bool FrtExists(IEnumerable`1<MsalRefreshTokenCacheItem> refreshTokens);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-SaveTokenResponseAsync>d__49")]
private sealed virtual override Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> Microsoft.Identity.Client.ITokenCacheInternal.SaveTokenResponseAsync(AuthenticationRequestParameters requestParams, MsalTokenResponse response);
    private static bool ShouldCacheAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem, TokenSource tokenSource);
    private void LogCacheContents(AuthenticationRequestParameters requestParameters);
    private bool IsLegacyAdalCacheEnabled(AuthenticationRequestParameters requestParams);
    private void SaveToLegacyAdalCache(AuthenticationRequestParameters requestParams, MsalTokenResponse response, MsalRefreshTokenCacheItem msalRefreshTokenCacheItem, MsalIdTokenCacheItem msalIdTokenCacheItem, string tenantId, InstanceDiscoveryMetadataEntry instanceDiscoveryMetadata);
    internal static Nullable`1<DateTimeOffset> CalculateSuggestedCacheExpiry(ITokenCacheAccessor accessor, ILoggerAdapter logger);
    private void MergeWamAccountIds(MsalAccountCacheItem msalAccountCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-FindAccessTokenAsync>d__56")]
private sealed virtual override Task`1<MsalAccessTokenCacheItem> Microsoft.Identity.Client.ITokenCacheInternal.FindAccessTokenAsync(AuthenticationRequestParameters requestParams);
    private static void FilterTokensByScopes(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private static void FilterTokensByTokenType(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private static void FilterTokensByHomeAccountTenantOrAssertion(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private MsalAccessTokenCacheItem FilterTokensByExpiry(MsalAccessTokenCacheItem msalAccessTokenCacheItem, AuthenticationRequestParameters requestParams);
    private static MsalAccessTokenCacheItem GetSingleToken(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<FilterTokensByEnvironmentAsync>d__62")]
private Task`1<List`1<MsalAccessTokenCacheItem>> FilterTokensByEnvironmentAsync(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private static MsalAccessTokenCacheItem FilterTokensByPopKeyId(MsalAccessTokenCacheItem item, AuthenticationRequestParameters authenticationRequest);
    private void FilterTokensByClientId(List`1<T> tokenCacheItems);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<ExpireAllAccessTokensForTestAsync>d__65")]
internal Task ExpireAllAccessTokensForTestAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-FindRefreshTokenAsync>d__66")]
private sealed virtual override Task`1<MsalRefreshTokenCacheItem> Microsoft.Identity.Client.ITokenCacheInternal.FindRefreshTokenAsync(AuthenticationRequestParameters requestParams, string familyId);
    private static void FilterRefreshTokensByHomeAccountIdOrAssertion(List`1<MsalRefreshTokenCacheItem> cacheItems, AuthenticationRequestParameters requestParams, string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-IsFociMemberAsync>d__68")]
private sealed virtual override Task`1<Nullable`1<bool>> Microsoft.Identity.Client.ITokenCacheInternal.IsFociMemberAsync(AuthenticationRequestParameters requestParams, string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-GetAccountsAsync>d__69")]
private sealed virtual override Task`1<IEnumerable`1<IAccount>> Microsoft.Identity.Client.ITokenCacheInternal.GetAccountsAsync(AuthenticationRequestParameters requestParameters);
    private static void UpdateMapWithAdalAccountsWithClientInfo(string envFromRequest, IEnumerable`1<string> envAliases, AdalUsersForMsal adalUsers, IDictionary`2<string, Account> clientInfoToAccountMap);
    private static void UpdateWithAdalAccountsWithoutClientInfo(string envFromRequest, IEnumerable`1<string> envAliases, AdalUsersForMsal adalUsers, List`1<IAccount> accounts);
    private sealed virtual override MsalIdTokenCacheItem Microsoft.Identity.Client.ITokenCacheInternal.GetIdTokenCacheItem(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<GetTenantProfilesAsync>d__73")]
private Task`1<IDictionary`2<string, TenantProfile>> GetTenantProfilesAsync(AuthenticationRequestParameters requestParameters, string homeAccountId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-GetAccountAssociatedWithAccessTokenAsync>d__74")]
private sealed virtual override Task`1<Account> Microsoft.Identity.Client.ITokenCacheInternal.GetAccountAssociatedWithAccessTokenAsync(AuthenticationRequestParameters requestParameters, MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-StopLongRunningOboProcessAsync>d__75")]
private sealed virtual override Task`1<bool> Microsoft.Identity.Client.ITokenCacheInternal.StopLongRunningOboProcessAsync(string longRunningOboCacheKey, AuthenticationRequestParameters requestParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-RemoveAccountAsync>d__76")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.RemoveAccountAsync(IAccount account, AuthenticationRequestParameters requestParameters);
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.HasTokensNoLocks();
    private bool RemoveOboTokensInternal(string oboPartitionKey, RequestContext requestContext);
    internal void RemoveAccountInternal(IAccount account, RequestContext requestContext);
    private int RemoveRefreshTokens(List`1<MsalRefreshTokenCacheItem> refreshTokens, ILoggerAdapter logger, Boolean& filterByClientId);
    private int RemoveAccessTokens(List`1<MsalAccessTokenCacheItem> accessTokens, ILoggerAdapter logger, bool filterByClientId);
    private int RemoveIdTokens(string partitionKey, ILoggerAdapter logger, bool filterByClientId);
    private void RemoveAccounts(IAccount account);
    [CompilerGeneratedAttribute]
internal TokenCacheCallback get_BeforeAccess();
    [CompilerGeneratedAttribute]
internal void set_BeforeAccess(TokenCacheCallback value);
    [CompilerGeneratedAttribute]
internal TokenCacheCallback get_BeforeWrite();
    [CompilerGeneratedAttribute]
internal void set_BeforeWrite(TokenCacheCallback value);
    [CompilerGeneratedAttribute]
internal TokenCacheCallback get_AfterAccess();
    [CompilerGeneratedAttribute]
internal void set_AfterAccess(TokenCacheCallback value);
    [CompilerGeneratedAttribute]
internal Func`2<TokenCacheNotificationArgs, Task> get_AsyncBeforeAccess();
    [CompilerGeneratedAttribute]
internal void set_AsyncBeforeAccess(Func`2<TokenCacheNotificationArgs, Task> value);
    [CompilerGeneratedAttribute]
internal Func`2<TokenCacheNotificationArgs, Task> get_AsyncAfterAccess();
    [CompilerGeneratedAttribute]
internal void set_AsyncAfterAccess(Func`2<TokenCacheNotificationArgs, Task> value);
    [CompilerGeneratedAttribute]
internal Func`2<TokenCacheNotificationArgs, Task> get_AsyncBeforeWrite();
    [CompilerGeneratedAttribute]
internal void set_AsyncBeforeWrite(Func`2<TokenCacheNotificationArgs, Task> value);
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.IsAppSubscribedToSerializationEvents();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-OnAfterAccessAsync>d__109")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.OnAfterAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-OnBeforeAccessAsync>d__110")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.OnBeforeAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-OnBeforeWriteAsync>d__111")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.OnBeforeWriteAsync(TokenCacheNotificationArgs args);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBeforeAccess(TokenCacheCallback beforeAccess);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetAfterAccess(TokenCacheCallback afterAccess);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBeforeWrite(TokenCacheCallback beforeWrite);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBeforeAccessAsync(Func`2<TokenCacheNotificationArgs, Task> beforeAccess);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetAfterAccessAsync(Func`2<TokenCacheNotificationArgs, Task> afterAccess);
    [EditorBrowsableAttribute("1")]
public sealed virtual void SetBeforeWriteAsync(Func`2<TokenCacheNotificationArgs, Task> beforeWrite);
    private void Validate();
    private sealed virtual override Byte[] Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3();
    private sealed virtual override void Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(Byte[] adalV3State);
    private sealed virtual override Byte[] Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2();
    private sealed virtual override void Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(Byte[] msalV2State);
    private sealed virtual override Byte[] Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3();
    private sealed virtual override void Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    [CompilerGeneratedAttribute]
private string <SerializeUnifiedAndAdalCache>b__3_0();
    [CompilerGeneratedAttribute]
private bool <FilterTokensByClientId>b__64_0(T x);
    [CompilerGeneratedAttribute]
private MsalAppMetadataCacheItem <Microsoft.Identity.Client.ITokenCacheInternal.IsFociMemberAsync>b__68_0(string env);
    [CompilerGeneratedAttribute]
private string <Microsoft.Identity.Client.ITokenCacheInternal.StopLongRunningOboProcessAsync>b__75_0();
    [CompilerGeneratedAttribute]
private string <Microsoft.Identity.Client.ITokenCacheInternal.RemoveAccountAsync>b__76_0();
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.TokenCacheCallback : MulticastDelegate {
    public TokenCacheCallback(object object, IntPtr method);
    public virtual void Invoke(TokenCacheNotificationArgs args);
    public virtual IAsyncResult BeginInvoke(TokenCacheNotificationArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.TokenCacheExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void SetCacheOptions(ITokenCache tokenCache, CacheOptions options);
    private static void ValidatePlatform();
}
public class Microsoft.Identity.Client.TokenCacheNotificationArgs : object {
    [CompilerGeneratedAttribute]
private ITokenCacheSerializer <TokenCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasStateChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsApplicationCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuggestedCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <RequestScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestTenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <SuggestedCacheExpiry>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryData <TelemetryData>k__BackingField;
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use Account instead (See https://aka.ms/msal-net-2-released)", "True")]
public IUser User { get; }
    public ITokenCacheSerializer TokenCache { get; }
    public string ClientId { get; }
    public IAccount Account { get; }
    public bool HasStateChanged { get; internal set; }
    public bool IsApplicationCache { get; }
    public string SuggestedCacheKey { get; }
    public bool HasTokens { get; }
    public CancellationToken CancellationToken { get; }
    public Guid CorrelationId { get; }
    public IEnumerable`1<string> RequestScopes { get; }
    public string RequestTenantId { get; }
    public Nullable`1<DateTimeOffset> SuggestedCacheExpiry { get; }
    public IIdentityLogger IdentityLogger { get; }
    public bool PiiLoggingEnabled { get; }
    public TelemetryData TelemetryData { get; }
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken);
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId);
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId, IEnumerable`1<string> requestScopes, string requestTenantId);
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId, IEnumerable`1<string> requestScopes, string requestTenantId, IIdentityLogger identityLogger, bool piiLoggingEnabled, TelemetryData telemetryData);
    public IUser get_User();
    [CompilerGeneratedAttribute]
public ITokenCacheSerializer get_TokenCache();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public bool get_HasStateChanged();
    [CompilerGeneratedAttribute]
internal void set_HasStateChanged(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsApplicationCache();
    [CompilerGeneratedAttribute]
public string get_SuggestedCacheKey();
    [CompilerGeneratedAttribute]
public bool get_HasTokens();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RequestScopes();
    [CompilerGeneratedAttribute]
public string get_RequestTenantId();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_SuggestedCacheExpiry();
    [CompilerGeneratedAttribute]
public IIdentityLogger get_IdentityLogger();
    [CompilerGeneratedAttribute]
public bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public TelemetryData get_TelemetryData();
}
internal static class Microsoft.Identity.Client.TokenResponseHelper : object {
    internal static string NullPreferredUsernameDisplayLabel;
    public static string GetTenantId(IdToken idToken, AuthenticationRequestParameters requestParams);
    public static string GetUsernameFromIdToken(IdToken idToken);
    public static string GetHomeAccountId(AuthenticationRequestParameters requestParams, MsalTokenResponse response, IdToken idToken);
    public static Dictionary`2<string, string> GetWamAccountIds(AuthenticationRequestParameters requestParams, MsalTokenResponse response);
}
public enum Microsoft.Identity.Client.TokenSource : Enum {
    public int value__;
    public static TokenSource IdentityProvider;
    public static TokenSource Cache;
    public static TokenSource Broker;
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.TraceTelemetryConfig : object {
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    public TelemetryAudienceType AudienceType { get; }
    public string SessionId { get; }
    public Action`1<ITelemetryEventPayload> DispatchAction { get; }
    public IEnumerable`1<string> AllowedScopes { get; }
    public sealed virtual TelemetryAudienceType get_AudienceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionId();
    public sealed virtual Action`1<ITelemetryEventPayload> get_DispatchAction();
    public IEnumerable`1<string> get_AllowedScopes();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.UI.AuthorizationResult : object {
    [CompilerGeneratedAttribute]
private AuthorizationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudInstanceHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    public AuthorizationStatus Status { get; private set; }
    [JsonPropertyAttribute]
public string Code { get; public set; }
    [JsonPropertyAttribute]
public string Error { get; public set; }
    [JsonPropertyAttribute]
public string ErrorDescription { get; public set; }
    [JsonPropertyAttribute]
public string CloudInstanceHost { get; public set; }
    public string ClientInfo { get; public set; }
    public string State { get; public set; }
    public static AuthorizationResult FromUri(string webAuthenticationResult);
    public static AuthorizationResult FromPostData(Byte[] postData);
    private static AuthorizationResult FromParsedValues(Dictionary`2<string, string> parameters, string url);
    internal static AuthorizationResult FromStatus(AuthorizationStatus status);
    public static AuthorizationResult FromStatus(AuthorizationStatus status, string error, string errorDescription);
    [CompilerGeneratedAttribute]
public AuthorizationStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(AuthorizationStatus value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public void set_ErrorDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CloudInstanceHost();
    [CompilerGeneratedAttribute]
public void set_CloudInstanceHost(string value);
    [CompilerGeneratedAttribute]
public string get_ClientInfo();
    [CompilerGeneratedAttribute]
public void set_ClientInfo(string value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
}
internal enum Microsoft.Identity.Client.UI.AuthorizationStatus : Enum {
    public int value__;
    public static AuthorizationStatus Success;
    public static AuthorizationStatus ErrorHttp;
    public static AuthorizationStatus ProtocolError;
    public static AuthorizationStatus UserCancel;
    public static AuthorizationStatus UnknownError;
}
internal class Microsoft.Identity.Client.UI.CoreUIParent : object {
    [CompilerGeneratedAttribute]
private SynchronizationContext <SynchronizationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemWebViewOptions <SystemWebViewOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedWebViewOptions <EmbeddedWebviewOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private UIViewController <CallerViewController>k__BackingField;
    [CompilerGeneratedAttribute]
private UIStatusBarStyle <PreferredStatusBarStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private UIModalTransitionStyle <ModalTransitionStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private UIModalPresentationStyle <ModalPresentationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private UIViewControllerTransitioningDelegate <TransitioningDelegate>k__BackingField;
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    internal SystemWebViewOptions SystemWebViewOptions { get; internal set; }
    internal EmbeddedWebViewOptions EmbeddedWebviewOptions { get; internal set; }
    public UIViewController CallerViewController { get; public set; }
    public UIStatusBarStyle PreferredStatusBarStyle { get; public set; }
    public UIModalTransitionStyle ModalTransitionStyle { get; public set; }
    public UIModalPresentationStyle ModalPresentationStyle { get; public set; }
    public UIViewControllerTransitioningDelegate TransitioningDelegate { get; public set; }
    public CoreUIParent(UIViewController callerWindow);
    [CompilerGeneratedAttribute]
internal SynchronizationContext get_SynchronizationContext();
    [CompilerGeneratedAttribute]
internal void set_SynchronizationContext(SynchronizationContext value);
    [CompilerGeneratedAttribute]
internal SystemWebViewOptions get_SystemWebViewOptions();
    [CompilerGeneratedAttribute]
internal void set_SystemWebViewOptions(SystemWebViewOptions value);
    [CompilerGeneratedAttribute]
internal EmbeddedWebViewOptions get_EmbeddedWebviewOptions();
    [CompilerGeneratedAttribute]
internal void set_EmbeddedWebviewOptions(EmbeddedWebViewOptions value);
    [CompilerGeneratedAttribute]
public UIViewController get_CallerViewController();
    [CompilerGeneratedAttribute]
public void set_CallerViewController(UIViewController value);
    internal static UIViewController FindCurrentViewController(UIViewController callerViewController);
    [CompilerGeneratedAttribute]
public UIStatusBarStyle get_PreferredStatusBarStyle();
    [CompilerGeneratedAttribute]
public void set_PreferredStatusBarStyle(UIStatusBarStyle value);
    [CompilerGeneratedAttribute]
public UIModalTransitionStyle get_ModalTransitionStyle();
    [CompilerGeneratedAttribute]
public void set_ModalTransitionStyle(UIModalTransitionStyle value);
    [CompilerGeneratedAttribute]
public UIModalPresentationStyle get_ModalPresentationStyle();
    [CompilerGeneratedAttribute]
public void set_ModalPresentationStyle(UIModalPresentationStyle value);
    [CompilerGeneratedAttribute]
public UIViewControllerTransitioningDelegate get_TransitioningDelegate();
    [CompilerGeneratedAttribute]
public void set_TransitioningDelegate(UIViewControllerTransitioningDelegate value);
}
internal class Microsoft.Identity.Client.UI.CustomWebUiHandler : object {
    private ICustomWebUi _customWebUi;
    public CustomWebUiHandler(ICustomWebUi customWebUi);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.UI.CustomWebUiHandler/<AcquireAuthorizationAsync>d__2")]
public sealed virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public sealed virtual Uri UpdateRedirectUri(Uri redirectUri);
}
internal static class Microsoft.Identity.Client.UI.EmbeddedUiCommon : object {
    public static bool IsAllowedIeOrEdgeAuthorizationRedirect(Uri uri);
}
internal interface Microsoft.Identity.Client.UI.IWebUI {
    public abstract virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public abstract virtual Uri UpdateRedirectUri(Uri redirectUri);
}
internal interface Microsoft.Identity.Client.UI.IWebUIFactory {
    public bool IsSystemWebViewAvailable { get; }
    public bool IsUserInteractive { get; }
    public bool IsEmbeddedWebViewAvailable { get; }
    public abstract virtual IWebUI CreateAuthenticationDialog(CoreUIParent coreUIParent, WebViewPreference webViewPreference, RequestContext requestContext);
    public abstract virtual bool get_IsSystemWebViewAvailable();
    public abstract virtual bool get_IsUserInteractive();
    public abstract virtual bool get_IsEmbeddedWebViewAvailable();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("UIBehavior struct is now obsolete.  Please use Prompt struct instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public class Microsoft.Identity.Client.UIBehavior : ValueType {
}
[ObsoleteAttribute("In MSAL.NET 3.x, you should directly pass the Activity (on Xamarin.Android), or Window (on .NET Framework and UWP) using AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindowSee https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.UIParent : object {
    [ObsoleteAttribute("See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public UIParent(object parent, bool useEmbeddedWebView);
    [ObsoleteAttribute("See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public static bool IsSystemWebviewAvailable();
}
public enum Microsoft.Identity.Client.UiRequiredExceptionClassification : Enum {
    public int value__;
    public static UiRequiredExceptionClassification None;
    public static UiRequiredExceptionClassification MessageOnly;
    public static UiRequiredExceptionClassification BasicAction;
    public static UiRequiredExceptionClassification AdditionalAction;
    public static UiRequiredExceptionClassification ConsentRequired;
    public static UiRequiredExceptionClassification UserPasswordExpired;
    public static UiRequiredExceptionClassification PromptNeverFailed;
    public static UiRequiredExceptionClassification AcquireTokenSilentFailed;
}
public class Microsoft.Identity.Client.UserAssertion : object {
    [CompilerGeneratedAttribute]
private string <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssertionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssertionHash>k__BackingField;
    public string Assertion { get; private set; }
    public string AssertionType { get; private set; }
    internal string AssertionHash { get; internal set; }
    public UserAssertion(string jwtBearerToken);
    public UserAssertion(string assertion, string assertionType);
    [CompilerGeneratedAttribute]
public string get_Assertion();
    [CompilerGeneratedAttribute]
private void set_Assertion(string value);
    [CompilerGeneratedAttribute]
public string get_AssertionType();
    [CompilerGeneratedAttribute]
private void set_AssertionType(string value);
    [CompilerGeneratedAttribute]
internal string get_AssertionHash();
    [CompilerGeneratedAttribute]
internal void set_AssertionHash(string value);
}
internal static class Microsoft.Identity.Client.Utils.AuthorityHelpers : object {
    public static string GetTenantId(Uri authorityUri);
}
internal static class Microsoft.Identity.Client.Utils.Base64UrlHelpers : object {
    private static char base64PadCharacter;
    private static char base64Character62;
    private static char base64Character63;
    private static char base64UrlCharacter62;
    private static char base64UrlCharacter63;
    internal static Char[] s_base64Table;
    private static Base64UrlHelpers();
    public static string Encode(string arg);
    private static string Encode(Byte[] inArray, int offset, int length);
    public static string Encode(Byte[] inArray);
    internal static string EncodeString(string str);
    public static Byte[] DecodeBytes(string str);
    private static Byte[] UnsafeDecode(string str);
    public static string Decode(string arg);
}
internal static class Microsoft.Identity.Client.Utils.CollectionHelpers : object {
    public static IReadOnlyList`1<T> GetEmptyReadOnlyList();
    public static List`1<T> GetEmptyList();
    public static IReadOnlyDictionary`2<TKey, TValue> GetEmptyDictionary();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.Identity.Client.Utils.ConcurrentHashSet`1 : object {
    private static int DefaultCapacity;
    private static int MaxLockNumber;
    private IEqualityComparer`1<T> _comparer;
    private bool _growLockArray;
    private int _budget;
    private Tables modreq(System.Runtime.CompilerServices.IsVolatile) _tables;
    private static int DefaultConcurrencyLevel { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ConcurrentHashSet`1(int concurrencyLevel, int capacity);
    public ConcurrentHashSet`1(IEnumerable`1<T> collection);
    public ConcurrentHashSet`1(IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(int concurrencyLevel, IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(int concurrencyLevel, int capacity, IEqualityComparer`1<T> comparer);
    private ConcurrentHashSet`1(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<T> comparer);
    private static int get_DefaultConcurrencyLevel();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public bool TryRemove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Identity.Client.Utils.ConcurrentHashSet`1/<GetEnumerator>d__25")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    private bool AddInternal(T item, int hashcode, bool acquireLock);
    private static int GetBucket(int hashcode, int bucketCount);
    private static void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount);
    private void GrowTable(Tables<T> tables);
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private void CopyToItems(T[] array, int index);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.CoreHelpers : object {
    internal static string ByteArrayToString(Byte[] input);
    public static string UrlEncode(string message);
    public static string UrlDecode(string message);
    public static void AddKeyValueString(StringBuilder messageBuilder, string key, string value);
    [ExtensionAttribute]
public static string ToQueryParameter(IDictionary`2<string, string> input);
    public static Dictionary`2<string, string> ParseKeyValueList(string input, char delimiter, bool urlDecode, bool lowercaseKeys, RequestContext requestContext);
    public static Dictionary`2<string, string> ParseKeyValueList(string input, char delimiter, bool urlDecode, RequestContext requestContext);
    internal static IReadOnlyList`1<string> SplitWithQuotes(string input, char delimiter);
    private static void AddKeyValueString(StringBuilder messageBuilder, string key, Char[] value);
    internal static string GetCcsClientInfoHint(string userObjectId, string userTenantID);
    internal static string GetCcsUpnHint(string upn);
}
internal static class Microsoft.Identity.Client.Utils.DateTimeHelpers : object {
    public static DateTimeOffset UnixTimestampToDateTime(double unixTimestamp);
    public static Nullable`1<DateTimeOffset> UnixTimestampToDateTimeOrNull(double unixTimestamp);
    public static string DateTimeToUnixTimestamp(DateTimeOffset dateTimeOffset);
    public static long CurrDateTimeInUnixTimestamp();
    public static long GetDurationFromWindowsTimestamp(string windowsTimestampInFuture, ILoggerAdapter logger);
    public static long GetDurationFromNowInSeconds(string unixTimestampInFuture);
    public static Nullable`1<DateTimeOffset> DateTimeOffsetFromDuration(Nullable`1<long> duration);
    public static DateTimeOffset DateTimeOffsetFromDuration(long duration);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.EnumerableExtensions : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(IEnumerable`1<T> input);
    [ExtensionAttribute]
internal static string AsSingleString(IEnumerable`1<string> input);
    [ExtensionAttribute]
internal static bool ContainsOrdinalIgnoreCase(IEnumerable`1<string> set, string toLookFor);
    [ExtensionAttribute]
internal static List`1<T> FilterWithLogging(List`1<T> list, Func`2<T, bool> predicate, ILoggerAdapter logger, string logPrefix, bool updateOriginalCollection);
    [ExtensionAttribute]
internal static void MergeDifferentEntries(IDictionary`2<TKey, TValue> source, IDictionary`2<TKey, TValue> other);
}
internal class Microsoft.Identity.Client.Utils.GuidFactory : object {
    public sealed virtual Guid NewGuid();
}
internal interface Microsoft.Identity.Client.Utils.IGuidFactory {
    public abstract virtual Guid NewGuid();
}
internal interface Microsoft.Identity.Client.Utils.ITimeService {
    public abstract virtual DateTime GetUtcNow();
}
internal static class Microsoft.Identity.Client.Utils.JsonHelper : object {
    internal static string SerializeToJson(T toEncode);
    internal static T DeserializeFromJson(string json);
    internal static T TryToDeserializeFromJson(string json, RequestContext requestContext);
    internal static T DeserializeFromJson(Byte[] jsonByteArray);
    internal static string GetExistingOrEmptyString(JObject json, string key);
    internal static string ExtractExistingOrEmptyString(JObject json, string key);
    internal static IDictionary`2<string, string> ExtractInnerJsonAsDictionary(JObject json, string key);
    internal static T ExtractExistingOrDefault(JObject json, string key);
    internal static long ExtractParsedIntOrZero(JObject json, string key);
    internal static string JsonObjectToString(JObject jsonObject);
    internal static JObject ParseIntoJsonObject(string json);
    internal static JObject ToJsonObject(JToken jsonNode);
    internal static bool TryGetValue(JObject json, string propertyName, JToken& value);
    internal static T GetValue(JToken json);
}
internal class Microsoft.Identity.Client.Utils.MeasureDurationResult : ValueType {
    private static int TicksPerMicrosecond;
    private static double s_tickFrequency;
    [CompilerGeneratedAttribute]
private long <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Microseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Ticks>k__BackingField;
    public long Milliseconds { get; }
    public long Microseconds { get; }
    public long Ticks { get; }
    public MeasureDurationResult(long ticks);
    private static MeasureDurationResult();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Milliseconds();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Microseconds();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Ticks();
}
internal class Microsoft.Identity.Client.Utils.MeasureDurationResult`1 : ValueType {
    private static int TicksPerMicrosecond;
    private static double s_tickFrequency;
    [CompilerGeneratedAttribute]
private TResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Milliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Microseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Ticks>k__BackingField;
    public TResult Result { get; }
    public long Milliseconds { get; }
    public long Microseconds { get; }
    public long Ticks { get; }
    public MeasureDurationResult`1(TResult result, long ticks);
    private static MeasureDurationResult`1();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TResult get_Result();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Milliseconds();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Microseconds();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Ticks();
}
internal class Microsoft.Identity.Client.Utils.OptionalSemaphoreSlim : object {
    private bool _useRealSemaphore;
    private int _noLockCurrentCount;
    private SemaphoreSlim _semaphoreSlim;
    public int CurrentCount { get; }
    public OptionalSemaphoreSlim(bool useRealSemaphore);
    public int get_CurrentCount();
    public string GetCurrentCountLogMessage();
    public void Release();
    public Task WaitAsync(CancellationToken cancellationToken);
    public void Wait();
}
internal static class Microsoft.Identity.Client.Utils.ProcessorCounter : object {
    private static int ProcessorCountRefreshIntervalMs;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lastProcessorCountRefreshTicks;
    internal static int ProcessorCount { get; }
    internal static int get_ProcessorCount();
}
internal static class Microsoft.Identity.Client.Utils.RetryOperationHelper : object {
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.RetryOperationHelper/<ExecuteWithRetryAsync>d__0`1")]
public static Task`1<T> ExecuteWithRetryAsync(Func`1<Task`1<T>> func, int maxAttempts, Nullable`1<TimeSpan> retryInterval, Action`2<int, Exception> onAttemptFailed, ISet`1<Type> allowedExceptions);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.RetryOperationHelper/<ExecuteWithRetryAsync>d__1")]
public static Task ExecuteWithRetryAsync(Func`1<Task> func, int maxAttempts, Nullable`1<TimeSpan> retryInterval, Action`2<int, Exception> onAttemptFailed, ISet`1<Type> allowedExceptions);
}
internal static class Microsoft.Identity.Client.Utils.ScopeHelper : object {
    private static string DefaultSuffix;
    public static string OrderScopesAlphabetically(string originalScopes);
    public static bool ScopeContains(ISet`1<string> outerSet, IEnumerable`1<string> possibleContainedSet);
    public static HashSet`1<string> GetMsalScopes(HashSet`1<string> userScopes);
    public static string GetMsalRuntimeScopes();
    public static bool HasNonMsalScopes(HashSet`1<string> userScopes);
    public static HashSet`1<string> ConvertStringToScopeSet(string singleString);
    public static HashSet`1<string> CreateScopeSet(IEnumerable`1<string> input);
    public static string ScopesToResource(String[] scopes);
    public static string RemoveDefaultSuffixIfPresent(string resource);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.StopwatchService : object {
    internal static Stopwatch Watch;
    internal static long CurrentElapsedMilliseconds { get; }
    private static StopwatchService();
    internal static long get_CurrentElapsedMilliseconds();
    internal static MeasureDurationResult MeasureCodeBlock(Action codeBlock);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.StopwatchService/<MeasureCodeBlockAsync>d__4")]
internal static Task`1<MeasureDurationResult> MeasureCodeBlockAsync(Func`1<Task> codeBlock);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.StopwatchService/<MeasureCodeBlockAsync>d__5`1")]
internal static Task`1<MeasureDurationResult`1<TResult>> MeasureCodeBlockAsync(Func`1<Task`1<TResult>> codeBlock);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.StopwatchService/<MeasureAsync>d__6")]
[ExtensionAttribute]
internal static Task`1<MeasureDurationResult> MeasureAsync(Task task);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.StopwatchService/<MeasureAsync>d__7`1")]
[ExtensionAttribute]
internal static Task`1<MeasureDurationResult`1<TResult>> MeasureAsync(Task`1<TResult> task);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.StringExtensions : object {
    private static UTF8Encoding utf8Encoding;
    private static StringExtensions();
    [ExtensionAttribute]
public static Byte[] ToByteArray(string stringInput);
    [ExtensionAttribute]
public static string NullIfEmpty(string s);
    [ExtensionAttribute]
public static string NullIfWhiteSpace(string s);
}
internal class Microsoft.Identity.Client.Utils.StringWriterWithEncoding : StringWriter {
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public StringWriterWithEncoding(Encoding encoding);
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
}
internal class Microsoft.Identity.Client.Utils.TimeService : object {
    public sealed virtual DateTime GetUtcNow();
}
internal class Microsoft.Identity.Client.Utils.TraceWrapper : object {
    public static void WriteLine(string message);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.UriBuilderExtensions : object {
    private static int DefaultHttpsPort;
    [ExtensionAttribute]
public static void AppendQueryParameters(UriBuilder builder, string queryParams);
    [ExtensionAttribute]
public static void AppendQueryParameters(UriBuilder builder, IDictionary`2<string, string> queryParams);
    [ExtensionAttribute]
public static void AppendOrReplaceQueryParameter(UriBuilder builder, string key, string value);
    public static string GetHttpsUriWithOptionalPort(string host, string tenant, string path, int port);
    public static string GetHttpsUriWithOptionalPort(string uri, int port);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.WindowsBrokerOptions : object {
    [CompilerGeneratedAttribute]
private bool <MsaPassthrough>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ListWindowsWorkAndSchoolAccounts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderText>k__BackingField;
    [EditorBrowsableAttribute("1")]
public bool MsaPassthrough { get; public set; }
    public bool ListWindowsWorkAndSchoolAccounts { get; public set; }
    public string HeaderText { get; public set; }
    internal static WindowsBrokerOptions CreateDefault();
    [CompilerGeneratedAttribute]
public bool get_MsaPassthrough();
    [CompilerGeneratedAttribute]
public void set_MsaPassthrough(bool value);
    [CompilerGeneratedAttribute]
public bool get_ListWindowsWorkAndSchoolAccounts();
    [CompilerGeneratedAttribute]
public void set_ListWindowsWorkAndSchoolAccounts(bool value);
    [CompilerGeneratedAttribute]
public string get_HeaderText();
    [CompilerGeneratedAttribute]
public void set_HeaderText(string value);
    internal static void ValidatePlatformAvailability();
}
internal class Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler : object {
    private RequestContext _requestContext;
    private IServiceBundle _serviceBundle;
    public CommonNonInteractiveHandler(RequestContext requestContext, IServiceBundle serviceBundle);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<GetPlatformUserAsync>d__3")]
public Task`1<string> GetPlatformUserAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<QueryUserRealmDataAsync>d__4")]
public Task`1<UserRealmDiscoveryResponse> QueryUserRealmDataAsync(string userRealmUriPrefix, string username);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<PerformWsTrustMexExchangeAsync>d__5")]
public Task`1<WsTrustResponse> PerformWsTrustMexExchangeAsync(string federationMetadataUrl, string cloudAudienceUrn, UserAuthType userAuthType, string username, string password, string federationMetadataFilename);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<GetWsTrustResponseAsync>d__6")]
internal Task`1<WsTrustResponse> GetWsTrustResponseAsync(UserAuthType userAuthType, string cloudAudienceUrn, WsTrustEndpoint endpoint, string username, string password);
}
internal interface Microsoft.Identity.Client.WsTrust.IWsTrustWebRequestManager {
    public abstract virtual Task`1<MexDocument> GetMexDocumentAsync(string federationMetadataUrl, RequestContext requestContext, string federationMetadata);
    public abstract virtual Task`1<WsTrustResponse> GetWsTrustResponseAsync(WsTrustEndpoint wsTrustEndpoint, string wsTrustRequest, RequestContext requestContext);
    public abstract virtual Task`1<UserRealmDiscoveryResponse> GetUserRealmAsync(string userRealmUriPrefix, string userName, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.WsTrust.MexDocument : object {
    private static string WsTrustSoapTransport;
    private Dictionary`2<string, MexPolicy> _policies;
    private Dictionary`2<string, MexPolicy> _bindings;
    public MexDocument(string responseBody);
    public WsTrustEndpoint GetWsTrustUsernamePasswordEndpoint();
    public WsTrustEndpoint GetWsTrustWindowsTransportEndpoint();
    private WsTrustEndpoint GetWsTrustEndpoint(UserAuthType userAuthType);
    private MexPolicy SelectPolicy(UserAuthType userAuthType);
    private void ReadPolicies(XContainer mexDocument);
    private void ReadPolicyBindings(XContainer mexDocument);
    private void SetPolicyEndpointAddresses(XContainer mexDocument);
    private static IEnumerable`1<XElement> FindElements(XContainer mexDocument, XNamespace xNamespace, string element);
    private void AddPolicy(XElement policy, UserAuthType policyAuthType);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.WsTrust.SecureStringExtensions : object {
    [ExtensionAttribute]
public static Char[] PasswordToCharArray(SecureString secureString);
}
internal enum Microsoft.Identity.Client.WsTrust.UserAuthType : Enum {
    public int value__;
    public static UserAuthType IntegratedAuth;
    public static UserAuthType UsernamePassword;
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.WsTrust.UserRealmDiscoveryResponse : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMetadataUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationActiveAuthUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudAudienceUrn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DomainName>k__BackingField;
    [JsonPropertyAttribute("ver")]
public string Version { get; public set; }
    [JsonPropertyAttribute("account_type")]
public string AccountType { get; public set; }
    [JsonPropertyAttribute("federation_protocol")]
public string FederationProtocol { get; public set; }
    [JsonPropertyAttribute("federation_metadata_url")]
public string FederationMetadataUrl { get; public set; }
    [JsonPropertyAttribute("federation_active_auth_url")]
public string FederationActiveAuthUrl { get; public set; }
    [JsonPropertyAttribute("cloud_audience_urn")]
public string CloudAudienceUrn { get; public set; }
    [JsonPropertyAttribute("domain_name")]
public string DomainName { get; public set; }
    public bool IsFederated { get; }
    public bool IsManaged { get; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_AccountType();
    [CompilerGeneratedAttribute]
public void set_AccountType(string value);
    [CompilerGeneratedAttribute]
public string get_FederationProtocol();
    [CompilerGeneratedAttribute]
public void set_FederationProtocol(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMetadataUrl();
    [CompilerGeneratedAttribute]
public void set_FederationMetadataUrl(string value);
    [CompilerGeneratedAttribute]
public string get_FederationActiveAuthUrl();
    [CompilerGeneratedAttribute]
public void set_FederationActiveAuthUrl(string value);
    [CompilerGeneratedAttribute]
public string get_CloudAudienceUrn();
    [CompilerGeneratedAttribute]
public void set_CloudAudienceUrn(string value);
    [CompilerGeneratedAttribute]
public string get_DomainName();
    [CompilerGeneratedAttribute]
public void set_DomainName(string value);
    public bool get_IsFederated();
    public bool get_IsManaged();
}
internal class Microsoft.Identity.Client.WsTrust.WsTrustEndpoint : object {
    private static string EnvelopeNamespaceValue;
    private static string WsuNamespaceValue;
    private ITimeService _timeService;
    private IGuidFactory _guidFactory;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private WsTrustVersion <Version>k__BackingField;
    public Uri Uri { get; }
    public WsTrustVersion Version { get; }
    public WsTrustEndpoint(Uri uri, WsTrustVersion version, ITimeService timeService, IGuidFactory guidFactory);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public WsTrustVersion get_Version();
    public string BuildTokenRequestMessageWindowsIntegratedAuth(string cloudAudienceUri);
    public string BuildTokenRequestMessageUsernamePassword(string cloudAudienceUri, string username, string password);
    private string BuildTokenRequestMessage(UserAuthType authType, string cloudAudienceUri, string username, string password);
    private void AppendSecurityHeader(XmlWriter writer, string username, string password);
    private static string BuildTimeString(DateTime utcTime);
}
internal class Microsoft.Identity.Client.WsTrust.WsTrustResponse : object {
    public static string Saml1Assertion;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    public string Token { get; private set; }
    public string TokenType { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(string value);
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(string value);
    public static WsTrustResponse CreateFromResponse(string response, WsTrustVersion version);
    public static string ReadErrorResponse(XDocument responseDocument);
    private static string GetFaultMessage(XElement fault);
    internal static WsTrustResponse CreateFromResponseDocument(XDocument responseDocument, WsTrustVersion version);
}
internal enum Microsoft.Identity.Client.WsTrust.WsTrustVersion : Enum {
    public int value__;
    public static WsTrustVersion WsTrust13;
    public static WsTrustVersion WsTrust2005;
}
internal class Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager : object {
    private IHttpManager _httpManager;
    public WsTrustWebRequestManager(IHttpManager httpManager);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager/<GetMexDocumentAsync>d__2")]
public sealed virtual Task`1<MexDocument> GetMexDocumentAsync(string federationMetadataUrl, RequestContext requestContext, string federationMetadata);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager/<GetWsTrustResponseAsync>d__3")]
public sealed virtual Task`1<WsTrustResponse> GetWsTrustResponseAsync(WsTrustEndpoint wsTrustEndpoint, string wsTrustRequest, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager/<GetUserRealmAsync>d__4")]
public sealed virtual Task`1<UserRealmDiscoveryResponse> GetUserRealmAsync(string userRealmUriPrefix, string userName, RequestContext requestContext);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Identity.Client.WwwAuthenticateParameters : object {
    private static ISet`1<string> s_knownAuthenticationSchemes;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <RawParameters>k__BackingField;
    [ObsoleteAttribute("The client apps should know which App ID URI it requests scopes for.", "True")]
public string Resource { get; public set; }
    [ObsoleteAttribute("The client apps should know which scopes to request for.", "True")]
public IEnumerable`1<string> Scopes { get; public set; }
    public string Authority { get; public set; }
    public string Claims { get; public set; }
    public string Error { get; public set; }
    public string AuthenticationScheme { get; private set; }
    public string Nonce { get; private set; }
    public string Item { get; }
    internal IDictionary`2<string, string> RawParameters { get; private set; }
    private static WwwAuthenticateParameters();
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
public void set_Authority(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
private void set_AuthenticationScheme(string value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
private void set_Nonce(string value);
    public string get_Item(string key);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_RawParameters();
    [CompilerGeneratedAttribute]
private void set_RawParameters(IDictionary`2<string, string> value);
    public string GetTenantId();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with CreateFromAuthenticationResponseAsync(...)")]
public static Task`1<WwwAuthenticateParameters> CreateFromResourceResponseAsync(string resourceUri);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with CreateFromAuthenticationResponseAsync(...)")]
public static Task`1<WwwAuthenticateParameters> CreateFromResourceResponseAsync(string resourceUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WwwAuthenticateParameters/<CreateFromResourceResponseAsync>d__38")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with replaced with CreateFromAuthenticationResponseAsync(HttpResponseHeaders, string)")]
public static Task`1<WwwAuthenticateParameters> CreateFromResourceResponseAsync(HttpClient httpClient, string resourceUri, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with CreateFromAuthenticationHeaders(...)")]
public static WwwAuthenticateParameters CreateFromResponseHeaders(HttpResponseHeaders httpResponseHeaders, string scheme);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and should not be used.")]
public static WwwAuthenticateParameters CreateFromWwwAuthenticateHeaderValue(string wwwAuthenticateValue);
    public static Task`1<WwwAuthenticateParameters> CreateFromAuthenticationResponseAsync(string resourceUri, string scheme, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WwwAuthenticateParameters/<CreateFromAuthenticationResponseAsync>d__42")]
public static Task`1<WwwAuthenticateParameters> CreateFromAuthenticationResponseAsync(string resourceUri, string scheme, HttpClient httpClient, CancellationToken cancellationToken);
    public static WwwAuthenticateParameters CreateFromAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders, string scheme);
    public static Task`1<IReadOnlyList`1<WwwAuthenticateParameters>> CreateFromAuthenticationResponseAsync(string resourceUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WwwAuthenticateParameters/<CreateFromAuthenticationResponseAsync>d__45")]
public static Task`1<IReadOnlyList`1<WwwAuthenticateParameters>> CreateFromAuthenticationResponseAsync(string resourceUri, HttpClient httpClient, CancellationToken cancellationToken);
    public static IReadOnlyList`1<WwwAuthenticateParameters> CreateFromAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders);
    public static string GetClaimChallengeFromResponseHeaders(HttpResponseHeaders httpResponseHeaders, string scheme);
    private static WwwAuthenticateParameters CreateFromWwwAuthenticationHeaderValue(string wwwAuthenticateValue, string scheme);
    private static IEnumerable`1<string> GetParsedAuthValueElements(string wwwAuthenticateValue);
    internal static WwwAuthenticateParameters CreateWwwAuthenticateParameters(IDictionary`2<string, string> values, string scheme);
    private static string GetJsonFragment(string inputString);
}
internal class Microsoft.Identity.Json.Bson.BsonArray : BsonToken {
    private List`1<BsonToken> _children;
    public BsonType Type { get; }
    public void Add(BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Identity.Json.Bson.BsonBinary : BsonValue {
    [CompilerGeneratedAttribute]
private BsonBinaryType <BinaryType>k__BackingField;
    public BsonBinaryType BinaryType { get; public set; }
    public BsonBinary(Byte[] value, BsonBinaryType binaryType);
    [CompilerGeneratedAttribute]
public BsonBinaryType get_BinaryType();
    [CompilerGeneratedAttribute]
public void set_BinaryType(BsonBinaryType value);
}
internal enum Microsoft.Identity.Json.Bson.BsonBinaryType : Enum {
    public byte value__;
    public static BsonBinaryType Binary;
    public static BsonBinaryType Function;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Binary instead.")]
public static BsonBinaryType BinaryOld;
    [ObsoleteAttribute("This type has been deprecated in the BSON specification. Use Uuid instead.")]
public static BsonBinaryType UuidOld;
    public static BsonBinaryType Uuid;
    public static BsonBinaryType Md5;
    public static BsonBinaryType UserDefined;
}
internal class Microsoft.Identity.Json.Bson.BsonBinaryWriter : object {
    private static Encoding Encoding;
    private BinaryWriter _writer;
    private Byte[] _largeByteBuffer;
    [CompilerGeneratedAttribute]
private DateTimeKind <DateTimeKindHandling>k__BackingField;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonBinaryWriter(BinaryWriter writer);
    private static BsonBinaryWriter();
    [CompilerGeneratedAttribute]
public DateTimeKind get_DateTimeKindHandling();
    [CompilerGeneratedAttribute]
public void set_DateTimeKindHandling(DateTimeKind value);
    public void Flush();
    public void Close();
    public void WriteToken(BsonToken t);
    private void WriteTokenInternal(BsonToken t);
    private void WriteString(string s, int byteCount, Nullable`1<int> calculatedlengthPrefix);
    public void WriteUtf8Bytes(string s, int byteCount);
    private int CalculateSize(int stringByteCount);
    private int CalculateSizeWithLength(int stringByteCount, bool includeSize);
    private int CalculateSize(BsonToken t);
}
internal class Microsoft.Identity.Json.Bson.BsonBoolean : BsonValue {
    public static BsonBoolean False;
    public static BsonBoolean True;
    private BsonBoolean(bool value);
    private static BsonBoolean();
}
internal class Microsoft.Identity.Json.Bson.BsonEmpty : BsonToken {
    public static BsonToken Null;
    public static BsonToken Undefined;
    [CompilerGeneratedAttribute]
private BsonType <Type>k__BackingField;
    public BsonType Type { get; }
    private BsonEmpty(BsonType type);
    private static BsonEmpty();
    [CompilerGeneratedAttribute]
public virtual BsonType get_Type();
}
internal class Microsoft.Identity.Json.Bson.BsonObject : BsonToken {
    private List`1<BsonProperty> _children;
    public BsonType Type { get; }
    public void Add(string name, BsonToken token);
    public virtual BsonType get_Type();
    public sealed virtual IEnumerator`1<BsonProperty> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Microsoft.Identity.Json.Bson.BsonObjectId : object {
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Byte[] Value { get; }
    public BsonObjectId(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
}
internal class Microsoft.Identity.Json.Bson.BsonProperty : object {
    [CompilerGeneratedAttribute]
private BsonString <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonToken <Value>k__BackingField;
    public BsonString Name { get; public set; }
    public BsonToken Value { get; public set; }
    [CompilerGeneratedAttribute]
public BsonString get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(BsonString value);
    [CompilerGeneratedAttribute]
public BsonToken get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(BsonToken value);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Microsoft.Identity.Json.Bson.BsonReader : JsonReader {
    private static int MaxCharBytesSize;
    private static Byte[] SeqRange1;
    private static Byte[] SeqRange2;
    private static Byte[] SeqRange3;
    private static Byte[] SeqRange4;
    private BinaryReader _reader;
    private List`1<ContainerContext> _stack;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private BsonType _currentElementType;
    private BsonReaderState _bsonReaderState;
    private ContainerContext _currentContext;
    private bool _readRootValueAsArray;
    private bool _jsonNet35BinaryCompatibility;
    private DateTimeKind _dateTimeKindHandling;
    [ObsoleteAttribute("JsonNet35BinaryCompatibility will be removed in a future version of Json.NET.")]
public bool JsonNet35BinaryCompatibility { get; public set; }
    public bool ReadRootValueAsArray { get; public set; }
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonReader(Stream stream);
    public BsonReader(BinaryReader reader);
    public BsonReader(Stream stream, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    public BsonReader(BinaryReader reader, bool readRootValueAsArray, DateTimeKind dateTimeKindHandling);
    private static BsonReader();
    public bool get_JsonNet35BinaryCompatibility();
    public void set_JsonNet35BinaryCompatibility(bool value);
    public bool get_ReadRootValueAsArray();
    public void set_ReadRootValueAsArray(bool value);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    private string ReadElement();
    public virtual bool Read();
    public virtual void Close();
    private bool ReadCodeWScope();
    private bool ReadReference();
    private bool ReadNormal();
    private void PopContext();
    private void PushContext(ContainerContext newContext);
    private byte ReadByte();
    private void ReadType(BsonType type);
    private Byte[] ReadBinary(BsonBinaryType& binaryType);
    private string ReadString();
    private string ReadLengthString();
    private string GetString(int length);
    private int GetLastFullCharStop(int start);
    private int BytesInSequence(byte b);
    private void EnsureBuffers();
    private double ReadDouble();
    private int ReadInt32();
    private long ReadInt64();
    private BsonType ReadType();
    private void MovePosition(int count);
    private Byte[] ReadBytes(int count);
}
internal class Microsoft.Identity.Json.Bson.BsonRegex : BsonToken {
    [CompilerGeneratedAttribute]
private BsonString <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonString <Options>k__BackingField;
    public BsonString Pattern { get; public set; }
    public BsonString Options { get; public set; }
    public BsonType Type { get; }
    public BsonRegex(string pattern, string options);
    [CompilerGeneratedAttribute]
public BsonString get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(BsonString value);
    [CompilerGeneratedAttribute]
public BsonString get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(BsonString value);
    public virtual BsonType get_Type();
}
internal class Microsoft.Identity.Json.Bson.BsonString : BsonValue {
    [CompilerGeneratedAttribute]
private int <ByteCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeLength>k__BackingField;
    public int ByteCount { get; public set; }
    public bool IncludeLength { get; }
    public BsonString(object value, bool includeLength);
    [CompilerGeneratedAttribute]
public int get_ByteCount();
    [CompilerGeneratedAttribute]
public void set_ByteCount(int value);
    [CompilerGeneratedAttribute]
public bool get_IncludeLength();
}
internal abstract class Microsoft.Identity.Json.Bson.BsonToken : object {
    [CompilerGeneratedAttribute]
private BsonToken <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CalculatedSize>k__BackingField;
    public BsonType Type { get; }
    public BsonToken Parent { get; public set; }
    public int CalculatedSize { get; public set; }
    public abstract virtual BsonType get_Type();
    [CompilerGeneratedAttribute]
public BsonToken get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(BsonToken value);
    [CompilerGeneratedAttribute]
public int get_CalculatedSize();
    [CompilerGeneratedAttribute]
public void set_CalculatedSize(int value);
}
internal enum Microsoft.Identity.Json.Bson.BsonType : Enum {
    public sbyte value__;
    public static BsonType Number;
    public static BsonType String;
    public static BsonType Object;
    public static BsonType Array;
    public static BsonType Binary;
    public static BsonType Undefined;
    public static BsonType Oid;
    public static BsonType Boolean;
    public static BsonType Date;
    public static BsonType Null;
    public static BsonType Regex;
    public static BsonType Reference;
    public static BsonType Code;
    public static BsonType Symbol;
    public static BsonType CodeWScope;
    public static BsonType Integer;
    public static BsonType TimeStamp;
    public static BsonType Long;
    public static BsonType MinKey;
    public static BsonType MaxKey;
}
internal class Microsoft.Identity.Json.Bson.BsonValue : BsonToken {
    private object _value;
    private BsonType _type;
    public object Value { get; }
    public BsonType Type { get; }
    public BsonValue(object value, BsonType type);
    public object get_Value();
    public virtual BsonType get_Type();
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Microsoft.Identity.Json.Bson.BsonWriter : JsonWriter {
    private BsonBinaryWriter _writer;
    private BsonToken _root;
    private BsonToken _parent;
    private string _propertyName;
    public DateTimeKind DateTimeKindHandling { get; public set; }
    public BsonWriter(Stream stream);
    public BsonWriter(BinaryWriter writer);
    public DateTimeKind get_DateTimeKindHandling();
    public void set_DateTimeKindHandling(DateTimeKind value);
    public virtual void Flush();
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WriteComment(string text);
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteRaw(string json);
    public virtual void WriteRawValue(string json);
    public virtual void WriteStartArray();
    public virtual void WriteStartObject();
    public virtual void WritePropertyName(string name);
    public virtual void Close();
    private void AddParent(BsonToken container);
    private void RemoveParent();
    private void AddValue(object value, BsonType type);
    internal void AddToken(BsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Uri value);
    public void WriteObjectId(Byte[] value);
    public void WriteRegex(string pattern, string options);
}
internal enum Microsoft.Identity.Json.ConstructorHandling : Enum {
    public int value__;
    public static ConstructorHandling Default;
    public static ConstructorHandling AllowNonPublicDefaultConstructor;
}
internal class Microsoft.Identity.Json.Converters.BinaryConverter : JsonConverter {
    private static string BinaryTypeName;
    private static string BinaryToArrayName;
    [NullableAttribute("2")]
private static ReflectionObject _reflectionObject;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private Byte[] GetByteArray(object value);
    private static void EnsureReflectionObject(Type t);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private Byte[] ReadByteArray(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
}
[ObsoleteAttribute("BSON reading and writing has been moved to its own package. See https://www.nuget.org/packages/Newtonsoft.Json.Bson for more details.")]
internal class Microsoft.Identity.Json.Converters.BsonObjectIdConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal abstract class Microsoft.Identity.Json.Converters.CustomCreationConverter`1 : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T Create(Type objectType);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
internal abstract class Microsoft.Identity.Json.Converters.DateTimeConverterBase : JsonConverter {
    public virtual bool CanConvert(Type objectType);
}
internal class Microsoft.Identity.Json.Converters.DiscriminatedUnionConverter : JsonConverter {
    private static string CasePropertyName;
    private static string FieldsPropertyName;
    private static ThreadSafeStore`2<Type, Union> UnionCache;
    private static ThreadSafeStore`2<Type, Type> UnionTypeLookupCache;
    private static DiscriminatedUnionConverter();
    private static Type CreateUnionTypeLookup(Type t);
    private static Union CreateUnion(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Microsoft.Identity.Json.Converters.ExpandoObjectConverter : JsonConverter {
    public bool CanWrite { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadValue(JsonReader reader);
    private object ReadList(JsonReader reader);
    private object ReadObject(JsonReader reader);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanWrite();
}
internal class Microsoft.Identity.Json.Converters.IsoDateTimeConverter : DateTimeConverterBase {
    private static string DefaultDateTimeFormat;
    private DateTimeStyles _dateTimeStyles;
    [NullableAttribute("2")]
private string _dateTimeFormat;
    [NullableAttribute("2")]
private CultureInfo _culture;
    public DateTimeStyles DateTimeStyles { get; public set; }
    [NullableAttribute("2")]
public string DateTimeFormat { get; public set; }
    public CultureInfo Culture { get; public set; }
    public DateTimeStyles get_DateTimeStyles();
    public void set_DateTimeStyles(DateTimeStyles value);
    [NullableContextAttribute("2")]
public string get_DateTimeFormat();
    [NullableContextAttribute("2")]
public void set_DateTimeFormat(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal interface Microsoft.Identity.Json.Converters.IXmlDeclaration {
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public abstract virtual string get_Version();
    public abstract virtual string get_Encoding();
    public abstract virtual void set_Encoding(string value);
    public abstract virtual string get_Standalone();
    public abstract virtual void set_Standalone(string value);
}
internal interface Microsoft.Identity.Json.Converters.IXmlDocument {
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public abstract virtual IXmlNode CreateComment(string text);
    public abstract virtual IXmlNode CreateTextNode(string text);
    public abstract virtual IXmlNode CreateCDataSection(string data);
    public abstract virtual IXmlNode CreateWhitespace(string text);
    public abstract virtual IXmlNode CreateSignificantWhitespace(string text);
    [NullableContextAttribute("2")]
public abstract virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public abstract virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public abstract virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public abstract virtual IXmlElement CreateElement(string elementName);
    public abstract virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public abstract virtual IXmlNode CreateAttribute(string name, string value);
    public abstract virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public abstract virtual IXmlElement get_DocumentElement();
}
internal interface Microsoft.Identity.Json.Converters.IXmlDocumentType {
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_System();
    public abstract virtual string get_Public();
    public abstract virtual string get_InternalSubset();
}
internal interface Microsoft.Identity.Json.Converters.IXmlElement {
    public bool IsEmpty { get; }
    public abstract virtual void SetAttributeNode(IXmlNode attribute);
    public abstract virtual string GetPrefixOfNamespace(string namespaceUri);
    public abstract virtual bool get_IsEmpty();
}
[NullableContextAttribute("2")]
internal interface Microsoft.Identity.Json.Converters.IXmlNode {
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("0")]
public List`1<IXmlNode> ChildNodes { get; }
    [NullableAttribute("0")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public object WrappedNode { get; }
    public abstract virtual XmlNodeType get_NodeType();
    public abstract virtual string get_LocalName();
    [NullableContextAttribute("0")]
public abstract virtual List`1<IXmlNode> get_ChildNodes();
    [NullableContextAttribute("0")]
public abstract virtual List`1<IXmlNode> get_Attributes();
    public abstract virtual IXmlNode get_ParentNode();
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    [NullableContextAttribute("0")]
public abstract virtual IXmlNode AppendChild(IXmlNode newChild);
    public abstract virtual string get_NamespaceUri();
    public abstract virtual object get_WrappedNode();
}
internal class Microsoft.Identity.Json.Converters.JavaScriptDateTimeConverter : DateTimeConverterBase {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal class Microsoft.Identity.Json.Converters.KeyValuePairConverter : JsonConverter {
    private static string KeyName;
    private static string ValueName;
    private static ThreadSafeStore`2<Type, ReflectionObject> ReflectionObjectPerType;
    private static KeyValuePairConverter();
    private static ReflectionObject InitializeReflectionObject(Type t);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Microsoft.Identity.Json.Converters.RegexConverter : JsonConverter {
    private static string PatternName;
    private static string OptionsName;
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private bool HasFlag(RegexOptions options, RegexOptions flag);
    private void WriteBson(BsonWriter writer, Regex regex);
    private void WriteJson(JsonWriter writer, Regex regex, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private object ReadRegexString(JsonReader reader);
    private Regex ReadRegexObject(JsonReader reader, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    private bool IsRegex(Type objectType);
}
internal class Microsoft.Identity.Json.Converters.StringEnumConverter : JsonConverter {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowIntegerValues>k__BackingField;
    [ObsoleteAttribute("StringEnumConverter.CamelCaseText is obsolete. Set StringEnumConverter.NamingStrategy with CamelCaseNamingStrategy instead.")]
public bool CamelCaseText { get; public set; }
    [NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    public bool AllowIntegerValues { get; public set; }
    [ObsoleteAttribute("StringEnumConverter(bool) is obsolete. Create a converter with StringEnumConverter(NamingStrategy, bool) instead.")]
public StringEnumConverter(bool camelCaseText);
    public StringEnumConverter(NamingStrategy namingStrategy, bool allowIntegerValues);
    public StringEnumConverter(Type namingStrategyType);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters);
    public StringEnumConverter(Type namingStrategyType, Object[] namingStrategyParameters, bool allowIntegerValues);
    public bool get_CamelCaseText();
    public void set_CamelCaseText(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    [CompilerGeneratedAttribute]
public bool get_AllowIntegerValues();
    [CompilerGeneratedAttribute]
public void set_AllowIntegerValues(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
internal class Microsoft.Identity.Json.Converters.UnixDateTimeConverter : DateTimeConverterBase {
    internal static DateTime UnixEpoch;
    private static UnixDateTimeConverter();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
}
internal class Microsoft.Identity.Json.Converters.VersionConverter : JsonConverter {
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Converters.XAttributeWrapper : XObjectWrapper {
    [NullableAttribute("0")]
private XAttribute Attribute { get; }
    public string Value { get; public set; }
    public string LocalName { get; }
    public string NamespaceUri { get; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("0")]
public XAttributeWrapper(XAttribute attribute);
    [NullableContextAttribute("0")]
private XAttribute get_Attribute();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual string get_LocalName();
    public virtual string get_NamespaceUri();
    public virtual IXmlNode get_ParentNode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Converters.XCommentWrapper : XObjectWrapper {
    [NullableAttribute("0")]
private XComment Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("0")]
public XCommentWrapper(XComment text);
    [NullableContextAttribute("0")]
private XComment get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal class Microsoft.Identity.Json.Converters.XContainerWrapper : XObjectWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    private XContainer Container { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("2")]
public IXmlNode ParentNode { get; }
    public XContainerWrapper(XContainer container);
    private XContainer get_Container();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [NullableContextAttribute("2")]
public virtual IXmlNode get_ParentNode();
    internal static IXmlNode WrapNode(XObject node);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Microsoft.Identity.Json.Converters.XDeclarationWrapper : XObjectWrapper {
    [CompilerGeneratedAttribute]
private XDeclaration <Declaration>k__BackingField;
    internal XDeclaration Declaration { get; }
    public XmlNodeType NodeType { get; }
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XDeclarationWrapper(XDeclaration declaration);
    [CompilerGeneratedAttribute]
internal XDeclaration get_Declaration();
    public virtual XmlNodeType get_NodeType();
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Microsoft.Identity.Json.Converters.XDocumentTypeWrapper : XObjectWrapper {
    private XDocumentType _documentType;
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    [NullableAttribute("2")]
public string LocalName { get; }
    public XDocumentTypeWrapper(XDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    [NullableContextAttribute("2")]
public virtual string get_LocalName();
}
internal class Microsoft.Identity.Json.Converters.XDocumentWrapper : XContainerWrapper {
    private XDocument Document { get; }
    public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XDocumentWrapper(XDocument document);
    private XDocument get_Document();
    public virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    public sealed virtual IXmlNode CreateComment(string text);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
    public virtual IXmlNode AppendChild(IXmlNode newChild);
}
internal class Microsoft.Identity.Json.Converters.XElementWrapper : XContainerWrapper {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    private XElement Element { get; }
    public List`1<IXmlNode> Attributes { get; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    [NullableAttribute("2")]
public string LocalName { get; }
    [NullableAttribute("2")]
public string NamespaceUri { get; }
    public bool IsEmpty { get; }
    public XElementWrapper(XElement element);
    private XElement get_Element();
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public virtual List`1<IXmlNode> get_Attributes();
    private bool HasImplicitNamespaceAttribute(string namespaceUri);
    public virtual IXmlNode AppendChild(IXmlNode newChild);
    [NullableContextAttribute("2")]
public virtual string get_Value();
    [NullableContextAttribute("2")]
public virtual void set_Value(string value);
    [NullableContextAttribute("2")]
public virtual string get_LocalName();
    [NullableContextAttribute("2")]
public virtual string get_NamespaceUri();
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
internal class Microsoft.Identity.Json.Converters.XmlDeclarationWrapper : XmlNodeWrapper {
    private XmlDeclaration _declaration;
    public string Version { get; }
    public string Encoding { get; public set; }
    public string Standalone { get; public set; }
    public XmlDeclarationWrapper(XmlDeclaration declaration);
    public sealed virtual string get_Version();
    public sealed virtual string get_Encoding();
    public sealed virtual void set_Encoding(string value);
    public sealed virtual string get_Standalone();
    public sealed virtual void set_Standalone(string value);
}
internal class Microsoft.Identity.Json.Converters.XmlDocumentTypeWrapper : XmlNodeWrapper {
    private XmlDocumentType _documentType;
    public string Name { get; }
    public string System { get; }
    public string Public { get; }
    public string InternalSubset { get; }
    [NullableAttribute("2")]
public string LocalName { get; }
    public XmlDocumentTypeWrapper(XmlDocumentType documentType);
    public sealed virtual string get_Name();
    public sealed virtual string get_System();
    public sealed virtual string get_Public();
    public sealed virtual string get_InternalSubset();
    [NullableContextAttribute("2")]
public virtual string get_LocalName();
}
internal class Microsoft.Identity.Json.Converters.XmlDocumentWrapper : XmlNodeWrapper {
    private XmlDocument _document;
    [NullableAttribute("2")]
public IXmlElement DocumentElement { get; }
    public XmlDocumentWrapper(XmlDocument document);
    public sealed virtual IXmlNode CreateComment(string data);
    public sealed virtual IXmlNode CreateTextNode(string text);
    public sealed virtual IXmlNode CreateCDataSection(string data);
    public sealed virtual IXmlNode CreateWhitespace(string text);
    public sealed virtual IXmlNode CreateSignificantWhitespace(string text);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDeclaration(string version, string encoding, string standalone);
    [NullableContextAttribute("2")]
public sealed virtual IXmlNode CreateXmlDocumentType(string name, string publicId, string systemId, string internalSubset);
    public sealed virtual IXmlNode CreateProcessingInstruction(string target, string data);
    public sealed virtual IXmlElement CreateElement(string elementName);
    public sealed virtual IXmlElement CreateElement(string qualifiedName, string namespaceUri);
    public sealed virtual IXmlNode CreateAttribute(string name, string value);
    public sealed virtual IXmlNode CreateAttribute(string qualifiedName, string namespaceUri, string value);
    [NullableContextAttribute("2")]
public sealed virtual IXmlElement get_DocumentElement();
}
internal class Microsoft.Identity.Json.Converters.XmlElementWrapper : XmlNodeWrapper {
    private XmlElement _element;
    public bool IsEmpty { get; }
    public XmlElementWrapper(XmlElement element);
    public sealed virtual void SetAttributeNode(IXmlNode attribute);
    public sealed virtual string GetPrefixOfNamespace(string namespaceUri);
    public sealed virtual bool get_IsEmpty();
}
internal class Microsoft.Identity.Json.Converters.XmlNodeConverter : JsonConverter {
    internal static List`1<IXmlNode> EmptyChildNodes;
    private static string TextName;
    private static string CommentName;
    private static string CDataName;
    private static string WhitespaceName;
    private static string SignificantWhitespaceName;
    private static string DeclarationName;
    private static string JsonNamespaceUri;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <DeserializeRootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteArrayAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OmitRootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EncodeSpecialCharacters>k__BackingField;
    [NullableAttribute("2")]
public string DeserializeRootElementName { get; public set; }
    public bool WriteArrayAttribute { get; public set; }
    public bool OmitRootObject { get; public set; }
    public bool EncodeSpecialCharacters { get; public set; }
    private static XmlNodeConverter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_DeserializeRootElementName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_DeserializeRootElementName(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteArrayAttribute();
    [CompilerGeneratedAttribute]
public void set_WriteArrayAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_OmitRootObject();
    [CompilerGeneratedAttribute]
public void set_OmitRootObject(bool value);
    [CompilerGeneratedAttribute]
public bool get_EncodeSpecialCharacters();
    [CompilerGeneratedAttribute]
public void set_EncodeSpecialCharacters(bool value);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    private IXmlNode WrapXml(object value);
    private void PushParentNamespaces(IXmlNode node, XmlNamespaceManager manager);
    private string ResolveFullName(IXmlNode node, XmlNamespaceManager manager);
    private string GetPropertyName(IXmlNode node, XmlNamespaceManager manager);
    private bool IsArray(IXmlNode node);
    private void SerializeGroupedNodes(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, List`1<IXmlNode> groupedNodes, string elementNames);
    private void WriteGroupedNodes(JsonWriter writer, XmlNamespaceManager manager, bool writePropertyName, IXmlNode node, string elementNames);
    private void SerializeNode(JsonWriter writer, IXmlNode node, XmlNamespaceManager manager, bool writePropertyName);
    private static bool AllSameName(IXmlNode node);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private void DeserializeValue(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, string propertyName, IXmlNode currentNode);
    private void ReadElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, XmlNamespaceManager manager);
    private void CreateElement(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string elementName, XmlNamespaceManager manager, string elementPrefix, Dictionary`2<string, string> attributeNameValues);
    private static void AddAttribute(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName, string attributeName, XmlNamespaceManager manager, string attributePrefix);
    private static string ConvertTokenToXmlValue(JsonReader reader);
    private void ReadArrayElements(JsonReader reader, IXmlDocument document, string propertyName, IXmlNode currentNode, XmlNamespaceManager manager);
    private void AddJsonArrayAttribute(IXmlElement element, IXmlDocument document);
    private bool ShouldReadInto(JsonReader reader);
    private Dictionary`2<string, string> ReadAttributeElements(JsonReader reader, XmlNamespaceManager manager);
    private void CreateInstruction(JsonReader reader, IXmlDocument document, IXmlNode currentNode, string propertyName);
    private void CreateDocumentType(JsonReader reader, IXmlDocument document, IXmlNode currentNode);
    private IXmlElement CreateElement(string elementName, IXmlDocument document, string elementPrefix, XmlNamespaceManager manager);
    private void DeserializeNode(JsonReader reader, IXmlDocument document, XmlNamespaceManager manager, IXmlNode currentNode);
    private bool IsNamespaceAttribute(string attributeName, String& prefix);
    private bool ValueAttributes(List`1<IXmlNode> c);
    public virtual bool CanConvert(Type valueType);
    private bool IsXObject(Type valueType);
    private bool IsXmlNode(Type valueType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Converters.XmlNodeWrapper : object {
    [NullableAttribute("0")]
private XmlNode _node;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _childNodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IXmlNode> _attributes;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("0")]
public List`1<IXmlNode> ChildNodes { get; }
    protected bool HasChildNodes { get; }
    [NullableAttribute("0")]
public List`1<IXmlNode> Attributes { get; }
    private bool HasAttributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    [NullableContextAttribute("0")]
public XmlNodeWrapper(XmlNode node);
    public sealed virtual object get_WrappedNode();
    public sealed virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [NullableContextAttribute("0")]
public sealed virtual List`1<IXmlNode> get_ChildNodes();
    protected virtual bool get_HasChildNodes();
    [NullableContextAttribute("0")]
internal static IXmlNode WrapNode(XmlNode node);
    [NullableContextAttribute("0")]
public sealed virtual List`1<IXmlNode> get_Attributes();
    private bool get_HasAttributes();
    public sealed virtual IXmlNode get_ParentNode();
    public sealed virtual string get_Value();
    public sealed virtual void set_Value(string value);
    [NullableContextAttribute("0")]
public sealed virtual IXmlNode AppendChild(IXmlNode newChild);
    public sealed virtual string get_NamespaceUri();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Converters.XObjectWrapper : object {
    private XObject _xmlObject;
    public object WrappedNode { get; }
    public XmlNodeType NodeType { get; }
    public string LocalName { get; }
    [NullableAttribute("0")]
public List`1<IXmlNode> ChildNodes { get; }
    [NullableAttribute("0")]
public List`1<IXmlNode> Attributes { get; }
    public IXmlNode ParentNode { get; }
    public string Value { get; public set; }
    public string NamespaceUri { get; }
    public XObjectWrapper(XObject xmlObject);
    public sealed virtual object get_WrappedNode();
    public virtual XmlNodeType get_NodeType();
    public virtual string get_LocalName();
    [NullableContextAttribute("0")]
public virtual List`1<IXmlNode> get_ChildNodes();
    [NullableContextAttribute("0")]
public virtual List`1<IXmlNode> get_Attributes();
    public virtual IXmlNode get_ParentNode();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    [NullableContextAttribute("0")]
public virtual IXmlNode AppendChild(IXmlNode newChild);
    public virtual string get_NamespaceUri();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Converters.XProcessingInstructionWrapper : XObjectWrapper {
    [NullableAttribute("0")]
private XProcessingInstruction ProcessingInstruction { get; }
    public string LocalName { get; }
    public string Value { get; public set; }
    [NullableContextAttribute("0")]
public XProcessingInstructionWrapper(XProcessingInstruction processingInstruction);
    [NullableContextAttribute("0")]
private XProcessingInstruction get_ProcessingInstruction();
    public virtual string get_LocalName();
    public virtual string get_Value();
    public virtual void set_Value(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Converters.XTextWrapper : XObjectWrapper {
    [NullableAttribute("0")]
private XText Text { get; }
    public string Value { get; public set; }
    public IXmlNode ParentNode { get; }
    [NullableContextAttribute("0")]
public XTextWrapper(XText text);
    [NullableContextAttribute("0")]
private XText get_Text();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual IXmlNode get_ParentNode();
}
internal enum Microsoft.Identity.Json.DateFormatHandling : Enum {
    public int value__;
    public static DateFormatHandling IsoDateFormat;
    public static DateFormatHandling MicrosoftDateFormat;
}
internal enum Microsoft.Identity.Json.DateParseHandling : Enum {
    public int value__;
    public static DateParseHandling None;
    public static DateParseHandling DateTime;
    public static DateParseHandling DateTimeOffset;
}
internal enum Microsoft.Identity.Json.DateTimeZoneHandling : Enum {
    public int value__;
    public static DateTimeZoneHandling Local;
    public static DateTimeZoneHandling Utc;
    public static DateTimeZoneHandling Unspecified;
    public static DateTimeZoneHandling RoundtripKind;
}
internal class Microsoft.Identity.Json.DefaultJsonNameTable : JsonNameTable {
    private static int HashCodeRandomizer;
    private int _count;
    private Entry[] _entries;
    private int _mask;
    private static DefaultJsonNameTable();
    public virtual string Get(Char[] key, int start, int length);
    public string Add(string key);
    private string AddEntry(string str, int hashCode);
    private void Grow();
    private static bool TextEquals(string str1, Char[] str2, int str2Start, int str2Length);
}
[FlagsAttribute]
internal enum Microsoft.Identity.Json.DefaultValueHandling : Enum {
    public int value__;
    public static DefaultValueHandling Include;
    public static DefaultValueHandling Ignore;
    public static DefaultValueHandling Populate;
    public static DefaultValueHandling IgnoreAndPopulate;
}
internal enum Microsoft.Identity.Json.FloatFormatHandling : Enum {
    public int value__;
    public static FloatFormatHandling String;
    public static FloatFormatHandling Symbol;
    public static FloatFormatHandling DefaultValue;
}
internal enum Microsoft.Identity.Json.FloatParseHandling : Enum {
    public int value__;
    public static FloatParseHandling Double;
    public static FloatParseHandling Decimal;
}
internal enum Microsoft.Identity.Json.Formatting : Enum {
    public int value__;
    public static Formatting None;
    public static Formatting Indented;
}
internal interface Microsoft.Identity.Json.IArrayPool`1 {
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array);
}
internal interface Microsoft.Identity.Json.IJsonLineInfo {
    public int LineNumber { get; }
    public int LinePosition { get; }
    public abstract virtual bool HasLineInfo();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_LinePosition();
}
[AttributeUsageAttribute("1028")]
internal class Microsoft.Identity.Json.JsonArrayAttribute : JsonContainerAttribute {
    private bool _allowNullItems;
    public bool AllowNullItems { get; public set; }
    public JsonArrayAttribute(bool allowNullItems);
    public JsonArrayAttribute(string id);
    public bool get_AllowNullItems();
    public void set_AllowNullItems(bool value);
}
[AttributeUsageAttribute("32")]
internal class Microsoft.Identity.Json.JsonConstructorAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
internal abstract class Microsoft.Identity.Json.JsonContainerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategyInstance>k__BackingField;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    private Type _namingStrategyType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Object[] _namingStrategyParameters;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public Type ItemConverterType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    internal NamingStrategy NamingStrategyInstance { get; internal set; }
    public bool IsReference { get; public set; }
    public bool ItemIsReference { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    [NullableContextAttribute("0")]
protected JsonContainerAttribute(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    public Type get_NamingStrategyType();
    public void set_NamingStrategyType(Type value);
    public Object[] get_NamingStrategyParameters();
    public void set_NamingStrategyParameters(Object[] value);
    [CompilerGeneratedAttribute]
internal NamingStrategy get_NamingStrategyInstance();
    [CompilerGeneratedAttribute]
internal void set_NamingStrategyInstance(NamingStrategy value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
}
internal enum Microsoft.Identity.Json.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
internal static class Microsoft.Identity.Json.JsonConvert : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Func`1<JsonSerializerSettings> <DefaultSettings>k__BackingField;
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Func`1<JsonSerializerSettings> DefaultSettings { get; public set; }
    private static JsonConvert();
    [CompilerGeneratedAttribute]
public static Func`1<JsonSerializerSettings> get_DefaultSettings();
    [CompilerGeneratedAttribute]
public static void set_DefaultSettings(Func`1<JsonSerializerSettings> value);
    public static string ToString(DateTime value);
    public static string ToString(DateTime value, DateFormatHandling format, DateTimeZoneHandling timeZoneHandling);
    public static string ToString(DateTimeOffset value);
    public static string ToString(DateTimeOffset value, DateFormatHandling format);
    public static string ToString(bool value);
    public static string ToString(char value);
    public static string ToString(Enum value);
    public static string ToString(int value);
    public static string ToString(short value);
    [CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    public static string ToString(long value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    public static string ToString(float value);
    internal static string ToString(float value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureFloatFormat(double value, string text, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    public static string ToString(double value);
    internal static string ToString(double value, FloatFormatHandling floatFormatHandling, char quoteChar, bool nullable);
    private static string EnsureDecimalPlace(double value, string text);
    private static string EnsureDecimalPlace(string text);
    public static string ToString(byte value);
    [CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    public static string ToString(decimal value);
    public static string ToString(Guid value);
    internal static string ToString(Guid value, char quoteChar);
    public static string ToString(TimeSpan value);
    internal static string ToString(TimeSpan value, char quoteChar);
    public static string ToString(Uri value);
    internal static string ToString(Uri value, char quoteChar);
    public static string ToString(string value);
    public static string ToString(string value, char delimiter);
    public static string ToString(string value, char delimiter, StringEscapeHandling stringEscapeHandling);
    public static string ToString(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonConverter[] converters);
    [DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonConverter[] converters);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Formatting formatting, JsonSerializerSettings settings);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public static string SerializeObject(object value, Type type, Formatting formatting, JsonSerializerSettings settings);
    private static string SerializeObjectInternal(object value, Type type, JsonSerializer jsonSerializer);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonConverter[] converters);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value, Type type, JsonConverter[] converters);
    [NullableContextAttribute("2")]
public static object DeserializeObject(string value, Type type, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public static void PopulateObject(string value, object target);
    public static void PopulateObject(string value, object target, JsonSerializerSettings settings);
    public static string SerializeXmlNode(XmlNode node);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting);
    public static string SerializeXmlNode(XmlNode node, Formatting formatting, bool omitRootObject);
    public static XmlDocument DeserializeXmlNode(string value);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [NullableContextAttribute("2")]
public static XmlDocument DeserializeXmlNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
    public static string SerializeXNode(XObject node);
    public static string SerializeXNode(XObject node, Formatting formatting);
    public static string SerializeXNode(XObject node, Formatting formatting, bool omitRootObject);
    public static XDocument DeserializeXNode(string value);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute);
    [NullableContextAttribute("2")]
public static XDocument DeserializeXNode(string value, string deserializeRootElementName, bool writeArrayAttribute, bool encodeSpecialCharacters);
}
internal abstract class Microsoft.Identity.Json.JsonConverter : object {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public abstract virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
}
internal abstract class Microsoft.Identity.Json.JsonConverter`1 : JsonConverter {
    public sealed virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual void WriteJson(JsonWriter writer, T value, JsonSerializer serializer);
    public sealed virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public abstract virtual T ReadJson(JsonReader reader, Type objectType, T existingValue, bool hasExistingValue, JsonSerializer serializer);
    public sealed virtual bool CanConvert(Type objectType);
}
[AttributeUsageAttribute("3484")]
internal class Microsoft.Identity.Json.JsonConverterAttribute : Attribute {
    private Type _converterType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ConverterParameters>k__BackingField;
    public Type ConverterType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ConverterParameters { get; }
    public JsonConverterAttribute(Type converterType);
    public JsonConverterAttribute(Type converterType, Object[] converterParameters);
    public Type get_ConverterType();
    [CompilerGeneratedAttribute]
public Object[] get_ConverterParameters();
}
internal class Microsoft.Identity.Json.JsonConverterCollection : Collection`1<JsonConverter> {
}
[AttributeUsageAttribute("1028")]
internal class Microsoft.Identity.Json.JsonDictionaryAttribute : JsonContainerAttribute {
    public JsonDictionaryAttribute(string id);
}
internal class Microsoft.Identity.Json.JsonException : Exception {
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    internal static JsonException Create(IJsonLineInfo lineInfo, string path, string message);
}
[AttributeUsageAttribute("384")]
internal class Microsoft.Identity.Json.JsonExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WriteData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadData>k__BackingField;
    public bool WriteData { get; public set; }
    public bool ReadData { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WriteData();
    [CompilerGeneratedAttribute]
public void set_WriteData(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadData();
    [CompilerGeneratedAttribute]
public void set_ReadData(bool value);
}
[AttributeUsageAttribute("384")]
internal class Microsoft.Identity.Json.JsonIgnoreAttribute : Attribute {
}
internal abstract class Microsoft.Identity.Json.JsonNameTable : object {
    public abstract virtual string Get(Char[] key, int start, int length);
}
[AttributeUsageAttribute("1036")]
internal class Microsoft.Identity.Json.JsonObjectAttribute : JsonContainerAttribute {
    private MemberSerialization _memberSerialization;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<Required> _itemRequired;
    internal Nullable`1<NullValueHandling> _itemNullValueHandling;
    public MemberSerialization MemberSerialization { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling ItemNullValueHandling { get; public set; }
    public Required ItemRequired { get; public set; }
    public JsonObjectAttribute(MemberSerialization memberSerialization);
    public JsonObjectAttribute(string id);
    public MemberSerialization get_MemberSerialization();
    public void set_MemberSerialization(MemberSerialization value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public NullValueHandling get_ItemNullValueHandling();
    public void set_ItemNullValueHandling(NullValueHandling value);
    public Required get_ItemRequired();
    public void set_ItemRequired(Required value);
}
internal class Microsoft.Identity.Json.JsonPosition : ValueType {
    private static Char[] SpecialCharacters;
    internal JsonContainerType Type;
    internal int Position;
    [NullableAttribute("2")]
internal string PropertyName;
    internal bool HasIndex;
    public JsonPosition(JsonContainerType type);
    private static JsonPosition();
    internal int CalculateLength();
    [NullableContextAttribute("2")]
internal void WriteTo(StringBuilder sb, StringWriter& writer, Char[]& buffer);
    internal static bool TypeHasIndex(JsonContainerType type);
    internal static string BuildPath(List`1<JsonPosition> positions, Nullable`1<JsonPosition> currentPosition);
    internal static string FormatMessage(IJsonLineInfo lineInfo, string path, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
internal class Microsoft.Identity.Json.JsonPropertyAttribute : Attribute {
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<bool> _isReference;
    internal Nullable`1<int> _order;
    internal Nullable`1<Required> _required;
    internal Nullable`1<bool> _itemIsReference;
    internal Nullable`1<ReferenceLoopHandling> _itemReferenceLoopHandling;
    internal Nullable`1<TypeNameHandling> _itemTypeNameHandling;
    [CompilerGeneratedAttribute]
private Type <ItemConverterType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <ItemConverterParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NamingStrategyType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <NamingStrategyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public Type ItemConverterType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ItemConverterParameters { get; public set; }
    public Type NamingStrategyType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] NamingStrategyParameters { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public bool IsReference { get; public set; }
    public int Order { get; public set; }
    public Required Required { get; public set; }
    public string PropertyName { get; public set; }
    public ReferenceLoopHandling ItemReferenceLoopHandling { get; public set; }
    public TypeNameHandling ItemTypeNameHandling { get; public set; }
    public bool ItemIsReference { get; public set; }
    [NullableContextAttribute("0")]
public JsonPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public Type get_ItemConverterType();
    [CompilerGeneratedAttribute]
public void set_ItemConverterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_ItemConverterParameters();
    [CompilerGeneratedAttribute]
public void set_ItemConverterParameters(Object[] value);
    [CompilerGeneratedAttribute]
public Type get_NamingStrategyType();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_NamingStrategyParameters();
    [CompilerGeneratedAttribute]
public void set_NamingStrategyParameters(Object[] value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public bool get_IsReference();
    public void set_IsReference(bool value);
    public int get_Order();
    public void set_Order(int value);
    public Required get_Required();
    public void set_Required(Required value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    public ReferenceLoopHandling get_ItemReferenceLoopHandling();
    public void set_ItemReferenceLoopHandling(ReferenceLoopHandling value);
    public TypeNameHandling get_ItemTypeNameHandling();
    public void set_ItemTypeNameHandling(TypeNameHandling value);
    public bool get_ItemIsReference();
    public void set_ItemIsReference(bool value);
}
internal abstract class Microsoft.Identity.Json.JsonReader : object {
    private JsonToken _tokenType;
    [NullableAttribute("2")]
private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonPosition _currentPosition;
    [NullableAttribute("2")]
private CultureInfo _culture;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    internal DateParseHandling _dateParseHandling;
    internal FloatParseHandling _floatParseHandling;
    [NullableAttribute("2")]
private string _dateFormatString;
    [NullableAttribute("2")]
private List`1<JsonPosition> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public char QuoteChar { get; protected internal set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    [NullableAttribute("2")]
public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public JsonToken TokenType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    public int Depth { get; }
    public string Path { get; }
    public CultureInfo Culture { get; public set; }
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonReader/<SkipAsync>d__1")]
public Task SkipAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonReader/<ReaderReadAndAssertAsync>d__2")]
internal Task ReaderReadAndAssertAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonReader/<ReadArrayIntoByteArrayAsync>d__5")]
internal Task`1<Byte[]> ReadArrayIntoByteArrayAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonReader/<ReadAndMoveToContentAsync>d__12")]
internal Task`1<bool> ReadAndMoveToContentAsync(CancellationToken cancellationToken);
    internal Task`1<bool> MoveToContentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonReader/<MoveToContentFromNonContentAsync>d__14")]
private Task`1<bool> MoveToContentFromNonContentAsync(CancellationToken cancellationToken);
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    [NullableContextAttribute("2")]
public string get_DateFormatString();
    [NullableContextAttribute("2")]
public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public virtual JsonToken get_TokenType();
    [NullableContextAttribute("2")]
public virtual object get_Value();
    [NullableContextAttribute("2")]
public virtual Type get_ValueType();
    public virtual int get_Depth();
    public virtual string get_Path();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal JsonPosition GetPosition(int depth);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    [NullableContextAttribute("2")]
internal Nullable`1<int> ReadInt32String(string s);
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    internal Byte[] ReadArrayIntoByteArray();
    private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    [NullableContextAttribute("2")]
internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    [NullableContextAttribute("2")]
internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    [NullableContextAttribute("2")]
internal Nullable`1<decimal> ReadDecimalString(string s);
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    [NullableContextAttribute("2")]
internal Nullable`1<DateTime> ReadDateTimeString(string s);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    [NullableContextAttribute("2")]
internal Nullable`1<DateTimeOffset> ReadDateTimeOffsetString(string s);
    internal void ReaderReadAndAssert();
    internal JsonReaderException CreateUnexpectedEndException();
    internal void ReadIntoWrappedTypeObject();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    [NullableContextAttribute("2")]
protected void SetToken(JsonToken newToken, object value);
    [NullableContextAttribute("2")]
protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void UpdateScopeWithFinishedValue();
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    [NullableContextAttribute("2")]
internal void ReadForTypeAndAssert(JsonContract contract, bool hasConverter);
    [NullableContextAttribute("2")]
internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
internal class Microsoft.Identity.Json.JsonReaderException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [NullableAttribute("2")]
public string Path { get; }
    public JsonReaderException(string message);
    public JsonReaderException(string message, Exception innerException);
    public JsonReaderException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonReaderException Create(JsonReader reader, string message);
    internal static JsonReaderException Create(JsonReader reader, string message, Exception ex);
    internal static JsonReaderException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
[AttributeUsageAttribute("384")]
internal class Microsoft.Identity.Json.JsonRequiredAttribute : Attribute {
}
internal class Microsoft.Identity.Json.JsonSerializationException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    [NullableAttribute("2")]
public string Path { get; }
    public JsonSerializationException(string message);
    public JsonSerializationException(string message, Exception innerException);
    public JsonSerializationException(string message, string path, int lineNumber, int linePosition, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonSerializationException Create(JsonReader reader, string message);
    internal static JsonSerializationException Create(JsonReader reader, string message, Exception ex);
    internal static JsonSerializationException Create(IJsonLineInfo lineInfo, string path, string message, Exception ex);
}
internal class Microsoft.Identity.Json.JsonSerializer : object {
    internal TypeNameHandling _typeNameHandling;
    internal TypeNameAssemblyFormatHandling _typeNameAssemblyFormatHandling;
    internal PreserveReferencesHandling _preserveReferencesHandling;
    internal ReferenceLoopHandling _referenceLoopHandling;
    internal MissingMemberHandling _missingMemberHandling;
    internal ObjectCreationHandling _objectCreationHandling;
    internal NullValueHandling _nullValueHandling;
    internal DefaultValueHandling _defaultValueHandling;
    internal ConstructorHandling _constructorHandling;
    internal MetadataPropertyHandling _metadataPropertyHandling;
    [NullableAttribute("2")]
internal JsonConverterCollection _converters;
    internal IContractResolver _contractResolver;
    [NullableAttribute("2")]
internal ITraceWriter _traceWriter;
    [NullableAttribute("2")]
internal IEqualityComparer _equalityComparer;
    internal ISerializationBinder _serializationBinder;
    internal StreamingContext _context;
    [NullableAttribute("2")]
private IReferenceResolver _referenceResolver;
    private Nullable`1<Formatting> _formatting;
    private Nullable`1<DateFormatHandling> _dateFormatHandling;
    private Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    private Nullable`1<DateParseHandling> _dateParseHandling;
    private Nullable`1<FloatFormatHandling> _floatFormatHandling;
    private Nullable`1<FloatParseHandling> _floatParseHandling;
    private Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _maxDepthSet;
    private Nullable`1<bool> _checkAdditionalContent;
    [NullableAttribute("2")]
private string _dateFormatString;
    private bool _dateFormatStringSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Error;
    [NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    public JsonConverterCollection Converters { get; }
    public IContractResolver ContractResolver { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    [CompilerGeneratedAttribute]
public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    [NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual JsonConverterCollection get_Converters();
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal bool IsCheckAdditionalContentSet();
    public static JsonSerializer Create();
    public static JsonSerializer Create(JsonSerializerSettings settings);
    public static JsonSerializer CreateDefault();
    public static JsonSerializer CreateDefault(JsonSerializerSettings settings);
    private static void ApplySerializerSettings(JsonSerializer serializer, JsonSerializerSettings settings);
    [DebuggerStepThroughAttribute]
public void Populate(TextReader reader, object target);
    [DebuggerStepThroughAttribute]
public void Populate(JsonReader reader, object target);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader);
    [DebuggerStepThroughAttribute]
public object Deserialize(TextReader reader, Type objectType);
    [DebuggerStepThroughAttribute]
public T Deserialize(JsonReader reader);
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public object Deserialize(JsonReader reader, Type objectType);
    [NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    [NullableContextAttribute("2")]
private void SetupReader(JsonReader reader, CultureInfo& previousCulture, Nullable`1& previousDateTimeZoneHandling, Nullable`1& previousDateParseHandling, Nullable`1& previousFloatParseHandling, Nullable`1& previousMaxDepth, String& previousDateFormatString);
    [NullableContextAttribute("2")]
private void ResetReader(JsonReader reader, CultureInfo previousCulture, Nullable`1<DateTimeZoneHandling> previousDateTimeZoneHandling, Nullable`1<DateParseHandling> previousDateParseHandling, Nullable`1<FloatParseHandling> previousFloatParseHandling, Nullable`1<int> previousMaxDepth, string previousDateFormatString);
    public void Serialize(TextWriter textWriter, object value);
    [NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    public void Serialize(TextWriter textWriter, object value, Type objectType);
    public void Serialize(JsonWriter jsonWriter, object value);
    private TraceJsonReader CreateTraceJsonReader(JsonReader reader);
    [NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type objectType);
    internal IReferenceResolver GetReferenceResolver();
    internal JsonConverter GetMatchingConverter(Type type);
    internal static JsonConverter GetMatchingConverter(IList`1<JsonConverter> converters, Type objectType);
    internal void OnError(ErrorEventArgs e);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.JsonSerializerSettings : object {
    internal static ReferenceLoopHandling DefaultReferenceLoopHandling;
    internal static MissingMemberHandling DefaultMissingMemberHandling;
    internal static NullValueHandling DefaultNullValueHandling;
    internal static DefaultValueHandling DefaultDefaultValueHandling;
    internal static ObjectCreationHandling DefaultObjectCreationHandling;
    internal static PreserveReferencesHandling DefaultPreserveReferencesHandling;
    internal static ConstructorHandling DefaultConstructorHandling;
    internal static TypeNameHandling DefaultTypeNameHandling;
    internal static MetadataPropertyHandling DefaultMetadataPropertyHandling;
    internal static StreamingContext DefaultContext;
    internal static Formatting DefaultFormatting;
    internal static DateFormatHandling DefaultDateFormatHandling;
    internal static DateTimeZoneHandling DefaultDateTimeZoneHandling;
    internal static DateParseHandling DefaultDateParseHandling;
    internal static FloatParseHandling DefaultFloatParseHandling;
    internal static FloatFormatHandling DefaultFloatFormatHandling;
    internal static StringEscapeHandling DefaultStringEscapeHandling;
    internal static TypeNameAssemblyFormatHandling DefaultTypeNameAssemblyFormatHandling;
    [NullableAttribute("0")]
internal static CultureInfo DefaultCulture;
    internal static bool DefaultCheckAdditionalContent;
    [NullableAttribute("0")]
internal static string DefaultDateFormatString;
    internal static int DefaultMaxDepth;
    internal Nullable`1<Formatting> _formatting;
    internal Nullable`1<DateFormatHandling> _dateFormatHandling;
    internal Nullable`1<DateTimeZoneHandling> _dateTimeZoneHandling;
    internal Nullable`1<DateParseHandling> _dateParseHandling;
    internal Nullable`1<FloatFormatHandling> _floatFormatHandling;
    internal Nullable`1<FloatParseHandling> _floatParseHandling;
    internal Nullable`1<StringEscapeHandling> _stringEscapeHandling;
    internal CultureInfo _culture;
    internal Nullable`1<bool> _checkAdditionalContent;
    internal Nullable`1<int> _maxDepth;
    internal bool _maxDepthSet;
    internal string _dateFormatString;
    internal bool _dateFormatStringSet;
    internal Nullable`1<TypeNameAssemblyFormatHandling> _typeNameAssemblyFormatHandling;
    internal Nullable`1<DefaultValueHandling> _defaultValueHandling;
    internal Nullable`1<PreserveReferencesHandling> _preserveReferencesHandling;
    internal Nullable`1<NullValueHandling> _nullValueHandling;
    internal Nullable`1<ObjectCreationHandling> _objectCreationHandling;
    internal Nullable`1<MissingMemberHandling> _missingMemberHandling;
    internal Nullable`1<ReferenceLoopHandling> _referenceLoopHandling;
    internal Nullable`1<StreamingContext> _context;
    internal Nullable`1<ConstructorHandling> _constructorHandling;
    internal Nullable`1<TypeNameHandling> _typeNameHandling;
    internal Nullable`1<MetadataPropertyHandling> _metadataPropertyHandling;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer <EqualityComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IReferenceResolver> <ReferenceResolverProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceWriter <TraceWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private ISerializationBinder <SerializationBinder>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> <Error>k__BackingField;
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    [NullableAttribute("0")]
public IList`1<JsonConverter> Converters { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public IEqualityComparer EqualityComparer { get; public set; }
    [ObsoleteAttribute("ReferenceResolver property is obsolete. Use the ReferenceResolverProvider property to set the IReferenceResolver: settings.ReferenceResolverProvider = () => resolver")]
public IReferenceResolver ReferenceResolver { get; public set; }
    public Func`1<IReferenceResolver> ReferenceResolverProvider { get; public set; }
    public ITraceWriter TraceWriter { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EventHandler`1<ErrorEventArgs> Error { get; public set; }
    public StreamingContext Context { get; public set; }
    [NullableAttribute("0")]
public string DateFormatString { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    [NullableAttribute("0")]
public CultureInfo Culture { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    private static JsonSerializerSettings();
    public ReferenceLoopHandling get_ReferenceLoopHandling();
    public void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public MissingMemberHandling get_MissingMemberHandling();
    public void set_MissingMemberHandling(MissingMemberHandling value);
    public ObjectCreationHandling get_ObjectCreationHandling();
    public void set_ObjectCreationHandling(ObjectCreationHandling value);
    public NullValueHandling get_NullValueHandling();
    public void set_NullValueHandling(NullValueHandling value);
    public DefaultValueHandling get_DefaultValueHandling();
    public void set_DefaultValueHandling(DefaultValueHandling value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public void set_Converters(IList`1<JsonConverter> value);
    public PreserveReferencesHandling get_PreserveReferencesHandling();
    public void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public TypeNameHandling get_TypeNameHandling();
    public void set_TypeNameHandling(TypeNameHandling value);
    public MetadataPropertyHandling get_MetadataPropertyHandling();
    public void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public ConstructorHandling get_ConstructorHandling();
    public void set_ConstructorHandling(ConstructorHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ContractResolver();
    [CompilerGeneratedAttribute]
public void set_ContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public IEqualityComparer get_EqualityComparer();
    [CompilerGeneratedAttribute]
public void set_EqualityComparer(IEqualityComparer value);
    public IReferenceResolver get_ReferenceResolver();
    public void set_ReferenceResolver(IReferenceResolver value);
    [CompilerGeneratedAttribute]
public Func`1<IReferenceResolver> get_ReferenceResolverProvider();
    [CompilerGeneratedAttribute]
public void set_ReferenceResolverProvider(Func`1<IReferenceResolver> value);
    [CompilerGeneratedAttribute]
public ITraceWriter get_TraceWriter();
    [CompilerGeneratedAttribute]
public void set_TraceWriter(ITraceWriter value);
    public SerializationBinder get_Binder();
    public void set_Binder(SerializationBinder value);
    [CompilerGeneratedAttribute]
public ISerializationBinder get_SerializationBinder();
    [CompilerGeneratedAttribute]
public void set_SerializationBinder(ISerializationBinder value);
    [CompilerGeneratedAttribute]
public EventHandler`1<ErrorEventArgs> get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(EventHandler`1<ErrorEventArgs> value);
    public StreamingContext get_Context();
    public void set_Context(StreamingContext value);
    [NullableContextAttribute("0")]
public string get_DateFormatString();
    [NullableContextAttribute("0")]
public void set_DateFormatString(string value);
    public Nullable`1<int> get_MaxDepth();
    public void set_MaxDepth(Nullable`1<int> value);
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public DateParseHandling get_DateParseHandling();
    public void set_DateParseHandling(DateParseHandling value);
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    public FloatParseHandling get_FloatParseHandling();
    public void set_FloatParseHandling(FloatParseHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    [NullableContextAttribute("0")]
public CultureInfo get_Culture();
    [NullableContextAttribute("0")]
public void set_Culture(CultureInfo value);
    public bool get_CheckAdditionalContent();
    public void set_CheckAdditionalContent(bool value);
}
internal class Microsoft.Identity.Json.JsonTextReader : JsonReader {
    private bool _safeAsync;
    private static char UnicodeReplacementChar;
    private static int LargeBufferLength;
    private TextReader _reader;
    [NullableAttribute("2")]
private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    [NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonNameTable <PropertyNameTable>k__BackingField;
    [NullableAttribute("2")]
public JsonNameTable PropertyNameTable { get; public set; }
    [NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    public JsonTextReader(TextReader reader);
    public virtual Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    internal Task`1<bool> DoReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsync>d__3")]
private Task`1<bool> DoReadAsync(Task`1<bool> task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParsePostValueAsync>d__4")]
private Task`1<bool> ParsePostValueAsync(bool ignoreComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadFromFinishedAsync>d__5")]
private Task`1<bool> ReadFromFinishedAsync(CancellationToken cancellationToken);
    private Task`1<int> ReadDataAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadDataAsync>d__7")]
private Task`1<int> ReadDataAsync(bool append, int charsRequired, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseValueAsync>d__8")]
private Task`1<bool> ParseValueAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadStringIntoBufferAsync>d__9")]
private Task ReadStringIntoBufferAsync(char quote, CancellationToken cancellationToken);
    private Task ProcessCarriageReturnAsync(bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ProcessCarriageReturnAsync>d__11")]
private Task ProcessCarriageReturnAsync(Task`1<bool> task);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseUnicodeAsync>d__12")]
private Task`1<char> ParseUnicodeAsync(CancellationToken cancellationToken);
    private Task`1<bool> EnsureCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadCharsAsync>d__14")]
private Task`1<bool> ReadCharsAsync(int relativePosition, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseObjectAsync>d__15")]
private Task`1<bool> ParseObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseCommentAsync>d__16")]
private Task ParseCommentAsync(bool setToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<EatWhitespaceAsync>d__17")]
private Task EatWhitespaceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseStringAsync>d__18")]
private Task ParseStringAsync(char quote, ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<MatchValueAsync>d__19")]
private Task`1<bool> MatchValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<MatchValueWithTrailingSeparatorAsync>d__20")]
private Task`1<bool> MatchValueWithTrailingSeparatorAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<MatchAndSetAsync>d__21")]
private Task MatchAndSetAsync(string value, JsonToken newToken, object tokenValue, CancellationToken cancellationToken);
    private Task ParseTrueAsync(CancellationToken cancellationToken);
    private Task ParseFalseAsync(CancellationToken cancellationToken);
    private Task ParseNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseConstructorAsync>d__25")]
private Task ParseConstructorAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseNumberNaNAsync>d__26")]
private Task`1<object> ParseNumberNaNAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseNumberPositiveInfinityAsync>d__27")]
private Task`1<object> ParseNumberPositiveInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseNumberNegativeInfinityAsync>d__28")]
private Task`1<object> ParseNumberNegativeInfinityAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseNumberAsync>d__29")]
private Task ParseNumberAsync(ReadType readType, CancellationToken cancellationToken);
    private Task ParseUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParsePropertyAsync>d__31")]
private Task`1<bool> ParsePropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadNumberIntoBufferAsync>d__32")]
private Task ReadNumberIntoBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ParseUnquotedPropertyAsync>d__33")]
private Task ParseUnquotedPropertyAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadNullCharAsync>d__34")]
private Task`1<bool> ReadNullCharAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<HandleNullAsync>d__35")]
private Task HandleNullAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadFinishedAsync>d__36")]
private Task ReadFinishedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadStringValueAsync>d__37")]
private Task`1<object> ReadStringValueAsync(ReadType readType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadNumberValueAsync>d__38")]
private Task`1<object> ReadNumberValueAsync(ReadType readType, CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<bool>> ReadAsBooleanAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsBooleanAsync>d__40")]
internal Task`1<Nullable`1<bool>> DoReadAsBooleanAsync(CancellationToken cancellationToken);
    public virtual Task`1<Byte[]> ReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsBytesAsync>d__42")]
internal Task`1<Byte[]> DoReadAsBytesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<ReadIntoWrappedTypeObjectAsync>d__43")]
private Task ReadIntoWrappedTypeObjectAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTime>> ReadAsDateTimeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsDateTimeAsync>d__45")]
internal Task`1<Nullable`1<DateTime>> DoReadAsDateTimeAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<DateTimeOffset>> ReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsDateTimeOffsetAsync>d__47")]
internal Task`1<Nullable`1<DateTimeOffset>> DoReadAsDateTimeOffsetAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<decimal>> ReadAsDecimalAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsDecimalAsync>d__49")]
internal Task`1<Nullable`1<decimal>> DoReadAsDecimalAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<double>> ReadAsDoubleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsDoubleAsync>d__51")]
internal Task`1<Nullable`1<double>> DoReadAsDoubleAsync(CancellationToken cancellationToken);
    public virtual Task`1<Nullable`1<int>> ReadAsInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsInt32Async>d__53")]
internal Task`1<Nullable`1<int>> DoReadAsInt32Async(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextReader/<DoReadAsStringAsync>d__55")]
internal Task`1<string> DoReadAsStringAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonNameTable get_PropertyNameTable();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PropertyNameTable(JsonNameTable value);
    [NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    [NullableContextAttribute("2")]
private object ReadStringValue(ReadType readType);
    [NullableContextAttribute("2")]
private object FinishReadQuotedStringValue(ReadType readType);
    private JsonReaderException CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    [NullableContextAttribute("2")]
private object ReadNumberValue(ReadType readType);
    [NullableContextAttribute("2")]
private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private JsonReaderException ThrowReaderError(string message, Exception ex);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
    public sealed virtual bool HasLineInfo();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_LinePosition();
}
internal class Microsoft.Identity.Json.JsonTextWriter : JsonWriter {
    private bool _safeAsync;
    private static int IndentCharBufferSize;
    private TextWriter _writer;
    [NullableAttribute("2")]
private Base64Encoder _base64Encoder;
    private char _indentChar;
    private int _indentation;
    private char _quoteChar;
    private bool _quoteName;
    [NullableAttribute("2")]
private Boolean[] _charEscapeFlags;
    [NullableAttribute("2")]
private Char[] _writeBuffer;
    [NullableAttribute("2")]
private IArrayPool`1<char> _arrayPool;
    [NullableAttribute("2")]
private Char[] _indentChars;
    private Base64Encoder Base64Encoder { get; }
    [NullableAttribute("2")]
public IArrayPool`1<char> ArrayPool { get; public set; }
    public int Indentation { get; public set; }
    public char QuoteChar { get; public set; }
    public char IndentChar { get; public set; }
    public bool QuoteName { get; public set; }
    public JsonTextWriter(TextWriter textWriter);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    internal Task DoFlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    internal Task DoWriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    internal Task DoWriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoCloseAsync>d__8")]
internal Task DoCloseAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<WriteIndentAsync>d__12")]
private Task WriteIndentAsync(int currentIndentCount, int newLineLen, CancellationToken cancellationToken);
    private Task WriteValueInternalAsync(JsonToken token, string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<WriteValueInternalAsync>d__14")]
private Task WriteValueInternalAsync(Task task, string value, CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    internal Task DoWriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    internal Task DoWriteNullAsync(CancellationToken cancellationToken);
    private Task WriteDigitsAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    private Task WriteIntegerValueAsync(ulong uvalue, bool negative, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<WriteIntegerValueAsync>d__23")]
private Task WriteIntegerValueAsync(Task task, ulong uvalue, bool negative, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(long value, CancellationToken cancellationToken);
    internal Task WriteIntegerValueAsync(ulong uvalue, CancellationToken cancellationToken);
    private Task WriteEscapedStringAsync(string value, bool quote, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    internal Task DoWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__29")]
private Task DoWritePropertyNameAsync(Task task, string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWritePropertyNameAsync>d__31")]
internal Task DoWritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteStartArrayAsync>d__34")]
internal Task DoWriteStartArrayAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    internal Task DoWriteStartObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteStartObjectAsync>d__37")]
internal Task DoWriteStartObjectAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteStartConstructorAsync>d__39")]
internal Task DoWriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    internal Task DoWriteUndefinedAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteUndefinedAsync>d__42")]
private Task DoWriteUndefinedAsync(Task task, CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task DoWriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<WriteValueNonNullAsync>d__53")]
internal Task WriteValueNonNullAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteValueAsync>d__59")]
internal Task DoWriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteValueAsync>d__63")]
internal Task DoWriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(double value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    internal Task WriteValueAsync(float value, bool nullable, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteValueAsync>d__77")]
internal Task DoWriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteValueAsync>d__95")]
private Task DoWriteValueAsync(Task task, string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteValueAsync>d__97")]
internal Task DoWriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    internal Task WriteValueNotNullAsync(Uri value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<WriteValueNotNullAsync>d__108")]
internal Task WriteValueNotNullAsync(Task task, Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    internal Task DoWriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteCommentAsync>d__113")]
internal Task DoWriteCommentAsync(string text, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    internal Task DoWriteRawValueAsync(string json, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonTextWriter/<DoWriteRawValueAsync>d__119")]
private Task DoWriteRawValueAsync(Task task, string json, CancellationToken cancellationToken);
    internal Char[] EnsureWriteBuffer(int length, int copyTo);
    private Base64Encoder get_Base64Encoder();
    [NullableContextAttribute("2")]
public IArrayPool`1<char> get_ArrayPool();
    [NullableContextAttribute("2")]
public void set_ArrayPool(IArrayPool`1<char> value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public char get_QuoteChar();
    public void set_QuoteChar(char value);
    public char get_IndentChar();
    public void set_IndentChar(char value);
    public bool get_QuoteName();
    public void set_QuoteName(bool value);
    public virtual void Flush();
    public virtual void Close();
    private void CloseBufferAndWriter();
    public virtual void WriteStartObject();
    public virtual void WriteStartArray();
    public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    internal virtual void OnStringEscapeHandlingChanged();
    private void UpdateCharEscapeFlags();
    protected virtual void WriteIndent();
    private int SetIndentChars();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    private void WriteValueInternal(string value, JsonToken token);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    private void WriteEscapedString(string value, bool quote);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    private int WriteValueToBuffer(DateTime value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    private int WriteValueToBuffer(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private void EnsureWriteBuffer();
    private void WriteIntegerValue(long value);
    private void WriteIntegerValue(ulong value, bool negative);
    private int WriteNumberToBuffer(ulong value, bool negative);
    private void WriteIntegerValue(int value);
    private void WriteIntegerValue(UInt32 value, bool negative);
    private int WriteNumberToBuffer(UInt32 value, bool negative);
}
internal enum Microsoft.Identity.Json.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.JsonValidatingReader : JsonReader {
    private JsonReader _reader;
    private Stack`1<SchemaScope> _stack;
    private JsonSchema _schema;
    private JsonSchemaModel _model;
    private SchemaScope _currentScope;
    [CompilerGeneratedAttribute]
private ValidationEventHandler ValidationEventHandler;
    private static IList`1<JsonSchemaModel> EmptySchemaList;
    public object Value { get; }
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    public Type ValueType { get; }
    private IList`1<JsonSchemaModel> CurrentSchemas { get; }
    private IList`1<JsonSchemaModel> CurrentMemberSchemas { get; }
    public JsonSchema Schema { get; public set; }
    public JsonReader Reader { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LineNumber { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LinePosition { get; }
    public JsonValidatingReader(JsonReader reader);
    private static JsonValidatingReader();
    [CompilerGeneratedAttribute]
public void add_ValidationEventHandler(ValidationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ValidationEventHandler(ValidationEventHandler value);
    public virtual object get_Value();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    public virtual Type get_ValueType();
    private void Push(SchemaScope scope);
    private SchemaScope Pop();
    private IList`1<JsonSchemaModel> get_CurrentSchemas();
    private IList`1<JsonSchemaModel> get_CurrentMemberSchemas();
    private void RaiseError(string message, JsonSchemaModel schema);
    private void OnValidationEvent(JsonSchemaException exception);
    public JsonSchema get_Schema();
    public void set_Schema(JsonSchema value);
    public JsonReader get_Reader();
    public virtual void Close();
    private void ValidateNotDisallowed(JsonSchemaModel schema);
    private Nullable`1<JsonSchemaType> GetCurrentNodeSchemaType();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual string ReadAsString();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public virtual bool Read();
    private void ValidateCurrentToken();
    private void WriteToken(IList`1<JsonSchemaModel> schemas);
    private void ValidateEndObject(JsonSchemaModel schema);
    private void ValidateEndArray(JsonSchemaModel schema);
    private void ValidateNull(JsonSchemaModel schema);
    private void ValidateBoolean(JsonSchemaModel schema);
    private void ValidateString(JsonSchemaModel schema);
    private void ValidateInteger(JsonSchemaModel schema);
    private void ProcessValue();
    private void ValidateFloat(JsonSchemaModel schema);
    private static double FloatingPointRemainder(double dividend, double divisor);
    private static bool IsZero(double value);
    private void ValidatePropertyName(JsonSchemaModel schema);
    private bool IsPropertyDefinied(JsonSchemaModel schema, string propertyName);
    private bool ValidateArray(JsonSchemaModel schema);
    private bool ValidateObject(JsonSchemaModel schema);
    private bool TestType(JsonSchemaModel currentSchema, JsonSchemaType currentType);
    private sealed virtual override bool Microsoft.Identity.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LinePosition();
}
internal abstract class Microsoft.Identity.Json.JsonWriter : object {
    private static State[][] StateArray;
    internal static State[][] StateArrayTemplate;
    [NullableAttribute("2")]
private List`1<JsonPosition> _stack;
    private JsonPosition _currentPosition;
    private State _currentState;
    private Formatting _formatting;
    [CompilerGeneratedAttribute]
private bool <CloseOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoCompleteOnClose>k__BackingField;
    private DateFormatHandling _dateFormatHandling;
    private DateTimeZoneHandling _dateTimeZoneHandling;
    private StringEscapeHandling _stringEscapeHandling;
    private FloatFormatHandling _floatFormatHandling;
    [NullableAttribute("2")]
private string _dateFormatString;
    [NullableAttribute("2")]
private CultureInfo _culture;
    public bool CloseOutput { get; public set; }
    public bool AutoCompleteOnClose { get; public set; }
    protected internal int Top { get; }
    public WriteState WriteState { get; }
    internal string ContainerPath { get; }
    public string Path { get; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    [NullableAttribute("2")]
public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    private static JsonWriter();
    internal Task AutoCompleteAsync(JsonToken tokenBeingWritten, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<AutoCompleteAsync>d__1")]
private Task AutoCompleteAsync(CancellationToken cancellationToken);
    public virtual Task CloseAsync(CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteEndAsync(JsonToken token, CancellationToken cancellationToken);
    protected virtual Task WriteIndentAsync(CancellationToken cancellationToken);
    protected virtual Task WriteValueDelimiterAsync(CancellationToken cancellationToken);
    protected virtual Task WriteIndentSpaceAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteEndAsync(CancellationToken cancellationToken);
    internal Task WriteEndInternalAsync(CancellationToken cancellationToken);
    internal Task InternalWriteEndAsync(JsonContainerType type, CancellationToken cancellationToken);
    public virtual Task WriteEndArrayAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndConstructorAsync(CancellationToken cancellationToken);
    public virtual Task WriteEndObjectAsync(CancellationToken cancellationToken);
    public virtual Task WriteNullAsync(CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WritePropertyNameAsync(string name, bool escape, CancellationToken cancellationToken);
    internal Task InternalWritePropertyNameAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartArrayAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<InternalWriteStartAsync>d__20")]
internal Task InternalWriteStartAsync(JsonToken token, JsonContainerType container, CancellationToken cancellationToken);
    public virtual Task WriteCommentAsync(string text, CancellationToken cancellationToken);
    internal Task InternalWriteCommentAsync(CancellationToken cancellationToken);
    public virtual Task WriteRawValueAsync(string json, CancellationToken cancellationToken);
    public virtual Task WriteStartConstructorAsync(string name, CancellationToken cancellationToken);
    public virtual Task WriteStartObjectAsync(CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonReader reader, bool writeChildren, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, CancellationToken cancellationToken);
    public Task WriteTokenAsync(JsonToken token, object value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<WriteTokenAsync>d__30")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<WriteTokenSyncReadingAsync>d__31")]
internal Task WriteTokenSyncReadingAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<WriteConstructorDateAsync>d__32")]
private Task WriteConstructorDateAsync(JsonReader reader, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(bool value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(byte value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Byte[] value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(char value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<char> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTime value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTime> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(DateTimeOffset value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<DateTimeOffset> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(decimal value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<decimal> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(double value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(float value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Guid value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<Guid> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(int value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(long value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(object value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(short value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(string value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(TimeSpan value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Nullable`1<TimeSpan> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public virtual Task WriteValueAsync(Uri value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual Task WriteValueAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public virtual Task WriteUndefinedAsync(CancellationToken cancellationToken);
    public virtual Task WriteWhitespaceAsync(string ws, CancellationToken cancellationToken);
    internal Task InternalWriteValueAsync(JsonToken token, CancellationToken cancellationToken);
    protected Task SetWriteStateAsync(JsonToken token, object value, CancellationToken cancellationToken);
    internal static Task WriteValueAsync(JsonWriter writer, PrimitiveTypeCode typeCode, object value, CancellationToken cancellationToken);
    internal static State[][] BuildStateArray();
    [CompilerGeneratedAttribute]
public bool get_CloseOutput();
    [CompilerGeneratedAttribute]
public void set_CloseOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_AutoCompleteOnClose();
    [CompilerGeneratedAttribute]
public void set_AutoCompleteOnClose(bool value);
    protected internal int get_Top();
    public WriteState get_WriteState();
    internal string get_ContainerPath();
    public string get_Path();
    public Formatting get_Formatting();
    public void set_Formatting(Formatting value);
    public DateFormatHandling get_DateFormatHandling();
    public void set_DateFormatHandling(DateFormatHandling value);
    public DateTimeZoneHandling get_DateTimeZoneHandling();
    public void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public StringEscapeHandling get_StringEscapeHandling();
    public void set_StringEscapeHandling(StringEscapeHandling value);
    internal virtual void OnStringEscapeHandlingChanged();
    public FloatFormatHandling get_FloatFormatHandling();
    public void set_FloatFormatHandling(FloatFormatHandling value);
    [NullableContextAttribute("2")]
public string get_DateFormatString();
    [NullableContextAttribute("2")]
public void set_DateFormatString(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    internal void UpdateScopeWithFinishedValue();
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteEnd();
    public void WriteToken(JsonReader reader);
    public void WriteToken(JsonReader reader, bool writeChildren);
    [NullableContextAttribute("2")]
public void WriteToken(JsonToken token, object value);
    public void WriteToken(JsonToken token);
    internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
    private bool IsWriteTokenIncomplete(JsonReader reader, bool writeChildren, int initialDepth);
    private int CalculateWriteTokenInitialDepth(JsonReader reader);
    private int CalculateWriteTokenFinalDepth(JsonReader reader);
    private void WriteConstructorDate(JsonReader reader);
    private void WriteEnd(JsonContainerType type);
    private void AutoCompleteAll();
    private JsonToken GetCloseTokenForType(JsonContainerType type);
    private void AutoCompleteClose(JsonContainerType type);
    private int CalculateLevelsToComplete(JsonContainerType type);
    private void UpdateCurrentState();
    protected virtual void WriteEnd(JsonToken token);
    protected virtual void WriteIndent();
    protected virtual void WriteValueDelimiter();
    protected virtual void WriteIndentSpace();
    internal void AutoComplete(JsonToken tokenBeingWritten);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    [NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ulong> value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteValue(Nullable`1<char> value);
    public virtual void WriteValue(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteWhitespace(string ws);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    internal static void WriteValue(JsonWriter writer, PrimitiveTypeCode typeCode, object value);
    private static void ResolveConvertibleValue(IConvertible convertible, PrimitiveTypeCode& typeCode, Object& value);
    private static JsonWriterException CreateUnsupportedTypeException(JsonWriter writer, object value);
    protected void SetWriteState(JsonToken token, object value);
    internal void InternalWriteEnd(JsonContainerType container);
    internal void InternalWritePropertyName(string name);
    internal void InternalWriteRaw();
    internal void InternalWriteStart(JsonToken token, JsonContainerType container);
    internal void InternalWriteValue(JsonToken token);
    internal void InternalWriteWhitespace(string ws);
    internal void InternalWriteComment();
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitProperty|11_0>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitProperty|11_0(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitIndent|11_1>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitIndent|11_1(Task task, int LevelsToComplete, JsonToken token, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitEnd|11_2>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitEnd|11_2(Task task, int LevelsToComplete, CancellationToken CancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.JsonWriter/<<InternalWriteEndAsync>g__AwaitRemaining|11_3>d")]
[CompilerGeneratedAttribute]
private Task <InternalWriteEndAsync>g__AwaitRemaining|11_3(int LevelsToComplete, CancellationToken CancellationToken);
}
internal class Microsoft.Identity.Json.JsonWriterException : JsonException {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("2")]
public string Path { get; }
    public JsonWriterException(string message);
    public JsonWriterException(string message, Exception innerException);
    public JsonWriterException(string message, string path, Exception innerException);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Path();
    internal static JsonWriterException Create(JsonWriter writer, string message, Exception ex);
    internal static JsonWriterException Create(string path, string message, Exception ex);
}
internal enum Microsoft.Identity.Json.Linq.CommentHandling : Enum {
    public int value__;
    public static CommentHandling Ignore;
    public static CommentHandling Load;
}
internal enum Microsoft.Identity.Json.Linq.DuplicatePropertyNameHandling : Enum {
    public int value__;
    public static DuplicatePropertyNameHandling Replace;
    public static DuplicatePropertyNameHandling Ignore;
    public static DuplicatePropertyNameHandling Error;
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Linq.Extensions : object {
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Ancestors(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AncestorsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Descendants(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> DescendantsAndSelf(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JProperty> Properties(IEnumerable`1<JObject> source);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source, object key);
    [ExtensionAttribute]
public static IEnumerable`1<U> Values(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<JToken> value);
    [ExtensionAttribute]
public static U Value(IEnumerable`1<T> value);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.Extensions/<Values>d__11`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Values(IEnumerable`1<T> source, object key);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> Children(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<U> Children(IEnumerable`1<T> source);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.Extensions/<Convert>d__14`2")]
[ExtensionAttribute]
internal static IEnumerable`1<U> Convert(IEnumerable`1<T> source);
    [ExtensionAttribute]
internal static U Convert(T token);
    [ExtensionAttribute]
public static IJEnumerable`1<JToken> AsJEnumerable(IEnumerable`1<JToken> source);
    [ExtensionAttribute]
public static IJEnumerable`1<T> AsJEnumerable(IEnumerable`1<T> source);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Identity.Json.Linq.IJEnumerable`1 {
    public IJEnumerable`1<JToken> Item { get; }
    public abstract virtual IJEnumerable`1<JToken> get_Item(object key);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Linq.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(JArray other);
    public JArray(Object[] content);
    public JArray(object content);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JArray/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JArray> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JArray/<LoadAsync>d__2")]
public static Task`1<JArray> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public static JArray Load(JsonReader reader);
    public static JArray Load(JsonReader reader, JsonLoadSettings settings);
    public static JArray Parse(string json);
    public static JArray Parse(string json, JsonLoadSettings settings);
    public static JArray FromObject(object o);
    public static JArray FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    public sealed virtual int IndexOf(JToken item);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
    internal virtual int GetDeepHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Linq.JConstructor : JContainer {
    [NullableAttribute("2")]
private string _name;
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    public JConstructor(JConstructor other);
    public JConstructor(string name, Object[] content);
    public JConstructor(string name, object content);
    public JConstructor(string name);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JConstructor/<WriteToAsync>d__0")]
public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JConstructor> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JConstructor/<LoadAsync>d__2")]
public static Task`1<JConstructor> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    [NullableContextAttribute("2")]
public string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    public virtual JTokenType get_Type();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    internal virtual int GetDeepHashCode();
    public static JConstructor Load(JsonReader reader);
    public static JConstructor Load(JsonReader reader, JsonLoadSettings settings);
}
internal abstract class Microsoft.Identity.Json.Linq.JContainer : JToken {
    [NullableAttribute("2")]
internal NotifyCollectionChangedEventHandler _collectionChanged;
    [NullableAttribute("2")]
private object _syncRoot;
    private bool _busy;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    [NullableAttribute("2")]
public JToken First { get; }
    [NullableAttribute("2")]
public JToken Last { get; }
    private JToken System.Collections.Generic.IList<Microsoft.Identity.Json.Linq.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal JContainer(JContainer other);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JContainer/<ReadTokenFromAsync>d__0")]
internal Task ReadTokenFromAsync(JsonReader reader, JsonLoadSettings options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JContainer/<ReadContentFromAsync>d__1")]
private Task ReadContentFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    internal void CheckReentrancy();
    internal virtual IList`1<JToken> CreateChildrenCollection();
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    public virtual bool get_HasValues();
    internal bool ContentsEqual(JContainer container);
    [NullableContextAttribute("2")]
public virtual JToken get_First();
    [NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public virtual IEnumerable`1<T> Values();
    public IEnumerable`1<JToken> Descendants();
    public IEnumerable`1<JToken> DescendantsAndSelf();
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JContainer/<GetDescendants>d__26")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    [NullableContextAttribute("2")]
internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    [NullableContextAttribute("2")]
internal abstract virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    [NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    [NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual void ReplaceItem(JToken existing, JToken replacement);
    [NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    internal virtual void ValidateToken(JToken o, JToken existing);
    [NullableContextAttribute("2")]
public virtual void Add(object content);
    [NullableContextAttribute("2")]
internal bool TryAdd(object content);
    internal void AddAndSkipParentCheck(JToken token);
    [NullableContextAttribute("2")]
public void AddFirst(object content);
    [NullableContextAttribute("2")]
internal bool TryAddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    public JsonWriter CreateWriter();
    public void ReplaceAll(object content);
    public void RemoveAll();
    internal abstract virtual void MergeItem(object content, JsonMergeSettings settings);
    public void Merge(object content);
    public void Merge(object content, JsonMergeSettings settings);
    internal void ReadTokenFrom(JsonReader reader, JsonLoadSettings options);
    internal void ReadContentFrom(JsonReader r, JsonLoadSettings settings);
    [NullableContextAttribute("2")]
private static JProperty ReadProperty(JsonReader r, JsonLoadSettings settings, IJsonLineInfo lineInfo, JContainer parent);
    internal int ContentsHashCode();
    private sealed virtual override int System.Collections.Generic.IList<Microsoft.Identity.Json.Linq.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.Identity.Json.Linq.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.Identity.Json.Linq.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<Microsoft.Identity.Json.Linq.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<Microsoft.Identity.Json.Linq.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<Microsoft.Identity.Json.Linq.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal static void MergeEnumerableContent(JContainer target, IEnumerable content, JsonMergeSettings settings);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Linq.JEnumerable`1 : ValueType {
    public static JEnumerable`1<T> Empty;
    private IEnumerable`1<T> _enumerable;
    public IJEnumerable`1<JToken> Item { get; }
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IJEnumerable`1<JToken> get_Item(object key);
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Linq.JObject : JContainer {
    private JPropertyKeyedCollection _properties;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PropertyChangingEventHandler PropertyChanging;
    protected IList`1<JToken> ChildrenTokens { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Microsoft.Identity.Json.Linq.JToken>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Microsoft.Identity.Json.Linq.JToken>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.IsReadOnly { get; }
    public JObject(JObject other);
    public JObject(Object[] content);
    public JObject(object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JObject> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JObject/<LoadAsync>d__2")]
public static Task`1<JObject> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanging(PropertyChangingEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanging(PropertyChangingEventHandler value);
    internal virtual bool DeepEquals(JToken node);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void ValidateToken(JToken o, JToken existing);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    private static bool IsNull(JToken token);
    internal void InternalPropertyChanged(JProperty childProperty);
    internal void InternalPropertyChanging(JProperty childProperty);
    internal virtual JToken CloneToken();
    public virtual JTokenType get_Type();
    public IEnumerable`1<JProperty> Properties();
    public JProperty Property(string name);
    public JProperty Property(string name, StringComparison comparison);
    public JEnumerable`1<JToken> PropertyValues();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JToken value);
    public static JObject Load(JsonReader reader);
    public static JObject Load(JsonReader reader, JsonLoadSettings settings);
    public static JObject Parse(string json);
    public static JObject Parse(string json, JsonLoadSettings settings);
    public static JObject FromObject(object o);
    public static JObject FromObject(object o, JsonSerializer jsonSerializer);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    [NullableContextAttribute("2")]
public JToken GetValue(string propertyName);
    [NullableContextAttribute("2")]
public JToken GetValue(string propertyName, StringComparison comparison);
    public bool TryGetValue(string propertyName, StringComparison comparison, JToken& value);
    public sealed virtual void Add(string propertyName, JToken value);
    public sealed virtual bool ContainsKey(string propertyName);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,Microsoft.Identity.Json.Linq.JToken>.get_Keys();
    public sealed virtual bool Remove(string propertyName);
    public sealed virtual bool TryGetValue(string propertyName, JToken& value);
    private sealed virtual override ICollection`1<JToken> System.Collections.Generic.IDictionary<System.String,Microsoft.Identity.Json.Linq.JToken>.get_Values();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.Add(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.Contains(KeyValuePair`2<string, JToken> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,Microsoft.Identity.Json.Linq.JToken>>.Remove(KeyValuePair`2<string, JToken> item);
    internal virtual int GetDeepHashCode();
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JObject/<GetEnumerator>d__63")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, JToken>> GetEnumerator();
    protected virtual void OnPropertyChanged(string propertyName);
    protected virtual void OnPropertyChanging(string propertyName);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JObject/<<WriteToAsync>g__AwaitProperties|0_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteToAsync>g__AwaitProperties|0_0(Task task, int i, JsonWriter Writer, CancellationToken CancellationToken, JsonConverter[] Converters);
}
internal class Microsoft.Identity.Json.Linq.JProperty : JContainer {
    private JPropertyList _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    public JTokenType Type { get; }
    public JProperty(JProperty other);
    internal JProperty(string name);
    public JProperty(string name, Object[] content);
    public JProperty(string name, object content);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JProperty/<WriteToAsync>d__1")]
private Task WriteToAsync(Task task, JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    private Task WriteValueAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public static Task`1<JProperty> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JProperty/<LoadAsync>d__4")]
public static Task`1<JProperty> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    [NullableContextAttribute("2")]
internal virtual void SetItem(int index, JToken item);
    [NullableContextAttribute("2")]
internal virtual bool RemoveItem(JToken item);
    internal virtual void RemoveItemAt(int index);
    [NullableContextAttribute("2")]
internal virtual int IndexOfItem(JToken item);
    [NullableContextAttribute("2")]
internal virtual bool InsertItem(int index, JToken item, bool skipParentCheck);
    [NullableContextAttribute("2")]
internal virtual bool ContainsItem(JToken item);
    internal virtual void MergeItem(object content, JsonMergeSettings settings);
    internal virtual void ClearItems();
    internal virtual bool DeepEquals(JToken node);
    internal virtual JToken CloneToken();
    [DebuggerStepThroughAttribute]
public virtual JTokenType get_Type();
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    public static JProperty Load(JsonReader reader);
    public static JProperty Load(JsonReader reader, JsonLoadSettings settings);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Linq.JPropertyKeyedCollection : Collection`1<JToken> {
    private static IEqualityComparer`1<string> Comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, JToken> _dictionary;
    public JToken Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<JToken> Values { get; }
    private static JPropertyKeyedCollection();
    private void AddKey(string key, JToken item);
    protected void ChangeItemKey(JToken item, string newKey);
    protected virtual void ClearItems();
    public bool Contains(string key);
    private bool ContainsItem(JToken item);
    private void EnsureDictionary();
    private string GetKeyForItem(JToken item);
    protected virtual void InsertItem(int index, JToken item);
    public bool Remove(string key);
    protected virtual void RemoveItem(int index);
    private void RemoveKey(string key);
    protected virtual void SetItem(int index, JToken item);
    public JToken get_Item(string key);
    public bool TryGetValue(string key, JToken& value);
    public ICollection`1<string> get_Keys();
    public ICollection`1<JToken> get_Values();
    public int IndexOfReference(JToken t);
    public bool Compare(JPropertyKeyedCollection other);
}
internal class Microsoft.Identity.Json.Linq.JRaw : JValue {
    public JRaw(JRaw other);
    [NullableContextAttribute("2")]
public JRaw(object rawJson);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JRaw/<CreateAsync>d__0")]
public static Task`1<JRaw> CreateAsync(JsonReader reader, CancellationToken cancellationToken);
    public static JRaw Create(JsonReader reader);
    internal virtual JToken CloneToken();
}
internal class Microsoft.Identity.Json.Linq.JsonLoadSettings : object {
    private CommentHandling _commentHandling;
    private LineInfoHandling _lineInfoHandling;
    private DuplicatePropertyNameHandling _duplicatePropertyNameHandling;
    public CommentHandling CommentHandling { get; public set; }
    public LineInfoHandling LineInfoHandling { get; public set; }
    public DuplicatePropertyNameHandling DuplicatePropertyNameHandling { get; public set; }
    public CommentHandling get_CommentHandling();
    public void set_CommentHandling(CommentHandling value);
    public LineInfoHandling get_LineInfoHandling();
    public void set_LineInfoHandling(LineInfoHandling value);
    public DuplicatePropertyNameHandling get_DuplicatePropertyNameHandling();
    public void set_DuplicatePropertyNameHandling(DuplicatePropertyNameHandling value);
}
internal class Microsoft.Identity.Json.Linq.JsonMergeSettings : object {
    private MergeArrayHandling _mergeArrayHandling;
    private MergeNullValueHandling _mergeNullValueHandling;
    private StringComparison _propertyNameComparison;
    public MergeArrayHandling MergeArrayHandling { get; public set; }
    public MergeNullValueHandling MergeNullValueHandling { get; public set; }
    public StringComparison PropertyNameComparison { get; public set; }
    public MergeArrayHandling get_MergeArrayHandling();
    public void set_MergeArrayHandling(MergeArrayHandling value);
    public MergeNullValueHandling get_MergeNullValueHandling();
    public void set_MergeNullValueHandling(MergeNullValueHandling value);
    public StringComparison get_PropertyNameComparison();
    public void set_PropertyNameComparison(StringComparison value);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.ArrayIndexFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Index>k__BackingField;
    public Nullable`1<int> Index { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(Nullable`1<int> value);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.ArrayIndexFilter/<ExecuteFilter>d__4")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.ArrayMultipleIndexFilter : PathFilter {
    internal List`1<int> Indexes;
    public ArrayMultipleIndexFilter(List`1<int> indexes);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.ArrayMultipleIndexFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.ArraySliceFilter : PathFilter {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Step>k__BackingField;
    public Nullable`1<int> Start { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public Nullable`1<int> Step { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(Nullable`1<int> value);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.ArraySliceFilter/<ExecuteFilter>d__12")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    private bool IsValid(int index, int stopIndex, bool positiveStep);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.BooleanQueryExpression : QueryExpression {
    public object Left;
    [NullableAttribute("2")]
public object Right;
    public BooleanQueryExpression(QueryOperator operator, object left, object right);
    private IEnumerable`1<JToken> GetResult(JToken root, JToken t, object o);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
    private bool MatchTokens(JToken leftResult, JToken rightResult, JsonSelectSettings settings);
    private static bool RegexEquals(JValue input, JValue pattern, JsonSelectSettings settings);
    internal static bool EqualsWithStringCoercion(JValue value, JValue queryValue);
    internal static bool EqualsWithStrictMatch(JValue value, JValue queryValue);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.CompositeExpression : QueryExpression {
    [CompilerGeneratedAttribute]
private List`1<QueryExpression> <Expressions>k__BackingField;
    public List`1<QueryExpression> Expressions { get; public set; }
    public CompositeExpression(QueryOperator operator);
    [CompilerGeneratedAttribute]
public List`1<QueryExpression> get_Expressions();
    [CompilerGeneratedAttribute]
public void set_Expressions(List`1<QueryExpression> value);
    public virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.FieldFilter : PathFilter {
    [NullableAttribute("2")]
internal string Name;
    [NullableContextAttribute("2")]
public FieldFilter(string name);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.FieldFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.FieldMultipleFilter : PathFilter {
    internal List`1<string> Names;
    public FieldMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.FieldMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.JPath : object {
    private static Char[] FloatCharacters;
    private string _expression;
    [CompilerGeneratedAttribute]
private List`1<PathFilter> <Filters>k__BackingField;
    private int _currentIndex;
    public List`1<PathFilter> Filters { get; }
    public JPath(string expression);
    private static JPath();
    [CompilerGeneratedAttribute]
public List`1<PathFilter> get_Filters();
    private void ParseMain();
    private bool ParsePath(List`1<PathFilter> filters, int currentPartStartIndex, bool query);
    private static PathFilter CreatePathFilter(string member, bool scan);
    private PathFilter ParseIndexer(char indexerOpenChar, bool scan);
    private PathFilter ParseArrayIndexer(char indexerCloseChar);
    private void EatWhitespace();
    private PathFilter ParseQuery(char indexerCloseChar, bool scan);
    private bool TryParseExpression(List`1& expressionPath);
    private JsonException CreateUnexpectedCharacterException();
    private object ParseSide();
    private QueryExpression ParseExpression();
    [NullableContextAttribute("2")]
private bool TryParseValue(Object& value);
    private string ReadQuotedString();
    private string ReadRegexString();
    private bool Match(string s);
    private QueryOperator ParseOperator();
    private PathFilter ParseQuotedField(char indexerCloseChar, bool scan);
    private void EnsureLength(string message);
    internal IEnumerable`1<JToken> Evaluate(JToken root, JToken t, JsonSelectSettings settings);
    internal static IEnumerable`1<JToken> Evaluate(List`1<PathFilter> filters, JToken root, JToken t, JsonSelectSettings settings);
}
internal abstract class Microsoft.Identity.Json.Linq.JsonPath.PathFilter : object {
    public abstract virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
    [NullableContextAttribute("2")]
protected static JToken GetTokenIndex(JToken t, JsonSelectSettings settings, int index);
    [NullableContextAttribute("2")]
protected static JToken GetNextScanValue(JToken originalParent, JToken container, JToken value);
}
internal abstract class Microsoft.Identity.Json.Linq.JsonPath.QueryExpression : object {
    internal QueryOperator Operator;
    public QueryExpression(QueryOperator operator);
    public bool IsMatch(JToken root, JToken t);
    public abstract virtual bool IsMatch(JToken root, JToken t, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.QueryFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.QueryFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal enum Microsoft.Identity.Json.Linq.JsonPath.QueryOperator : Enum {
    public int value__;
    public static QueryOperator None;
    public static QueryOperator Equals;
    public static QueryOperator NotEquals;
    public static QueryOperator Exists;
    public static QueryOperator LessThan;
    public static QueryOperator LessThanOrEquals;
    public static QueryOperator GreaterThan;
    public static QueryOperator GreaterThanOrEquals;
    public static QueryOperator And;
    public static QueryOperator Or;
    public static QueryOperator RegexEquals;
    public static QueryOperator StrictEquals;
    public static QueryOperator StrictNotEquals;
}
internal class Microsoft.Identity.Json.Linq.JsonPath.QueryScanFilter : PathFilter {
    internal QueryExpression Expression;
    public QueryScanFilter(QueryExpression expression);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.QueryScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.RootFilter : PathFilter {
    public static RootFilter Instance;
    private static RootFilter();
    public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.ScanFilter : PathFilter {
    [NullableAttribute("2")]
internal string Name;
    [NullableContextAttribute("2")]
public ScanFilter(string name);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.ScanFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonPath.ScanMultipleFilter : PathFilter {
    private List`1<string> _names;
    public ScanMultipleFilter(List`1<string> names);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JsonPath.ScanMultipleFilter/<ExecuteFilter>d__2")]
public virtual IEnumerable`1<JToken> ExecuteFilter(JToken root, IEnumerable`1<JToken> current, JsonSelectSettings settings);
}
internal class Microsoft.Identity.Json.Linq.JsonSelectSettings : object {
    [CompilerGeneratedAttribute]
private bool <ErrorWhenNoMatch>k__BackingField;
    public bool ErrorWhenNoMatch { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ErrorWhenNoMatch();
    [CompilerGeneratedAttribute]
public void set_ErrorWhenNoMatch(bool value);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.Identity.Json.Linq.JToken : object {
    [NullableAttribute("2")]
private static JTokenEqualityComparer _equalityComparer;
    [NullableAttribute("2")]
private JContainer _parent;
    [NullableAttribute("2")]
private JToken _previous;
    [NullableAttribute("2")]
private JToken _next;
    [NullableAttribute("2")]
private object _annotations;
    private static JTokenType[] BooleanTypes;
    private static JTokenType[] NumberTypes;
    private static JTokenType[] StringTypes;
    private static JTokenType[] GuidTypes;
    private static JTokenType[] TimeSpanTypes;
    private static JTokenType[] UriTypes;
    private static JTokenType[] CharTypes;
    private static JTokenType[] DateTimeTypes;
    private static JTokenType[] BytesTypes;
    public static JTokenEqualityComparer EqualityComparer { get; }
    [NullableAttribute("2")]
public JContainer Parent { get; internal set; }
    public JToken Root { get; }
    public JTokenType Type { get; }
    public bool HasValues { get; }
    [NullableAttribute("2")]
public JToken Next { get; internal set; }
    [NullableAttribute("2")]
public JToken Previous { get; internal set; }
    public string Path { get; }
    [NullableAttribute("2")]
public JToken Item { get; public set; }
    [NullableAttribute("2")]
public JToken First { get; }
    [NullableAttribute("2")]
public JToken Last { get; }
    private IJEnumerable`1<JToken> Microsoft.Identity.Json.Linq.IJEnumerable<Microsoft.Identity.Json.Linq.JToken>.Item { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LineNumber { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LinePosition { get; }
    private static JToken();
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    public Task WriteToAsync(JsonWriter writer, JsonConverter[] converters);
    public static Task`1<JToken> ReadFromAsync(JsonReader reader, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Linq.JToken/<ReadFromAsync>d__3")]
public static Task`1<JToken> ReadFromAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, CancellationToken cancellationToken);
    public static Task`1<JToken> LoadAsync(JsonReader reader, JsonLoadSettings settings, CancellationToken cancellationToken);
    public static JTokenEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
[DebuggerStepThroughAttribute]
public JContainer get_Parent();
    [NullableContextAttribute("2")]
internal void set_Parent(JContainer value);
    public JToken get_Root();
    internal abstract virtual JToken CloneToken();
    internal abstract virtual bool DeepEquals(JToken node);
    public abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    [NullableContextAttribute("2")]
public static bool DeepEquals(JToken t1, JToken t2);
    [NullableContextAttribute("2")]
public JToken get_Next();
    [NullableContextAttribute("2")]
internal void set_Next(JToken value);
    [NullableContextAttribute("2")]
public JToken get_Previous();
    [NullableContextAttribute("2")]
internal void set_Previous(JToken value);
    public string get_Path();
    [NullableContextAttribute("2")]
public void AddAfterSelf(object content);
    [NullableContextAttribute("2")]
public void AddBeforeSelf(object content);
    public IEnumerable`1<JToken> Ancestors();
    public IEnumerable`1<JToken> AncestorsAndSelf();
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JToken/<GetAncestors>d__47")]
internal IEnumerable`1<JToken> GetAncestors(bool self);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JToken/<AfterSelf>d__48")]
public IEnumerable`1<JToken> AfterSelf();
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JToken/<BeforeSelf>d__49")]
public IEnumerable`1<JToken> BeforeSelf();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual T Value(object key);
    [NullableContextAttribute("2")]
public virtual JToken get_First();
    [NullableContextAttribute("2")]
public virtual JToken get_Last();
    public virtual JEnumerable`1<JToken> Children();
    public JEnumerable`1<T> Children();
    public virtual IEnumerable`1<T> Values();
    public void Remove();
    public void Replace(JToken value);
    public abstract virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    public virtual string ToString();
    public string ToString(Formatting formatting, JsonConverter[] converters);
    private static JValue EnsureValue(JToken value);
    private static string GetType(JToken token);
    private static bool ValidateToken(JToken o, JTokenType[] validTypes, bool nullable);
    public static bool op_Explicit(JToken value);
    public static DateTimeOffset op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JToken value);
    public static long op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static short op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static char op_Explicit(JToken value);
    public static byte op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JToken value);
    public static DateTime op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JToken value);
    public static decimal op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static string op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JToken value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Byte[] op_Explicit(JToken value);
    public static Guid op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JToken value);
    public static TimeSpan op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Nullable`1<TimeSpan> op_Explicit(JToken value);
    [NullableContextAttribute("2")]
public static Uri op_Explicit(JToken value);
    public static JToken op_Implicit(bool value);
    public static JToken op_Implicit(DateTimeOffset value);
    public static JToken op_Implicit(byte value);
    public static JToken op_Implicit(Nullable`1<byte> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<sbyte> value);
    public static JToken op_Implicit(Nullable`1<bool> value);
    public static JToken op_Implicit(long value);
    public static JToken op_Implicit(Nullable`1<DateTime> value);
    public static JToken op_Implicit(Nullable`1<DateTimeOffset> value);
    public static JToken op_Implicit(Nullable`1<decimal> value);
    public static JToken op_Implicit(Nullable`1<double> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ushort value);
    public static JToken op_Implicit(int value);
    public static JToken op_Implicit(Nullable`1<int> value);
    public static JToken op_Implicit(DateTime value);
    public static JToken op_Implicit(Nullable`1<long> value);
    public static JToken op_Implicit(Nullable`1<float> value);
    public static JToken op_Implicit(decimal value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(Nullable`1<ulong> value);
    public static JToken op_Implicit(double value);
    public static JToken op_Implicit(float value);
    public static JToken op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JToken op_Implicit(ulong value);
    public static JToken op_Implicit(Byte[] value);
    public static JToken op_Implicit(Uri value);
    public static JToken op_Implicit(TimeSpan value);
    public static JToken op_Implicit(Nullable`1<TimeSpan> value);
    public static JToken op_Implicit(Guid value);
    public static JToken op_Implicit(Nullable`1<Guid> value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<Microsoft.Identity.Json.Linq.JToken>.GetEnumerator();
    internal abstract virtual int GetDeepHashCode();
    private sealed virtual override IJEnumerable`1<JToken> Microsoft.Identity.Json.Linq.IJEnumerable<Microsoft.Identity.Json.Linq.JToken>.get_Item(object key);
    public JsonReader CreateReader();
    internal static JToken FromObjectInternal(object o, JsonSerializer jsonSerializer);
    public static JToken FromObject(object o);
    public static JToken FromObject(object o, JsonSerializer jsonSerializer);
    public T ToObject();
    public object ToObject(Type objectType);
    public T ToObject(JsonSerializer jsonSerializer);
    public object ToObject(Type objectType, JsonSerializer jsonSerializer);
    public static JToken ReadFrom(JsonReader reader);
    public static JToken ReadFrom(JsonReader reader, JsonLoadSettings settings);
    public static JToken Parse(string json);
    public static JToken Parse(string json, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader, JsonLoadSettings settings);
    public static JToken Load(JsonReader reader);
    [NullableContextAttribute("2")]
internal void SetLineInfo(IJsonLineInfo lineInfo, JsonLoadSettings settings);
    internal void SetLineInfo(int lineNumber, int linePosition);
    private sealed virtual override bool Microsoft.Identity.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LinePosition();
    public JToken SelectToken(string path);
    public JToken SelectToken(string path, bool errorWhenNoMatch);
    [NullableContextAttribute("2")]
public JToken SelectToken(string path, JsonSelectSettings settings);
    public IEnumerable`1<JToken> SelectTokens(string path);
    public IEnumerable`1<JToken> SelectTokens(string path, bool errorWhenNoMatch);
    public IEnumerable`1<JToken> SelectTokens(string path, JsonSelectSettings settings);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    public JToken DeepClone();
    public void AddAnnotation(object annotation);
    public T Annotation();
    public object Annotation(Type type);
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JToken/<Annotations>d__180`1")]
public IEnumerable`1<T> Annotations();
    [IteratorStateMachineAttribute("Microsoft.Identity.Json.Linq.JToken/<Annotations>d__181")]
public IEnumerable`1<object> Annotations(Type type);
    public void RemoveAnnotations();
    public void RemoveAnnotations(Type type);
    internal void CopyAnnotations(JToken target, JToken source);
}
internal class Microsoft.Identity.Json.Linq.JTokenEqualityComparer : object {
    public sealed virtual bool Equals(JToken x, JToken y);
    public sealed virtual int GetHashCode(JToken obj);
}
internal class Microsoft.Identity.Json.Linq.JTokenReader : JsonReader {
    private JToken _root;
    [NullableAttribute("2")]
private string _initialPath;
    [NullableAttribute("2")]
private JToken _parent;
    [NullableAttribute("2")]
private JToken _current;
    [NullableAttribute("2")]
public JToken CurrentToken { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LineNumber { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LinePosition { get; }
    public string Path { get; }
    public JTokenReader(JToken token);
    public JTokenReader(JToken token, string initialPath);
    [NullableContextAttribute("2")]
public JToken get_CurrentToken();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    [NullableContextAttribute("2")]
private string SafeToString(object value);
    private sealed virtual override bool Microsoft.Identity.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LinePosition();
    public virtual string get_Path();
}
internal enum Microsoft.Identity.Json.Linq.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Linq.JTokenWriter : JsonWriter {
    private JContainer _token;
    private JContainer _parent;
    private JValue _value;
    private JToken _current;
    public JToken CurrentToken { get; }
    public JToken Token { get; }
    [NullableContextAttribute("0")]
public JTokenWriter(JContainer container);
    [NullableContextAttribute("0")]
internal virtual Task WriteTokenAsync(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments, CancellationToken cancellationToken);
    public JToken get_CurrentToken();
    public JToken get_Token();
    public virtual void Flush();
    public virtual void Close();
    public virtual void WriteStartObject();
    [NullableContextAttribute("0")]
private void AddParent(JContainer container);
    private void RemoveParent();
    public virtual void WriteStartArray();
    [NullableContextAttribute("0")]
public virtual void WriteStartConstructor(string name);
    protected virtual void WriteEnd(JsonToken token);
    [NullableContextAttribute("0")]
public virtual void WritePropertyName(string name);
    private void AddValue(object value, JsonToken token);
    internal void AddValue(JValue value, JsonToken token);
    public virtual void WriteValue(object value);
    public virtual void WriteNull();
    public virtual void WriteUndefined();
    public virtual void WriteRaw(string json);
    public virtual void WriteComment(string text);
    public virtual void WriteValue(string value);
    public virtual void WriteValue(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ulong value);
    public virtual void WriteValue(float value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(short value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(ushort value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(byte value);
    [CLSCompliantAttribute("False")]
public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Uri value);
    [NullableContextAttribute("0")]
internal virtual void WriteToken(JsonReader reader, bool writeChildren, bool writeDateConstructorAsDate, bool writeComments);
}
internal class Microsoft.Identity.Json.Linq.JValue : JToken {
    private JTokenType _valueType;
    [NullableAttribute("2")]
private object _value;
    public bool HasValues { get; }
    public JTokenType Type { get; }
    [NullableAttribute("2")]
public object Value { get; public set; }
    [NullableContextAttribute("2")]
internal JValue(object value, JTokenType type);
    public JValue(JValue other);
    public JValue(long value);
    public JValue(decimal value);
    public JValue(char value);
    [CLSCompliantAttribute("False")]
public JValue(ulong value);
    public JValue(double value);
    public JValue(float value);
    public JValue(DateTime value);
    public JValue(DateTimeOffset value);
    public JValue(bool value);
    [NullableContextAttribute("2")]
public JValue(string value);
    public JValue(Guid value);
    [NullableContextAttribute("2")]
public JValue(Uri value);
    public JValue(TimeSpan value);
    [NullableContextAttribute("2")]
public JValue(object value);
    public virtual Task WriteToAsync(JsonWriter writer, CancellationToken cancellationToken, JsonConverter[] converters);
    internal virtual bool DeepEquals(JToken node);
    public virtual bool get_HasValues();
    [NullableContextAttribute("2")]
internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    [NullableContextAttribute("2")]
private static bool Operation(ExpressionType operation, object objA, object objB, Object& result);
    internal virtual JToken CloneToken();
    public static JValue CreateComment(string value);
    public static JValue CreateString(string value);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    [NullableContextAttribute("2")]
private static JTokenType GetValueType(Nullable`1<JTokenType> current, object value);
    private static JTokenType GetStringValueType(Nullable`1<JTokenType> current);
    public virtual JTokenType get_Type();
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
public void set_Value(object value);
    public virtual void WriteTo(JsonWriter writer, JsonConverter[] converters);
    internal virtual int GetDeepHashCode();
    private static bool ValuesEquals(JValue v1, JValue v2);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string format);
    public sealed virtual string ToString(IFormatProvider formatProvider);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    protected virtual DynamicMetaObject GetMetaObject(Expression parameter);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
}
internal enum Microsoft.Identity.Json.Linq.LineInfoHandling : Enum {
    public int value__;
    public static LineInfoHandling Ignore;
    public static LineInfoHandling Load;
}
internal enum Microsoft.Identity.Json.Linq.MergeArrayHandling : Enum {
    public int value__;
    public static MergeArrayHandling Concat;
    public static MergeArrayHandling Union;
    public static MergeArrayHandling Replace;
    public static MergeArrayHandling Merge;
}
[FlagsAttribute]
internal enum Microsoft.Identity.Json.Linq.MergeNullValueHandling : Enum {
    public int value__;
    public static MergeNullValueHandling Ignore;
    public static MergeNullValueHandling Merge;
}
internal enum Microsoft.Identity.Json.MemberSerialization : Enum {
    public int value__;
    public static MemberSerialization OptOut;
    public static MemberSerialization OptIn;
    public static MemberSerialization Fields;
}
internal enum Microsoft.Identity.Json.MetadataPropertyHandling : Enum {
    public int value__;
    public static MetadataPropertyHandling Default;
    public static MetadataPropertyHandling ReadAhead;
    public static MetadataPropertyHandling Ignore;
}
internal enum Microsoft.Identity.Json.MissingMemberHandling : Enum {
    public int value__;
    public static MissingMemberHandling Ignore;
    public static MissingMemberHandling Error;
}
internal enum Microsoft.Identity.Json.NullValueHandling : Enum {
    public int value__;
    public static NullValueHandling Include;
    public static NullValueHandling Ignore;
}
internal enum Microsoft.Identity.Json.ObjectCreationHandling : Enum {
    public int value__;
    public static ObjectCreationHandling Auto;
    public static ObjectCreationHandling Reuse;
    public static ObjectCreationHandling Replace;
}
[FlagsAttribute]
internal enum Microsoft.Identity.Json.PreserveReferencesHandling : Enum {
    public int value__;
    public static PreserveReferencesHandling None;
    public static PreserveReferencesHandling Objects;
    public static PreserveReferencesHandling Arrays;
    public static PreserveReferencesHandling All;
}
internal enum Microsoft.Identity.Json.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDateTimeOffset;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
internal enum Microsoft.Identity.Json.ReferenceLoopHandling : Enum {
    public int value__;
    public static ReferenceLoopHandling Error;
    public static ReferenceLoopHandling Ignore;
    public static ReferenceLoopHandling Serialize;
}
internal enum Microsoft.Identity.Json.Required : Enum {
    public int value__;
    public static Required Default;
    public static Required AllowNull;
    public static Required Always;
    public static Required DisallowNull;
}
[ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Microsoft.Identity.Json.Schema.Extensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static bool IsValid(JToken source, JsonSchema schema, IList`1& errorMessages);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema);
    [ExtensionAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
public static void Validate(JToken source, JsonSchema schema, ValidationEventHandler validationEventHandler);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchema : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Transient>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<JsonSchemaType> <Disallow>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <Extends>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <DeferredReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesResolved>k__BackingField;
    public string Id { get; public set; }
    public string Title { get; public set; }
    public Nullable`1<bool> Required { get; public set; }
    public Nullable`1<bool> ReadOnly { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public Nullable`1<bool> Transient { get; public set; }
    public string Description { get; public set; }
    public Nullable`1<JsonSchemaType> Type { get; public set; }
    public string Pattern { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public Nullable`1<bool> ExclusiveMinimum { get; public set; }
    public Nullable`1<bool> ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<JsonSchema> Items { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public JsonSchema AdditionalItems { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IDictionary`2<string, JsonSchema> Properties { get; public set; }
    public JsonSchema AdditionalProperties { get; public set; }
    public IDictionary`2<string, JsonSchema> PatternProperties { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public string Requires { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public Nullable`1<JsonSchemaType> Disallow { get; public set; }
    public JToken Default { get; public set; }
    public IList`1<JsonSchema> Extends { get; public set; }
    public string Format { get; public set; }
    internal string Location { get; internal set; }
    internal string InternalId { get; }
    internal string DeferredReference { get; internal set; }
    internal bool ReferencesResolved { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Hidden();
    [CompilerGeneratedAttribute]
public void set_Hidden(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Transient();
    [CompilerGeneratedAttribute]
public void set_Transient(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchema value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public JsonSchema get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchema value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchema> value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(string value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public Nullable`1<JsonSchemaType> get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(Nullable`1<JsonSchemaType> value);
    [CompilerGeneratedAttribute]
public JToken get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(JToken value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_Extends();
    [CompilerGeneratedAttribute]
public void set_Extends(IList`1<JsonSchema> value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
internal string get_Location();
    [CompilerGeneratedAttribute]
internal void set_Location(string value);
    internal string get_InternalId();
    [CompilerGeneratedAttribute]
internal string get_DeferredReference();
    [CompilerGeneratedAttribute]
internal void set_DeferredReference(string value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesResolved();
    [CompilerGeneratedAttribute]
internal void set_ReferencesResolved(bool value);
    public static JsonSchema Read(JsonReader reader);
    public static JsonSchema Read(JsonReader reader, JsonSchemaResolver resolver);
    public static JsonSchema Parse(string json);
    public static JsonSchema Parse(string json, JsonSchemaResolver resolver);
    public void WriteTo(JsonWriter writer);
    public void WriteTo(JsonWriter writer, JsonSchemaResolver resolver);
    public virtual string ToString();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaBuilder : object {
    private IList`1<JsonSchema> _stack;
    private JsonSchemaResolver _resolver;
    private IDictionary`2<string, JsonSchema> _documentSchemas;
    private JsonSchema _currentSchema;
    private JObject _rootSchema;
    private JsonSchema CurrentSchema { get; }
    public JsonSchemaBuilder(JsonSchemaResolver resolver);
    private void Push(JsonSchema value);
    private JsonSchema Pop();
    private JsonSchema get_CurrentSchema();
    internal JsonSchema Read(JsonReader reader);
    private string UnescapeReference(string reference);
    private JsonSchema ResolveReferences(JsonSchema schema);
    private JsonSchema BuildSchema(JToken token);
    private void ProcessSchemaProperties(JObject schemaObject);
    private void ProcessExtends(JToken token);
    private void ProcessEnum(JToken token);
    private void ProcessAdditionalProperties(JToken token);
    private void ProcessAdditionalItems(JToken token);
    private IDictionary`2<string, JsonSchema> ProcessProperties(JToken token);
    private void ProcessItems(JToken token);
    private Nullable`1<JsonSchemaType> ProcessType(JToken token);
    internal static JsonSchemaType MapType(string type);
    internal static string MapType(JsonSchemaType type);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal static class Microsoft.Identity.Json.Schema.JsonSchemaConstants : object {
    public static string TypePropertyName;
    public static string PropertiesPropertyName;
    public static string ItemsPropertyName;
    public static string AdditionalItemsPropertyName;
    public static string RequiredPropertyName;
    public static string PatternPropertiesPropertyName;
    public static string AdditionalPropertiesPropertyName;
    public static string RequiresPropertyName;
    public static string MinimumPropertyName;
    public static string MaximumPropertyName;
    public static string ExclusiveMinimumPropertyName;
    public static string ExclusiveMaximumPropertyName;
    public static string MinimumItemsPropertyName;
    public static string MaximumItemsPropertyName;
    public static string PatternPropertyName;
    public static string MaximumLengthPropertyName;
    public static string MinimumLengthPropertyName;
    public static string EnumPropertyName;
    public static string ReadOnlyPropertyName;
    public static string TitlePropertyName;
    public static string DescriptionPropertyName;
    public static string FormatPropertyName;
    public static string DefaultPropertyName;
    public static string TransientPropertyName;
    public static string DivisibleByPropertyName;
    public static string HiddenPropertyName;
    public static string DisallowPropertyName;
    public static string ExtendsPropertyName;
    public static string IdPropertyName;
    public static string UniqueItemsPropertyName;
    public static string OptionValuePropertyName;
    public static string OptionLabelPropertyName;
    public static IDictionary`2<string, JsonSchemaType> JsonSchemaTypeMapping;
    private static JsonSchemaConstants();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaException : JsonException {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public int LineNumber { get; }
    public int LinePosition { get; }
    public string Path { get; }
    public JsonSchemaException(string message);
    public JsonSchemaException(string message, Exception innerException);
    internal JsonSchemaException(string message, Exception innerException, string path, int lineNumber, int linePosition);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
public string get_Path();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaGenerator : object {
    [CompilerGeneratedAttribute]
private UndefinedSchemaIdHandling <UndefinedSchemaIdHandling>k__BackingField;
    private IContractResolver _contractResolver;
    private JsonSchemaResolver _resolver;
    private IList`1<TypeSchema> _stack;
    private JsonSchema _currentSchema;
    public UndefinedSchemaIdHandling UndefinedSchemaIdHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    private JsonSchema CurrentSchema { get; }
    [CompilerGeneratedAttribute]
public UndefinedSchemaIdHandling get_UndefinedSchemaIdHandling();
    [CompilerGeneratedAttribute]
public void set_UndefinedSchemaIdHandling(UndefinedSchemaIdHandling value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    private JsonSchema get_CurrentSchema();
    private void Push(TypeSchema typeSchema);
    private TypeSchema Pop();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver);
    public JsonSchema Generate(Type type, bool rootSchemaNullable);
    public JsonSchema Generate(Type type, JsonSchemaResolver resolver, bool rootSchemaNullable);
    private string GetTitle(Type type);
    private string GetDescription(Type type);
    private string GetTypeId(Type type, bool explicitOnly);
    private JsonSchema GenerateInternal(Type type, Required valueRequired, bool required);
    private JsonSchemaType AddNullType(JsonSchemaType type, Required valueRequired);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private void GenerateObjectSchema(Type type, JsonObjectContract contract);
    private void GenerateISerializableContract(Type type, JsonISerializableContract contract);
    internal static bool HasFlag(Nullable`1<JsonSchemaType> value, JsonSchemaType flag);
    private JsonSchemaType GetJsonSchemaType(Type type, Required valueRequired);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaModel : object {
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <DivisibleBy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinimumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Patterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonSchemaModel> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchemaModel> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaModel <AdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalItemsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAdditionalItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JToken> <Enum>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaType <Disallow>k__BackingField;
    public bool Required { get; public set; }
    public JsonSchemaType Type { get; public set; }
    public Nullable`1<int> MinimumLength { get; public set; }
    public Nullable`1<int> MaximumLength { get; public set; }
    public Nullable`1<double> DivisibleBy { get; public set; }
    public Nullable`1<double> Minimum { get; public set; }
    public Nullable`1<double> Maximum { get; public set; }
    public bool ExclusiveMinimum { get; public set; }
    public bool ExclusiveMaximum { get; public set; }
    public Nullable`1<int> MinimumItems { get; public set; }
    public Nullable`1<int> MaximumItems { get; public set; }
    public IList`1<string> Patterns { get; public set; }
    public IList`1<JsonSchemaModel> Items { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> Properties { get; public set; }
    public IDictionary`2<string, JsonSchemaModel> PatternProperties { get; public set; }
    public JsonSchemaModel AdditionalProperties { get; public set; }
    public JsonSchemaModel AdditionalItems { get; public set; }
    public bool PositionalItemsValidation { get; public set; }
    public bool AllowAdditionalProperties { get; public set; }
    public bool AllowAdditionalItems { get; public set; }
    public bool UniqueItems { get; public set; }
    public IList`1<JToken> Enum { get; public set; }
    public JsonSchemaType Disallow { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(JsonSchemaType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumLength();
    [CompilerGeneratedAttribute]
public void set_MinimumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumLength();
    [CompilerGeneratedAttribute]
public void set_MaximumLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_DivisibleBy();
    [CompilerGeneratedAttribute]
public void set_DivisibleBy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinimumItems();
    [CompilerGeneratedAttribute]
public void set_MinimumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumItems();
    [CompilerGeneratedAttribute]
public void set_MaximumItems(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Patterns();
    [CompilerGeneratedAttribute]
public void set_Patterns(IList`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<JsonSchemaModel> get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IList`1<JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchemaModel> get_PatternProperties();
    [CompilerGeneratedAttribute]
public void set_PatternProperties(IDictionary`2<string, JsonSchemaModel> value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public JsonSchemaModel get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaModel value);
    [CompilerGeneratedAttribute]
public bool get_PositionalItemsValidation();
    [CompilerGeneratedAttribute]
public void set_PositionalItemsValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AllowAdditionalItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public IList`1<JToken> get_Enum();
    [CompilerGeneratedAttribute]
public void set_Enum(IList`1<JToken> value);
    [CompilerGeneratedAttribute]
public JsonSchemaType get_Disallow();
    [CompilerGeneratedAttribute]
public void set_Disallow(JsonSchemaType value);
    public static JsonSchemaModel Create(IList`1<JsonSchema> schemata);
    private static void Combine(JsonSchemaModel model, JsonSchema schema);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaModelBuilder : object {
    private JsonSchemaNodeCollection _nodes;
    private Dictionary`2<JsonSchemaNode, JsonSchemaModel> _nodeModels;
    private JsonSchemaNode _node;
    public JsonSchemaModel Build(JsonSchema schema);
    public JsonSchemaNode AddSchema(JsonSchemaNode existingNode, JsonSchema schema);
    public void AddProperties(IDictionary`2<string, JsonSchema> source, IDictionary`2<string, JsonSchemaNode> target);
    public void AddProperty(IDictionary`2<string, JsonSchemaNode> target, string propertyName, JsonSchema schema);
    public void AddItem(JsonSchemaNode parentNode, int index, JsonSchema schema);
    public void AddAdditionalProperties(JsonSchemaNode parentNode, JsonSchema schema);
    public void AddAdditionalItems(JsonSchemaNode parentNode, JsonSchema schema);
    private JsonSchemaModel BuildNodeModel(JsonSchemaNode node);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaNode : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<JsonSchema> <Schemas>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonSchemaNode> <PatternProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<JsonSchemaNode> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaNode <AdditionalItems>k__BackingField;
    public string Id { get; }
    public ReadOnlyCollection`1<JsonSchema> Schemas { get; }
    public Dictionary`2<string, JsonSchemaNode> Properties { get; }
    public Dictionary`2<string, JsonSchemaNode> PatternProperties { get; }
    public List`1<JsonSchemaNode> Items { get; }
    public JsonSchemaNode AdditionalProperties { get; public set; }
    public JsonSchemaNode AdditionalItems { get; public set; }
    public JsonSchemaNode(JsonSchema schema);
    private JsonSchemaNode(JsonSchemaNode source, JsonSchema schema);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<JsonSchema> get_Schemas();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_Properties();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonSchemaNode> get_PatternProperties();
    [CompilerGeneratedAttribute]
public List`1<JsonSchemaNode> get_Items();
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(JsonSchemaNode value);
    [CompilerGeneratedAttribute]
public JsonSchemaNode get_AdditionalItems();
    [CompilerGeneratedAttribute]
public void set_AdditionalItems(JsonSchemaNode value);
    public JsonSchemaNode Combine(JsonSchema schema);
    public static string GetId(IEnumerable`1<JsonSchema> schemata);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaNodeCollection : KeyedCollection`2<string, JsonSchemaNode> {
    protected virtual string GetKeyForItem(JsonSchemaNode item);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaResolver : object {
    [CompilerGeneratedAttribute]
private IList`1<JsonSchema> <LoadedSchemas>k__BackingField;
    public IList`1<JsonSchema> LoadedSchemas { get; protected set; }
    [CompilerGeneratedAttribute]
public IList`1<JsonSchema> get_LoadedSchemas();
    [CompilerGeneratedAttribute]
protected void set_LoadedSchemas(IList`1<JsonSchema> value);
    public virtual JsonSchema GetSchema(string reference);
}
[FlagsAttribute]
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal enum Microsoft.Identity.Json.Schema.JsonSchemaType : Enum {
    public int value__;
    public static JsonSchemaType None;
    public static JsonSchemaType String;
    public static JsonSchemaType Float;
    public static JsonSchemaType Integer;
    public static JsonSchemaType Boolean;
    public static JsonSchemaType Object;
    public static JsonSchemaType Array;
    public static JsonSchemaType Null;
    public static JsonSchemaType Any;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.JsonSchemaWriter : object {
    private JsonWriter _writer;
    private JsonSchemaResolver _resolver;
    public JsonSchemaWriter(JsonWriter writer, JsonSchemaResolver resolver);
    private void ReferenceOrWriteSchema(JsonSchema schema);
    public void WriteSchema(JsonSchema schema);
    private void WriteSchemaDictionaryIfNotNull(JsonWriter writer, string propertyName, IDictionary`2<string, JsonSchema> properties);
    private void WriteItems(JsonSchema schema);
    private void WriteType(string propertyName, JsonWriter writer, JsonSchemaType type);
    private void WritePropertyIfNotNull(JsonWriter writer, string propertyName, object value);
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal enum Microsoft.Identity.Json.Schema.UndefinedSchemaIdHandling : Enum {
    public int value__;
    public static UndefinedSchemaIdHandling None;
    public static UndefinedSchemaIdHandling UseTypeName;
    public static UndefinedSchemaIdHandling UseAssemblyQualifiedName;
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.ValidationEventArgs : EventArgs {
    private JsonSchemaException _ex;
    public JsonSchemaException Exception { get; }
    public string Path { get; }
    public string Message { get; }
    internal ValidationEventArgs(JsonSchemaException ex);
    public JsonSchemaException get_Exception();
    public string get_Path();
    public string get_Message();
}
[ObsoleteAttribute("JSON Schema validation has been moved to its own package. See https://www.newtonsoft.com/jsonschema for more details.")]
internal class Microsoft.Identity.Json.Schema.ValidationEventHandler : MulticastDelegate {
    public ValidationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ValidationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ValidationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Identity.Json.Serialization.CachedAttributeGetter`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<object, T> TypeAttributeCache;
    private static CachedAttributeGetter`1();
    public static T GetAttribute(object type);
}
internal class Microsoft.Identity.Json.Serialization.CamelCaseNamingStrategy : NamingStrategy {
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public CamelCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    protected virtual string ResolvePropertyName(string name);
}
internal class Microsoft.Identity.Json.Serialization.CamelCasePropertyNamesContractResolver : DefaultContractResolver {
    private static object TypeContractCacheLock;
    private static DefaultJsonNameTable NameTable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<StructMultiKey`2<Type, Type>, JsonContract> _contractCache;
    private static CamelCasePropertyNamesContractResolver();
    public virtual JsonContract ResolveContract(Type type);
    internal virtual DefaultJsonNameTable GetNameTable();
}
internal class Microsoft.Identity.Json.Serialization.DefaultContractResolver : object {
    private static IContractResolver _instance;
    private static String[] RestrictedTypeNames;
    private static JsonConverter[] BuiltInConverters;
    private DefaultJsonNameTable _nameTable;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    [CompilerGeneratedAttribute]
private BindingFlags <DefaultMembersSearchFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeCompilerGeneratedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSerializableAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreIsSpecifiedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreShouldSerializeMembers>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private NamingStrategy <NamingStrategy>k__BackingField;
    internal static IContractResolver Instance { get; }
    public bool DynamicCodeGeneration { get; }
    [ObsoleteAttribute("DefaultMembersSearchFlags is obsolete. To modify the members serialized inherit from DefaultContractResolver and override the GetSerializableMembers method instead.")]
public BindingFlags DefaultMembersSearchFlags { get; public set; }
    public bool SerializeCompilerGeneratedMembers { get; public set; }
    public bool IgnoreSerializableInterface { get; public set; }
    public bool IgnoreSerializableAttribute { get; public set; }
    public bool IgnoreIsSpecifiedMembers { get; public set; }
    public bool IgnoreShouldSerializeMembers { get; public set; }
    [NullableAttribute("2")]
public NamingStrategy NamingStrategy { get; public set; }
    private static DefaultContractResolver();
    internal static IContractResolver get_Instance();
    public bool get_DynamicCodeGeneration();
    [CompilerGeneratedAttribute]
public BindingFlags get_DefaultMembersSearchFlags();
    [CompilerGeneratedAttribute]
public void set_DefaultMembersSearchFlags(BindingFlags value);
    [CompilerGeneratedAttribute]
public bool get_SerializeCompilerGeneratedMembers();
    [CompilerGeneratedAttribute]
public void set_SerializeCompilerGeneratedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableInterface();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableInterface(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSerializableAttribute();
    [CompilerGeneratedAttribute]
public void set_IgnoreSerializableAttribute(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreIsSpecifiedMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreIsSpecifiedMembers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreShouldSerializeMembers();
    [CompilerGeneratedAttribute]
public void set_IgnoreShouldSerializeMembers(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NamingStrategy get_NamingStrategy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NamingStrategy(NamingStrategy value);
    public virtual JsonContract ResolveContract(Type type);
    private static bool FilterMembers(MemberInfo member);
    protected virtual List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private bool ShouldSerializeEntityMember(MemberInfo memberInfo);
    protected virtual JsonObjectContract CreateObjectContract(Type objectType);
    private static void ThrowUnableToSerializeError(object o, StreamingContext context);
    private MemberInfo GetExtensionDataMemberForType(Type type);
    private static void SetExtensionDataDelegates(JsonObjectContract contract, MemberInfo member);
    private ConstructorInfo GetAttributeConstructor(Type objectType);
    private ConstructorInfo GetImmutableConstructor(Type objectType, JsonPropertyCollection memberProperties);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    protected virtual IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    protected virtual JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    protected virtual JsonConverter ResolveContractConverter(Type objectType);
    private Func`1<object> GetDefaultCreator(Type createdType);
    private void InitializeContract(JsonContract contract);
    private void ResolveCallbackMethods(JsonContract contract, Type t);
    private void GetCallbackMethodsForType(Type type, List`1& onSerializing, List`1& onSerialized, List`1& onDeserializing, List`1& onDeserialized, List`1& onError);
    private static bool IsConcurrentOrObservableCollection(Type t);
    private static bool ShouldSkipDeserialized(Type t);
    private static bool ShouldSkipSerializing(Type t);
    private List`1<Type> GetClassHierarchyForType(Type type);
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
    protected virtual JsonPrimitiveContract CreatePrimitiveContract(Type objectType);
    protected virtual JsonLinqContract CreateLinqContract(Type objectType);
    protected virtual JsonISerializableContract CreateISerializableContract(Type objectType);
    protected virtual JsonDynamicContract CreateDynamicContract(Type objectType);
    protected virtual JsonStringContract CreateStringContract(Type objectType);
    protected virtual JsonContract CreateContract(Type objectType);
    internal static bool IsJsonPrimitiveType(Type t);
    internal static bool IsIConvertible(Type t);
    internal static bool CanConvertToString(Type type);
    private static bool IsValidCallback(MethodInfo method, ParameterInfo[] parameters, Type attributeType, MethodInfo currentCallback, Type& prevAttributeType);
    internal static string GetClrTypeFullName(Type type);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    internal virtual DefaultJsonNameTable GetNameTable();
    protected virtual IValueProvider CreateMemberValueProvider(MemberInfo member);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, MemberSerialization memberSerialization, Boolean& allowNonPublicAccess);
    private Predicate`1<object> CreateShouldSerializeTest(MemberInfo member);
    private void SetIsSpecifiedActions(JsonProperty property, MemberInfo member, bool allowNonPublicAccess);
    protected virtual string ResolvePropertyName(string propertyName);
    protected virtual string ResolveExtensionDataName(string extensionDataName);
    protected virtual string ResolveDictionaryKey(string dictionaryKey);
    public string GetResolvedPropertyName(string propertyName);
}
internal class Microsoft.Identity.Json.Serialization.DefaultNamingStrategy : NamingStrategy {
    protected virtual string ResolvePropertyName(string name);
}
internal class Microsoft.Identity.Json.Serialization.DefaultReferenceResolver : object {
    private int _referenceCount;
    private BidirectionalDictionary`2<string, object> GetMappings(object context);
    public sealed virtual object ResolveReference(object context, string reference);
    public sealed virtual string GetReference(object context, object value);
    public sealed virtual void AddReference(object context, string reference, object value);
    public sealed virtual bool IsReferenced(object context, object value);
}
internal class Microsoft.Identity.Json.Serialization.DefaultSerializationBinder : SerializationBinder {
    internal static DefaultSerializationBinder Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<StructMultiKey`2<string, string>, Type> _typeCache;
    private static DefaultSerializationBinder();
    private Type GetTypeFromTypeNameKey(StructMultiKey`2<string, string> typeNameKey);
    private Type GetGenericTypeFromTypeName(string typeName, Assembly assembly);
    private Type GetTypeByName(StructMultiKey`2<string, string> typeNameKey);
    public virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal class Microsoft.Identity.Json.Serialization.ErrorContext : object {
    [CompilerGeneratedAttribute]
private bool <Traced>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <OriginalObject>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Handled>k__BackingField;
    internal bool Traced { get; internal set; }
    public Exception Error { get; }
    [NullableAttribute("2")]
public object OriginalObject { get; }
    [NullableAttribute("2")]
public object Member { get; }
    public string Path { get; }
    public bool Handled { get; public set; }
    internal ErrorContext(object originalObject, object member, string path, Exception error);
    [CompilerGeneratedAttribute]
internal bool get_Traced();
    [CompilerGeneratedAttribute]
internal void set_Traced(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_OriginalObject();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Member();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
internal class Microsoft.Identity.Json.Serialization.ErrorEventArgs : EventArgs {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <CurrentObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorContext <ErrorContext>k__BackingField;
    [NullableAttribute("2")]
public object CurrentObject { get; }
    public ErrorContext ErrorContext { get; }
    public ErrorEventArgs(object currentObject, ErrorContext errorContext);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_CurrentObject();
    [CompilerGeneratedAttribute]
public ErrorContext get_ErrorContext();
}
internal class Microsoft.Identity.Json.Serialization.ExpressionValueProvider : object {
    private MemberInfo _memberInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, object> _getter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<object, object> _setter;
    public ExpressionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Microsoft.Identity.Json.Serialization.ExtensionDataGetter : MulticastDelegate {
    public ExtensionDataGetter(object object, IntPtr method);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual IEnumerable`1<KeyValuePair`2<object, object>> EndInvoke(IAsyncResult result);
}
internal class Microsoft.Identity.Json.Serialization.ExtensionDataSetter : MulticastDelegate {
    public ExtensionDataSetter(object object, IntPtr method);
    public virtual void Invoke(object o, string key, object value);
    public virtual IAsyncResult BeginInvoke(object o, string key, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Identity.Json.Serialization.FormatterConverter : object {
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
internal interface Microsoft.Identity.Json.Serialization.IAttributeProvider {
    public abstract virtual IList`1<Attribute> GetAttributes(bool inherit);
    public abstract virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
internal interface Microsoft.Identity.Json.Serialization.IContractResolver {
    public abstract virtual JsonContract ResolveContract(Type type);
}
internal interface Microsoft.Identity.Json.Serialization.IReferenceResolver {
    public abstract virtual object ResolveReference(object context, string reference);
    public abstract virtual string GetReference(object context, object value);
    public abstract virtual bool IsReferenced(object context, object value);
    public abstract virtual void AddReference(object context, string reference, object value);
}
internal interface Microsoft.Identity.Json.Serialization.ISerializationBinder {
    public abstract virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public abstract virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal interface Microsoft.Identity.Json.Serialization.ITraceWriter {
    public TraceLevel LevelFilter { get; }
    public abstract virtual TraceLevel get_LevelFilter();
    public abstract virtual void Trace(TraceLevel level, string message, Exception ex);
}
internal interface Microsoft.Identity.Json.Serialization.IValueProvider {
    public abstract virtual void SetValue(object target, object value);
    public abstract virtual object GetValue(object target);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Serialization.JsonArrayContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private Type <CollectionItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMultidimensionalArray>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryCollectionCreator;
    [CompilerGeneratedAttribute]
private bool <IsArray>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type CollectionItemType { get; }
    public bool IsMultidimensionalArray { get; }
    internal bool IsArray { get; }
    internal bool ShouldCreateWrapper { get; }
    internal bool CanDeserialize { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [NullableContextAttribute("0")]
public JsonArrayContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_CollectionItemType();
    [CompilerGeneratedAttribute]
public bool get_IsMultidimensionalArray();
    [CompilerGeneratedAttribute]
internal bool get_IsArray();
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
internal bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [NullableContextAttribute("0")]
internal IWrappedCollection CreateWrapper(object list);
    [NullableContextAttribute("0")]
internal IList CreateTemporaryCollection();
    [NullableContextAttribute("0")]
private void StoreFSharpListCreatorIfNecessary(Type underlyingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Serialization.JsonContainerContract : JsonContract {
    private JsonContract _itemContract;
    private JsonContract _finalItemContract;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContract FinalItemContract { get; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    [NullableContextAttribute("0")]
internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
    internal JsonContract get_FinalItemContract();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
}
internal abstract class Microsoft.Identity.Json.Serialization.JsonContract : object {
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializedCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onDeserializingCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializedCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationCallback> _onSerializingCallbacks;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<SerializationErrorCallback> _onErrorCallbacks;
    private Type _createdType;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonConverter <InternalConverter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<object> <DefaultCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultCreatorNonPublic>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    public Nullable`1<bool> IsReference { get; public set; }
    [NullableAttribute("2")]
public JsonConverter Converter { get; public set; }
    [NullableAttribute("2")]
public JsonConverter InternalConverter { get; internal set; }
    public IList`1<SerializationCallback> OnDeserializedCallbacks { get; }
    public IList`1<SerializationCallback> OnDeserializingCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializedCallbacks { get; }
    public IList`1<SerializationCallback> OnSerializingCallbacks { get; }
    public IList`1<SerializationErrorCallback> OnErrorCallbacks { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> DefaultCreator { get; public set; }
    public bool DefaultCreatorNonPublic { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public JsonConverter get_InternalConverter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_InternalConverter(JsonConverter value);
    public IList`1<SerializationCallback> get_OnDeserializedCallbacks();
    public IList`1<SerializationCallback> get_OnDeserializingCallbacks();
    public IList`1<SerializationCallback> get_OnSerializedCallbacks();
    public IList`1<SerializationCallback> get_OnSerializingCallbacks();
    public IList`1<SerializationErrorCallback> get_OnErrorCallbacks();
    [CompilerGeneratedAttribute]
public Func`1<object> get_DefaultCreator();
    [CompilerGeneratedAttribute]
public void set_DefaultCreator(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_DefaultCreatorNonPublic();
    [CompilerGeneratedAttribute]
public void set_DefaultCreatorNonPublic(bool value);
    internal void InvokeOnSerializing(object o, StreamingContext context);
    internal void InvokeOnSerialized(object o, StreamingContext context);
    internal void InvokeOnDeserializing(object o, StreamingContext context);
    internal void InvokeOnDeserialized(object o, StreamingContext context);
    internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext);
    internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo);
    internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo);
}
internal enum Microsoft.Identity.Json.Serialization.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Serialization.JsonDictionaryContract : JsonContainerContract {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <DictionaryKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    private Type _genericCollectionDefinitionType;
    private Type _genericWrapperType;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _genericWrapperCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<object> _genericTemporaryDictionaryCreator;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    private ConstructorInfo _parameterizedConstructor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> DictionaryKeyResolver { get; public set; }
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    [NullableContextAttribute("0")]
public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_DictionaryKeyResolver();
    [CompilerGeneratedAttribute]
public void set_DictionaryKeyResolver(Func`2<string, string> value);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    [NullableContextAttribute("0")]
internal IWrappedDictionary CreateWrapper(object dictionary);
    [NullableContextAttribute("0")]
internal IDictionary CreateTemporaryDictionary();
}
internal class Microsoft.Identity.Json.Serialization.JsonDynamicContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <PropertyNameResolver>k__BackingField;
    private ThreadSafeStore`2<string, CallSite`1<Func`3<CallSite, object, object>>> _callSiteGetters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ThreadSafeStore`2<string, CallSite`1<Func`4<CallSite, object, object, object>>> _callSiteSetters;
    public JsonPropertyCollection Properties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> PropertyNameResolver { get; public set; }
    public JsonDynamicContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_PropertyNameResolver();
    [CompilerGeneratedAttribute]
public void set_PropertyNameResolver(Func`2<string, string> value);
    private static CallSite`1<Func`3<CallSite, object, object>> CreateCallSiteGetter(string name);
    private static CallSite`1<Func`4<CallSite, object, object, object>> CreateCallSiteSetter(string name);
    internal bool TryGetMember(IDynamicMetaObjectProvider dynamicProvider, string name, Object& value);
    internal bool TrySetMember(IDynamicMetaObjectProvider dynamicProvider, string name, object value);
}
internal class Microsoft.Identity.Json.Serialization.JsonFormatterConverter : object {
    private JsonSerializerInternalReader _reader;
    private JsonISerializableContract _contract;
    [NullableAttribute("2")]
private JsonProperty _member;
    public JsonFormatterConverter(JsonSerializerInternalReader reader, JsonISerializableContract contract, JsonProperty member);
    private T GetTokenValue(object value);
    public sealed virtual object Convert(object value, Type type);
    public sealed virtual object Convert(object value, TypeCode typeCode);
    public sealed virtual bool ToBoolean(object value);
    public sealed virtual byte ToByte(object value);
    public sealed virtual char ToChar(object value);
    public sealed virtual DateTime ToDateTime(object value);
    public sealed virtual decimal ToDecimal(object value);
    public sealed virtual double ToDouble(object value);
    public sealed virtual short ToInt16(object value);
    public sealed virtual int ToInt32(object value);
    public sealed virtual long ToInt64(object value);
    public sealed virtual sbyte ToSByte(object value);
    public sealed virtual float ToSingle(object value);
    public sealed virtual string ToString(object value);
    public sealed virtual ushort ToUInt16(object value);
    public sealed virtual UInt32 ToUInt32(object value);
    public sealed virtual ulong ToUInt64(object value);
}
internal class Microsoft.Identity.Json.Serialization.JsonISerializableContract : JsonContainerContract {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <ISerializableCreator>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> ISerializableCreator { get; public set; }
    public JsonISerializableContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_ISerializableCreator();
    [CompilerGeneratedAttribute]
public void set_ISerializableCreator(ObjectConstructor`1<object> value);
}
internal class Microsoft.Identity.Json.Serialization.JsonLinqContract : JsonContract {
    public JsonLinqContract(Type underlyingType);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Serialization.JsonObjectContract : JsonContainerContract {
    [CompilerGeneratedAttribute]
private MemberSerialization <MemberSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MissingMemberHandling> <MissingMemberHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Required> <ItemRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <ItemNullValueHandling>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataSetter <ExtensionDataSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtensionDataGetter <ExtensionDataGetter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<string, string> <ExtensionDataNameResolver>k__BackingField;
    internal bool ExtensionDataIsJToken;
    private Nullable`1<bool> _hasRequiredOrDefaultValueProperties;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _overrideCreator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectConstructor`1<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    private Type _extensionDataValueType;
    public MemberSerialization MemberSerialization { get; public set; }
    public Nullable`1<MissingMemberHandling> MissingMemberHandling { get; public set; }
    public Nullable`1<Required> ItemRequired { get; public set; }
    public Nullable`1<NullValueHandling> ItemNullValueHandling { get; public set; }
    [NullableAttribute("0")]
public JsonPropertyCollection Properties { get; }
    [NullableAttribute("0")]
public JsonPropertyCollection CreatorParameters { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> OverrideCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ObjectConstructor`1<object> ParameterizedCreator { get; internal set; }
    public ExtensionDataSetter ExtensionDataSetter { get; public set; }
    public ExtensionDataGetter ExtensionDataGetter { get; public set; }
    public Type ExtensionDataValueType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<string, string> ExtensionDataNameResolver { get; public set; }
    internal bool HasRequiredOrDefaultValueProperties { get; }
    [NullableContextAttribute("0")]
public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public MemberSerialization get_MemberSerialization();
    [CompilerGeneratedAttribute]
public void set_MemberSerialization(MemberSerialization value);
    [CompilerGeneratedAttribute]
public Nullable`1<MissingMemberHandling> get_MissingMemberHandling();
    [CompilerGeneratedAttribute]
public void set_MissingMemberHandling(Nullable`1<MissingMemberHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Required> get_ItemRequired();
    [CompilerGeneratedAttribute]
public void set_ItemRequired(Nullable`1<Required> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_ItemNullValueHandling();
    [CompilerGeneratedAttribute]
public void set_ItemNullValueHandling(Nullable`1<NullValueHandling> value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    [NullableContextAttribute("0")]
public JsonPropertyCollection get_CreatorParameters();
    public ObjectConstructor`1<object> get_OverrideCreator();
    public void set_OverrideCreator(ObjectConstructor`1<object> value);
    internal ObjectConstructor`1<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(ObjectConstructor`1<object> value);
    [CompilerGeneratedAttribute]
public ExtensionDataSetter get_ExtensionDataSetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataSetter(ExtensionDataSetter value);
    [CompilerGeneratedAttribute]
public ExtensionDataGetter get_ExtensionDataGetter();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataGetter(ExtensionDataGetter value);
    public Type get_ExtensionDataValueType();
    public void set_ExtensionDataValueType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<string, string> get_ExtensionDataNameResolver();
    [CompilerGeneratedAttribute]
public void set_ExtensionDataNameResolver(Func`2<string, string> value);
    internal bool get_HasRequiredOrDefaultValueProperties();
}
internal class Microsoft.Identity.Json.Serialization.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Serialization.JsonProperty : object {
    internal Nullable`1<Required> _required;
    internal bool _hasExplicitDefaultValue;
    private object _defaultValue;
    private bool _hasGeneratedDefaultValue;
    private string _propertyName;
    internal bool _skipPropertyNameEscape;
    private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlyingName>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueProvider <ValueProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IAttributeProvider <AttributeProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <Converter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NullValueHandling> <NullValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DefaultValueHandling> <DefaultValueHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ReferenceLoopHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ObjectCreationHandling> <ObjectCreationHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <TypeNameHandling>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldSerialize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <ShouldDeserialize>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Predicate`1<object> <GetIsSpecified>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <SetIsSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter <ItemConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ItemIsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeNameHandling> <ItemTypeNameHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReferenceLoopHandling> <ItemReferenceLoopHandling>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Type DeclaringType { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public string UnderlyingName { get; public set; }
    public IValueProvider ValueProvider { get; public set; }
    public IAttributeProvider AttributeProvider { get; public set; }
    public Type PropertyType { get; public set; }
    public JsonConverter Converter { get; public set; }
    [ObsoleteAttribute("MemberConverter is obsolete. Use Converter instead.")]
public JsonConverter MemberConverter { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    public object DefaultValue { get; public set; }
    public Required Required { get; public set; }
    public bool IsRequiredSpecified { get; }
    public Nullable`1<bool> IsReference { get; public set; }
    public Nullable`1<NullValueHandling> NullValueHandling { get; public set; }
    public Nullable`1<DefaultValueHandling> DefaultValueHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ReferenceLoopHandling { get; public set; }
    public Nullable`1<ObjectCreationHandling> ObjectCreationHandling { get; public set; }
    public Nullable`1<TypeNameHandling> TypeNameHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldSerialize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> ShouldDeserialize { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Predicate`1<object> GetIsSpecified { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> SetIsSpecified { get; public set; }
    public JsonConverter ItemConverter { get; public set; }
    public Nullable`1<bool> ItemIsReference { get; public set; }
    public Nullable`1<TypeNameHandling> ItemTypeNameHandling { get; public set; }
    public Nullable`1<ReferenceLoopHandling> ItemReferenceLoopHandling { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Type get_DeclaringType();
    [CompilerGeneratedAttribute]
public void set_DeclaringType(Type value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_UnderlyingName();
    [CompilerGeneratedAttribute]
public void set_UnderlyingName(string value);
    [CompilerGeneratedAttribute]
public IValueProvider get_ValueProvider();
    [CompilerGeneratedAttribute]
public void set_ValueProvider(IValueProvider value);
    [CompilerGeneratedAttribute]
public IAttributeProvider get_AttributeProvider();
    [CompilerGeneratedAttribute]
public void set_AttributeProvider(IAttributeProvider value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public JsonConverter get_Converter();
    [CompilerGeneratedAttribute]
public void set_Converter(JsonConverter value);
    public JsonConverter get_MemberConverter();
    public void set_MemberConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public object get_DefaultValue();
    public void set_DefaultValue(object value);
    internal object GetResolvedDefaultValue();
    public Required get_Required();
    public void set_Required(Required value);
    public bool get_IsRequiredSpecified();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsReference();
    [CompilerGeneratedAttribute]
public void set_IsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<NullValueHandling> get_NullValueHandling();
    [CompilerGeneratedAttribute]
public void set_NullValueHandling(Nullable`1<NullValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DefaultValueHandling> get_DefaultValueHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultValueHandling(Nullable`1<DefaultValueHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ObjectCreationHandling> get_ObjectCreationHandling();
    [CompilerGeneratedAttribute]
public void set_ObjectCreationHandling(Nullable`1<ObjectCreationHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_TypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_TypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldSerialize();
    [CompilerGeneratedAttribute]
public void set_ShouldSerialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
public void set_ShouldDeserialize(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Predicate`1<object> get_GetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_GetIsSpecified(Predicate`1<object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_SetIsSpecified();
    [CompilerGeneratedAttribute]
public void set_SetIsSpecified(Action`2<object, object> value);
    [NullableContextAttribute("0")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
public JsonConverter get_ItemConverter();
    [CompilerGeneratedAttribute]
public void set_ItemConverter(JsonConverter value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ItemIsReference();
    [CompilerGeneratedAttribute]
public void set_ItemIsReference(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TypeNameHandling> get_ItemTypeNameHandling();
    [CompilerGeneratedAttribute]
public void set_ItemTypeNameHandling(Nullable`1<TypeNameHandling> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReferenceLoopHandling> get_ItemReferenceLoopHandling();
    [CompilerGeneratedAttribute]
public void set_ItemReferenceLoopHandling(Nullable`1<ReferenceLoopHandling> value);
    [NullableContextAttribute("0")]
internal void WritePropertyName(JsonWriter writer);
}
internal class Microsoft.Identity.Json.Serialization.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValue(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class Microsoft.Identity.Json.Serialization.JsonSerializerInternalBase : object {
    [NullableAttribute("2")]
private ErrorContext _currentErrorContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BidirectionalDictionary`2<string, object> _mappings;
    internal JsonSerializer Serializer;
    [NullableAttribute("2")]
internal ITraceWriter TraceWriter;
    [NullableAttribute("2")]
protected JsonSerializerProxy InternalSerializer;
    internal BidirectionalDictionary`2<string, object> DefaultReferenceMappings { get; }
    protected JsonSerializerInternalBase(JsonSerializer serializer);
    internal BidirectionalDictionary`2<string, object> get_DefaultReferenceMappings();
    protected NullValueHandling ResolvedNullValueHandling(JsonObjectContract containerContract, JsonProperty property);
    private ErrorContext GetErrorContext(object currentObject, object member, string path, Exception error);
    protected void ClearErrorContext();
    [NullableContextAttribute("2")]
protected bool IsErrorHandled(object currentObject, JsonContract contract, object keyValue, IJsonLineInfo lineInfo, string path, Exception ex);
}
internal class Microsoft.Identity.Json.Serialization.JsonSerializerInternalReader : JsonSerializerInternalBase {
    public JsonSerializerInternalReader(JsonSerializer serializer);
    public void Populate(JsonReader reader, object target);
    [NullableContextAttribute("2")]
private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    [NullableContextAttribute("2")]
public object Deserialize(JsonReader reader, Type objectType, bool checkAdditionalContent);
    private JsonSerializerProxy GetInternalSerializer();
    [NullableContextAttribute("2")]
private JToken CreateJToken(JsonReader reader, JsonContract contract);
    private JToken CreateJObject(JsonReader reader);
    [NullableContextAttribute("2")]
private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [NullableContextAttribute("2")]
private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    [NullableContextAttribute("2")]
private JsonConverter GetConverter(JsonContract contract, JsonConverter memberConverter, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    [NullableContextAttribute("2")]
private bool ReadMetadataPropertiesToken(JTokenReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [NullableContextAttribute("2")]
private bool ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue, Object& newValue, String& id);
    [NullableContextAttribute("2")]
private void ResolveTypeName(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, string qualifiedTypeName);
    private JsonArrayContract EnsureArrayContract(JsonReader reader, Type objectType, JsonContract contract);
    [NullableContextAttribute("2")]
private object CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, object existingValue, string id);
    [NullableContextAttribute("2")]
private bool HasNoDefinedType(JsonContract contract);
    [NullableContextAttribute("2")]
private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private bool SetPropertyValue(JsonProperty property, JsonConverter propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target);
    [NullableContextAttribute("2")]
private bool CalculatePropertyDetails(JsonProperty property, JsonConverter& propertyConverter, JsonContainerContract containerContract, JsonProperty containerProperty, JsonReader reader, object target, Boolean& useExistingValue, Object& currentValue, JsonContract& propertyContract, Boolean& gottenCurrentValue, Boolean& ignoredValue);
    private void AddReference(JsonReader reader, string id, object value);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    [NullableContextAttribute("2")]
private bool ShouldSetPropertyValue(JsonProperty property, JsonObjectContract contract, object value);
    private IList CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator);
    private IDictionary CreateNewDictionary(JsonReader reader, JsonDictionaryContract contract, Boolean& createdFromNonDefaultCreator);
    private void OnDeserializing(JsonReader reader, JsonContract contract, object value);
    private void OnDeserialized(JsonReader reader, JsonContract contract, object value);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty, string id);
    private object PopulateMultidimensionalArray(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private void ThrowUnexpectedEndException(JsonReader reader, JsonContract contract, object currentObject, string message);
    private object PopulateList(IList list, JsonReader reader, JsonArrayContract contract, JsonProperty containerProperty, string id);
    private object CreateISerializable(JsonReader reader, JsonISerializableContract contract, JsonProperty member, string id);
    internal object CreateISerializableItem(JToken token, Type type, JsonISerializableContract contract, JsonProperty member);
    private object CreateDynamic(JsonReader reader, JsonDynamicContract contract, JsonProperty member, string id);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1<object> creator, string id);
    private object DeserializeConvertable(JsonConverter converter, JsonReader reader, Type objectType, object existingValue);
    private List`1<CreatorPropertyContext> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, string id, Boolean& createdFromNonDefaultCreator);
    private object PopulateObject(object newObject, JsonReader reader, JsonObjectContract contract, JsonProperty member, string id);
    private bool ShouldDeserialize(JsonReader reader, JsonProperty property, object target);
    private bool CheckPropertyName(JsonReader reader, string memberName);
    private void SetExtensionData(JsonObjectContract contract, JsonProperty member, JsonReader reader, string memberName, object o);
    private object ReadExtensionDataValue(JsonObjectContract contract, JsonProperty member, JsonReader reader);
    private void EndProcessProperty(object newObject, JsonReader reader, JsonObjectContract contract, int initialDepth, JsonProperty property, PropertyPresence presence, bool setDefaultValue);
    private void SetPropertyPresence(JsonReader reader, JsonProperty property, Dictionary`2<JsonProperty, PropertyPresence> requiredProperties);
    private void HandleError(JsonReader reader, bool readPastError, int initialDepth);
}
internal class Microsoft.Identity.Json.Serialization.JsonSerializerInternalWriter : JsonSerializerInternalBase {
    [NullableAttribute("2")]
private Type _rootType;
    private int _rootLevel;
    private List`1<object> _serializeStack;
    public JsonSerializerInternalWriter(JsonSerializer serializer);
    [NullableContextAttribute("2")]
public void Serialize(JsonWriter jsonWriter, object value, Type objectType);
    private JsonSerializerProxy GetInternalSerializer();
    [NullableContextAttribute("2")]
private JsonContract GetContractSafe(object value);
    private JsonContract GetContract(object value);
    private void SerializePrimitive(JsonWriter writer, object value, JsonPrimitiveContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private void SerializeValue(JsonWriter writer, object value, JsonContract valueContract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private Nullable`1<bool> ResolveIsReference(JsonContract contract, JsonProperty property, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteReference(object value, JsonProperty property, JsonContract valueContract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteProperty(object memberValue, JsonObjectContract containerContract, JsonProperty property);
    [NullableContextAttribute("2")]
private bool CheckForCircularReference(JsonWriter writer, object value, JsonProperty property, JsonContract contract, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void WriteReference(JsonWriter writer, object value);
    private string GetReference(JsonWriter writer, object value);
    internal static bool TryConvertToString(object value, Type type, String& s);
    private void SerializeString(JsonWriter writer, object value, JsonStringContract contract);
    private void OnSerializing(JsonWriter writer, JsonContract contract, object value);
    private void OnSerialized(JsonWriter writer, JsonContract contract, object value);
    private void SerializeObject(JsonWriter writer, object value, JsonObjectContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool CalculatePropertyValues(JsonWriter writer, object value, JsonContainerContract contract, JsonProperty member, JsonProperty property, JsonContract& memberContract, Object& memberValue);
    private void WriteObjectStart(JsonWriter writer, object value, JsonContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private bool HasCreatorParameter(JsonContainerContract contract, JsonProperty property);
    private void WriteReferenceIdProperty(JsonWriter writer, Type type, object value);
    private void WriteTypeProperty(JsonWriter writer, Type type);
    private bool HasFlag(DefaultValueHandling value, DefaultValueHandling flag);
    private bool HasFlag(PreserveReferencesHandling value, PreserveReferencesHandling flag);
    private bool HasFlag(TypeNameHandling value, TypeNameHandling flag);
    private void SerializeConvertable(JsonWriter writer, JsonConverter converter, object value, JsonContract contract, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeMultidimensionalArray(JsonWriter writer, Array values, JsonArrayContract contract, JsonProperty member, int initialDepth, Int32[] indices);
    private bool WriteStartArray(JsonWriter writer, object values, JsonArrayContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeISerializable(JsonWriter writer, ISerializable value, JsonISerializableContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private void SerializeDynamic(JsonWriter writer, IDynamicMetaObjectProvider value, JsonDynamicContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    [NullableContextAttribute("2")]
private bool ShouldWriteDynamicProperty(object memberValue);
    [NullableContextAttribute("2")]
private bool ShouldWriteType(TypeNameHandling typeNameHandlingFlag, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerProperty);
    private void SerializeDictionary(JsonWriter writer, IDictionary values, JsonDictionaryContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty);
    private string GetPropertyName(JsonWriter writer, object name, JsonContract contract, Boolean& escape);
    private void HandleError(JsonWriter writer, int initialDepth);
    private bool ShouldSerialize(JsonWriter writer, JsonProperty property, object target);
    private bool IsSpecified(JsonWriter writer, JsonProperty property, object target);
}
internal class Microsoft.Identity.Json.Serialization.JsonSerializerProxy : JsonSerializer {
    [NullableAttribute("2")]
private JsonSerializerInternalReader _serializerReader;
    [NullableAttribute("2")]
private JsonSerializerInternalWriter _serializerWriter;
    private JsonSerializer _serializer;
    [NullableAttribute("2")]
public IReferenceResolver ReferenceResolver { get; public set; }
    [NullableAttribute("2")]
public ITraceWriter TraceWriter { get; public set; }
    [NullableAttribute("2")]
public IEqualityComparer EqualityComparer { get; public set; }
    public JsonConverterCollection Converters { get; }
    public DefaultValueHandling DefaultValueHandling { get; public set; }
    public IContractResolver ContractResolver { get; public set; }
    public MissingMemberHandling MissingMemberHandling { get; public set; }
    public NullValueHandling NullValueHandling { get; public set; }
    public ObjectCreationHandling ObjectCreationHandling { get; public set; }
    public ReferenceLoopHandling ReferenceLoopHandling { get; public set; }
    public PreserveReferencesHandling PreserveReferencesHandling { get; public set; }
    public TypeNameHandling TypeNameHandling { get; public set; }
    public MetadataPropertyHandling MetadataPropertyHandling { get; public set; }
    [ObsoleteAttribute("TypeNameAssemblyFormat is obsolete. Use TypeNameAssemblyFormatHandling instead.")]
public FormatterAssemblyStyle TypeNameAssemblyFormat { get; public set; }
    public TypeNameAssemblyFormatHandling TypeNameAssemblyFormatHandling { get; public set; }
    public ConstructorHandling ConstructorHandling { get; public set; }
    [ObsoleteAttribute("Binder is obsolete. Use SerializationBinder instead.")]
public SerializationBinder Binder { get; public set; }
    public ISerializationBinder SerializationBinder { get; public set; }
    public StreamingContext Context { get; public set; }
    public Formatting Formatting { get; public set; }
    public DateFormatHandling DateFormatHandling { get; public set; }
    public DateTimeZoneHandling DateTimeZoneHandling { get; public set; }
    public DateParseHandling DateParseHandling { get; public set; }
    public FloatFormatHandling FloatFormatHandling { get; public set; }
    public FloatParseHandling FloatParseHandling { get; public set; }
    public StringEscapeHandling StringEscapeHandling { get; public set; }
    public string DateFormatString { get; public set; }
    public CultureInfo Culture { get; public set; }
    public Nullable`1<int> MaxDepth { get; public set; }
    public bool CheckAdditionalContent { get; public set; }
    public JsonSerializerProxy(JsonSerializerInternalReader serializerReader);
    public JsonSerializerProxy(JsonSerializerInternalWriter serializerWriter);
    public virtual void add_Error(EventHandler`1<ErrorEventArgs> value);
    public virtual void remove_Error(EventHandler`1<ErrorEventArgs> value);
    [NullableContextAttribute("2")]
public virtual IReferenceResolver get_ReferenceResolver();
    [NullableContextAttribute("2")]
public virtual void set_ReferenceResolver(IReferenceResolver value);
    [NullableContextAttribute("2")]
public virtual ITraceWriter get_TraceWriter();
    [NullableContextAttribute("2")]
public virtual void set_TraceWriter(ITraceWriter value);
    [NullableContextAttribute("2")]
public virtual IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
public virtual void set_EqualityComparer(IEqualityComparer value);
    public virtual JsonConverterCollection get_Converters();
    public virtual DefaultValueHandling get_DefaultValueHandling();
    public virtual void set_DefaultValueHandling(DefaultValueHandling value);
    public virtual IContractResolver get_ContractResolver();
    public virtual void set_ContractResolver(IContractResolver value);
    public virtual MissingMemberHandling get_MissingMemberHandling();
    public virtual void set_MissingMemberHandling(MissingMemberHandling value);
    public virtual NullValueHandling get_NullValueHandling();
    public virtual void set_NullValueHandling(NullValueHandling value);
    public virtual ObjectCreationHandling get_ObjectCreationHandling();
    public virtual void set_ObjectCreationHandling(ObjectCreationHandling value);
    public virtual ReferenceLoopHandling get_ReferenceLoopHandling();
    public virtual void set_ReferenceLoopHandling(ReferenceLoopHandling value);
    public virtual PreserveReferencesHandling get_PreserveReferencesHandling();
    public virtual void set_PreserveReferencesHandling(PreserveReferencesHandling value);
    public virtual TypeNameHandling get_TypeNameHandling();
    public virtual void set_TypeNameHandling(TypeNameHandling value);
    public virtual MetadataPropertyHandling get_MetadataPropertyHandling();
    public virtual void set_MetadataPropertyHandling(MetadataPropertyHandling value);
    public virtual FormatterAssemblyStyle get_TypeNameAssemblyFormat();
    public virtual void set_TypeNameAssemblyFormat(FormatterAssemblyStyle value);
    public virtual TypeNameAssemblyFormatHandling get_TypeNameAssemblyFormatHandling();
    public virtual void set_TypeNameAssemblyFormatHandling(TypeNameAssemblyFormatHandling value);
    public virtual ConstructorHandling get_ConstructorHandling();
    public virtual void set_ConstructorHandling(ConstructorHandling value);
    public virtual SerializationBinder get_Binder();
    public virtual void set_Binder(SerializationBinder value);
    public virtual ISerializationBinder get_SerializationBinder();
    public virtual void set_SerializationBinder(ISerializationBinder value);
    public virtual StreamingContext get_Context();
    public virtual void set_Context(StreamingContext value);
    public virtual Formatting get_Formatting();
    public virtual void set_Formatting(Formatting value);
    public virtual DateFormatHandling get_DateFormatHandling();
    public virtual void set_DateFormatHandling(DateFormatHandling value);
    public virtual DateTimeZoneHandling get_DateTimeZoneHandling();
    public virtual void set_DateTimeZoneHandling(DateTimeZoneHandling value);
    public virtual DateParseHandling get_DateParseHandling();
    public virtual void set_DateParseHandling(DateParseHandling value);
    public virtual FloatFormatHandling get_FloatFormatHandling();
    public virtual void set_FloatFormatHandling(FloatFormatHandling value);
    public virtual FloatParseHandling get_FloatParseHandling();
    public virtual void set_FloatParseHandling(FloatParseHandling value);
    public virtual StringEscapeHandling get_StringEscapeHandling();
    public virtual void set_StringEscapeHandling(StringEscapeHandling value);
    public virtual string get_DateFormatString();
    public virtual void set_DateFormatString(string value);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual Nullable`1<int> get_MaxDepth();
    public virtual void set_MaxDepth(Nullable`1<int> value);
    public virtual bool get_CheckAdditionalContent();
    public virtual void set_CheckAdditionalContent(bool value);
    internal JsonSerializerInternalBase GetInternalSerializer();
    [NullableContextAttribute("2")]
internal virtual object DeserializeInternal(JsonReader reader, Type objectType);
    internal virtual void PopulateInternal(JsonReader reader, object target);
    [NullableContextAttribute("2")]
internal virtual void SerializeInternal(JsonWriter jsonWriter, object value, Type rootType);
}
internal class Microsoft.Identity.Json.Serialization.JsonStringContract : JsonPrimitiveContract {
    public JsonStringContract(Type underlyingType);
}
internal static class Microsoft.Identity.Json.Serialization.JsonTypeReflector : object {
    private static Nullable`1<bool> _dynamicCodeGeneration;
    private static Nullable`1<bool> _fullyTrusted;
    public static string IdPropertyName;
    public static string RefPropertyName;
    public static string TypePropertyName;
    public static string ValuePropertyName;
    public static string ArrayValuesPropertyName;
    public static string ShouldSerializePrefix;
    public static string SpecifiedPostfix;
    public static string ConcurrentDictionaryTypeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Func`2<Object[], object>> CreatorCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<Type, Type> AssociatedMetadataTypesCache;
    [NullableAttribute("2")]
private static ReflectionObject _metadataTypeAttributeReflectionObject;
    public static bool DynamicCodeGeneration { get; }
    public static bool FullyTrusted { get; }
    public static ReflectionDelegateFactory ReflectionDelegateFactory { get; }
    private static JsonTypeReflector();
    public static T GetCachedAttribute(object attributeProvider);
    public static DataContractAttribute GetDataContractAttribute(Type type);
    public static DataMemberAttribute GetDataMemberAttribute(MemberInfo memberInfo);
    public static MemberSerialization GetObjectMemberSerialization(Type objectType, bool ignoreSerializableAttribute);
    public static JsonConverter GetJsonConverter(object attributeProvider);
    public static JsonConverter CreateJsonConverterInstance(Type converterType, Object[] args);
    public static NamingStrategy CreateNamingStrategyInstance(Type namingStrategyType, Object[] args);
    public static NamingStrategy GetContainerNamingStrategy(JsonContainerAttribute containerAttribute);
    private static Func`2<Object[], object> GetCreator(Type type);
    private static Type GetAssociatedMetadataType(Type type);
    private static Type GetAssociateMetadataTypeFromAttribute(Type type);
    private static T GetAttribute(Type type);
    private static T GetAttribute(MemberInfo memberInfo);
    public static bool IsNonSerializable(object provider);
    public static bool IsSerializable(object provider);
    public static T GetAttribute(object provider);
    public static bool get_DynamicCodeGeneration();
    public static bool get_FullyTrusted();
    public static ReflectionDelegateFactory get_ReflectionDelegateFactory();
}
internal class Microsoft.Identity.Json.Serialization.KebabCaseNamingStrategy : NamingStrategy {
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public KebabCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    protected virtual string ResolvePropertyName(string name);
}
internal class Microsoft.Identity.Json.Serialization.MemoryTraceWriter : object {
    private Queue`1<string> _traceMessages;
    private object _lock;
    [CompilerGeneratedAttribute]
private TraceLevel <LevelFilter>k__BackingField;
    public TraceLevel LevelFilter { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TraceLevel get_LevelFilter();
    [CompilerGeneratedAttribute]
public void set_LevelFilter(TraceLevel value);
    public sealed virtual void Trace(TraceLevel level, string message, Exception ex);
    public IEnumerable`1<string> GetTraceMessages();
    public virtual string ToString();
}
internal abstract class Microsoft.Identity.Json.Serialization.NamingStrategy : object {
    [CompilerGeneratedAttribute]
private bool <ProcessDictionaryKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessExtensionDataNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverrideSpecifiedNames>k__BackingField;
    public bool ProcessDictionaryKeys { get; public set; }
    public bool ProcessExtensionDataNames { get; public set; }
    public bool OverrideSpecifiedNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ProcessDictionaryKeys();
    [CompilerGeneratedAttribute]
public void set_ProcessDictionaryKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_ProcessExtensionDataNames();
    [CompilerGeneratedAttribute]
public void set_ProcessExtensionDataNames(bool value);
    [CompilerGeneratedAttribute]
public bool get_OverrideSpecifiedNames();
    [CompilerGeneratedAttribute]
public void set_OverrideSpecifiedNames(bool value);
    public virtual string GetPropertyName(string name, bool hasSpecifiedName);
    public virtual string GetExtensionDataName(string name);
    public virtual string GetDictionaryKey(string key);
    protected abstract virtual string ResolvePropertyName(string name);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
protected bool Equals(NamingStrategy other);
}
internal class Microsoft.Identity.Json.Serialization.ObjectConstructor`1 : MulticastDelegate {
    public ObjectConstructor`1(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("64")]
internal class Microsoft.Identity.Json.Serialization.OnErrorAttribute : Attribute {
}
internal class Microsoft.Identity.Json.Serialization.ReflectionAttributeProvider : object {
    private object _attributeProvider;
    public ReflectionAttributeProvider(object attributeProvider);
    public sealed virtual IList`1<Attribute> GetAttributes(bool inherit);
    public sealed virtual IList`1<Attribute> GetAttributes(Type attributeType, bool inherit);
}
internal class Microsoft.Identity.Json.Serialization.ReflectionValueProvider : object {
    private MemberInfo _memberInfo;
    public ReflectionValueProvider(MemberInfo memberInfo);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
internal class Microsoft.Identity.Json.Serialization.SerializationBinderAdapter : object {
    public SerializationBinder SerializationBinder;
    public SerializationBinderAdapter(SerializationBinder serializationBinder);
    public sealed virtual Type BindToType(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public sealed virtual void BindToName(Type serializedType, String& assemblyName, String& typeName);
}
internal class Microsoft.Identity.Json.Serialization.SerializationCallback : MulticastDelegate {
    public SerializationCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Identity.Json.Serialization.SerializationErrorCallback : MulticastDelegate {
    public SerializationErrorCallback(object object, IntPtr method);
    public virtual void Invoke(object o, StreamingContext context, ErrorContext errorContext);
    public virtual IAsyncResult BeginInvoke(object o, StreamingContext context, ErrorContext errorContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Identity.Json.Serialization.SnakeCaseNamingStrategy : NamingStrategy {
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames);
    public SnakeCaseNamingStrategy(bool processDictionaryKeys, bool overrideSpecifiedNames, bool processExtensionDataNames);
    protected virtual string ResolvePropertyName(string name);
}
internal class Microsoft.Identity.Json.Serialization.TraceJsonReader : JsonReader {
    private JsonReader _innerReader;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public int Depth { get; }
    public string Path { get; }
    public char QuoteChar { get; protected internal set; }
    public JsonToken TokenType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    [NullableAttribute("2")]
public Type ValueType { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LineNumber { get; }
    private int Microsoft.Identity.Json.IJsonLineInfo.LinePosition { get; }
    public TraceJsonReader(JsonReader innerReader);
    public string GetDeserializedJsonMessage();
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    [NullableContextAttribute("2")]
public virtual string ReadAsString();
    [NullableContextAttribute("2")]
public virtual Byte[] ReadAsBytes();
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    public virtual Nullable`1<bool> ReadAsBoolean();
    public virtual Nullable`1<DateTime> ReadAsDateTime();
    public virtual Nullable`1<DateTimeOffset> ReadAsDateTimeOffset();
    public void WriteCurrentToken();
    public virtual int get_Depth();
    public virtual string get_Path();
    public virtual char get_QuoteChar();
    protected internal virtual void set_QuoteChar(char value);
    public virtual JsonToken get_TokenType();
    [NullableContextAttribute("2")]
public virtual object get_Value();
    [NullableContextAttribute("2")]
public virtual Type get_ValueType();
    public virtual void Close();
    private sealed virtual override bool Microsoft.Identity.Json.IJsonLineInfo.HasLineInfo();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LineNumber();
    private sealed virtual override int Microsoft.Identity.Json.IJsonLineInfo.get_LinePosition();
}
internal class Microsoft.Identity.Json.Serialization.TraceJsonWriter : JsonWriter {
    private JsonWriter _innerWriter;
    private JsonTextWriter _textWriter;
    private StringWriter _sw;
    public TraceJsonWriter(JsonWriter innerWriter);
    public string GetSerializedJsonMessage();
    public virtual void WriteValue(decimal value);
    public virtual void WriteValue(Nullable`1<decimal> value);
    public virtual void WriteValue(bool value);
    public virtual void WriteValue(Nullable`1<bool> value);
    public virtual void WriteValue(byte value);
    public virtual void WriteValue(Nullable`1<byte> value);
    public virtual void WriteValue(char value);
    public virtual void WriteValue(Nullable`1<char> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(Nullable`1<DateTime> value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(Nullable`1<DateTimeOffset> value);
    public virtual void WriteValue(double value);
    public virtual void WriteValue(Nullable`1<double> value);
    public virtual void WriteUndefined();
    public virtual void WriteNull();
    public virtual void WriteValue(float value);
    public virtual void WriteValue(Nullable`1<float> value);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(Nullable`1<Guid> value);
    public virtual void WriteValue(int value);
    public virtual void WriteValue(Nullable`1<int> value);
    public virtual void WriteValue(long value);
    public virtual void WriteValue(Nullable`1<long> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(object value);
    public virtual void WriteValue(sbyte value);
    public virtual void WriteValue(Nullable`1<sbyte> value);
    public virtual void WriteValue(short value);
    public virtual void WriteValue(Nullable`1<short> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Nullable`1<TimeSpan> value);
    public virtual void WriteValue(UInt32 value);
    public virtual void WriteValue(Nullable`1<UInt32> value);
    public virtual void WriteValue(ulong value);
    public virtual void WriteValue(Nullable`1<ulong> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Uri value);
    public virtual void WriteValue(ushort value);
    public virtual void WriteValue(Nullable`1<ushort> value);
    public virtual void WriteWhitespace(string ws);
    [NullableContextAttribute("2")]
public virtual void WriteComment(string text);
    public virtual void WriteStartArray();
    public virtual void WriteEndArray();
    public virtual void WriteStartConstructor(string name);
    public virtual void WriteEndConstructor();
    public virtual void WritePropertyName(string name);
    public virtual void WritePropertyName(string name, bool escape);
    public virtual void WriteStartObject();
    public virtual void WriteEndObject();
    [NullableContextAttribute("2")]
public virtual void WriteRawValue(string json);
    [NullableContextAttribute("2")]
public virtual void WriteRaw(string json);
    public virtual void Close();
    public virtual void Flush();
}
internal enum Microsoft.Identity.Json.StringEscapeHandling : Enum {
    public int value__;
    public static StringEscapeHandling Default;
    public static StringEscapeHandling EscapeNonAscii;
    public static StringEscapeHandling EscapeHtml;
}
internal enum Microsoft.Identity.Json.TraceLevel : Enum {
    public int value__;
    public static TraceLevel Off;
    public static TraceLevel Error;
    public static TraceLevel Warning;
    public static TraceLevel Info;
    public static TraceLevel Verbose;
}
internal enum Microsoft.Identity.Json.TypeNameAssemblyFormatHandling : Enum {
    public int value__;
    public static TypeNameAssemblyFormatHandling Simple;
    public static TypeNameAssemblyFormatHandling Full;
}
[FlagsAttribute]
internal enum Microsoft.Identity.Json.TypeNameHandling : Enum {
    public int value__;
    public static TypeNameHandling None;
    public static TypeNameHandling Objects;
    public static TypeNameHandling Arrays;
    public static TypeNameHandling All;
    public static TypeNameHandling Auto;
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.AsyncUtils : object {
    public static Task`1<bool> False;
    public static Task`1<bool> True;
    internal static Task CompletedTask;
    private static AsyncUtils();
    [ExtensionAttribute]
internal static Task`1<bool> ToAsync(bool value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Task CancelIfRequestedAsync(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> CancelIfRequestedAsync(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> FromCanceled(CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, char value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, string value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task WriteAsync(TextWriter writer, Char[] value, int start, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<int> ReadAsync(TextReader reader, Char[] buffer, int index, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsCompletedSucessfully(Task task);
}
internal class Microsoft.Identity.Json.Utilities.Base64Encoder : object {
    private static int Base64LineSize;
    private static int LineSizeInBytes;
    private Char[] _charsLine;
    private TextWriter _writer;
    [NullableAttribute("2")]
private Byte[] _leftOverBytes;
    private int _leftOverBytesCount;
    public Base64Encoder(TextWriter writer);
    private void ValidateEncode(Byte[] buffer, int index, int count);
    public void Encode(Byte[] buffer, int index, int count);
    private void StoreLeftOverBytes(Byte[] buffer, int index, Int32& count);
    private bool FulfillFromLeftover(Byte[] buffer, int index, Int32& count);
    public void Flush();
    private void WriteChars(Char[] chars, int index, int count);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Utilities.Base64Encoder/<EncodeAsync>d__13")]
public Task EncodeAsync(Byte[] buffer, int index, int count, CancellationToken cancellationToken);
    private Task WriteCharsAsync(Char[] chars, int index, int count, CancellationToken cancellationToken);
    public Task FlushAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Json.Utilities.BidirectionalDictionary`2 : object {
    private IDictionary`2<TFirst, TSecond> _firstToSecond;
    private IDictionary`2<TSecond, TFirst> _secondToFirst;
    private string _duplicateFirstErrorMessage;
    private string _duplicateSecondErrorMessage;
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer);
    public BidirectionalDictionary`2(IEqualityComparer`1<TFirst> firstEqualityComparer, IEqualityComparer`1<TSecond> secondEqualityComparer, string duplicateFirstErrorMessage, string duplicateSecondErrorMessage);
    public void Set(TFirst first, TSecond second);
    public bool TryGetByFirst(TFirst first, TSecond& second);
    public bool TryGetBySecond(TSecond second, TFirst& first);
}
internal static class Microsoft.Identity.Json.Utilities.BufferUtils : object {
    public static Char[] RentBuffer(IArrayPool`1<char> bufferPool, int minSize);
    [NullableContextAttribute("2")]
public static void ReturnBuffer(IArrayPool`1<char> bufferPool, Char[] buffer);
    [NullableContextAttribute("2")]
public static Char[] EnsureBufferSize(IArrayPool`1<char> bufferPool, int size, Char[] buffer);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.CollectionUtils : object {
    public static bool IsNullOrEmpty(ICollection`1<T> collection);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> initial, IEnumerable`1<T> collection);
    public static bool IsDictionaryType(Type type);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value);
    [ExtensionAttribute]
public static bool AddDistinct(IList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool ContainsValue(IEnumerable`1<TSource> source, TSource value, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static bool AddRangeDistinct(IList`1<T> list, IEnumerable`1<T> values, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(List`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOfReference(List`1<T> list, T item);
    private static IList`1<int> GetDimensions(IList values, int dimensionsCount);
    private static void CopyFromJaggedToMultidimensionalArray(IList values, Array multidimensionalArray, Int32[] indices);
    private static object JaggedArrayGetValue(IList values, Int32[] indices);
    public static Array ToMultidimensionalArray(IList values, Type type, int rank);
    public static T[] ArrayEmpty();
}
internal class Microsoft.Identity.Json.Utilities.CollectionWrapper`1 : object {
    [NullableAttribute("2")]
private IList _list;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<T> _genericCollection;
    [NullableAttribute("2")]
private object _syncRoot;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingCollection { get; }
    public CollectionWrapper`1(IList list);
    public CollectionWrapper`1(ICollection`1<T> list);
    public virtual void Add(T item);
    public virtual void Clear();
    public virtual bool Contains(T item);
    public virtual void CopyTo(T[] array, int arrayIndex);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool Remove(T item);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void VerifyValueType(object value);
    private static bool IsCompatibleObject(object value);
    public sealed virtual object get_UnderlyingCollection();
}
internal static class Microsoft.Identity.Json.Utilities.ConvertUtils : object {
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static TypeInformation[] PrimitiveTypeCodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, Type>, Func`2<object, object>> CastConverters;
    private static ConvertUtils();
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static TypeInformation GetTypeInformation(IConvertible convertable);
    public static bool IsConvertible(Type t);
    public static TimeSpan ParseTimeSpan(string input);
    private static Func`2<object, object> CreateCastConverter(StructMultiKey`2<Type, Type> t);
    public static object Convert(object initialValue, CultureInfo culture, Type targetType);
    private static bool TryConvert(object initialValue, CultureInfo culture, Type targetType, Object& value);
    private static ConvertResult TryConvertInternal(object initialValue, CultureInfo culture, Type targetType, Object& value);
    public static object ConvertOrCast(object initialValue, CultureInfo culture, Type targetType);
    private static object EnsureTypeAssignable(object value, Type initialType, Type targetType);
    public static bool VersionTryParse(string input, Version& result);
    public static bool IsInteger(object value);
    public static ParseResult Int32TryParse(Char[] chars, int start, int length, Int32& value);
    public static ParseResult Int64TryParse(Char[] chars, int start, int length, Int64& value);
    public static ParseResult DecimalTryParse(Char[] chars, int start, int length, Decimal& value);
    public static bool TryConvertGuid(string s, Guid& g);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class Microsoft.Identity.Json.Utilities.Creator`1 : MulticastDelegate {
    public Creator`1(object object, IntPtr method);
    public virtual T Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Identity.Json.Utilities.DateTimeParser : ValueType {
    public int Year;
    public int Month;
    public int Day;
    public int Hour;
    public int Minute;
    public int Second;
    public int Fraction;
    public int ZoneHour;
    public int ZoneMinute;
    public ParserTimeZone Zone;
    private Char[] _text;
    private int _end;
    private static Int32[] Power10;
    private static int Lzyyyy;
    private static int Lzyyyy_;
    private static int Lzyyyy_MM;
    private static int Lzyyyy_MM_;
    private static int Lzyyyy_MM_dd;
    private static int Lzyyyy_MM_ddT;
    private static int LzHH;
    private static int LzHH_;
    private static int LzHH_mm;
    private static int LzHH_mm_;
    private static int LzHH_mm_ss;
    private static int Lz_;
    private static int Lz_zz;
    private static short MaxFractionDigits;
    private static DateTimeParser();
    public bool Parse(Char[] text, int startIndex, int length);
    private bool ParseDate(int start);
    private bool ParseTimeAndZoneAndWhitespace(int start);
    private bool ParseTime(Int32& start);
    private bool ParseZone(int start);
    private bool Parse4Digit(int start, Int32& num);
    private bool Parse2Digit(int start, Int32& num);
    private bool ParseChar(int start, char ch);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.DateTimeUtils : object {
    internal static long InitialJavaScriptDateTicks;
    private static string IsoDateFormat;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysPer4Years;
    private static int DaysPerYear;
    private static long TicksPerDay;
    private static Int32[] DaysToMonth365;
    private static Int32[] DaysToMonth366;
    private static DateTimeUtils();
    [ExtensionAttribute]
public static TimeSpan GetUtcOffset(DateTime d);
    public static XmlDateTimeSerializationMode ToSerializationMode(DateTimeKind kind);
    internal static DateTime EnsureDateTime(DateTime value, DateTimeZoneHandling timeZone);
    private static DateTime SwitchToLocalTime(DateTime value);
    private static DateTime SwitchToUtcTime(DateTime value);
    private static long ToUniversalTicks(DateTime dateTime);
    private static long ToUniversalTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, TimeSpan offset);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime);
    internal static long ConvertDateTimeToJavaScriptTicks(DateTime dateTime, bool convertToUtc);
    private static long UniversalTicksToJavaScriptTicks(long universalTicks);
    internal static DateTime ConvertJavaScriptTicksToDateTime(long javaScriptTicks);
    internal static bool TryParseDateTimeIso(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    internal static bool TryParseDateTimeOffsetIso(StringReference text, DateTimeOffset& dt);
    private static DateTime CreateDateTime(DateTimeParser dateTimeParser);
    internal static bool TryParseDateTime(StringReference s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTime(string s, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    internal static bool TryParseDateTimeOffset(StringReference s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    internal static bool TryParseDateTimeOffset(string s, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryParseMicrosoftDate(StringReference text, Int64& ticks, TimeSpan& offset, DateTimeKind& kind);
    private static bool TryParseDateTimeMicrosoft(StringReference text, DateTimeZoneHandling dateTimeZoneHandling, DateTime& dt);
    private static bool TryParseDateTimeExact(string text, DateTimeZoneHandling dateTimeZoneHandling, string dateFormatString, CultureInfo culture, DateTime& dt);
    private static bool TryParseDateTimeOffsetMicrosoft(StringReference text, DateTimeOffset& dt);
    private static bool TryParseDateTimeOffsetExact(string text, string dateFormatString, CultureInfo culture, DateTimeOffset& dt);
    private static bool TryReadOffset(StringReference offsetText, int startIndex, TimeSpan& offset);
    internal static void WriteDateTimeString(TextWriter writer, DateTime value, DateFormatHandling format, string formatString, CultureInfo culture);
    internal static int WriteDateTimeString(Char[] chars, int start, DateTime value, Nullable`1<TimeSpan> offset, DateTimeKind kind, DateFormatHandling format);
    internal static int WriteDefaultIsoDate(Char[] chars, int start, DateTime dt);
    private static void CopyIntToCharArray(Char[] chars, int start, int value, int digits);
    internal static int WriteDateTimeOffset(Char[] chars, int start, TimeSpan offset, DateFormatHandling format);
    internal static void WriteDateTimeOffsetString(TextWriter writer, DateTimeOffset value, DateFormatHandling format, string formatString, CultureInfo culture);
    private static void GetDateValues(DateTime td, Int32& year, Int32& month, Int32& day);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Utilities.DictionaryWrapper`2 : object {
    [NullableAttribute("2")]
private IDictionary _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<TKey, TValue> _genericDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyDictionary`2<TKey, TValue> _readOnlyDictionary;
    [NullableAttribute("2")]
private object _syncRoot;
    internal IDictionary`2<TKey, TValue> GenericDictionary { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public object UnderlyingDictionary { get; }
    public DictionaryWrapper`2(IDictionary dictionary);
    public DictionaryWrapper`2(IDictionary`2<TKey, TValue> dictionary);
    public DictionaryWrapper`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
    internal IDictionary`2<TKey, TValue> get_GenericDictionary();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual void Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual object get_UnderlyingDictionary();
}
internal class Microsoft.Identity.Json.Utilities.DynamicProxy`1 : object {
    public virtual IEnumerable`1<string> GetDynamicMemberNames(T instance);
    public virtual bool TryBinaryOperation(T instance, BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(T instance, ConvertBinder binder, Object& result);
    public virtual bool TryCreateInstance(T instance, CreateInstanceBinder binder, Object[] args, Object& result);
    public virtual bool TryDeleteIndex(T instance, DeleteIndexBinder binder, Object[] indexes);
    public virtual bool TryDeleteMember(T instance, DeleteMemberBinder binder);
    public virtual bool TryGetIndex(T instance, GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(T instance, GetMemberBinder binder, Object& result);
    public virtual bool TryInvoke(T instance, InvokeBinder binder, Object[] args, Object& result);
    public virtual bool TryInvokeMember(T instance, InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TrySetIndex(T instance, SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(T instance, SetMemberBinder binder, object value);
    public virtual bool TryUnaryOperation(T instance, UnaryOperationBinder binder, Object& result);
}
internal class Microsoft.Identity.Json.Utilities.DynamicProxyMetaObject`1 : DynamicMetaObject {
    private DynamicProxy`1<T> _proxy;
    private static Expression[] NoArgs { get; }
    internal DynamicProxyMetaObject`1(Expression expression, T value, DynamicProxy`1<T> proxy);
    private bool IsOverridden(string method);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteMember(DeleteMemberBinder binder);
    public virtual DynamicMetaObject BindConvert(ConvertBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindBinaryOperation(BinaryOperationBinder binder, DynamicMetaObject arg);
    public virtual DynamicMetaObject BindUnaryOperation(UnaryOperationBinder binder);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindDeleteIndex(DeleteIndexBinder binder, DynamicMetaObject[] indexes);
    private static Expression[] get_NoArgs();
    private static IEnumerable`1<Expression> GetArgs(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args);
    private static Expression[] GetArgArray(DynamicMetaObject[] args, DynamicMetaObject value);
    private static ConstantExpression Constant(DynamicMetaObjectBinder binder);
    private DynamicMetaObject CallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback, Fallback<T> fallbackInvoke);
    private DynamicMetaObject BuildCallMethodWithResult(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, DynamicMetaObject fallbackResult, Fallback<T> fallbackInvoke);
    private DynamicMetaObject CallMethodReturnLast(string methodName, DynamicMetaObjectBinder binder, IEnumerable`1<Expression> args, Fallback<T> fallback);
    private DynamicMetaObject CallMethodNoResult(string methodName, DynamicMetaObjectBinder binder, Expression[] args, Fallback<T> fallback);
    private BindingRestrictions GetRestrictions();
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.DynamicUtils : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDynamicMemberNames(IDynamicMetaObjectProvider dynamicProvider);
}
internal class Microsoft.Identity.Json.Utilities.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    internal EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
internal static class Microsoft.Identity.Json.Utilities.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static string EnumSeparatorString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ThreadSafeStore`2<StructMultiKey`2<Type, NamingStrategy>, EnumInfo> ValuesAndNamesPerEnum;
    private static CamelCaseNamingStrategy _camelCaseNamingStrategy;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(StructMultiKey`2<Type, NamingStrategy> key);
    public static IList`1<T> GetFlagsValues(T value);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    public static bool TryToString(Type enumType, object value, NamingStrategy namingStrategy, String& name);
    private static string InternalFlagsFormat(EnumInfo entry, ulong result);
    public static EnumInfo GetEnumValuesAndNames(Type enumType);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, NamingStrategy namingStrategy, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
internal class Microsoft.Identity.Json.Utilities.ExpressionReflectionDelegateFactory : ReflectionDelegateFactory {
    private static ExpressionReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static ExpressionReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    private Expression BuildMethodCall(MethodBase method, Type type, ParameterExpression targetParameterExpression, ParameterExpression argsParameterExpression);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
    private Expression EnsureCastExpression(Expression expression, Type targetType, bool allowWidening);
}
internal class Microsoft.Identity.Json.Utilities.FSharpFunction : object {
    [NullableAttribute("2")]
private object _instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MethodCall`2<object, object> _invoker;
    [NullableContextAttribute("2")]
public FSharpFunction(object instance, MethodCall`2<object, object> invoker);
    public object Invoke(Object[] args);
}
internal class Microsoft.Identity.Json.Utilities.FSharpUtils : object {
    private static object Lock;
    [NullableAttribute("2")]
private static FSharpUtils _instance;
    private MethodInfo _ofSeq;
    private Type _mapType;
    [CompilerGeneratedAttribute]
private Assembly <FSharpCoreAssembly>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <IsUnion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCases>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionTagReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionReader>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <PreComputeUnionConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoDeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoName>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetUnionCaseInfoTag>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MethodCall`2<object, object> <GetUnionCaseInfoFields>k__BackingField;
    public static string FSharpSetTypeName;
    public static string FSharpListTypeName;
    public static string FSharpMapTypeName;
    public static FSharpUtils Instance { get; }
    public Assembly FSharpCoreAssembly { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> IsUnion { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCases { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionTagReader { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionReader { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> PreComputeUnionConstructor { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoDeclaringType { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoName { get; private set; }
    public Func`2<object, object> GetUnionCaseInfoTag { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public MethodCall`2<object, object> GetUnionCaseInfoFields { get; private set; }
    private FSharpUtils(Assembly fsharpCoreAssembly);
    private static FSharpUtils();
    public static FSharpUtils get_Instance();
    [CompilerGeneratedAttribute]
public Assembly get_FSharpCoreAssembly();
    [CompilerGeneratedAttribute]
private void set_FSharpCoreAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_IsUnion();
    [CompilerGeneratedAttribute]
private void set_IsUnion(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCases();
    [CompilerGeneratedAttribute]
private void set_GetUnionCases(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionTagReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionTagReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionReader();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionReader(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_PreComputeUnionConstructor();
    [CompilerGeneratedAttribute]
private void set_PreComputeUnionConstructor(MethodCall`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoDeclaringType();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoDeclaringType(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoName();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoName(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetUnionCaseInfoTag();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoTag(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public MethodCall`2<object, object> get_GetUnionCaseInfoFields();
    [CompilerGeneratedAttribute]
private void set_GetUnionCaseInfoFields(MethodCall`2<object, object> value);
    public static void EnsureInitialized(Assembly fsharpCoreAssembly);
    private static MethodInfo GetMethodWithNonPublicFallback(Type type, string methodName, BindingFlags bindingFlags);
    private static MethodCall`2<object, object> CreateFSharpFuncCall(Type type, string methodName);
    public ObjectConstructor`1<object> CreateSeq(Type t);
    public ObjectConstructor`1<object> CreateMap(Type keyType, Type valueType);
    public ObjectConstructor`1<object> BuildMapCreator();
}
internal static class Microsoft.Identity.Json.Utilities.ImmutableCollectionsUtils : object {
    private static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableQueueGenericInterfaceTypeName;
    private static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableSetGenericInterfaceTypeName;
    private static string ImmutableArrayTypeName;
    private static string ImmutableArrayGenericTypeName;
    private static string ImmutableListTypeName;
    private static string ImmutableListGenericTypeName;
    private static string ImmutableQueueTypeName;
    private static string ImmutableQueueGenericTypeName;
    private static string ImmutableStackTypeName;
    private static string ImmutableStackGenericTypeName;
    private static string ImmutableSortedSetTypeName;
    private static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetTypeName;
    private static string ImmutableHashSetGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> ArrayContractImmutableCollectionDefinitions;
    private static string ImmutableDictionaryGenericInterfaceTypeName;
    private static string ImmutableDictionaryTypeName;
    private static string ImmutableDictionaryGenericTypeName;
    private static string ImmutableSortedDictionaryTypeName;
    private static string ImmutableSortedDictionaryGenericTypeName;
    private static IList`1<ImmutableCollectionTypeInfo> DictionaryContractImmutableCollectionDefinitions;
    private static ImmutableCollectionsUtils();
    internal static bool TryBuildImmutableForArrayContract(Type underlyingType, Type collectionItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
    internal static bool TryBuildImmutableForDictionaryContract(Type underlyingType, Type keyItemType, Type valueItemType, Type& createdType, ObjectConstructor`1& parameterizedCreator);
}
internal interface Microsoft.Identity.Json.Utilities.IWrappedCollection {
    public object UnderlyingCollection { get; }
    public abstract virtual object get_UnderlyingCollection();
}
internal interface Microsoft.Identity.Json.Utilities.IWrappedDictionary {
    public object UnderlyingDictionary { get; }
    public abstract virtual object get_UnderlyingDictionary();
}
internal static class Microsoft.Identity.Json.Utilities.JavaScriptUtils : object {
    internal static Boolean[] SingleQuoteCharEscapeFlags;
    internal static Boolean[] DoubleQuoteCharEscapeFlags;
    internal static Boolean[] HtmlCharEscapeFlags;
    private static int UnicodeTextLength;
    private static string EscapedUnicodeText;
    private static JavaScriptUtils();
    public static Boolean[] GetCharEscapeFlags(StringEscapeHandling stringEscapeHandling, char quoteChar);
    public static bool ShouldEscapeJavaScriptString(string s, Boolean[] charEscapeFlags);
    [NullableContextAttribute("2")]
public static void WriteEscapedJavaScriptString(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, IArrayPool`1<char> bufferPool, Char[]& writeBuffer);
    public static string ToEscapedJavaScriptString(string value, char delimiter, bool appendDelimiters, StringEscapeHandling stringEscapeHandling);
    private static int FirstCharToEscape(string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling);
    public static Task WriteEscapedJavaScriptStringAsync(TextWriter writer, string s, char delimiter, bool appendDelimiters, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Utilities.JavaScriptUtils/<WriteEscapedJavaScriptStringWithDelimitersAsync>d__13")]
private static Task WriteEscapedJavaScriptStringWithDelimitersAsync(Task task, TextWriter writer, string s, char delimiter, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Utilities.JavaScriptUtils/<WriteCharAsync>d__14")]
public static Task WriteCharAsync(Task task, TextWriter writer, char c, CancellationToken cancellationToken);
    private static Task WriteEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Json.Utilities.JavaScriptUtils/<WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync>d__16")]
private static Task WriteDefinitelyEscapedJavaScriptStringWithoutDelimitersAsync(TextWriter writer, string s, int lastWritePosition, Boolean[] charEscapeFlags, StringEscapeHandling stringEscapeHandling, JsonTextWriter client, Char[] writeBuffer, CancellationToken cancellationToken);
    public static bool TryGetDateFromConstructorJson(JsonReader reader, DateTime& dateTime, String& errorMessage);
    private static bool TryGetDateConstructorValue(JsonReader reader, Nullable`1& integer, String& errorMessage);
}
internal static class Microsoft.Identity.Json.Utilities.JsonTokenUtils : object {
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
}
internal class Microsoft.Identity.Json.Utilities.LateBoundReflectionDelegateFactory : ReflectionDelegateFactory {
    private static LateBoundReflectionDelegateFactory _instance;
    internal static ReflectionDelegateFactory Instance { get; }
    private static LateBoundReflectionDelegateFactory();
    internal static ReflectionDelegateFactory get_Instance();
    public virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public virtual Func`1<T> CreateDefaultConstructor(Type type);
    public virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
internal static class Microsoft.Identity.Json.Utilities.MathUtils : object {
    public static int IntLength(ulong i);
    public static char IntToHex(int n);
    public static Nullable`1<int> Min(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<int> Max(Nullable`1<int> val1, Nullable`1<int> val2);
    public static Nullable`1<double> Max(Nullable`1<double> val1, Nullable`1<double> val2);
    public static bool ApproxEquals(double d1, double d2);
}
internal class Microsoft.Identity.Json.Utilities.MethodCall`2 : MulticastDelegate {
    public MethodCall`2(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Identity.Json.Utilities.MiscellaneousUtils : object {
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [NullableContextAttribute("2")]
public static bool ValueEquals(object objA, object objB);
    public static ArgumentOutOfRangeException CreateArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static string GetPrefix(string qualifiedName);
    public static string GetLocalName(string qualifiedName);
    public static void GetQualifiedNameParts(string qualifiedName, String& prefix, String& localName);
    internal static RegexOptions GetRegexOptions(string optionsText);
}
internal class Microsoft.Identity.Json.Utilities.NoThrowExpressionVisitor : ExpressionVisitor {
    internal static object ErrorResult;
    private static NoThrowExpressionVisitor();
    protected virtual Expression VisitConditional(ConditionalExpression node);
}
internal class Microsoft.Identity.Json.Utilities.NoThrowGetBinderMember : GetMemberBinder {
    private GetMemberBinder _innerBinder;
    public NoThrowGetBinderMember(GetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.Identity.Json.Utilities.NoThrowSetBinderMember : SetMemberBinder {
    private SetMemberBinder _innerBinder;
    public NoThrowSetBinderMember(SetMemberBinder innerBinder);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal enum Microsoft.Identity.Json.Utilities.ParseResult : Enum {
    public int value__;
    public static ParseResult None;
    public static ParseResult Success;
    public static ParseResult Overflow;
    public static ParseResult Invalid;
}
internal enum Microsoft.Identity.Json.Utilities.ParserTimeZone : Enum {
    public int value__;
    public static ParserTimeZone Unspecified;
    public static ParserTimeZone Utc;
    public static ParserTimeZone LocalWestOfUtc;
    public static ParserTimeZone LocalEastOfUtc;
}
internal enum Microsoft.Identity.Json.Utilities.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
internal abstract class Microsoft.Identity.Json.Utilities.ReflectionDelegateFactory : object {
    public Func`2<T, object> CreateGet(MemberInfo memberInfo);
    public Action`2<T, object> CreateSet(MemberInfo memberInfo);
    public abstract virtual MethodCall`2<T, object> CreateMethodCall(MethodBase method);
    public abstract virtual ObjectConstructor`1<object> CreateParameterizedConstructor(MethodBase method);
    public abstract virtual Func`1<T> CreateDefaultConstructor(Type type);
    public abstract virtual Func`2<T, object> CreateGet(PropertyInfo propertyInfo);
    public abstract virtual Func`2<T, object> CreateGet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(FieldInfo fieldInfo);
    public abstract virtual Action`2<T, object> CreateSet(PropertyInfo propertyInfo);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Utilities.ReflectionMember : object {
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<object, object> <Getter>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    public Type MemberType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Getter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Setter { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_Getter();
    [CompilerGeneratedAttribute]
public void set_Getter(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
public void set_Setter(Action`2<object, object> value);
}
internal class Microsoft.Identity.Json.Utilities.ReflectionObject : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ObjectConstructor`1<object> <Creator>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, ReflectionMember> <Members>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ObjectConstructor`1<object> Creator { get; }
    public IDictionary`2<string, ReflectionMember> Members { get; }
    private ReflectionObject(ObjectConstructor`1<object> creator);
    [CompilerGeneratedAttribute]
public ObjectConstructor`1<object> get_Creator();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, ReflectionMember> get_Members();
    public object GetValue(object target, string member);
    public void SetValue(object target, string member, object value);
    public Type GetType(string member);
    public static ReflectionObject Create(Type t, String[] memberNames);
    public static ReflectionObject Create(Type t, MethodBase creator, String[] memberNames);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.ReflectionUtils : object {
    public static Type[] EmptyTypes;
    private static ReflectionUtils();
    [ExtensionAttribute]
public static bool IsVirtual(PropertyInfo propertyInfo);
    [ExtensionAttribute]
public static MethodInfo GetBaseDefinition(PropertyInfo propertyInfo);
    public static bool IsPublic(PropertyInfo property);
    [NullableContextAttribute("2")]
public static Type GetObjectType(object v);
    public static string GetTypeName(Type t, TypeNameAssemblyFormatHandling assemblyFormat, ISerializationBinder binder);
    private static string GetFullyQualifiedTypeName(Type t, ISerializationBinder binder);
    private static string RemoveAssemblyDetails(string fullyQualifiedTypeName);
    public static bool HasDefaultConstructor(Type t, bool nonPublic);
    public static ConstructorInfo GetDefaultConstructor(Type t);
    public static ConstructorInfo GetDefaultConstructor(Type t, bool nonPublic);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static Type EnsureNotNullableType(Type t);
    public static Type EnsureNotByRefType(Type t);
    public static bool IsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition);
    public static bool InheritsGenericDefinition(Type type, Type genericClassDefinition, Type& implementingType);
    private static bool InheritsGenericDefinitionInternal(Type currentType, Type genericClassDefinition, Type& implementingType);
    public static Type GetCollectionItemType(Type type);
    [NullableContextAttribute("2")]
public static void GetDictionaryKeyValueTypes(Type dictionaryType, Type& keyType, Type& valueType);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsByRefLikeType(Type type);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    public static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    public static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static T GetAttribute(object attributeProvider);
    public static T GetAttribute(object attributeProvider, bool inherit);
    public static T[] GetAttributes(object attributeProvider, bool inherit);
    public static Attribute[] GetAttributes(object attributeProvider, Type attributeType, bool inherit);
    public static StructMultiKey`2<string, string> SplitFullyQualifiedTypeName(string fullyQualifiedTypeName);
    private static Nullable`1<int> GetAssemblyDelimiterIndex(string fullyQualifiedTypeName);
    public static MemberInfo GetMemberInfoFromType(Type targetType, MemberInfo memberInfo);
    public static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    [ExtensionAttribute]
public static BindingFlags RemoveFlag(BindingFlags bindingAttr, BindingFlags flag);
    private static void GetChildPrivateProperties(IList`1<PropertyInfo> initialProperties, Type targetType, BindingFlags bindingAttr);
    public static bool IsMethodOverridden(Type currentType, Type methodDeclaringType, string method);
    public static object GetDefaultValue(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Identity.Json.Utilities.StringBuffer : ValueType {
    private Char[] _buffer;
    private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(IArrayPool`1<char> bufferPool, int initalSize);
    [NullableContextAttribute("0")]
private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(IArrayPool`1<char> bufferPool, char value);
    [NullableContextAttribute("0")]
public void Append(IArrayPool`1<char> bufferPool, Char[] buffer, int startIndex, int count);
    public void Clear(IArrayPool`1<char> bufferPool);
    private void EnsureSize(IArrayPool`1<char> bufferPool, int appendLength);
    [NullableContextAttribute("0")]
public virtual string ToString();
    [NullableContextAttribute("0")]
public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Identity.Json.Utilities.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public char Item { get; }
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public char get_Item(int i);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.StringReferenceExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(StringReference s, char c, int startIndex, int length);
    [ExtensionAttribute]
public static bool StartsWith(StringReference s, string text);
    [ExtensionAttribute]
public static bool EndsWith(StringReference s, string text);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.StringUtils : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1);
    [ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string FormatWith(string format, IFormatProvider provider, object arg0, object arg1, object arg2, object arg3);
    [ExtensionAttribute]
private static string FormatWith(string format, IFormatProvider provider, Object[] args);
    public static bool IsWhiteSpace(string s);
    public static StringWriter CreateStringWriter(int capacity);
    public static void ToCharAsUnicode(char c, Char[] buffer);
    [ExtensionAttribute]
public static TSource ForgivingCaseSensitiveFind(IEnumerable`1<TSource> source, Func`2<TSource, string> valueSelector, string testValue);
    public static string ToCamelCase(string s);
    private static char ToLower(char c);
    public static string ToSnakeCase(string s);
    public static string ToKebabCase(string s);
    private static string ToSeparatedCase(string s, char separator);
    public static bool IsHighSurrogate(char c);
    public static bool IsLowSurrogate(char c);
    [ExtensionAttribute]
public static bool StartsWith(string source, char value);
    [ExtensionAttribute]
public static bool EndsWith(string source, char value);
    [ExtensionAttribute]
public static string Trim(string s, int start, int length);
}
[IsReadOnlyAttribute]
internal class Microsoft.Identity.Json.Utilities.StructMultiKey`2 : ValueType {
    public T1 Value1;
    public T2 Value2;
    public StructMultiKey`2(T1 v1, T2 v2);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StructMultiKey`2<T1, T2> other);
}
internal class Microsoft.Identity.Json.Utilities.ThreadSafeStore`2 : object {
    private ConcurrentDictionary`2<TKey, TValue> _concurrentStore;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Json.Utilities.TypeExtensions : object {
    [ExtensionAttribute]
public static MethodInfo Method(Delegate d);
    [ExtensionAttribute]
public static MemberTypes MemberType(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool ContainsGenericParameters(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsSealed(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsVisible(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces, Type& match);
    [ExtensionAttribute]
public static bool AssignableToTypeName(Type type, string fullTypeName, bool searchInterfaces);
    [ExtensionAttribute]
public static bool ImplementInterface(Type type, Type interfaceType);
}
internal class Microsoft.Identity.Json.Utilities.TypeInformation : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    public Type Type { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public TypeInformation(Type type, PrimitiveTypeCode typeCode);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public PrimitiveTypeCode get_TypeCode();
}
internal static class Microsoft.Identity.Json.Utilities.ValidationUtils : object {
    public static void ArgumentNotNull(object value, string parameterName);
}
internal enum Microsoft.Identity.Json.WriteState : Enum {
    public int value__;
    public static WriteState Error;
    public static WriteState Closed;
    public static WriteState Object;
    public static WriteState Array;
    public static WriteState Constructor;
    public static WriteState Property;
    public static WriteState Start;
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("10688")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
