[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[BestFriendAttribute]
[AttributeUsageAttribute("5628")]
internal class Microsoft.ML.BestFriendAttribute : Attribute {
}
[BestFriendAttribute]
internal interface Microsoft.ML.Command.ICommand {
    public abstract virtual void Run();
}
[BestFriendAttribute]
internal class Microsoft.ML.Command.SignatureCommand : MulticastDelegate {
    public SignatureCommand(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("256")]
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.ArgumentAttribute : Attribute {
    private string _shortName;
    private string _name;
    [CompilerGeneratedAttribute]
private ArgumentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpText>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hide>k__BackingField;
    [CompilerGeneratedAttribute]
private double <SortOrder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInputFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Purpose>k__BackingField;
    [CompilerGeneratedAttribute]
private VisibilityType <Visibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SignatureType>k__BackingField;
    public ArgumentType Type { get; }
    public string ShortName { get; public set; }
    public string HelpText { get; public set; }
    public bool Hide { get; public set; }
    public double SortOrder { get; public set; }
    public string NullName { get; public set; }
    public bool IsInputFileName { get; public set; }
    public string Purpose { get; public set; }
    public VisibilityType Visibility { get; public set; }
    public string Name { get; public set; }
    public String[] Aliases { get; }
    public bool IsRequired { get; }
    public Type SignatureType { get; public set; }
    public ArgumentAttribute(ArgumentType type);
    [CompilerGeneratedAttribute]
public ArgumentType get_Type();
    public string get_ShortName();
    public void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_HelpText();
    [CompilerGeneratedAttribute]
public void set_HelpText(string value);
    [CompilerGeneratedAttribute]
public bool get_Hide();
    [CompilerGeneratedAttribute]
public void set_Hide(bool value);
    [CompilerGeneratedAttribute]
public double get_SortOrder();
    [CompilerGeneratedAttribute]
public void set_SortOrder(double value);
    [CompilerGeneratedAttribute]
public string get_NullName();
    [CompilerGeneratedAttribute]
public void set_NullName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsInputFileName();
    [CompilerGeneratedAttribute]
public void set_IsInputFileName(bool value);
    [CompilerGeneratedAttribute]
public string get_Purpose();
    [CompilerGeneratedAttribute]
public void set_Purpose(string value);
    [CompilerGeneratedAttribute]
public VisibilityType get_Visibility();
    [CompilerGeneratedAttribute]
public void set_Visibility(VisibilityType value);
    public string get_Name();
    public void set_Name(string value);
    public String[] get_Aliases();
    public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public Type get_SignatureType();
    [CompilerGeneratedAttribute]
public void set_SignatureType(Type value);
}
[FlagsAttribute]
[BestFriendAttribute]
internal enum Microsoft.ML.CommandLine.ArgumentType : Enum {
    public int value__;
    public static ArgumentType Required;
    public static ArgumentType Unique;
    public static ArgumentType Multiple;
    public static ArgumentType AtMostOnce;
    public static ArgumentType LastOccurrenceWins;
    public static ArgumentType MultipleUnique;
}
internal class Microsoft.ML.CommandLine.CharCursor : object {
    private string _text;
    private int _ichLim;
    private int _ichCur;
    private char _chCur;
    public bool Eof { get; }
    public int IchCur { get; }
    public char ChCur { get; }
    public CharCursor(string text);
    public CharCursor(string text, int min, int lim);
    public bool get_Eof();
    public int get_IchCur();
    public char get_ChCur();
    public string GetRest();
    public char ChNext();
    public char ChPeek(int dich);
}
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.CmdLexer : object {
    private CharCursor _curs;
    private bool _escapes;
    private bool _error;
    public bool Error { get; }
    public CmdLexer(CharCursor curs, bool escapes);
    public bool get_Error();
    public void GetToken(StringBuilder bldr);
    public void SkipWhiteSpace();
    private void GatherCurlyGroup(StringBuilder bldr);
    internal void GatherCurlyContents(StringBuilder bldr);
    private void GatherSlash(StringBuilder bldr, bool reduce);
    private void GatherString(StringBuilder bldr, bool reduce);
    public static string UnquoteValue(string str);
}
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.CmdParser : object {
    private static int SpaceBeforeParam;
    private ErrorReporter _reporter;
    private IHost _host;
    private CmdParser(IHostEnvironment env);
    private CmdParser(IHostEnvironment env, ErrorReporter reporter);
    public static bool ParseArguments(IHostEnvironment env, string settings, object destination);
    public static bool ParseArguments(IHostEnvironment env, string settings, object destination, Type destinationType, ErrorReporter reporter);
    private static bool ParseArguments(string settings, object destination, CmdParser parser);
    public static bool ParseArguments(IHostEnvironment env, string settings, object destination, ErrorReporter reporter);
    public static bool ParseArguments(IHostEnvironment env, string settings, object destination, String& helpText);
    public static bool ParseArguments(IHostEnvironment env, string settings, object destination, ErrorReporter reporter, String& helpText);
    public static string CombineSettings(String[] settings);
    public static string GetSettings(IHostEnvironment env, object values, object defaults, SettingsFlags flags);
    public static IEnumerable`1<KeyValuePair`2<string, string>> GetSettingPairs(IHostEnvironment env, object values, object defaults, SettingsFlags flags);
    public static IEnumerable`1<KeyValuePair`2<string, string>> GetSettingPairs(IHostEnvironment env, object values, SettingsFlags flags);
    public static bool IsNumericType(Type type);
    private void Report(string str);
    private void Report(string fmt, Object[] args);
    public static string ArgumentsUsage(IHostEnvironment env, Type type, object defaults, bool showRsp, Nullable`1<int> columns);
    public static ArgInfo GetArgInfo(Type type, object defaults);
    private static string ArgCase(string name);
    private static ArgumentInfo GetArgumentInfo(Type type, object defaults);
    private static ArgumentAttribute GetAttribute(FieldInfo field);
    private void ReportUnrecognizedArgument(string argument);
    private bool ParseArgumentList(ArgumentInfo info, String[] strs, object destination, ArgValue[] values);
    private bool TryGetOptionValue(ArgumentInfo info, string str, Argument& arg, String& option, String& tag, String& value);
    private static bool IsCurlyGroup(string str);
    private bool Parse(ArgumentInfo info, String[] strs, object destination);
    private static string GetSettingsCore(IHostEnvironment env, ArgumentInfo info, object values, SettingsFlags flags);
    private static void AppendCustomItem(IHostEnvironment env, ArgumentInfo info, object values, SettingsFlags flags, StringBuilder sb);
    [IteratorStateMachineAttribute("Microsoft.ML.CommandLine.CmdParser/<GetSettingPairsCore>d__30")]
private IEnumerable`1<KeyValuePair`2<string, string>> GetSettingPairsCore(IHostEnvironment env, ArgumentInfo info, object values, SettingsFlags flags);
    private string GetUsageString(IHostEnvironment env, ArgumentInfo info, bool showRsp, Nullable`1<int> columns);
    private static void AddNewLine(string newLine, StringBuilder builder, Int32& currentColumn);
    private ArgumentHelpStrings[] GetAllHelpStrings(IHostEnvironment env, ArgumentInfo info, bool showRsp);
    private ArgumentHelpStrings GetHelpStrings(IHostEnvironment env, Argument arg);
    private bool LexFileArguments(string fileName, String[]& arguments);
    public static string TrimExePath(string args, String& exe);
    public static bool TryGetFirstToken(string text, String& token, String& rest);
    public static bool LexString(string text, String[]& arguments);
    private static bool IsNullableType(Type type);
    private static bool IsValidItemType(Type type);
    public static ICommandLineComponentFactory CreateComponentFactory(Type factoryType, Type signatureType, string settings);
    private static void ParseComponentStrings(string str, String& kind, String& args);
}
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.CmdQuoter : object {
    private string _str;
    private StringBuilder _sb;
    private int _ich;
    private CmdQuoter(string str, StringBuilder sb);
    public static bool NeedsQuoting(string str);
    public static bool NeedsQuoting(StringBuilder sb, int ich);
    public static bool QuoteValue(string str, StringBuilder sb, bool force);
    private static bool QuoteValueCore(string str, StringBuilder sb, bool force);
    private static bool TryNoQuoting(string str, StringBuilder sb);
    private static bool TryNaiveQuoting(string str, StringBuilder sb);
    private void QuoteValueCore();
    private void HandleSlash();
}
[AttributeUsageAttribute("256")]
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.DefaultArgumentAttribute : ArgumentAttribute {
    public DefaultArgumentAttribute(ArgumentType type);
}
[AttributeUsageAttribute("256")]
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.EnumValueDisplayAttribute : Attribute {
    public string Name;
    public EnumValueDisplayAttribute(string name);
}
internal class Microsoft.ML.CommandLine.ErrorReporter : MulticastDelegate {
    public ErrorReporter(object object, IntPtr method);
    public virtual void Invoke(string message);
    public virtual IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[AttributeUsageAttribute("256")]
[BestFriendAttribute]
internal class Microsoft.ML.CommandLine.HideEnumValueAttribute : Attribute {
}
[BestFriendAttribute]
internal interface Microsoft.ML.CommandLine.ICommandLineComponentFactory {
    public Type SignatureType { get; }
    public string Name { get; }
    public abstract virtual Type get_SignatureType();
    public abstract virtual string get_Name();
    public abstract virtual string GetSettingsString();
}
[FlagsAttribute]
[BestFriendAttribute]
internal enum Microsoft.ML.CommandLine.SettingsFlags : Enum {
    public int value__;
    public static SettingsFlags None;
    public static SettingsFlags ShortNames;
    public static SettingsFlags NoSlashes;
    public static SettingsFlags NoUnparse;
    public static SettingsFlags Default;
}
[BestFriendAttribute]
internal static class Microsoft.ML.CommandLine.SpecialPurpose : object {
    public static string ColumnSelector;
    public static string MultilineText;
    public static string ColumnName;
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.AnnotationBuilderExtensions : object {
    [ExtensionAttribute]
public static void AddSlotNames(Builder builder, int size, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> getter);
    [ExtensionAttribute]
public static void AddKeyValues(Builder builder, int size, PrimitiveDataViewType valueType, ValueGetter`1<VBuffer`1<TValue>> getter);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.AnnotationUtils : object {
    private static KeyDataViewType modreq(System.Runtime.CompilerServices.IsVolatile) _scoreColumnSetIdType;
    public static KeyDataViewType ScoreColumnSetIdType { get; }
    public static Exception ExceptGetAnnotation();
    [ExtensionAttribute]
public static Exception ExceptGetAnnotation(IExceptionContext ctx);
    [ExtensionAttribute]
public static void Marshal(AnnotationGetter`1<THave> getter, int col, TNeed& dst);
    public static VectorDataViewType GetNamesType(int size);
    public static VectorDataViewType GetCategoricalType(int rangeCount);
    public static KeyDataViewType get_ScoreColumnSetIdType();
    public static KeyValuePair`2<string, DataViewType> GetSlotNamesPair(int size);
    public static KeyValuePair`2<string, DataViewType> GetKeyNamesPair(int size);
    [ExtensionAttribute]
public static KeyValuePair`2<string, DataViewType> GetPair(DataViewType type, string kind);
    [ExtensionAttribute]
public static IEnumerable`1<T> Prepend(IEnumerable`1<T> tail, T[] head);
    [ExtensionAttribute]
public static UInt32 GetMaxAnnotationKind(DataViewSchema schema, Int32& colMax, string annotationKind, Func`3<DataViewSchema, int, bool> filterFunc);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.AnnotationUtils/<GetColumnSet>d__16")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetColumnSet(DataViewSchema schema, string annotationKind, UInt32 value);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.AnnotationUtils/<GetColumnSet>d__17")]
[ExtensionAttribute]
public static IEnumerable`1<int> GetColumnSet(DataViewSchema schema, string annotationKind, string value);
    [ExtensionAttribute]
public static bool HasSlotNames(Column column, int vectorSize);
    public static void GetSlotNames(RoleMappedSchema schema, ColumnRole role, int vectorSize, VBuffer`1& slotNames);
    [ExtensionAttribute]
public static bool NeedsSlotNames(Column col);
    [ExtensionAttribute]
public static bool IsNormalized(Column column);
    [ExtensionAttribute]
public static bool HasSlotNames(Column col);
    [ExtensionAttribute]
public static bool TryGetAnnotation(DataViewSchema schema, PrimitiveDataViewType type, string kind, int col, T& value);
    public static bool TryGetCategoricalFeatureIndices(DataViewSchema schema, int colIndex, Int32[]& categoricalFeatures);
    public static IEnumerable`1<Column> GetTrainerOutputAnnotation(bool isNormalized);
    public static IEnumerable`1<Column> AnnotationsForMulticlassScoreColumn(Nullable`1<Column> labelColumn);
    [BestFriendAttribute]
internal static DataViewRow AnnotationsAsRow(Annotations annotations);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ColumnTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsStandardScalar(DataViewType columnType);
    [ExtensionAttribute]
public static ulong GetKeyCount(DataViewType columnType);
    [ExtensionAttribute]
public static int GetKeyCountAsInt32(DataViewType columnType, IExceptionContext ectx);
    [ExtensionAttribute]
public static DataViewType GetItemType(DataViewType columnType);
    [ExtensionAttribute]
public static int GetVectorSize(DataViewType columnType);
    [ExtensionAttribute]
public static int GetValueCount(DataViewType columnType);
    [ExtensionAttribute]
public static bool IsKnownSizeVector(DataViewType columnType);
    [ExtensionAttribute]
public static InternalDataKind GetRawKind(DataViewType columnType);
    [ExtensionAttribute]
public static bool SameSizeAndItemType(DataViewType columnType, DataViewType other);
    public static PrimitiveDataViewType PrimitiveTypeFromType(Type type);
    public static PrimitiveDataViewType PrimitiveTypeFromKind(InternalDataKind kind);
    public static NumberDataViewType NumberTypeFromType(Type type);
    private static NumberDataViewType NumberTypeFromKind(InternalDataKind kind);
}
public enum Microsoft.ML.Data.DataKind : Enum {
    public byte value__;
    public static DataKind SByte;
    public static DataKind Byte;
    public static DataKind Int16;
    public static DataKind UInt16;
    public static DataKind Int32;
    public static DataKind UInt32;
    public static DataKind Int64;
    public static DataKind UInt64;
    public static DataKind Single;
    public static DataKind Double;
    public static DataKind String;
    public static DataKind Boolean;
    public static DataKind TimeSpan;
    public static DataKind DateTime;
    public static DataKind DateTimeOffset;
}
public interface Microsoft.ML.Data.IFileHandle {
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public abstract virtual bool get_CanWrite();
    public abstract virtual bool get_CanRead();
    public abstract virtual Stream CreateWriteStream();
    public abstract virtual Stream OpenReadStream();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.InPredicate`1 : MulticastDelegate {
    public InPredicate`1(object object, IntPtr method);
    public virtual bool Invoke(T& modreq(System.Runtime.InteropServices.InAttribute) value);
    public virtual IAsyncResult BeginInvoke(T& modreq(System.Runtime.InteropServices.InAttribute) value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(T& modreq(System.Runtime.InteropServices.InAttribute) value, IAsyncResult result);
}
[BestFriendAttribute]
internal enum Microsoft.ML.Data.InternalDataKind : Enum {
    public byte value__;
    public static InternalDataKind I1;
    public static InternalDataKind U1;
    public static InternalDataKind I2;
    public static InternalDataKind U2;
    public static InternalDataKind I4;
    public static InternalDataKind U4;
    public static InternalDataKind I8;
    public static InternalDataKind U8;
    public static InternalDataKind R4;
    public static InternalDataKind R8;
    public static InternalDataKind Num;
    public static InternalDataKind TX;
    public static InternalDataKind TXT;
    public static InternalDataKind Text;
    public static InternalDataKind BL;
    public static InternalDataKind Bool;
    public static InternalDataKind TS;
    public static InternalDataKind TimeSpan;
    public static InternalDataKind DT;
    public static InternalDataKind DateTime;
    public static InternalDataKind DZ;
    public static InternalDataKind DateTimeZone;
    public static InternalDataKind UG;
    public static InternalDataKind U16;
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.InternalDataKindExtensions : object {
    public static InternalDataKind KindMin;
    public static InternalDataKind KindLim;
    public static int KindCount;
    [ExtensionAttribute]
public static int ToIndex(InternalDataKind kind);
    public static InternalDataKind FromIndex(int index);
    [ExtensionAttribute]
public static InternalDataKind ToInternalDataKind(DataKind dataKind);
    [ExtensionAttribute]
public static DataKind ToDataKind(InternalDataKind kind);
    [ExtensionAttribute]
public static ulong ToMaxInt(InternalDataKind kind);
    [ExtensionAttribute]
public static ulong ToMaxInt(Type type);
    [ExtensionAttribute]
public static long ToMinInt(InternalDataKind kind);
    [ExtensionAttribute]
public static Type ToType(InternalDataKind kind);
    [ExtensionAttribute]
public static bool TryGetDataKind(Type type, InternalDataKind& kind);
    [ExtensionAttribute]
public static string GetString(InternalDataKind kind);
}
public interface Microsoft.ML.Data.IRowToRowMapper {
    public DataViewSchema InputSchema { get; }
    public DataViewSchema OutputSchema { get; }
    public abstract virtual DataViewSchema get_InputSchema();
    public abstract virtual DataViewSchema get_OutputSchema();
    public abstract virtual IEnumerable`1<Column> GetDependencies(IEnumerable`1<Column> dependingColumns);
    public abstract virtual DataViewRow GetRow(DataViewRow input, IEnumerable`1<Column> activeColumns);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ISchemaBindableMapper {
    public abstract virtual ISchemaBoundMapper Bind(IHostEnvironment env, RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ISchemaBoundMapper {
    public RoleMappedSchema InputRoleMappedSchema { get; }
    public DataViewSchema OutputSchema { get; }
    public ISchemaBindableMapper Bindable { get; }
    public abstract virtual RoleMappedSchema get_InputRoleMappedSchema();
    public abstract virtual DataViewSchema get_OutputSchema();
    public abstract virtual ISchemaBindableMapper get_Bindable();
    public abstract virtual IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetInputColumnRoles();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ISchemaBoundRowMapper {
    public DataViewSchema InputSchema { get; }
    public abstract virtual DataViewSchema get_InputSchema();
    public abstract virtual IEnumerable`1<Column> GetDependenciesForNewColumns(IEnumerable`1<Column> dependingColumns);
    public abstract virtual DataViewRow GetRow(DataViewRow input, IEnumerable`1<Column> activeColumns);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IValueMapper {
    public DataViewType InputType { get; }
    public DataViewType OutputType { get; }
    public abstract virtual DataViewType get_InputType();
    public abstract virtual DataViewType get_OutputType();
    public abstract virtual ValueMapper`2<TSrc, TDst> GetMapper();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IValueMapperDist {
    public DataViewType DistType { get; }
    public abstract virtual DataViewType get_DistType();
    public abstract virtual ValueMapper`3<TSrc, TDst, TDist> GetMapper();
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.KeyTypeExtensions : object {
    [ExtensionAttribute]
public static int GetCountAsInt32(KeyDataViewType key, IExceptionContext ectx);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.LinkedRootCursorBase : RootCursorBase {
    [CompilerGeneratedAttribute]
private DataViewRowCursor <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private DataViewRowCursor <Root>k__BackingField;
    private bool _disposed;
    protected DataViewRowCursor Input { get; }
    protected DataViewRowCursor Root { get; }
    protected LinkedRootCursorBase(IChannelProvider provider, DataViewRowCursor input);
    [CompilerGeneratedAttribute]
protected DataViewRowCursor get_Input();
    [CompilerGeneratedAttribute]
protected DataViewRowCursor get_Root();
    protected virtual void Dispose(bool disposing);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.LinkedRowFilterCursorBase : LinkedRowRootCursorBase {
    public long Batch { get; }
    protected LinkedRowFilterCursorBase(IChannelProvider provider, DataViewRowCursor input, DataViewSchema schema, Boolean[] active);
    public virtual long get_Batch();
    public virtual ValueGetter`1<DataViewRowId> GetIdGetter();
    protected virtual bool MoveNextCore();
    protected abstract virtual bool Accept();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.LinkedRowRootCursorBase : LinkedRootCursorBase {
    private Boolean[] _active;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    public DataViewSchema Schema { get; }
    protected LinkedRowRootCursorBase(IChannelProvider provider, DataViewRowCursor input, DataViewSchema schema, Boolean[] active);
    [CompilerGeneratedAttribute]
public sealed virtual DataViewSchema get_Schema();
    public sealed virtual bool IsColumnActive(Column column);
    public virtual ValueGetter`1<TValue> GetGetter(Column column);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ReadOnlyMemoryUtils : object {
    public static bool EqualsStr(string s, ReadOnlyMemory`1<char> memory);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ReadOnlyMemoryUtils/<Split>d__1")]
public static IEnumerable`1<ReadOnlyMemory`1<char>> Split(ReadOnlyMemory`1<char> memory, Char[] separators);
    public static bool SplitOne(ReadOnlyMemory`1<char> memory, char separator, ReadOnlyMemory`1& left, ReadOnlyMemory`1& right);
    public static bool SplitOne(ReadOnlyMemory`1<char> memory, Char[] separators, ReadOnlyMemory`1& left, ReadOnlyMemory`1& right);
    public static ReadOnlyMemory`1<char> TrimSpaces(ReadOnlyMemory`1<char> memory);
    public static ReadOnlyMemory`1<char> TrimWhiteSpace(ReadOnlyMemory`1<char> memory);
    public static ReadOnlyMemory`1<char> TrimEndWhiteSpace(ReadOnlyMemory`1<char> memory);
    public static void AddLowerCaseToStringBuilder(ReadOnlySpan`1<char> span, StringBuilder sb);
    [ExtensionAttribute]
public static StringBuilder AppendMemory(StringBuilder sb, ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static StringBuilder AppendSpan(StringBuilder sb, ReadOnlySpan`1<char> span);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RoleMappedData : object {
    [CompilerGeneratedAttribute]
private IDataView <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private RoleMappedSchema <Schema>k__BackingField;
    public IDataView Data { get; }
    public RoleMappedSchema Schema { get; }
    private RoleMappedData(IDataView data, RoleMappedSchema schema);
    public RoleMappedData(IDataView data, bool opt, KeyValuePair`2[] roles);
    public RoleMappedData(IDataView data, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> roles, bool opt);
    public RoleMappedData(IDataView data, string label, string feature, string group, string weight, string name, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> custom, bool opt);
    [CompilerGeneratedAttribute]
public IDataView get_Data();
    [CompilerGeneratedAttribute]
public RoleMappedSchema get_Schema();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RoleMappedSchema : object {
    private static string FeatureString;
    private static string LabelString;
    private static string GroupString;
    private static string WeightString;
    private static string NameString;
    private static string FeatureContributionsString;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Column> <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Column> <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Column> <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Column> <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Column> <Name>k__BackingField;
    private Dictionary`2<string, IReadOnlyList`1<Column>> _map;
    public DataViewSchema Schema { get; }
    public Nullable`1<Column> Feature { get; }
    public Nullable`1<Column> Label { get; }
    public Nullable`1<Column> Group { get; }
    public Nullable`1<Column> Weight { get; }
    public Nullable`1<Column> Name { get; }
    private RoleMappedSchema(DataViewSchema schema, Dictionary`2<string, IReadOnlyList`1<Column>> map);
    private RoleMappedSchema(DataViewSchema schema, Dictionary`2<string, List`1<Column>> map);
    public RoleMappedSchema(DataViewSchema schema, bool opt, KeyValuePair`2[] roles);
    public RoleMappedSchema(DataViewSchema schema, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> roles, bool opt);
    public RoleMappedSchema(DataViewSchema schema, string label, string feature, string group, string weight, string name, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> custom, bool opt);
    public static KeyValuePair`2<ColumnRole, string> CreatePair(ColumnRole role, string name);
    [CompilerGeneratedAttribute]
public DataViewSchema get_Schema();
    [CompilerGeneratedAttribute]
public Nullable`1<Column> get_Feature();
    [CompilerGeneratedAttribute]
public Nullable`1<Column> get_Label();
    [CompilerGeneratedAttribute]
public Nullable`1<Column> get_Group();
    [CompilerGeneratedAttribute]
public Nullable`1<Column> get_Weight();
    [CompilerGeneratedAttribute]
public Nullable`1<Column> get_Name();
    private static void Add(Dictionary`2<string, List`1<Column>> map, ColumnRole role, Column column);
    private static Dictionary`2<string, List`1<Column>> MapFromNames(DataViewSchema schema, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> roles, bool opt);
    public bool Has(ColumnRole role);
    public bool HasUnique(ColumnRole role);
    public bool HasMultiple(ColumnRole role);
    public IReadOnlyList`1<Column> GetColumns(ColumnRole role);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RoleMappedSchema/<GetColumnRoles>d__35")]
public IEnumerable`1<KeyValuePair`2<ColumnRole, Column>> GetColumnRoles();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RoleMappedSchema/<GetColumnRoleNames>d__36")]
public IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetColumnRoleNames();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RoleMappedSchema/<GetColumnRoleNames>d__37")]
public IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetColumnRoleNames(ColumnRole role);
    public Column GetUniqueColumn(ColumnRole role);
    private static Dictionary`2<string, IReadOnlyList`1<Column>> Copy(Dictionary`2<string, List`1<Column>> map);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RoleMappedSchema/<PredefinedRolesHelper>d__42")]
private static IEnumerable`1<KeyValuePair`2<ColumnRole, string>> PredefinedRolesHelper(string label, string feature, string group, string weight, string name, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> custom);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RootCursorBase : DataViewRowCursor {
    protected IChannel Ch;
    private long _position;
    private bool _disposed;
    public long Position { get; }
    protected bool IsGood { get; }
    protected RootCursorBase(IChannelProvider provider);
    public sealed virtual long get_Position();
    protected bool get_IsGood();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool MoveNext();
    protected abstract virtual bool MoveNextCore();
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.SchemaExtensions : object {
    public static DataViewSchema MakeSchema(IEnumerable`1<DetachedColumn> columns);
    [ExtensionAttribute]
public static bool TryGetColumnIndex(DataViewSchema schema, string name, Int32& col);
}
public class Microsoft.ML.Data.SimpleFileHandle : object {
    private string _fullPath;
    private IExceptionContext _ectx;
    private object _lock;
    private bool _autoDelete;
    private bool _wrote;
    private Stream _streamWrite;
    private List`1<Stream> _streams;
    private bool IsDisposed { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public SimpleFileHandle(IExceptionContext ectx, string path, bool needsWrite, bool autoDelete);
    private bool get_IsDisposed();
    public sealed virtual bool get_CanWrite();
    public sealed virtual bool get_CanRead();
    public sealed virtual void Dispose();
    private void CheckNotDisposed();
    public sealed virtual Stream CreateWriteStream();
    public sealed virtual Stream OpenReadStream();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.SynchronizedCursorBase : DataViewRowCursor {
    protected IChannel Ch;
    internal DataViewRowCursor Root;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private DataViewRowCursor <Input>k__BackingField;
    protected DataViewRowCursor Input { get; }
    public long Position { get; }
    public long Batch { get; }
    protected bool IsGood { get; }
    protected SynchronizedCursorBase(IChannelProvider provider, DataViewRowCursor input);
    [CompilerGeneratedAttribute]
protected DataViewRowCursor get_Input();
    public sealed virtual long get_Position();
    public sealed virtual long get_Batch();
    protected bool get_IsGood();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool MoveNext();
    public sealed virtual ValueGetter`1<DataViewRowId> GetIdGetter();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ValueMapper`2 : MulticastDelegate {
    public ValueMapper`2(object object, IntPtr method);
    public virtual void Invoke(TSrc& modreq(System.Runtime.InteropServices.InAttribute) src, TDst& dst);
    public virtual IAsyncResult BeginInvoke(TSrc& modreq(System.Runtime.InteropServices.InAttribute) src, TDst& dst, AsyncCallback callback, object object);
    public virtual void EndInvoke(TSrc& modreq(System.Runtime.InteropServices.InAttribute) src, TDst& dst, IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ValueMapper`3 : MulticastDelegate {
    public ValueMapper`3(object object, IntPtr method);
    public virtual void Invoke(TVal1& modreq(System.Runtime.InteropServices.InAttribute) val1, TVal2& val2, TVal3& val3);
    public virtual IAsyncResult BeginInvoke(TVal1& modreq(System.Runtime.InteropServices.InAttribute) val1, TVal2& val2, TVal3& val3, AsyncCallback callback, object object);
    public virtual void EndInvoke(TVal1& modreq(System.Runtime.InteropServices.InAttribute) val1, TVal2& val2, TVal3& val3, IAsyncResult result);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.WrappingRow : DataViewRow {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private DataViewRow <Input>k__BackingField;
    protected DataViewRow Input { get; }
    public long Batch { get; }
    public long Position { get; }
    [BestFriendAttribute]
private protected WrappingRow(DataViewRow input);
    [CompilerGeneratedAttribute]
protected DataViewRow get_Input();
    public sealed virtual long get_Batch();
    public sealed virtual long get_Position();
    public virtual ValueGetter`1<DataViewRowId> GetIdGetter();
    protected sealed virtual void Dispose(bool disposing);
    protected virtual void DisposeCore(bool disposing);
}
[AttributeUsageAttribute("1")]
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.EntryPointModuleAttribute : LoadableClassAttributeBase {
    public EntryPointModuleAttribute(Type loaderType);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.EntryPointUtils : object {
    private static FuncStaticMethodInfo1`3<RangeAttribute, object, bool> _isValueWithinRangeMethodInfo;
    private static EntryPointUtils();
    private static bool IsValueWithinRange(RangeAttribute range, object obj);
    [ExtensionAttribute]
public static bool IsValueWithinRange(RangeAttribute range, object val);
    public static void CheckInputArgs(IExceptionContext ectx, object args);
    public static IHost CheckArgsAndCreateHost(IHostEnvironment env, string hostName, object input);
    public static string FindColumnOrNull(IExceptionContext ectx, DataViewSchema schema, Optional`1<string> value);
    [ExtensionAttribute]
public static Nullable`1<T> AsNullable(Optional`1<T> opt);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.EntryPoints.Optional : object {
    public bool IsExplicit;
    private protected Optional(bool isExplicit);
    public abstract virtual object GetValue();
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.Optional`1 : Optional {
    public T Value;
    private Optional`1(bool isExplicit, T value);
    public static Optional`1<T> Implicit(T value);
    public static Optional`1<T> Explicit(T value);
    public static T op_Implicit(Optional`1<T> optional);
    public static Optional`1<T> op_Implicit(T value);
    public virtual object GetValue();
    public virtual string ToString();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.EntryPoints.PredictorModel : object {
    [BestFriendAttribute]
internal TransformModel TransformModel { get; }
    [BestFriendAttribute]
internal IPredictor Predictor { get; }
    [BestFriendAttribute]
internal abstract virtual void Save(IHostEnvironment env, Stream stream);
    internal abstract virtual TransformModel get_TransformModel();
    internal abstract virtual IPredictor get_Predictor();
    [BestFriendAttribute]
internal abstract virtual PredictorModel Apply(IHostEnvironment env, TransformModel transformModel);
    [BestFriendAttribute]
internal abstract virtual void PrepareData(IHostEnvironment env, IDataView input, RoleMappedData& roleMappedData, IPredictor& predictor);
    [BestFriendAttribute]
internal abstract virtual String[] GetLabelInfo(IHostEnvironment env, DataViewType& labelType);
    [BestFriendAttribute]
internal abstract virtual RoleMappedSchema GetTrainingSchema(IHostEnvironment env);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.SignatureEntryPointModule : MulticastDelegate {
    public SignatureEntryPointModule(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.TlcModule : object {
    public static DataKind GetDataType(Type type);
    public static bool IsNumericKind(DataKind kind);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.EntryPoints.TransformModel : object {
    [BestFriendAttribute]
internal DataViewSchema InputSchema { get; }
    [BestFriendAttribute]
internal DataViewSchema OutputSchema { get; }
    internal abstract virtual DataViewSchema get_InputSchema();
    internal abstract virtual DataViewSchema get_OutputSchema();
    [BestFriendAttribute]
internal abstract virtual IDataView Apply(IHostEnvironment env, IDataView input);
    [BestFriendAttribute]
internal abstract virtual TransformModel Apply(IHostEnvironment env, TransformModel input);
    [BestFriendAttribute]
internal abstract virtual void Save(IHostEnvironment env, Stream stream);
    [BestFriendAttribute]
internal abstract virtual IRowToRowMapper AsRowToRowMapper(IExceptionContext ectx);
}
[AttributeUsageAttribute("4")]
public abstract class Microsoft.ML.ExtensionBaseAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ContractName>k__BackingField;
    public string ContractName { get; }
    [BestFriendAttribute]
private protected ExtensionBaseAttribute(string contractName);
    [CompilerGeneratedAttribute]
public string get_ContractName();
}
[BestFriendAttribute]
internal interface Microsoft.ML.ICanSaveInBinaryFormat {
    public abstract virtual void SaveAsBinary(BinaryWriter writer);
}
public interface Microsoft.ML.ICanSaveModel {
    public abstract virtual void Save(ModelSaveContext ctx);
}
public interface Microsoft.ML.IDataLoader`1 {
    public abstract virtual IDataView Load(TSource input);
    public abstract virtual DataViewSchema GetOutputSchema();
}
public interface Microsoft.ML.IDataLoaderEstimator`2 {
    public abstract virtual TLoader Fit(TSource input);
    public abstract virtual SchemaShape GetOutputSchema();
}
[BestFriendAttribute]
internal interface Microsoft.ML.IDistPredictorProducing`2 {
}
public interface Microsoft.ML.IEstimator`1 {
    public abstract virtual TTransformer Fit(IDataView input);
    public abstract virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal static class Microsoft.ML.Internal.Utilities.ArrayUtils : object {
    public static int ArrayMaxSize;
    public static int Size(T[] x);
    public static bool TryFindIndexSorted(Int32[] input, int min, int lim, int value, Int32& index);
    public static int FindIndexSorted(Int32[] input, int min, int lim, int value);
    public static int FindIndexSorted(ReadOnlySpan`1<int> input, int min, int lim, int value);
    public static int EnsureSize(T[]& array, int min, int max, bool keepOld, Boolean& resized);
}
[DefaultMemberAttribute("Item")]
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.BigArray`1 : object {
    private static int BlockSizeBits;
    private static int BlockSize;
    private static int BlockSizeMinusOne;
    private static long MaxSize;
    private static int FullAllocationBeyond;
    private T[][] _entries;
    private long _length;
    public long Length { get; }
    public T Item { get; public set; }
    public BigArray`1(long size);
    public long get_Length();
    public T get_Item(long index);
    public void set_Item(long index, T value);
    public void ApplyAt(long index, Visitor<T> manip);
    public void ApplyRange(long min, long lim, Visitor<T> manip);
    public void FillRange(long min, long lim, T value);
    public void Resize(long newLength);
    public void TrimCapacity();
    public void AddRange(ReadOnlySpan`1<T> src);
    public void CopyTo(long idx, Span`1<T> dst, int length);
    private static void LongMinToMajorMinorMin(long min, Int32& major, Int32& minor);
    private static void LongLimToMajorMaxMinorLim(long lim, Int32& major, Int32& minor);
    [IteratorStateMachineAttribute("Microsoft.ML.Internal.Utilities.BigArray`1/<GetEnumerator>d__23")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Internal.Utilities.BinFinderBase : object {
    private Single[] _valuesSng;
    private Double[] _valuesDbl;
    private List`1<int> _counts;
    private Int32[] _path;
    [CompilerGeneratedAttribute]
private int <CountBins>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CountValues>k__BackingField;
    protected int CountBins { get; private set; }
    protected int CountValues { get; private set; }
    [CompilerGeneratedAttribute]
protected int get_CountBins();
    [CompilerGeneratedAttribute]
private void set_CountBins(int value);
    [CompilerGeneratedAttribute]
protected int get_CountValues();
    [CompilerGeneratedAttribute]
private void set_CountValues(int value);
    public Single[] FindBins(int cbin, IList`1<float> values, int numZeroes);
    public Double[] FindBins(int cbin, IList`1<double> values, int numZeroes);
    public void FindBinsWithCounts(IList`1<int> counts, int numValues, int cbin, Int32[] path);
    public static float GetSplitValue(float a, float b);
    public static double GetSplitValue(double a, double b);
    protected abstract virtual void FindBinsCore(List`1<int> counts, Int32[] path);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.CharUtils : object {
    private static int CharsCount;
    private static Char[] modreq(System.Runtime.CompilerServices.IsVolatile) _lowerInvariantChars;
    private static Char[] modreq(System.Runtime.CompilerServices.IsVolatile) _upperInvariantChars;
    private static Char[] EnsureLowerInvariant();
    private static Char[] EnsureUpperInvariant();
    public static char ToLowerInvariant(char c);
    public static char ToUpperInvariant(char c);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.CmdIndenter : object {
    public static string GetIndentedCommandLine(string commandLine);
    private static bool TryProduceIndentString(string text, IndentedTextWriter itw);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.DoubleParser : object {
    private static ulong TopBit;
    private static ulong TopTwoBits;
    private static ulong TopThreeBits;
    private static char InfinitySymbol;
    private static UInt64[] _mpe10Man;
    private static UInt64[] _mpne10Man;
    private static Int16[] _mpe10e2;
    private static Int16[] _mpne10ne2;
    private static Double[] _mpe10Dbl;
    private static Double[] _mpne10Dbl;
    private static DoubleParser();
    public static bool TryParse(ReadOnlySpan`1<char> span, Single& value, OptionFlags flags);
    public static bool TryParse(ReadOnlySpan`1<char> span, Double& value, OptionFlags flags);
    public static Result Parse(ReadOnlySpan`1<char> span, Single& value, OptionFlags flags);
    public static Result Parse(ReadOnlySpan`1<char> span, Double& value, OptionFlags flags);
    public static bool TryParse(ReadOnlySpan`1<char> span, Single& value, Int32& ichEnd, OptionFlags flags);
    public static bool TryParse(ReadOnlySpan`1<char> span, Double& value, Int32& ichEnd, OptionFlags flags);
    private static bool TryParseSpecial(ReadOnlySpan`1<char> span, Int32& ich, Double& value);
    private static bool TryParseSpecial(ReadOnlySpan`1<char> span, Int32& ich, Single& value);
    private static bool TryParseCore(ReadOnlySpan`1<char> span, Int32& ich, Boolean& neg, UInt64& num, Int64& exp, OptionFlags flags);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.DynamicBinFinder : BinFinderBase {
    private Int32[] _accum;
    private int _cskip;
    private Int32[] _pathInfo;
    private Double[] _energies;
    private Double[] _energiesBest;
    private Int32[] _cols;
    private Int32[] _colsNew;
    private Int32[] _path;
    protected virtual void FindBinsCore(List`1<int> counts, Int32[] path);
    private static double Square(int d);
    private void GetEnergyBounds(int row, int col, double cur, Double& best, Double& worst);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.ExceptionMarshaller : object {
    private CancellationTokenSource _ctSource;
    private object _lock;
    private string _component;
    private Exception _ex;
    public CancellationToken Token { get; }
    public CancellationToken get_Token();
    public sealed virtual void Dispose();
    public void Set(string component, Exception ex);
    public void ThrowIfSet(IExceptionContext ectx);
}
[DefaultMemberAttribute("Item")]
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.FixedSizeQueue`1 : object {
    private T[] _array;
    private int _startIndex;
    private int _count;
    public int Count { get; }
    public int Capacity { get; }
    public bool IsFull { get; }
    public T Item { get; }
    public FixedSizeQueue`1(int capacity);
    [ConditionalAttribute("DEBUG")]
private void AssertValid();
    public int get_Count();
    public int get_Capacity();
    public bool get_IsFull();
    public T get_Item(int index);
    public void AddLast(T item);
    public T PeekFirst();
    public T PeekLast();
    public T RemoveFirst();
    public T RemoveLast();
    public void Clear();
    public FixedSizeQueue`1<T> Clone();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.FloatUtils : object {
    public static ulong GetBits(double x);
    public static UInt32 GetBits(float x);
    public static double FromBits(ulong bits);
    public static float FromBits(UInt32 bits);
    public static bool IsFinite(double x);
    public static bool IsFinite(float x);
    public static bool IsFinite(ReadOnlySpan`1<double> values);
    public static bool IsFinite(ReadOnlySpan`1<float> values);
    public static bool IsFiniteNonZero(double x);
    public static bool IsFiniteNonZero(float x);
    public static bool IsFiniteNormal(double x);
    public static bool IsFiniteNormal(float x);
    public static bool IsDenormal(double x);
    public static bool IsDenormal(float x);
    public static int GetExponent(double x);
    public static int GetExponent(float x);
    public static double SetExponent(double x, int exp);
    public static float SetExponent(float x, int exp);
    public static void GetParts(double x, Int32& sign, Int32& exp, UInt64& man, Boolean& fFinite);
    public static void GetParts(float x, Int32& sign, Int32& exp, UInt32& man, Boolean& fFinite);
    public static double GetFromPartsDouble(int sign, int exp, ulong man);
    public static float GetFromPartsSingle(int sign, int exp, UInt32 man);
    public static double GetPowerOfTwoDouble(int exp);
    public static float GetPowerOfTwoSingle(int exp);
    public static int NormalizeExponent(Double& x);
    public static int NormalizeExponent(Single& x);
    public static double TruncateMantissaToSingleBit(double x);
    public static float TruncateMantissaToSingleBit(float x);
    public static double Truncate(double x);
    public static string ToRoundTripString(float x);
    public static string ToRoundTripString(double x);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncInstanceMethodInfo1`2 : FuncMethodInfo1`1<TResult> {
    private static string _targetTypeCheckMessage;
    public FuncInstanceMethodInfo1`2(Func`1<TResult> function);
    private FuncInstanceMethodInfo1`2(MethodInfo methodInfo);
    private static FuncInstanceMethodInfo1`2();
    public static FuncInstanceMethodInfo1`2<TTarget, TResult> Create(Expression`1<Func`2<TTarget, Func`1<TResult>>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncInstanceMethodInfo1`3 : FuncMethodInfo1`2<T, TResult> {
    private static string _targetTypeCheckMessage;
    public FuncInstanceMethodInfo1`3(Func`2<T, TResult> function);
    private FuncInstanceMethodInfo1`3(MethodInfo methodInfo);
    private static FuncInstanceMethodInfo1`3();
    public static FuncInstanceMethodInfo1`3<TTarget, T, TResult> Create(Expression`1<Func`2<TTarget, Func`2<T, TResult>>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncInstanceMethodInfo1`4 : FuncMethodInfo1`3<T1, T2, TResult> {
    private static string _targetTypeCheckMessage;
    public FuncInstanceMethodInfo1`4(Func`3<T1, T2, TResult> function);
    private FuncInstanceMethodInfo1`4(MethodInfo methodInfo);
    private static FuncInstanceMethodInfo1`4();
    public static FuncInstanceMethodInfo1`4<TTarget, T1, T2, TResult> Create(Expression`1<Func`2<TTarget, Func`3<T1, T2, TResult>>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncInstanceMethodInfo2`4 : FuncMethodInfo2`3<T1, T2, TResult> {
    private static string _targetTypeCheckMessage;
    public FuncInstanceMethodInfo2`4(Func`3<T1, T2, TResult> function);
    private FuncInstanceMethodInfo2`4(MethodInfo methodInfo);
    private static FuncInstanceMethodInfo2`4();
    public static FuncInstanceMethodInfo2`4<TTarget, T1, T2, TResult> Create(Expression`1<Func`2<TTarget, Func`3<T1, T2, TResult>>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncInstanceMethodInfo3`3 : FuncMethodInfo3`2<T, TResult> {
    private static string _targetTypeCheckMessage;
    public FuncInstanceMethodInfo3`3(Func`2<T, TResult> function);
    private FuncInstanceMethodInfo3`3(MethodInfo methodInfo);
    private static FuncInstanceMethodInfo3`3();
    public static FuncInstanceMethodInfo3`3<TTarget, T, TResult> Create(Expression`1<Func`2<TTarget, Func`2<T, TResult>>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncInstanceMethodInfo3`4 : FuncMethodInfo3`3<T1, T2, TResult> {
    private static string _targetTypeCheckMessage;
    public FuncInstanceMethodInfo3`4(Func`3<T1, T2, TResult> function);
    private FuncInstanceMethodInfo3`4(MethodInfo methodInfo);
    private static FuncInstanceMethodInfo3`4();
    public static FuncInstanceMethodInfo3`4<TTarget, T1, T2, TResult> Create(Expression`1<Func`2<TTarget, Func`3<T1, T2, TResult>>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo`1 : object {
    [CompilerGeneratedAttribute]
private MethodInfo <GenericMethodDefinition>k__BackingField;
    protected MethodInfo GenericMethodDefinition { get; }
    private protected FuncMethodInfo`1(MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
protected MethodInfo get_GenericMethodDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo`2 : object {
    [CompilerGeneratedAttribute]
private MethodInfo <GenericMethodDefinition>k__BackingField;
    protected MethodInfo GenericMethodDefinition { get; }
    private protected FuncMethodInfo`2(MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
protected MethodInfo get_GenericMethodDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo`3 : object {
    [CompilerGeneratedAttribute]
private MethodInfo <GenericMethodDefinition>k__BackingField;
    protected MethodInfo GenericMethodDefinition { get; }
    private protected FuncMethodInfo`3(MethodInfo methodInfo);
    [CompilerGeneratedAttribute]
protected MethodInfo get_GenericMethodDefinition();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo1`1 : FuncMethodInfo`1<TResult> {
    private ImmutableDictionary`2<Type, MethodInfo> _instanceMethodInfo;
    private protected FuncMethodInfo1`1(MethodInfo methodInfo);
    public MethodInfo MakeGenericMethod(Type typeArg1);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo1`2 : FuncMethodInfo`2<T, TResult> {
    private ImmutableDictionary`2<Type, MethodInfo> _instanceMethodInfo;
    private protected FuncMethodInfo1`2(MethodInfo methodInfo);
    public MethodInfo MakeGenericMethod(Type typeArg1);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo1`3 : FuncMethodInfo`3<T1, T2, TResult> {
    private ImmutableDictionary`2<Type, MethodInfo> _instanceMethodInfo;
    private protected FuncMethodInfo1`3(MethodInfo methodInfo);
    public MethodInfo MakeGenericMethod(Type typeArg1);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo2`3 : FuncMethodInfo`3<T1, T2, TResult> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ValueTuple`2<Type, Type>, MethodInfo> _instanceMethodInfo;
    [NullableContextAttribute("1")]
private protected FuncMethodInfo2`3(MethodInfo methodInfo);
    [NullableContextAttribute("1")]
public MethodInfo MakeGenericMethod(Type typeArg1, Type typeArg2);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo3`2 : FuncMethodInfo`2<T, TResult> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ValueTuple`3<Type, Type, Type>, MethodInfo> _instanceMethodInfo;
    private protected FuncMethodInfo3`2(MethodInfo methodInfo);
    public MethodInfo MakeGenericMethod(Type typeArg1, Type typeArg2, Type typeArg3);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.ML.Internal.Utilities.FuncMethodInfo3`3 : FuncMethodInfo`3<T1, T2, TResult> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ValueTuple`3<Type, Type, Type>, MethodInfo> _instanceMethodInfo;
    [NullableContextAttribute("1")]
private protected FuncMethodInfo3`3(MethodInfo methodInfo);
    [NullableContextAttribute("1")]
public MethodInfo MakeGenericMethod(Type typeArg1, Type typeArg2, Type typeArg3);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncStaticMethodInfo1`1 : FuncMethodInfo1`1<TResult> {
    public FuncStaticMethodInfo1`1(Func`1<TResult> function);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncStaticMethodInfo1`2 : FuncMethodInfo1`2<T, TResult> {
    [NullableContextAttribute("1")]
public FuncStaticMethodInfo1`2(Func`2<T, TResult> function);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncStaticMethodInfo1`3 : FuncMethodInfo1`3<T1, T2, TResult> {
    [NullableContextAttribute("1")]
public FuncStaticMethodInfo1`3(Func`3<T1, T2, TResult> function);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncStaticMethodInfo2`3 : FuncMethodInfo2`3<T1, T2, TResult> {
    [NullableContextAttribute("1")]
public FuncStaticMethodInfo2`3(Func`3<T1, T2, TResult> function);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncStaticMethodInfo3`2 : FuncMethodInfo3`2<T, TResult> {
    [NullableContextAttribute("1")]
public FuncStaticMethodInfo3`2(Func`2<T, TResult> function);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.ML.Internal.Utilities.FuncStaticMethodInfo3`3 : FuncMethodInfo3`3<T1, T2, TResult> {
    [NullableContextAttribute("1")]
public FuncStaticMethodInfo3`3(Func`3<T1, T2, TResult> function);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.GreedyBinFinder : BinFinderBase {
    private Heap`1<Segment> _segmentHeap;
    private Heap`1<Peg> _pegHeap;
    private Int32[] _accum;
    private Int32[] _path;
    private float _meanBinSize;
    protected virtual void FindBinsCore(List`1<int> counts, Int32[] path);
    private void PlacePegs();
    private Segment GetSegmentSplit(int min, int max);
    private int FindSplitPosition(Int64& energy, int min, int max, int pos);
    private long GetSplitEnergy(int min, int split, int max);
    private bool BetterPlacement(int i, int j, int pos);
    private void ReduceEnergy();
    private void UpdatePeg(Peg peg);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.HashArray`1 : object {
    private Int32[] _rgit;
    private int _ct;
    private Entry[] _entries;
    public int Count { get; }
    public int get_Count();
    [ConditionalAttribute("DEBUG")]
private void AssertValid();
    private int GetIit(int hash);
    public TItem GetItem(int it);
    public bool TryGetIndex(TItem val, Int32& index);
    private int GetIndexCore(TItem val, int iit);
    public int Add(TItem val);
    public bool TryAdd(TItem val);
    private int AddCore(TItem val, int iit);
    private void GrowTable();
    public void Sort();
    private void FillTable();
    [ConditionalAttribute("DUMP_STATS")]
private void DumpStats();
    public void CopyTo(Span`1<TItem> destination);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.Hashing : object {
    private static UInt32 _defaultSeed;
    public static UInt32 CombineHash(UInt32 u1, UInt32 u2);
    public static int CombineHash(int n1, int n2);
    public static int CombinedHash(int startHash, Object[] os);
    public static int CombinedHash(int startHash, T[] os);
    public static UInt32 HashUint(UInt32 u);
    public static int HashInt(int n);
    public static UInt32 HashString(ReadOnlySpan`1<char> str);
    public static UInt32 HashString(StringBuilder sb);
    public static UInt32 HashSequence(UInt32[] sequence, int min, int lim);
    public static UInt32 MurmurRound(UInt32 hash, UInt32 chunk);
    public static UInt32 MurmurHash(UInt32 hash, ReadOnlySpan`1<char> span, bool toUpper);
    public static UInt32 MurmurHashV2(UInt32 hash, ReadOnlySpan`1<char> span, bool toUpper);
    public static UInt32 MurmurHash(UInt32 hash, StringBuilder data, int ichMin, int ichLim, bool toUpper);
    public static UInt32 MurmurHash(UInt32 hash, UInt32[] data, int min, int lim);
    public static UInt32 MixHash(UInt32 hash);
    public static UInt32 MixHash(UInt32 hash, int len);
    private static UInt32 Rotate(UInt32 x, int r);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.Heap`1 : object {
    private List`1<T> _rgv;
    private Func`3<T, T, bool> _fnReverse;
    public Func`3<T, T, bool> FnReverse { get; }
    public int Count { get; }
    public T Top { get; }
    public Heap`1(Func`3<T, T, bool> fnReverse);
    public Heap`1(Func`3<T, T, bool> fnReverse, int capacity);
    [ConditionalAttribute("DEBUG")]
private void AssertValid();
    public Func`3<T, T, bool> get_FnReverse();
    public int get_Count();
    private static int Parent(int iv);
    private static int Left(int iv);
    private static int Right(int iv);
    private void MoveTo(T v, int iv);
    public void Clear();
    public T get_Top();
    public T Pop();
    public void Add(T item);
    private void BubbleUp(int iv);
    private void BubbleDown(int iv);
}
internal abstract class Microsoft.ML.Internal.Utilities.HeapNode : object {
    private int _index;
    public bool InHeap { get; }
    public bool get_InHeap();
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.HybridMemoryStream : Stream {
    private MemoryStream _memStream;
    private Stream _overflowStream;
    private int _overflowBoundary;
    private static int _defaultMaxLen;
    private bool _disposed;
    private Stream MyStream { get; }
    private bool IsMemory { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public HybridMemoryStream(int maxLen);
    private Stream get_MyStream();
    private bool get_IsMemory();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public static Stream CreateCache(Stream stream, int maxLen);
    [ConditionalAttribute("DEBUG")]
private void AssertInvariants();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual void Flush();
    private void EnsureOverflow();
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.IndentedTextWriterExtensions : object {
    [ExtensionAttribute]
public static Scope Nest(IndentedTextWriter writer);
    [ExtensionAttribute]
public static void Indent(IndentedTextWriter writer);
    [ExtensionAttribute]
public static void Outdent(IndentedTextWriter writer);
    [ExtensionAttribute]
public static void WriteLineNoTabs(IndentedTextWriter writer);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Internal.Utilities.IReservoirSampler`1 {
    public int Size { get; }
    public long NumSampled { get; }
    public abstract virtual int get_Size();
    public abstract virtual long get_NumSampled();
    public abstract virtual void Sample();
    public abstract virtual void Lock();
    public abstract virtual IEnumerable`1<T> GetSample();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.LineParser : object {
    public static ValueTuple`3<bool, string, Single[]> ParseKeyThenNumbers(string line, bool invariantCulture);
    private static Single[] AllocateFixedSizeArrayToStoreParsedValues(ReadOnlySpan`1<char> valuesToParse);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.LruCache`2 : object {
    private int _size;
    private Dictionary`2<TKey, LinkedListNode`1<KeyValuePair`2<TKey, TValue>>> _cache;
    private LinkedList`1<KeyValuePair`2<TKey, TValue>> _lru;
    public IEnumerable`1<TKey> Keys { get; }
    public LruCache`2(int size);
    public IEnumerable`1<TKey> get_Keys();
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.MadeObjectPool`1 : ObjectPoolBase`1<T> {
    private Func`1<T> _maker;
    public MadeObjectPool`1(Func`1<T> maker);
    protected virtual T Create();
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.MathUtils : object {
    private static float LogTolerance;
    public static float DefaultMaxRelativeErr;
    public static float DefaultMaxAbsErr;
    private static Int32[] _possiblePrimeMod30;
    private static double _constantForLogGamma;
    private static Double[] _coeffsForLogGamma;
    private static List`1<double> _logFactorialCache;
    private static int LogFactorialCacheSize;
    private static int ExpInf;
    private static float Coef1;
    private static float Coef2;
    private static float Coef3;
    private static float RecipLn2;
    private static MathUtils();
    [ExtensionAttribute]
public static float ToFloat(double dbl);
    [ExtensionAttribute]
public static void ToFloat(float dbl);
    public static float Sqrt(float x);
    public static float Log(float x);
    public static float Log(float a, float newBase);
    public static float Pow(float x, float y);
    public static void SimpleLinearRegression(Single[] x, Single[] y, Single& a, Single& b);
    public static int Product(Int32[] a);
    public static float Max(Single[] a);
    public static float Min(Single[] a);
    public static int ArgMax(ReadOnlySpan`1<float> a);
    public static int ArgMin(ReadOnlySpan`1<float> a);
    public static float SoftMax(ReadOnlySpan`1<float> inputs);
    public static float SoftMax(float lx, float ly);
    public static bool AlmostEqual(float a, float b);
    public static bool AlmostEqual(float a, float b, float maxRelErr, float maxAbsError);
    public static double LogGamma(double x);
    public static double LogFactorial(int n);
    public static double TStatisticToPValue(double t, double df);
    private static double Lentz(Sequence a, Sequence b, double tol);
    private static double Beta(double a, double b);
    private static double IncompleteBeta(double x, double a, double b);
    private static double Unclamp(double val);
    public static float Sigmoid(float x);
    public static float Tanh(float x);
    public static float SigmoidSlow(float x);
    public static float TanhSlow(float x);
    public static float ExpSlow(float x);
    private static float PowerOfTwo(int exp);
    public static float SigmoidFast(float x);
    public static float TanhFast(float x);
    public static float ExpFast(float x);
    public static void ApplySoftMax(Single[] src, Single[] dst);
    public static void ApplySoftMax(Single[] src, Single[] dst, int start, int end);
    public static float GetMedianInPlace(Single[] src, int count);
    public static double CosineSimilarity(ReadOnlySpan`1<float> a, ReadOnlySpan`1<float> b, int aIdx, int bIdx, int len);
    public static double Entropy(double prob, bool useLnNotLog2);
    public static double CrossEntropy(double probTrue, double probPredicted, bool useLnNotLog2);
    public static float LnSum(IEnumerable`1<float> terms);
    public static double Sin(double a);
    public static double Cos(double a);
    public static long DivisionCeiling(long numerator, long denomenator);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.MatrixTransposeOps : object {
    private static int _block;
    public static void TransposeSingleThread(T[] src, T[] dst, int m, int n);
    public static void Transpose(T[] src, T[] dst, int m, int n);
    public static void Transpose(Single* src, Single* dst, int m, int n);
    public static void Transpose(Double* src, Double* dst, int m, int n);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.MinWaiter : object {
    private Heap`1<WaitStats> _waiters;
    private int _maxWaiters;
    public MinWaiter(int waiters);
    public ManualResetEventSlim Register(long position);
    public int Retire();
    private void SignalIfNeeded();
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.NormStr : object {
    public ReadOnlyMemory`1<char> Value;
    public int Id;
    private UInt32 _hash;
    private NormStr(ReadOnlyMemory`1<char> str, int id, UInt32 hash);
    public virtual int GetHashCode();
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.ObjectPool`1 : ObjectPoolBase`1<T> {
    protected virtual T Create();
}
internal abstract class Microsoft.ML.Internal.Utilities.ObjectPoolBase`1 : object {
    private ConcurrentBag`1<T> _pool;
    private int _numCreated;
    public int Count { get; }
    public int NumCreated { get; }
    public int get_Count();
    public int get_NumCreated();
    public T Get();
    protected abstract virtual T Create();
    public void Return(T item);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.OrderedWaiter : object {
    private Heap`1<WaitStats> _waiters;
    private long _currCleared;
    private Exception _ex;
    public OrderedWaiter(bool firstCleared);
    public OrderedWaiter(long startPos);
    public void Wait(long position, CancellationToken token);
    public long Increment();
    public long IncrementAll();
    public void SignalException(Exception ex);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.PlatformUtils : object {
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> AsReadOnly(T[] items);
    [ExtensionAttribute]
public static bool IsGenericEx(Type type, Type typeDef);
    [ExtensionAttribute]
public static Type[] GetGenericTypeArgumentsEx(Type type);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.ReservoirSamplerWithoutReplacement`1 : object {
    private T[] _cache;
    private Random _rnd;
    private long _numSampled;
    private ValueGetter`1<T> _getter;
    private bool _locked;
    public int Size { get; }
    public long NumSampled { get; }
    public ReservoirSamplerWithoutReplacement`1(Random rnd, int size, ValueGetter`1<T> getter);
    public sealed virtual int get_Size();
    public sealed virtual long get_NumSampled();
    public sealed virtual void Sample();
    public sealed virtual void Lock();
    [IteratorStateMachineAttribute("Microsoft.ML.Internal.Utilities.ReservoirSamplerWithoutReplacement`1/<GetSample>d__12")]
public sealed virtual IEnumerable`1<T> GetSample();
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.ReservoirSamplerWithReplacement`1 : object {
    private Int32[] _reservoir;
    private T[] _cache;
    private Int32[] _counts;
    private Random _rnd;
    private long _numSampled;
    private ValueGetter`1<T> _getter;
    private bool _locked;
    public int Size { get; }
    public long NumSampled { get; }
    public ReservoirSamplerWithReplacement`1(Random rnd, int size, ValueGetter`1<T> getter);
    public sealed virtual int get_Size();
    public sealed virtual long get_NumSampled();
    public sealed virtual void Sample();
    public T[] GetCache();
    public sealed virtual void Lock();
    [IteratorStateMachineAttribute("Microsoft.ML.Internal.Utilities.ReservoirSamplerWithReplacement`1/<GetSample>d__15")]
public sealed virtual IEnumerable`1<T> GetSample();
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.ResourceManagerUtils : object {
    private static ResourceManagerUtils modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    private static string DefaultUrl;
    public static string TimeoutEnvVariable;
    public static string CustomResourcesUrlEnvVariable;
    public static ResourceManagerUtils Instance { get; }
    private static string MlNetResourcesUrl { get; }
    public static ResourceManagerUtils get_Instance();
    private static string get_MlNetResourcesUrl();
    public static string GetUrl(string suffix);
    [AsyncStateMachineAttribute("Microsoft.ML.Internal.Utilities.ResourceManagerUtils/<EnsureResourceAsync>d__11")]
public Task`1<ResourceDownloadResults> EnsureResourceAsync(IHostEnvironment env, IChannel ch, string relativeUrl, string fileName, string dir, int timeout);
    [AsyncStateMachineAttribute("Microsoft.ML.Internal.Utilities.ResourceManagerUtils/<DownloadFromUrlWithRetryAsync>d__12")]
private Task`1<string> DownloadFromUrlWithRetryAsync(IHostEnvironment env, IChannel ch, string url, string fileName, int timeout, string filePath, int retryTimes);
    [AsyncStateMachineAttribute("Microsoft.ML.Internal.Utilities.ResourceManagerUtils/<DownloadFromUrlAsync>d__13")]
private Task`1<string> DownloadFromUrlAsync(IHostEnvironment env, IChannel ch, string url, string fileName, int timeout, string filePath);
    private static void TryDelete(IChannel ch, string filePath, bool warn);
    private static void UpdateTimeout(Int32& timeout);
    private static string GetFilePath(IChannel ch, string fileName, string dir, String& error);
    [AsyncStateMachineAttribute("Microsoft.ML.Internal.Utilities.ResourceManagerUtils/<DownloadResource>d__17")]
private Task`1<Exception> DownloadResource(IHostEnvironment env, IChannel ch, HttpClient httpClient, Uri uri, string path, string fileName, CancellationToken ct);
    public bool IsRedirectToDefaultPage(string url);
    public static ResourceDownloadResults GetErrorMessage(String& errorMessage, ResourceDownloadResults[] result);
    private static int chmod(string pathname, int mode);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.Stats : object {
    private static double _vScale;
    private static Stats();
    public static long SampleLong(long rangeSize, Random rand);
    public static double SampleFromGaussian(Random rand);
    public static double SampleFromGamma(Random r, double alpha);
    public static double SampleFromBeta(Random rand, double alpha1, double alpha2);
    public static void SampleFromDirichlet(Random rand, Double[] alphas, Double[] result);
    public static int SampleFromPoisson(Random rand, double lambda);
    public static float SampleFromLaplacian(Random rand, float mean, float scale);
    public static float SampleFromCauchy(Random rand);
    public static int SampleFromBinomial(Random r, int n, double p);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.SubsetStream : Stream {
    private Stream _stream;
    private long _offset;
    private long _remaining;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public bool CanSeek { get; }
    public long Position { get; public set; }
    public long Length { get; }
    public SubsetStream(Stream stream, Nullable`1<long> length);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.SummaryStatistics : SummaryStatisticsBase {
    private double _m3;
    private double _m4;
    public double Nonzero { get; }
    public double Skewness { get; }
    public double Kurtosis { get; }
    public double SkewnessZ { get; }
    public double KurtosisZ { get; }
    public double OmnibusK2 { get; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public double get_Nonzero();
    public double get_Skewness();
    public double get_Kurtosis();
    public double get_SkewnessZ();
    public double get_KurtosisZ();
    public double get_OmnibusK2();
    public virtual string ToString();
    public virtual void Add(double v, double w, long c);
    public void Add(SummaryStatistics s);
    public static SummaryStatistics op_Addition(SummaryStatistics a, SummaryStatistics b);
}
internal abstract class Microsoft.ML.Internal.Utilities.SummaryStatisticsBase : object {
    protected double M2;
    [CompilerGeneratedAttribute]
private long <RawCount>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <NonzeroCount>k__BackingField;
    [CompilerGeneratedAttribute]
private double <NonzeroWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    public long RawCount { get; private set; }
    public double Count { get; private set; }
    public double NonzeroCount { get; private set; }
    public double NonzeroWeight { get; private set; }
    public double Mean { get; private set; }
    public double SampleVariance { get; }
    public double SampleStdDev { get; }
    public double StandardErrorMean { get; }
    public double Max { get; private set; }
    public double Min { get; private set; }
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public long get_RawCount();
    [CompilerGeneratedAttribute]
private void set_RawCount(long value);
    [CompilerGeneratedAttribute]
public double get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(double value);
    [CompilerGeneratedAttribute]
public double get_NonzeroCount();
    [CompilerGeneratedAttribute]
private void set_NonzeroCount(double value);
    [CompilerGeneratedAttribute]
public double get_NonzeroWeight();
    [CompilerGeneratedAttribute]
private void set_NonzeroWeight(double value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
private void set_Mean(double value);
    public double get_SampleVariance();
    public double get_SampleStdDev();
    public double get_StandardErrorMean();
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
private void set_Max(double value);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
private void set_Min(double value);
    public virtual string ToString();
    public virtual void Add(double v, double w, long c);
    public void Add(SummaryStatisticsBase s);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.SummaryStatisticsUpToSecondOrderMoments : SummaryStatisticsBase {
    public static SummaryStatisticsUpToSecondOrderMoments op_Addition(SummaryStatisticsUpToSecondOrderMoments a, SummaryStatisticsUpToSecondOrderMoments b);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.SupervisedBinFinder : object {
    private int _valueCount;
    private int _distinctValueCount;
    private int _labelCardinality;
    private int _maxBins;
    private int _minBinSize;
    private Int32[0...,0...] _cumulativeCounts;
    public Single[] FindBins(int maxBins, int minBinSize, int nLabels, IList`1<float> values, IList`1<int> labels);
    public Double[] FindBins(int maxBins, int minBinSize, int nLabels, IList`1<double> values, IList`1<int> labels);
    [ConditionalAttribute("DEBUG")]
private void AssertStrictlyIncreasing(Single[] result);
    [ConditionalAttribute("DEBUG")]
private void AssertStrictlyIncreasing(Double[] result);
    private double GetEntropy(int min, int lim, Int32& totalCount);
    private Int32[] FindBinsCore();
}
[ExtensionAttribute]
internal static class Microsoft.ML.Internal.Utilities.TaskExtensions : object {
    [ExtensionAttribute]
public static TResult CompletedResult(Task`1<TResult> task);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.TextReaderStream : Stream {
    private TextReader _baseReader;
    private Encoding _encoding;
    private long _position;
    private static int _charBlockSize;
    private string _line;
    private int _lineCur;
    private Byte[] _buff;
    private int _buffCur;
    private int _buffLim;
    private bool _eof;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TextReaderStream(TextReader baseReader);
    public TextReaderStream(TextReader baseReader, Encoding encoding);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    private void EnsureBytes();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
}
[DefaultMemberAttribute("Item")]
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.Tree`2 : object {
    private TKey _key;
    private bool _hasNodeValue;
    private TValue _nodeValue;
    private Dictionary`2<TKey, Tree`2<TKey, TValue>> _children;
    private Tree`2<TKey, TValue> _parent;
    public bool HasNodeValue { get; }
    public TValue NodeValue { get; public set; }
    public Tree`2<TKey, TValue> Item { get; public set; }
    public TKey Key { get; }
    public Tree`2<TKey, TValue> Parent { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<Tree`2<TKey, TValue>> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool get_HasNodeValue();
    public TValue get_NodeValue();
    public void set_NodeValue(TValue value);
    public sealed virtual Tree`2<TKey, TValue> get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, Tree`2<TKey, TValue> value);
    public TKey get_Key();
    public Tree`2<TKey, TValue> get_Parent();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<Tree`2<TKey, TValue>> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool TryGetValue(TKey key, Tree`2& value);
    public void ClearNodeValue();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, Tree`2<TKey, TValue>> item);
    public sealed virtual void Add(KeyValuePair`2<TKey, Tree`2<TKey, TValue>> item);
    public sealed virtual void Add(TKey key, Tree`2<TKey, TValue> newChild);
    public void Detach();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, Tree`2<TKey, TValue>> item);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, Tree`2<TKey, TValue>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.Utils : object {
    private static int CbitUint;
    private static int CbitUlong;
    public static string CustomSearchDirEnvVariable;
    private static string _dllDir;
    private static int _bulkReadThresholdInBytes;
    private static Encoding _utf8NoBom;
    public static int ArrayMaxSize;
    private static string DllDir { get; }
    public static ulong MakeUlong(UInt32 uHi, UInt32 uLo);
    public static UInt32 GetLo(ulong uu);
    public static UInt32 GetHi(ulong uu);
    public static UInt32 Abs(int a);
    public static ulong Abs(long a);
    public static int CbitHighZero(UInt32 u);
    public static int IbitHigh(UInt32 u);
    public static int CbitLowZero(UInt32 u);
    public static int CbitHighZero(ulong uu);
    public static int CbitLowZero(ulong uu);
    public static int Cbit(UInt32 u);
    public static int Cbit(ulong uu);
    public static UInt32 UMaskBelow(int ibit);
    public static UInt32 UMaskBelowEx(int ibit);
    public static ulong UuMaskBelow(int ibit);
    public static bool IsPowerOfTwo(int x);
    public static bool IsPowerOfTwo(UInt32 x);
    public static bool IsPowerOfTwo(long x);
    public static bool IsPowerOfTwo(ulong x);
    private static string get_DllDir();
    public static string FindExistentFileOrNull(string fileName, string folderPrefix, string customSearchDir, Type assemblyForBasePath);
    private static bool TryFindFile(string fileName, string folderPrefix, string dir, String& foundFile);
    public static string CreateFolderIfNotExists(string folder);
    [ExtensionAttribute]
public static void CloseEx(Stream stream);
    [ExtensionAttribute]
public static void CloseEx(TextWriter writer);
    [ExtensionAttribute]
public static long CopyRange(Stream source, Stream destination, long length, int bufferSize);
    [ExtensionAttribute]
public static void WriteBoolByte(BinaryWriter writer, bool x);
    [ExtensionAttribute]
public static void WriteIntArray(BinaryWriter writer, ReadOnlySpan`1<int> values);
    [ExtensionAttribute]
public static void WriteIntsNoCount(BinaryWriter writer, ReadOnlySpan`1<int> values);
    [ExtensionAttribute]
public static void WriteUIntArray(BinaryWriter writer, ReadOnlySpan`1<UInt32> values);
    [ExtensionAttribute]
public static void WriteUIntsNoCount(BinaryWriter writer, ReadOnlySpan`1<UInt32> values);
    [ExtensionAttribute]
public static void WriteByteArray(BinaryWriter writer, Byte[] values);
    [ExtensionAttribute]
public static void WriteByteArray(BinaryWriter writer, ReadOnlySpan`1<byte> values);
    [ExtensionAttribute]
public static void WriteByteArray(BinaryWriter writer, Byte[] values, int count);
    [ExtensionAttribute]
public static void WriteBytesNoCount(BinaryWriter writer, Byte[] values, int count);
    [ExtensionAttribute]
public static void WriteSingleArray(BinaryWriter writer, ReadOnlySpan`1<float> values);
    [ExtensionAttribute]
public static void WriteSingleArray(BinaryWriter writer, IEnumerable`1<float> values, int count);
    [ExtensionAttribute]
public static void WriteSinglesNoCount(BinaryWriter writer, ReadOnlySpan`1<float> values);
    [ExtensionAttribute]
public static void WriteDoubleArray(BinaryWriter writer, ReadOnlySpan`1<double> values);
    [ExtensionAttribute]
public static void WriteDoublesNoCount(BinaryWriter writer, ReadOnlySpan`1<double> values);
    [ExtensionAttribute]
public static void WriteBoolByteArray(BinaryWriter writer, ReadOnlySpan`1<bool> values);
    [ExtensionAttribute]
public static void WriteBoolBytesNoCount(BinaryWriter writer, ReadOnlySpan`1<bool> values);
    [ExtensionAttribute]
public static void WriteCharArray(BinaryWriter writer, ReadOnlySpan`1<char> values);
    [ExtensionAttribute]
public static void WriteBitArray(BinaryWriter writer, BitArray arr);
    [ExtensionAttribute]
public static long WriteSByteStream(BinaryWriter writer, IEnumerable`1<sbyte> e);
    [ExtensionAttribute]
public static long WriteByteStream(BinaryWriter writer, IEnumerable`1<byte> e);
    [ExtensionAttribute]
public static long WriteIntStream(BinaryWriter writer, IEnumerable`1<int> e);
    [ExtensionAttribute]
public static long WriteUIntStream(BinaryWriter writer, IEnumerable`1<UInt32> e);
    [ExtensionAttribute]
public static long WriteShortStream(BinaryWriter writer, IEnumerable`1<short> e);
    [ExtensionAttribute]
public static long WriteUShortStream(BinaryWriter writer, IEnumerable`1<ushort> e);
    [ExtensionAttribute]
public static long WriteLongStream(BinaryWriter writer, IEnumerable`1<long> e);
    [ExtensionAttribute]
public static long WriteULongStream(BinaryWriter writer, IEnumerable`1<long> e);
    [ExtensionAttribute]
public static long WriteSingleStream(BinaryWriter writer, IEnumerable`1<float> e);
    [ExtensionAttribute]
public static long WriteDoubleStream(BinaryWriter writer, IEnumerable`1<double> e);
    [ExtensionAttribute]
public static long WriteStringStream(BinaryWriter writer, IEnumerable`1<string> e);
    [ExtensionAttribute]
public static void WriteLeb128Int(BinaryWriter writer, ulong value);
    public static int Leb128IntLength(ulong value);
    [ExtensionAttribute]
public static long FpCur(BinaryWriter writer);
    [ExtensionAttribute]
public static void Seek(BinaryWriter writer, long fp);
    [ExtensionAttribute]
public static long FpCur(BinaryReader reader);
    [ExtensionAttribute]
public static void Seek(BinaryReader reader, long fp);
    [ExtensionAttribute]
public static bool ReadBoolByte(BinaryReader reader);
    [ExtensionAttribute]
public static float ReadFloat(BinaryReader reader);
    [ExtensionAttribute]
public static Single[] ReadFloatArray(BinaryReader reader);
    [ExtensionAttribute]
public static Single[] ReadFloatArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static void ReadFloatArray(BinaryReader reader, Single[] array, int start, int count);
    [ExtensionAttribute]
public static Single[] ReadSingleArray(BinaryReader reader);
    [ExtensionAttribute]
public static Single[] ReadSingleArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static Double[] ReadDoubleArray(BinaryReader reader);
    [ExtensionAttribute]
public static Double[] ReadDoubleArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static Int32[] ReadIntArray(BinaryReader reader);
    [ExtensionAttribute]
public static Int32[] ReadIntArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static UInt32[] ReadUIntArray(BinaryReader reader);
    [ExtensionAttribute]
public static UInt32[] ReadUIntArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static Int64[] ReadLongArray(BinaryReader reader);
    [ExtensionAttribute]
public static Int64[] ReadLongArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static Boolean[] ReadBoolArray(BinaryReader reader);
    [ExtensionAttribute]
public static Boolean[] ReadBoolArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static Char[] ReadCharArray(BinaryReader reader);
    [ExtensionAttribute]
public static Char[] ReadCharArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static Byte[] ReadByteArray(BinaryReader reader);
    [ExtensionAttribute]
public static Byte[] ReadByteArray(BinaryReader reader, int size);
    [ExtensionAttribute]
public static BitArray ReadBitArray(BinaryReader reader);
    [ExtensionAttribute]
public static void ReadBytes(BinaryReader reader, Void* destination, long destinationSizeInBytes, long bytesToRead, Byte[]& work);
    [ExtensionAttribute]
public static void ReadBytes(BinaryReader reader, Void* destination, long destinationSizeInBytes, long bytesToRead);
    [ExtensionAttribute]
public static void ReadBlock(Stream s, Byte[] buff, int offset, int length);
    [ExtensionAttribute]
public static int TryReadBlock(Stream s, Byte[] buff, int offset, int length);
    [ExtensionAttribute]
public static ulong ReadLeb128Int(BinaryReader reader);
    public static StreamWriter OpenWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public static void CheckOptionalUserDirectory(string file, string userArgument);
    public static Task RunOnBackgroundThreadAsync(Action start);
    public static Task RunOnBackgroundThreadAsync(Action`1<object> start, object obj);
    public static Thread RunOnForegroundThread(ParameterizedThreadStart start);
    [ExtensionAttribute]
public static bool StartsWithInvariantCultureIgnoreCase(string str, string startsWith);
    [ExtensionAttribute]
public static bool StartsWithInvariantCulture(string str, string startsWith);
    public static void Swap(T& a, T& b);
    public static void Reverse(T[] a, int iMin, int iLim);
    public static int Size(string x);
    public static int Size(StringBuilder x);
    public static int Size(Array x);
    public static int Size(T[] x);
    public static int Size(List`1<T> x);
    public static int Size(IList`1<T> x);
    public static int Size(IReadOnlyList`1<T> x);
    public static int Size(Stack`1<T> x);
    public static int Size(HashSet`1<T> x);
    public static int Size(SortedSet`1<T> x);
    public static int Size(Dictionary`2<TKey, TValue> x);
    public static int Size(BitArray x);
    public static bool TryGetValue(Dictionary`2<TKey, TValue> map, TKey key, TValue& value);
    public static T[] ToArray(List`1<T> list);
    public static void Add(List`1& list, T item);
    public static bool Add(HashSet`1& set, T item);
    public static void Add(Dictionary`2& map, TKey key, TValue value);
    public static void Set(Dictionary`2& map, TKey key, TValue value);
    public static void Push(Stack`1& stack, T item);
    [ExtensionAttribute]
public static void CopyTo(List`1<T> src, Span`1<T> dst, Nullable`1<int> count);
    [ExtensionAttribute]
public static int FindIndexSorted(IList`1<int> input, int value);
    [ExtensionAttribute]
public static int FindIndexSorted(IList`1<float> input, float value);
    [ExtensionAttribute]
public static int FindIndexSorted(Double[] input, double value);
    [ExtensionAttribute]
public static bool TryFindIndexSorted(Int32[] input, int min, int lim, int value, Int32& index);
    public static bool TryFindIndexSorted(ReadOnlySpan`1<int> input, int min, int lim, int value, Int32& index);
    [ExtensionAttribute]
public static int FindIndexSorted(Int32[] input, int min, int lim, int value);
    [ExtensionAttribute]
public static int FindIndexSorted(ReadOnlySpan`1<int> input, int min, int lim, int value);
    [ExtensionAttribute]
public static int FindIndexSorted(IList`1<int> input, int min, int lim, int value);
    [ExtensionAttribute]
public static int FindIndexSorted(IList`1<float> input, int min, int lim, float value);
    [ExtensionAttribute]
public static int FindIndexSorted(Double[] input, int min, int lim, double value);
    [ExtensionAttribute]
public static int FindIndexSorted(T[] input, int min, int lim, Func`2<T, bool> func);
    [ExtensionAttribute]
public static int FindIndexSorted(T[] input, int min, int lim, Func`3<T, TValue, bool> func, TValue value);
    public static Int32[] GetIdentityPermutation(int size);
    public static void FillIdentity(Span`1<int> a, int lim);
    public static void InterlockedAdd(Double& target, double v);
    public static Int32[] InvertPermutation(Int32[] perm);
    public static Int32[] GetRandomPermutation(Random rand, int size);
    public static bool AreEqual(Single[] arr1, Single[] arr2);
    public static bool AreEqual(Double[] arr1, Double[] arr2);
    public static void Shuffle(Random rand, Span`1<T> rgv);
    public static bool AreEqual(Int32[] arr1, Int32[] arr2);
    public static bool AreEqual(Boolean[] arr1, Boolean[] arr2);
    public static string ExtractLettersAndNumbers(string value);
    public static bool IsMonotonicallyIncreasing(IList`1<float> values);
    public static bool IsMonotonicallyIncreasing(IList`1<int> values);
    public static bool IsMonotonicallyIncreasing(IList`1<double> values);
    public static bool IsIncreasing(int min, ReadOnlySpan`1<int> values, int lim);
    public static bool IsIncreasing(int min, ReadOnlySpan`1<int> values, int len, int lim);
    public static T[] CreateArray(int length, T value);
    public static Boolean[] BuildArray(int length, IEnumerable`1<Column> columnsNeeded);
    public static T[] BuildArray(int length, Func`2<int, T> func);
    public static void BuildSubsetMaps(DataViewSchema schema, Func`2<Column, bool> pred, Int32[]& map, Int32[]& invMap);
    public static void BuildSubsetMaps(int lim, Func`2<int, bool> pred, Int32[]& map, Int32[]& invMap);
    public static void BuildSubsetMaps(int lim, IEnumerable`1<Column> columnsNeeded, Int32[]& map, Int32[]& invMap);
    public static T[] Concat(T[] a, T[] b);
    public static T[] Concat(T[][] arrays);
    public static int EnsureSize(T[]& array, int min, bool keepOld);
    public static int EnsureSize(T[]& array, int min, int max, bool keepOld);
    public static int EnsureSize(T[]& array, int min, int max, bool keepOld, Boolean& resized);
    public static int GetCardinality(BitArray bitArray);
    private static MethodInfo MarshalInvokeCheckAndCreate(Type genArg, Delegate func);
    public static TResult MarshalInvoke(FuncInstanceMethodInfo1`2<TTarget, TResult> func, TTarget target, Type genArg);
    public static TResult MarshalInvoke(FuncStaticMethodInfo1`1<TResult> func, Type genArg);
    public static TResult MarshalInvoke(FuncInstanceMethodInfo1`3<TTarget, TArg1, TResult> func, TTarget target, Type genArg, TArg1 arg1);
    public static TResult MarshalInvoke(FuncStaticMethodInfo1`2<TArg1, TResult> func, Type genArg, TArg1 arg1);
    public static TResult MarshalInvoke(FuncInstanceMethodInfo3`3<TTarget, TArg1, TResult> func, TTarget target, Type genArg1, Type genArg2, Type genArg3, TArg1 arg1);
    public static TResult MarshalInvoke(FuncStaticMethodInfo3`2<TArg1, TResult> func, Type genArg1, Type genArg2, Type genArg3, TArg1 arg1);
    public static TResult MarshalInvoke(FuncInstanceMethodInfo1`4<TTarget, TArg1, TArg2, TResult> func, TTarget target, Type genArg, TArg1 arg1, TArg2 arg2);
    public static TResult MarshalInvoke(FuncStaticMethodInfo1`3<TArg1, TArg2, TResult> func, Type genArg, TArg1 arg1, TArg2 arg2);
    public static TResult MarshalInvoke(FuncInstanceMethodInfo2`4<TTarget, TArg1, TArg2, TResult> func, TTarget target, Type genArg1, Type genArg2, TArg1 arg1, TArg2 arg2);
    public static TResult MarshalInvoke(FuncStaticMethodInfo2`3<TArg1, TArg2, TResult> func, Type genArg1, Type genArg2, TArg1 arg1, TArg2 arg2);
    public static TResult MarshalInvoke(FuncInstanceMethodInfo3`4<TTarget, TArg1, TArg2, TResult> func, TTarget target, Type genArg1, Type genArg2, Type genArg3, TArg1 arg1, TArg2 arg2);
    public static TResult MarshalInvoke(FuncStaticMethodInfo3`3<TArg1, TArg2, TResult> func, Type genArg1, Type genArg2, Type genArg3, TArg1 arg1, TArg2 arg2);
    public static TRet MarshalInvoke(Func`4<TArg1, TArg2, TArg3, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static TRet MarshalInvoke(Func`5<TArg1, TArg2, TArg3, TArg4, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4);
    public static TRet MarshalInvoke(Func`6<TArg1, TArg2, TArg3, TArg4, TArg5, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5);
    public static TRet MarshalInvoke(Func`7<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6);
    public static TRet MarshalInvoke(Func`8<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7);
    public static TRet MarshalInvoke(Func`9<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8);
    public static TRet MarshalInvoke(Func`10<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9);
    public static TRet MarshalInvoke(Func`11<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6, TArg7, TArg8, TArg9, TArg10, TRet> func, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6, TArg7 arg7, TArg8 arg8, TArg9 arg9, TArg10 arg10);
    private static MethodInfo MarshalActionInvokeCheckAndCreate(Type genArg, Delegate func);
    public static void MarshalActionInvoke(Action act, Type genArg);
    public static void MarshalActionInvoke(Action`1<TArg1> act, Type genArg, TArg1 arg1);
    public static void MarshalActionInvoke(Action`2<TArg1, TArg2> act, Type genArg, TArg1 arg1, TArg2 arg2);
    public static void MarshalActionInvoke(Action`3<TArg1, TArg2, TArg3> act, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static void MarshalActionInvoke(Action`4<TArg1, TArg2, TArg3, TArg4> act, Type genArg, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4);
    [ExtensionAttribute]
public static string GetDescription(Enum value);
    [ExtensionAttribute]
public static int Count(ReadOnlySpan`1<TSource> source, Func`2<TSource, bool> predicate);
    [ExtensionAttribute]
public static bool All(ReadOnlySpan`1<TSource> source, Func`2<TSource, bool> predicate);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.VBufferUtils : object {
    private static float SparsityThreshold;
    public static bool HasNaNs(VBuffer`1& buffer);
    public static bool HasNaNs(VBuffer`1& buffer);
    public static bool HasNonFinite(VBuffer`1& buffer);
    public static bool HasNonFinite(VBuffer`1& buffer);
    public static VBuffer`1<T> CreateEmpty(int length);
    public static VBuffer`1<T> CreateDense(int length);
    public static void ForEachDefined(VBuffer`1& a, Action`2<int, T> visitor);
    public static void ForEachBothDefined(VBuffer`1& a, VBuffer`1& b, Action`3<int, T, T> visitor);
    public static void ForEachEitherDefined(VBuffer`1& a, VBuffer`1& b, Action`3<int, T, T> visitor);
    public static void Clear(VBuffer`1& dst);
    public static void Apply(VBuffer`1& dst, SlotValueManipulator`1<T> manip);
    public static void ApplyAt(VBuffer`1& dst, int slot, SlotValueManipulator`1<T> manip, ValuePredicate`1<T> pred);
    public static void Densify(VBuffer`1& dst);
    public static void DensifyFirst(VBuffer`1& dst, int denseCount);
    public static void CreateMaybeSparseCopy(VBuffer`1& src, VBuffer`1& dst, InPredicate`1<T> isDefaultPredicate, float sparsityThreshold);
    public static void ApplyWith(VBuffer`1& src, VBuffer`1& dst, PairManipulator`2<TSrc, TDst> manip);
    public static void ApplyWithCopy(VBuffer`1& src, VBuffer`1& dst, VBuffer`1& res, PairManipulatorCopy`2<TSrc, TDst> manip);
    public static void ApplyWithEitherDefined(VBuffer`1& src, VBuffer`1& dst, PairManipulator`2<TSrc, TDst> manip);
    public static void ApplyWithEitherDefinedCopy(VBuffer`1& src, VBuffer`1& dst, VBuffer`1& res, PairManipulatorCopy`2<TSrc, TDst> manip);
    private static void ApplyWithCore(VBuffer`1& src, VBuffer`1& dst, PairManipulator`2<TSrc, TDst> manip, bool outer);
    private static void ApplyWithCoreCopy(VBuffer`1& src, VBuffer`1& dst, VBuffer`1& res, PairManipulatorCopy`2<TSrc, TDst> manip, bool outer);
    public static void ApplyIntoEitherDefined(VBuffer`1& src, VBuffer`1& dst, Func`3<int, TSrc, TDst> func);
    public static void ApplyInto(VBuffer`1& a, VBuffer`1& b, VBuffer`1& dst, Func`4<int, TSrc1, TSrc2, TDst> func);
    public static void Copy(List`1<T> src, VBuffer`1& dst, int length);
    public static void Resize(VBuffer`1& dst, int newLogicalLength, Nullable`1<int> valuesCount);
}
[BestFriendAttribute]
internal static class Microsoft.ML.InternalPublicKey : object {
    public static string Value;
}
[BestFriendAttribute]
internal interface Microsoft.ML.IPredictor {
    public PredictionKind PredictionKind { get; }
    public abstract virtual PredictionKind get_PredictionKind();
}
[BestFriendAttribute]
internal interface Microsoft.ML.IPredictorProducing`1 {
}
[BestFriendAttribute]
internal interface Microsoft.ML.ITrainer {
    public TrainerInfo Info { get; }
    public PredictionKind PredictionKind { get; }
    public abstract virtual TrainerInfo get_Info();
    public abstract virtual PredictionKind get_PredictionKind();
    public abstract virtual IPredictor Train(TrainContext context);
}
[BestFriendAttribute]
internal interface Microsoft.ML.ITrainer`1 {
    public abstract virtual TPredictor Train(TrainContext context);
}
public interface Microsoft.ML.ITransformer {
    public bool IsRowToRowMapper { get; }
    public abstract virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public abstract virtual IDataView Transform(IDataView input);
    public abstract virtual bool get_IsRowToRowMapper();
    public abstract virtual IRowToRowMapper GetRowToRowMapper(DataViewSchema inputSchema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.ITransformerWithDifferentMappingAtTrainingTime {
    public abstract virtual IDataView TransformForTrainingPipeline(IDataView input);
}
[AttributeUsageAttribute("1")]
[BestFriendAttribute]
internal class Microsoft.ML.LoadableClassAttribute : LoadableClassAttributeBase {
    public LoadableClassAttribute(Type instType, Type argType, Type sigType, string userName, String[] loadNames);
    public LoadableClassAttribute(Type instType, Type loaderType, Type argType, Type sigType, string userName, String[] loadNames);
    public LoadableClassAttribute(Type instType, Type argType, Type[] sigTypes, string userName, String[] loadNames);
    public LoadableClassAttribute(Type instType, Type loaderType, Type argType, Type[] sigTypes, string userName, String[] loadNames);
    public LoadableClassAttribute(string summary, Type instType, Type argType, Type sigType, string userName, String[] loadNames);
    public LoadableClassAttribute(string summary, Type instType, Type loaderType, Type argType, Type sigType, string userName, String[] loadNames);
    public LoadableClassAttribute(string summary, Type instType, Type argType, Type[] sigTypes, string userName, String[] loadNames);
    public LoadableClassAttribute(string summary, Type instType, Type loaderType, Type argType, Type[] sigTypes, string userName, String[] loadNames);
}
internal abstract class Microsoft.ML.LoadableClassAttributeBase : Attribute {
    [CompilerGeneratedAttribute]
private Type <InstanceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LoaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ArgType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <SigTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <CtorTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <LoadNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocName>k__BackingField;
    public Type InstanceType { get; private set; }
    public Type LoaderType { get; private set; }
    public Type ArgType { get; private set; }
    public Type[] SigTypes { get; private set; }
    public Type[] CtorTypes { get; private set; }
    public string Summary { get; private set; }
    public string UserName { get; private set; }
    public String[] LoadNames { get; private set; }
    public string DocName { get; public set; }
    protected LoadableClassAttributeBase(string summary, Type instType, Type loaderType, Type argType, Type[] sigTypes, string userName, String[] loadNames);
    [CompilerGeneratedAttribute]
public Type get_InstanceType();
    [CompilerGeneratedAttribute]
private void set_InstanceType(Type value);
    [CompilerGeneratedAttribute]
public Type get_LoaderType();
    [CompilerGeneratedAttribute]
private void set_LoaderType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ArgType();
    [CompilerGeneratedAttribute]
private void set_ArgType(Type value);
    [CompilerGeneratedAttribute]
public Type[] get_SigTypes();
    [CompilerGeneratedAttribute]
private void set_SigTypes(Type[] value);
    [CompilerGeneratedAttribute]
public Type[] get_CtorTypes();
    [CompilerGeneratedAttribute]
private void set_CtorTypes(Type[] value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
private void set_Summary(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
private void set_UserName(string value);
    [CompilerGeneratedAttribute]
public String[] get_LoadNames();
    [CompilerGeneratedAttribute]
private void set_LoadNames(String[] value);
    [CompilerGeneratedAttribute]
public string get_DocName();
    [CompilerGeneratedAttribute]
public void set_DocName(string value);
}
[BestFriendAttribute]
internal class Microsoft.ML.ModelHeader : ValueType {
    public static ulong SignatureValue;
    public static ulong TailSignatureValue;
    private static UInt32 VerAssemblyNameSupported;
    private static UInt32 VerWrittenCur;
    private static UInt32 VerReadableCur;
    private static UInt32 VerWeCanReadBack;
    public ulong Signature;
    public UInt32 VerWritten;
    public UInt32 VerReadable;
    public long FpModel;
    public long CbModel;
    public long FpStringTable;
    public long CbStringTable;
    public long FpStringChars;
    public long CbStringChars;
    public ulong ModelSignature;
    public UInt32 ModelVerWritten;
    public UInt32 ModelVerReadable;
    public ulong LoaderSignature0;
    public ulong LoaderSignature1;
    public ulong LoaderSignature2;
    public ulong LoaderSignatureAlt0;
    public ulong LoaderSignatureAlt1;
    public ulong LoaderSignatureAlt2;
    public long FpTail;
    public long FpLim;
    public long FpAssemblyName;
    public UInt32 CbAssemblyName;
    public static int Size;
    public static void BeginWrite(BinaryWriter writer, Int64& fpMin, ModelHeader& header);
    public static void EndWrite(BinaryWriter writer, long fpMin, ModelHeader& header, Pool pool, string loaderAssemblyName);
    private static void WriteLoaderAssemblyName(BinaryWriter writer, long fpMin, ModelHeader& header, string loaderAssemblyName);
    public static void WriteHeaderAndTailCore(BinaryWriter writer, long fpMin, ModelHeader& header);
    public static void EndModelCore(BinaryWriter writer, long fpMin, ModelHeader& header);
    public static void SetVersionInfo(ModelHeader& header, VersionInfo ver);
    public static void SetLoaderSig(ModelHeader& header, string sig);
    public static void SetLoaderSigAlt(ModelHeader& header, string sig);
    public static void MarshalToBytes(ModelHeader& header, Byte[] bytes);
    public static void BeginRead(Int64& fpMin, ModelHeader& header, String[]& strings, String& loaderAssemblyName, BinaryReader reader);
    public static void EndRead(long fpMin, ModelHeader& header, BinaryReader reader);
    public static void CheckVersionInfo(ModelHeader& header, VersionInfo ver);
    public static void MarshalFromBytes(ModelHeader& header, Byte[] bytes);
    public static bool TryValidate(ModelHeader& header, long size, Exception& ex);
    public static bool TryValidate(ModelHeader& header, BinaryReader reader, long fpMin, String[]& strings, String& loaderAssemblyName, Exception& ex);
    public static string GetLoaderSig(ModelHeader& header);
    public static string GetLoaderSigAlt(ModelHeader& header);
}
[BestFriendAttribute]
internal class Microsoft.ML.ModelLoadContext : object {
    public RepositoryReader Repository;
    public string Directory;
    public BinaryReader Reader;
    public String[] Strings;
    public string LoaderAssemblyName;
    [BestFriendAttribute]
internal ModelHeader Header;
    public long FpMin;
    private IExceptionContext _ectx;
    public static string ModelStreamName;
    internal static string NameBinary;
    public bool InRepository { get; }
    private string ForwardedLoaderAssemblyName { get; }
    internal ModelLoadContext(RepositoryReader rep, Entry ent, string dir);
    internal ModelLoadContext(BinaryReader reader, IExceptionContext ectx);
    public bool get_InRepository();
    public void CheckAtModel();
    public void CheckAtModel(VersionInfo ver);
    public void CheckVersionInfo(VersionInfo ver);
    public string LoadStringOrNull();
    public string LoadString();
    public string LoadNonEmptyString();
    public void Done();
    public sealed virtual void Dispose();
    private string get_ForwardedLoaderAssemblyName();
    public bool ContainsModel(string name);
    public static bool LoadModelOrNull(IHostEnvironment env, TRes& result, RepositoryReader rep, string dir, Object[] extra);
    public static void LoadModel(IHostEnvironment env, TRes& result, RepositoryReader rep, string dir, Object[] extra);
    public bool LoadModelOrNull(IHostEnvironment env, TRes& result, string name, Object[] extra);
    public void LoadModel(IHostEnvironment env, TRes& result, string name, Object[] extra);
    private static bool TryLoadModel(IHostEnvironment env, TRes& result, RepositoryReader rep, Entry ent, string dir, Object[] extra);
    public static void LoadModel(IHostEnvironment env, TRes& result, RepositoryReader rep, Entry ent, string dir, Object[] extra);
    public static bool TryLoadModel(IHostEnvironment env, TRes& result, Stream stream, Object[] extra);
    public static void LoadModel(IHostEnvironment env, TRes& result, Stream stream, Object[] extra);
    public static bool TryLoadModel(IHostEnvironment env, TRes& result, BinaryReader reader, Object[] extra);
    public static void LoadModel(IHostEnvironment env, TRes& result, BinaryReader reader, Object[] extra);
    private bool TryLoadModelCore(IHostEnvironment env, TRes& result, Object[] extra);
    private void EnsureLoaderAssemblyIsRegistered(ComponentCatalog catalog);
    private static Object[] ConcatArgsRev(Object[] args2, Object[] args1);
    public bool TryProcessSubModel(string dir, Action`1<ModelLoadContext> action);
    public bool TryLoadBinaryStream(string name, Action`1<BinaryReader> action);
    public bool TryLoadTextStream(string name, Action`1<TextReader> action);
}
public class Microsoft.ML.ModelSaveContext : object {
    [BestFriendAttribute]
internal RepositoryWriter Repository;
    [BestFriendAttribute]
internal string Directory;
    [BestFriendAttribute]
internal BinaryWriter Writer;
    [BestFriendAttribute]
internal Pool Strings;
    [BestFriendAttribute]
internal ModelHeader Header;
    [BestFriendAttribute]
internal long FpMin;
    private Entry _ent;
    private IExceptionContext _ectx;
    private string _loaderAssemblyName;
    [BestFriendAttribute]
internal bool InRepository { get; }
    internal ModelSaveContext(RepositoryWriter rep, string dir, string name);
    internal ModelSaveContext(BinaryWriter writer, IExceptionContext ectx);
    internal bool get_InRepository();
    [BestFriendAttribute]
internal void CheckAtModel();
    [BestFriendAttribute]
internal void SetVersionInfo(VersionInfo ver);
    [BestFriendAttribute]
internal void SaveTextStream(string name, Action`1<TextWriter> action);
    [BestFriendAttribute]
internal void SaveBinaryStream(string name, Action`1<BinaryWriter> action);
    [BestFriendAttribute]
internal void SaveStringOrNull(string str);
    [BestFriendAttribute]
internal void SaveString(string str);
    [BestFriendAttribute]
internal void SaveString(ReadOnlyMemory`1<char> str);
    [BestFriendAttribute]
internal void SaveNonEmptyString(string str);
    [BestFriendAttribute]
internal void SaveNonEmptyString(ReadOnlyMemory`1<char> str);
    [BestFriendAttribute]
internal void Done();
    public sealed virtual void Dispose();
    [BestFriendAttribute]
internal void SaveModel(T value, string name);
    [BestFriendAttribute]
internal static void SaveModel(RepositoryWriter rep, T value, string path);
    [BestFriendAttribute]
internal static void Save(BinaryWriter writer, Action`1<ModelSaveContext> fn);
    [BestFriendAttribute]
internal void SaveSubModel(string dir, Action`1<ModelSaveContext> fn);
}
[BestFriendAttribute]
internal enum Microsoft.ML.PredictionKind : Enum {
    public int value__;
    public static PredictionKind Unknown;
    public static PredictionKind Custom;
    public static PredictionKind BinaryClassification;
    public static PredictionKind MulticlassClassification;
    public static PredictionKind Regression;
    public static PredictionKind MultiOutputRegression;
    public static PredictionKind Ranking;
    public static PredictionKind Recommendation;
    public static PredictionKind AnomalyDetection;
    public static PredictionKind Clustering;
    public static PredictionKind SequenceClassification;
}
[BestFriendAttribute]
internal static class Microsoft.ML.PublicKey : object {
    public static string Value;
    public static string TestValue;
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.RandomUtils : object {
    [ExtensionAttribute]
public static float NextSingle(Random random);
    [ExtensionAttribute]
public static int NextSigned(Random random);
    public static TauswortheHybrid Create();
    public static TauswortheHybrid Create(Nullable`1<int> seed);
    public static TauswortheHybrid Create(int seed);
    public static TauswortheHybrid Create(Nullable`1<UInt32> seed);
    public static TauswortheHybrid Create(UInt32 seed);
    public static TauswortheHybrid Create(Random seed);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Repository : object {
    private List`1<Entry> _open;
    private bool _disposed;
    private IExceptionContext _ectx;
    protected string DirTemp;
    protected ConcurrentDictionary`2<string, string> PathMap;
    public IExceptionContext ExceptionContext { get; }
    protected bool Disposed { get; }
    internal Repository(bool needDir, IExceptionContext ectx);
    public IExceptionContext get_ExceptionContext();
    protected bool get_Disposed();
    private static string GetShortTempDir(IExceptionContext ectx);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected void DisposeAllEntries();
    protected void RemoveEntry(Entry ent);
    protected abstract virtual void OnDispose(Entry ent);
    protected static string NormalizeForArchiveEntry(string path);
    private static string NormalizeForFileSystem(string path);
    protected void GetPath(String& pathEnt, String& pathTemp, string dir, string name, bool createDir);
    protected Entry AddEntry(string pathEnt, Stream stream);
}
[BestFriendAttribute]
internal class Microsoft.ML.RepositoryReader : Repository {
    private ZipArchive _archive;
    private Dictionary`2<string, ZipArchiveEntry> _entries;
    private RepositoryReader(Stream stream, IExceptionContext ectx, bool useFileSystem);
    public static RepositoryReader Open(Stream stream, IExceptionContext ectx, bool useFileSystem);
    public Entry OpenEntry(string name);
    public Entry OpenEntry(string dir, string name);
    public Entry OpenEntryOrNull(string name);
    public Entry OpenEntryOrNull(string dir, string name);
    protected virtual void OnDispose(Entry ent);
}
[BestFriendAttribute]
internal class Microsoft.ML.RepositoryWriter : Repository {
    private static string DirTrainingInfo;
    private ZipArchive _archive;
    private Queue`1<KeyValuePair`2<string, Stream>> _closed;
    private RepositoryWriter(Stream stream, IExceptionContext ectx, bool useFileSystem);
    public static RepositoryWriter CreateNew(Stream stream, IExceptionContext ectx, bool useFileSystem);
    public Entry CreateEntry(string name);
    public Entry CreateEntry(string dir, string name);
    protected virtual void OnDispose(Entry ent);
    protected virtual void Dispose(bool disposing);
    private void Flush();
    public void Commit();
    private static string GetProductVersion();
}
[ObsoleteAttribute("The usage for this is intended for the internal command line utilities and is not intended for anything related to the API. Please consider another way of doing whatever it is you're attempting to accomplish.")]
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.AssemblyLoadingUtils : object {
    private static String[] _filePrefixesToAvoid;
    private static AssemblyLoadingUtils();
    public static void LoadAndRegister(IHostEnvironment env, String[] assemblies);
    public static IDisposable CreateAssemblyRegistrar(IHostEnvironment env, string loadAssembliesPath);
    public static void RegisterCurrentLoadedAssemblies(IHostEnvironment env);
    private static string CreateTempDirectory();
    private static string GetTempPath();
    private static bool ShouldSkipPath(string path);
    private static void LoadAssembliesInDir(IHostEnvironment env, string dir, bool filter);
    private static Assembly LoadAssembly(IHostEnvironment env, string path);
    private static bool CanContainComponents(Assembly assembly);
    private static void TryRegisterAssembly(ComponentCatalog catalog, Assembly assembly);
}
[IsReadOnlyAttribute]
public class Microsoft.ML.Runtime.ChannelMessage : ValueType {
    public ChannelMessageKind Kind;
    public MessageSensitivity Sensitivity;
    private string _message;
    private Object[] _args;
    public string Message { get; }
    [BestFriendAttribute]
internal ChannelMessage(ChannelMessageKind kind, MessageSensitivity sensitivity, string message);
    [BestFriendAttribute]
internal ChannelMessage(ChannelMessageKind kind, MessageSensitivity sensitivity, string fmt, Object[] args);
    public string get_Message();
}
public enum Microsoft.ML.Runtime.ChannelMessageKind : Enum {
    public int value__;
    public static ChannelMessageKind Trace;
    public static ChannelMessageKind Info;
    public static ChannelMessageKind Warning;
    public static ChannelMessageKind Error;
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Runtime.ChannelProviderBase : object {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    public string ShortName { get; }
    public string ParentFullName { get; }
    public string FullName { get; }
    public bool Verbose { get; }
    public int Depth { get; }
    public string ContextDescription { get; }
    protected ChannelProviderBase(string shortName, string parentFullName, bool verbose);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ShortName();
    [CompilerGeneratedAttribute]
public string get_ParentFullName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_FullName();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Verbose();
    public abstract virtual int get_Depth();
    public virtual string get_ContextDescription();
    protected virtual string GenerateFullName();
    public virtual TException Process(TException ex);
}
public class Microsoft.ML.Runtime.ComponentCatalog : object {
    private object _lock;
    private HashSet`1<string> _cachedAssemblies;
    private Dictionary`2<Key, LoadableClassInfo> _classesByKey;
    private List`1<LoadableClassInfo> _classes;
    private Dictionary`2<Type, bool> _signatures;
    private List`1<EntryPointInfo> _entryPoints;
    private Dictionary`2<string, EntryPointInfo> _entryPointMap;
    private List`1<ComponentInfo> _components;
    private Dictionary`2<string, ComponentInfo> _componentMap;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, string>, Type> _extensionsMap;
    private static Regex _nameRegex;
    private static ComponentCatalog();
    private static bool TryGetIniters(Type instType, Type loaderType, Type[] parmTypes, MethodInfo& getter, ConstructorInfo& ctor, MethodInfo& create, Boolean& requireEnvironment);
    private void AddClass(LoadableClassInfo info, String[] loadNames, bool throwOnError);
    private void ScanForEntryPoints(LoadableClassInfo info);
    private bool ScanForComponents(Type nestedType);
    private static MethodInfo FindInstanceGetter(Type instType, Type loaderType);
    private static MethodInfo FindCreateMethod(Type instType, Type loaderType, Type[] parmTypes);
    public void RegisterAssembly(Assembly assembly, bool throwOnError);
    [BestFriendAttribute]
internal LoadableClassInfo[] GetAllClasses();
    [BestFriendAttribute]
internal LoadableClassInfo[] GetAllDerivedClasses(Type typeBase, Type typeSig);
    [BestFriendAttribute]
internal Type[] GetAllSignatureTypes();
    [BestFriendAttribute]
internal static string SignatureToString(Type sig);
    private LoadableClassInfo FindClassCore(Key key);
    [BestFriendAttribute]
internal LoadableClassInfo[] FindLoadableClasses(string name);
    [BestFriendAttribute]
internal LoadableClassInfo[] FindLoadableClasses();
    [BestFriendAttribute]
internal LoadableClassInfo[] FindLoadableClasses();
    [BestFriendAttribute]
internal LoadableClassInfo GetLoadableClassInfo(string loadName);
    [BestFriendAttribute]
internal LoadableClassInfo GetLoadableClassInfo(string loadName, Type signatureType);
    [BestFriendAttribute]
internal IEnumerable`1<EntryPointInfo> AllEntryPoints();
    [BestFriendAttribute]
internal bool TryFindEntryPoint(string name, EntryPointInfo& entryPoint);
    [BestFriendAttribute]
internal bool TryFindComponent(string kind, string alias, ComponentInfo& component);
    [BestFriendAttribute]
internal bool TryFindComponent(Type argumentType, ComponentInfo& component);
    [BestFriendAttribute]
internal bool TryFindComponent(Type interfaceType, Type argumentType, ComponentInfo& component);
    [BestFriendAttribute]
internal bool TryFindComponent(Type interfaceType, string alias, ComponentInfo& component);
    [BestFriendAttribute]
internal bool TryFindComponentCaseInsensitive(Type interfaceType, string alias, ComponentInfo& component);
    private static bool AnyMatch(string name, String[] aliases);
    [BestFriendAttribute]
internal IEnumerable`1<string> GetAllComponentKinds();
    [BestFriendAttribute]
internal IEnumerable`1<ComponentInfo> GetAllComponents(string kind);
    [BestFriendAttribute]
internal IEnumerable`1<ComponentInfo> GetAllComponents(Type interfaceType);
    [BestFriendAttribute]
internal bool TryGetComponentKind(Type signatureType, String& kind);
    [BestFriendAttribute]
internal bool TryGetComponentShortName(Type type, String& name);
    private static bool IsValidName(string name);
    [BestFriendAttribute]
internal static TRes CreateInstance(IHostEnvironment env, Type signatureType, string name, string options, Object[] extra);
    [BestFriendAttribute]
internal static bool TryCreateInstance(IHostEnvironment env, TRes& result, string name, string options, Object[] extra);
    [BestFriendAttribute]
internal static bool TryCreateInstance(IHostEnvironment env, Type signatureType, TRes& result, string name, string options, Object[] extra);
    private static void ParseArguments(IHostEnvironment env, object args, string settings, string name);
    private void LoadExtensions(Assembly assembly, bool throwOnError);
    private static bool CanContainExtensions(Assembly assembly);
    private static bool HasMLNetPublicKey(Assembly assembly);
    [BestFriendAttribute]
internal object GetExtensionValue(IHostEnvironment env, Type attributeType, string contractName);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.ComponentFactoryUtils : object {
    public static IComponentFactory`1<TComponent> CreateFromFunction(Func`2<IHostEnvironment, TComponent> factory);
    public static IComponentFactory`2<TArg1, TComponent> CreateFromFunction(Func`3<IHostEnvironment, TArg1, TComponent> factory);
    public static IComponentFactory`3<TArg1, TArg2, TComponent> CreateFromFunction(Func`4<IHostEnvironment, TArg1, TArg2, TComponent> factory);
    public static IComponentFactory`4<TArg1, TArg2, TArg3, TComponent> CreateFromFunction(Func`5<IHostEnvironment, TArg1, TArg2, TArg3, TComponent> factory);
}
[BestFriendAttribute]
internal class Microsoft.ML.Runtime.ConsoleEnvironment : HostEnvironmentBase`1<ConsoleEnvironment> {
    public static string ComponentHistoryKey;
    private ConsoleWriter modreq(System.Runtime.CompilerServices.IsVolatile) _consoleWriter;
    private MessageSensitivity _sensitivityFlags;
    private TextWriter _testWriter;
    public ConsoleEnvironment(Nullable`1<int> seed, bool verbose, MessageSensitivity sensitivity, TextWriter outWriter, TextWriter errWriter, TextWriter testWriter);
    public void PrintProgress();
    private void PrintMessage(IMessageSource src, ChannelMessage msg);
    protected virtual IHost RegisterCore(HostEnvironmentBase`1<ConsoleEnvironment> source, string shortName, string parentFullName, Random rand, bool verbose);
    protected virtual IChannel CreateCommChannel(ChannelProviderBase parent, string name);
    protected virtual IPipe`1<TMessage> CreatePipe(ChannelProviderBase parent, string name);
    internal IDisposable RedirectChannelOutput(TextWriter newOutWriter, TextWriter newErrWriter);
    internal void ResetProgressChannel();
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.Contracts : object {
    public static string IsMarkedKey;
    public static string SensitivityKey;
    private static Action`2 modreq(System.Runtime.CompilerServices.IsVolatile) _handler;
    private static string GetMsg(string msg, Object[] args);
    private static int Size(ICollection`1<T> c);
    [ExtensionAttribute]
public static TException Process(TException ex, IExceptionContext ectx);
    public static TException Mark(TException ex);
    [ExtensionAttribute]
public static bool IsMarked(Exception ex);
    [ExtensionAttribute]
public static TException MarkSensitive(TException ex, MessageSensitivity sensitivity);
    [ExtensionAttribute]
public static MessageSensitivity Sensitivity(Exception ex);
    public static IExceptionContext NotSensitive();
    [ExtensionAttribute]
public static IExceptionContext NotSensitive(IExceptionContext ctx);
    public static IExceptionContext UserSensitive();
    [ExtensionAttribute]
public static IExceptionContext UserSensitive(IExceptionContext ctx);
    public static IExceptionContext SchemaSensitive();
    [ExtensionAttribute]
public static IExceptionContext SchemaSensitive(IExceptionContext ctx);
    public static Action`2<string, IExceptionContext> SetAssertHandler(Action`2<string, IExceptionContext> handler);
    public static Exception Except();
    [ExtensionAttribute]
public static Exception Except(IExceptionContext ctx);
    public static Exception Except(string msg);
    [ExtensionAttribute]
public static Exception Except(IExceptionContext ctx, string msg);
    public static Exception Except(string msg, Object[] args);
    [ExtensionAttribute]
public static Exception Except(IExceptionContext ctx, string msg, Object[] args);
    public static Exception Except(Exception inner, string msg);
    [ExtensionAttribute]
public static Exception Except(IExceptionContext ctx, Exception inner, string msg);
    public static Exception Except(Exception inner, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception Except(IExceptionContext ctx, Exception inner, string msg, Object[] args);
    public static Exception ExceptUserArg(string name);
    [ExtensionAttribute]
public static Exception ExceptUserArg(IExceptionContext ctx, string name);
    public static Exception ExceptUserArg(string name, string msg);
    [ExtensionAttribute]
public static Exception ExceptUserArg(IExceptionContext ctx, string name, string msg);
    public static Exception ExceptUserArg(string name, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptUserArg(IExceptionContext ctx, string name, string msg, Object[] args);
    public static Exception ExceptParam(string paramName);
    [ExtensionAttribute]
public static Exception ExceptParam(IExceptionContext ctx, string paramName);
    public static Exception ExceptParam(string paramName, string msg);
    [ExtensionAttribute]
public static Exception ExceptParam(IExceptionContext ctx, string paramName, string msg);
    public static Exception ExceptParam(string paramName, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptParam(IExceptionContext ctx, string paramName, string msg, Object[] args);
    public static Exception ExceptParamValue(T value, string paramName, string msg);
    [ExtensionAttribute]
public static Exception ExceptParamValue(IExceptionContext ctx, T value, string paramName, string msg);
    public static Exception ExceptParamValue(T value, string paramName, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptParamValue(IExceptionContext ctx, T value, string paramName, string msg, Object[] args);
    public static Exception ExceptValue(string paramName);
    [ExtensionAttribute]
public static Exception ExceptValue(IExceptionContext ctx, string paramName);
    public static Exception ExceptValue(string paramName, string msg);
    [ExtensionAttribute]
public static Exception ExceptValue(IExceptionContext ctx, string paramName, string msg);
    public static Exception ExceptValue(string paramName, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptValue(IExceptionContext ctx, string paramName, string msg, Object[] args);
    public static Exception ExceptEmpty(string paramName);
    [ExtensionAttribute]
public static Exception ExceptEmpty(IExceptionContext ctx, string paramName);
    public static Exception ExceptEmpty(string paramName, string msg);
    [ExtensionAttribute]
public static Exception ExceptEmpty(IExceptionContext ctx, string paramName, string msg);
    public static Exception ExceptEmpty(string paramName, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptEmpty(IExceptionContext ctx, string paramName, string msg, Object[] args);
    public static Exception ExceptWhiteSpace(string paramName);
    [ExtensionAttribute]
public static Exception ExceptWhiteSpace(IExceptionContext ctx, string paramName);
    public static Exception ExceptWhiteSpace(string paramName, string msg);
    [ExtensionAttribute]
public static Exception ExceptWhiteSpace(IExceptionContext ctx, string paramName, string msg);
    public static Exception ExceptDecode();
    [ExtensionAttribute]
public static Exception ExceptDecode(IExceptionContext ctx);
    public static Exception ExceptDecode(string msg);
    [ExtensionAttribute]
public static Exception ExceptDecode(IExceptionContext ctx, string msg);
    public static Exception ExceptDecode(string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptDecode(IExceptionContext ctx, string msg, Object[] args);
    public static Exception ExceptDecode(Exception inner, string msg);
    [ExtensionAttribute]
public static Exception ExceptDecode(IExceptionContext ctx, Exception inner, string msg);
    public static Exception ExceptDecode(Exception inner, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptDecode(IExceptionContext ctx, Exception inner, string msg, Object[] args);
    public static Exception ExceptIO();
    [ExtensionAttribute]
public static Exception ExceptIO(IExceptionContext ctx);
    public static Exception ExceptIO(string msg);
    [ExtensionAttribute]
public static Exception ExceptIO(IExceptionContext ctx, string msg);
    public static Exception ExceptIO(string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptIO(IExceptionContext ctx, string msg, Object[] args);
    public static Exception ExceptIO(Exception inner, string msg);
    [ExtensionAttribute]
public static Exception ExceptIO(IExceptionContext ctx, Exception inner, string msg);
    public static Exception ExceptIO(Exception inner, string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptIO(IExceptionContext ctx, Exception inner, string msg, Object[] args);
    public static Exception ExceptNotImpl();
    [ExtensionAttribute]
public static Exception ExceptNotImpl(IExceptionContext ctx);
    public static Exception ExceptNotImpl(string msg);
    [ExtensionAttribute]
public static Exception ExceptNotImpl(IExceptionContext ctx, string msg);
    public static Exception ExceptNotImpl(string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptNotImpl(IExceptionContext ctx, string msg, Object[] args);
    public static Exception ExceptNotSupp();
    [ExtensionAttribute]
public static Exception ExceptNotSupp(IExceptionContext ctx);
    public static Exception ExceptNotSupp(string msg);
    [ExtensionAttribute]
public static Exception ExceptNotSupp(IExceptionContext ctx, string msg);
    public static Exception ExceptNotSupp(string msg, Object[] args);
    [ExtensionAttribute]
public static Exception ExceptNotSupp(IExceptionContext ctx, string msg, Object[] args);
    public static Exception ExceptSchemaMismatch(string paramName, string columnRole, string columnName);
    [ExtensionAttribute]
public static Exception ExceptSchemaMismatch(IExceptionContext ctx, string paramName, string columnRole, string columnName);
    public static Exception ExceptSchemaMismatch(string paramName, string columnRole, string columnName, string expectedType, string actualType);
    [ExtensionAttribute]
public static Exception ExceptSchemaMismatch(IExceptionContext ctx, string paramName, string columnRole, string columnName, string expectedType, string actualType);
    private static string MakeSchemaMismatchMsg(string columnRole, string columnName, string expectedType, string actualType);
    public static void Check(bool f);
    [ExtensionAttribute]
public static void Check(IExceptionContext ctx, bool f);
    public static void Check(bool f, string msg);
    [ExtensionAttribute]
public static void Check(IExceptionContext ctx, bool f, string msg);
    public static void CheckUserArg(bool f, string name);
    [ExtensionAttribute]
public static void CheckUserArg(IExceptionContext ctx, bool f, string name);
    public static void CheckUserArg(bool f, string name, string msg);
    [ExtensionAttribute]
public static void CheckUserArg(IExceptionContext ctx, bool f, string name, string msg);
    public static void CheckParam(bool f, string paramName);
    [ExtensionAttribute]
public static void CheckParam(IExceptionContext ctx, bool f, string paramName);
    public static void CheckParam(bool f, string paramName, string msg);
    [ExtensionAttribute]
public static void CheckParam(IExceptionContext ctx, bool f, string paramName, string msg);
    public static void CheckParamValue(bool f, T value, string paramName, string msg);
    [ExtensionAttribute]
public static void CheckParamValue(IExceptionContext ctx, bool f, T value, string paramName, string msg);
    public static T CheckRef(T val, string paramName);
    [ExtensionAttribute]
public static T CheckRef(IExceptionContext ctx, T val, string paramName);
    [ExtensionAttribute]
public static T CheckRef(IExceptionContext ctx, T val, string paramName, string msg);
    public static void CheckValue(T val, string paramName);
    [ExtensionAttribute]
public static void CheckValue(IExceptionContext ctx, T val, string paramName);
    public static T CheckValue(T val, string paramName, string msg);
    [ExtensionAttribute]
public static T CheckValue(IExceptionContext ctx, T val, string paramName, string msg);
    public static string CheckNonEmpty(string s, string paramName);
    [ExtensionAttribute]
public static string CheckNonEmpty(IExceptionContext ctx, string s, string paramName);
    public static string CheckNonWhiteSpace(string s, string paramName);
    [ExtensionAttribute]
public static string CheckNonWhiteSpace(IExceptionContext ctx, string s, string paramName);
    public static string CheckNonEmpty(string s, string paramName, string msg);
    [ExtensionAttribute]
public static string CheckNonEmpty(IExceptionContext ctx, string s, string paramName, string msg);
    public static string CheckNonWhiteSpace(string s, string paramName, string msg);
    [ExtensionAttribute]
public static string CheckNonWhiteSpace(IExceptionContext ctx, string s, string paramName, string msg);
    public static T[] CheckNonEmpty(T[] args, string paramName);
    [ExtensionAttribute]
public static T[] CheckNonEmpty(IExceptionContext ctx, T[] args, string paramName);
    public static T[] CheckNonEmpty(T[] args, string paramName, string msg);
    [ExtensionAttribute]
public static T[] CheckNonEmpty(IExceptionContext ctx, T[] args, string paramName, string msg);
    public static ICollection`1<T> CheckNonEmpty(ICollection`1<T> args, string paramName);
    [ExtensionAttribute]
public static ICollection`1<T> CheckNonEmpty(IExceptionContext ctx, ICollection`1<T> args, string paramName);
    public static ICollection`1<T> CheckNonEmpty(ICollection`1<T> args, string paramName, string msg);
    [ExtensionAttribute]
public static ICollection`1<T> CheckNonEmpty(IExceptionContext ctx, ICollection`1<T> args, string paramName, string msg);
    public static void CheckDecode(bool f);
    [ExtensionAttribute]
public static void CheckDecode(IExceptionContext ctx, bool f);
    public static void CheckDecode(bool f, string msg);
    [ExtensionAttribute]
public static void CheckDecode(IExceptionContext ctx, bool f, string msg);
    public static void CheckIO(bool f);
    [ExtensionAttribute]
public static void CheckIO(IExceptionContext ctx, bool f);
    public static void CheckIO(bool f, string msg);
    [ExtensionAttribute]
public static void CheckIO(IExceptionContext ctx, bool f, string msg);
    [ExtensionAttribute]
public static void CheckIO(IExceptionContext ctx, bool f, string msg, Object[] args);
    [ExtensionAttribute]
public static void CheckAlive(IHostEnvironment env);
    [ConditionalAttribute("INVARIANT_CHECKS")]
public static void CheckValueOrNull(T val);
    [ExtensionAttribute]
[ConditionalAttribute("INVARIANT_CHECKS")]
public static void CheckValueOrNull(IExceptionContext ctx, T val);
    private static void DbgFailCore(string msg, IExceptionContext ctx);
    private static void DbgFail(IExceptionContext ctx);
    private static void DbgFail(string msg);
    private static void DbgFail(IExceptionContext ctx, string msg);
    private static void DbgFailValue(IExceptionContext ctx);
    private static void DbgFailValue(string paramName);
    private static void DbgFailValue(IExceptionContext ctx, string paramName);
    private static void DbgFailValue(string paramName, string msg);
    private static void DbgFailValue(IExceptionContext ctx, string paramName, string msg);
    private static void DbgFailEmpty(IExceptionContext ctx);
    private static void DbgFailEmpty(string msg);
    private static void DbgFailEmpty(IExceptionContext ctx, string msg);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool f);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void Assert(IExceptionContext ctx, bool f);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool f, string msg);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void Assert(IExceptionContext ctx, bool f, string msg);
    [ConditionalAttribute("DEBUG")]
public static void AssertValue(T val);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertValue(IExceptionContext ctx, T val);
    [ConditionalAttribute("DEBUG")]
public static void AssertValue(T val, string paramName);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertValue(IExceptionContext ctx, T val, string paramName);
    [ConditionalAttribute("DEBUG")]
public static void AssertValue(T val, string name, string msg);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertValue(IExceptionContext ctx, T val, string name, string msg);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(string s);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(IExceptionContext ctx, string s);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonWhiteSpace(string s);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertNonWhiteSpace(IExceptionContext ctx, string s);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(string s, string msg);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(IExceptionContext ctx, string s, string msg);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonWhiteSpace(string s, string msg);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertNonWhiteSpace(IExceptionContext ctx, string s, string msg);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(ReadOnlySpan`1<T> args);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(Span`1<T> args);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(ICollection`1<T> args);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(IExceptionContext ctx, ICollection`1<T> args);
    [ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(ICollection`1<T> args, string msg);
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void AssertNonEmpty(IExceptionContext ctx, ICollection`1<T> args, string msg);
    [ConditionalAttribute("INVARIANT_CHECKS")]
public static void AssertValueOrNull(T val);
    [ExtensionAttribute]
[ConditionalAttribute("INVARIANT_CHECKS")]
public static void AssertValueOrNull(IExceptionContext ctx, T val);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Runtime.Extension : object {
    [ExtensionAttribute]
internal static AccessModifier Accessmodifier(MethodInfo methodInfo);
    [ExtensionAttribute]
internal static AccessModifier Accessmodifier(ConstructorInfo constructorInfo);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Runtime.HostEnvironmentBase`1 : ChannelProviderBase {
    [CompilerGeneratedAttribute]
private string <TempFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <GpuDeviceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FallbackToCpu>k__BackingField;
    protected TEnv Root;
    protected HostEnvironmentBase`1<TEnv> Master;
    private object _cancelLock;
    private Random _rand;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Seed>k__BackingField;
    protected ConcurrentDictionary`2<Type, Dispatcher<TEnv>> ListenerDict;
    protected ProgressTracker ProgressTracker;
    [CompilerGeneratedAttribute]
private ComponentCatalog <ComponentCatalog>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanceled>k__BackingField;
    private List`1<WeakReference`1<IHost>> _children;
    public string TempFilePath { get; public set; }
    public Nullable`1<int> GpuDeviceId { get; public set; }
    public bool FallbackToCpu { get; public set; }
    public Nullable`1<int> Seed { get; }
    public ComponentCatalog ComponentCatalog { get; }
    public int Depth { get; }
    public bool IsCanceled { get; protected set; }
    public string ContextDescription { get; }
    protected HostEnvironmentBase`1(Nullable`1<int> seed, bool verbose, string shortName, string parentFullName);
    protected HostEnvironmentBase`1(HostEnvironmentBase`1<TEnv> source, Random rand, bool verbose, string shortName, string parentFullName);
    private sealed virtual override void Microsoft.ML.Runtime.ICancelable.CancelExecution();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TempFilePath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TempFilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_GpuDeviceId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_GpuDeviceId(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_FallbackToCpu();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FallbackToCpu(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_Seed();
    [CompilerGeneratedAttribute]
public sealed virtual ComponentCatalog get_ComponentCatalog();
    public virtual int get_Depth();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCanceled();
    [CompilerGeneratedAttribute]
protected void set_IsCanceled(bool value);
    public sealed virtual IHost Register(string name, Nullable`1<int> seed, Nullable`1<bool> verbose);
    protected abstract virtual IHost RegisterCore(HostEnvironmentBase`1<TEnv> source, string shortName, string parentFullName, Random rand, bool verbose);
    public sealed virtual IProgressChannel StartProgressChannel(string name);
    protected virtual IProgressChannel StartProgressChannelCore(HostBase<TEnv> host, string name);
    private void DispatchMessageCore(Action`2<IMessageSource, TMessage> listenerAction, IMessageSource channel, TMessage message);
    protected Action`2<IMessageSource, TMessage> GetDispatchDelegate();
    protected Dispatcher`1<TEnv, TMessage> EnsureDispatcher();
    public sealed virtual IChannel Start(string name);
    public sealed virtual IPipe`1<TMessage> StartPipe(string name);
    protected abstract virtual IChannel CreateCommChannel(ChannelProviderBase parent, string name);
    protected abstract virtual IPipe`1<TMessage> CreatePipe(ChannelProviderBase parent, string name);
    public void AddListener(Action`2<IMessageSource, TMessage> listenerFunc);
    public void RemoveListener(Action`2<IMessageSource, TMessage> listenerFunc);
    public virtual TException Process(TException ex);
    public virtual string get_ContextDescription();
    public virtual void PrintMessageNormalized(TextWriter writer, string message, bool removeLastNewLine, string prefix);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.HostEnvironmentExtensions : object {
    [ExtensionAttribute]
public static IFileHandle OpenInputFile(IHostEnvironment env, string path);
    [ExtensionAttribute]
public static IFileHandle CreateOutputFile(IHostEnvironment env, string path);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.HostExtensions : object {
    [ExtensionAttribute]
public static T Apply(IHost host, string channelName, Func`2<IChannel, T> func);
    [ExtensionAttribute]
public static void Trace(IChannel ch, string fmt);
    [ExtensionAttribute]
public static void Trace(IChannel ch, string fmt, Object[] args);
    [ExtensionAttribute]
public static void Error(IChannel ch, string fmt);
    [ExtensionAttribute]
public static void Error(IChannel ch, string fmt, Object[] args);
    [ExtensionAttribute]
public static void Warning(IChannel ch, string fmt);
    [ExtensionAttribute]
public static void Warning(IChannel ch, string fmt, Object[] args);
    [ExtensionAttribute]
public static void Info(IChannel ch, string fmt);
    [ExtensionAttribute]
public static void Info(IChannel ch, string fmt, Object[] args);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Runtime.ICancelable {
    public bool IsCanceled { get; }
    public abstract virtual void CancelExecution();
    public abstract virtual bool get_IsCanceled();
}
public interface Microsoft.ML.Runtime.IChannel {
    public abstract virtual void Trace(MessageSensitivity sensitivity, string fmt);
    public abstract virtual void Trace(MessageSensitivity sensitivity, string fmt, Object[] args);
    public abstract virtual void Error(MessageSensitivity sensitivity, string fmt);
    public abstract virtual void Error(MessageSensitivity sensitivity, string fmt, Object[] args);
    public abstract virtual void Warning(MessageSensitivity sensitivity, string fmt);
    public abstract virtual void Warning(MessageSensitivity sensitivity, string fmt, Object[] args);
    public abstract virtual void Info(MessageSensitivity sensitivity, string fmt);
    public abstract virtual void Info(MessageSensitivity sensitivity, string fmt, Object[] args);
}
public interface Microsoft.ML.Runtime.IChannelProvider {
    public abstract virtual IChannel Start(string name);
    public abstract virtual IPipe`1<TMessage> StartPipe(string name);
}
public interface Microsoft.ML.Runtime.IComponentFactory {
}
public interface Microsoft.ML.Runtime.IComponentFactory`1 {
    public abstract virtual TComponent CreateComponent(IHostEnvironment env);
}
public interface Microsoft.ML.Runtime.IComponentFactory`2 {
    public abstract virtual TComponent CreateComponent(IHostEnvironment env, TArg1 argument1);
}
public interface Microsoft.ML.Runtime.IComponentFactory`3 {
    public abstract virtual TComponent CreateComponent(IHostEnvironment env, TArg1 argument1, TArg2 argument2);
}
public interface Microsoft.ML.Runtime.IComponentFactory`4 {
    public abstract virtual TComponent CreateComponent(IHostEnvironment env, TArg1 argument1, TArg2 argument2, TArg3 argument3);
}
public interface Microsoft.ML.Runtime.IExceptionContext {
    public string ContextDescription { get; }
    public abstract virtual TException Process(TException ex);
    public abstract virtual string get_ContextDescription();
}
public interface Microsoft.ML.Runtime.IHost {
    public Random Rand { get; }
    public abstract virtual Random get_Rand();
}
public interface Microsoft.ML.Runtime.IHostEnvironment {
    public ComponentCatalog ComponentCatalog { get; }
    public abstract virtual IHost Register(string name, Nullable`1<int> seed, Nullable`1<bool> verbose);
    public abstract virtual ComponentCatalog get_ComponentCatalog();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Runtime.IHostEnvironmentInternal {
    public Nullable`1<int> Seed { get; }
    public string TempFilePath { get; public set; }
    public bool FallbackToCpu { get; public set; }
    public Nullable`1<int> GpuDeviceId { get; public set; }
    public abstract virtual Nullable`1<int> get_Seed();
    public abstract virtual string get_TempFilePath();
    public abstract virtual void set_TempFilePath(string value);
    public abstract virtual bool get_FallbackToCpu();
    public abstract virtual void set_FallbackToCpu(bool value);
    public abstract virtual Nullable`1<int> get_GpuDeviceId();
    public abstract virtual void set_GpuDeviceId(Nullable`1<int> value);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Runtime.IMessageSource {
    public string ShortName { get; }
    public string FullName { get; }
    public bool Verbose { get; }
    public abstract virtual string get_ShortName();
    public abstract virtual string get_FullName();
    public abstract virtual bool get_Verbose();
}
public interface Microsoft.ML.Runtime.IPipe`1 {
    public abstract virtual void Send(TMessage msg);
}
public interface Microsoft.ML.Runtime.IProgressChannel {
    public abstract virtual void SetHeader(ProgressHeader header, Action`1<IProgressEntry> fillAction);
    public abstract virtual void Checkpoint(Nullable`1[] values);
}
public interface Microsoft.ML.Runtime.IProgressChannelProvider {
    public abstract virtual IProgressChannel StartProgressChannel(string name);
}
public interface Microsoft.ML.Runtime.IProgressEntry {
    public abstract virtual void SetProgress(int index, double value);
    public abstract virtual void SetProgress(int index, double value, double lim);
    public abstract virtual void SetMetric(int index, double value);
}
[FlagsAttribute]
public enum Microsoft.ML.Runtime.MessageSensitivity : Enum {
    public int value__;
    public static MessageSensitivity None;
    public static MessageSensitivity UserData;
    public static MessageSensitivity Schema;
    public static MessageSensitivity Unknown;
    public static MessageSensitivity All;
}
public class Microsoft.ML.Runtime.ProgressHeader : object {
    public IReadOnlyList`1<string> UnitNames;
    public IReadOnlyList`1<string> MetricNames;
    public ProgressHeader(String[] metricNames, String[] unitNames);
    public ProgressHeader(String[] unitNames);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.ProgressReporting : object {
}
[BestFriendAttribute]
internal class Microsoft.ML.Runtime.ServerChannel : object {
    private IChannelProvider _chp;
    private string _identifier;
    private Dictionary`2<string, Delegate> _toPublish;
    private Action`1<Bundle> _onPublish;
    private Bundle _published;
    private bool _disposed;
    private ServerChannel ThisIfActiveOrNull { get; }
    private ServerChannel(IChannelProvider provider, string idenfier);
    private ServerChannel get_ThisIfActiveOrNull();
    public static ServerChannel Start(IChannelProvider provider, string identifier);
    public sealed virtual void Dispose();
    private void RegisterCore(string name, Delegate func);
    public void Register(string name, Func`1<TRet> func);
    public void Register(string name, Func`2<T1, TRet> func);
    public void Register(string name, Func`3<T1, T2, TRet> func);
    public void Register(string name, Func`4<T1, T2, T3, TRet> func);
    public void Publish();
    public sealed virtual void Acknowledge(Action`1<Bundle> toDo);
    public static IServerFactory CreateDefaultServerFactoryOrNull(IHostEnvironment env);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Runtime.ServerChannelUtilities : object {
    [ExtensionAttribute]
public static ServerChannel StartServerChannel(IChannelProvider provider, string identifier);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.ML.SchemaShape : object {
    private Column[] _columns;
    private static SchemaShape _empty;
    public int Count { get; }
    public Column Item { get; }
    public SchemaShape(IEnumerable`1<Column> columns);
    private static SchemaShape();
    public sealed virtual int get_Count();
    public sealed virtual Column get_Item(int index);
    [BestFriendAttribute]
internal static void GetColumnTypeShape(DataViewType type, VectorKind& vecKind, DataViewType& itemType, Boolean& isKey);
    [BestFriendAttribute]
internal static SchemaShape Create(DataViewSchema schema);
    [BestFriendAttribute]
internal bool TryFindColumn(string name, Column& column);
    public sealed virtual IEnumerator`1<Column> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.SearchSpace.BooleanChoiceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DefaultValue>k__BackingField;
    public bool DefaultValue { get; }
    public BooleanChoiceAttribute(bool defaultValue);
    [CompilerGeneratedAttribute]
public bool get_DefaultValue();
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.SearchSpace.ChoiceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Object[] <Candidates>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    public Object[] Candidates { get; }
    public object DefaultValue { get; }
    public ChoiceAttribute(Object[] candidates);
    public ChoiceAttribute(Object[] candidates, object defaultValue);
    [CompilerGeneratedAttribute]
public Object[] get_Candidates();
    [CompilerGeneratedAttribute]
public object get_DefaultValue();
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.SearchSpace.NestOptionAttribute : Attribute {
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.SearchSpace.RangeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Init>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogBase>k__BackingField;
    public object Min { get; }
    public object Max { get; }
    public object Init { get; }
    public bool LogBase { get; }
    public RangeAttribute(double min, double max, bool logBase);
    public RangeAttribute(double min, double max, double init, bool logBase);
    public RangeAttribute(int min, int max, bool logBase);
    public RangeAttribute(int min, int max, int init, bool logBase);
    public RangeAttribute(float min, float max, bool logBase);
    public RangeAttribute(float min, float max, float init, bool logBase);
    [CompilerGeneratedAttribute]
public object get_Min();
    [CompilerGeneratedAttribute]
public object get_Max();
    [CompilerGeneratedAttribute]
public object get_Init();
    [CompilerGeneratedAttribute]
public bool get_LogBase();
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureAnomalyDetectorTrainer : MulticastDelegate {
    public SignatureAnomalyDetectorTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureBinaryClassifierTrainer : MulticastDelegate {
    public SignatureBinaryClassifierTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureClusteringTrainer : MulticastDelegate {
    public SignatureClusteringTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureDefault : MulticastDelegate {
    public SignatureDefault(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureLoadModel : MulticastDelegate {
    public SignatureLoadModel(object object, IntPtr method);
    public virtual void Invoke(ModelLoadContext ctx);
    public virtual IAsyncResult BeginInvoke(ModelLoadContext ctx, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureMatrixRecommendingTrainer : MulticastDelegate {
    public SignatureMatrixRecommendingTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureMulticlassClassifierTrainer : MulticastDelegate {
    public SignatureMulticlassClassifierTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureMultiOutputRegressorTrainer : MulticastDelegate {
    public SignatureMultiOutputRegressorTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureRankerTrainer : MulticastDelegate {
    public SignatureRankerTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureRegressorTrainer : MulticastDelegate {
    public SignatureRegressorTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureSequenceTrainer : MulticastDelegate {
    public SignatureSequenceTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.SignatureTrainer : MulticastDelegate {
    public SignatureTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.TauswortheHybrid : Random {
    private UInt32 _z1;
    private UInt32 _z2;
    private UInt32 _z3;
    private UInt32 _z4;
    public TauswortheHybrid(State state);
    public TauswortheHybrid(Random rng);
    private static UInt32 GetU(Random rng);
    private static UInt32 GetSeed(Random rng);
    public float NextSingle();
    public virtual double NextDouble();
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    public int NextSigned();
    private UInt32 GetUint();
    private float GetSingle();
    private double GetDouble();
    private void NextState();
    private static void TauswortheStateChange(UInt32& z, int s1, int s2, int s3, UInt32 m);
    private static void LcgStateChange(UInt32& z, UInt32 a, UInt32 c);
    public State GetState();
}
[BestFriendAttribute]
internal class Microsoft.ML.TelemetryException : TelemetryMessage {
    public Exception Exception;
    public TelemetryException(Exception exception);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.TelemetryMessage : object {
    public static TelemetryMessage CreateCommand(string commandName, string commandText);
    public static TelemetryMessage CreateTrainer(string trainerName, string trainerParams);
    public static TelemetryMessage CreateTransform(string transformName, string transformParams);
    public static TelemetryMessage CreateMetric(string metricName, double metricValue, Dictionary`2<string, string> properties);
    public static TelemetryMessage CreateException(Exception exception);
}
[BestFriendAttribute]
internal class Microsoft.ML.TelemetryMetric : TelemetryMessage {
    public string Name;
    public double Value;
    public IDictionary`2<string, string> Properties;
    public TelemetryMetric(string name, double value, IDictionary`2<string, string> properties);
}
[BestFriendAttribute]
internal class Microsoft.ML.TelemetryTrace : TelemetryMessage {
    public string Text;
    public string Name;
    public string Type;
    public TelemetryTrace(string text, string name, string type);
}
[BestFriendAttribute]
internal class Microsoft.ML.TrainContext : object {
    [CompilerGeneratedAttribute]
private RoleMappedData <TrainingSet>k__BackingField;
    [CompilerGeneratedAttribute]
private RoleMappedData <ValidationSet>k__BackingField;
    [CompilerGeneratedAttribute]
private RoleMappedData <TestSet>k__BackingField;
    [CompilerGeneratedAttribute]
private IPredictor <InitialPredictor>k__BackingField;
    public RoleMappedData TrainingSet { get; }
    public RoleMappedData ValidationSet { get; }
    public RoleMappedData TestSet { get; }
    public IPredictor InitialPredictor { get; }
    public TrainContext(RoleMappedData trainingSet, RoleMappedData validationSet, RoleMappedData testSet, IPredictor initialPredictor);
    [CompilerGeneratedAttribute]
public RoleMappedData get_TrainingSet();
    [CompilerGeneratedAttribute]
public RoleMappedData get_ValidationSet();
    [CompilerGeneratedAttribute]
public RoleMappedData get_TestSet();
    [CompilerGeneratedAttribute]
public IPredictor get_InitialPredictor();
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.TrainerExtensions : object {
    [ExtensionAttribute]
public static IPredictor Train(ITrainer trainer, RoleMappedData trainData);
    [ExtensionAttribute]
public static TPredictor Train(ITrainer`1<TPredictor> trainer, RoleMappedData trainData);
}
public class Microsoft.ML.TrainerInfo : object {
    [CompilerGeneratedAttribute]
private bool <NeedNormalization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedCalibration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WantCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsTest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsIncrementalTraining>k__BackingField;
    public bool NeedNormalization { get; }
    [BestFriendAttribute]
internal bool NeedCalibration { get; }
    public bool WantCaching { get; }
    [BestFriendAttribute]
internal bool SupportsValidation { get; }
    [BestFriendAttribute]
internal bool SupportsTest { get; }
    [BestFriendAttribute]
internal bool SupportsIncrementalTraining { get; }
    [BestFriendAttribute]
internal TrainerInfo(bool normalization, bool calibration, bool caching, bool supportValid, bool supportIncrementalTrain, bool supportTest);
    [CompilerGeneratedAttribute]
public bool get_NeedNormalization();
    [CompilerGeneratedAttribute]
internal bool get_NeedCalibration();
    [CompilerGeneratedAttribute]
public bool get_WantCaching();
    [CompilerGeneratedAttribute]
internal bool get_SupportsValidation();
    [CompilerGeneratedAttribute]
internal bool get_SupportsTest();
    [CompilerGeneratedAttribute]
internal bool get_SupportsIncrementalTraining();
}
[BestFriendAttribute]
internal interface Microsoft.ML.TreePredictor.INode {
    public Dictionary`2<string, object> KeyValues { get; }
    public abstract virtual Dictionary`2<string, object> get_KeyValues();
}
[BestFriendAttribute]
internal interface Microsoft.ML.TreePredictor.ITree {
    public Int32[] GtChild { get; }
    public Int32[] LteChild { get; }
    public int NumNodes { get; }
    public int NumLeaves { get; }
    public abstract virtual Int32[] get_GtChild();
    public abstract virtual Int32[] get_LteChild();
    public abstract virtual int get_NumNodes();
    public abstract virtual int get_NumLeaves();
    public abstract virtual INode GetNode(int nodeId, bool isLeaf, IEnumerable`1<string> featureNames);
}
[BestFriendAttribute]
internal interface Microsoft.ML.TreePredictor.ITree`1 {
    public abstract virtual int GetLeaf(TFeatures& modreq(System.Runtime.InteropServices.InAttribute) features);
}
[BestFriendAttribute]
internal interface Microsoft.ML.TreePredictor.ITreeEnsemble {
    public int NumTrees { get; }
    public abstract virtual int get_NumTrees();
    public abstract virtual ITree[] GetTrees();
}
[BestFriendAttribute]
internal static class Microsoft.ML.TreePredictor.NodeKeys : object {
    public static string SplitName;
    public static string SplitGain;
    public static string Threshold;
    public static string GainValue;
    public static string PreviousLeafValue;
    public static string LeafValue;
    public static string Extras;
}
[IsReadOnlyAttribute]
[BestFriendAttribute]
internal class Microsoft.ML.VersionInfo : ValueType {
    public ulong ModelSignature;
    public UInt32 VerWrittenCur;
    public UInt32 VerReadableCur;
    public UInt32 VerWeCanReadBack;
    public string LoaderAssemblyName;
    public string LoaderSignature;
    public string LoaderSignatureAlt;
    public VersionInfo(string modelSignature, UInt32 verWrittenCur, UInt32 verReadableCur, UInt32 verWeCanReadBack, string loaderAssemblyName, string loaderSignature, string loaderSignatureAlt);
}
[BestFriendAttribute]
[AttributeUsageAttribute("1")]
internal class Microsoft.ML.WantsToBeBestFriendsAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
