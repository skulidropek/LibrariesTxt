[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
public static class Microsoft.ML.CategoricalCatalog : object {
    [ExtensionAttribute]
public static OneHotEncodingEstimator OneHotEncoding(CategoricalTransforms catalog, string outputColumnName, string inputColumnName, OutputKind outputKind, int maximumNumberOfKeys, KeyOrdinality keyOrdinality, IDataView keyData);
    [ExtensionAttribute]
public static OneHotEncodingEstimator OneHotEncoding(CategoricalTransforms catalog, InputOutputColumnPair[] columns, OutputKind outputKind, int maximumNumberOfKeys, KeyOrdinality keyOrdinality, IDataView keyData);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static OneHotEncodingEstimator OneHotEncoding(CategoricalTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static OneHotEncodingEstimator OneHotEncoding(CategoricalTransforms catalog, ColumnOptions[] columns, IDataView keyData);
    [ExtensionAttribute]
public static OneHotHashEncodingEstimator OneHotHashEncoding(CategoricalTransforms catalog, string outputColumnName, string inputColumnName, OutputKind outputKind, int numberOfBits, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    [ExtensionAttribute]
public static OneHotHashEncodingEstimator OneHotHashEncoding(CategoricalTransforms catalog, InputOutputColumnPair[] columns, OutputKind outputKind, int numberOfBits, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static OneHotHashEncodingEstimator OneHotHashEncoding(CategoricalTransforms catalog, ColumnOptions[] columns);
}
[ExtensionAttribute]
public static class Microsoft.ML.ConversionsCatalog : object {
    [ExtensionAttribute]
[BestFriendAttribute]
internal static KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector(ConversionTransforms catalog, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static KeyToBinaryVectorMappingEstimator MapKeyToBinaryVector(ConversionTransforms catalog, string outputColumnName, string inputColumnName);
}
[ExtensionAttribute]
public static class Microsoft.ML.CustomMappingCatalog : object {
    [ExtensionAttribute]
public static CustomMappingEstimator`2<TSrc, TDst> CustomMapping(TransformsCatalog catalog, Action`2<TSrc, TDst> mapAction, string contractName, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition);
    [ExtensionAttribute]
public static StatefulCustomMappingEstimator`3<TSrc, TDst, TState> StatefulCustomMapping(TransformsCatalog catalog, Action`3<TSrc, TDst, TState> mapAction, Action`1<TState> stateInitAction, string contractName);
    [ExtensionAttribute]
public static IDataView FilterByCustomPredicate(DataOperationsCatalog catalog, IDataView input, Func`2<TSrc, bool> filterPredicate);
    [ExtensionAttribute]
public static IDataView FilterByStatefulCustomPredicate(DataOperationsCatalog catalog, IDataView input, Func`3<TSrc, TState, bool> filterPredicate, Action`1<TState> stateInitAction);
}
public class Microsoft.ML.Data.BinaryClassificationMetricsStatistics : object {
    [CompilerGeneratedAttribute]
private MetricStatistics <AreaUnderRocCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <PositivePrecision>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <PositiveRecall>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <NegativePrecision>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <NegativeRecall>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <F1Score>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <AreaUnderPrecisionRecallCurve>k__BackingField;
    public MetricStatistics AreaUnderRocCurve { get; }
    public MetricStatistics Accuracy { get; }
    public MetricStatistics PositivePrecision { get; }
    public MetricStatistics PositiveRecall { get; }
    public MetricStatistics NegativePrecision { get; }
    public MetricStatistics NegativeRecall { get; }
    public MetricStatistics F1Score { get; }
    public MetricStatistics AreaUnderPrecisionRecallCurve { get; }
    [CompilerGeneratedAttribute]
public MetricStatistics get_AreaUnderRocCurve();
    [CompilerGeneratedAttribute]
public MetricStatistics get_Accuracy();
    [CompilerGeneratedAttribute]
public MetricStatistics get_PositivePrecision();
    [CompilerGeneratedAttribute]
public MetricStatistics get_PositiveRecall();
    [CompilerGeneratedAttribute]
public MetricStatistics get_NegativePrecision();
    [CompilerGeneratedAttribute]
public MetricStatistics get_NegativeRecall();
    [CompilerGeneratedAttribute]
public MetricStatistics get_F1Score();
    [CompilerGeneratedAttribute]
public MetricStatistics get_AreaUnderPrecisionRecallCurve();
    private sealed virtual override void Microsoft.ML.Data.IMetricsStatistics<Microsoft.ML.Data.BinaryClassificationMetrics>.Add(BinaryClassificationMetrics metrics);
}
internal interface Microsoft.ML.Data.IMetricsStatistics`1 {
    public abstract virtual void Add(T metrics);
}
internal static class Microsoft.ML.Data.MetricsStatisticsUtils : object {
    public static void AddToEach(IReadOnlyList`1<double> src, IReadOnlyList`1<MetricStatistics> dest);
    public static MetricStatistics[] InitializeArray(int length);
}
public class Microsoft.ML.Data.MetricStatistics : object {
    private SummaryStatistics _statistic;
    public double Mean { get; }
    public double StandardDeviation { get; }
    public double StandardError { get; }
    public int Count { get; }
    public double get_Mean();
    public double get_StandardDeviation();
    public double get_StandardError();
    public int get_Count();
    internal void Add(double metric);
}
public class Microsoft.ML.Data.MulticlassClassificationMetricsStatistics : object {
    [CompilerGeneratedAttribute]
private MetricStatistics <MacroAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <MicroAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <LogLoss>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <LogLossReduction>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <TopKAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetricStatistics> <PerClassLogLoss>k__BackingField;
    public MetricStatistics MacroAccuracy { get; }
    public MetricStatistics MicroAccuracy { get; }
    public MetricStatistics LogLoss { get; }
    public MetricStatistics LogLossReduction { get; }
    public MetricStatistics TopKAccuracy { get; }
    public IReadOnlyList`1<MetricStatistics> PerClassLogLoss { get; private set; }
    [CompilerGeneratedAttribute]
public MetricStatistics get_MacroAccuracy();
    [CompilerGeneratedAttribute]
public MetricStatistics get_MicroAccuracy();
    [CompilerGeneratedAttribute]
public MetricStatistics get_LogLoss();
    [CompilerGeneratedAttribute]
public MetricStatistics get_LogLossReduction();
    [CompilerGeneratedAttribute]
public MetricStatistics get_TopKAccuracy();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetricStatistics> get_PerClassLogLoss();
    [CompilerGeneratedAttribute]
private void set_PerClassLogLoss(IReadOnlyList`1<MetricStatistics> value);
    private sealed virtual override void Microsoft.ML.Data.IMetricsStatistics<Microsoft.ML.Data.MulticlassClassificationMetrics>.Add(MulticlassClassificationMetrics metrics);
}
internal class Microsoft.ML.Data.NgramBufferBuilder : object {
    private BufferBuilder`1<float> _bldr;
    private FixedSizeQueue`1<UInt32> _queue;
    private int _ngramLength;
    private int _skipLength;
    private UInt32[] _ngram;
    private int _slotLim;
    private NgramIdFinder _finder;
    public static int MaxSkipNgramLength;
    public bool IsEmpty { get; }
    public NgramBufferBuilder(int ngramLength, int skipLength, int slotLim, NgramIdFinder finder);
    public bool get_IsEmpty();
    public void Reset();
    public bool AddNgrams(VBuffer`1& src, int icol, UInt32 keyMax);
    public void GetResult(VBuffer`1& dst);
    private bool ProcessNgrams(int icol);
    private bool ProcessSkipNgrams(int icol, int i, int skips);
}
internal class Microsoft.ML.Data.NgramIdFinder : MulticastDelegate {
    public NgramIdFinder(object object, IntPtr method);
    public virtual int Invoke(UInt32[] ngram, int lim, int icol, Boolean& more);
    public virtual IAsyncResult BeginInvoke(UInt32[] ngram, int lim, int icol, Boolean& more, AsyncCallback callback, object object);
    public virtual int EndInvoke(Boolean& more, IAsyncResult result);
}
internal static class Microsoft.ML.Data.NgramUtils : object {
    public static bool IsValidNgramRawType(Type rawType);
}
public class Microsoft.ML.Data.RankingMetricsStatistics : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetricStatistics> <DiscountedCumulativeGains>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetricStatistics> <NormalizedDiscountedCumulativeGains>k__BackingField;
    public IReadOnlyList`1<MetricStatistics> DiscountedCumulativeGains { get; private set; }
    public IReadOnlyList`1<MetricStatistics> NormalizedDiscountedCumulativeGains { get; private set; }
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetricStatistics> get_DiscountedCumulativeGains();
    [CompilerGeneratedAttribute]
private void set_DiscountedCumulativeGains(IReadOnlyList`1<MetricStatistics> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetricStatistics> get_NormalizedDiscountedCumulativeGains();
    [CompilerGeneratedAttribute]
private void set_NormalizedDiscountedCumulativeGains(IReadOnlyList`1<MetricStatistics> value);
    private sealed virtual override void Microsoft.ML.Data.IMetricsStatistics<Microsoft.ML.Data.RankingMetrics>.Add(RankingMetrics metrics);
}
public class Microsoft.ML.Data.RegressionMetricsStatistics : object {
    [CompilerGeneratedAttribute]
private MetricStatistics <MeanAbsoluteError>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <MeanSquaredError>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <RootMeanSquaredError>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <LossFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private MetricStatistics <RSquared>k__BackingField;
    public MetricStatistics MeanAbsoluteError { get; }
    public MetricStatistics MeanSquaredError { get; }
    public MetricStatistics RootMeanSquaredError { get; }
    public MetricStatistics LossFunction { get; }
    public MetricStatistics RSquared { get; }
    [CompilerGeneratedAttribute]
public MetricStatistics get_MeanAbsoluteError();
    [CompilerGeneratedAttribute]
public MetricStatistics get_MeanSquaredError();
    [CompilerGeneratedAttribute]
public MetricStatistics get_RootMeanSquaredError();
    [CompilerGeneratedAttribute]
public MetricStatistics get_LossFunction();
    [CompilerGeneratedAttribute]
public MetricStatistics get_RSquared();
    private sealed virtual override void Microsoft.ML.Data.IMetricsStatistics<Microsoft.ML.Data.RegressionMetrics>.Add(RegressionMetrics metrics);
}
public class Microsoft.ML.Data.SvmLightLoader : object {
    private IHost _host;
    private ITransformer _keyVectorsToIndexVectors;
    private FeatureIndices _indicesKind;
    private ulong _featureCount;
    private DataViewSchema _outputSchema;
    internal static string Summary;
    internal static string UserName;
    internal static string LoaderSignature;
    internal SvmLightLoader(IHostEnvironment env, Options options, IMultiStreamSource dataSample);
    private SvmLightLoader(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal static SvmLightLoader Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private DataViewSchema CreateOutputSchema();
    private static IDataView GetData(IHostEnvironment env, Nullable`1<long> numRows, IMultiStreamSource dataSample);
    private static UInt32 InferMax(IHostEnvironment env, IDataView view);
    private static ITransformer CreateOutputTransformer(IHostEnvironment env, int keyCount, bool keyIndices, DataViewSchema inputSchema);
    public sealed virtual DataViewSchema GetOutputSchema();
    public sealed virtual IDataView Load(IMultiStreamSource input);
    internal static ILegacyDataLoader Create(IHostEnvironment env, ModelLoadContext ctx, IMultiStreamSource files);
    internal static ILegacyDataLoader Create(IHostEnvironment env, Options options, IMultiStreamSource files);
}
[ExtensionAttribute]
public static class Microsoft.ML.Data.SvmLightLoaderSaverCatalog : object {
    [ExtensionAttribute]
public static SvmLightLoader CreateSvmLightLoader(DataOperationsCatalog catalog, Nullable`1<long> numberOfRows, int inputSize, bool zeroBased, IMultiStreamSource dataSample);
    [ExtensionAttribute]
public static SvmLightLoader CreateSvmLightLoaderWithFeatureNames(DataOperationsCatalog catalog, Nullable`1<long> numberOfRows, IMultiStreamSource dataSample);
    [ExtensionAttribute]
public static IDataView LoadFromSvmLightFile(DataOperationsCatalog catalog, string path, Nullable`1<long> numberOfRows, int inputSize, bool zeroBased);
    [ExtensionAttribute]
public static IDataView LoadFromSvmLightFileWithFeatureNames(DataOperationsCatalog catalog, string path, Nullable`1<long> numberOfRows);
    [ExtensionAttribute]
public static void SaveInSvmLightFormat(DataOperationsCatalog catalog, IDataView data, Stream stream, bool zeroBasedIndexing, bool binaryLabel, string labelColumnName, string featureColumnName, string rowGroupColumnName, string exampleWeightColumnName);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SvmLightSaver : object {
    internal static string LoadName;
    internal static string Summary;
    private IHost _host;
    private bool _zero;
    private bool _binary;
    private string _featureCol;
    private string _labelCol;
    private string _groupCol;
    private string _weightCol;
    public SvmLightSaver(IHostEnvironment env, Arguments args);
    public sealed virtual bool IsColumnSavable(DataViewType type);
    public sealed virtual void SaveData(Stream stream, IDataView data, Int32[] cols);
}
[ExtensionAttribute]
public static class Microsoft.ML.ExpressionCatalog : object {
    [ExtensionAttribute]
public static ExpressionEstimator Expression(TransformsCatalog catalog, string outputColumnName, string expression, String[] inputColumnNames);
}
[ExtensionAttribute]
public static class Microsoft.ML.ExtensionsCatalog : object {
    [ExtensionAttribute]
public static MissingValueIndicatorEstimator IndicateMissingValues(TransformsCatalog catalog, string outputColumnName, string inputColumnName);
    [ExtensionAttribute]
public static MissingValueIndicatorEstimator IndicateMissingValues(TransformsCatalog catalog, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static MissingValueReplacingEstimator ReplaceMissingValues(TransformsCatalog catalog, string outputColumnName, string inputColumnName, ReplacementMode replacementMode, bool imputeBySlot);
    [ExtensionAttribute]
public static MissingValueReplacingEstimator ReplaceMissingValues(TransformsCatalog catalog, InputOutputColumnPair[] columns, ReplacementMode replacementMode, bool imputeBySlot);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static MissingValueReplacingEstimator ReplaceMissingValues(TransformsCatalog catalog, ColumnOptions[] columns);
}
[ExtensionAttribute]
public static class Microsoft.ML.FeatureSelectionCatalog : object {
    [ExtensionAttribute]
public static MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation(FeatureSelectionTransforms catalog, string outputColumnName, string inputColumnName, string labelColumnName, int slotsInOutput, int numberOfBins);
    [ExtensionAttribute]
public static MutualInformationFeatureSelectingEstimator SelectFeaturesBasedOnMutualInformation(FeatureSelectionTransforms catalog, InputOutputColumnPair[] columns, string labelColumnName, int slotsInOutput, int numberOfBins);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(FeatureSelectionTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(FeatureSelectionTransforms catalog, string outputColumnName, string inputColumnName, long count);
    [ExtensionAttribute]
public static CountFeatureSelectingEstimator SelectFeaturesBasedOnCount(FeatureSelectionTransforms catalog, InputOutputColumnPair[] columns, long count);
}
[ExtensionAttribute]
public static class Microsoft.ML.KernelExpansionCatalog : object {
    [ExtensionAttribute]
public static ApproximatedKernelMappingEstimator ApproximatedKernelMap(TransformsCatalog catalog, string outputColumnName, string inputColumnName, int rank, bool useCosAndSinBases, KernelBase generator, Nullable`1<int> seed);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ApproximatedKernelMappingEstimator ApproximatedKernelMap(TransformsCatalog catalog, ColumnOptions[] columns);
}
[ExtensionAttribute]
public static class Microsoft.ML.NormalizationCatalog : object {
    [ExtensionAttribute]
[BestFriendAttribute]
internal static NormalizingEstimator Normalize(TransformsCatalog catalog, NormalizationMode mode, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeMinMax(TransformsCatalog catalog, string outputColumnName, string inputColumnName, long maximumExampleCount, bool fixZero);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeMinMax(TransformsCatalog catalog, InputOutputColumnPair[] columns, long maximumExampleCount, bool fixZero);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeMeanVariance(TransformsCatalog catalog, string outputColumnName, string inputColumnName, long maximumExampleCount, bool fixZero, bool useCdf);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeMeanVariance(TransformsCatalog catalog, InputOutputColumnPair[] columns, long maximumExampleCount, bool fixZero, bool useCdf);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeLogMeanVariance(TransformsCatalog catalog, string outputColumnName, string inputColumnName, long maximumExampleCount, bool useCdf);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeLogMeanVariance(TransformsCatalog catalog, InputOutputColumnPair[] columns, long maximumExampleCount, bool useCdf);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeLogMeanVariance(TransformsCatalog catalog, string outputColumnName, bool fixZero, string inputColumnName, long maximumExampleCount, bool useCdf);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeLogMeanVariance(TransformsCatalog catalog, InputOutputColumnPair[] columns, bool fixZero, long maximumExampleCount, bool useCdf);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeBinning(TransformsCatalog catalog, string outputColumnName, string inputColumnName, long maximumExampleCount, bool fixZero, int maximumBinCount);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeBinning(TransformsCatalog catalog, InputOutputColumnPair[] columns, long maximumExampleCount, bool fixZero, int maximumBinCount);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeSupervisedBinning(TransformsCatalog catalog, string outputColumnName, string inputColumnName, string labelColumnName, long maximumExampleCount, bool fixZero, int maximumBinCount, int mininimumExamplesPerBin);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeSupervisedBinning(TransformsCatalog catalog, InputOutputColumnPair[] columns, string labelColumnName, long maximumExampleCount, bool fixZero, int maximumBinCount, int mininimumExamplesPerBin);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeRobustScaling(TransformsCatalog catalog, string outputColumnName, string inputColumnName, long maximumExampleCount, bool centerData, UInt32 quantileMin, UInt32 quantileMax);
    [ExtensionAttribute]
public static NormalizingEstimator NormalizeRobustScaling(TransformsCatalog catalog, InputOutputColumnPair[] columns, long maximumExampleCount, bool centerData, UInt32 quantileMin, UInt32 quantileMax);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static NormalizingEstimator Normalize(TransformsCatalog catalog, ColumnOptionsBase[] columns);
    [ExtensionAttribute]
public static LpNormNormalizingEstimator NormalizeLpNorm(TransformsCatalog catalog, string outputColumnName, string inputColumnName, NormFunction norm, bool ensureZeroMean);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static LpNormNormalizingEstimator NormalizeLpNorm(TransformsCatalog catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static GlobalContrastNormalizingEstimator NormalizeGlobalContrast(TransformsCatalog catalog, string outputColumnName, string inputColumnName, bool ensureZeroMean, bool ensureUnitStandardDeviation, float scale);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static GlobalContrastNormalizingEstimator NormalizeGlobalContrast(TransformsCatalog catalog, ColumnOptions[] columns);
}
[ExtensionAttribute]
public static class Microsoft.ML.PermutationFeatureImportanceExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<RegressionMetricsStatistics> PermutationFeatureImportance(RegressionCatalog catalog, ISingleFeaturePredictionTransformer`1<TModel> predictionTransformer, IDataView data, string labelColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    [ExtensionAttribute]
public static ImmutableDictionary`2<string, RegressionMetricsStatistics> PermutationFeatureImportance(RegressionCatalog catalog, ITransformer model, IDataView data, string labelColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    private static RegressionMetrics RegressionDelta(RegressionMetrics a, RegressionMetrics b);
    [ExtensionAttribute]
public static ImmutableArray`1<BinaryClassificationMetricsStatistics> PermutationFeatureImportance(BinaryClassificationCatalog catalog, ISingleFeaturePredictionTransformer`1<TModel> predictionTransformer, IDataView data, string labelColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    [ExtensionAttribute]
public static ImmutableDictionary`2<string, BinaryClassificationMetricsStatistics> PermutationFeatureImportanceNonCalibrated(BinaryClassificationCatalog catalog, ITransformer model, IDataView data, string labelColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    private static BinaryClassificationMetrics BinaryClassifierDelta(BinaryClassificationMetrics a, BinaryClassificationMetrics b);
    [ExtensionAttribute]
public static ImmutableArray`1<MulticlassClassificationMetricsStatistics> PermutationFeatureImportance(MulticlassClassificationCatalog catalog, ISingleFeaturePredictionTransformer`1<TModel> predictionTransformer, IDataView data, string labelColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    [ExtensionAttribute]
public static ImmutableDictionary`2<string, MulticlassClassificationMetricsStatistics> PermutationFeatureImportance(MulticlassClassificationCatalog catalog, ITransformer model, IDataView data, string labelColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    private static MulticlassClassificationMetrics MulticlassClassificationDelta(MulticlassClassificationMetrics a, MulticlassClassificationMetrics b);
    [ExtensionAttribute]
public static ImmutableArray`1<RankingMetricsStatistics> PermutationFeatureImportance(RankingCatalog catalog, ISingleFeaturePredictionTransformer`1<TModel> predictionTransformer, IDataView data, string labelColumnName, string rowGroupColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    [ExtensionAttribute]
public static ImmutableDictionary`2<string, RankingMetricsStatistics> PermutationFeatureImportance(RankingCatalog catalog, ITransformer model, IDataView data, string labelColumnName, string rowGroupColumnName, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse, int permutationCount);
    private static RankingMetrics RankingDelta(RankingMetrics a, RankingMetrics b);
    private static Double[] ComputeSequenceDeltas(IReadOnlyList`1<double> a, IReadOnlyList`1<double> b);
    private static ImmutableDictionary`2<string, TResult> PermutationFeatureImportance(IHostEnvironment env, ITransformer model, IDataView data, Func`1<TResult> resultInitializer, Func`2<IDataView, TMetric> evaluationFunc, Func`3<TMetric, TMetric, TMetric> deltaFunc, int permutationCount, bool useFeatureWeightFilter, Nullable`1<int> numberOfExamplesToUse);
    private static Type GetImplementedIPredictionTransformer(Type type);
    [CompilerGeneratedAttribute]
internal static RegressionMetricsStatistics <PermutationFeatureImportance>g__resultInitializer|1_0();
    [CompilerGeneratedAttribute]
internal static BinaryClassificationMetricsStatistics <PermutationFeatureImportanceNonCalibrated>g__resultInitializer|4_0();
    [CompilerGeneratedAttribute]
internal static MulticlassClassificationMetricsStatistics <PermutationFeatureImportance>g__resultInitializer|7_0();
    [CompilerGeneratedAttribute]
internal static RankingMetricsStatistics <PermutationFeatureImportance>g__resultInitializer|10_0();
}
internal static class Microsoft.ML.TextAnalytics.LdaInterface : object {
    private static string NativePath;
    [SuppressUnmanagedCodeSecurityAttribute]
internal static SafeLdaEngineHandle CreateEngine(int numTopic, int numVocab, float alphaSum, float beta, int numIter, int likelihoodInterval, int numThread, int mhstep, int maxDocToken);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void AllocateModelMemory(SafeLdaEngineHandle engine, int numTopic, int numVocab, long tableSize, long aliasTableSize);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void AllocateDataMemory(SafeLdaEngineHandle engine, int docNum, long corpusSize);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void Train(SafeLdaEngineHandle engine, string trainOutput);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetModelStat(SafeLdaEngineHandle engine, Int64& memBlockSize, Int64& aliasMemBlockSize);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void Test(SafeLdaEngineHandle engine, int numBurninIter, Single[] pLogLikelihood);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void CleanData(SafeLdaEngineHandle engine);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void CleanModel(SafeLdaEngineHandle engine);
    [SuppressUnmanagedCodeSecurityAttribute]
private static void DestroyEngine(IntPtr engine);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetWordTopic(SafeLdaEngineHandle engine, int wordId, Int32[] pTopic, Int32[] pProb, Int32& length);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void SetWordTopic(SafeLdaEngineHandle engine, int wordId, Int32[] pTopic, Int32[] pProb, int length);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void SetAlphaSum(SafeLdaEngineHandle engine, float avgDocLength);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int FeedInData(SafeLdaEngineHandle engine, Int32[] termId, Int32[] termFreq, int termNum, int numVocab);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static int FeedInDataDense(SafeLdaEngineHandle engine, Int32[] termFreq, int termNum, int numVocab);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetDocTopic(SafeLdaEngineHandle engine, int docId, Int32[] pTopic, Int32[] pProb, Int32& numTopicReturn);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void GetTopicSummary(SafeLdaEngineHandle engine, int topicId, Int32[] pWords, Single[] pProb, Int32& numTopicReturn);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void TestOneDoc(SafeLdaEngineHandle engine, Int32[] termId, Int32[] termFreq, int termNum, Int32[] pTopics, Int32[] pProbs, Int32& numTopicsMax, int numBurnIter, bool reset);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void TestOneDocDense(SafeLdaEngineHandle engine, Int32[] termFreq, int termNum, Int32[] pTopics, Int32[] pProbs, Int32& numTopicsMax, int numBurninIter, bool reset);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void InitializeBeforeTrain(SafeLdaEngineHandle engine);
    [SuppressUnmanagedCodeSecurityAttribute]
internal static void InitializeBeforeTest(SafeLdaEngineHandle engine);
}
internal class Microsoft.ML.TextAnalytics.LdaSingleBox : object {
    private SafeLdaEngineHandle _engine;
    private bool _isDisposed;
    private Int32[] _topics;
    private Int32[] _probabilities;
    private Int32[] _summaryTerm;
    private Single[] _summaryTermProb;
    private int _likelihoodInterval;
    private float _alpha;
    private float _beta;
    private int _mhStep;
    private int _numThread;
    private int _numSummaryTerms;
    private bool _denseOutput;
    public int NumTopic;
    public int NumVocab;
    public LdaSingleBox(int numTopic, int numVocab, float alpha, float beta, int numIter, int likelihoodInterval, int numThread, int mhstep, int numSummaryTerms, bool denseOutput, int maxDocToken);
    public void AllocateModelMemory(int numTopic, int numVocab, long tableSize, long aliasTableSize);
    public void AllocateDataMemory(int docNum, long corpusSize);
    public void Train(string trainOutput);
    public void GetModelStat(Int64& memBlockSize, Int64& aliasMemBlockSize);
    public void Test(int numBurninIter, Single[] logLikelihood);
    public void CleanData();
    public void CleanModel();
    public void CopyModel(LdaSingleBox trainer, int wordId);
    public void SetAlphaSum(float averageDocLength);
    public int LoadDoc(ReadOnlySpan`1<int> termID, ReadOnlySpan`1<double> termVal, int termNum, int numVocab);
    public int LoadDocDense(ReadOnlySpan`1<double> termVal, int termNum, int numVocab);
    public List`1<KeyValuePair`2<int, float>> GetDocTopicVector(int docID);
    public List`1<KeyValuePair`2<int, float>> TestDoc(ReadOnlySpan`1<int> termID, ReadOnlySpan`1<double> termVal, int termNum, int numBurninIter, bool reset);
    public List`1<KeyValuePair`2<int, float>> TestDocDense(ReadOnlySpan`1<double> termVal, int termNum, int numBurninIter, bool reset);
    public void InitializeBeforeTrain();
    public void InitializeBeforeTest();
    public KeyValuePair`2[] GetModel(int wordId);
    public KeyValuePair`2[] GetTopicSummary(int topicId);
    public void SetModel(int termID, Int32[] topicID, Int32[] topicProb, int topicNum);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Microsoft.ML.TextCatalog : object {
    [ExtensionAttribute]
public static TextFeaturizingEstimator FeaturizeText(TextTransforms catalog, string outputColumnName, string inputColumnName);
    [ExtensionAttribute]
public static TextFeaturizingEstimator FeaturizeText(TextTransforms catalog, string outputColumnName, Options options, String[] inputColumnNames);
    [ExtensionAttribute]
public static TokenizingByCharactersEstimator TokenizeIntoCharactersAsKeys(TextTransforms catalog, string outputColumnName, string inputColumnName, bool useMarkerCharacters);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static TokenizingByCharactersEstimator TokenizeIntoCharactersAsKeys(TextTransforms catalog, bool useMarkerCharacters, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static TextNormalizingEstimator NormalizeText(TextTransforms catalog, string outputColumnName, string inputColumnName, CaseMode caseMode, bool keepDiacritics, bool keepPunctuations, bool keepNumbers);
    [ExtensionAttribute]
public static WordEmbeddingEstimator ApplyWordEmbedding(TextTransforms catalog, string outputColumnName, string inputColumnName, PretrainedModelKind modelKind);
    [ExtensionAttribute]
public static WordEmbeddingEstimator ApplyWordEmbedding(TextTransforms catalog, string outputColumnName, string customModelFile, string inputColumnName);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static WordEmbeddingEstimator ApplyWordEmbedding(TextTransforms catalog, PretrainedModelKind modelKind, ColumnOptions[] columns);
    [ExtensionAttribute]
public static WordTokenizingEstimator TokenizeIntoWords(TextTransforms catalog, string outputColumnName, string inputColumnName, Char[] separators);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static WordTokenizingEstimator TokenizeIntoWords(TextTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static NgramExtractingEstimator ProduceNgrams(TextTransforms catalog, string outputColumnName, string inputColumnName, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static NgramExtractingEstimator ProduceNgrams(TextTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static StopWordsRemovingEstimator RemoveDefaultStopWords(TextTransforms catalog, string outputColumnName, string inputColumnName, Language language);
    [ExtensionAttribute]
public static CustomStopWordsRemovingEstimator RemoveStopWords(TextTransforms catalog, string outputColumnName, string inputColumnName, String[] stopwords);
    [ExtensionAttribute]
public static WordBagEstimator ProduceWordBags(TextTransforms catalog, string outputColumnName, string inputColumnName, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting);
    [ExtensionAttribute]
public static WordBagEstimator ProduceWordBags(TextTransforms catalog, string outputColumnName, char termSeparator, char freqSeparator, string inputColumnName, int maximumNgramsCount);
    [ExtensionAttribute]
public static WordBagEstimator ProduceWordBags(TextTransforms catalog, string outputColumnName, String[] inputColumnNames, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting);
    [ExtensionAttribute]
public static WordHashBagEstimator ProduceHashedWordBags(TextTransforms catalog, string outputColumnName, string inputColumnName, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    [ExtensionAttribute]
public static WordHashBagEstimator ProduceHashedWordBags(TextTransforms catalog, string outputColumnName, String[] inputColumnNames, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    [ExtensionAttribute]
public static NgramHashingEstimator ProduceHashedNgrams(TextTransforms catalog, string outputColumnName, string inputColumnName, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts, bool rehashUnigrams);
    [ExtensionAttribute]
public static NgramHashingEstimator ProduceHashedNgrams(TextTransforms catalog, string outputColumnName, String[] inputColumnNames, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts, bool rehashUnigrams);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static NgramHashingEstimator ProduceHashedNgrams(TextTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static LatentDirichletAllocationEstimator LatentDirichletAllocation(TextTransforms catalog, string outputColumnName, string inputColumnName, int numberOfTopics, float alphaSum, float beta, int samplingStepCount, int maximumNumberOfIterations, int likelihoodInterval, int numberOfThreads, int maximumTokenCountPerDocument, int numberOfSummaryTermsPerTopic, int numberOfBurninIterations, bool resetRandomGenerator);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static LatentDirichletAllocationEstimator LatentDirichletAllocation(TextTransforms catalog, ColumnOptions[] columns);
}
public class Microsoft.ML.Transforms.ApproximatedKernelMappingEstimator : object {
    private IHost _host;
    private ColumnOptions[] _columns;
    internal ApproximatedKernelMappingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int rank, bool useCosAndSinBases);
    internal ApproximatedKernelMappingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    public sealed virtual ApproximatedKernelTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.ApproximatedKernelTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    private TransformInfo[] _transformInfos;
    private static int _cfltAlign;
    internal ApproximatedKernelTransformer(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    private ApproximatedKernelTransformer(IHost host, ModelLoadContext ctx);
    private static ApproximatedKernelTransformer();
    private static VersionInfo GetVersionInfo();
    private static string TestColumnType(DataViewType type);
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private static int RoundUp(int cflt, int cfltAlign);
    private Single[] GetAvgDistances(ColumnOptions[] columns, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static ApproximatedKernelTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.BagMultiCountTableBuilder : MultiCountTableBuilderBase {
    private IHost _host;
    private InternalCountTableBuilderBase _builder;
    private int _colCount;
    private Int32[] _slotCount;
    public static string LoaderSignature;
    public BagMultiCountTableBuilder(IHostEnvironment env, Column[] inputColumns, CountTableBuilderBase builder, long labelCardinality);
    public BagMultiCountTableBuilder(IHostEnvironment env, MultiCountTable table, Column[] inputCols, long labelCardinality);
    public virtual void IncrementSlot(int iCol, int iSlot, UInt32 key, UInt32 labelKey);
    public virtual MultiCountTableBase CreateMultiCountTable();
}
internal enum Microsoft.ML.Transforms.BinaryOp : Enum {
    public int value__;
    public static BinaryOp Coalesce;
    public static BinaryOp Or;
    public static BinaryOp And;
    public static BinaryOp Add;
    public static BinaryOp Sub;
    public static BinaryOp Mul;
    public static BinaryOp Div;
    public static BinaryOp Mod;
    public static BinaryOp Power;
    public static BinaryOp Error;
}
internal class Microsoft.ML.Transforms.BinaryOpNode : ExprNode {
    public ExprNode Left;
    public ExprNode Right;
    public BinaryOp Op;
    public bool ReduceToLeft;
    public bool ReduceToRight;
    public NodeKind Kind { get; }
    public BinaryOpNode AsBinaryOp { get; }
    public BinaryOpNode TestBinaryOp { get; }
    public BinaryOpNode(Token tok, BinaryOp op, ExprNode left, ExprNode right);
    public virtual NodeKind get_Kind();
    public virtual BinaryOpNode get_AsBinaryOp();
    public virtual BinaryOpNode get_TestBinaryOp();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.BoolLitNode : ExprNode {
    public bool Value { get; }
    public NodeKind Kind { get; }
    public BoolLitNode AsBoolLit { get; }
    public BoolLitNode TestBoolLit { get; }
    public BoolLitNode(Token tok);
    public bool get_Value();
    public virtual NodeKind get_Kind();
    public virtual BoolLitNode get_AsBoolLit();
    public virtual BoolLitNode get_TestBoolLit();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.BuiltinFunctions : object {
    private static BuiltinFunctions modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static BuiltinFunctions Instance { get; }
    public string NameSpace { get; }
    public static BuiltinFunctions get_Instance();
    public sealed virtual string get_NameSpace();
    private static MethodInfo Id();
    private static void Id(T src);
    public sealed virtual MethodInfo[] Lookup(string name);
    public sealed virtual object ResolveToConstant(string name, MethodInfo fn, Object[] values);
    public static double Pi();
    public static float NA(float a);
    public static double NA(double a);
    public static int Default(int a);
    public static long Default(long a);
    public static float Default(float a);
    public static double Default(double a);
    public static bool Default(bool a);
    public static ReadOnlyMemory`1<char> Default(ReadOnlyMemory`1<char> a);
    public static float Sign(float a);
    public static double Sign(double a);
    public static int Sign(int a);
    public static long Sign(long a);
    public static float Pow(float a, float b);
    public static float Exp(float a);
    public static float Log(float a);
    public static float Log(float a, float b);
    public static float Deg(float a);
    public static double Deg(double a);
    public static float Rad(float a);
    public static double Rad(double a);
    public static float Sin(float a);
    public static double Sin(double a);
    public static float SinD(float a);
    public static double SinD(double a);
    public static float Cos(float a);
    public static double Cos(double a);
    public static float CosD(float a);
    public static double CosD(double a);
    public static float Tan(float a);
    public static float TanD(float a);
    public static double TanD(double a);
    public static float Asin(float a);
    public static float Acos(float a);
    public static float Atan(float a);
    public static float Atan2(float a, float b);
    public static double Atan2(double a, double b);
    public static float Sinh(float a);
    public static float Cosh(float a);
    public static float Tanh(float a);
    public static float Sqrt(float a);
    public static float Truncate(float a);
    public static float Floor(float a);
    public static float Ceiling(float a);
    public static float Round(float a);
    public static ReadOnlyMemory`1<char> Lower(ReadOnlyMemory`1<char> a);
    public static ReadOnlyMemory`1<char> Upper(ReadOnlyMemory`1<char> a);
    public static ReadOnlyMemory`1<char> Empty();
    public static ReadOnlyMemory`1<char> Concat(ReadOnlyMemory`1<char> a, ReadOnlyMemory`1<char> b);
    public static ReadOnlyMemory`1<char> Concat(ReadOnlyMemory`1<char> a, ReadOnlyMemory`1<char> b, ReadOnlyMemory`1<char> c);
    public static ReadOnlyMemory`1<char> Concat(ReadOnlyMemory`1[] a);
    public static int Len(ReadOnlyMemory`1<char> a);
    private static int NormalizeIndex(int i, int len);
    public static ReadOnlyMemory`1<char> Right(ReadOnlyMemory`1<char> a, int min);
    public static ReadOnlyMemory`1<char> Left(ReadOnlyMemory`1<char> a, int lim);
    public static ReadOnlyMemory`1<char> Mid(ReadOnlyMemory`1<char> a, int min, int lim);
    public static bool IsNA(float a);
    public static bool IsNA(double a);
    public static bool ToBL(ReadOnlyMemory`1<char> a);
    public static int ToI4(ReadOnlyMemory`1<char> a);
    public static long ToI8(ReadOnlyMemory`1<char> a);
    public static float ToR4(float a);
    public static float ToR4(double a);
    public static float ToR4(ReadOnlyMemory`1<char> a);
    public static double ToR8(float a);
    public static double ToR8(double a);
    public static double ToR8(ReadOnlyMemory`1<char> a);
    public static ReadOnlyMemory`1<char> ToTX(int src);
    public static ReadOnlyMemory`1<char> ToTX(long src);
    public static ReadOnlyMemory`1<char> ToTX(float src);
    public static ReadOnlyMemory`1<char> ToTX(double src);
    public static ReadOnlyMemory`1<char> ToTX(bool src);
    public static bool Equals(ReadOnlyMemory`1<char> first, ReadOnlyMemory`1<char> second);
    public static bool NotEquals(ReadOnlyMemory`1<char> first, ReadOnlyMemory`1<char> second);
    public static byte Not(bool b);
    public static bool False();
    public static bool True();
    public static int Pow(int a, int b);
    public static long Pow(long a, long b);
}
internal class Microsoft.ML.Transforms.CallNode : ExprNode {
    public NameNode NameSpace;
    public Token Dot;
    public NameNode Head;
    public ListNode Args;
    public Token CloseToken;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    public MethodInfo Method { get; private set; }
    public NodeKind Kind { get; }
    public CallNode AsCall { get; }
    public CallNode TestCall { get; }
    public CallNode(Token tok, NameNode head, ListNode args, Token tokClose);
    public CallNode(Token tok, NameNode ns, Token dot, NameNode head, ListNode args, Token tokClose);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(MethodInfo value);
    public virtual NodeKind get_Kind();
    public virtual CallNode get_AsCall();
    public virtual CallNode get_TestCall();
    public virtual void Accept(NodeVisitor visitor);
    public void SetMethod(MethodInfo meth);
}
internal static class Microsoft.ML.Transforms.Categorical : object {
    [EntryPointAttribute]
public static TransformOutput CatTransformDict(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput CatTransformHash(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput TextToKey(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput KeyToText(IHostEnvironment env, Options input);
}
internal class Microsoft.ML.Transforms.CharCursor : object {
    private Char[] _buffer;
    private int _ichBase;
    private int _ichNext;
    private int _ichLim;
    private bool _fNoMore;
    [CompilerGeneratedAttribute]
private bool <Eof>k__BackingField;
    [CompilerGeneratedAttribute]
private char <ChCur>k__BackingField;
    public bool Eof { get; private set; }
    public int IchCur { get; }
    public char ChCur { get; private set; }
    public CharCursor(string text);
    public CharCursor(string text, int ichMin, int ichLim);
    private CharCursor(Char[] buffer, int ichLimInit);
    [CompilerGeneratedAttribute]
public bool get_Eof();
    [CompilerGeneratedAttribute]
private void set_Eof(bool value);
    public int get_IchCur();
    [CompilerGeneratedAttribute]
public char get_ChCur();
    [CompilerGeneratedAttribute]
private void set_ChCur(char value);
    public char ChNext();
    public char ChPeek(int dich);
    private bool EnsureMore();
}
internal class Microsoft.ML.Transforms.CharLitToken : Token {
    public char Value;
    public CharLitToken(TextSpan span, char val);
    public virtual string ToString();
}
internal class Microsoft.ML.Transforms.CMCountTable : CountTableBase {
    public static string LoaderSignature;
    public int Depth;
    public int Width;
    [CompilerGeneratedAttribute]
private Dictionary`2[][] <Tables>k__BackingField;
    public Dictionary`2[][] Tables { get; }
    public CMCountTable(Dictionary`2[][] tables, Single[] priorCounts, int depth, int width);
    private CMCountTable(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    [CompilerGeneratedAttribute]
public Dictionary`2[][] get_Tables();
    public static CMCountTable Create(IHostEnvironment env, ModelLoadContext ctx);
    public virtual void Save(ModelSaveContext ctx);
    public virtual void GetCounts(long key, Span`1<float> counts);
    public virtual InternalCountTableBuilderBase ToBuilder(long labelCardinality);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__7_0(Dictionary`2[] x);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__7_1(Dictionary`2[] t);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__7_2(Dictionary`2<int, float> t2);
}
internal class Microsoft.ML.Transforms.CMCountTableBuilder : CountTableBuilderBase {
    private static int DepthLim;
    public static string LoaderSignature;
    private int _depth;
    private int _width;
    public CMCountTableBuilder(int depth, int width);
    internal CMCountTableBuilder(IHostEnvironment env, Options options);
    internal virtual InternalCountTableBuilderBase GetInternalBuilder(long labelCardinality);
}
internal class Microsoft.ML.Transforms.CommentToken : Token {
    public string Text;
    public int NewLineCount;
    public CommentToken(TextSpan span, string val, int lines);
    public virtual string ToString();
}
internal class Microsoft.ML.Transforms.CompareNode : ExprNode {
    public CompareOp Op;
    public ListNode Operands;
    public TokKind TidStrict;
    public TokKind TidLax;
    public ExprTypeKind ArgTypeKind;
    public NodeKind Kind { get; }
    public CompareNode AsCompare { get; }
    public CompareNode TestCompare { get; }
    public CompareNode(Token tok, CompareOp op, ListNode operands);
    public virtual NodeKind get_Kind();
    public virtual CompareNode get_AsCompare();
    public virtual CompareNode get_TestCompare();
    public virtual void Accept(NodeVisitor visitor);
}
internal enum Microsoft.ML.Transforms.CompareOp : Enum {
    public int value__;
    public static CompareOp Equal;
    public static CompareOp NotEqual;
    public static CompareOp IncrChain;
    public static CompareOp DecrChain;
}
internal static class Microsoft.ML.Transforms.CompositeTransformer : object {
    private static string RegistrationName;
    public static string LoaderSignature;
    private static VersionInfo GetVersionInfo();
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
}
internal class Microsoft.ML.Transforms.ConditionalNode : ExprNode {
    public ExprNode Cond;
    public ExprNode Left;
    public Token TokColon;
    public ExprNode Right;
    public NodeKind Kind { get; }
    public ConditionalNode AsConditional { get; }
    public ConditionalNode TestConditional { get; }
    public ConditionalNode(Token tok, ExprNode cond, ExprNode left, Token tokColon, ExprNode right);
    public virtual NodeKind get_Kind();
    public virtual ConditionalNode get_AsConditional();
    public virtual ConditionalNode get_TestConditional();
    public virtual void Accept(NodeVisitor visitor);
}
public class Microsoft.ML.Transforms.CountFeatureSelectingEstimator : object {
    internal static string Summary;
    internal static string UserName;
    private IHost _host;
    private ColumnOptions[] _columns;
    internal static string RegistrationName;
    internal CountFeatureSelectingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal CountFeatureSelectingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, long minCount);
    private static CountFeatureSelectingEstimator();
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual ITransformer Fit(IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static void CreateDropAndCopyColumns(ColumnOptions[] columnOptions, int size, Int64[][] scores, Int32[]& selectedCount, ColumnOptions[]& dropSlotsColumns, ValueTuple`2[]& copyColumnsPairs);
}
internal static class Microsoft.ML.Transforms.CountFeatureSelectionUtils : object {
    public static Int64[][] Train(IHostEnvironment env, IDataView input, String[] columns, Int32[]& colSizes);
    public static bool IsValidColumnType(DataViewType type);
    private static CountAggregator GetOneAggregator(DataViewRow row, DataViewType colType, int colSrc);
    private static CountAggregator GetOneAggregator(DataViewRow row, DataViewType colType, int colSrc);
    private static CountAggregator GetVecAggregator(DataViewRow row, VectorDataViewType colType, int colSrc);
    private static CountAggregator GetVecAggregator(DataViewRow row, VectorDataViewType colType, int colSrc);
}
internal static class Microsoft.ML.Transforms.CountTable : object {
    [EntryPointAttribute]
internal static TransformOutput Create(IHostEnvironment env, Options input);
}
internal abstract class Microsoft.ML.Transforms.CountTableBase : object {
    public static int LabelCardinalityLim;
    public int LabelCardinality;
    private Double[] _priorFrequencies;
    [CompilerGeneratedAttribute]
private float <GarbageThreshold>k__BackingField;
    private Single[] _garbageCounts;
    public float GarbageThreshold { get; private set; }
    public IReadOnlyCollection`1<float> GarbageCounts { get; }
    public ReadOnlySpan`1<double> PriorFrequencies { get; }
    protected CountTableBase(int labelCardinality, Single[] priorCounts, float garbageThreshold, Single[] garbageCounts);
    protected CountTableBase(IHostEnvironment env, string name, ModelLoadContext ctx);
    [CompilerGeneratedAttribute]
public sealed virtual float get_GarbageThreshold();
    [CompilerGeneratedAttribute]
private void set_GarbageThreshold(float value);
    public sealed virtual IReadOnlyCollection`1<float> get_GarbageCounts();
    public sealed virtual ReadOnlySpan`1<double> get_PriorFrequencies();
    public abstract virtual void GetCounts(long key, Span`1<float> counts);
    public virtual void Save(ModelSaveContext ctx);
    public abstract virtual InternalCountTableBuilderBase ToBuilder(long labelCardinality);
}
internal abstract class Microsoft.ML.Transforms.CountTableBuilderBase : object {
    internal abstract virtual InternalCountTableBuilderBase GetInternalBuilder(long labelCardinality);
    public static CountTableBuilderBase CreateCMCountTableBuilder(int depth, int width);
    public static CountTableBuilderBase CreateDictionaryCountTableBuilder(float garbageThreshold);
}
internal class Microsoft.ML.Transforms.CountTableEstimator : object {
    private IHost _host;
    private ColumnOptionsBase[] _columns;
    private CountTableBuilderBase[] _builders;
    private CountTableBuilderBase _sharedBuilder;
    private string _labelColumnName;
    private CountTableTransformer _initialCounts;
    internal CountTableEstimator(IHostEnvironment env, string labelColumnName, CountTableBuilderBase countTableBuilder, SharedColumnOptions[] columns);
    internal CountTableEstimator(IHostEnvironment env, string labelColumnName, ColumnOptions[] columns);
    internal CountTableEstimator(IHostEnvironment env, string labelColumnName, CountTableTransformer initial, InputOutputColumnPair[] columns);
    private CountTableEstimator(IHostEnvironment env, string labelColumnName, ColumnOptionsBase[] columns);
    private static ColumnOptionsBase[] ExtractColumnOptions(CountTableTransformer initial, InputOutputColumnPair[] columns);
    public sealed virtual CountTableTransformer Fit(IDataView input);
    private void TrainTables(IDataView trainingData, List`1<Column> cols, MultiCountTableBuilderBase builder, Column labelColumn);
    private ValueGetter`1<long> GetLabelGetter(DataViewRow row, Column col);
    private void IncrementVec(MultiCountTableBuilderBase builder, int iCol, VBuffer`1& srcBuffer, UInt32 labelKey);
    private void CheckLabelType(RoleMappedData data, Int32& labelCardinality);
    private static String[] InitLabelClassNames(IExceptionContext ectx, Column labelCol, int labelCardinality);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal class Microsoft.ML.Transforms.CountTableTransformer : OneToOneTransformerBase {
    internal CountTargetEncodingFeaturizer Featurizer;
    private String[] _labelClassNames;
    [CompilerGeneratedAttribute]
private Int32[] <Seeds>k__BackingField;
    internal static string Summary;
    internal static string LoaderSignature;
    internal static string UserName;
    internal Int32[] Seeds { get; }
    internal CountTableTransformer(IHostEnvironment env, CountTargetEncodingFeaturizer featurizer, String[] labelClassNames, Int32[] seeds, ValueTuple`2[] columns);
    private CountTableTransformer(IHost host, ModelLoadContext ctx);
    [CompilerGeneratedAttribute]
internal Int32[] get_Seeds();
    private static VersionInfo GetVersionInfo();
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    internal static CountTableTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private sealed virtual override IDataView Microsoft.ML.ITransformerWithDifferentMappingAtTrainingTime.TransformForTrainingPipeline(IDataView input);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private IRowMapper MakeRowMapperWithNoise(DataViewSchema schema);
}
internal static class Microsoft.ML.Transforms.CountTargetEncoder : object {
    [EntryPointAttribute]
internal static TransformOutput Create(IHostEnvironment env, Options input);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Transforms.CountTargetEncodingCatalog : object {
    [ExtensionAttribute]
public static CountTargetEncodingEstimator CountTargetEncode(TransformsCatalog catalog, InputOutputColumnPair[] columns, string labelColumn, CountTableBuilderBase builder, float priorCoefficient, float laplaceScale, bool sharedTable, int numberOfBits, bool combine, UInt32 hashingSeed);
    [ExtensionAttribute]
public static CountTargetEncodingEstimator CountTargetEncode(TransformsCatalog catalog, InputOutputColumnPair[] columns, CountTargetEncodingTransformer initialCounts, string labelColumn);
    [ExtensionAttribute]
public static CountTargetEncodingEstimator CountTargetEncode(TransformsCatalog catalog, string outputColumnName, string inputColumnName, string labelColumn, CountTableBuilderBase builder, float priorCoefficient, float laplaceScale, int numberOfBits, bool combine, UInt32 hashingSeed);
    [ExtensionAttribute]
public static CountTargetEncodingEstimator CountTargetEncode(TransformsCatalog catalog, string outputColumnName, CountTargetEncodingTransformer initialCounts, string inputColumnName, string labelColumn);
}
internal class Microsoft.ML.Transforms.CountTargetEncodingEstimator : object {
    private IHost _host;
    private ColumnOptions[] _hashingColumns;
    private HashingEstimator _hashingEstimator;
    private CountTableEstimator _countTableEstimator;
    internal CountTargetEncodingEstimator(IHostEnvironment env, string labelColumnName, ColumnOptions[] columnOptions, int numberOfBits, bool combine, UInt32 hashingSeed);
    internal CountTargetEncodingEstimator(IHostEnvironment env, string labelColumnName, SharedColumnOptions[] columnOptions, CountTableBuilderBase countTableBuilder, int numberOfBits, bool combine, UInt32 hashingSeed);
    internal CountTargetEncodingEstimator(IHostEnvironment env, string labelColumnName, CountTargetEncodingTransformer initialCounts, InputOutputColumnPair[] columns);
    private CountTargetEncodingEstimator(IHostEnvironment env, CountTableEstimator estimator, ColumnOptionsBase[] columns, int numberOfBits, bool combine, UInt32 hashingSeed);
    internal CountTargetEncodingEstimator(IHostEnvironment env, Options options);
    internal static CountTableEstimator LoadFromFile(IHostEnvironment env, string initialCountsModel, string labelColumn, InputOutputColumnPair[] columns);
    private ColumnOptions[] InitializeHashingColumnOptions(ColumnOptionsBase[] columns, int numberOfBits, bool combine, UInt32 hashingSeed);
    private ColumnOptions[] InitializeHashingColumnOptions(Options options);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static CountTargetEncodingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    public sealed virtual CountTargetEncodingTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal class Microsoft.ML.Transforms.CountTargetEncodingFeaturizer : object {
    private IHost _host;
    private int _labelBinCount;
    private int _logOddsCount;
    private MultiCountTableBase _countTables;
    [CompilerGeneratedAttribute]
private Single[] <PriorCoef>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[] <LaplaceScale>k__BackingField;
    internal static string RegistrationName;
    [CompilerGeneratedAttribute]
private int <NumFeatures>k__BackingField;
    public MultiCountTableBase MultiCountTable { get; }
    public Single[] PriorCoef { get; }
    public Single[] LaplaceScale { get; }
    public int ColCount { get; }
    public ReadOnlySpan`1<int> SlotCount { get; }
    public int NumFeatures { get; }
    public CountTargetEncodingFeaturizer(IHostEnvironment env, Single[] priorCoef, Single[] laplaceScale, long labelBinCount, MultiCountTableBase countTable);
    public CountTargetEncodingFeaturizer(IHostEnvironment env, ModelLoadContext ctx);
    public MultiCountTableBase get_MultiCountTable();
    [CompilerGeneratedAttribute]
public Single[] get_PriorCoef();
    [CompilerGeneratedAttribute]
public Single[] get_LaplaceScale();
    private static VersionInfo GetVersionInfo();
    public int get_ColCount();
    public ReadOnlySpan`1<int> get_SlotCount();
    public sealed virtual void Save(ModelSaveContext ctx);
    [CompilerGeneratedAttribute]
public int get_NumFeatures();
    public void GetFeatureNames(String[] classNames, VBuffer`1& featureNames);
    public void GetFeatures(int iCol, int iSlot, Random rand, long key, Span`1<float> features);
    private float AddLaplacianNoisePerLabel(int iCol, Random rand, Span`1<float> counts);
    private void GenerateLogOdds(int iCol, ICountTable countTable, Span`1<float> counts, Span`1<float> logOdds, float sum);
}
internal class Microsoft.ML.Transforms.CountTargetEncodingTransformer : object {
    private IHost _host;
    public CountTableTransformer CountTable;
    public HashingTransformer HashingTransformer;
    internal static string Summary;
    internal static string LoaderSignature;
    internal static string UserName;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    internal CountTargetEncodingTransformer(IHostEnvironment env, HashingTransformer hashingTransformer, CountTableTransformer countTable);
    private CountTargetEncodingTransformer(IHost host, ModelLoadContext ctx);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private static VersionInfo GetVersionInfo();
    public sealed virtual void Save(ModelSaveContext ctx);
    internal static CountTargetEncodingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override IDataView Microsoft.ML.ITransformerWithDifferentMappingAtTrainingTime.TransformForTrainingPipeline(IDataView input);
    internal bool VerifyColumns(InputOutputColumnPair[] columns);
    [CompilerGeneratedAttribute]
private bool <VerifyColumns>b__17_0(InputOutputColumnPair c);
    [CompilerGeneratedAttribute]
private bool <VerifyColumns>b__17_1(InputOutputColumnPair c);
}
public class Microsoft.ML.Transforms.CustomMappingEstimator`2 : TrivialEstimator`1<CustomMappingTransformer`2<TSrc, TDst>> {
    internal CustomMappingEstimator`2(IHostEnvironment env, Action`2<TSrc, TDst> mapAction, string contractName, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public abstract class Microsoft.ML.Transforms.CustomMappingFactory`2 : object {
    public abstract virtual Action`2<TSrc, TDst> GetMapping();
    private sealed virtual override ITransformer Microsoft.ML.Transforms.ICustomMappingFactory.CreateTransformer(IHostEnvironment env, string contractName);
}
[AttributeUsageAttribute("4")]
public class Microsoft.ML.Transforms.CustomMappingFactoryAttributeAttribute : ExtensionBaseAttribute {
    public CustomMappingFactoryAttributeAttribute(string contractName);
}
internal class Microsoft.ML.Transforms.CustomMappingFilter`1 : CustomMappingFilterBase`1<TSrc> {
    private Func`2<TSrc, bool> _predicate;
    public bool CanShuffle { get; }
    public CustomMappingFilter`1(IHostEnvironment env, IDataView input, Func`2<TSrc, bool> predicate);
    public virtual bool get_CanShuffle();
    protected virtual DataViewRowCursor GetRowCursorCore(DataViewRowCursor input, Boolean[] active);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
internal abstract class Microsoft.ML.Transforms.CustomMappingFilterBase`1 : object {
    protected IDataView Input;
    protected TypedCursorable`1<TSrc> TypedSrc;
    protected IHost Host;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    private protected CustomMappingFilterBase`1(IHostEnvironment env, IDataView input);
    public abstract virtual bool get_CanShuffle();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    protected abstract virtual DataViewRowCursor GetRowCursorCore(DataViewRowCursor input, Boolean[] active);
    public abstract virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
public class Microsoft.ML.Transforms.CustomMappingTransformer`2 : object {
    private IHost _host;
    private Action`2<TSrc, TDst> _mapAction;
    private string _contractName;
    private string _contractAssembly;
    [CompilerGeneratedAttribute]
private InternalSchemaDefinition <AddedSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaDefinition <InputSchemaDefinition>k__BackingField;
    internal InternalSchemaDefinition AddedSchema { get; }
    internal SchemaDefinition InputSchemaDefinition { get; }
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    internal CustomMappingTransformer`2(IHostEnvironment env, Action`2<TSrc, TDst> mapAction, string contractName, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition);
    [CompilerGeneratedAttribute]
internal InternalSchemaDefinition get_AddedSchema();
    [CompilerGeneratedAttribute]
internal SchemaDefinition get_InputSchemaDefinition();
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    internal void SaveModel(ModelSaveContext ctx);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
    private IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.DblLitToken : NumLitToken {
    public double Value;
    public bool HasSuffix;
    public DblLitToken(TextSpan span, double val, bool hasSuf);
    public virtual string ToString();
    private static bool AllDigits(string s);
}
internal class Microsoft.ML.Transforms.DictCountTable : CountTableBase {
    public static string LoaderSignature;
    [CompilerGeneratedAttribute]
private Dictionary`2[] <Tables>k__BackingField;
    public Dictionary`2[] Tables { get; }
    public DictCountTable(Dictionary`2[] counts, int labelCardinality, Single[] priorCounts, float garbageThreshold, Single[] garbageCounts);
    private DictCountTable(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    [CompilerGeneratedAttribute]
public Dictionary`2[] get_Tables();
    public static DictCountTable Create(IHostEnvironment env, ModelLoadContext ctx);
    public virtual void Save(ModelSaveContext ctx);
    public virtual void GetCounts(long key, Span`1<float> counts);
    public virtual InternalCountTableBuilderBase ToBuilder(long labelCardinality);
}
internal class Microsoft.ML.Transforms.DictCountTableBuilder : CountTableBuilderBase {
    public static string LoaderSignature;
    private float _garbageThreshold;
    private DictCountTableBuilder(IHostEnvironment env, Arguments args);
    internal DictCountTableBuilder(float garbageThreshold);
    internal virtual InternalCountTableBuilderBase GetInternalBuilder(long labelCardinality);
}
internal class Microsoft.ML.Transforms.EofToken : Token {
    public EofToken(TextSpan span);
}
public enum Microsoft.ML.Transforms.ErrId : Enum {
    public int value__;
    public static ErrId None;
    public static ErrId BadChar;
    public static ErrId BadEscape;
    public static ErrId CharConstEmpty;
    public static ErrId CharConstTooLong;
    public static ErrId FloatOverflow;
    public static ErrId IntOverflow;
    public static ErrId NewlineInConst;
    public static ErrId UnterminatedComment;
    public static ErrId UnterminatedString;
    public static ErrId VerbatimLiteralExpected;
    public static ErrId BadPreProcPos;
    public static ErrId EndOfPreLineExpected;
    public static ErrId IdentExpected;
    public static ErrId PreProcDirExpected;
    public static ErrId UniEscInPreProc;
}
[ExtensionAttribute]
internal static class Microsoft.ML.Transforms.ErrIdExt : object {
    [ExtensionAttribute]
public static string GetMsgFmt(ErrId eid, Int32& carg);
    [ExtensionAttribute]
public static string GetMsg(ErrId eid, Object[] args);
}
internal class Microsoft.ML.Transforms.Error : object {
    public Token Token;
    public string Message;
    public Object[] Args;
    public Error(Token tok, string msg);
    public Error(Token tok, string msg, Object[] args);
    public string GetMessage();
}
internal class Microsoft.ML.Transforms.ErrorToken : Token {
    public ErrId Id;
    public Object[] Args;
    public ErrorToken(TextSpan span, ErrId eid, Object[] args);
    public virtual string ToString();
}
internal class Microsoft.ML.Transforms.Exec : object {
    public static ReadOnlyMemory`1<char> ToTX(string str);
}
public class Microsoft.ML.Transforms.ExpressionEstimator : object {
    private IHost _host;
    private ColumnOptions[] _columns;
    internal ExpressionEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal static LambdaNode ParseAndBindLambda(IHostEnvironment env, string expression, int ivec, DataViewType[] inputTypes, Int32[]& perm);
    private static int FindVectorInputColumn(IHostEnvironment env, IReadOnlyList`1<string> inputColumnNames, SchemaShape inputSchema, DataViewType[] inputTypes);
    private static int FindVectorInputColumn(IHostEnvironment env, IReadOnlyList`1<string> inputColumnNames, DataViewSchema inputSchema, DataViewType[] inputTypes);
    public sealed virtual ExpressionTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.ExpressionTransformer : RowToRowTransformerBase {
    private ColumnInfo[] _columns;
    internal static string Summary;
    public static string LoaderSignature;
    internal ExpressionTransformer(IHostEnvironment env, ColumnInfo[] columns);
    private static VersionInfo GetVersionInfo();
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private static ExpressionTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private Delegate MakeGetter(IExceptionContext ectx, DataViewRow input, int iinfo);
    private ValueGetter`1<TDst> GetGetter(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Delegate del);
    private ValueGetter`1<TDst> GetGetter(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Delegate del);
    private ValueGetter`1<TDst> GetGetter(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Delegate del);
    private ValueGetter`1<TDst> GetGetter(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Delegate del);
    private ValueGetter`1<TDst> GetGetter(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Delegate del);
    private Delegate MakeGetterVec(IExceptionContext ectx, DataViewRow input, int iinfo);
    private ValueGetter`1<VBuffer`1<TDst>> GetGetterVec(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Int32[] perm, Delegate del, DataViewType outputColumnItemType);
    private ValueGetter`1<VBuffer`1<TDst>> GetGetterVec(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Int32[] perm, Delegate del, DataViewType outputColumnItemType);
    private ValueGetter`1<VBuffer`1<TDst>> GetGetterVec(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Int32[] perm, Delegate del, DataViewType outputColumnItemType);
    private ValueGetter`1<VBuffer`1<TDst>> GetGetterVec(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Int32[] perm, Delegate del, DataViewType outputColumnItemType);
    private ValueGetter`1<VBuffer`1<TDst>> GetGetterVec(IExceptionContext ectx, DataViewRow input, Column[] inputColumns, Int32[] perm, Delegate del, DataViewType outputColumnItemType);
}
internal abstract class Microsoft.ML.Transforms.ExprNode : Node {
    [CompilerGeneratedAttribute]
private ExprTypeKind <ExprType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExprValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExprTypeKind <SrcKind>k__BackingField;
    public ExprNode AsExpr { get; }
    public ExprNode TestExpr { get; }
    public ExprTypeKind ExprType { get; private set; }
    public object ExprValue { get; private set; }
    public bool HasType { get; }
    public bool IsNone { get; }
    public bool IsError { get; }
    public bool IsBool { get; }
    public bool IsNumber { get; }
    public bool IsI4 { get; }
    public bool IsI8 { get; }
    public bool IsRx { get; }
    public bool IsR4 { get; }
    public bool IsR8 { get; }
    public bool IsTX { get; }
    public ExprTypeKind SrcKind { get; private set; }
    public bool NeedsConversion { get; }
    protected ExprNode(Token tok);
    public virtual ExprNode get_AsExpr();
    public virtual ExprNode get_TestExpr();
    [CompilerGeneratedAttribute]
public ExprTypeKind get_ExprType();
    [CompilerGeneratedAttribute]
private void set_ExprType(ExprTypeKind value);
    [CompilerGeneratedAttribute]
public object get_ExprValue();
    [CompilerGeneratedAttribute]
private void set_ExprValue(object value);
    private bool IsSimple(ExprTypeKind kind);
    public bool get_HasType();
    public bool get_IsNone();
    public bool get_IsError();
    public bool get_IsBool();
    public bool get_IsNumber();
    public bool get_IsI4();
    public bool get_IsI8();
    public bool get_IsRx();
    public bool get_IsR4();
    public bool get_IsR8();
    public bool get_IsTX();
    [CompilerGeneratedAttribute]
public ExprTypeKind get_SrcKind();
    [CompilerGeneratedAttribute]
private void set_SrcKind(ExprTypeKind value);
    public bool get_NeedsConversion();
    public void SetType(ExprTypeKind kind);
    public void SetType(ExprTypeKind kind, object value);
    internal static Type ToSysType(ExprTypeKind kind);
    internal static ExprTypeKind ToExprTypeKind(Type type);
    public void SetValue(ExprNode expr);
    public void SetValue(bool value);
    public void SetValue(Nullable`1<bool> value);
    public void SetValue(int value);
    public void SetValue(Nullable`1<int> value);
    public void SetValue(long value);
    public void SetValue(Nullable`1<long> value);
    public void SetValue(float value);
    public void SetValue(Nullable`1<float> value);
    public void SetValue(double value);
    public void SetValue(Nullable`1<double> value);
    public void SetValue(ReadOnlyMemory`1<char> value);
    public void SetValue(Nullable`1<ReadOnlyMemory`1<char>> value);
    public void Convert(ExprTypeKind kind);
    public bool TryGet(Nullable`1& value);
    public bool TryGet(Nullable`1& value);
    public bool TryGet(Nullable`1& value);
    public bool TryGet(Nullable`1& value);
    public bool TryGet(Nullable`1& value);
    public bool TryGet(Nullable`1& value);
}
internal enum Microsoft.ML.Transforms.ExprTypeKind : Enum {
    public int value__;
    public static ExprTypeKind None;
    public static ExprTypeKind Error;
    public static ExprTypeKind BL;
    public static ExprTypeKind I4;
    public static ExprTypeKind I8;
    public static ExprTypeKind R4;
    public static ExprTypeKind R8;
    public static ExprTypeKind TX;
    public static ExprTypeKind _Lim;
    public static ExprTypeKind Float;
}
internal abstract class Microsoft.ML.Transforms.ExprVisitor : NodeVisitor {
    public virtual void Visit(NameNode node);
    public virtual void Visit(ParamNode node);
    public virtual void PostVisit(LambdaNode node);
}
internal class Microsoft.ML.Transforms.FltLitToken : NumLitToken {
    public float Value;
    public FltLitToken(TextSpan span, float val);
    public virtual string ToString();
}
internal abstract class Microsoft.ML.Transforms.FourierRandomNumberGeneratorBase : object {
    public abstract virtual float Next(Random rand);
}
internal static class Microsoft.ML.Transforms.FunctionProviderUtils : object {
    public static bool IsNA(object v);
    public static object GetNA(Type type);
    public static MethodInfo[] Ret(MethodInfo[] funcs);
    public static MethodInfo Fn(Func`1<T1> fn);
    public static MethodInfo Fn(Func`2<T1, T2> fn);
    public static MethodInfo Fn(Func`3<T1, T2, T3> fn);
    public static MethodInfo Fn(Func`4<T1, T2, T3, T4> fn);
}
public class Microsoft.ML.Transforms.GaussianKernel : KernelBase {
    internal static string LoadName;
    private float _gamma;
    public GaussianKernel(float gamma);
    internal GaussianKernel(IHostEnvironment env, Options options);
    internal virtual float Distance(VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) first, VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) second);
    internal virtual FourierRandomNumberGeneratorBase GetRandomNumberGenerator(float averageDistance);
}
public class Microsoft.ML.Transforms.GlobalContrastNormalizingEstimator : LpNormNormalizingEstimatorBase {
    internal GlobalContrastNormalizingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, bool ensureZeroMean, bool ensureUnitStandardDeviation, float scale);
    internal GlobalContrastNormalizingEstimator(IHostEnvironment env, ValueTuple`2[] columns, bool ensureZeroMean, bool ensureUnitStandardDeviation, float scale);
    internal GlobalContrastNormalizingEstimator(IHostEnvironment env, ColumnOptions[] columns);
}
internal static class Microsoft.ML.Transforms.GroupingOperations : object {
    [EntryPointAttribute]
public static TransformOutput Group(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput Ungroup(IHostEnvironment env, Options input);
}
internal class Microsoft.ML.Transforms.GroupTransform : TransformBase {
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    private static string RegistrationName;
    internal static string LoaderSignature;
    private GroupBinding _groupBinding;
    public DataViewSchema OutputSchema { get; }
    public bool CanShuffle { get; }
    public GroupTransform(IHostEnvironment env, IDataView input, string groupKey, String[] columns);
    public GroupTransform(IHostEnvironment env, Options options, IDataView input);
    private GroupTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static GroupTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public virtual Nullable`1<long> GetRowCount();
    public virtual DataViewSchema get_OutputSchema();
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    public virtual bool get_CanShuffle();
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
internal static class Microsoft.ML.Transforms.HashJoin : object {
    [EntryPointAttribute]
public static TransformOutput Apply(IHostEnvironment env, Arguments input);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.HashJoiningTransform : OneToOneTransformBase {
    public static int NumBitsMin;
    public static int NumBitsLim;
    internal static string RegistrationName;
    internal static string Summary;
    internal static string UserName;
    internal static string LoaderSignature;
    private ColumnOptions[] _exes;
    private static FuncInstanceMethodInfo1`4<HashJoiningTransform, DataViewRow, int, Delegate> _composeGetterOneToOneMethodInfo;
    private static FuncInstanceMethodInfo1`4<HashJoiningTransform, DataViewRow, int, Delegate> _composeGetterVecToVecMethodInfo;
    private static FuncInstanceMethodInfo1`4<HashJoiningTransform, DataViewRow, int, Delegate> _composeGetterVecToOneMethodInfo;
    public HashJoiningTransform(IHostEnvironment env, IDataView input, string name, string source, bool join, int numberOfBits);
    public HashJoiningTransform(IHostEnvironment env, Arguments args, IDataView input);
    private HashJoiningTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static HashJoiningTransform();
    private static VersionInfo GetVersionInfo();
    public static HashJoiningTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private ColumnOptions CreateColumnOptionsEx(bool join, string customSlotMap, int numberOfBits, UInt32 hashSeed, bool ordered, ColInfo colInfo);
    private Int32[][] CompileSlotMap(string slotMapString, int srcSlotCount);
    private static Int32[][] CreateDefaultSlotMap(bool join, int srcSlotCount);
    private static string TestColumnType(DataViewType type);
    private void SetMetadata();
    private void GetSlotNames(int iinfo, VBuffer`1& dst);
    protected virtual Delegate GetGetterCore(IChannel ch, DataViewRow input, int iinfo, Action& disposer);
    private ValueGetter`1<UInt32> ComposeGetterOneToOne(DataViewRow input, int iinfo);
    private ValueGetter`1<VBuffer`1<UInt32>> ComposeGetterVecToVec(DataViewRow input, int iinfo);
    private ValueGetter`1<UInt32> ComposeGetterVecToOne(DataViewRow input, int iinfo);
    private HashDelegate`1<TSrc> ComposeHashDelegate();
    private HashDelegate`1<float> ComposeFloatHashDelegate();
    private HashDelegate`1<double> ComposeDoubleHashDelegate();
    private UInt32 Hash(Single& value, UInt32 seed);
    private UInt32 Hash(Double& value, UInt32 seed);
    protected virtual DataViewType GetColumnTypeCore(int iinfo);
}
internal interface Microsoft.ML.Transforms.ICountTable {
    public float GarbageThreshold { get; }
    public IReadOnlyCollection`1<float> GarbageCounts { get; }
    public ReadOnlySpan`1<double> PriorFrequencies { get; }
    public abstract virtual void GetCounts(long key, Span`1<float> counts);
    public abstract virtual float get_GarbageThreshold();
    public abstract virtual IReadOnlyCollection`1<float> get_GarbageCounts();
    public abstract virtual ReadOnlySpan`1<double> get_PriorFrequencies();
}
[ComponentKindAttribute("CountTableBuilder")]
internal interface Microsoft.ML.Transforms.ICountTableBuilderFactory {
}
internal interface Microsoft.ML.Transforms.ICustomMappingFactory {
    public abstract virtual ITransformer CreateTransformer(IHostEnvironment env, string contractName);
}
internal class Microsoft.ML.Transforms.IdentNode : ExprNode {
    public string Value;
    public bool IsMissing;
    public Node Referent;
    public NodeKind Kind { get; }
    public IdentNode AsIdent { get; }
    public IdentNode TestIdent { get; }
    public IdentNode(IdentToken tok);
    public IdentNode(Token tok, string value, bool missing);
    public virtual NodeKind get_Kind();
    public virtual IdentNode get_AsIdent();
    public virtual IdentNode get_TestIdent();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.IdentToken : Token {
    public string Value;
    public IdentToken(TextSpan span, string val);
    public IdentToken(TextSpan span, string val, TokKind tidContext);
    public virtual string ToString();
}
public interface Microsoft.ML.Transforms.IFunctionProvider {
    public string NameSpace { get; }
    public abstract virtual string get_NameSpace();
    public abstract virtual MethodInfo[] Lookup(string name);
    public abstract virtual object ResolveToConstant(string name, MethodInfo meth, Object[] values);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Transforms.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static ILGenerator Add(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Beq(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Bge(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Bge_Un(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Bgt(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Bgt_Un(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Ble(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Ble_Un(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Blt(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Blt_Un(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Bne_Un(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Br(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Brfalse(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Brtrue(ILGenerator il, Label label);
    [ExtensionAttribute]
public static ILGenerator Call(ILGenerator il, MethodInfo info);
    [ExtensionAttribute]
public static ILGenerator Ceq(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Cgt(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Cgt_Un(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Clt(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Clt_Un(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Conv_I8(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Conv_R4(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Conv_R8(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Div(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Dup(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Ldarg(ILGenerator il, int arg);
    [ExtensionAttribute]
public static ILGenerator Ldc_I4(ILGenerator il, int arg);
    [ExtensionAttribute]
public static ILGenerator Ldc_I8(ILGenerator il, long arg);
    [ExtensionAttribute]
public static ILGenerator Ldc_R4(ILGenerator il, float arg);
    [ExtensionAttribute]
public static ILGenerator Ldc_R8(ILGenerator il, double arg);
    [ExtensionAttribute]
public static ILGenerator Ldloc(ILGenerator il, LocalBuilder builder);
    [ExtensionAttribute]
public static ILGenerator Ldstr(ILGenerator il, string str);
    [ExtensionAttribute]
public static ILGenerator Mul(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Mul_Ovf(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Neg(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Newarr(ILGenerator il, Type type);
    [ExtensionAttribute]
public static ILGenerator Pop(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Rem(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Ret(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Stelem(ILGenerator il, Type type);
    [ExtensionAttribute]
public static ILGenerator Stloc(ILGenerator il, LocalBuilder builder);
    [ExtensionAttribute]
public static ILGenerator Sub(ILGenerator il);
    [ExtensionAttribute]
public static ILGenerator Xor(ILGenerator il);
}
internal abstract class Microsoft.ML.Transforms.InternalCountTableBuilderBase : object {
    protected int LabelCardinality;
    protected Double[] PriorCounts;
    protected InternalCountTableBuilderBase(long labelCardinality);
    internal void Increment(long key, long labelKey);
    protected abstract virtual void IncrementCore(long key, long labelKey);
    internal abstract virtual CountTableBase CreateCountTable();
}
[FlagsAttribute]
internal enum Microsoft.ML.Transforms.IntLitKind : Enum {
    public byte value__;
    public static IntLitKind None;
    public static IntLitKind Uns;
    public static IntLitKind Lng;
    public static IntLitKind Hex;
    public static IntLitKind UnsLng;
}
internal class Microsoft.ML.Transforms.IntLitToken : NumLitToken {
    public ulong Value;
    public IntLitKind IntKind;
    public bool IsHex { get; }
    public IntLitToken(TextSpan span, ulong val, IntLitKind ilk);
    public virtual string ToString();
    public bool get_IsHex();
}
public abstract class Microsoft.ML.Transforms.KernelBase : object {
    internal abstract virtual float Distance(VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) first, VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) second);
    internal abstract virtual FourierRandomNumberGeneratorBase GetRandomNumberGenerator(float averageDistance);
}
public class Microsoft.ML.Transforms.KeyToBinaryVectorMappingEstimator : TrivialEstimator`1<KeyToBinaryVectorMappingTransformer> {
    internal KeyToBinaryVectorMappingEstimator(IHostEnvironment env, ValueTuple`2[] columns);
    internal KeyToBinaryVectorMappingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName);
    private KeyToBinaryVectorMappingEstimator(IHostEnvironment env, KeyToBinaryVectorMappingTransformer transformer);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.KeyToBinaryVectorMappingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string UserName;
    internal static string LoaderSignature;
    private static string RegistrationName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, string>> Columns { get; }
    internal KeyToBinaryVectorMappingTransformer(IHostEnvironment env, ValueTuple`2[] columns);
    private KeyToBinaryVectorMappingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ValueTuple`2<string, string>> get_Columns();
    private string TestIsKey(DataViewType type);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static KeyToBinaryVectorMappingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, IDataView input, ValueTuple`2[] columns);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.KeyToken : Token {
    private KeyToken(TextSpan span, TokKind tid);
    public static KeyToken Create(TextSpan span, TokKind tid);
    public static Token CreateKeyWord(TextSpan span, string str, TokKind tid, bool isContextKeyWord);
}
internal class Microsoft.ML.Transforms.KeyWordTable : object {
    private Pool _pool;
    private Dictionary`2<NormStr, KeyWordKind> _mpnstrtidWord;
    private Dictionary`2<NormStr, TokKind> _mpnstrtidPunc;
    public IEnumerable`1<KeyValuePair`2<NormStr, TokKind>> Punctuators { get; }
    public IEnumerable`1<KeyValuePair`2<NormStr, KeyWordKind>> KeyWords { get; }
    public KeyWordTable(Pool pool);
    public void AddKeyWord(string str, TokKind tid);
    public bool TryAddPunctuator(string str, TokKind tid);
    public void AddPunctuator(string str, TokKind tid);
    public bool IsKeyWord(NormStr nstr, KeyWordKind& kind);
    public bool IsPunctuator(NormStr nstr, TokKind& tid);
    public IEnumerable`1<KeyValuePair`2<NormStr, TokKind>> get_Punctuators();
    public IEnumerable`1<KeyValuePair`2<NormStr, KeyWordKind>> get_KeyWords();
}
internal class Microsoft.ML.Transforms.LambdaBinder : NodeVisitor {
    private IHost _host;
    private List`1<WithNode> _rgwith;
    private List`1<Error> _errors;
    private LambdaNode _lambda;
    private IFunctionProvider[] _providers;
    private Action`1<string> _printError;
    private static Cmp[] _fnEqual;
    private static Cmp[] _fnNotEqual;
    private static Cmp[] _fnLess;
    private static Cmp[] _fnLessEqual;
    private static Cmp[] _fnGreater;
    private static Cmp[] _fnGreaterEqual;
    private bool HasErrors { get; }
    private LambdaBinder(IHostEnvironment env, Action`1<string> printError);
    private static LambdaBinder();
    public static void Run(IHostEnvironment env, List`1& errors, LambdaNode node, Action`1<string> printError);
    private bool get_HasErrors();
    private void PostError(Node node, string msg);
    private void PostError(Node node, string msg, Object[] args);
    public virtual void Visit(BoolLitNode node);
    public virtual void Visit(StrLitNode node);
    public virtual void Visit(NumLitNode node);
    public virtual void Visit(NameNode node);
    public virtual void Visit(IdentNode node);
    public virtual void Visit(ParamNode node);
    public virtual bool PreVisit(LambdaNode node);
    public virtual void PostVisit(LambdaNode node);
    private string GetStr(ExprTypeKind kind);
    private void BadNum(ExprNode arg);
    private void BadNum(ExprNode node, ExprNode arg);
    private void BadText(ExprNode arg);
    private void BadArg(ExprNode arg, ExprTypeKind kind);
    public virtual void PostVisit(UnaryOpNode node);
    private Nullable`1<bool> GetBoolOp(ExprNode arg);
    public virtual void PostVisit(BinaryOpNode node);
    private void ApplyBoolBinOp(BinaryOpNode node);
    private void ReconcileNumericTypes(ExprNode a, ExprNode b, ExprTypeKind& kind);
    private void ApplyNumericBinOp(BinaryOpNode node);
    private void ReduceBinOp(BinaryOpNode node, Nullable`1<int> a, Nullable`1<int> b);
    private void ReduceBinOp(BinaryOpNode node, Nullable`1<long> a, Nullable`1<long> b);
    private void ReduceBinOp(BinaryOpNode node, Nullable`1<float> a, Nullable`1<float> b);
    private void ReduceBinOp(BinaryOpNode node, Nullable`1<double> a, Nullable`1<double> b);
    private int BinOp(BinaryOpNode node, int v1, int v2);
    private long BinOp(BinaryOpNode node, long v1, long v2);
    private float BinOp(BinaryOpNode node, float v1, float v2);
    private double BinOp(BinaryOpNode node, double v1, double v2);
    public virtual void PostVisit(ConditionalNode node);
    public virtual void PostVisit(CompareNode node);
    public virtual void PostVisit(CallNode node);
    private static bool CanConvert(ExprTypeKind src, ExprTypeKind dst);
    private object Convert(ExprNode expr, ExprTypeKind kind);
    private Candidate GetBestOverload(CallNode node, List`1<Candidate> candidates);
    public virtual void PostVisit(ListNode node);
    public virtual bool PreVisit(WithNode node);
    public virtual void PostVisit(WithNode node);
    public virtual void PostVisit(WithLocalNode node);
    private bool ValidateType(ExprNode expr, ExprTypeKind& itemKind);
    internal static bool CanPromote(bool precise, ExprTypeKind k1, ExprTypeKind k2, ExprTypeKind& res);
    private static int MapKindToIndex(ExprTypeKind kind);
    private static T Cast(object a);
    [CompilerGeneratedAttribute]
private IFunctionProvider <.ctor>b__6_0(LoadableClassInfo info);
}
internal class Microsoft.ML.Transforms.LambdaCompiler : object {
    public static int MaxParams;
    private LambdaNode _top;
    private Type _delType;
    private MethodGenerator _meth;
    private LambdaCompiler(LambdaNode node);
    public static Delegate Compile(List`1& errors, LambdaNode node);
    private Delegate Do(List`1& errors);
    public sealed virtual void Dispose();
}
internal class Microsoft.ML.Transforms.LambdaNode : Node {
    public ParamNode[] Vars;
    public ExprNode Expr;
    public DataViewType ResultType;
    public NodeKind Kind { get; }
    public LambdaNode AsPredicate { get; }
    public LambdaNode TestPredicate { get; }
    public LambdaNode(Token tok, ParamNode[] vars, ExprNode expr);
    public virtual NodeKind get_Kind();
    public virtual LambdaNode get_AsPredicate();
    public virtual LambdaNode get_TestPredicate();
    public virtual void Accept(NodeVisitor visitor);
    public ParamNode FindParam(string name);
}
internal class Microsoft.ML.Transforms.LambdaParser : object {
    private Pool _pool;
    private KeyWordTable _kwt;
    private Lexer _lex;
    private Dictionary`2<TokKind, string> _mapTidStr;
    private Int32[] _perm;
    private DataViewType[] _types;
    private TokenCursor _curs;
    private List`1<Error> _errors;
    private List`1<int> _lineMap;
    private TokKind TidCur { get; }
    private TokKind CtxCur { get; }
    private Token TokCur { get; }
    private void InitKeyWordTable();
    public static LambdaNode Parse(List`1& errors, List`1& lineMap, CharCursor chars, Int32[] perm, DataViewType[] types);
    private LambdaNode ParseCore(List`1& errors, List`1& lineMap, CharCursor chars, Int32[] perm, DataViewType[] types);
    private void AddError(Error err);
    private void PostError(Token tok, string msg);
    private void PostError(Token tok, string msg, Object[] args);
    private void PostTidError(Token tok, TokKind tidWanted);
    private string Stringize(Token tok);
    private string Stringize(TokKind tid);
    private TokKind get_TidCur();
    private TokKind get_CtxCur();
    private Token get_TokCur();
    private Token TokPeek(int cv);
    private TokKind TidPeek(int cv);
    private TokKind TidNext();
    private void SkipJunk();
    private Token TokMove();
    private bool EatTid(TokKind tid);
    private Token TokEat(TokKind tid);
    private LambdaNode ParseLambda(Token tokFirst);
    private ParamNode ParseParam(int index);
    private ExprNode ParseExpr();
    private ExprNode ParseExpr(Precedence precMin);
    private ExprNode ParsePrimary();
    private CompareNode ParseCompareExpr(ExprNode node, CompareOp op, TokKind tidLax, TokKind tidStrict);
    private IdentNode ParseIdent();
    private CallNode ParseInvocation();
    private CallNode ParseInvocationWithNameSpace();
    private ExprNode ParseParenExpr();
    private ListNode ParseList(Token tok, TokKind tidEmpty);
    private WithNode ParseWith(Token tokWith);
    private WithLocalNode ParseWithLocal();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Transforms.LambdaTransform : object {
    internal static string LoaderSignature;
    private static UInt32 VerAssemblyNameSaved;
    private static VersionInfo GetVersionInfo();
    internal static void SaveCustomTransformer(IExceptionContext ectx, ModelSaveContext ctx, string contractName, string contractAssembly);
    private static ITransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    public static IDataView CreateMap(IHostEnvironment env, IDataView source, Action`3<TSrc, TDst, TState> mapAction, Action`1<TState> initStateAction, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition);
    public static IDataView CreateFilter(IHostEnvironment env, IDataView source, Func`3<TSrc, TState, bool> filterFunc, Action`1<TState> initStateAction, SchemaDefinition inputSchemaDefinition);
}
public class Microsoft.ML.Transforms.LaplacianKernel : KernelBase {
    internal static string LoadName;
    private float _a;
    public LaplacianKernel(float a);
    internal LaplacianKernel(IHostEnvironment env, Options options);
    internal virtual float Distance(VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) first, VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) second);
    internal virtual FourierRandomNumberGeneratorBase GetRandomNumberGenerator(float averageDistance);
}
internal static class Microsoft.ML.Transforms.LearnerFeatureSelectionTransform : object {
    internal static string Summary;
    internal static string RegistrationName;
    private static LearnerFeatureSelectionTransform();
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static ColumnOptions CreateDropSlotsColumn(Options options, VBuffer`1& scores, Int32& selectedCount);
    private static float ComputeThreshold(ReadOnlySpan`1<float> scores, int topk, Int32& tiedScoresToKeep);
    private static void TrainCore(IHost host, IDataView input, Options options, VBuffer`1& scores);
    public static void Train(IHostEnvironment env, IDataView input, Options options, VBuffer`1& scores);
}
internal static class Microsoft.ML.Transforms.LexCharUtils : object {
    private static LexCharInfo[] _rgchi;
    private static LexCharUtils();
    private static UniCatFlags GetCatFlags(char ch);
    public static LexStartKind StartKind(char ch);
    public static bool IsPunc(char ch);
    public static bool IsDigit(char ch);
    public static bool IsHexDigit(char ch);
    public static bool IsIdentStart(char ch);
    public static bool IsIdent(char ch);
    public static bool IsFormat(char ch);
    public static bool IsSpace(char ch);
    public static bool IsLineTerm(char ch);
    public static int GetDecVal(char ch);
    public static int GetHexVal(char ch);
    public static string GetUniEscape(UInt32 u);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.Lexer : object {
    private Pool _pool;
    private KeyWordTable _kwt;
    public Lexer(Pool pool, KeyWordTable kwt);
    [IteratorStateMachineAttribute("Microsoft.ML.Transforms.Lexer/<LexSource>d__3")]
public IEnumerable`1<Token> LexSource(CharCursor cursor);
}
internal enum Microsoft.ML.Transforms.LexStartKind : Enum {
    public ushort value__;
    public static LexStartKind None;
    public static LexStartKind Punc;
    public static LexStartKind Ident;
    public static LexStartKind NumLit;
    public static LexStartKind StrLit;
    public static LexStartKind Verbatim;
    public static LexStartKind Comment;
    public static LexStartKind PreProc;
    public static LexStartKind Space;
    public static LexStartKind LineTerm;
}
internal class Microsoft.ML.Transforms.ListNode : Node {
    public Node[] Items;
    public Token[] Delimiters;
    public NodeKind Kind { get; }
    public ListNode AsList { get; }
    public ListNode TestList { get; }
    public ListNode(Token tok, Node[] items, Token[] delimiters);
    public virtual NodeKind get_Kind();
    public virtual ListNode get_AsList();
    public virtual ListNode get_TestList();
    public virtual void Accept(NodeVisitor visitor);
}
internal static class Microsoft.ML.Transforms.LoadTransform : object {
    internal static string Summary;
    public static IDataTransform Create(IHostEnvironment env, IDataView input, string modelFile, String[] tag, bool complement);
    private static IDataTransform Create(IHostEnvironment env, Arguments args, IDataView input);
}
internal static class Microsoft.ML.Transforms.LpNormNormalization : object {
    [EntryPointAttribute]
public static TransformOutput Normalize(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput GcNormalize(IHostEnvironment env, GcnOptions input);
}
public class Microsoft.ML.Transforms.LpNormNormalizingEstimator : LpNormNormalizingEstimatorBase {
    internal LpNormNormalizingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, NormFunction norm, bool ensureZeroMean);
    internal LpNormNormalizingEstimator(IHostEnvironment env, ValueTuple`2[] columns, NormFunction norm, bool ensureZeroMean);
    internal LpNormNormalizingEstimator(IHostEnvironment env, ColumnOptions[] columns);
}
public abstract class Microsoft.ML.Transforms.LpNormNormalizingEstimatorBase : TrivialEstimator`1<LpNormNormalizingTransformer> {
    internal static string ExpectedColumnType;
    internal LpNormNormalizingEstimatorBase(IHostEnvironment env, ColumnOptionsBase[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    internal static bool IsSchemaColumnValid(Column col);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.LpNormNormalizingTransformer : OneToOneTransformerBase {
    internal static string GcnSummary;
    internal static string UserNameGn;
    internal static string ShortNameGn;
    internal static string Summary;
    internal static string UserNameLP;
    internal static string ShortNameLP;
    private static UInt32 VerVectorNormalizerSupported;
    internal static string LoaderSignature;
    internal static string LoaderSignatureOld;
    private static string RegistrationName;
    private static float MinScale;
    private ColumnOptionsBase[] _columns;
    internal IReadOnlyCollection`1<ColumnOptionsBase> Columns { get; }
    internal LpNormNormalizingTransformer(IHostEnvironment env, ColumnOptionsBase[] columns);
    private LpNormNormalizingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ColumnOptionsBase> get_Columns();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptionsBase[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    internal static IDataTransform Create(IHostEnvironment env, GcnOptions options, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static LpNormNormalizingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.MethodGenerator : object {
    private DynamicMethod _method;
    [CompilerGeneratedAttribute]
private ILGenerator <Il>k__BackingField;
    private Dictionary`2<LocalKey, List`1<LocalBuilder>> _locals;
    private Action`2<LocalBuilder, bool> _tempDisposer;
    public ILGenerator Il { get; private set; }
    public MethodGenerator(string name, Type thisType, Type returnType, Type[] parameterTypes);
    [CompilerGeneratedAttribute]
public ILGenerator get_Il();
    [CompilerGeneratedAttribute]
private void set_Il(ILGenerator value);
    public Delegate CreateDelegate(Type delegateType);
    public sealed virtual void Dispose();
    public Temporary AcquireTemporary(Type type, bool isRef);
    private void ReleaseLocal(LocalBuilder localBuilder, bool isRef);
}
internal class Microsoft.ML.Transforms.MissingValueDroppingEstimator : TrivialEstimator`1<MissingValueDroppingTransformer> {
    public MissingValueDroppingEstimator(IHostEnvironment env, ValueTuple`2[] columns);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal class Microsoft.ML.Transforms.MissingValueDroppingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string FriendlyName;
    internal static string ShortName;
    internal static string LoaderSignature;
    private static string RegistrationName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<ValueTuple`2<string, string>> Columns { get; }
    internal MissingValueDroppingTransformer(IHostEnvironment env, ValueTuple`2[] columns);
    internal MissingValueDroppingTransformer(IHostEnvironment env, Options options);
    private MissingValueDroppingTransformer(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyList`1<ValueTuple`2<string, string>> get_Columns();
    private static ValueTuple`2[] GetColumnPairs(Column[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    internal static MissingValueDroppingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal static class Microsoft.ML.Transforms.MissingValueHandlingTransformer : object {
    internal static string Summary;
    internal static string FriendlyName;
    internal static string ShortName;
    private static IDataView Create(IHostEnvironment env, IDataView input, string outputColumnName, string inputColumnName, ReplacementKind replaceWith);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
}
public class Microsoft.ML.Transforms.MissingValueIndicatorEstimator : TrivialEstimator`1<MissingValueIndicatorTransformer> {
    internal MissingValueIndicatorEstimator(IHostEnvironment env, ValueTuple`2[] columns);
    internal MissingValueIndicatorEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal class Microsoft.ML.Transforms.MissingValueIndicatorTransform : OneToOneTransformBase {
    public static string LoaderSignature;
    private static string RegistrationName;
    private static string IndicatorSuffix;
    private VectorDataViewType[] _types;
    public MissingValueIndicatorTransform(IHostEnvironment env, Arguments args, IDataView input);
    private MissingValueIndicatorTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static MissingValueIndicatorTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private VectorDataViewType[] GetTypesAndMetadata();
    protected virtual DataViewType GetColumnTypeCore(int iinfo);
    private void GetSlotNames(int iinfo, VBuffer`1& dst);
    protected virtual Delegate GetGetterCore(IChannel ch, DataViewRow input, int iinfo, Action& disposer);
    private static void FillValues(float input, VBuffer`1& result);
    private static void FillValues(IExceptionContext ectx, VBuffer`1& buffer);
}
public class Microsoft.ML.Transforms.MissingValueIndicatorTransformer : OneToOneTransformerBase {
    internal static string LoadName;
    internal static string Summary;
    internal static string FriendlyName;
    internal static string ShortName;
    private static string RegistrationName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<ValueTuple`2<string, string>> Columns { get; }
    internal MissingValueIndicatorTransformer(IHostEnvironment env, ValueTuple`2[] columns);
    internal MissingValueIndicatorTransformer(IHostEnvironment env, Options options);
    private MissingValueIndicatorTransformer(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyList`1<ValueTuple`2<string, string>> get_Columns();
    private static ValueTuple`2[] GetColumnPairs(Column[] columns);
    internal static MissingValueIndicatorTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    internal static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
public class Microsoft.ML.Transforms.MissingValueReplacingEstimator : object {
    private IHost _host;
    private ColumnOptions[] _columns;
    internal MissingValueReplacingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, ReplacementMode replacementKind);
    [BestFriendAttribute]
internal MissingValueReplacingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual MissingValueReplacingTransformer Fit(IDataView input);
}
public class Microsoft.ML.Transforms.MissingValueReplacingTransformer : OneToOneTransformerBase {
    private static FuncInstanceMethodInfo1`4<MissingValueReplacingTransformer, DataViewType, Array, BitArray> _computeDefaultSlotsMethodInfo;
    private static FuncStaticMethodInfo1`2<DataViewType, string> _testTypeMethodInfo;
    private static FuncInstanceMethodInfo1`3<MissingValueReplacingTransformer, DataViewType, Delegate> _getIsNADelegateMethodInfo;
    internal static string LoadName;
    internal static string Summary;
    internal static string FriendlyName;
    internal static string ShortName;
    private DataViewType[] _replaceTypes;
    private Object[] _repValues;
    private BitArray[] _repIsDefault;
    internal MissingValueReplacingTransformer(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    private MissingValueReplacingTransformer(IHost host, ModelLoadContext ctx);
    private static MissingValueReplacingTransformer();
    private static VersionInfo GetVersionInfo();
    internal static string TestType(DataViewType type);
    private static string TestType(DataViewType type);
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private T[] GetValuesArray(VBuffer`1<T> src, VectorDataViewType srcType, int iinfo);
    private void GetReplacementValues(IDataView input, ColumnOptions[] columns, Object[]& repValues, BitArray[]& slotIsDefault, DataViewType[]& types);
    private BitArray ComputeDefaultSlots(DataViewType type, Array values);
    private object GetDefault(DataViewType type);
    private Delegate GetIsNADelegate(DataViewType type);
    private Delegate GetIsNADelegate(DataViewType type);
    private object GetSpecifiedValue(string srcStr, DataViewType dstType, Delegate isNA);
    private object GetSpecifiedValue(string srcStr, DataViewType dstType, InPredicate`1<T> isNA);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    private static MissingValueReplacingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private VBuffer`1<T> CreateVBuffer(T[] array);
    private void WriteTypeAndValue(Stream stream, BinarySaver saver, DataViewType type, T rep);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private static StatAggregator CreateStatAggregator(IChannel ch, DataViewType type, Nullable`1<ReplacementKind> kind, bool bySlot, DataViewRowCursor cursor, int col);
    private static DataViewRowId Add(DataViewRowId left, ulong right);
    private static DataViewRowId Subtract(DataViewRowId left, ulong right);
    private static bool Equals(DataViewRowId left, ulong right);
    private static bool GreaterThanOrEqual(DataViewRowId left, ulong right);
    private static bool GreaterThan(DataViewRowId left, ulong right);
    private static double ToDouble(DataViewRowId value);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.ML.Transforms.MultiCountTableBase : object {
    protected IHost Host;
    public int ColCount { get; }
    public Int32[] SlotCount { get; }
    public ICountTable Item { get; }
    protected MultiCountTableBase(IHostEnvironment env, string registrationName);
    public abstract virtual int get_ColCount();
    public abstract virtual Int32[] get_SlotCount();
    public abstract virtual ICountTable get_Item(int iCol, int iSlot);
    public abstract virtual void Save(ModelSaveContext ctx);
    public abstract virtual MultiCountTableBuilderBase ToBuilder(IHostEnvironment env, Column[] inputCols, long labelCardinality);
}
internal abstract class Microsoft.ML.Transforms.MultiCountTableBuilderBase : object {
    public abstract virtual void IncrementSlot(int iCol, int iSlot, UInt32 key, UInt32 labelKey);
    public abstract virtual MultiCountTableBase CreateMultiCountTable();
}
public class Microsoft.ML.Transforms.MutualInformationFeatureSelectingEstimator : object {
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    internal static string RegistrationName;
    private IHost _host;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _columns;
    private string _labelColumnName;
    private int _slotsInOutput;
    private int _numBins;
    internal MutualInformationFeatureSelectingEstimator(IHostEnvironment env, string labelColumnName, int slotsInOutput, int numberOfBins, ValueTuple`2[] columns);
    internal MutualInformationFeatureSelectingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, string labelColumnName, int slotsInOutput, int numBins);
    private static MutualInformationFeatureSelectingEstimator();
    public sealed virtual ITransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static float ComputeThreshold(Single[][] scores, int topk, Int32& tiedScoresToKeep);
    private static void CreateDropAndCopyColumns(int size, Single[][] scores, float threshold, int tiedScoresToKeep, ValueTuple`2[] cols, Int32[]& selectedCount, ColumnOptions[]& dropSlotsColumns, ValueTuple`2[]& copyColumnsPairs);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Transforms.MutualInformationFeatureSelectionUtils : object {
    internal static Single[][] TrainCore(IHost host, IDataView input, string labelColumnName, String[] columns, int numBins, Int32[] colSizes);
    internal static bool IsValidColumnType(DataViewType type);
    private static ValueMapper`2<VBuffer`1<TSrc>, VBuffer`1<TDst>> CreateVectorMapper(ValueMapper`2<TSrc, TDst> map);
    [ExtensionAttribute]
private static void MapVector(ValueMapper`2<TSrc, TDst> map, VBuffer`1& input, VBuffer`1& output);
}
internal static class Microsoft.ML.Transforms.NAHandling : object {
    [EntryPointAttribute]
public static TransformOutput Drop(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput Filter(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static TransformOutput Handle(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput Indicator(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput Replace(IHostEnvironment env, Options input);
}
internal class Microsoft.ML.Transforms.NameNode : Node {
    public string Value;
    public NodeKind Kind { get; }
    public NameNode AsName { get; }
    public NameNode TestName { get; }
    public NameNode(IdentToken tok);
    public virtual NodeKind get_Kind();
    public virtual NameNode get_AsName();
    public virtual NameNode get_TestName();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.NewLineToken : Token {
    public bool Nested;
    public NewLineToken(TextSpan span, bool fNested);
    public virtual string ToString();
}
internal abstract class Microsoft.ML.Transforms.Node : object {
    public Token Token;
    public NodeKind Kind { get; }
    public LambdaNode AsPredicate { get; }
    public LambdaNode TestPredicate { get; }
    public ParamNode AsParam { get; }
    public ParamNode TestParam { get; }
    public ConditionalNode AsConditional { get; }
    public ConditionalNode TestConditional { get; }
    public BinaryOpNode AsBinaryOp { get; }
    public BinaryOpNode TestBinaryOp { get; }
    public UnaryOpNode AsUnaryOp { get; }
    public UnaryOpNode TestUnaryOp { get; }
    public CompareNode AsCompare { get; }
    public CompareNode TestCompare { get; }
    public CallNode AsCall { get; }
    public CallNode TestCall { get; }
    public ListNode AsList { get; }
    public ListNode TestList { get; }
    public WithNode AsWith { get; }
    public WithNode TestWith { get; }
    public WithLocalNode AsWithLocal { get; }
    public WithLocalNode TestWithLocal { get; }
    public NameNode AsName { get; }
    public NameNode TestName { get; }
    public IdentNode AsIdent { get; }
    public IdentNode TestIdent { get; }
    public BoolLitNode AsBoolLit { get; }
    public BoolLitNode TestBoolLit { get; }
    public NumLitNode AsNumLit { get; }
    public NumLitNode TestNumLit { get; }
    public StrLitNode AsStrLit { get; }
    public StrLitNode TestStrLit { get; }
    public ExprNode AsExpr { get; }
    public ExprNode TestExpr { get; }
    protected Node(Token tok);
    public abstract virtual NodeKind get_Kind();
    public abstract virtual void Accept(NodeVisitor visitor);
    private T Cast();
    public virtual LambdaNode get_AsPredicate();
    public virtual LambdaNode get_TestPredicate();
    public virtual ParamNode get_AsParam();
    public virtual ParamNode get_TestParam();
    public virtual ConditionalNode get_AsConditional();
    public virtual ConditionalNode get_TestConditional();
    public virtual BinaryOpNode get_AsBinaryOp();
    public virtual BinaryOpNode get_TestBinaryOp();
    public virtual UnaryOpNode get_AsUnaryOp();
    public virtual UnaryOpNode get_TestUnaryOp();
    public virtual CompareNode get_AsCompare();
    public virtual CompareNode get_TestCompare();
    public virtual CallNode get_AsCall();
    public virtual CallNode get_TestCall();
    public virtual ListNode get_AsList();
    public virtual ListNode get_TestList();
    public virtual WithNode get_AsWith();
    public virtual WithNode get_TestWith();
    public virtual WithLocalNode get_AsWithLocal();
    public virtual WithLocalNode get_TestWithLocal();
    public virtual NameNode get_AsName();
    public virtual NameNode get_TestName();
    public virtual IdentNode get_AsIdent();
    public virtual IdentNode get_TestIdent();
    public virtual BoolLitNode get_AsBoolLit();
    public virtual BoolLitNode get_TestBoolLit();
    public virtual NumLitNode get_AsNumLit();
    public virtual NumLitNode get_TestNumLit();
    public virtual StrLitNode get_AsStrLit();
    public virtual StrLitNode get_TestStrLit();
    public virtual ExprNode get_AsExpr();
    public virtual ExprNode get_TestExpr();
    public virtual string ToString();
}
internal enum Microsoft.ML.Transforms.NodeKind : Enum {
    public int value__;
    public static NodeKind Lambda;
    public static NodeKind Param;
    public static NodeKind Conditional;
    public static NodeKind BinaryOp;
    public static NodeKind UnaryOp;
    public static NodeKind Compare;
    public static NodeKind Call;
    public static NodeKind List;
    public static NodeKind With;
    public static NodeKind WithLocal;
    public static NodeKind Name;
    public static NodeKind Ident;
    public static NodeKind BoolLit;
    public static NodeKind NumLit;
    public static NodeKind StrLit;
}
internal class Microsoft.ML.Transforms.NodePrinter : PreVisitor {
    private bool _showTypes;
    private bool _showValues;
    private IndentedTextWriter _wrt;
    private NodePrinter(IndentedTextWriter wrt, bool showTypes, bool showValues);
    public static void Print(Node node, TextWriter writer, bool showTypes, bool showValues);
    private bool NeedParensLeft(Precedence precLeft, Precedence precOp);
    private bool NeedParensRight(Precedence precOp, Precedence precRight);
    private Precedence GetPrec(Node node);
    private Precedence GetPrec(BinaryOp op);
    private string GetString(BinaryOp op);
    private string GetString(UnaryOp op);
    private string GetString(TokKind tidCompare);
    private bool TryShowValue(ExprNode node);
    private void ShowValueCore(ExprNode node);
    private void Show(int x);
    private void Show(long x);
    private void Show(float x);
    private void Show(double x);
    private void Show(bool x);
    private void Show(ReadOnlyMemory`1<char> str);
    private void ShowType(ExprNode node);
    private void ShowType(ParamNode node);
    public virtual void Visit(BoolLitNode node);
    public virtual void Visit(StrLitNode node);
    public virtual void Visit(NumLitNode node);
    public virtual void Visit(NameNode node);
    public virtual void Visit(IdentNode node);
    public virtual void Visit(ParamNode node);
    public virtual void Visit(LambdaNode node);
    public virtual void Visit(UnaryOpNode node);
    public virtual void Visit(BinaryOpNode node);
    public virtual void Visit(ConditionalNode node);
    public virtual void Visit(CompareNode node);
    public virtual void Visit(CallNode node);
    public virtual void Visit(ListNode node);
    public virtual void Visit(WithNode node);
    public virtual void Visit(WithLocalNode node);
}
internal abstract class Microsoft.ML.Transforms.NodeVisitor : object {
    public abstract virtual void Visit(BoolLitNode node);
    public abstract virtual void Visit(StrLitNode node);
    public abstract virtual void Visit(NumLitNode node);
    public abstract virtual void Visit(NameNode node);
    public abstract virtual void Visit(IdentNode node);
    public abstract virtual void Visit(ParamNode node);
    public virtual bool PreVisit(LambdaNode node);
    public virtual bool PreVisit(UnaryOpNode node);
    public virtual bool PreVisit(BinaryOpNode node);
    public virtual bool PreVisit(ConditionalNode node);
    public virtual bool PreVisit(CompareNode node);
    public virtual bool PreVisit(CallNode node);
    public virtual bool PreVisit(ListNode node);
    public virtual bool PreVisit(WithNode node);
    public virtual bool PreVisit(WithLocalNode node);
    public abstract virtual void PostVisit(LambdaNode node);
    public abstract virtual void PostVisit(UnaryOpNode node);
    public abstract virtual void PostVisit(BinaryOpNode node);
    public abstract virtual void PostVisit(ConditionalNode node);
    public abstract virtual void PostVisit(CompareNode node);
    public abstract virtual void PostVisit(CallNode node);
    public abstract virtual void PostVisit(ListNode node);
    public abstract virtual void PostVisit(WithNode node);
    public abstract virtual void PostVisit(WithLocalNode node);
}
internal class Microsoft.ML.Transforms.NumLitNode : ExprNode {
    public NumLitToken Value { get; }
    public NodeKind Kind { get; }
    public NumLitNode AsNumLit { get; }
    public NumLitNode TestNumLit { get; }
    public NumLitNode(NumLitToken tok);
    public NumLitToken get_Value();
    public virtual NodeKind get_Kind();
    public virtual NumLitNode get_AsNumLit();
    public virtual NumLitNode get_TestNumLit();
    public virtual void Accept(NodeVisitor visitor);
}
internal abstract class Microsoft.ML.Transforms.NumLitToken : Token {
    protected NumLitToken(TextSpan span, TokKind tid);
}
public class Microsoft.ML.Transforms.OneHotEncodingEstimator : object {
    private IHost _host;
    private IEstimator`1<ITransformer> _toSomething;
    private ValueToKeyMappingEstimator _term;
    internal OneHotEncodingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, OutputKind outputKind);
    internal OneHotEncodingEstimator(IHostEnvironment env, ColumnOptions[] columns, IDataView keyData);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual OneHotEncodingTransformer Fit(IDataView input);
    [BestFriendAttribute]
internal void WrapTermWithDelegate(Action`1<ValueToKeyMappingTransformer> onFit);
}
public class Microsoft.ML.Transforms.OneHotEncodingTransformer : object {
    internal static string Summary;
    internal static string UserName;
    private TransformerChain`1<ITransformer> _transformer;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    internal OneHotEncodingTransformer(ValueToKeyMappingEstimator term, IEstimator`1<ITransformer> toVector, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
}
public class Microsoft.ML.Transforms.OneHotHashEncodingEstimator : object {
    private IHost _host;
    private IEstimator`1<ITransformer> _toSomething;
    private HashingEstimator _hash;
    internal OneHotHashEncodingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int numberOfBits, int maximumNumberOfInverts, OutputKind outputKind);
    internal OneHotHashEncodingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual OneHotHashEncodingTransformer Fit(IDataView input);
}
public class Microsoft.ML.Transforms.OneHotHashEncodingTransformer : object {
    internal static string Summary;
    internal static string UserName;
    private TransformerChain`1<ITransformer> _transformer;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    internal OneHotHashEncodingTransformer(HashingEstimator hash, IEstimator`1<ITransformer> keyToVector, IDataView input);
    private static IDataView Create(IHostEnvironment env, IDataView input, string name, string source, int numberOfBits, int maximumNumberOfInverts, OutputKind outputKind);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.OptionalColumnTransform : RowToRowMapperTransformBase {
    internal static string Summary;
    internal static string UserName;
    public static string LoaderSignature;
    internal static string ShortName;
    private static FuncInstanceMethodInfo1`4<OptionalColumnTransform, DataViewRow, int, Delegate> _getSrcGetterMethodInfo;
    private static FuncInstanceMethodInfo1`2<OptionalColumnTransform, Delegate> _makeGetterOneMethodInfo;
    private static FuncInstanceMethodInfo1`3<OptionalColumnTransform, int, Delegate> _makeGetterVecMethodInfo;
    private Bindings _bindings;
    private static string RegistrationName;
    public DataViewSchema OutputSchema { get; }
    public OptionalColumnTransform(IHostEnvironment env, IDataView input, String[] columns);
    public OptionalColumnTransform(IHostEnvironment env, Arguments args, IDataView input);
    private OptionalColumnTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static OptionalColumnTransform();
    private static VersionInfo GetVersionInfo();
    public static OptionalColumnTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public virtual DataViewSchema get_OutputSchema();
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    protected virtual IEnumerable`1<Column> GetDependenciesCore(IEnumerable`1<Column> dependingColumns);
    protected virtual int MapColumnIndex(Boolean& isSrc, int col);
    protected virtual Delegate[] CreateGetters(DataViewRow input, IEnumerable`1<Column> activeColumns, Action& disposer);
    private ValueGetter`1<T> GetSrcGetter(DataViewRow input, int iinfo);
    private Delegate MakeGetter(int iinfo);
    private Delegate MakeGetterOne();
    private Delegate MakeGetterVec(int length);
    public sealed virtual void SaveAsOnnx(OnnxContext ctx);
    public sealed virtual bool CanSaveOnnx(OnnxContext ctx);
    private bool SaveAsOnnxCore(OnnxContext ctx, string srcVariableName, DataViewType columnType);
    [EntryPointAttribute]
public static TransformOutput MakeOptional(IHostEnvironment env, Arguments input);
}
internal class Microsoft.ML.Transforms.ParallelMultiCountTableBuilder : MultiCountTableBuilderBase {
    private IHost _host;
    private InternalCountTableBuilderBase[][] _countTableBuilders;
    public static string RegistrationName;
    public ParallelMultiCountTableBuilder(IHostEnvironment env, Column[] inputColumns, CountTableBuilderBase[] builders, long labelCardinality);
    private ParallelMultiCountTableBuilder(IHostEnvironment env, MultiCountTable table, Column[] inputCols, long labelCardinality);
    public virtual void IncrementSlot(int iCol, int iSlot, UInt32 key, UInt32 labelKey);
    public virtual MultiCountTableBase CreateMultiCountTable();
}
internal class Microsoft.ML.Transforms.ParamNode : Node {
    public string Name;
    public int Index;
    public DataViewType Type;
    public ExprTypeKind ExprType;
    public NodeKind Kind { get; }
    public ParamNode AsParam { get; }
    public ParamNode TestParam { get; }
    public ParamNode(Token tok, string name, int index, DataViewType type);
    public virtual NodeKind get_Kind();
    public virtual ParamNode get_AsParam();
    public virtual ParamNode get_TestParam();
    public virtual void Accept(NodeVisitor visitor);
}
internal static class Microsoft.ML.Transforms.PermutationFeatureImportance`3 : object {
    public static ImmutableArray`1<TResult> GetImportanceMetricsMatrix(IHostEnvironment env, IPredictionTransformer`1<TModel> model, IDataView data, Func`1<TResult> resultInitializer, Func`2<IDataView, TMetric> evaluationFunc, Func`3<TMetric, TMetric, TMetric> deltaFunc, string features, int permutationCount, bool useFeatureWeightFilter, Nullable`1<int> topExamples);
    private static ReadOnlyMemory`1<char> GetSlotName(VBuffer`1<ReadOnlyMemory`1<char>> slotNames, int index);
}
internal enum Microsoft.ML.Transforms.Precedence : Enum {
    public byte value__;
    public static Precedence None;
    public static Precedence Conditional;
    public static Precedence Coalesce;
    public static Precedence Or;
    public static Precedence And;
    public static Precedence Compare;
    public static Precedence Concat;
    public static Precedence Add;
    public static Precedence Mul;
    public static Precedence Error;
    public static Precedence PrefixUnary;
    public static Precedence Power;
    public static Precedence Postfix;
    public static Precedence Primary;
    public static Precedence Atomic;
}
internal abstract class Microsoft.ML.Transforms.PreVisitor : NodeVisitor {
    public abstract virtual void Visit(LambdaNode node);
    public abstract virtual void Visit(UnaryOpNode node);
    public abstract virtual void Visit(BinaryOpNode node);
    public abstract virtual void Visit(ConditionalNode node);
    public abstract virtual void Visit(CompareNode node);
    public abstract virtual void Visit(CallNode node);
    public abstract virtual void Visit(ListNode node);
    public abstract virtual void Visit(WithNode node);
    public abstract virtual void Visit(WithLocalNode node);
    public virtual bool PreVisit(LambdaNode node);
    public virtual bool PreVisit(UnaryOpNode node);
    public virtual bool PreVisit(BinaryOpNode node);
    public virtual bool PreVisit(ConditionalNode node);
    public virtual bool PreVisit(CompareNode node);
    public virtual bool PreVisit(CallNode node);
    public virtual bool PreVisit(ListNode node);
    public virtual bool PreVisit(WithNode node);
    public virtual bool PreVisit(WithLocalNode node);
    public virtual void PostVisit(LambdaNode node);
    public virtual void PostVisit(UnaryOpNode node);
    public virtual void PostVisit(BinaryOpNode node);
    public virtual void PostVisit(ConditionalNode node);
    public virtual void PostVisit(CompareNode node);
    public virtual void PostVisit(CallNode node);
    public virtual void PostVisit(ListNode node);
    public virtual void PostVisit(WithNode node);
    public virtual void PostVisit(WithLocalNode node);
}
internal class Microsoft.ML.Transforms.ProduceIdTransform : RowToRowTransformBase {
    internal static string Summary;
    internal static string LoaderSignature;
    private Bindings _bindings;
    public DataViewSchema OutputSchema { get; }
    public bool CanShuffle { get; }
    public ProduceIdTransform(IHostEnvironment env, Arguments args, IDataView input);
    private ProduceIdTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public virtual DataViewSchema get_OutputSchema();
    public virtual bool get_CanShuffle();
    public static ProduceIdTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.ML.Transforms.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Arabic { get; }
    internal static string Czech { get; }
    internal static string Danish { get; }
    internal static string Dutch { get; }
    internal static string English { get; }
    internal static string French { get; }
    internal static string German { get; }
    internal static string Italian { get; }
    internal static string Japanese { get; }
    internal static string Norwegian_Bokmal { get; }
    internal static string Polish { get; }
    internal static string Portuguese { get; }
    internal static string Portuguese_Brazilian { get; }
    internal static string Russian { get; }
    internal static string Spanish { get; }
    internal static string Swedish { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Arabic();
    internal static string get_Czech();
    internal static string get_Danish();
    internal static string get_Dutch();
    internal static string get_English();
    internal static string get_French();
    internal static string get_German();
    internal static string get_Italian();
    internal static string get_Japanese();
    internal static string get_Norwegian_Bokmal();
    internal static string get_Polish();
    internal static string get_Portuguese();
    internal static string get_Portuguese_Brazilian();
    internal static string get_Russian();
    internal static string get_Spanish();
    internal static string get_Swedish();
}
internal static class Microsoft.ML.Transforms.SelectFeatures : object {
    [EntryPointAttribute]
public static TransformOutput CountSelect(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput MutualInformationSelect(IHostEnvironment env, Options input);
}
internal class Microsoft.ML.Transforms.SignatureCountTableBuilder : MulticastDelegate {
    public SignatureCountTableBuilder(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.Transforms.SignatureFunctionProvider : MulticastDelegate {
    public SignatureFunctionProvider(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.SignatureKernelBase : MulticastDelegate {
    public SignatureKernelBase(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.Transforms.StatefulCustomMappingEstimator`3 : TrivialEstimator`1<StatefulCustomMappingTransformer`3<TSrc, TDst, TState>> {
    internal StatefulCustomMappingEstimator`3(IHostEnvironment env, Action`3<TSrc, TDst, TState> mapAction, string contractName, Action`1<TState> stateInitAction);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public abstract class Microsoft.ML.Transforms.StatefulCustomMappingFactory`3 : object {
    public abstract virtual Action`3<TSrc, TDst, TState> GetMapping();
    public abstract virtual Action`1<TState> GetStateInitAction();
    private sealed virtual override ITransformer Microsoft.ML.Transforms.ICustomMappingFactory.CreateTransformer(IHostEnvironment env, string contractName);
}
internal class Microsoft.ML.Transforms.StatefulCustomMappingFilter`2 : CustomMappingFilterBase`1<TSrc> {
    private Func`3<TSrc, TState, bool> _predicate;
    private Action`1<TState> _stateInitAction;
    public bool CanShuffle { get; }
    public StatefulCustomMappingFilter`2(IHostEnvironment env, IDataView input, Func`3<TSrc, TState, bool> predicate, Action`1<TState> stateInitAction);
    public virtual bool get_CanShuffle();
    protected virtual DataViewRowCursor GetRowCursorCore(DataViewRowCursor input, Boolean[] active);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
public class Microsoft.ML.Transforms.StatefulCustomMappingTransformer`3 : object {
    private IHost _host;
    private Action`3<TSrc, TDst, TState> _mapAction;
    private Action`1<TState> _stateInitAction;
    private string _contractName;
    private string _contractAssembly;
    [CompilerGeneratedAttribute]
private InternalSchemaDefinition <AddedSchema>k__BackingField;
    internal InternalSchemaDefinition AddedSchema { get; }
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    internal StatefulCustomMappingTransformer`3(IHostEnvironment env, Action`3<TSrc, TDst, TState> mapAction, string contractName, Action`1<TState> stateInitAction);
    [CompilerGeneratedAttribute]
internal InternalSchemaDefinition get_AddedSchema();
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    internal void SaveModel(ModelSaveContext ctx);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
}
internal class Microsoft.ML.Transforms.StatefulFilterTransform`3 : object {
    private IHost _host;
    private static string RegistrationNameTemplate;
    private IDataView _source;
    private Func`4<TSrc, TDst, TState, bool> _filterFunc;
    private Action`1<TState> _initStateAction;
    private ColumnBindings _bindings;
    private InternalSchemaDefinition _addedSchema;
    private SchemaDefinition _inputSchemaDefinition;
    private TypedCursorable`1<TSrc> _typedSource;
    private static string RegistrationName { get; }
    public bool CanShuffle { get; }
    private DataViewSchema Microsoft.ML.IDataView.Schema { get; }
    public DataViewSchema OutputSchema { get; }
    public IDataView Source { get; }
    public StatefulFilterTransform`3(IHostEnvironment env, IDataView source, Func`4<TSrc, TDst, TState, bool> filterFunc, Action`1<TState> initStateAction, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition);
    private StatefulFilterTransform`3(IHostEnvironment env, StatefulFilterTransform`3<TSrc, TDst, TState> transform, IDataView newSource);
    private static string get_RegistrationName();
    public sealed virtual bool get_CanShuffle();
    private sealed virtual override DataViewSchema Microsoft.ML.IDataView.get_Schema();
    public DataViewSchema get_OutputSchema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    public IDataView get_Source();
}
internal class Microsoft.ML.Transforms.StrLitNode : ExprNode {
    public ReadOnlyMemory`1<char> Value;
    public NodeKind Kind { get; }
    public StrLitNode AsStrLit { get; }
    public StrLitNode TestStrLit { get; }
    public StrLitNode(StrLitToken tok);
    public virtual NodeKind get_Kind();
    public virtual StrLitNode get_AsStrLit();
    public virtual StrLitNode get_TestStrLit();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.StrLitToken : Token {
    public string Value;
    public StrLitToken(TextSpan span, string val);
    public virtual string ToString();
    public static void Write(TextWriter wrt, string str);
}
public class Microsoft.ML.Transforms.Text.CustomStopWordsRemovingEstimator : TrivialEstimator`1<CustomStopWordsRemovingTransformer> {
    internal static string ExpectedColumnType;
    internal CustomStopWordsRemovingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, String[] stopwords);
    internal CustomStopWordsRemovingEstimator(IHostEnvironment env, ValueTuple`2[] columns, String[] stopwords);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.CustomStopWordsRemovingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    private static string StopwordsManagerLoaderSignature;
    private static DataViewType _outputType;
    private Pool _stopWordsMap;
    private static string RegistrationName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, string>> Columns { get; }
    internal CustomStopWordsRemovingTransformer(IHostEnvironment env, String[] stopwords, ValueTuple`2[] columns);
    internal CustomStopWordsRemovingTransformer(IHostEnvironment env, string stopwords, string dataFile, string stopwordsColumn, IComponentFactory`2<IMultiStreamSource, ILegacyDataLoader> loader, ValueTuple`2[] columns);
    private CustomStopWordsRemovingTransformer(IHost host, ModelLoadContext ctx);
    private static CustomStopWordsRemovingTransformer();
    private static VersionInfo GetVersionInfo();
    private static VersionInfo GetStopwordsManagerVersionInfo();
    private ILegacyDataLoader GetLoaderForStopwords(IChannel ch, string dataFile, IComponentFactory`2<IMultiStreamSource, ILegacyDataLoader> loader, String& stopwordsCol);
    private void LoadStopWords(IChannel ch, ReadOnlyMemory`1<char> stopwords, string dataFile, string stopwordsColumn, IComponentFactory`2<IMultiStreamSource, ILegacyDataLoader> loaderFactory, Pool& stopWordsMap);
    internal IReadOnlyCollection`1<ValueTuple`2<string, string>> get_Columns();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static CustomStopWordsRemovingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.Text.ExtractorColumn : ManyToOneColumn {
    public String[] FriendlyNames;
}
internal interface Microsoft.ML.Transforms.Text.INgramExtractorFactory {
    public bool UseHashingTrick { get; }
    public abstract virtual bool get_UseHashingTrick();
    public abstract virtual ITransformer Create(IHostEnvironment env, IDataView input, ExtractorColumn[] cols);
}
[ComponentKindAttribute("NgramExtractor")]
internal interface Microsoft.ML.Transforms.Text.INgramExtractorFactoryFactory {
}
[ComponentKindAttribute("StopWordsRemover")]
internal interface Microsoft.ML.Transforms.Text.IStopWordsRemoverFactory {
}
public interface Microsoft.ML.Transforms.Text.IStopWordsRemoverOptions {
}
public class Microsoft.ML.Transforms.Text.LatentDirichletAllocationEstimator : object {
    private IHost _host;
    private ImmutableArray`1<ColumnOptions> _columns;
    internal LatentDirichletAllocationEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int numberOfTopics, float alphaSum, float beta, int samplingStepCount, int maximumNumberOfIterations, int numberOfThreads, int maximumTokenCountPerDocument, int numberOfSummaryTermsPerTopic, int likelihoodInterval, int numberOfBurninIterations, bool resetRandomGenerator, bool outputTopicWordSummary);
    internal LatentDirichletAllocationEstimator(IHostEnvironment env, ColumnOptions[] columns);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual LatentDirichletAllocationTransformer Fit(IDataView input);
}
public class Microsoft.ML.Transforms.Text.LatentDirichletAllocationTransformer : OneToOneTransformerBase {
    internal static string LoaderSignature;
    private ColumnOptions[] _columns;
    private LdaState[] _ldas;
    private List`1<VBuffer`1<ReadOnlyMemory`1<char>>> _columnMappings;
    private static string RegistrationName;
    private static string WordTopicModelFilename;
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    private LatentDirichletAllocationTransformer(IHostEnvironment env, LdaState[] ldas, List`1<VBuffer`1<ReadOnlyMemory`1<char>>> columnMappings, ColumnOptions[] columns);
    private LatentDirichletAllocationTransformer(IHost host, ModelLoadContext ctx);
    public ModelParameters GetLdaDetails(int columnIndex);
    private static VersionInfo GetVersionInfo();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    internal static LatentDirichletAllocationTransformer TrainLdaTransformer(IHostEnvironment env, IDataView inputData, ColumnOptions[] columns);
    public void Dispose();
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static LatentDirichletAllocationTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private void SaveTopicWordSummary(ModelSaveContext ctx, int i);
    private static int GetFrequency(double value);
    private static List`1<VBuffer`1<ReadOnlyMemory`1<char>>> Train(IHostEnvironment env, IChannel ch, IDataView inputData, LdaState[] states, ColumnOptions[] columns);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
public class Microsoft.ML.Transforms.Text.NgramExtractingEstimator : object {
    private IHost _host;
    private ColumnOptions[] _columns;
    internal static string ExpectedColumnType;
    internal NgramExtractingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting);
    internal NgramExtractingEstimator(IHostEnvironment env, ValueTuple`2[] columns, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting);
    internal NgramExtractingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    public sealed virtual NgramExtractingTransformer Fit(IDataView input);
    internal static bool IsColumnTypeValid(DataViewType type);
    internal static bool IsSchemaColumnValid(Column col);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.NgramExtractingTransformer : OneToOneTransformerBase {
    private static UInt32 VerTfIdfSupported;
    internal static string LoaderSignature;
    internal static string Summary;
    internal static string UserName;
    private ImmutableArray`1<TransformInfo> _transformInfos;
    private SequencePool[] _ngramMaps;
    private Double[][] _invDocFreqs;
    internal NgramExtractingTransformer(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    private NgramExtractingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private static SequencePool[] Train(IHostEnvironment env, ColumnOptions[] columns, ImmutableArray`1<TransformInfo> transformInfos, IDataView trainingData, Double[][]& invDocFreqs);
    [ConditionalAttribute("DEBUG")]
private static void AssertValid(IHostEnvironment env, Int32[] counts, IReadOnlyList`1<int> lims, SequencePool pool);
    private static NgramIdFinder GetNgramIdFinderAdd(IHostEnvironment env, Int32[] counts, IReadOnlyList`1<int> lims, SequencePool pool, bool requireIdf);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static NgramExtractingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal static class Microsoft.ML.Transforms.Text.NgramExtractionUtils : object {
    public static IEstimator`1<ITransformer> GetConcatEstimator(IHostEnvironment env, ManyToOneColumn[] columns);
    public static String[][] GenerateUniqueSourceNames(IHostEnvironment env, ManyToOneColumn[] columns, DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.Text.NgramExtractorFactory : object {
    private NgramExtractorArguments _extractorArgs;
    private TermLoaderArguments _termLoaderArgs;
    public bool UseHashingTrick { get; }
    public NgramExtractorFactory(NgramExtractorArguments extractorArgs, TermLoaderArguments termLoaderArgs);
    public sealed virtual bool get_UseHashingTrick();
    public sealed virtual ITransformer Create(IHostEnvironment env, IDataView input, ExtractorColumn[] cols);
}
internal static class Microsoft.ML.Transforms.Text.NgramExtractorTransform : object {
    internal static string Summary;
    internal static string LoaderSignature;
    internal static IEstimator`1<ITransformer> CreateEstimator(IHostEnvironment env, Options options, SchemaShape inputSchema, TermLoaderArguments termLoaderArgs);
    internal static IDataTransform CreateDataTransform(IHostEnvironment env, Options options, IDataView input, TermLoaderArguments termLoaderArgs);
    internal static Options CreateNgramExtractorOptions(NgramExtractorArguments extractorArgs, ExtractorColumn[] cols);
    internal static INgramExtractorFactory Create(IHostEnvironment env, NgramExtractorArguments extractorArgs, TermLoaderArguments termLoaderArgs);
}
internal static class Microsoft.ML.Transforms.Text.NgramHashExtractingTransformer : object {
    internal static string Summary;
    internal static string LoaderSignature;
    internal static ITransformer Create(IHostEnvironment env, Options options, IDataView input);
    internal static ITransformer Create(NgramHashExtractorArguments extractorArgs, IHostEnvironment env, IDataView input, ExtractorColumn[] cols);
    internal static INgramExtractorFactory Create(IHostEnvironment env, NgramHashExtractorArguments extractorArgs, TermLoaderArguments termLoaderArgs);
}
internal class Microsoft.ML.Transforms.Text.NgramHashExtractorFactory : object {
    private NgramHashExtractorArguments _extractorArgs;
    public bool UseHashingTrick { get; }
    public NgramHashExtractorFactory(NgramHashExtractorArguments extractorArgs);
    public sealed virtual bool get_UseHashingTrick();
    public sealed virtual ITransformer Create(IHostEnvironment env, IDataView input, ExtractorColumn[] cols);
}
public class Microsoft.ML.Transforms.Text.NgramHashingEstimator : object {
    private IHost _host;
    private ColumnOptions[] _columns;
    internal static string ExpectedColumnType;
    internal NgramHashingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    internal NgramHashingEstimator(IHostEnvironment env, string outputColumnName, String[] inputColumnNames, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    internal NgramHashingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    internal static bool IsSchemaColumnValid(Column col);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual NgramHashingTransformer Fit(IDataView input);
}
public class Microsoft.ML.Transforms.Text.NgramHashingTransformer : RowToRowTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    private static int VersionTransformer;
    private ImmutableArray`1<ColumnOptions> _columns;
    private VBuffer`1[] _slotNames;
    private VectorDataViewType[] _slotNamesTypes;
    internal NgramHashingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    internal NgramHashingTransformer(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    private NgramHashingTransformer(IHostEnvironment env, ModelLoadContext ctx, bool loadLegacy);
    private static VersionInfo GetVersionInfo();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static NgramHashingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
[ComponentAttribute]
internal class Microsoft.ML.Transforms.Text.PredefinedStopWordsRemoverFactory : object {
    public sealed virtual ITransformer CreateComponent(IHostEnvironment env, IDataView input, OneToOneColumn[] columns);
}
internal static class Microsoft.ML.Transforms.Text.SentimentAnalyzingTransformer : object {
    internal static string Summary;
    internal static string LoaderSignature;
    internal static string UserName;
    internal static string ShortName;
    private static string ModelInputColumnName;
    private static String[] _modelIntermediateColumnNames;
    private static string ModelScoreColumnName;
    private static SentimentAnalyzingTransformer();
    internal static IDataTransform Create(IHostEnvironment env, Arguments args, IDataView input);
    private static IDataView AliasIfNeeded(IHostEnvironment env, IDataView input, String[] colNames, KeyValuePair`2[]& hiddenNames);
    private static IDataView UnaliasIfNeeded(IHostEnvironment env, IDataView input, KeyValuePair`2[] hiddenNames);
    private static IDataView LoadTransforms(IHostEnvironment env, IDataView input, string modelFile);
}
internal class Microsoft.ML.Transforms.Text.SignatureNgramExtractorFactory : MulticastDelegate {
    public SignatureNgramExtractorFactory(object object, IntPtr method);
    public virtual void Invoke(TermLoaderArguments termLoaderArgs);
    public virtual IAsyncResult BeginInvoke(TermLoaderArguments termLoaderArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.Transforms.Text.StopWordsRemovingEstimator : TrivialEstimator`1<StopWordsRemovingTransformer> {
    internal static string ExpectedColumnType;
    internal StopWordsRemovingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, Language language);
    internal StopWordsRemovingEstimator(IHostEnvironment env, ValueTuple`2[] columns, Language language);
    internal StopWordsRemovingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.StopWordsRemovingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    private ColumnOptions[] _columns;
    private static Pool[] modreq(System.Runtime.CompilerServices.IsVolatile) _stopWords;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _langsDictionary;
    private static string RegistrationName;
    private static string StopWordsDirectoryName;
    internal IReadOnlyCollection`1<ColumnOptions> Columns { get; }
    private static Pool[] StopWords { get; }
    private static Dictionary`2<ReadOnlyMemory`1<char>, Language> LangsDictionary { get; }
    internal StopWordsRemovingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private StopWordsRemovingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ColumnOptions> get_Columns();
    private static Pool[] get_StopWords();
    private static Dictionary`2<ReadOnlyMemory`1<char>, Language> get_LangsDictionary();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static StopWordsRemovingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private void CheckResources();
    private static void AddResourceIfNotPresent(Language lang);
    private static Stream GetResourceFileStreamOrNull(Language lang);
}
internal class Microsoft.ML.Transforms.Text.TermLoaderArguments : object {
    [ArgumentAttribute("0")]
public string Term;
    [ArgumentAttribute("0")]
public String[] Terms;
    [ArgumentAttribute("0")]
public string DataFile;
    [ArgumentAttribute("4")]
internal IComponentFactory`2<IMultiStreamSource, ILegacyDataLoader> Loader;
    [ArgumentAttribute("0")]
public string TermsColumn;
    [ArgumentAttribute("0")]
public KeyOrdinality Sort;
    [ArgumentAttribute("0")]
public bool DropUnknowns;
}
internal static class Microsoft.ML.Transforms.Text.TextAnalytics : object {
    [EntryPointAttribute]
public static TransformOutput TextTransform(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput DelimitedTokenizeTransform(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput NGramTransform(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput TermTransform(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput AnalyzeSentiment(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static TransformOutput CharTokenize(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput LightLda(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput WordEmbeddings(IHostEnvironment env, Options input);
}
public class Microsoft.ML.Transforms.Text.TextFeaturizingEstimator : object {
    internal string OutputColumn;
    private String[] _inputColumns;
    [CompilerGeneratedAttribute]
private Options <OptionalSettings>k__BackingField;
    private IStopWordsRemoverFactory _stopWordsRemover;
    private TermLoaderArguments _dictionary;
    private INgramExtractorFactoryFactory _wordFeatureExtractor;
    private INgramExtractorFactoryFactory _charFeatureExtractor;
    private IHost _host;
    internal static string Summary;
    internal static string UserName;
    internal static string LoaderSignature;
    internal static Language DefaultLanguage;
    private IReadOnlyCollection`1<string> InputColumns { get; }
    internal Options OptionalSettings { get; }
    internal TextFeaturizingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName);
    internal TextFeaturizingEstimator(IHostEnvironment env, string name, IEnumerable`1<string> source, Options options);
    private IReadOnlyCollection`1<string> get_InputColumns();
    [CompilerGeneratedAttribute]
internal Options get_OptionalSettings();
    public sealed virtual ITransformer Fit(IDataView input);
    private static TransformerChain`1<ITransformer> AddToChainAndTransform(TransformerChain`1<ITransformer> chain, ITransformer transformer, IDataView& view);
    private static ITransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static string GenerateColumnName(DataViewSchema schema, string srcName, string xfTag);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    internal static IDataTransform Create(IHostEnvironment env, Options args, IDataView data);
}
public class Microsoft.ML.Transforms.Text.TextNormalizingEstimator : TrivialEstimator`1<TextNormalizingTransformer> {
    internal static string ExpectedColumnType;
    internal TextNormalizingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, CaseMode caseMode, bool keepDiacritics, bool keepPunctuations, bool keepNumbers);
    internal TextNormalizingEstimator(IHostEnvironment env, CaseMode caseMode, bool keepDiacritics, bool keepPunctuations, bool keepNumbers, ValueTuple`2[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.TextNormalizingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    private static string RegistrationName;
    private CaseMode _caseMode;
    private bool _keepDiacritics;
    private bool _keepPunctuations;
    private bool _keepNumbers;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, string>> Columns { get; }
    internal TextNormalizingTransformer(IHostEnvironment env, CaseMode caseMode, bool keepDiacritics, bool keepPunctuations, bool keepNumbers, ValueTuple`2[] columns);
    private TextNormalizingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ValueTuple`2<string, string>> get_Columns();
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static TextNormalizingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
public class Microsoft.ML.Transforms.Text.TokenizingByCharactersEstimator : TrivialEstimator`1<TokenizingByCharactersTransformer> {
    internal static string ExpectedColumnType;
    internal TokenizingByCharactersEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, bool useMarkerCharacters);
    internal TokenizingByCharactersEstimator(IHostEnvironment env, bool useMarkerCharacters, ValueTuple`2[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.TokenizingByCharactersTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    internal static string UserName;
    private bool _isSeparatorStartEnd;
    private bool _useMarkerChars;
    private static ushort UnitSeparator;
    private static ushort TextStartMarker;
    private static ushort TextEndMarker;
    private static int TextMarkersCount;
    internal static int CharsCount;
    private static string RegistrationName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, string>> Columns { get; }
    internal TokenizingByCharactersTransformer(IHostEnvironment env, bool useMarkerCharacters, ValueTuple`2[] columns);
    private TokenizingByCharactersTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ValueTuple`2<string, string>> get_Columns();
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static TokenizingByCharactersTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal static class Microsoft.ML.Transforms.Text.WordBagBuildingTransformer : object {
    private static string RegistrationName;
    internal static string Summary;
    internal static IEstimator`1<ITransformer> CreateEstimator(IHostEnvironment env, Options options, SchemaShape inputSchema);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
}
public class Microsoft.ML.Transforms.Text.WordBagEstimator : object {
    private IHost _host;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _columns;
    private int _ngramLength;
    private int _skipLength;
    private bool _useAllLengths;
    private int _maxNumTerms;
    private WeightingCriteria _weighting;
    private char _termSeparator;
    private char _freqSeparator;
    internal WordBagEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting, char termSeparator, char freqSeparator);
    internal WordBagEstimator(IHostEnvironment env, string outputColumnName, String[] inputColumnNames, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting, char termSeparator, char freqSeparator);
    internal WordBagEstimator(IHostEnvironment env, ValueTuple`2[] columns, int ngramLength, int skipLength, bool useAllLengths, int maximumNgramsCount, WeightingCriteria weighting, char termSeparator, char freqSeparator);
    public sealed virtual ITransformer Fit(IDataView input);
    private Options CreateOptions();
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.WordEmbeddingEstimator : object {
    private IHost _host;
    private ColumnOptions[] _columns;
    private Nullable`1<PretrainedModelKind> _modelKind;
    private string _customLookupTable;
    internal WordEmbeddingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, PretrainedModelKind modelKind);
    internal WordEmbeddingEstimator(IHostEnvironment env, string outputColumnName, string customModelFile, string inputColumnName);
    internal WordEmbeddingEstimator(IHostEnvironment env, PretrainedModelKind modelKind, ColumnOptions[] columns);
    internal WordEmbeddingEstimator(IHostEnvironment env, string customModelFile, ColumnOptions[] columns);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual WordEmbeddingTransformer Fit(IDataView input);
}
public class Microsoft.ML.Transforms.Text.WordEmbeddingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    internal static string LoaderSignature;
    private Nullable`1<PretrainedModelKind> _modelKind;
    private string _modelFileNameWithPath;
    private static object _embeddingsLock;
    private bool _customLookup;
    private int _linesToSkip;
    private Model _currentVocab;
    private static Dictionary`2<string, WeakReference`1<Model>> _vocab;
    private static string RegistrationName;
    private static int Timeout;
    private static Dictionary`2<PretrainedModelKind, string> _modelsMetaData;
    private static Dictionary`2<PretrainedModelKind, int> _linesToSkipInModels;
    internal WordEmbeddingTransformer(IHostEnvironment env, string outputColumnName, string inputColumnName, PretrainedModelKind modelKind);
    internal WordEmbeddingTransformer(IHostEnvironment env, string outputColumnName, string customModelFile, string inputColumnName);
    internal WordEmbeddingTransformer(IHostEnvironment env, PretrainedModelKind modelKind, ColumnOptions[] columns);
    internal WordEmbeddingTransformer(IHostEnvironment env, string customModelFile, ColumnOptions[] columns);
    private WordEmbeddingTransformer(IHost host, ModelLoadContext ctx);
    private static WordEmbeddingTransformer();
    internal static VersionInfo GetVersionInfo();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    internal static WordEmbeddingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private string EnsureModelFile(IHostEnvironment env, Int32& linesToSkip, PretrainedModelKind kind);
    private Model GetVocabularyDictionary(IHostEnvironment hostEnvironment);
    private static ParallelOptions GetParallelOptions(IHostEnvironment hostEnvironment);
}
public class Microsoft.ML.Transforms.Text.WordHashBagEstimator : object {
    private IHost _host;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _columns;
    private int _numberOfBits;
    private int _ngramLength;
    private int _skipLength;
    private bool _useAllLengths;
    private UInt32 _seed;
    private bool _ordered;
    private int _maximumNumberOfInverts;
    internal WordHashBagEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    internal WordHashBagEstimator(IHostEnvironment env, string outputColumnName, String[] inputColumnNames, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    internal WordHashBagEstimator(IHostEnvironment env, ValueTuple`2[] columns, int numberOfBits, int ngramLength, int skipLength, bool useAllLengths, UInt32 seed, bool useOrderedHashing, int maximumNumberOfInverts);
    public sealed virtual ITransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal static class Microsoft.ML.Transforms.Text.WordHashBagProducingTransformer : object {
    private static string RegistrationName;
    internal static string Summary;
    internal static ITransformer CreateTransformer(IHostEnvironment env, Options options, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
}
public class Microsoft.ML.Transforms.Text.WordTokenizingEstimator : TrivialEstimator`1<WordTokenizingTransformer> {
    internal static string ExpectedColumnType;
    internal WordTokenizingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, Char[] separators);
    internal WordTokenizingEstimator(IHostEnvironment env, ValueTuple`2[] columns, Char[] separators);
    internal WordTokenizingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.Text.WordTokenizingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    internal static string UserName;
    private static string RegistrationName;
    private ColumnOptions[] _columns;
    internal IReadOnlyCollection`1<ColumnOptions> Columns { get; }
    internal WordTokenizingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private WordTokenizingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ColumnOptions> get_Columns();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static WordTokenizingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal class Microsoft.ML.Transforms.TextSpan : ValueType {
    public int Min;
    public int Lim;
    public TextSpan(int ichMin, int ichLim);
    public virtual string ToString();
}
internal abstract class Microsoft.ML.Transforms.Token : object {
    public TokKind Kind;
    public TokKind KindContext;
    public TextSpan Span;
    protected Token(TextSpan span, TokKind tid);
    protected Token(TextSpan span, TokKind tid, TokKind tidContext);
    public T As();
    public virtual string ToString();
}
internal class Microsoft.ML.Transforms.TokenCursor : object {
    private IEnumerator`1<Token> _tokens;
    private Token[] _buffer;
    private int _itokBase;
    private int _itokLim;
    private int _itokCur;
    private Token _tokCur;
    private TokKind _tidCur;
    private int _itokPin;
    public Token TokCur { get; }
    public TokKind TidCur { get; }
    public TokKind CtxCur { get; }
    public TokenCursor(IEnumerable`1<Token> tokens);
    [ConditionalAttribute("DEBUG")]
private void AssertValid();
    public Token get_TokCur();
    public TokKind get_TidCur();
    public TokKind get_CtxCur();
    private void FetchToken();
    private void FetchCore();
    private void MoveBy(int ditok);
    public TokKind TidNext();
    public Token TokPeek(int ditok);
}
internal enum Microsoft.ML.Transforms.TokKind : Enum {
    public int value__;
    public static TokKind None;
    public static TokKind Eof;
    public static TokKind Error;
    public static TokKind ErrorInline;
    public static TokKind IntLit;
    public static TokKind FltLit;
    public static TokKind DblLit;
    public static TokKind CharLit;
    public static TokKind StrLit;
    public static TokKind Comment;
    public static TokKind NewLine;
    public static TokKind Add;
    public static TokKind AddAdd;
    public static TokKind AddEqu;
    public static TokKind Sub;
    public static TokKind SubSub;
    public static TokKind SubEqu;
    public static TokKind SubGrt;
    public static TokKind Mul;
    public static TokKind MulEqu;
    public static TokKind Div;
    public static TokKind DivEqu;
    public static TokKind Per;
    public static TokKind PerEqu;
    public static TokKind Car;
    public static TokKind CarEqu;
    public static TokKind Amp;
    public static TokKind AmpAmp;
    public static TokKind AmpEqu;
    public static TokKind Bar;
    public static TokKind BarBar;
    public static TokKind BarEqu;
    public static TokKind Til;
    public static TokKind Bng;
    public static TokKind BngEqu;
    public static TokKind Equ;
    public static TokKind EquEqu;
    public static TokKind EquGrt;
    public static TokKind Lss;
    public static TokKind LssLss;
    public static TokKind LssEqu;
    public static TokKind LssGrt;
    public static TokKind LssLssEqu;
    public static TokKind Grt;
    public static TokKind GrtGrt;
    public static TokKind GrtEqu;
    public static TokKind GrtGrtEqu;
    public static TokKind Que;
    public static TokKind QueQue;
    public static TokKind Dot;
    public static TokKind Comma;
    public static TokKind Colon;
    public static TokKind ColonColon;
    public static TokKind Semi;
    public static TokKind OpenCurly;
    public static TokKind OpenParen;
    public static TokKind OpenSquare;
    public static TokKind CloseCurly;
    public static TokKind CloseParen;
    public static TokKind CloseSquare;
    public static TokKind Ident;
    public static TokKind False;
    public static TokKind True;
    public static TokKind Not;
    public static TokKind And;
    public static TokKind Or;
    public static TokKind With;
}
internal enum Microsoft.ML.Transforms.UnaryOp : Enum {
    public int value__;
    public static UnaryOp Not;
    public static UnaryOp Minus;
}
internal class Microsoft.ML.Transforms.UnaryOpNode : ExprNode {
    public ExprNode Arg;
    public UnaryOp Op;
    public NodeKind Kind { get; }
    public UnaryOpNode AsUnaryOp { get; }
    public UnaryOpNode TestUnaryOp { get; }
    public UnaryOpNode(Token tok, UnaryOp op, ExprNode arg);
    public virtual NodeKind get_Kind();
    public virtual UnaryOpNode get_AsUnaryOp();
    public virtual UnaryOpNode get_TestUnaryOp();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.UngroupTransform : TransformBase {
    public static string Summary;
    public static string LoaderSignature;
    public static string ShortName;
    public static string UserName;
    private UngroupBinding _ungroupBinding;
    public DataViewSchema OutputSchema { get; }
    public bool CanShuffle { get; }
    public UngroupTransform(IHostEnvironment env, IDataView input, UngroupMode mode, String[] columns);
    public UngroupTransform(IHostEnvironment env, Options options, IDataView input);
    private UngroupTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static UngroupTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public virtual Nullable`1<long> GetRowCount();
    public virtual DataViewSchema get_OutputSchema();
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    public virtual bool get_CanShuffle();
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
internal class Microsoft.ML.Transforms.WithLocalNode : Node {
    public string Name;
    public ExprNode Value;
    public int UseCount;
    public int Index;
    public int GenCount;
    public NodeKind Kind { get; }
    public WithLocalNode AsWithLocal { get; }
    public WithLocalNode TestWithLocal { get; }
    public WithLocalNode(Token tok, string name, ExprNode value);
    public virtual NodeKind get_Kind();
    public virtual WithLocalNode get_AsWithLocal();
    public virtual WithLocalNode get_TestWithLocal();
    public virtual void Accept(NodeVisitor visitor);
}
internal class Microsoft.ML.Transforms.WithNode : ExprNode {
    public WithLocalNode Local;
    public ExprNode Body;
    public NodeKind Kind { get; }
    public WithNode AsWith { get; }
    public WithNode TestWith { get; }
    public WithNode(Token tok, WithLocalNode local, ExprNode body);
    public virtual NodeKind get_Kind();
    public virtual WithNode get_AsWith();
    public virtual WithNode get_TestWith();
    public virtual void Accept(NodeVisitor visitor);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
