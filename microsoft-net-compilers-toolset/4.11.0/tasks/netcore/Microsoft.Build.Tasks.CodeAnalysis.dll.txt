[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.BuildTasks.CanonicalError : object {
    private static Regex s_originCategoryCodeTextExpression;
    private static Regex s_filenameLocationFromOrigin;
    private static Regex s_lineFromLocation;
    private static Regex s_lineLineFromLocation;
    private static Regex s_lineColFromLocation;
    private static Regex s_lineColColFromLocation;
    private static Regex s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.CommandLineBuilderExtension : CommandLineBuilder {
    private bool _isQuotingRequired;
    protected virtual bool IsQuotingRequired(string parameter);
    internal void AppendWhenTrue(string switchName, PropertyDictionary bag, string parameterName);
    internal void AppendPlusOrMinusSwitch(string switchName, PropertyDictionary bag, string parameterName);
    internal void AppendByChoiceSwitch(string switchName, PropertyDictionary bag, string parameterName, string choice1, string choice2);
    internal void AppendSwitchWithInteger(string switchName, PropertyDictionary bag, string parameterName);
    internal void AppendSwitchAliased(string switchName, string alias, string parameter);
    internal void AppendTextWithForceQuoting(string parameter);
    internal void AppendSwitchForceQuoted(string switchName, string parameter);
    internal void AppendNestedSwitch(string outerSwitchName, string innerSwitchName, string parameter);
    protected string GetQuotedText(string unquotedText);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] attributes);
    internal void AppendSwitchWithSplitting(string switchName, string parameter, string delimiter, Char[] splitOn);
    internal static bool IsParameterEmpty(string parameter, Char[] splitOn);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] metadataNames, Boolean[] treatAsFlags);
    internal void AppendArgumentIfNotNull(string argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.CopyRefAssembly : Task {
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DestinationPath>k__BackingField;
    [RequiredAttribute]
public string SourcePath { get; public set; }
    [OutputAttribute]
[RequiredAttribute]
public string DestinationPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public void set_SourcePath(string value);
    [CompilerGeneratedAttribute]
public string get_DestinationPath();
    [CompilerGeneratedAttribute]
public void set_DestinationPath(string value);
    public virtual bool Execute();
    private bool Copy();
    private Guid ExtractMvid(string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.Csc : ManagedCompiler {
    [NullableAttribute("1")]
private static String[] s_separators;
    public bool AllowUnsafeBlocks { get; public set; }
    public string ApplicationConfiguration { get; public set; }
    public string BaseAddress { get; public set; }
    public bool CheckForOverflowUnderflow { get; public set; }
    public string DocumentationFile { get; public set; }
    public string DisabledWarnings { get; public set; }
    public bool DisableSdkPath { get; public set; }
    public bool ErrorEndLocation { get; public set; }
    public string ErrorReport { get; public set; }
    public bool GenerateFullPaths { get; public set; }
    public string ModuleAssemblyName { get; public set; }
    public bool NoStandardLib { get; public set; }
    public string PdbFile { get; public set; }
    public string PreferredUILang { get; public set; }
    public string VsSessionGuid { get; public set; }
    public bool UseHostCompilerIfAvailable { get; public set; }
    public int WarningLevel { get; public set; }
    public string WarningsAsErrors { get; public set; }
    public string WarningsNotAsErrors { get; public set; }
    public string Nullable { get; public set; }
    [NullableAttribute("1")]
protected string ToolNameWithoutExtension { get; }
    internal RequestLanguage Language { get; }
    public string InterceptorsPreviewNamespaces { get; public set; }
    private static Csc();
    public void set_AllowUnsafeBlocks(bool value);
    public bool get_AllowUnsafeBlocks();
    public void set_ApplicationConfiguration(string value);
    public string get_ApplicationConfiguration();
    public void set_BaseAddress(string value);
    public string get_BaseAddress();
    public void set_CheckForOverflowUnderflow(bool value);
    public bool get_CheckForOverflowUnderflow();
    public void set_DocumentationFile(string value);
    public string get_DocumentationFile();
    public void set_DisabledWarnings(string value);
    public string get_DisabledWarnings();
    public void set_DisableSdkPath(bool value);
    public bool get_DisableSdkPath();
    public void set_ErrorEndLocation(bool value);
    public bool get_ErrorEndLocation();
    public void set_ErrorReport(string value);
    public string get_ErrorReport();
    public void set_GenerateFullPaths(bool value);
    public bool get_GenerateFullPaths();
    public void set_ModuleAssemblyName(string value);
    public string get_ModuleAssemblyName();
    public void set_NoStandardLib(bool value);
    public bool get_NoStandardLib();
    public void set_PdbFile(string value);
    public string get_PdbFile();
    public void set_PreferredUILang(string value);
    public string get_PreferredUILang();
    public void set_VsSessionGuid(string value);
    public string get_VsSessionGuid();
    public void set_UseHostCompilerIfAvailable(bool value);
    public bool get_UseHostCompilerIfAvailable();
    public void set_WarningLevel(int value);
    public int get_WarningLevel();
    public void set_WarningsAsErrors(string value);
    public string get_WarningsAsErrors();
    public void set_WarningsNotAsErrors(string value);
    public string get_WarningsNotAsErrors();
    public void set_Nullable(string value);
    public string get_Nullable();
    [NullableContextAttribute("1")]
internal virtual void LogCompilerOutput(string output, MessageImportance messageImportance);
    [NullableContextAttribute("1")]
protected virtual string get_ToolNameWithoutExtension();
    [NullableContextAttribute("1")]
protected virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    internal virtual RequestLanguage get_Language();
    [NullableContextAttribute("1")]
internal static void AddInterceptorsPreviewNamespaces(CommandLineBuilderExtension commandLine, string interceptorsNamespaces);
    public void set_InterceptorsPreviewNamespaces(string value);
    public string get_InterceptorsPreviewNamespaces();
    [NullableContextAttribute("1")]
internal static void AddReferencesToCommandLine(CommandLineBuilderExtension commandLine, ITaskItem[] references, bool isInteractive);
    internal static string GetDefineConstantsSwitch(string originalDefineConstants, TaskLoggingHelper log);
    [NullableContextAttribute("1")]
private bool InitializeHostCompiler(ICscHostObject cscHostObject);
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual bool CallHostObjectToExecute();
    [CompilerGeneratedAttribute]
internal static void <AddReferencesToCommandLine>g__appendGlobalReference|71_0(string itemSpec, <>c__DisplayClass71_0& , <>c__DisplayClass71_1& , <>c__DisplayClass71_2& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.Csi : InteractiveCompiler {
    protected string ToolNameWithoutExtension { get; }
    protected virtual string get_ToolNameWithoutExtension();
    protected virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
}
internal static class Microsoft.CodeAnalysis.BuildTasks.ErrorString : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Compiler_UnexpectedException { get; }
    internal static string Csc_AssemblyAliasContainsIllegalCharacters { get; }
    internal static string Csc_InvalidParameter { get; }
    internal static string Csc_InvalidParameterWarning { get; }
    internal static string General_CannotConvertStringToBool { get; }
    internal static string General_CouldNotSetHostObjectParameter { get; }
    internal static string General_DuplicateItemsNotSupported { get; }
    internal static string General_DuplicateItemsNotSupportedWithMetadata { get; }
    internal static string General_ExpectedFileMissing { get; }
    internal static string CopyRefAssembly_SkippingCopy1 { get; }
    internal static string CopyRefAssembly_Changed { get; }
    internal static string CopyRefAssembly_Copying { get; }
    internal static string CopyRefAssembly_SourceNotRef1 { get; }
    internal static string CopyRefAssembly_BadSource3 { get; }
    internal static string CopyRefAssembly_BadDestination1 { get; }
    internal static string General_ToolFileNotFound { get; }
    internal static string General_IncorrectHostObject { get; }
    internal static string General_InvalidAttributeMetadata { get; }
    internal static string General_ParameterUnsupportedOnHostCompiler { get; }
    internal static string General_ReferenceDoesNotExist { get; }
    internal static string SharedCompilationFallback { get; }
    internal static string UsingSharedCompilation { get; }
    internal static string Vbc_EnumParameterHasInvalidValue { get; }
    internal static string Vbc_ParameterHasInvalidValue { get; }
    internal static string Vbc_RenamePDB { get; }
    internal static string MapSourceRoots_ContainsDuplicate { get; }
    internal static string MapSourceRoots_NoSuchTopLevelSourceRoot { get; }
    internal static string MapSourceRoots_PathMustEndWithSlashOrBackslash { get; }
    internal static string MapSourceRoots_NoTopLevelSourceRoot { get; }
    internal static string General_UnableToReadFile { get; }
    internal static string ImplicitlySkipAnalyzersMessage { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Compiler_UnexpectedException();
    internal static string get_Csc_AssemblyAliasContainsIllegalCharacters();
    internal static string get_Csc_InvalidParameter();
    internal static string get_Csc_InvalidParameterWarning();
    internal static string get_General_CannotConvertStringToBool();
    internal static string get_General_CouldNotSetHostObjectParameter();
    internal static string get_General_DuplicateItemsNotSupported();
    internal static string get_General_DuplicateItemsNotSupportedWithMetadata();
    internal static string get_General_ExpectedFileMissing();
    internal static string get_CopyRefAssembly_SkippingCopy1();
    internal static string get_CopyRefAssembly_Changed();
    internal static string get_CopyRefAssembly_Copying();
    internal static string get_CopyRefAssembly_SourceNotRef1();
    internal static string get_CopyRefAssembly_BadSource3();
    internal static string get_CopyRefAssembly_BadDestination1();
    internal static string get_General_ToolFileNotFound();
    internal static string get_General_IncorrectHostObject();
    internal static string get_General_InvalidAttributeMetadata();
    internal static string get_General_ParameterUnsupportedOnHostCompiler();
    internal static string get_General_ReferenceDoesNotExist();
    internal static string get_SharedCompilationFallback();
    internal static string get_UsingSharedCompilation();
    internal static string get_Vbc_EnumParameterHasInvalidValue();
    internal static string get_Vbc_ParameterHasInvalidValue();
    internal static string get_Vbc_RenamePDB();
    internal static string get_MapSourceRoots_ContainsDuplicate();
    internal static string get_MapSourceRoots_NoSuchTopLevelSourceRoot();
    internal static string get_MapSourceRoots_PathMustEndWithSlashOrBackslash();
    internal static string get_MapSourceRoots_NoTopLevelSourceRoot();
    internal static string get_General_UnableToReadFile();
    internal static string get_ImplicitlySkipAnalyzersMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.GenerateMSBuildEditorConfig : Task {
    [CompilerGeneratedAttribute]
private string <ConfigFileContents>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <MetadataItems>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <PropertyItems>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <FileName>k__BackingField;
    [OutputAttribute]
public string ConfigFileContents { get; public set; }
    [RequiredAttribute]
public ITaskItem[] MetadataItems { get; public set; }
    [RequiredAttribute]
public ITaskItem[] PropertyItems { get; public set; }
    public ITaskItem FileName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigFileContents();
    [CompilerGeneratedAttribute]
public void set_ConfigFileContents(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_MetadataItems();
    [CompilerGeneratedAttribute]
public void set_MetadataItems(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_PropertyItems();
    [CompilerGeneratedAttribute]
public void set_PropertyItems(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(ITaskItem value);
    public virtual bool Execute();
    internal bool WriteMSBuildEditorConfig();
    private static void EncodeString(StringBuilder builder, string value);
    private static string NormalizeWithForwardSlash(string p);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("31891ED8-BEB5-43BF-A90D-9E7E1CE9BA84")]
public interface Microsoft.CodeAnalysis.BuildTasks.IAnalyzerConfigFilesHostObject {
    public abstract virtual bool SetAnalyzerConfigFiles(ITaskItem[] analyzerConfigFiles);
    public abstract virtual bool SetPotentialAnalyzerConfigFiles(ITaskItem[] potentialAnalyzerConfigfiles);
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("117CC9AD-299A-4898-AAFD-8ADE0FE0A1EF")]
public interface Microsoft.CodeAnalysis.BuildTasks.ICompilerOptionsHostObject {
    public abstract virtual bool SetCompilerOptions(string compilerOptions);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("E113A674-3F6C-4514-B7AD-1E59226A1C50")]
public interface Microsoft.CodeAnalysis.BuildTasks.ICscHostObject5 {
    [NullableContextAttribute("2")]
public abstract virtual bool SetErrorLog(string errorLogFile);
    public abstract virtual bool SetReportAnalyzer(bool reportAnalyzerInDiagnosticOutput);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.BuildTasks.InteractiveCompiler : ManagedToolTask {
    [NullableAttribute("1")]
internal PropertyDictionary _store;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] AdditionalLibPaths { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] AdditionalLoadPaths { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputAttribute]
public ITaskItem[] CommandLineArgs { get; public set; }
    public string Features { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] Imports { get; public set; }
    public bool ProvideCommandLineArgs { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] References { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] ResponseFiles { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ScriptArguments { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] ScriptResponseFiles { get; public set; }
    public bool SkipInteractiveExecution { get; public set; }
    public ITaskItem Source { get; public set; }
    public void set_AdditionalLibPaths(String[] value);
    public String[] get_AdditionalLibPaths();
    public void set_AdditionalLoadPaths(String[] value);
    public String[] get_AdditionalLoadPaths();
    public void set_CommandLineArgs(ITaskItem[] value);
    public ITaskItem[] get_CommandLineArgs();
    public void set_Features(string value);
    public string get_Features();
    public void set_Imports(ITaskItem[] value);
    public ITaskItem[] get_Imports();
    public void set_ProvideCommandLineArgs(bool value);
    public bool get_ProvideCommandLineArgs();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_References();
    public void set_ResponseFiles(ITaskItem[] value);
    public ITaskItem[] get_ResponseFiles();
    public void set_ScriptArguments(String[] value);
    public String[] get_ScriptArguments();
    public void set_ScriptResponseFiles(ITaskItem[] value);
    public ITaskItem[] get_ScriptResponseFiles();
    public void set_SkipInteractiveExecution(bool value);
    public bool get_SkipInteractiveExecution();
    public void set_Source(ITaskItem value);
    public ITaskItem get_Source();
    [NullableContextAttribute("1")]
protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    [NullableContextAttribute("1")]
protected virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("10617623-DD4E-4E81-B4C3-46F55DC76E52")]
public interface Microsoft.CodeAnalysis.BuildTasks.IVbcHostObject6 {
    [NullableContextAttribute("2")]
public abstract virtual bool SetErrorLog(string errorLogFile);
    public abstract virtual bool SetReportAnalyzer(bool reportAnalyzerInDiagnosticOutput);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.BuildTasks.ManagedCompiler : ManagedToolTask {
    private CancellationTokenSource _sharedCompileCts;
    [NullableAttribute("1")]
internal PropertyDictionary _store;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsedCommandLineTool>k__BackingField;
    private bool _hostCompilerSupportsAllParameters;
    internal RequestLanguage Language { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] AdditionalLibPaths { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] AddModules { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] AdditionalFiles { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] EmbeddedFiles { get; public set; }
    public bool EmbedAllSources { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] Analyzers { get; public set; }
    public string ChecksumAlgorithm { get; public set; }
    public string CodeAnalysisRuleSet { get; public set; }
    public int CodePage { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputAttribute]
public ITaskItem[] CommandLineArgs { get; public set; }
    public string DebugType { get; public set; }
    public string SourceLink { get; public set; }
    public string DefineConstants { get; public set; }
    public bool DelaySign { get; public set; }
    public bool Deterministic { get; public set; }
    public bool PublicSign { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] AnalyzerConfigFiles { get; public set; }
    public bool EmitDebugInformation { get; public set; }
    public string ErrorLog { get; public set; }
    public string Features { get; public set; }
    public int FileAlignment { get; public set; }
    public string GeneratedFilesOutputPath { get; public set; }
    public bool HighEntropyVA { get; public set; }
    public string Instrument { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] LinkResources { get; public set; }
    public string MainEntryPoint { get; public set; }
    public bool NoConfig { get; public set; }
    public bool NoLogo { get; public set; }
    public bool NoWin32Manifest { get; public set; }
    public bool Optimize { get; public set; }
    [OutputAttribute]
public ITaskItem OutputAssembly { get; public set; }
    [OutputAttribute]
public ITaskItem OutputRefAssembly { get; public set; }
    public string Platform { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] PotentialAnalyzerConfigFiles { get; public set; }
    public bool Prefer32Bit { get; public set; }
    public string ProjectName { get; public set; }
    public bool ProvideCommandLineArgs { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] References { get; public set; }
    public bool RefOnly { get; public set; }
    public bool ReportAnalyzer { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] Resources { get; public set; }
    public string RuntimeMetadataVersion { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] ResponseFiles { get; public set; }
    public string SharedCompilationId { get; public set; }
    public bool SkipAnalyzers { get; public set; }
    public bool SkipCompilerExecution { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] Sources { get; public set; }
    public string SubsystemVersion { get; public set; }
    public string TargetFramework { get; public set; }
    public string TargetType { get; public set; }
    public bool TreatWarningsAsErrors { get; public set; }
    public bool Utf8Output { get; public set; }
    public string Win32Icon { get; public set; }
    public string Win32Manifest { get; public set; }
    public string Win32Resource { get; public set; }
    public string PathMap { get; public set; }
    public bool UseSharedCompilation { get; public set; }
    internal string PlatformWith32BitPreference { get; }
    [NullableAttribute("1")]
protected Encoding StandardOutputEncoding { get; }
    public string LangVersion { get; public set; }
    public bool ReportIVTs { get; public set; }
    [OutputAttribute]
public int ExitCode { get; private set; }
    protected bool UsedCommandLineTool { get; protected set; }
    protected bool HostCompilerSupportsAllParameters { get; protected set; }
    internal abstract virtual RequestLanguage get_Language();
    public void set_AdditionalLibPaths(String[] value);
    public String[] get_AdditionalLibPaths();
    public void set_AddModules(String[] value);
    public String[] get_AddModules();
    public void set_AdditionalFiles(ITaskItem[] value);
    public ITaskItem[] get_AdditionalFiles();
    public void set_EmbeddedFiles(ITaskItem[] value);
    public ITaskItem[] get_EmbeddedFiles();
    public void set_EmbedAllSources(bool value);
    public bool get_EmbedAllSources();
    public void set_Analyzers(ITaskItem[] value);
    public ITaskItem[] get_Analyzers();
    public void set_ChecksumAlgorithm(string value);
    public string get_ChecksumAlgorithm();
    public void set_CodeAnalysisRuleSet(string value);
    public string get_CodeAnalysisRuleSet();
    public void set_CodePage(int value);
    public int get_CodePage();
    public void set_CommandLineArgs(ITaskItem[] value);
    public ITaskItem[] get_CommandLineArgs();
    public void set_DebugType(string value);
    public string get_DebugType();
    public void set_SourceLink(string value);
    public string get_SourceLink();
    public void set_DefineConstants(string value);
    public string get_DefineConstants();
    public void set_DelaySign(bool value);
    public bool get_DelaySign();
    public void set_Deterministic(bool value);
    public bool get_Deterministic();
    public void set_PublicSign(bool value);
    public bool get_PublicSign();
    public void set_AnalyzerConfigFiles(ITaskItem[] value);
    public ITaskItem[] get_AnalyzerConfigFiles();
    public void set_EmitDebugInformation(bool value);
    public bool get_EmitDebugInformation();
    public void set_ErrorLog(string value);
    public string get_ErrorLog();
    public void set_Features(string value);
    public string get_Features();
    public void set_FileAlignment(int value);
    public int get_FileAlignment();
    public void set_GeneratedFilesOutputPath(string value);
    public string get_GeneratedFilesOutputPath();
    public void set_HighEntropyVA(bool value);
    public bool get_HighEntropyVA();
    public void set_Instrument(string value);
    public string get_Instrument();
    public void set_KeyContainer(string value);
    public string get_KeyContainer();
    public void set_KeyFile(string value);
    public string get_KeyFile();
    public void set_LinkResources(ITaskItem[] value);
    public ITaskItem[] get_LinkResources();
    public void set_MainEntryPoint(string value);
    public string get_MainEntryPoint();
    public void set_NoConfig(bool value);
    public bool get_NoConfig();
    public void set_NoLogo(bool value);
    public bool get_NoLogo();
    public void set_NoWin32Manifest(bool value);
    public bool get_NoWin32Manifest();
    public void set_Optimize(bool value);
    public bool get_Optimize();
    public void set_OutputAssembly(ITaskItem value);
    public ITaskItem get_OutputAssembly();
    public void set_OutputRefAssembly(ITaskItem value);
    public ITaskItem get_OutputRefAssembly();
    public void set_Platform(string value);
    public string get_Platform();
    public void set_PotentialAnalyzerConfigFiles(ITaskItem[] value);
    public ITaskItem[] get_PotentialAnalyzerConfigFiles();
    public void set_Prefer32Bit(bool value);
    public bool get_Prefer32Bit();
    public void set_ProjectName(string value);
    public string get_ProjectName();
    public void set_ProvideCommandLineArgs(bool value);
    public bool get_ProvideCommandLineArgs();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_References();
    public void set_RefOnly(bool value);
    public bool get_RefOnly();
    public void set_ReportAnalyzer(bool value);
    public bool get_ReportAnalyzer();
    public void set_Resources(ITaskItem[] value);
    public ITaskItem[] get_Resources();
    public void set_RuntimeMetadataVersion(string value);
    public string get_RuntimeMetadataVersion();
    public void set_ResponseFiles(ITaskItem[] value);
    public ITaskItem[] get_ResponseFiles();
    public void set_SharedCompilationId(string value);
    public string get_SharedCompilationId();
    public void set_SkipAnalyzers(bool value);
    public bool get_SkipAnalyzers();
    public void set_SkipCompilerExecution(bool value);
    public bool get_SkipCompilerExecution();
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_SubsystemVersion(string value);
    public string get_SubsystemVersion();
    public void set_TargetFramework(string value);
    public string get_TargetFramework();
    public void set_TargetType(string value);
    public string get_TargetType();
    public void set_TreatWarningsAsErrors(bool value);
    public bool get_TreatWarningsAsErrors();
    public void set_Utf8Output(bool value);
    public bool get_Utf8Output();
    public void set_Win32Icon(string value);
    public string get_Win32Icon();
    public void set_Win32Manifest(string value);
    public string get_Win32Manifest();
    public void set_Win32Resource(string value);
    public string get_Win32Resource();
    public void set_PathMap(string value);
    public string get_PathMap();
    public void set_UseSharedCompilation(bool value);
    public bool get_UseSharedCompilation();
    internal string get_PlatformWith32BitPreference();
    [NullableContextAttribute("1")]
protected virtual Encoding get_StandardOutputEncoding();
    public void set_LangVersion(string value);
    public string get_LangVersion();
    public void set_ReportIVTs(bool value);
    public bool get_ReportIVTs();
    [NullableContextAttribute("1")]
public string GeneratePathToTool();
    [NullableContextAttribute("1")]
protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    [NullableContextAttribute("1")]
internal int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands, ICompilerServerLogger logger);
    public virtual void Cancel();
    [NullableContextAttribute("1")]
private string CurrentDirectoryToUse();
    private string LibDirectoryToUse();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
private void set_ExitCode(int value);
    [NullableContextAttribute("1")]
private int HandleResponse(string requestId, BuildResponse response, string pathToTool, string responseFileCommands, string commandLineCommands, ICompilerServerLogger logger);
    [NullableContextAttribute("1")]
internal abstract virtual void LogCompilerOutput(string output, MessageImportance messageImportance);
    [NullableContextAttribute("1")]
private void LogCompilationMessage(ICompilerServerLogger logger, string requestId, CompilationKind kind, string diagnostic);
    [NullableContextAttribute("1")]
protected virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    [NullableContextAttribute("1")]
protected virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    [NullableContextAttribute("1")]
internal void AddResponseFileCommandsForSwitchesSinceInitialReleaseThatAreNeededByTheHost(CommandLineBuilderExtension commandLine);
    [NullableContextAttribute("1")]
internal static void AddFeatures(CommandLineBuilderExtension commandLine, string features);
    [NullableContextAttribute("1")]
internal static void AddAnalyzersToCommandLine(CommandLineBuilderExtension commandLine, ITaskItem[] analyzers);
    [NullableContextAttribute("1")]
private void AddAdditionalFilesToCommandLine(CommandLineBuilderExtension commandLine);
    [NullableContextAttribute("1")]
private void AddEmbeddedFilesToCommandLine(CommandLineBuilderExtension commandLine);
    [NullableContextAttribute("1")]
private void AddAnalyzerConfigFilesToCommandLine(CommandLineBuilderExtension commandLine);
    private void ConfigureDebugProperties();
    protected virtual bool HandleTaskExecutionErrors();
    private void NormalizePaths(ITaskItem[] taskItems);
    [CompilerGeneratedAttribute]
protected bool get_UsedCommandLineTool();
    [CompilerGeneratedAttribute]
protected void set_UsedCommandLineTool(bool value);
    protected bool get_HostCompilerSupportsAllParameters();
    protected void set_HostCompilerSupportsAllParameters(bool value);
    [NullableContextAttribute("1")]
protected void CheckHostObjectSupport(string parameterName, bool resultFromHostObjectSetOperation);
    [NullableContextAttribute("1")]
internal void InitializeHostObjectSupportForNewSwitches(ITaskHost hostObject, String& param);
    protected bool CheckAllReferencesExistOnDisk();
    internal string GetWin32ManifestSwitch(bool noDefaultWin32Manifest, string win32Manifest);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private string <ExecuteTool>g__getRequestId|195_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.BuildTasks.ManagedToolTask : ToolTask {
    protected bool IsManagedTool { get; }
    internal string PathToManagedTool { get; }
    private string PathToManagedToolWithoutExtension { get; }
    protected string ToolNameWithoutExtension { get; }
    protected string ToolName { get; }
    protected ManagedToolTask(ResourceManager resourceManager);
    protected bool get_IsManagedTool();
    internal string get_PathToManagedTool();
    private string get_PathToManagedToolWithoutExtension();
    internal string GenerateToolArguments();
    protected sealed virtual string GenerateCommandLineCommands();
    protected sealed virtual string GenerateResponseFileCommands();
    internal string GenerateCommandLineContents();
    internal string GenerateResponseFileContents();
    protected sealed virtual string GenerateFullPathToTool();
    protected abstract virtual string get_ToolNameWithoutExtension();
    protected abstract virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected abstract virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected sealed virtual string get_ToolName();
    protected List`1<string> GenerateCommandLineArgsList(string responseFileCommands);
    protected internal ITaskItem[] GenerateCommandLineArgsTaskItems(string responseFileCommands);
    protected static ITaskItem[] GenerateCommandLineArgsTaskItems(List`1<string> commandLineArgs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.MapSourceRoots : Task {
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceRoots>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ITaskItem[] <MappedSourceRoots>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SourceRoots { get; public set; }
    public bool Deterministic { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputAttribute]
public ITaskItem[] MappedSourceRoots { get; private set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceRoots();
    [CompilerGeneratedAttribute]
public void set_SourceRoots(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_MappedSourceRoots();
    [CompilerGeneratedAttribute]
private void set_MappedSourceRoots(ITaskItem[] value);
    private static string EnsureEndsWithSlash(string path);
    private static bool EndsWithDirectorySeparator(string path);
    public virtual bool Execute();
    private void ReportConflictingWellKnownMetadata(ITaskItem left, ITaskItem right);
    [CompilerGeneratedAttribute]
private void <Execute>g__setTopLevelMappedPaths|16_0(bool sourceControlled, <>c__DisplayClass16_0& , <>c__DisplayClass16_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.BuildTasks.MvidReader : object {
    private static Guid s_empty;
    private static MvidReader();
    public static Guid ReadAssemblyMvidOrEmpty(Stream stream);
    private static Guid ReadAssemblyMvidOrEmpty(BinaryReader reader);
    private static Guid FindMvidInSections(ushort count, BinaryReader reader);
    private static Guid ReadMvidSection(BinaryReader reader, UInt32 pointerToMvidSection);
    private static bool ReadUInt16(BinaryReader reader, UInt16& output);
    private static bool ReadUInt32(BinaryReader reader, UInt32& output);
    private static bool ReadBytes(BinaryReader reader, int count, Byte[]& output);
    private static bool Skip(int bytes, BinaryReader reader);
    private static bool MoveTo(UInt32 position, BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.BuildTasks.PropertyDictionary : Dictionary`2<string, object> {
    [NullableAttribute("2")]
public object Item { get; public set; }
    public T GetOrDefault(string name, T default);
    public object get_Item(string name);
    public void set_Item(string name, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.BuildTasks.RCWForCurrentContext`1 : object {
    [NullableAttribute("2")]
private T _rcwForCurrentCtx;
    private bool _shouldReleaseRCW;
    public T RCW { get; }
    public RCWForCurrentContext`1(T rcw);
    protected virtual override void Finalize();
    public T get_RCW();
    public sealed virtual void Dispose();
    private void CleanupComObject();
}
public class Microsoft.CodeAnalysis.BuildTasks.ShowMessageForImplicitlySkipAnalyzers : Task {
    public virtual bool Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.BuildTasks.Utilities : object {
    public static string FixFilePath(string path);
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName);
    internal static bool ConvertStringToBool(string parameterValue);
    internal static bool CanConvertStringToBool(string parameterValue);
    private static bool ValidBooleanTrue(string parameterValue);
    private static bool ValidBooleanFalse(string parameterValue);
    internal static string GetFullPathNoThrow(string path);
    internal static void DeleteNoThrow(string path);
    internal static bool IsIoRelatedException(Exception e);
    internal static Exception GetLocalizedArgumentException(Exception e, string errorString, Object[] args);
    internal static Exception GetLocalizedArgumentException(string errorString, Object[] args);
    internal static string TryGetAssemblyPath(Assembly assembly);
    internal static string GenerateFullPathToTool(string toolFileName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.BuildTasks.Vbc : ManagedCompiler {
    private bool _useHostCompilerIfAvailable;
    [NullableAttribute("1")]
private Queue`1<VBError> _vbErrorLines;
    private bool _isDoneOutputtingErrorMessage;
    private int _numberOfLinesInErrorMessage;
    [NullableAttribute("1")]
private static String[] s_separator;
    internal RequestLanguage Language { get; }
    public string BaseAddress { get; public set; }
    public string DisabledWarnings { get; public set; }
    public bool DisableSdkPath { get; public set; }
    public string DocumentationFile { get; public set; }
    public string ErrorReport { get; public set; }
    public bool GenerateDocumentation { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ITaskItem[] Imports { get; public set; }
    public string ModuleAssemblyName { get; public set; }
    public bool NoStandardLib { get; public set; }
    public bool NoVBRuntimeReference { get; public set; }
    public bool NoWarnings { get; public set; }
    public string OptionCompare { get; public set; }
    public bool OptionExplicit { get; public set; }
    public bool OptionStrict { get; public set; }
    public bool OptionInfer { get; public set; }
    public string OptionStrictType { get; public set; }
    public bool RemoveIntegerChecks { get; public set; }
    public string RootNamespace { get; public set; }
    public string SdkPath { get; public set; }
    public string PreferredUILang { get; public set; }
    public string VsSessionGuid { get; public set; }
    public bool TargetCompactFramework { get; public set; }
    public bool UseHostCompilerIfAvailable { get; public set; }
    public string VBRuntimePath { get; public set; }
    public string Verbosity { get; public set; }
    public string WarningsAsErrors { get; public set; }
    public string WarningsNotAsErrors { get; public set; }
    public string VBRuntime { get; public set; }
    public string PdbFile { get; public set; }
    [NullableAttribute("1")]
protected string ToolNameWithoutExtension { get; }
    private static Vbc();
    internal virtual RequestLanguage get_Language();
    public void set_BaseAddress(string value);
    public string get_BaseAddress();
    public void set_DisabledWarnings(string value);
    public string get_DisabledWarnings();
    public void set_DisableSdkPath(bool value);
    public bool get_DisableSdkPath();
    public void set_DocumentationFile(string value);
    public string get_DocumentationFile();
    public void set_ErrorReport(string value);
    public string get_ErrorReport();
    public void set_GenerateDocumentation(bool value);
    public bool get_GenerateDocumentation();
    public void set_Imports(ITaskItem[] value);
    public ITaskItem[] get_Imports();
    public void set_ModuleAssemblyName(string value);
    public string get_ModuleAssemblyName();
    public void set_NoStandardLib(bool value);
    public bool get_NoStandardLib();
    public void set_NoVBRuntimeReference(bool value);
    public bool get_NoVBRuntimeReference();
    public void set_NoWarnings(bool value);
    public bool get_NoWarnings();
    public void set_OptionCompare(string value);
    public string get_OptionCompare();
    public void set_OptionExplicit(bool value);
    public bool get_OptionExplicit();
    public void set_OptionStrict(bool value);
    public bool get_OptionStrict();
    public void set_OptionInfer(bool value);
    public bool get_OptionInfer();
    public void set_OptionStrictType(string value);
    public string get_OptionStrictType();
    public void set_RemoveIntegerChecks(bool value);
    public bool get_RemoveIntegerChecks();
    public void set_RootNamespace(string value);
    public string get_RootNamespace();
    public void set_SdkPath(string value);
    public string get_SdkPath();
    public void set_PreferredUILang(string value);
    public string get_PreferredUILang();
    public void set_VsSessionGuid(string value);
    public string get_VsSessionGuid();
    public void set_TargetCompactFramework(bool value);
    public bool get_TargetCompactFramework();
    public void set_UseHostCompilerIfAvailable(bool value);
    public bool get_UseHostCompilerIfAvailable();
    public void set_VBRuntimePath(string value);
    public string get_VBRuntimePath();
    public void set_Verbosity(string value);
    public string get_Verbosity();
    public void set_WarningsAsErrors(string value);
    public string get_WarningsAsErrors();
    public void set_WarningsNotAsErrors(string value);
    public string get_WarningsNotAsErrors();
    public void set_VBRuntime(string value);
    public string get_VBRuntime();
    public void set_PdbFile(string value);
    public string get_PdbFile();
    [NullableContextAttribute("1")]
internal virtual void LogCompilerOutput(string output, MessageImportance messageImportance);
    [NullableContextAttribute("1")]
protected virtual string get_ToolNameWithoutExtension();
    public virtual bool Execute();
    internal void MovePdbFileIfNecessary(string outputAssembly);
    internal string GetBaseAddressInHex();
    [NullableContextAttribute("1")]
protected virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    [NullableContextAttribute("1")]
private void AddReferencesToCommandLine(CommandLineBuilderExtension commandLine);
    protected virtual bool ValidateParameters();
    [NullableContextAttribute("1")]
protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    [NullableContextAttribute("1")]
private void ParseVBErrorOrWarning(string singleLine, MessageImportance messageImportance);
    internal static string GetDefineConstantsSwitch(string originalDefineConstants);
    [NullableContextAttribute("1")]
private bool InitializeHostCompiler(IVbcHostObject vbcHostObject);
    [NullableContextAttribute("1")]
private static bool DeferToICompilerOptionsHostObject(string langVersion, IVbcHostObject vbcHostObject);
    protected virtual HostObjectInitializationStatus InitializeHostObject();
    protected virtual bool CallHostObjectToExecute();
}
internal class Microsoft.CodeAnalysis.CommandLine.<BuildProtocol>F8271E8AE89A2C907DE3408139AD3133781C41781E59512107BFAD57B38332113__MismatchedVersionBuildResponse : BuildResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    [NullableContextAttribute("1")]
protected virtual void AddResponseBody(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.AnalyzerInconsistencyBuildResponse : BuildResponse {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ErrorMessages>k__BackingField;
    public ResponseType Type { get; }
    public ReadOnlyCollection`1<string> ErrorMessages { get; }
    public AnalyzerInconsistencyBuildResponse(ReadOnlyCollection`1<string> errorMessages);
    public virtual ResponseType get_Type();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ErrorMessages();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static AnalyzerInconsistencyBuildResponse Create(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CommandLine.BuildProtocolConstants : object {
    public static string ReadLengthPrefixedString(BinaryReader reader);
    public static void WriteLengthPrefixedString(BinaryWriter writer, string value);
    [NullableContextAttribute("2")]
public static string GetCommitHash();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildProtocolConstants/<ReadAllAsync>d__4")]
internal static Task ReadAllAsync(Stream stream, Byte[] buffer, int count, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.BuildRequest : object {
    private static int MaximumRequestSize;
    public string RequestId;
    public RequestLanguage Language;
    public ReadOnlyCollection`1<Argument> Arguments;
    public string CompilerHash;
    public BuildRequest(RequestLanguage language, string compilerHash, IEnumerable`1<Argument> arguments, string requestId);
    public static BuildRequest Create(RequestLanguage language, IList`1<string> args, string workingDirectory, string tempDirectory, string compilerHash, string requestId, string keepAlive, string libDirectory);
    public static BuildRequest CreateShutdown();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildRequest/<ReadAsync>d__8")]
public static Task`1<BuildRequest> ReadAsync(Stream inStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildRequest/<WriteAsync>d__9")]
public Task WriteAsync(Stream outStream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CommandLine.BuildResponse : object {
    public ResponseType Type { get; }
    public abstract virtual ResponseType get_Type();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildResponse/<WriteAsync>d__3")]
public Task WriteAsync(Stream outStream, CancellationToken cancellationToken);
    protected abstract virtual void AddResponseBody(BinaryWriter writer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildResponse/<ReadAsync>d__5")]
public static Task`1<BuildResponse> ReadAsync(Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.BuildServerConnection : object {
    internal static int TimeOutMsExistingProcess;
    internal static int TimeOutMsNewProcess;
    private static string GlobalMutexPrefix;
    internal static bool IsCompilerServerSupported { get; }
    internal static bool get_IsCompilerServerSupported();
    internal static BuildRequest CreateBuildRequest(string requestId, RequestLanguage language, List`1<string> arguments, string workingDirectory, string tempDirectory, string keepAlive, string libDirectory);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<RunServerShutdownRequestAsync>d__6")]
internal static Task`1<bool> RunServerShutdownRequestAsync(string pipeName, Nullable`1<int> timeoutOverride, bool waitForProcess, ICompilerServerLogger logger, CancellationToken cancellationToken);
    internal static Task`1<BuildResponse> RunServerBuildRequestAsync(BuildRequest buildRequest, string pipeName, string clientDirectory, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<RunServerBuildRequestAsync>d__8")]
internal static Task`1<BuildResponse> RunServerBuildRequestAsync(BuildRequest buildRequest, string pipeName, Nullable`1<int> timeoutOverride, Func`3<string, ICompilerServerLogger, bool> tryCreateServerFunc, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<MonitorDisconnectAsync>d__9")]
internal static Task MonitorDisconnectAsync(PipeStream pipeStream, string requestId, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<TryConnectToServerAsync>d__10")]
internal static Task`1<NamedPipeClientStream> TryConnectToServerAsync(string pipeName, int timeoutMs, ICompilerServerLogger logger, CancellationToken cancellationToken);
    internal static ValueTuple`3<string, string, string> GetServerProcessInfo(string clientDir, string pipeName);
    internal static bool TryCreateServer(string clientDirectory, string pipeName, ICompilerServerLogger logger, Int32& processId);
    internal static string GetPipeName(string clientDirectory);
    internal static string GetPipeName(string userName, bool isAdmin, string clientDirectory);
    internal static bool WasServerMutexOpen(string mutexName);
    internal static IServerMutex OpenOrCreateMutex(string name, Boolean& createdNew);
    internal static string GetServerMutexName(string pipeName);
    internal static string GetClientMutexName(string pipeName);
    [NullableContextAttribute("2")]
internal static string GetTempPath(string workingDir);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <RunServerShutdownRequestAsync>g__wasServerRunning|6_0(string pipeName);
    [CompilerGeneratedAttribute]
internal static Task`1<NamedPipeClientStream> <RunServerBuildRequestAsync>g__tryConnectToServerAsync|8_0(string pipeName, Nullable`1<int> timeoutOverride, ICompilerServerLogger logger, Func`3<string, ICompilerServerLogger, bool> tryCreateServerFunc, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<<RunServerBuildRequestAsync>g__tryRunRequestAsync|8_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<BuildResponse> <RunServerBuildRequestAsync>g__tryRunRequestAsync|8_1(NamedPipeClientStream pipeStream, BuildRequest request, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetTempPath>g__getTempPathLinux|19_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetTempPath>g__getTempPathWindows|19_1(string workingDir);
}
internal class Microsoft.CodeAnalysis.CommandLine.CannotConnectResponse : BuildResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    [NullableContextAttribute("1")]
protected virtual void AddResponseBody(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.CompilerServerLogger : object {
    internal static string EnvironmentVariableName;
    internal static string LoggingPrefix;
    [NullableAttribute("2")]
private Stream _loggingStream;
    private string _identifier;
    public bool IsLogging { get; }
    public CompilerServerLogger(string identifier, string loggingFilePath);
    public sealed virtual bool get_IsLogging();
    public sealed virtual void Dispose();
    public sealed virtual void Log(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CommandLine.CompilerServerLoggerExtensions : object {
    [ExtensionAttribute]
internal static void Log(ICompilerServerLogger logger, string format, Object[] arguments);
    [ExtensionAttribute]
internal static void LogError(ICompilerServerLogger logger, string message);
    [ExtensionAttribute]
internal static void LogError(ICompilerServerLogger logger, string format, Object[] arguments);
    [ExtensionAttribute]
internal static void LogException(ICompilerServerLogger logger, Exception exception, string reason);
    [CompilerGeneratedAttribute]
internal static void <LogException>g__AppendException|3_0(Exception exception, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.CompletedBuildResponse : BuildResponse {
    public int ReturnCode;
    public bool Utf8Output;
    public string Output;
    public ResponseType Type { get; }
    [NullableContextAttribute("2")]
public CompletedBuildResponse(int returnCode, bool utf8output, string output);
    public virtual ResponseType get_Type();
    public static CompletedBuildResponse Create(BinaryReader reader);
    protected virtual void AddResponseBody(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CommandLine.ConsoleUtil : object {
    private static Encoding s_utf8Encoding;
    private static ConsoleUtil();
    internal static T RunWithUtf8Output(Func`2<TextWriter, T> func);
    internal static T RunWithUtf8Output(bool utf8Output, TextWriter textWriter, Func`2<TextWriter, T> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.EmptyCompilerServerLogger : object {
    [CompilerGeneratedAttribute]
private static EmptyCompilerServerLogger <Instance>k__BackingField;
    public static EmptyCompilerServerLogger Instance { get; }
    public bool IsLogging { get; }
    private static EmptyCompilerServerLogger();
    [CompilerGeneratedAttribute]
public static EmptyCompilerServerLogger get_Instance();
    public sealed virtual bool get_IsLogging();
    public sealed virtual void Log(string message);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CommandLine.ICompilerServerLogger {
    public bool IsLogging { get; }
    public abstract virtual bool get_IsLogging();
    public abstract virtual void Log(string message);
}
internal class Microsoft.CodeAnalysis.CommandLine.IncorrectHashBuildResponse : BuildResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    [NullableContextAttribute("1")]
protected virtual void AddResponseBody(BinaryWriter writer);
}
internal interface Microsoft.CodeAnalysis.CommandLine.IServerMutex {
    public bool IsDisposed { get; }
    public abstract virtual bool TryLock(int timeoutMs);
    public abstract virtual bool get_IsDisposed();
}
internal static class Microsoft.CodeAnalysis.CommandLine.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidIntPtr;
    internal static UInt32 NORMAL_PRIORITY_CLASS;
    internal static UInt32 CREATE_NO_WINDOW;
    internal static int STARTF_USESTDHANDLES;
    internal static int ERROR_SUCCESS;
    private static NativeMethods();
    internal static bool CloseHandle(IntPtr hObject);
    [NullableContextAttribute("1")]
internal static bool CreateProcess(string lpApplicationName, StringBuilder lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    internal static IntPtr GetCommandLine();
}
internal class Microsoft.CodeAnalysis.CommandLine.PROCESS_INFORMATION : ValueType {
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.RejectedBuildResponse : BuildResponse {
    public string Reason;
    public ResponseType Type { get; }
    public RejectedBuildResponse(string reason);
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static RejectedBuildResponse Create(BinaryReader reader);
}
internal enum Microsoft.CodeAnalysis.CommandLine.RequestLanguage : Enum {
    public int value__;
    public static RequestLanguage CSharpCompile;
    public static RequestLanguage VisualBasicCompile;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.ServerFileMutex : object {
    [NullableAttribute("2")]
public FileStream Stream;
    public string FilePath;
    public string GuardPath;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public ServerFileMutex(string name);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    internal static string GetMutexDirectory();
    internal FileStream LockGuard();
    internal bool TryLockFile();
    internal void UnlockFile();
    public sealed virtual bool TryLock(int timeoutMs);
    public bool CouldLock();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.CommandLine.ServerNamedMutex : object {
    [NullableAttribute("1")]
public Mutex Mutex;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocked>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool IsLocked { get; private set; }
    [NullableContextAttribute("1")]
public ServerNamedMutex(string mutexName, Boolean& createdNew);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLocked();
    [CompilerGeneratedAttribute]
private void set_IsLocked(bool value);
    [NullableContextAttribute("1")]
public static bool WasOpen(string mutexName);
    public sealed virtual bool TryLock(int timeoutMs);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.ShutdownBuildResponse : BuildResponse {
    public int ServerProcessId;
    public ResponseType Type { get; }
    public ShutdownBuildResponse(int serverProcessId);
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static ShutdownBuildResponse Create(BinaryReader reader);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.STARTUPINFO : ValueType {
    internal int cb;
    internal string lpReserved;
    internal string lpDesktop;
    internal string lpTitle;
    internal int dwX;
    internal int dwY;
    internal int dwXSize;
    internal int dwYSize;
    internal int dwXCountChars;
    internal int dwYCountChars;
    internal int dwFillAttribute;
    internal int dwFlags;
    internal short wShowWindow;
    internal short cbReserved2;
    internal IntPtr lpReserved2;
    internal IntPtr hStdInput;
    internal IntPtr hStdOutput;
    internal IntPtr hStdError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class Microsoft.CodeAnalysis.CommitHashAttribute : Attribute {
    internal string Hash;
    public CommitHashAttribute(string hash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.NamedPipeUtil : object {
    private static int PipeBufferSize;
    private static PipeOptions CurrentUserOption;
    private static string GetPipeNameOrPath(string pipeName);
    internal static NamedPipeClientStream CreateClient(string serverName, string pipeName, PipeDirection direction, PipeOptions options);
    internal static bool CheckClientElevationMatches(NamedPipeServerStream pipeStream);
    internal static NamedPipeServerStream CreateServer(string pipeName, Nullable`1<PipeDirection> pipeDirection);
    internal static bool CheckPipeConnectionOwnership(NamedPipeClientStream pipeStream);
    [NullableContextAttribute("2")]
internal static PipeSecurity CreatePipeSecurity();
    private static NamedPipeServerStream CreateServer(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<string, bool> <CheckClientElevationMatches>g__getIdentity|3_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RuntimeHostInfo : object {
    private static string DotNetHostPathEnvironmentName;
    internal static bool IsDesktopRuntime { get; }
    internal static bool IsCoreClrRuntime { get; }
    internal static bool get_IsDesktopRuntime();
    internal static ValueTuple`3<string, string, string> GetProcessInfo(string toolFilePathWithoutExtension, string commandLineArguments);
    internal static bool get_IsCoreClrRuntime();
    internal static string GetDotNetPathOrDefault();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CommandLineUtilities : object {
    public static List`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments);
    public static List`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments, Nullable`1& illegalChar);
    public static void SplitCommandLineIntoArguments(ReadOnlySpan`1<char> commandLine, bool removeHashComments, StringBuilder builder, List`1<string> list, Nullable`1& illegalChar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
internal static class Roslyn.Utilities.PlatformInformation : object {
    [SupportedOSPlatformGuardAttribute("windows")]
public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool IsUsingMonoRuntime { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
    public static bool get_IsUsingMonoRuntime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    [NullableContextAttribute("2")]
public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(T value);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void AssertOrFailFast(bool condition, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
internal static class Roslyn.Utilities.UnicodeCharacterUtilities : object {
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    [NullableContextAttribute("2")]
public static bool IsValidIdentifier(string name);
    private static bool IsLetterChar(UnicodeCategory cat);
    private static bool IsCombiningChar(UnicodeCategory cat);
    private static bool IsDecimalDigitChar(UnicodeCategory cat);
    private static bool IsConnectingChar(UnicodeCategory cat);
    internal static bool IsFormattingChar(char ch);
    private static bool IsFormattingChar(UnicodeCategory cat);
}
