internal class Microsoft.CodeAnalysis.CommandLine.<BuildProtocol>F8271E8AE89A2C907DE3408139AD3133781C41781E59512107BFAD57B38332113__MismatchedVersionBuildResponse : BuildResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    [NullableContextAttribute("1")]
protected virtual void AddResponseBody(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.AnalyzerInconsistencyBuildResponse : BuildResponse {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ErrorMessages>k__BackingField;
    public ResponseType Type { get; }
    public ReadOnlyCollection`1<string> ErrorMessages { get; }
    public AnalyzerInconsistencyBuildResponse(ReadOnlyCollection`1<string> errorMessages);
    public virtual ResponseType get_Type();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ErrorMessages();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static AnalyzerInconsistencyBuildResponse Create(BinaryReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.BuildClient : object {
    private ICompilerServerLogger _logger;
    private RequestLanguage _language;
    private CompileFunc _compileFunc;
    private CompileOnServerFunc _compileOnServerFunc;
    internal static bool IsRunningOnWindows { get; }
    internal BuildClient(ICompilerServerLogger logger, RequestLanguage language, CompileFunc compileFunc, CompileOnServerFunc compileOnServerFunc);
    internal static bool get_IsRunningOnWindows();
    public static string GetClientDirectory();
    [NullableContextAttribute("2")]
public static string GetSystemSdkDirectory();
    internal static int Run(IEnumerable`1<string> arguments, RequestLanguage language, CompileFunc compileFunc, CompileOnServerFunc compileOnServerFunc, ICompilerServerLogger logger);
    [NullableContextAttribute("2")]
internal RunCompilationResult RunCompilation(IEnumerable`1<string> originalArguments, BuildPaths buildPaths, TextWriter textWriter, string pipeName);
    public Task`1<RunCompilationResult> RunCompilationAsync(IEnumerable`1<string> originalArguments, BuildPaths buildPaths, TextWriter textWriter);
    private int RunLocalCompilation(String[] arguments, BuildPaths buildPaths, TextWriter textWriter);
    public static CompileOnServerFunc GetCompileOnServerFunc(ICompilerServerLogger logger);
    private Nullable`1<RunCompilationResult> RunServerCompilation(TextWriter textWriter, List`1<string> arguments, BuildPaths buildPaths, string libDirectory, string pipeName, string keepAlive);
    private static IEnumerable`1<string> GetCommandLineArgs(IEnumerable`1<string> args);
    private static bool UseNativeArguments();
    private static bool AreNamedPipesSupported();
    private static IEnumerable`1<string> GetCommandLineWindows(IEnumerable`1<string> args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CommandLine.BuildProtocolConstants : object {
    public static string ReadLengthPrefixedString(BinaryReader reader);
    public static void WriteLengthPrefixedString(BinaryWriter writer, string value);
    [NullableContextAttribute("2")]
public static string GetCommitHash();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildProtocolConstants/<ReadAllAsync>d__4")]
internal static Task ReadAllAsync(Stream stream, Byte[] buffer, int count, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.BuildRequest : object {
    private static int MaximumRequestSize;
    public string RequestId;
    public RequestLanguage Language;
    public ReadOnlyCollection`1<Argument> Arguments;
    public string CompilerHash;
    public BuildRequest(RequestLanguage language, string compilerHash, IEnumerable`1<Argument> arguments, string requestId);
    public static BuildRequest Create(RequestLanguage language, IList`1<string> args, string workingDirectory, string tempDirectory, string compilerHash, string requestId, string keepAlive, string libDirectory);
    public static BuildRequest CreateShutdown();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildRequest/<ReadAsync>d__8")]
public static Task`1<BuildRequest> ReadAsync(Stream inStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildRequest/<WriteAsync>d__9")]
public Task WriteAsync(Stream outStream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CommandLine.BuildResponse : object {
    public ResponseType Type { get; }
    public abstract virtual ResponseType get_Type();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildResponse/<WriteAsync>d__3")]
public Task WriteAsync(Stream outStream, CancellationToken cancellationToken);
    protected abstract virtual void AddResponseBody(BinaryWriter writer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildResponse/<ReadAsync>d__5")]
public static Task`1<BuildResponse> ReadAsync(Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.BuildServerConnection : object {
    internal static int TimeOutMsExistingProcess;
    internal static int TimeOutMsNewProcess;
    private static string GlobalMutexPrefix;
    internal static bool IsCompilerServerSupported { get; }
    internal static bool get_IsCompilerServerSupported();
    internal static BuildRequest CreateBuildRequest(string requestId, RequestLanguage language, List`1<string> arguments, string workingDirectory, string tempDirectory, string keepAlive, string libDirectory);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<RunServerShutdownRequestAsync>d__6")]
internal static Task`1<bool> RunServerShutdownRequestAsync(string pipeName, Nullable`1<int> timeoutOverride, bool waitForProcess, ICompilerServerLogger logger, CancellationToken cancellationToken);
    internal static Task`1<BuildResponse> RunServerBuildRequestAsync(BuildRequest buildRequest, string pipeName, string clientDirectory, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<RunServerBuildRequestAsync>d__8")]
internal static Task`1<BuildResponse> RunServerBuildRequestAsync(BuildRequest buildRequest, string pipeName, Nullable`1<int> timeoutOverride, Func`3<string, ICompilerServerLogger, bool> tryCreateServerFunc, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<MonitorDisconnectAsync>d__9")]
internal static Task MonitorDisconnectAsync(PipeStream pipeStream, string requestId, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<TryConnectToServerAsync>d__10")]
internal static Task`1<NamedPipeClientStream> TryConnectToServerAsync(string pipeName, int timeoutMs, ICompilerServerLogger logger, CancellationToken cancellationToken);
    internal static ValueTuple`3<string, string, string> GetServerProcessInfo(string clientDir, string pipeName);
    internal static bool TryCreateServer(string clientDirectory, string pipeName, ICompilerServerLogger logger, Int32& processId);
    internal static string GetPipeName(string clientDirectory);
    internal static string GetPipeName(string userName, bool isAdmin, string clientDirectory);
    internal static bool WasServerMutexOpen(string mutexName);
    internal static IServerMutex OpenOrCreateMutex(string name, Boolean& createdNew);
    internal static string GetServerMutexName(string pipeName);
    internal static string GetClientMutexName(string pipeName);
    [NullableContextAttribute("2")]
internal static string GetTempPath(string workingDir);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <RunServerShutdownRequestAsync>g__wasServerRunning|6_0(string pipeName);
    [CompilerGeneratedAttribute]
internal static Task`1<NamedPipeClientStream> <RunServerBuildRequestAsync>g__tryConnectToServerAsync|8_0(string pipeName, Nullable`1<int> timeoutOverride, ICompilerServerLogger logger, Func`3<string, ICompilerServerLogger, bool> tryCreateServerFunc, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CommandLine.BuildServerConnection/<<RunServerBuildRequestAsync>g__tryRunRequestAsync|8_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<BuildResponse> <RunServerBuildRequestAsync>g__tryRunRequestAsync|8_1(NamedPipeClientStream pipeStream, BuildRequest request, ICompilerServerLogger logger, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetTempPath>g__getTempPathLinux|19_0();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <GetTempPath>g__getTempPathWindows|19_1(string workingDir);
}
internal class Microsoft.CodeAnalysis.CommandLine.CannotConnectResponse : BuildResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    [NullableContextAttribute("1")]
protected virtual void AddResponseBody(BinaryWriter writer);
}
internal class Microsoft.CodeAnalysis.CommandLine.CompileFunc : MulticastDelegate {
    public CompileFunc(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual int Invoke(String[] arguments, BuildPaths buildPaths, TextWriter textWriter, IAnalyzerAssemblyLoader analyzerAssemblyLoader);
    public virtual IAsyncResult BeginInvoke(String[] arguments, BuildPaths buildPaths, TextWriter textWriter, IAnalyzerAssemblyLoader analyzerAssemblyLoader, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
internal class Microsoft.CodeAnalysis.CommandLine.CompileOnServerFunc : MulticastDelegate {
    public CompileOnServerFunc(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<BuildResponse> Invoke(BuildRequest buildRequest, string pipeName, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(BuildRequest buildRequest, string pipeName, CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<BuildResponse> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.CompilerServerLogger : object {
    internal static string EnvironmentVariableName;
    internal static string LoggingPrefix;
    [NullableAttribute("2")]
private Stream _loggingStream;
    private string _identifier;
    public bool IsLogging { get; }
    public CompilerServerLogger(string identifier, string loggingFilePath);
    public sealed virtual bool get_IsLogging();
    public sealed virtual void Dispose();
    public sealed virtual void Log(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CommandLine.CompilerServerLoggerExtensions : object {
    [ExtensionAttribute]
internal static void Log(ICompilerServerLogger logger, string format, Object[] arguments);
    [ExtensionAttribute]
internal static void LogError(ICompilerServerLogger logger, string message);
    [ExtensionAttribute]
internal static void LogError(ICompilerServerLogger logger, string format, Object[] arguments);
    [ExtensionAttribute]
internal static void LogException(ICompilerServerLogger logger, Exception exception, string reason);
    [CompilerGeneratedAttribute]
internal static void <LogException>g__AppendException|3_0(Exception exception, <>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.CompletedBuildResponse : BuildResponse {
    public int ReturnCode;
    public bool Utf8Output;
    public string Output;
    public ResponseType Type { get; }
    [NullableContextAttribute("2")]
public CompletedBuildResponse(int returnCode, bool utf8output, string output);
    public virtual ResponseType get_Type();
    public static CompletedBuildResponse Create(BinaryReader reader);
    protected virtual void AddResponseBody(BinaryWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CommandLine.ConsoleUtil : object {
    private static Encoding s_utf8Encoding;
    private static ConsoleUtil();
    internal static T RunWithUtf8Output(Func`2<TextWriter, T> func);
    internal static T RunWithUtf8Output(bool utf8Output, TextWriter textWriter, Func`2<TextWriter, T> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.EmptyCompilerServerLogger : object {
    [CompilerGeneratedAttribute]
private static EmptyCompilerServerLogger <Instance>k__BackingField;
    public static EmptyCompilerServerLogger Instance { get; }
    public bool IsLogging { get; }
    private static EmptyCompilerServerLogger();
    [CompilerGeneratedAttribute]
public static EmptyCompilerServerLogger get_Instance();
    public sealed virtual bool get_IsLogging();
    public sealed virtual void Log(string message);
}
internal class Microsoft.CodeAnalysis.CommandLine.ExitingTraceListener : TraceListener {
    [CompilerGeneratedAttribute]
private ICompilerServerLogger <Logger>k__BackingField;
    internal ICompilerServerLogger Logger { get; }
    internal ExitingTraceListener(ICompilerServerLogger logger);
    [CompilerGeneratedAttribute]
internal ICompilerServerLogger get_Logger();
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    internal static void Install(ICompilerServerLogger logger);
    private void Exit(string originalMessage);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CommandLine.ICompilerServerLogger {
    public bool IsLogging { get; }
    public abstract virtual bool get_IsLogging();
    public abstract virtual void Log(string message);
}
internal class Microsoft.CodeAnalysis.CommandLine.IncorrectHashBuildResponse : BuildResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    [NullableContextAttribute("1")]
protected virtual void AddResponseBody(BinaryWriter writer);
}
internal interface Microsoft.CodeAnalysis.CommandLine.IServerMutex {
    public bool IsDisposed { get; }
    public abstract virtual bool TryLock(int timeoutMs);
    public abstract virtual bool get_IsDisposed();
}
internal static class Microsoft.CodeAnalysis.CommandLine.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidIntPtr;
    internal static UInt32 NORMAL_PRIORITY_CLASS;
    internal static UInt32 CREATE_NO_WINDOW;
    internal static int STARTF_USESTDHANDLES;
    internal static int ERROR_SUCCESS;
    private static NativeMethods();
    internal static bool CloseHandle(IntPtr hObject);
    [NullableContextAttribute("1")]
internal static bool CreateProcess(string lpApplicationName, StringBuilder lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    internal static IntPtr GetCommandLine();
}
internal class Microsoft.CodeAnalysis.CommandLine.PROCESS_INFORMATION : ValueType {
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.RejectedBuildResponse : BuildResponse {
    public string Reason;
    public ResponseType Type { get; }
    public RejectedBuildResponse(string reason);
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static RejectedBuildResponse Create(BinaryReader reader);
}
internal enum Microsoft.CodeAnalysis.CommandLine.RequestLanguage : Enum {
    public int value__;
    public static RequestLanguage CSharpCompile;
    public static RequestLanguage VisualBasicCompile;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CommandLine.RunCompilationResult : ValueType {
    internal static RunCompilationResult Succeeded;
    internal static RunCompilationResult Failed;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RanOnServer>k__BackingField;
    internal int ExitCode { get; }
    internal bool RanOnServer { get; }
    internal RunCompilationResult(int exitCode, bool ranOnServer);
    private static RunCompilationResult();
    [CompilerGeneratedAttribute]
internal int get_ExitCode();
    [CompilerGeneratedAttribute]
internal bool get_RanOnServer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.ServerFileMutex : object {
    [NullableAttribute("2")]
public FileStream Stream;
    public string FilePath;
    public string GuardPath;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public bool IsDisposed { get; private set; }
    public ServerFileMutex(string name);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    internal static string GetMutexDirectory();
    internal FileStream LockGuard();
    internal bool TryLockFile();
    internal void UnlockFile();
    public sealed virtual bool TryLock(int timeoutMs);
    public bool CouldLock();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.CommandLine.ServerNamedMutex : object {
    [NullableAttribute("1")]
public Mutex Mutex;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocked>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool IsLocked { get; private set; }
    [NullableContextAttribute("1")]
public ServerNamedMutex(string mutexName, Boolean& createdNew);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLocked();
    [CompilerGeneratedAttribute]
private void set_IsLocked(bool value);
    [NullableContextAttribute("1")]
public static bool WasOpen(string mutexName);
    public sealed virtual bool TryLock(int timeoutMs);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.ShutdownBuildResponse : BuildResponse {
    public int ServerProcessId;
    public ResponseType Type { get; }
    public ShutdownBuildResponse(int serverProcessId);
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static ShutdownBuildResponse Create(BinaryReader reader);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CommandLine.STARTUPINFO : ValueType {
    internal int cb;
    internal string lpReserved;
    internal string lpDesktop;
    internal string lpTitle;
    internal int dwX;
    internal int dwY;
    internal int dwXSize;
    internal int dwYSize;
    internal int dwXCountChars;
    internal int dwYCountChars;
    internal int dwFillAttribute;
    internal int dwFlags;
    internal short wShowWindow;
    internal short cbReserved2;
    internal IntPtr lpReserved2;
    internal IntPtr hStdInput;
    internal IntPtr hStdOutput;
    internal IntPtr hStdError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CompilerServer.AnalyzerConsistencyChecker : object {
    public static bool Check(string baseDirectory, IEnumerable`1<CommandLineAnalyzerReference> analyzerReferences, IAnalyzerAssemblyLoaderInternal loader, ICompilerServerLogger logger);
    public static bool Check(string baseDirectory, IEnumerable`1<CommandLineAnalyzerReference> analyzerReferences, IAnalyzerAssemblyLoaderInternal loader, ICompilerServerLogger logger, List`1& errorMessages);
    private static bool CheckCore(string baseDirectory, IEnumerable`1<CommandLineAnalyzerReference> analyzerReferences, IAnalyzerAssemblyLoaderInternal loader, ICompilerServerLogger logger, List`1& errorMessages);
}
internal static class Microsoft.CodeAnalysis.CompilerServer.BuildProtocolUtil : object {
    [NullableContextAttribute("1")]
internal static RunRequest GetRunRequest(BuildRequest req);
    [NullableContextAttribute("2")]
internal static String[] GetCommandLineArguments(BuildRequest req, String& currentDirectory, String& tempDirectory, String& libDirectory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.BuildServerController : object {
    internal static string KeepAliveSettingName;
    private NameValueCollection _appSettings;
    private ICompilerServerLogger _logger;
    internal BuildServerController(NameValueCollection appSettings, ICompilerServerLogger logger);
    internal int Run(String[] args);
    internal Nullable`1<TimeSpan> GetKeepAliveTimeout();
    internal static IClientConnectionHost CreateClientConnectionHost(string pipeName, ICompilerServerLogger logger);
    internal static ICompilerServerHost CreateCompilerServerHost(ICompilerServerLogger logger);
    [NullableContextAttribute("2")]
private static string GetDefaultPipeName();
    [NullableContextAttribute("2")]
internal int RunServer(string pipeName, ICompilerServerHost compilerServerHost, IClientConnectionHost clientConnectionHost, IDiagnosticListener listener, Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal static int CreateAndRunServer(string pipeName, ICompilerServerHost compilerServerHost, IClientConnectionHost clientConnectionHost, IDiagnosticListener listener, Nullable`1<TimeSpan> keepAlive, NameValueCollection appSettings, ICompilerServerLogger logger, CancellationToken cancellationToken);
    internal int RunShutdown(string pipeName, Nullable`1<int> timeoutOverride, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.BuildServerController/<RunShutdownAsync>d__12")]
internal Task`1<int> RunShutdownAsync(string pipeName, bool waitForProcess, Nullable`1<int> timeoutOverride, CancellationToken cancellationToken);
    internal static bool ParseCommandLine(String[] args, String& pipeName, Boolean& shutdown);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.CachingMetadataReference : PortableExecutableReference {
    private static MetadataAndSymbolCache s_mdCache;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; }
    public CachingMetadataReference(string fullPath, MetadataReferenceProperties properties);
    private static CachingMetadataReference();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    protected virtual DocumentationProvider CreateDocumentationProvider();
    protected virtual Metadata GetMetadataImpl();
    protected virtual PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.ClientConnectionHandler : object {
    [CompilerGeneratedAttribute]
private ICompilerServerHost <CompilerServerHost>k__BackingField;
    internal ICompilerServerHost CompilerServerHost { get; }
    internal ICompilerServerLogger Logger { get; }
    internal ClientConnectionHandler(ICompilerServerHost compilerServerHost);
    [CompilerGeneratedAttribute]
internal ICompilerServerHost get_CompilerServerHost();
    internal ICompilerServerLogger get_Logger();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.ClientConnectionHandler/<ProcessAsync>d__6")]
internal Task`1<CompletionData> ProcessAsync(Task`1<IClientConnection> clientConnectionTask, bool allowCompilationRequests, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.ClientConnectionHandler/<WriteBuildResponseAsync>d__7")]
private Task`1<CompletionData> WriteBuildResponseAsync(IClientConnection clientConnection, string requestId, BuildResponse response, CompletionData completionData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.ClientConnectionHandler/<ProcessCompilationRequestAsync>d__8")]
private Task`1<CompletionData> ProcessCompilationRequestAsync(IClientConnection clientConnection, BuildRequest request, CancellationToken cancellationToken);
    private static Nullable`1<TimeSpan> CheckForNewKeepAlive(BuildRequest request);
    [CompilerGeneratedAttribute]
internal static Task`1<BuildResponse> <ProcessCompilationRequestAsync>g__ProcessCompilationRequestCoreAsync|8_0(ICompilerServerHost compilerServerHost, BuildRequest buildRequest, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.CompilerServerHost : object {
    [CompilerGeneratedAttribute]
private IAnalyzerAssemblyLoaderInternal <AnalyzerAssemblyLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`3<string, MetadataReferenceProperties, PortableExecutableReference> <SharedAssemblyReferenceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> <AssemblyReferenceProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientDirectory>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <SdkDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompilerServerLogger <Logger>k__BackingField;
    private GeneratorDriverCache _driverCache;
    public IAnalyzerAssemblyLoaderInternal AnalyzerAssemblyLoader { get; }
    public static Func`3<string, MetadataReferenceProperties, PortableExecutableReference> SharedAssemblyReferenceProvider { get; }
    private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> AssemblyReferenceProvider { get; }
    private string ClientDirectory { get; }
    [NullableAttribute("2")]
private string SdkDirectory { get; }
    public ICompilerServerLogger Logger { get; }
    internal CompilerServerHost(string clientDirectory, string sdkDirectory, ICompilerServerLogger logger);
    private static CompilerServerHost();
    [CompilerGeneratedAttribute]
public IAnalyzerAssemblyLoaderInternal get_AnalyzerAssemblyLoader();
    [CompilerGeneratedAttribute]
public static Func`3<string, MetadataReferenceProperties, PortableExecutableReference> get_SharedAssemblyReferenceProvider();
    [CompilerGeneratedAttribute]
private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> get_AssemblyReferenceProvider();
    [CompilerGeneratedAttribute]
private string get_ClientDirectory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private string get_SdkDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual ICompilerServerLogger get_Logger();
    [NullableContextAttribute("2")]
public bool TryCreateCompiler(RunRequest& request, BuildPaths buildPaths, CommonCompiler& compiler);
    public BuildResponse RunCompilation(RunRequest& request, CancellationToken cancellationToken);
    private sealed virtual override BuildResponse Microsoft.CodeAnalysis.CompilerServer.ICompilerServerHost.RunCompilation(RunRequest& modreq(System.Runtime.InteropServices.InAttribute) request, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CompilerServer.CompletionData : ValueType {
    [CompilerGeneratedAttribute]
private CompletionReason <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <NewKeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShutdownRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompletionData <RequestCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompletionData <RequestError>k__BackingField;
    internal CompletionReason Reason { get; }
    internal Nullable`1<TimeSpan> NewKeepAlive { get; }
    internal bool ShutdownRequest { get; }
    internal static CompletionData RequestCompleted { get; }
    internal static CompletionData RequestError { get; }
    internal CompletionData(CompletionReason reason, Nullable`1<TimeSpan> newKeepAlive, bool shutdownRequested);
    private static CompletionData();
    [CompilerGeneratedAttribute]
internal CompletionReason get_Reason();
    [CompilerGeneratedAttribute]
internal Nullable`1<TimeSpan> get_NewKeepAlive();
    [CompilerGeneratedAttribute]
internal bool get_ShutdownRequest();
    [CompilerGeneratedAttribute]
internal static CompletionData get_RequestCompleted();
    [CompilerGeneratedAttribute]
internal static CompletionData get_RequestError();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal enum Microsoft.CodeAnalysis.CompilerServer.CompletionReason : Enum {
    public int value__;
    public static CompletionReason RequestCompleted;
    public static CompletionReason RequestError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.CSharpCompilerServer : CSharpCompiler {
    private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> _metadataProvider;
    internal CSharpCompilerServer(Func`3<string, MetadataReferenceProperties, PortableExecutableReference> metadataProvider, String[] args, BuildPaths buildPaths, string libDirectory, IAnalyzerAssemblyLoader analyzerLoader, GeneratorDriverCache driverCache);
    internal CSharpCompilerServer(Func`3<string, MetadataReferenceProperties, PortableExecutableReference> metadataProvider, string responseFile, String[] args, BuildPaths buildPaths, string libDirectory, IAnalyzerAssemblyLoader analyzerLoader, GeneratorDriverCache driverCache);
    internal virtual Func`3<string, MetadataReferenceProperties, PortableExecutableReference> GetMetadataProvider();
}
internal class Microsoft.CodeAnalysis.CompilerServer.EmptyDiagnosticListener : object {
    public sealed virtual void UpdateKeepAlive(TimeSpan keepAlive);
    public sealed virtual void ConnectionReceived();
    public sealed virtual void ConnectionCompleted(CompletionData completionData);
    public sealed virtual void KeepAliveReached();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CompilerServer.IClientConnection {
    public Task DisconnectTask { get; }
    public abstract virtual Task get_DisconnectTask();
    public abstract virtual Task`1<BuildRequest> ReadBuildRequestAsync(CancellationToken cancellationToken);
    public abstract virtual Task WriteBuildResponseAsync(BuildResponse response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CompilerServer.IClientConnectionHost {
    public bool IsListening { get; }
    public abstract virtual bool get_IsListening();
    public abstract virtual void BeginListening();
    public abstract virtual Task`1<IClientConnection> GetNextClientConnectionAsync();
    public abstract virtual void EndListening();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CompilerServer.ICompilerServerHost {
    public ICompilerServerLogger Logger { get; }
    public abstract virtual ICompilerServerLogger get_Logger();
    public abstract virtual BuildResponse RunCompilation(RunRequest& modreq(System.Runtime.InteropServices.InAttribute) request, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CompilerServer.IDiagnosticListener {
    public abstract virtual void UpdateKeepAlive(TimeSpan keepAlive);
    public abstract virtual void ConnectionReceived();
    public abstract virtual void ConnectionCompleted(CompletionData completionData);
    public abstract virtual void KeepAliveReached();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.MemoryHelper : object {
    public int Length;
    public int PercentPhysicalUsed;
    public ulong MaxPhysical;
    public ulong AvailablePhysical;
    public ulong MaxPageFile;
    public ulong AvailablePageFile;
    public ulong MaxVirtual;
    public ulong AvailableVirtual;
    public ulong Reserved;
    public static bool IsMemoryAvailable(ICompilerServerLogger logger);
    private static bool GlobalMemoryStatusEx(MemoryHelper buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.MetadataAndSymbolCache : object {
    private static int CacheSize;
    private ConcurrentLruCache`2<FileKey, Metadata> _metadataCache;
    private ModuleMetadata CreateModuleMetadata(string path, bool prefetchEntireImage);
    private ImmutableArray`1<ModuleMetadata> GetAllModules(ModuleMetadata manifestModule, string assemblyDir);
    internal Metadata GetMetadata(string fullPath, MetadataReferenceProperties properties);
    private Nullable`1<FileKey> GetUniqueFileKey(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.NamedPipeClientConnection : object {
    [CompilerGeneratedAttribute]
private CancellationTokenSource <DisconnectCancellationTokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> <DisconnectTaskCompletionSource>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedPipeServerStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompilerServerLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private CancellationTokenSource DisconnectCancellationTokenSource { get; }
    private TaskCompletionSource`1<object> DisconnectTaskCompletionSource { get; }
    public NamedPipeServerStream Stream { get; }
    public ICompilerServerLogger Logger { get; }
    public bool IsDisposed { get; private set; }
    public Task DisconnectTask { get; }
    internal NamedPipeClientConnection(NamedPipeServerStream stream, ICompilerServerLogger logger);
    [CompilerGeneratedAttribute]
private CancellationTokenSource get_DisconnectCancellationTokenSource();
    [CompilerGeneratedAttribute]
private TaskCompletionSource`1<object> get_DisconnectTaskCompletionSource();
    [CompilerGeneratedAttribute]
public NamedPipeServerStream get_Stream();
    [CompilerGeneratedAttribute]
public ICompilerServerLogger get_Logger();
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual Task get_DisconnectTask();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.NamedPipeClientConnection/<ReadBuildRequestAsync>d__20")]
public sealed virtual Task`1<BuildRequest> ReadBuildRequestAsync(CancellationToken cancellationToken);
    public sealed virtual Task WriteBuildResponseAsync(BuildResponse response, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.NamedPipeClientConnectionHost : object {
    [NullableAttribute("2")]
private CancellationTokenSource _cancellationTokenSource;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task[] _listenTasks;
    [NullableAttribute("2")]
private AsyncQueue`1<ListenResult> _queue;
    [CompilerGeneratedAttribute]
private string <PipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICompilerServerLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListening>k__BackingField;
    public string PipeName { get; }
    public ICompilerServerLogger Logger { get; }
    public bool IsListening { get; private set; }
    internal NamedPipeClientConnectionHost(string pipeName, ICompilerServerLogger logger);
    [CompilerGeneratedAttribute]
public string get_PipeName();
    [CompilerGeneratedAttribute]
public ICompilerServerLogger get_Logger();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsListening();
    [CompilerGeneratedAttribute]
private void set_IsListening(bool value);
    public sealed virtual void BeginListening();
    public sealed virtual void EndListening();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.NamedPipeClientConnectionHost/<GetNextClientConnectionAsync>d__17")]
public sealed virtual Task`1<IClientConnection> GetNextClientConnectionAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.NamedPipeClientConnectionHost/<ListenCoreAsync>d__18")]
private static Task ListenCoreAsync(string pipeName, ICompilerServerLogger logger, AsyncQueue`1<ListenResult> queue, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private Task <BeginListening>b__15_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CompilerServer.RunRequest : ValueType {
    [CompilerGeneratedAttribute]
private string <RequestId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LibDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public string RequestId { get; }
    public string Language { get; }
    [NullableAttribute("2")]
public string WorkingDirectory { get; }
    [NullableAttribute("2")]
public string TempDirectory { get; }
    [NullableAttribute("2")]
public string LibDirectory { get; }
    public String[] Arguments { get; }
    public RunRequest(string requestId, string language, string workingDirectory, string tempDirectory, string libDirectory, String[] arguments);
    [CompilerGeneratedAttribute]
public string get_RequestId();
    [CompilerGeneratedAttribute]
public string get_Language();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_TempDirectory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LibDirectory();
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.ServerDispatcher : object {
    internal static TimeSpan DefaultServerKeepAlive;
    internal static TimeSpan GCTimeout;
    private ICompilerServerHost _compilerServerHost;
    private ICompilerServerLogger _logger;
    private IClientConnectionHost _clientConnectionHost;
    private IDiagnosticListener _diagnosticListener;
    private State _state;
    [NullableAttribute("2")]
private Task _timeoutTask;
    [NullableAttribute("2")]
private Task _gcTask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<IClientConnection> _listenTask;
    private List`1<Task`1<CompletionData>> _connectionList;
    private Nullable`1<TimeSpan> _keepAlive;
    private bool _keepAliveIsDefault;
    internal ServerDispatcher(ICompilerServerHost compilerServerHost, IClientConnectionHost clientConnectionHost, IDiagnosticListener diagnosticListener);
    private static ServerDispatcher();
    public void ListenAndDispatchConnections(Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
    public void ListenAndDispatchConnectionsCore(CancellationToken cancellationToken);
    private void CheckCompletedTasks(CancellationToken cancellationToken);
    private void WaitForAnyCompletion(CancellationToken cancellationToken);
    private void ChangeToShuttingDown(string reason);
    private void RunGC();
    private void MaybeCreateListenTask();
    private void MaybeCreateTimeoutTask();
    private void MaybeCreateGCTask();
    private void HandleCompletedConnections();
    private void ChangeKeepAlive(TimeSpan keepAlive);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CompilerServer.ServerDispatcher/<ProcessClientConnectionAsync>d__26")]
internal static Task`1<CompletionData> ProcessClientConnectionAsync(ICompilerServerHost compilerServerHost, Task`1<IClientConnection> clientStreamTask, bool allowCompilationRequests, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <WaitForAnyCompletion>g__AddNonNull|18_0(Task task, <>c__DisplayClass18_0& );
}
internal static class Microsoft.CodeAnalysis.CompilerServer.VBCSCompiler : object {
    [NullableContextAttribute("1")]
public static int Main(String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CompilerServer.VisualBasicCompilerServer : VisualBasicCompiler {
    private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> _metadataProvider;
    internal VisualBasicCompilerServer(Func`3<string, MetadataReferenceProperties, PortableExecutableReference> metadataProvider, String[] args, BuildPaths buildPaths, string libDirectory, IAnalyzerAssemblyLoader analyzerLoader, GeneratorDriverCache driverCache);
    internal VisualBasicCompilerServer(Func`3<string, MetadataReferenceProperties, PortableExecutableReference> metadataProvider, string responseFile, String[] args, BuildPaths buildPaths, string libDirectory, IAnalyzerAssemblyLoader analyzerLoader, GeneratorDriverCache driverCache);
    internal virtual Func`3<string, MetadataReferenceProperties, PortableExecutableReference> GetMetadataProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.NamedPipeUtil : object {
    private static int PipeBufferSize;
    private static PipeOptions CurrentUserOption;
    private static string GetPipeNameOrPath(string pipeName);
    internal static NamedPipeClientStream CreateClient(string serverName, string pipeName, PipeDirection direction, PipeOptions options);
    internal static bool CheckClientElevationMatches(NamedPipeServerStream pipeStream);
    internal static NamedPipeServerStream CreateServer(string pipeName, Nullable`1<PipeDirection> pipeDirection);
    internal static bool CheckPipeConnectionOwnership(NamedPipeClientStream pipeStream);
    [NullableContextAttribute("2")]
internal static PipeSecurity CreatePipeSecurity();
    private static NamedPipeServerStream CreateServer(string pipeName, PipeDirection direction, int maxNumberOfServerInstances, PipeTransmissionMode transmissionMode, PipeOptions options, int inBufferSize, int outBufferSize);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<string, bool> <CheckClientElevationMatches>g__getIdentity|3_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.RuntimeHostInfo : object {
    private static string DotNetHostPathEnvironmentName;
    internal static bool IsDesktopRuntime { get; }
    internal static bool IsCoreClrRuntime { get; }
    internal static bool get_IsDesktopRuntime();
    internal static ValueTuple`3<string, string, string> GetProcessInfo(string toolFilePathWithoutExtension, string commandLineArguments);
    internal static bool get_IsCoreClrRuntime();
    internal static string GetDotNetPathOrDefault();
}
