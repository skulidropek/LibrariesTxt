[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.AnalyzerOptionsExtensions : object {
    [ExtensionAttribute]
public static string GetMSBuildPropertyValue(AnalyzerOptions options, string optionName, Compilation compilation);
    [ExtensionAttribute]
public static bool IsMSBuildPropertyValueTrue(AnalyzerOptions options, string propertyName, Compilation compilation);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.COMAnalyzer : DiagnosticAnalyzer {
    private static string StructLayoutAttribute;
    private static string DllImportAttribute;
    private static string MarshalAsAttribute;
    private static DiagnosticDescriptor s_correctnessOfCOMCannotBeGuaranteed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static COMAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    [CompilerGeneratedAttribute]
internal static bool <Initialize>g__IsComInterop|6_1(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.RoslynAnalyzer.CompilationExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetBestTypeByMetadataName(Compilation compilation, string fullyQualifiedMetadataName);
    [ExtensionAttribute]
private static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
internal static bool HasAttributeSuffix(string name, bool isCaseSensitive);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(ReadOnlySpan`1<T> span);
    [ExtensionAttribute]
public static SimpleNameSyntax GetUnqualifiedName(NameSyntax name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.BlockProxy : ValueType {
    [CompilerGeneratedAttribute]
private BasicBlock <Block>k__BackingField;
    public BasicBlock Block { get; public set; }
    public BlockProxy(BasicBlock Block);
    [CompilerGeneratedAttribute]
public BasicBlock get_Block();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Block(BasicBlock value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(BlockProxy left, BlockProxy right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(BlockProxy left, BlockProxy right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(BlockProxy other);
    [CompilerGeneratedAttribute]
public void Deconstruct(BasicBlock& Block);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.CapturedReferenceValue : ValueType {
    public IOperation Reference;
    public CapturedReferenceValue(IOperation operation);
    public sealed virtual bool Equals(CapturedReferenceValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.DataFlow.ControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static BasicBlock EntryBlock(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static BasicBlock ExitBlock(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static IEnumerable`1<T> DescendantOperations(ControlFlowGraph cfg, OperationKind operationKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.ControlFlowGraphProxy : ValueType {
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    public ControlFlowGraph ControlFlowGraph { get; public set; }
    public IEnumerable`1<BlockProxy> Blocks { get; }
    public BlockProxy Entry { get; }
    public ControlFlowGraphProxy(ControlFlowGraph ControlFlowGraph);
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_ControlFlowGraph();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ControlFlowGraph(ControlFlowGraph value);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.ControlFlowGraphProxy/<get_Blocks>d__6")]
public sealed virtual IEnumerable`1<BlockProxy> get_Blocks();
    public sealed virtual BlockProxy get_Entry();
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.ControlFlowGraphProxy/<GetPredecessors>d__9")]
public sealed virtual IEnumerable`1<Predecessor<BlockProxy, RegionProxy>> GetPredecessors(BlockProxy block);
    public sealed virtual bool TryGetEnclosingTryOrCatchOrFilter(BlockProxy block, RegionProxy& tryOrCatchOrFilterRegion);
    public sealed virtual bool TryGetEnclosingTryOrCatchOrFilter(RegionProxy regionProxy, RegionProxy& tryOrCatchOrFilterRegion);
    private static bool TryGetTryOrCatchOrFilter(ControlFlowRegion region, RegionProxy& tryOrCatchOrFilterRegion);
    public sealed virtual bool TryGetEnclosingFinally(BlockProxy block, RegionProxy& catchRegion);
    public sealed virtual RegionProxy GetCorrespondingTry(RegionProxy catchOrFilterOrFinallyRegion);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.ControlFlowGraphProxy/<GetPreviousFilters>d__15")]
public sealed virtual IEnumerable`1<RegionProxy> GetPreviousFilters(RegionProxy catchOrFilterRegion);
    public sealed virtual bool HasFilter(RegionProxy catchRegion);
    public sealed virtual BlockProxy FirstBlock(RegionProxy region);
    public sealed virtual BlockProxy LastBlock(RegionProxy region);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ControlFlowGraphProxy left, ControlFlowGraphProxy right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ControlFlowGraphProxy left, ControlFlowGraphProxy right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ControlFlowGraphProxy other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ControlFlowGraph& ControlFlowGraph);
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder : object {
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetDynamicallyAccessedMembers>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetDynamicallyAccessedMembers(ITypeSymbol typeDefinition, DynamicallyAccessedMemberTypes memberTypes, bool declaredOnly);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetConstructorsOnType>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetConstructorsOnType(ITypeSymbol type, Func`2<IMethodSymbol, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetMethodsOnTypeHierarchy>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<IMethodSymbol> GetMethodsOnTypeHierarchy(ITypeSymbol thisType, Func`2<IMethodSymbol, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetFieldsOnTypeHierarchy>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<IFieldSymbol> GetFieldsOnTypeHierarchy(ITypeSymbol thisType, Func`2<IFieldSymbol, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetNestedTypesOnType>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetNestedTypesOnType(ITypeSymbol type, Func`2<ITypeSymbol, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetPropertiesOnTypeHierarchy>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetPropertiesOnTypeHierarchy(ITypeSymbol thisType, Func`2<IPropertySymbol, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetEventsOnTypeHierarchy>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<IEventSymbol> GetEventsOnTypeHierarchy(ITypeSymbol thisType, Func`2<IEventSymbol, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DataFlow.DynamicallyAccessedMembersBinder/<GetAllInterfaceImplementations>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetAllInterfaceImplementations(ITypeSymbol thisType, bool declaredOnly);
    [ExtensionAttribute]
public static void GetAllOnType(ITypeSymbol type, bool declaredOnly, List`1<ISymbol> members);
    private static void GetAllOnType(ITypeSymbol type, bool declaredOnly, List`1<ISymbol> members, HashSet`1<ITypeSymbol> types);
}
public enum ILLink.RoslynAnalyzer.DataFlow.FlowCaptureKind : Enum {
    public int value__;
    public static FlowCaptureKind RValueCapture;
    public static FlowCaptureKind LValueCapture;
    public static FlowCaptureKind LValueAndRValueCapture;
}
public class ILLink.RoslynAnalyzer.DataFlow.InterproceduralState`2 : ValueType {
    public ValueSet`1<MethodBodyValue> Methods;
    public DefaultValueDictionary`2<LocalKey, Maybe`1<TValue>> HoistedLocals;
    private InterproceduralStateLattice`2<TValue, TValueLattice> lattice;
    public InterproceduralState`2(ValueSet`1<MethodBodyValue> methods, DefaultValueDictionary`2<LocalKey, Maybe`1<TValue>> hoistedLocals, InterproceduralStateLattice`2<TValue, TValueLattice> lattice);
    public sealed virtual bool Equals(InterproceduralState`2<TValue, TValueLattice> other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public InterproceduralState`2<TValue, TValueLattice> Clone();
    public void TrackMethod(MethodBodyValue method);
    public void TrackHoistedLocal(LocalKey key);
    public bool TrySetHoistedLocal(LocalKey key, TValue value);
    public bool TryGetHoistedLocal(LocalKey key, Nullable`1& value);
}
public class ILLink.RoslynAnalyzer.DataFlow.InterproceduralStateLattice`2 : ValueType {
    public ValueSetLattice`1<MethodBodyValue> MethodLattice;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DictionaryLattice`3<LocalKey, Maybe`1<TValue>, MaybeLattice`2<TValue, TValueLattice>> HoistedLocalLattice;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public InterproceduralState`2<TValue, TValueLattice> Top { get; }
    public InterproceduralStateLattice`2(ValueSetLattice`1<MethodBodyValue> methodLattice, DictionaryLattice`3<LocalKey, Maybe`1<TValue>, MaybeLattice`2<TValue, TValueLattice>> hoistedLocalLattice);
    public sealed virtual InterproceduralState`2<TValue, TValueLattice> get_Top();
    public sealed virtual InterproceduralState`2<TValue, TValueLattice> Meet(InterproceduralState`2<TValue, TValueLattice> left, InterproceduralState`2<TValue, TValueLattice> right);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class ILLink.RoslynAnalyzer.DataFlow.LocalDataFlowAnalysis`3 : ForwardDataFlowAnalysis`7<LocalState`1<TValue>, LocalDataFlowState`2<TValue, TLattice>, LocalStateLattice`2<TValue, TLattice>, BlockProxy, RegionProxy, ControlFlowGraphProxy, TTransfer> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected LocalStateLattice`2<TValue, TLattice> Lattice;
    protected OperationBlockAnalysisContext Context;
    private IOperation OperationBlock;
    [NullableContextAttribute("1")]
protected LocalDataFlowAnalysis`3(OperationBlockAnalysisContext context, IOperation operationBlock);
    public void InterproceduralAnalyze();
    private void AnalyzeMethod(MethodBodyValue method, InterproceduralState`2& interproceduralState);
    [NullableContextAttribute("1")]
protected abstract virtual TTransfer GetVisitor(IMethodSymbol method, ControlFlowGraph methodCFG, ImmutableDictionary`2<CaptureId, FlowCaptureKind> lValueFlowCaptures, InterproceduralState`2<TValue, TLattice> interproceduralState);
}
public class ILLink.RoslynAnalyzer.DataFlow.LocalDataFlowState`2 : object {
    private LocalState`1<TValue> current;
    [CompilerGeneratedAttribute]
private Box`1<LocalState`1<TValue>> <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalStateLattice`2<TValue, TValueLattice> <Lattice>k__BackingField;
    public LocalState`1<TValue> Current { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Box`1<LocalState`1<TValue>> Exception { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public LocalStateLattice`2<TValue, TValueLattice> Lattice { get; public set; }
    public sealed virtual LocalState`1<TValue> get_Current();
    public sealed virtual void set_Current(LocalState`1<TValue> value);
    [CompilerGeneratedAttribute]
public sealed virtual Box`1<LocalState`1<TValue>> get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exception(Box`1<LocalState`1<TValue>> value);
    [CompilerGeneratedAttribute]
public sealed virtual LocalStateLattice`2<TValue, TValueLattice> get_Lattice();
    [CompilerGeneratedAttribute]
public sealed virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Lattice(LocalStateLattice`2<TValue, TValueLattice> value);
    public void Set(LocalKey key, TValue value);
    public TValue Get(LocalKey key);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class ILLink.RoslynAnalyzer.DataFlow.LocalDataFlowVisitor`2 : OperationWalker`2<LocalDataFlowState`2<TValue, TValueLattice>, TValue> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected LocalStateLattice`2<TValue, TValueLattice> LocalStateLattice;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected InterproceduralStateLattice`2<TValue, TValueLattice> InterproceduralStateLattice;
    [NullableAttribute("1")]
protected IMethodSymbol Method;
    private ControlFlowGraph ControlFlowGraph;
    private ImmutableDictionary`2<CaptureId, FlowCaptureKind> lValueFlowCaptures;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public InterproceduralState`2<TValue, TValueLattice> InterproceduralState;
    protected TValue TopValue { get; }
    [NullableContextAttribute("1")]
public LocalDataFlowVisitor`2(LocalStateLattice`2<TValue, TValueLattice> lattice, IMethodSymbol method, ControlFlowGraph cfg, ImmutableDictionary`2<CaptureId, FlowCaptureKind> lValueFlowCaptures, InterproceduralState`2<TValue, TValueLattice> interproceduralState);
    protected TValue get_TopValue();
    private bool IsLValueFlowCapture(CaptureId captureId);
    private bool IsRValueFlowCapture(CaptureId captureId);
    public sealed virtual void Transfer(BlockProxy block, LocalDataFlowState`2<TValue, TValueLattice> state);
    public abstract virtual TValue GetFieldTargetValue(IFieldSymbol field);
    public abstract virtual TValue GetParameterTargetValue(IParameterSymbol parameter);
    public abstract virtual void HandleAssignment(TValue source, TValue target, IOperation operation);
    public abstract virtual TValue HandleArrayElementRead(TValue arrayValue, TValue indexValue, IOperation operation);
    public abstract virtual void HandleArrayElementWrite(TValue arrayValue, TValue indexValue, TValue valueToWrite, IOperation operation, bool merge);
    public abstract virtual void HandleReturnValue(TValue returnValue, IOperation operation);
    public abstract virtual TValue HandleMethodCall(IMethodSymbol calledMethod, TValue instance, ImmutableArray`1<TValue> arguments, IOperation operation);
    public virtual TValue VisitLocalReference(ILocalReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    private bool IsReferenceToCapturedVariable(ILocalReferenceOperation localReference);
    private TValue GetLocal(ILocalReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    private void SetLocal(ILocalReferenceOperation operation, TValue value, LocalDataFlowState`2<TValue, TValueLattice> state, bool merge);
    private TValue ProcessSingleTargetAssignment(IOperation targetOperation, ISimpleAssignmentOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state, bool merge);
    public virtual TValue VisitSimpleAssignment(ISimpleAssignmentOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    private TValue GetFlowCaptureValue(IFlowCaptureReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitFlowCapture(IFlowCaptureOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitExpressionStatement(IExpressionStatementOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitInvocation(IInvocationOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitPropertyReference(IPropertyReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitImplicitIndexerReference(IImplicitIndexerReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitArrayElementReference(IArrayElementReferenceOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitArgument(IArgumentOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitReturn(IReturnOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitConversion(IConversionOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitObjectCreation(IObjectCreationOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    public virtual TValue VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation, LocalDataFlowState`2<TValue, TValueLattice> state);
    private TValue ProcessMethodCall(IOperation operation, IMethodSymbol method, IOperation instance, ImmutableArray`1<IArgumentOperation> arguments, LocalDataFlowState`2<TValue, TValueLattice> state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.LocalKey : ValueType {
    private ILocalSymbol Local;
    private Nullable`1<CaptureId> CaptureId;
    public LocalKey(ILocalSymbol symbol);
    public LocalKey(CaptureId captureId);
    public sealed virtual bool Equals(LocalKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.RoslynAnalyzer.DataFlow.LocalState`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DefaultValueDictionary`2<LocalKey, TValue> Dictionary;
    [NullableAttribute("0")]
public DefaultValueDictionary`2<CaptureId, ValueSet`1<CapturedReferenceValue>> CapturedReferences;
    public LocalState`1(TValue defaultValue);
    [NullableContextAttribute("0")]
public LocalState`1(DefaultValueDictionary`2<LocalKey, TValue> dictionary, DefaultValueDictionary`2<CaptureId, ValueSet`1<CapturedReferenceValue>> capturedReferences);
    public LocalState`1(DefaultValueDictionary`2<LocalKey, TValue> dictionary);
    public sealed virtual bool Equals(LocalState`1<TValue> other);
    public virtual bool Equals(object obj);
    public TValue Get(LocalKey key);
    public virtual int GetHashCode();
    public void Set(LocalKey key, TValue value);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.LocalStateLattice`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DictionaryLattice`3<LocalKey, TValue, TValueLattice> Lattice;
    public DictionaryLattice`3<CaptureId, ValueSet`1<CapturedReferenceValue>, ValueSetLattice`1<CapturedReferenceValue>> CapturedReferenceLattice;
    [CompilerGeneratedAttribute]
private LocalState`1<TValue> <Top>k__BackingField;
    public LocalState`1<TValue> Top { get; }
    [NullableContextAttribute("1")]
public LocalStateLattice`2(TValueLattice valueLattice);
    [CompilerGeneratedAttribute]
public sealed virtual LocalState`1<TValue> get_Top();
    public sealed virtual LocalState`1<TValue> Meet(LocalState`1<TValue> left, LocalState`1<TValue> right);
}
internal static class ILLink.RoslynAnalyzer.DataFlow.LValueFlowCapturesProvider : object {
    private static bool IsLValueFlowCapture(IFlowCaptureReferenceOperation flowCaptureReference, IAssignmentOperation& assignment);
    public static ImmutableDictionary`2<CaptureId, FlowCaptureKind> CreateLValueFlowCaptures(ControlFlowGraph cfg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.MethodBodyValue : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowGraph <ControlFlowGraph>k__BackingField;
    public IMethodSymbol Method { get; }
    public ControlFlowGraph ControlFlowGraph { get; }
    public MethodBodyValue(IMethodSymbol method, ControlFlowGraph cfg);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public ControlFlowGraph get_ControlFlowGraph();
    public sealed virtual bool Equals(MethodBodyValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class ILLink.RoslynAnalyzer.DataFlow.OperationWalker`2 : OperationVisitor`2<TArgument, TResult> {
    private int _recursionDepth;
    private void VisitChildOperations(IOperation operation, TArgument argument);
    public virtual TResult Visit(IOperation operation, TArgument argument);
    [NullableContextAttribute("1")]
public virtual TResult DefaultVisit(IOperation operation, TArgument argument);
}
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.DataFlow.RegionProxy : ValueType {
    [CompilerGeneratedAttribute]
private ControlFlowRegion <Region>k__BackingField;
    [NullableAttribute("1")]
public ControlFlowRegion Region { get; public set; }
    public RegionKind Kind { get; }
    [NullableContextAttribute("1")]
public RegionProxy(ControlFlowRegion Region);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public ControlFlowRegion get_Region();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Region(ControlFlowRegion value);
    public sealed virtual RegionKind get_Kind();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RegionProxy left, RegionProxy right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RegionProxy left, RegionProxy right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RegionProxy other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void Deconstruct(ControlFlowRegion& Region);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class ILLink.RoslynAnalyzer.DiagnosticDescriptors : object {
    public static DiagnosticDescriptor GetDiagnosticDescriptor(DiagnosticId diagnosticId);
    public static DiagnosticDescriptor GetDiagnosticDescriptor(DiagnosticId diagnosticId, DiagnosticString diagnosticString);
    [NullableContextAttribute("2")]
public static DiagnosticDescriptor GetDiagnosticDescriptor(DiagnosticId diagnosticId, LocalizableResourceString lrsTitle, LocalizableResourceString lrsMessage, string diagnosticCategory, DiagnosticSeverity diagnosticSeverity, bool isEnabledByDefault, string helpLinkUri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.DynamicallyAccessedMembersAnalyzer : DiagnosticAnalyzer {
    internal static string DynamicallyAccessedMembers;
    internal static string DynamicallyAccessedMembersAttribute;
    public static string attributeArgument;
    public static string FullyQualifiedDynamicallyAccessedMembersAttribute;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public static ImmutableArray`1<DiagnosticDescriptor> GetSupportedDiagnostics();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private static Location GetPrimaryLocation(ImmutableArray`1<Location> locations);
    public virtual void Initialize(AnalysisContext context);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DynamicallyAccessedMembersAnalyzer/<ProcessMethodGenericParameters>d__9")]
private static IEnumerable`1<Diagnostic> ProcessMethodGenericParameters(IMethodSymbol methodSymbol, Location location);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.DynamicallyAccessedMembersAnalyzer/<ProcessGenericParameters>d__10")]
private static IEnumerable`1<Diagnostic> ProcessGenericParameters(ISymbol symbol, Location location);
    private static List`1<Diagnostic> GetDynamicallyAccessedMembersDiagnostics(SingleValue sourceValue, SingleValue targetValue, Location location);
    private static void VerifyMemberOnlyApplyToTypesOrStrings(SymbolAnalysisContext context, ISymbol member);
    private static void VerifyDamOnDerivedAndBaseMethodsMatch(SymbolAnalysisContext context, IMethodSymbol methodSymbol);
    private static void VerifyDamOnMethodsMatch(SymbolAnalysisContext context, IMethodSymbol overrideMethod, IMethodSymbol baseMethod);
    private static void VerifyDamOnInterfaceAndImplementationMethodsMatch(SymbolAnalysisContext context, INamedTypeSymbol type);
    private static void VerifyDamOnPropertyAndAccessorMatch(SymbolAnalysisContext context, IMethodSymbol methodSymbol);
    private static ValueTuple`2<IMethodSymbol, DynamicallyAccessedMemberTypes> GetTargetAndRequirements(IMethodSymbol method, IMethodSymbol overriddenMethod, DynamicallyAccessedMemberTypes methodAnnotation, DynamicallyAccessedMemberTypes overriddenMethodAnnotation);
    private static ValueTuple`2<Location[], Dictionary`2<string, string>> CreateArguments(Location attributableSymbolLocation, DynamicallyAccessedMemberTypes mismatchedArgument);
    [CompilerGeneratedAttribute]
internal static void <GetSupportedDiagnostics>g__AddRange|4_0(DiagnosticId first, DiagnosticId last, <>c__DisplayClass4_0& );
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSymbol method);
    [ExtensionAttribute]
public static ParameterProxyEnumerable GetParameters(IMethodSymbol method);
    [ExtensionAttribute]
public static ParameterProxyEnumerable GetMetadataParameters(IMethodSymbol method);
    [ExtensionAttribute]
public static ParameterProxy GetParameter(IMethodSymbol method, ParameterIndex index);
    [ExtensionAttribute]
public static Nullable`1<ParameterProxy> TryGetParameter(IMethodSymbol method, ParameterIndex index);
    [ExtensionAttribute]
public static int GetMetadataParametersCount(IMethodSymbol method);
    [ExtensionAttribute]
public static int GetParametersCount(IMethodSymbol method);
}
internal class ILLink.RoslynAnalyzer.ImmutableArrayOperations : object {
    internal static bool Contains(ImmutableArray`1<T> list, T elem, TComp comparer);
    internal static TSymbol TryGetSingleSymbol(ImmutableArray`1<ISymbol> members);
    internal static void AddIfNotNull(Builder<TSymbol> properties, TSymbol p);
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.INamedTypeSymbolExtensions : object {
    [ExtensionAttribute]
internal static bool HasName(INamedTypeSymbol type, string typeName);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.INamedTypeSymbolExtensions/<GetMemberInterfaceImplementationPairs>d__1")]
[ExtensionAttribute]
internal static IEnumerable`1<ValueTuple`2<ISymbol, ISymbol>> GetMemberInterfaceImplementationPairs(INamedTypeSymbol namedType);
    [IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.INamedTypeSymbolExtensions/<GetMatchingMembers>d__2")]
private static IEnumerable`1<ValueTuple`2<ISymbol, ISymbol>> GetMatchingMembers(INamedTypeSymbol implementationSymbol, INamedTypeSymbol interfaceSymbol);
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.IOperationExtensions : object {
    [ExtensionAttribute]
public static ValueUsageInfo GetValueUsageInfo(IOperation operation, ISymbol containingSymbol);
    [ExtensionAttribute]
public static RefKind GetRefKind(IReturnOperation operation, ISymbol containingSymbol);
    [ExtensionAttribute]
public static IMethodSymbol TryGetContainingAnonymousFunctionOrLocalFunction(IOperation operation);
    [ExtensionAttribute]
public static bool IsInLeftOfDeconstructionAssignment(IOperation operation, IDeconstructionAssignmentOperation& deconstructionAssignment);
    [ExtensionAttribute]
public static bool IsAnyCompoundAssignment(IOperation operation);
    [ExtensionAttribute]
public static ISymbol FindContainingSymbol(IOperation operation, ISymbol owningSymbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.RoslynAnalyzer.IPropertySymbolExtensions : object {
    [ExtensionAttribute]
public static IMethodSymbol GetGetMethod(IPropertySymbol property);
    [ExtensionAttribute]
public static IMethodSymbol GetSetMethod(IPropertySymbol property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.RoslynAnalyzer.ISymbolExtensions : object {
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <ILLinkTypeDisplayFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <ILLinkMemberDisplayFormat>k__BackingField;
    public static SymbolDisplayFormat ILLinkTypeDisplayFormat { get; }
    public static SymbolDisplayFormat ILLinkMemberDisplayFormat { get; }
    private static ISymbolExtensions();
    [ExtensionAttribute]
internal static bool HasAttribute(ISymbol symbol, string attributeName);
    [ExtensionAttribute]
internal static bool TryGetAttribute(ISymbol member, string attributeName, AttributeData& attribute);
    [ExtensionAttribute]
internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypes(ISymbol symbol);
    [ExtensionAttribute]
internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesOnReturnType(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
internal static bool TryGetReturnAttribute(IMethodSymbol member, string attributeName, AttributeData& attribute);
    [ExtensionAttribute]
internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesOnAssociatedSymbol(IMethodSymbol methodSymbol);
    [ExtensionAttribute]
internal static bool TryGetOverriddenMember(ISymbol symbol, ISymbol& overridenMember);
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_ILLinkTypeDisplayFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_ILLinkMemberDisplayFormat();
    [ExtensionAttribute]
public static string GetDisplayName(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsInterface(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsSubclassOf(ISymbol symbol, string ns, string type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStaticConstructor(ISymbol symbol);
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsTypeInterestingForDataflow(ITypeSymbol type);
    private static HierarchyFlags GetFlags(ITypeSymbol type);
    private static bool IsSystemType(HierarchyFlags flags);
    private static bool IsSystemReflectionIReflect(HierarchyFlags flags);
    [ExtensionAttribute]
public static bool IsTypeOf(ITypeSymbol symbol, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeOf(ITypeSymbol symbol, WellKnownType wellKnownType);
    [ExtensionAttribute]
public static Nullable`1<WellKnownType> TryGetWellKnownType(ITypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class ILLink.RoslynAnalyzer.MSBuildPropertyOptionNames : object {
    public static string EnableSingleFileAnalyzer;
    public static string IncludeAllContentForSelfExtract;
    public static string EnableTrimAnalyzer;
    public static string EnableAotAnalyzer;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ILLink.RoslynAnalyzer.RequiresAnalyzerBase : DiagnosticAnalyzer {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<Action`1<OperationAnalysisContext>, OperationKind[]>> <ExtraOperationActions>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<Action`1<SyntaxNodeAnalysisContext>, SyntaxKind[]>> <ExtraSyntaxNodeActions>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ValueTuple`2<Action`1<SymbolAnalysisContext>, SymbolKind[]>> <ExtraSymbolActions>k__BackingField;
    private protected string RequiresAttributeName { get; }
    private protected string RequiresAttributeFullyQualifiedName { get; }
    private protected DiagnosticTargets AnalyzerDiagnosticTargets { get; }
    private protected DiagnosticDescriptor RequiresDiagnosticRule { get; }
    private protected DiagnosticDescriptor RequiresAttributeMismatch { get; }
    private protected DiagnosticDescriptor RequiresOnStaticCtor { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected ImmutableArray`1<ValueTuple`2<Action`1<OperationAnalysisContext>, OperationKind[]>> ExtraOperationActions { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected ImmutableArray`1<ValueTuple`2<Action`1<SyntaxNodeAnalysisContext>, SyntaxKind[]>> ExtraSyntaxNodeActions { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected ImmutableArray`1<ValueTuple`2<Action`1<SymbolAnalysisContext>, SymbolKind[]>> ExtraSymbolActions { get; }
    private protected abstract virtual string get_RequiresAttributeName();
    private protected abstract virtual string get_RequiresAttributeFullyQualifiedName();
    private protected abstract virtual DiagnosticTargets get_AnalyzerDiagnosticTargets();
    private protected abstract virtual DiagnosticDescriptor get_RequiresDiagnosticRule();
    private protected abstract virtual DiagnosticDescriptor get_RequiresAttributeMismatch();
    private protected abstract virtual DiagnosticDescriptor get_RequiresOnStaticCtor();
    [CompilerGeneratedAttribute]
private protected virtual ImmutableArray`1<ValueTuple`2<Action`1<OperationAnalysisContext>, OperationKind[]>> get_ExtraOperationActions();
    [CompilerGeneratedAttribute]
private protected virtual ImmutableArray`1<ValueTuple`2<Action`1<SyntaxNodeAnalysisContext>, SyntaxKind[]>> get_ExtraSyntaxNodeActions();
    [CompilerGeneratedAttribute]
private protected virtual ImmutableArray`1<ValueTuple`2<Action`1<SymbolAnalysisContext>, SymbolKind[]>> get_ExtraSymbolActions();
    public virtual void Initialize(AnalysisContext context);
    protected static ISymbol FindContainingSymbol(OperationAnalysisContext operationContext, DiagnosticTargets targets);
    private void ReportRequiresDiagnostic(OperationAnalysisContext operationContext, ISymbol member, AttributeData requiresAttribute);
    private void ReportRequiresOnStaticCtorDiagnostic(SymbolAnalysisContext symbolAnalysisContext, IMethodSymbol ctor);
    private void ReportMismatchInAttributesDiagnostic(SymbolAnalysisContext symbolAnalysisContext, ISymbol member, ISymbol baseMember, bool isInterface);
    private bool HasMismatchingAttributes(ISymbol member1, ISymbol member2);
    protected abstract virtual string GetMessageFromAttribute(AttributeData requiresAttribute);
    public static string GetUrlFromAttribute(AttributeData requiresAttribute);
    protected abstract virtual bool VerifyAttributeArguments(AttributeData attribute);
    protected virtual bool ReportSpecialIncompatibleMembersDiagnostic(OperationAnalysisContext operationContext, ImmutableArray`1<ISymbol> specialIncompatibleMembers, ISymbol member);
    protected virtual ImmutableArray`1<ISymbol> GetSpecialIncompatibleMembers(Compilation compilation);
    protected abstract virtual bool IsAnalyzerEnabled(AnalyzerOptions options, Compilation compilation);
    [CompilerGeneratedAttribute]
private void <Initialize>b__21_0(CompilationStartAnalysisContext context);
    [CompilerGeneratedAttribute]
private void <Initialize>b__21_1(SymbolAnalysisContext symbolAnalysisContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__21_2(SymbolAnalysisContext symbolAnalysisContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__21_3(SymbolAnalysisContext symbolAnalysisContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__21_4(SymbolAnalysisContext symbolAnalysisContext);
    [CompilerGeneratedAttribute]
private void <Initialize>b__21_11(SyntaxNodeAnalysisContext syntaxNodeAnalysisContext);
    [CompilerGeneratedAttribute]
private void <Initialize>g__CheckCalledMember|21_12(OperationAnalysisContext operationContext, ISymbol member, ImmutableArray`1<ISymbol> incompatibleMembers);
    [CompilerGeneratedAttribute]
private void <Initialize>g__CheckMatchingAttributesInOverrides|21_13(SymbolAnalysisContext symbolAnalysisContext, ISymbol member);
    [CompilerGeneratedAttribute]
private void <Initialize>g__CheckMatchingAttributesInInterfaces|21_14(SymbolAnalysisContext symbolAnalysisContext, INamedTypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.RequiresAssemblyFilesAnalyzer : RequiresAnalyzerBase {
    private static string RequiresAssemblyFilesAttribute;
    public static string RequiresAssemblyFilesAttributeFullyQualifiedName;
    private static DiagnosticDescriptor s_locationRule;
    private static DiagnosticDescriptor s_getFilesRule;
    private static DiagnosticDescriptor s_requiresAssemblyFilesRule;
    private static DiagnosticDescriptor s_requiresAssemblyFilesAttributeMismatch;
    private static DiagnosticDescriptor s_requiresAssemblyFilesOnStaticCtor;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected string RequiresAttributeName { get; }
    private protected string RequiresAttributeFullyQualifiedName { get; }
    private protected DiagnosticTargets AnalyzerDiagnosticTargets { get; }
    private protected DiagnosticDescriptor RequiresDiagnosticRule { get; }
    private protected DiagnosticDescriptor RequiresAttributeMismatch { get; }
    private protected DiagnosticDescriptor RequiresOnStaticCtor { get; }
    private static RequiresAssemblyFilesAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected virtual string get_RequiresAttributeName();
    private protected virtual string get_RequiresAttributeFullyQualifiedName();
    private protected virtual DiagnosticTargets get_AnalyzerDiagnosticTargets();
    private protected virtual DiagnosticDescriptor get_RequiresDiagnosticRule();
    private protected virtual DiagnosticDescriptor get_RequiresAttributeMismatch();
    private protected virtual DiagnosticDescriptor get_RequiresOnStaticCtor();
    protected virtual bool IsAnalyzerEnabled(AnalyzerOptions options, Compilation compilation);
    protected virtual ImmutableArray`1<ISymbol> GetSpecialIncompatibleMembers(Compilation compilation);
    protected virtual bool ReportSpecialIncompatibleMembersDiagnostic(OperationAnalysisContext operationContext, ImmutableArray`1<ISymbol> dangerousPatterns, ISymbol member);
    protected virtual bool VerifyAttributeArguments(AttributeData attribute);
    protected virtual string GetMessageFromAttribute(AttributeData requiresAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.RequiresDynamicCodeAnalyzer : RequiresAnalyzerBase {
    private static string RequiresDynamicCodeAttribute;
    public static string FullyQualifiedRequiresDynamicCodeAttribute;
    private static DiagnosticDescriptor s_requiresDynamicCodeOnStaticCtor;
    private static DiagnosticDescriptor s_requiresDynamicCodeRule;
    private static DiagnosticDescriptor s_requiresDynamicCodeAttributeMismatch;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected string RequiresAttributeName { get; }
    private protected string RequiresAttributeFullyQualifiedName { get; }
    private protected DiagnosticTargets AnalyzerDiagnosticTargets { get; }
    private protected DiagnosticDescriptor RequiresDiagnosticRule { get; }
    private protected DiagnosticDescriptor RequiresAttributeMismatch { get; }
    private protected DiagnosticDescriptor RequiresOnStaticCtor { get; }
    private static RequiresDynamicCodeAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected virtual string get_RequiresAttributeName();
    private protected virtual string get_RequiresAttributeFullyQualifiedName();
    private protected virtual DiagnosticTargets get_AnalyzerDiagnosticTargets();
    private protected virtual DiagnosticDescriptor get_RequiresDiagnosticRule();
    private protected virtual DiagnosticDescriptor get_RequiresAttributeMismatch();
    private protected virtual DiagnosticDescriptor get_RequiresOnStaticCtor();
    protected virtual bool IsAnalyzerEnabled(AnalyzerOptions options, Compilation compilation);
    protected virtual bool VerifyAttributeArguments(AttributeData attribute);
    protected virtual string GetMessageFromAttribute(AttributeData requiresAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.RoslynAnalyzer.RequiresISymbolExtensions : object {
    [ExtensionAttribute]
public static bool DoesMemberRequire(ISymbol member, string requiresAttribute, AttributeData& requiresAttributeData);
    [ExtensionAttribute]
public static bool IsInRequiresScope(ISymbol member, string attributeName, AttributeData& requiresAttribute);
    [ExtensionAttribute]
public static bool IsOverrideInRequiresScope(ISymbol member, string requiresAttribute);
    [ExtensionAttribute]
private static bool IsInRequiresScope(ISymbol member, string attributeName, bool checkAssociatedSymbol, AttributeData& requiresAttribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.RequiresUnreferencedCodeAnalyzer : RequiresAnalyzerBase {
    public static string RequiresUnreferencedCodeAttribute;
    public static string FullyQualifiedRequiresUnreferencedCodeAttribute;
    private static DiagnosticDescriptor s_requiresUnreferencedCodeRule;
    private static DiagnosticDescriptor s_requiresUnreferencedCodeAttributeMismatch;
    private static DiagnosticDescriptor s_dynamicTypeInvocationRule;
    private static DiagnosticDescriptor s_makeGenericTypeRule;
    private static DiagnosticDescriptor s_makeGenericMethodRule;
    private static DiagnosticDescriptor s_requiresUnreferencedCodeOnStaticCtor;
    private static DiagnosticDescriptor s_typeDerivesFromRucClassRule;
    private static Action`1<OperationAnalysisContext> s_dynamicTypeInvocation;
    private Action`1<SymbolAnalysisContext> typeDerivesFromRucBase { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private protected string RequiresAttributeName { get; }
    private protected string RequiresAttributeFullyQualifiedName { get; }
    private protected DiagnosticTargets AnalyzerDiagnosticTargets { get; }
    private protected DiagnosticDescriptor RequiresDiagnosticRule { get; }
    private protected DiagnosticDescriptor RequiresAttributeMismatch { get; }
    private protected DiagnosticDescriptor RequiresOnStaticCtor { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected ImmutableArray`1<ValueTuple`2<Action`1<SymbolAnalysisContext>, SymbolKind[]>> ExtraSymbolActions { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private protected ImmutableArray`1<ValueTuple`2<Action`1<OperationAnalysisContext>, OperationKind[]>> ExtraOperationActions { get; }
    private static RequiresUnreferencedCodeAnalyzer();
    private Action`1<SymbolAnalysisContext> get_typeDerivesFromRucBase();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    private protected virtual string get_RequiresAttributeName();
    private protected virtual string get_RequiresAttributeFullyQualifiedName();
    private protected virtual DiagnosticTargets get_AnalyzerDiagnosticTargets();
    private protected virtual DiagnosticDescriptor get_RequiresDiagnosticRule();
    private protected virtual DiagnosticDescriptor get_RequiresAttributeMismatch();
    private protected virtual DiagnosticDescriptor get_RequiresOnStaticCtor();
    protected virtual bool IsAnalyzerEnabled(AnalyzerOptions options, Compilation compilation);
    protected virtual bool ReportSpecialIncompatibleMembersDiagnostic(OperationAnalysisContext operationContext, ImmutableArray`1<ISymbol> specialIncompatibleMembers, ISymbol member);
    private protected virtual ImmutableArray`1<ValueTuple`2<Action`1<SymbolAnalysisContext>, SymbolKind[]>> get_ExtraSymbolActions();
    private protected virtual ImmutableArray`1<ValueTuple`2<Action`1<OperationAnalysisContext>, OperationKind[]>> get_ExtraOperationActions();
    protected virtual bool VerifyAttributeArguments(AttributeData attribute);
    protected virtual string GetMessageFromAttribute(AttributeData requiresAttribute);
    [CompilerGeneratedAttribute]
private void <get_typeDerivesFromRucBase>b__11_0(SymbolAnalysisContext symbolAnalysisContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.RoslynAnalyzer.RequiresUnreferencedCodeUtils : object {
    private static string RequiresUnreferencedCodeAttribute;
    [ExtensionAttribute]
public static bool TryGetRequiresUnreferencedCodeAttribute(ISymbol member, AttributeData& requiresAttributeData);
    [ExtensionAttribute]
public static bool DoesMemberRequireUnreferencedCodeAttribute(ISymbol member, AttributeData& requiresAttributeData);
    [ExtensionAttribute]
public static bool IsInRequiresUnreferencedCodeAttributeScope(ISymbol member, AttributeData& requiresAttribute);
    public static bool VerifyRequiresUnreferencedCodeAttributeArguments(AttributeData attribute);
    public static string GetMessageFromAttribute(AttributeData requiresAttribute);
}
[IsReadOnlyAttribute]
internal class ILLink.RoslynAnalyzer.TrimAnalysis.ReflectionAccessAnalyzer : ValueType {
    internal void GetReflectionAccessDiagnostics(DiagnosticContext& diagnosticContext, ITypeSymbol typeSymbol, DynamicallyAccessedMemberTypes requiredMemberTypes, bool declaredOnly);
    internal void GetReflectionAccessDiagnosticsForEventsOnTypeHierarchy(DiagnosticContext& diagnosticContext, ITypeSymbol typeSymbol, string name, Nullable`1<BindingFlags> bindingFlags);
    internal void GetReflectionAccessDiagnosticsForFieldsOnTypeHierarchy(DiagnosticContext& diagnosticContext, ITypeSymbol typeSymbol, string name, Nullable`1<BindingFlags> bindingFlags);
    internal void GetReflectionAccessDiagnosticsForPropertiesOnTypeHierarchy(DiagnosticContext& diagnosticContext, ITypeSymbol typeSymbol, string name, Nullable`1<BindingFlags> bindingFlags);
    internal void GetReflectionAccessDiagnosticsForConstructorsOnType(DiagnosticContext& diagnosticContext, ITypeSymbol typeSymbol, Nullable`1<BindingFlags> bindingFlags, Nullable`1<int> parameterCount);
    internal void GetReflectionAccessDiagnosticsForPublicParameterlessConstructor(DiagnosticContext& diagnosticContext, ITypeSymbol typeSymbol);
    private static void ReportRequiresUnreferencedCodeDiagnostic(DiagnosticContext& diagnosticContext, AttributeData requiresAttributeData, ISymbol member);
    internal static void GetReflectionAccessDiagnosticsForMethod(DiagnosticContext& diagnosticContext, IMethodSymbol methodSymbol);
    internal static void GetReflectionAccessDiagnosticsForProperty(DiagnosticContext& diagnosticContext, IPropertySymbol propertySymbol);
    private static void GetDiagnosticsForEvent(DiagnosticContext& diagnosticContext, IEventSymbol eventSymbol);
    private static void GetDiagnosticsForField(DiagnosticContext& diagnosticContext, IFieldSymbol fieldSymbol);
}
public static class ILLink.RoslynAnalyzer.TrimAnalysis.SingleValueExtensions : object {
    [NullableContextAttribute("1")]
public static SingleValue FromTypeSymbol(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.TrimAnalysis.TrimAnalysisAssignmentPattern : ValueType {
    [CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Source { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Target { get; public set; }
    public IOperation Operation { get; public set; }
    public TrimAnalysisAssignmentPattern(ValueSet`1<SingleValue> source, ValueSet`1<SingleValue> target, IOperation operation);
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Target(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Target();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Operation(IOperation value);
    [CompilerGeneratedAttribute]
public IOperation get_Operation();
    public TrimAnalysisAssignmentPattern Merge(ValueSetLattice`1<SingleValue> lattice, TrimAnalysisAssignmentPattern other);
    public IEnumerable`1<Diagnostic> CollectDiagnostics();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrimAnalysisAssignmentPattern left, TrimAnalysisAssignmentPattern right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrimAnalysisAssignmentPattern left, TrimAnalysisAssignmentPattern right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrimAnalysisAssignmentPattern other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.TrimAnalysis.TrimAnalysisMethodCallPattern : ValueType {
    [CompilerGeneratedAttribute]
private IMethodSymbol <CalledMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ValueSet`1<SingleValue>> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <OwningSymbol>k__BackingField;
    public IMethodSymbol CalledMethod { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Instance { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueSet`1<SingleValue>> Arguments { get; public set; }
    public IOperation Operation { get; public set; }
    public ISymbol OwningSymbol { get; public set; }
    public TrimAnalysisMethodCallPattern(IMethodSymbol calledMethod, ValueSet`1<SingleValue> instance, ImmutableArray`1<ValueSet`1<SingleValue>> arguments, IOperation operation, ISymbol owningSymbol);
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CalledMethod(IMethodSymbol value);
    [CompilerGeneratedAttribute]
public IMethodSymbol get_CalledMethod();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Instance(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Instance();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Arguments(ImmutableArray`1<ValueSet`1<SingleValue>> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ValueSet`1<SingleValue>> get_Arguments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Operation(IOperation value);
    [CompilerGeneratedAttribute]
public IOperation get_Operation();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OwningSymbol(ISymbol value);
    [CompilerGeneratedAttribute]
public ISymbol get_OwningSymbol();
    public TrimAnalysisMethodCallPattern Merge(ValueSetLattice`1<SingleValue> lattice, TrimAnalysisMethodCallPattern other);
    public IEnumerable`1<Diagnostic> CollectDiagnostics();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrimAnalysisMethodCallPattern left, TrimAnalysisMethodCallPattern right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrimAnalysisMethodCallPattern left, TrimAnalysisMethodCallPattern right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrimAnalysisMethodCallPattern other);
}
[IsReadOnlyAttribute]
public class ILLink.RoslynAnalyzer.TrimAnalysis.TrimAnalysisPatternStore : ValueType {
    private Dictionary`2<ValueTuple`2<IOperation, bool>, TrimAnalysisAssignmentPattern> AssignmentPatterns;
    private Dictionary`2<IOperation, TrimAnalysisMethodCallPattern> MethodCallPatterns;
    private ValueSetLattice`1<SingleValue> Lattice;
    public TrimAnalysisPatternStore(ValueSetLattice`1<SingleValue> lattice);
    public void Add(TrimAnalysisAssignmentPattern trimAnalysisPattern, bool isReturnValue);
    public void Add(TrimAnalysisMethodCallPattern pattern);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("ILLink.RoslynAnalyzer.TrimAnalysis.TrimAnalysisPatternStore/<CollectDiagnostics>d__6")]
public IEnumerable`1<Diagnostic> CollectDiagnostics();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.TrimAnalysis.TrimAnalysisVisitor : LocalDataFlowVisitor`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> {
    public TrimAnalysisPatternStore TrimAnalysisPatterns;
    private ValueSetLattice`1<SingleValue> _multiValueLattice;
    private static int MaxTrackedArrayValues;
    public TrimAnalysisVisitor(LocalStateLattice`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> lattice, IMethodSymbol method, ControlFlowGraph methodCFG, ImmutableDictionary`2<CaptureId, FlowCaptureKind> lValueFlowCaptures, TrimAnalysisPatternStore trimAnalysisPatterns, InterproceduralState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> interproceduralState);
    [NullableContextAttribute("2")]
public virtual ValueSet`1<SingleValue> Visit(IOperation operation, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> argument);
    public virtual ValueSet`1<SingleValue> VisitArrayCreation(IArrayCreationOperation operation, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> state);
    public virtual ValueSet`1<SingleValue> VisitConversion(IConversionOperation operation, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> state);
    public virtual ValueSet`1<SingleValue> VisitParameterReference(IParameterReferenceOperation paramRef, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> state);
    public virtual ValueSet`1<SingleValue> VisitInstanceReference(IInstanceReferenceOperation instanceRef, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> state);
    public virtual ValueSet`1<SingleValue> VisitFieldReference(IFieldReferenceOperation fieldRef, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> state);
    public virtual ValueSet`1<SingleValue> VisitTypeOf(ITypeOfOperation typeOfOperation, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> state);
    public virtual ValueSet`1<SingleValue> VisitBinaryOperator(IBinaryOperation operation, LocalDataFlowState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> argument);
    public virtual ValueSet`1<SingleValue> GetFieldTargetValue(IFieldSymbol field);
    public virtual ValueSet`1<SingleValue> GetParameterTargetValue(IParameterSymbol parameter);
    public virtual void HandleAssignment(ValueSet`1<SingleValue> source, ValueSet`1<SingleValue> target, IOperation operation);
    public virtual ValueSet`1<SingleValue> HandleArrayElementRead(ValueSet`1<SingleValue> arrayValue, ValueSet`1<SingleValue> indexValue, IOperation operation);
    public virtual void HandleArrayElementWrite(ValueSet`1<SingleValue> arrayValue, ValueSet`1<SingleValue> indexValue, ValueSet`1<SingleValue> valueToWrite, IOperation operation, bool merge);
    public virtual ValueSet`1<SingleValue> HandleMethodCall(IMethodSymbol calledMethod, ValueSet`1<SingleValue> instance, ImmutableArray`1<ValueSet`1<SingleValue>> arguments, IOperation operation);
    public virtual void HandleReturnValue(ValueSet`1<SingleValue> returnValue, IOperation operation);
    private static bool TryGetConstantValue(IOperation operation, ValueSet`1& constValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class ILLink.RoslynAnalyzer.TrimAnalysis.TrimDataFlowAnalysis : LocalDataFlowAnalysis`3<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>, TrimAnalysisVisitor> {
    [CompilerGeneratedAttribute]
private TrimAnalysisPatternStore <TrimAnalysisPatterns>k__BackingField;
    public TrimAnalysisPatternStore TrimAnalysisPatterns { get; }
    public TrimDataFlowAnalysis(OperationBlockAnalysisContext context, IOperation operationBlock);
    [CompilerGeneratedAttribute]
public TrimAnalysisPatternStore get_TrimAnalysisPatterns();
    protected virtual TrimAnalysisVisitor GetVisitor(IMethodSymbol method, ControlFlowGraph methodCFG, ImmutableDictionary`2<CaptureId, FlowCaptureKind> lValueFlowCaptures, InterproceduralState`2<ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> interproceduralState);
}
[FlagsAttribute]
internal enum ILLink.RoslynAnalyzer.ValueUsageInfo : Enum {
    public int value__;
    public static ValueUsageInfo None;
    public static ValueUsageInfo Read;
    public static ValueUsageInfo Write;
    public static ValueUsageInfo Reference;
    public static ValueUsageInfo Name;
    public static ValueUsageInfo ReadWrite;
    public static ValueUsageInfo ReadableReference;
    public static ValueUsageInfo WritableReference;
    public static ValueUsageInfo ReadableWritableReference;
}
[ExtensionAttribute]
internal static class ILLink.RoslynAnalyzer.ValueUsageInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsReadFrom(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsWrittenTo(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsNameOnly(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsReference(ValueUsageInfo valueUsageInfo);
}
internal static class ILLink.Shared.Annotations : object {
    private static DynamicallyAccessedMemberTypes[] AllDynamicallyAccessedMemberTypes;
    private static Annotations();
    public static bool SourceHasRequiredAnnotations(DynamicallyAccessedMemberTypes sourceMemberTypes, DynamicallyAccessedMemberTypes targetMemberTypes, String& missingMemberTypesString);
    public static DynamicallyAccessedMemberTypes GetMissingMemberTypes(DynamicallyAccessedMemberTypes requiredMemberTypes, DynamicallyAccessedMemberTypes availableMemberTypes);
    public static string GetMemberTypesString(DynamicallyAccessedMemberTypes memberTypes);
    private static DynamicallyAccessedMemberTypes[] GetAllDynamicallyAccessedMemberTypes();
    public static ValueTuple`2<DiagnosticId, String[]> GetDiagnosticForAnnotationMismatch(ValueWithDynamicallyAccessedMembers source, ValueWithDynamicallyAccessedMembers target, string missingAnnotations);
}
public class ILLink.Shared.DataFlow.Box`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Box`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.Shared.DataFlow.DefaultValueDictionary`2 : ValueType {
    private Dictionary`2<TKey, TValue> Dictionary;
    private TValue DefaultValue;
    public int Count { get; }
    public DefaultValueDictionary`2(TValue defaultValue);
    private DefaultValueDictionary`2(TValue defaultValue, Dictionary`2<TKey, TValue> dictionary);
    public DefaultValueDictionary`2(DefaultValueDictionary`2<TKey, TValue> other);
    public TValue Get(TKey key);
    public void Set(TKey key, TValue value);
    public sealed virtual bool Equals(DefaultValueDictionary`2<TKey, TValue> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public DefaultValueDictionary`2<TKey, TValue> Clone();
    public virtual int GetHashCode();
    public static bool op_Equality(DefaultValueDictionary`2<TKey, TValue> left, DefaultValueDictionary`2<TKey, TValue> right);
    public static bool op_Inequality(DefaultValueDictionary`2<TKey, TValue> left, DefaultValueDictionary`2<TKey, TValue> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.DataFlow.DictionaryLattice`3 : ValueType {
    public TValueLattice ValueLattice;
    [CompilerGeneratedAttribute]
private DefaultValueDictionary`2<TKey, TValue> <Top>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DefaultValueDictionary`2<TKey, TValue> Top { get; }
    public DictionaryLattice`3(TValueLattice valueLattice);
    [CompilerGeneratedAttribute]
public sealed virtual DefaultValueDictionary`2<TKey, TValue> get_Top();
    public sealed virtual DefaultValueDictionary`2<TKey, TValue> Meet(DefaultValueDictionary`2<TKey, TValue> left, DefaultValueDictionary`2<TKey, TValue> right);
}
public abstract class ILLink.Shared.DataFlow.ForwardDataFlowAnalysis`7 : object {
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public virtual void TraceStart(TControlFlowGraph cfg);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public virtual void TraceVisitBlock(TBlock block);
    [ConditionalAttribute("DEBUG")]
public virtual void TraceBlockInput(TValue normalState, Nullable`1<TValue> exceptionState, Nullable`1<TValue> exceptionFinallyState);
    [ConditionalAttribute("DEBUG")]
public virtual void TraceBlockOutput(TValue normalState, Nullable`1<TValue> exceptionState, Nullable`1<TValue> exceptionFinallyState);
    [NullableContextAttribute("1")]
public void Fixpoint(TControlFlowGraph cfg, TLattice lattice, TTransfer transfer);
}
[NullableContextAttribute("1")]
public interface ILLink.Shared.DataFlow.IControlFlowGraph`2 {
    public IEnumerable`1<TBlock> Blocks { get; }
    public TBlock Entry { get; }
    public abstract virtual IEnumerable`1<TBlock> get_Blocks();
    public abstract virtual TBlock get_Entry();
    public abstract virtual IEnumerable`1<Predecessor<TBlock, TRegion>> GetPredecessors(TBlock block);
    public abstract virtual bool TryGetEnclosingTryOrCatchOrFilter(TBlock block, TRegion& tryOrCatchOrFilterRegion);
    public abstract virtual bool TryGetEnclosingTryOrCatchOrFilter(TRegion region, TRegion& tryOrCatchOrFilterRegion);
    public abstract virtual bool TryGetEnclosingFinally(TBlock block, TRegion& region);
    public abstract virtual TRegion GetCorrespondingTry(TRegion cathOrFilterOrFinallyRegion);
    public abstract virtual IEnumerable`1<TRegion> GetPreviousFilters(TRegion catchOrFilterRegion);
    public abstract virtual bool HasFilter(TRegion catchRegion);
    public abstract virtual TBlock FirstBlock(TRegion region);
    public abstract virtual TBlock LastBlock(TRegion region);
}
public interface ILLink.Shared.DataFlow.IDataFlowState`2 {
    public TValue Current { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Box`1<TValue> Exception { get; public set; }
    [NullableAttribute("1")]
public TValueLattice Lattice { get; public set; }
    public abstract virtual TValue get_Current();
    public abstract virtual void set_Current(TValue value);
    public abstract virtual Box`1<TValue> get_Exception();
    public abstract virtual void set_Exception(Box`1<TValue> value);
    [NullableContextAttribute("1")]
public abstract virtual TValueLattice get_Lattice();
    [NullableContextAttribute("1")]
public abstract virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Lattice(TValueLattice value);
}
[NullableContextAttribute("1")]
public interface ILLink.Shared.DataFlow.IDeepCopyValue`1 {
    public abstract virtual TSingleValue DeepCopy();
}
[NullableContextAttribute("1")]
public interface ILLink.Shared.DataFlow.ILattice`1 {
    public TValue Top { get; }
    public abstract virtual TValue get_Top();
    public abstract virtual TValue Meet(TValue left, TValue right);
}
[NullableContextAttribute("2")]
public interface ILLink.Shared.DataFlow.IRegion`1 {
    public RegionKind Kind { get; }
    public abstract virtual RegionKind get_Kind();
}
public interface ILLink.Shared.DataFlow.ITransfer`4 {
    [NullableContextAttribute("1")]
public abstract virtual void Transfer(TOperation operation, TState state);
}
public class ILLink.Shared.DataFlow.Maybe`1 : ValueType {
    public Nullable`1<T> MaybeValue;
    public Maybe`1(T value);
    public sealed virtual bool Equals(Maybe`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual Maybe`1<T> DeepCopy();
    public static bool op_Equality(Maybe`1<T> left, Maybe`1<T> right);
    public static bool op_Inequality(Maybe`1<T> left, Maybe`1<T> right);
}
public class ILLink.Shared.DataFlow.MaybeLattice`2 : ValueType {
    [NullableAttribute("1")]
public TValueLattice ValueLattice;
    [CompilerGeneratedAttribute]
private Maybe`1<T> <Top>k__BackingField;
    public Maybe`1<T> Top { get; }
    [NullableContextAttribute("1")]
public MaybeLattice`2(TValueLattice valueLattice);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual Maybe`1<T> get_Top();
    public sealed virtual Maybe`1<T> Meet(Maybe`1<T> left, Maybe`1<T> right);
}
public enum ILLink.Shared.DataFlow.RegionKind : Enum {
    public int value__;
    public static RegionKind Try;
    public static RegionKind Catch;
    public static RegionKind Filter;
    public static RegionKind Finally;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ILLink.Shared.DataFlow.SingleValue : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected SingleValue(SingleValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual SingleValue DeepCopy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SingleValue left, SingleValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SingleValue left, SingleValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public abstract virtual SingleValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.DataFlow.ValueSet`1 : ValueType {
    private static int MaxValuesInSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ValueSet`1<TValue> Empty;
    private static ValueSetSentinel<TValue> UnknownSentinel;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ValueSet`1<TValue> Unknown;
    private object _values;
    public bool HasMultipleValues { get; }
    public ValueSet`1(TValue value);
    public ValueSet`1(IEnumerable`1<TValue> values);
    private ValueSet`1(EnumerableValues<TValue> values);
    private ValueSet`1(ValueSetSentinel<TValue> sentinel);
    private static ValueSet`1();
    public static ValueSet`1<TValue> op_Implicit(TValue value);
    public bool get_HasMultipleValues();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueSet`1<TValue> other);
    public static bool op_Equality(ValueSet`1<TValue> left, ValueSet`1<TValue> right);
    public static bool op_Inequality(ValueSet`1<TValue> left, ValueSet`1<TValue> right);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public Enumerable<TValue> GetKnownValues();
    public bool Contains(TValue value);
    internal static ValueSet`1<TValue> Meet(ValueSet`1<TValue> left, ValueSet`1<TValue> right);
    public bool IsEmpty();
    public bool IsUnknown();
    public virtual string ToString();
    public sealed virtual ValueSet`1<TValue> DeepCopy();
}
[IsReadOnlyAttribute]
public class ILLink.Shared.DataFlow.ValueSetLattice`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<TValue> Top { get; }
    public sealed virtual ValueSet`1<TValue> get_Top();
    public sealed virtual ValueSet`1<TValue> Meet(ValueSet`1<TValue> left, ValueSet`1<TValue> right);
}
internal static class ILLink.Shared.DiagnosticCategory : object {
    public static string SingleFile;
    public static string Trimming;
    public static string AOT;
}
public enum ILLink.Shared.DiagnosticId : Enum {
    public int value__;
    public static DiagnosticId XmlFeatureDoesNotSpecifyFeatureValue;
    public static DiagnosticId XmlUnsupportedNonBooleanValueForFeature;
    public static DiagnosticId XmlException;
    public static DiagnosticId _unused_FailedToProcessDescriptorFile;
    public static DiagnosticId CouldNotFindMethodInAssembly;
    public static DiagnosticId CannotStubConstructorWhenBaseTypeDoesNotHaveConstructor;
    public static DiagnosticId CouldNotFindType;
    public static DiagnosticId CouldNotFindConstructor;
    public static DiagnosticId CouldNotFindAssemblyReference;
    public static DiagnosticId CouldNotLoadAssembly;
    public static DiagnosticId FailedToWriteOutput;
    public static DiagnosticId LinkerUnexpectedError;
    public static DiagnosticId ErrorProcessingXmlLocation;
    public static DiagnosticId XmlDocumentLocationHasInvalidFeatureDefault;
    public static DiagnosticId UnrecognizedCommandLineOption;
    public static DiagnosticId InvalidWarningVersion;
    public static DiagnosticId InvalidGenerateWarningSuppressionsValue;
    public static DiagnosticId MissingArgumentForCommanLineOptionName;
    public static DiagnosticId CustomDataFormatIsInvalid;
    public static DiagnosticId NoFilesToLinkSpecified;
    public static DiagnosticId NewMvidAndDeterministicCannotBeUsedAtSameTime;
    public static DiagnosticId AssemblyInCustomStepOptionCouldNotBeFound;
    public static DiagnosticId AssemblyPathInCustomStepMustBeFullyQualified;
    public static DiagnosticId InvalidArgForCustomStep;
    public static DiagnosticId ExpectedSignToControlNewStepInsertion;
    public static DiagnosticId PipelineStepCouldNotBeFound;
    public static DiagnosticId CustomStepTypeCouldNotBeFound;
    public static DiagnosticId CustomStepTypeIsIncompatibleWithLinkerVersion;
    public static DiagnosticId InvalidOptimizationValue;
    public static DiagnosticId InvalidArgumentForTokenOption;
    public static DiagnosticId InvalidAssemblyAction;
    public static DiagnosticId RootAssemblyCouldNotBeFound;
    public static DiagnosticId XmlDescriptorCouldNotBeFound;
    public static DiagnosticId RootAssemblyDoesNotHaveEntryPoint;
    public static DiagnosticId RootAssemblyCannotUseAction;
    public static DiagnosticId InvalidAssemblyName;
    public static DiagnosticId InvalidAssemblyRootMode;
    public static DiagnosticId ExportedTypeCannotBeResolved;
    public static DiagnosticId ReferenceAssemblyCouldNotBeLoaded;
    public static DiagnosticId FailedToResolveMetadataElement;
    public static DiagnosticId TypeUsedWithAttributeValueCouldNotBeFound;
    public static DiagnosticId CannotConverValueToType;
    public static DiagnosticId CustomAttributeArgumentForTypeRequiresNestedNode;
    public static DiagnosticId CouldNotResolveCustomAttributeTypeValue;
    public static DiagnosticId UnexpectedAttributeArgumentType;
    public static DiagnosticId InvalidMetadataOption;
    public static DiagnosticId InvalidDependenciesFileFormat;
    public static DiagnosticId TypeHasNoFieldsToPreserve;
    public static DiagnosticId TypeHasNoMethodsToPreserve;
    public static DiagnosticId CouldNotResolveDependencyAssembly;
    public static DiagnosticId CouldNotResolveDependencyType;
    public static DiagnosticId CouldNotResolveDependencyMember;
    public static DiagnosticId _unused_UnrecognizedReflectionPattern;
    public static DiagnosticId XmlCouldNotResolveAssembly;
    public static DiagnosticId XmlCouldNotResolveType;
    public static DiagnosticId XmlCouldNotFindMethodOnType;
    public static DiagnosticId XmlInvalidValueForStub;
    public static DiagnosticId XmlUnkownBodyModification;
    public static DiagnosticId XmlCouldNotFindFieldOnType;
    public static DiagnosticId XmlSubstitutedFieldNeedsToBeStatic;
    public static DiagnosticId XmlMissingSubstitutionValueForField;
    public static DiagnosticId XmlInvalidSubstitutionValueForField;
    public static DiagnosticId XmlCouldNotFindEventOnType;
    public static DiagnosticId XmlCouldNotFindPropertyOnType;
    public static DiagnosticId XmlCouldNotFindGetAccesorOfPropertyOnType;
    public static DiagnosticId XmlCouldNotFindSetAccesorOfPropertyOnType;
    public static DiagnosticId _unused_RearrangedXmlWarning1;
    public static DiagnosticId _unused_RearrangedXmlWarning2;
    public static DiagnosticId XmlCouldNotFindMatchingConstructorForCustomAttribute;
    public static DiagnosticId XmlMoreThanOneReturnElementForMethod;
    public static DiagnosticId XmlMoreThanOneValyForParameterOfMethod;
    public static DiagnosticId XmlDuplicatePreserveMember;
    public static DiagnosticId RequiresUnreferencedCode;
    public static DiagnosticId AttributeShouldOnlyBeUsedOnceOnMember;
    public static DiagnosticId AttributeDoesntHaveTheRequiredNumberOfParameters;
    public static DiagnosticId XmlElementDoesNotContainRequiredAttributeFullname;
    public static DiagnosticId XmlCouldNotResolveAssemblyForAttribute;
    public static DiagnosticId XmlAttributeTypeCouldNotBeFound;
    public static DiagnosticId UnrecognizedParameterInMethodCreateInstance;
    public static DiagnosticId DeprecatedPreserveDependencyAttribute;
    public static DiagnosticId DynamicDependencyAttributeCouldNotBeAnalyzed;
    public static DiagnosticId UnresolvedAssemblyInDynamicDependencyAttribute;
    public static DiagnosticId UnresolvedTypeInDynamicDependencyAttribute;
    public static DiagnosticId NoMembersResolvedForMemberSignatureOrType;
    public static DiagnosticId XmlMissingNameAttributeInResource;
    public static DiagnosticId XmlInvalidValueForAttributeActionForResource;
    public static DiagnosticId XmlCouldNotFindResourceToRemoveInAssembly;
    public static DiagnosticId DynamicallyAccessedMembersIsNotAllowedOnMethods;
    public static DiagnosticId DynamicallyAccessedMembersCouldNotFindBackingField;
    public static DiagnosticId DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessor;
    public static DiagnosticId XmlCouldNotFindAnyTypeInNamespace;
    public static DiagnosticId AttributeIsReferencedButTrimmerRemoveAllInstances;
    public static DiagnosticId RequiresUnreferencedCodeAttributeMismatch;
    public static DiagnosticId _unused_DynamicallyAccessedMembersMismatchBetweenOverrides;
    public static DiagnosticId XmlRemoveAttributeInstancesCanOnlyBeUsedOnType;
    public static DiagnosticId UnrecognizedInternalAttribute;
    public static DiagnosticId CorrectnessOfCOMCannotBeGuaranteed;
    public static DiagnosticId XmlPropertyDoesNotContainAttributeName;
    public static DiagnosticId XmlCouldNotFindProperty;
    public static DiagnosticId _unused_XmlInvalidPropertyValueForProperty;
    public static DiagnosticId _unused_XmlInvalidArgumentForParameterOfType;
    public static DiagnosticId MakeGenericType;
    public static DiagnosticId DynamicallyAccessedMembersOnPropertyConflictsWithBackingField;
    public static DiagnosticId UnrecognizedTypeNameInTypeGetType;
    public static DiagnosticId ParametersOfAssemblyCreateInstanceCannotBeAnalyzed;
    public static DiagnosticId UnrecognizedTypeInRuntimeHelpersRunClassConstructor;
    public static DiagnosticId MakeGenericMethod;
    public static DiagnosticId UnresolvedAssemblyInCreateInstance;
    public static DiagnosticId MethodParameterCannotBeStaticallyDetermined;
    public static DiagnosticId MethodReturnValueCannotBeStaticallyDetermined;
    public static DiagnosticId FieldValueCannotBeStaticallyDetermined;
    public static DiagnosticId ImplicitThisCannotBeStaticallyDetermined;
    public static DiagnosticId TypePassedToGenericParameterCannotBeStaticallyDetermined;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverrides;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverrides;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverrides;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverrides;
    public static DiagnosticId CaseInsensitiveTypeGetTypeCallIsNotSupported;
    public static DiagnosticId DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId XmlUnsuportedWildcard;
    public static DiagnosticId AssemblyWithEmbeddedXmlApplyToAnotherAssembly;
    public static DiagnosticId InvalidIsTrimmableValue;
    public static DiagnosticId PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDetermined;
    public static DiagnosticId AssemblyProducedTrimWarnings;
    public static DiagnosticId TypeWasNotFoundInAssemblyNorBaseLibrary;
    public static DiagnosticId DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId MethodsAreAssociatedWithStateMachine;
    public static DiagnosticId InvalidScopeInUnconditionalSuppressMessage;
    public static DiagnosticId RequiresUnreferencedCodeOnBaseClass;
    public static DiagnosticId DynamicallyAccessedMembersFieldAccessedViaReflection;
    public static DiagnosticId DynamicallyAccessedMembersMethodAccessedViaReflection;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCode;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCode;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembers;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembers;
    public static DiagnosticId RequiresUnreferencedCodeOnStaticConstructor;
    public static DiagnosticId MethodsAreAssociatedWithUserMethod;
    public static DiagnosticId CompilerGeneratedMemberAccessedViaReflection;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMember;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBase;
    public static DiagnosticId RedundantSuppression;
    public static DiagnosticId AvoidAssemblyLocationInSingleFile;
    public static DiagnosticId AvoidAssemblyGetFilesInSingleFile;
    public static DiagnosticId RequiresAssemblyFiles;
    public static DiagnosticId RequiresAssemblyFilesAttributeMismatch;
    public static DiagnosticId RequiresAssemblyFilesOnStaticConstructor;
    public static DiagnosticId RequiresDynamicCode;
    public static DiagnosticId RequiresDynamicCodeAttributeMismatch;
    public static DiagnosticId COMInteropNotSupportedInFullAOT;
    public static DiagnosticId AssemblyProducedAOTWarnings;
    public static DiagnosticId GenericRecursionCycle;
    public static DiagnosticId CorrectnessOfAbstractDelegatesCannotBeGuaranteed;
    public static DiagnosticId RequiresDynamicCodeOnStaticConstructor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.Shared.DiagnosticIdExtensions : object {
    [ExtensionAttribute]
public static string AsString(DiagnosticId diagnosticId);
    [ExtensionAttribute]
public static string GetDiagnosticSubcategory(DiagnosticId diagnosticId);
    [ExtensionAttribute]
public static string GetDiagnosticCategory(DiagnosticId diagnosticId);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string GetHelpUri(DiagnosticId diagnosticId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.DiagnosticString : ValueType {
    private string _titleFormat;
    private string _messageFormat;
    public DiagnosticString(DiagnosticId diagnosticId);
    public DiagnosticString(string diagnosticResourceStringName);
    public string GetMessage(String[] args);
    public string GetMessageFormat();
    public string GetTitle(String[] args);
    public string GetTitleFormat();
}
internal static class ILLink.Shared.HashUtils : object {
    private static int Multiplier;
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
}
internal static class ILLink.Shared.MessageFormat : object {
    public static string FormatRequiresAttributeMessageArg(string message);
    public static string FormatRequiresAttributeUrlArg(string url);
    public static string FormatRequiresAttributeMismatch(bool memberHasAttribute, bool isInterface, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class ILLink.Shared.MessageSubCategory : object {
    public static string None;
    public static string TrimAnalysis;
    public static string UnresolvedAssembly;
    public static string AotAnalysis;
}
internal static class ILLink.Shared.SharedStrings : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string XmlFeatureDoesNotSpecifyFeatureValueTitle { get; }
    internal static string XmlFeatureDoesNotSpecifyFeatureValueMessage { get; }
    internal static string XmlUnsupportedNonBooleanValueForFeatureTitle { get; }
    internal static string XmlUnsupportedNonBooleanValueForFeatureMessage { get; }
    internal static string XmlExceptionTitle { get; }
    internal static string XmlExceptionMessage { get; }
    internal static string CouldNotFindMethodInAssemblyTitle { get; }
    internal static string CouldNotFindMethodInAssemblyMessage { get; }
    internal static string CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorTitle { get; }
    internal static string CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorMessage { get; }
    internal static string CouldNotFindTypeTitle { get; }
    internal static string CouldNotFindTypeMessage { get; }
    internal static string CouldNotFindConstructorTitle { get; }
    internal static string CouldNotFindConstructorMessage { get; }
    internal static string CouldNotFindAssemblyReferenceTitle { get; }
    internal static string CouldNotFindAssemblyReferenceMessage { get; }
    internal static string CouldNotLoadAssemblyTitle { get; }
    internal static string CouldNotLoadAssemblyMessage { get; }
    internal static string FailedToWriteOutputTitle { get; }
    internal static string FailedToWriteOutputMessage { get; }
    internal static string LinkerUnexpectedErrorTitle { get; }
    internal static string LinkerUnexpectedErrorMessage { get; }
    internal static string ErrorProcessingXmlLocationTitle { get; }
    internal static string ErrorProcessingXmlLocationMessage { get; }
    internal static string XmlDocumentLocationHasInvalidFeatureDefaultTitle { get; }
    internal static string XmlDocumentLocationHasInvalidFeatureDefaultMessage { get; }
    internal static string UnrecognizedCommandLineOptionTitle { get; }
    internal static string UnrecognizedCommandLineOptionMessage { get; }
    internal static string InvalidWarningVersionTitle { get; }
    internal static string InvalidWarningVersionMessage { get; }
    internal static string InvalidGenerateWarningSuppressionsValueTitle { get; }
    internal static string InvalidGenerateWarningSuppressionsValueMessage { get; }
    internal static string MissingArgumentForCommanLineOptionNameTitle { get; }
    internal static string MissingArgumentForCommanLineOptionNameMessage { get; }
    internal static string CustomDataFormatIsInvalidTitle { get; }
    internal static string CustomDataFormatIsInvalidMessage { get; }
    internal static string NoFilesToLinkSpecifiedTitle { get; }
    internal static string NoFilesToLinkSpecifiedMessage { get; }
    internal static string NewMvidAndDeterministicCannotBeUsedAtSameTimeTitle { get; }
    internal static string NewMvidAndDeterministicCannotBeUsedAtSameTimeMessage { get; }
    internal static string AssemblyInCustomStepOptionCouldNotBeFoundTitle { get; }
    internal static string AssemblyInCustomStepOptionCouldNotBeFoundMessage { get; }
    internal static string AssemblyPathInCustomStepMustBeFullyQualifiedTitle { get; }
    internal static string AssemblyPathInCustomStepMustBeFullyQualifiedMessage { get; }
    internal static string InvalidArgForCustomStepTitle { get; }
    internal static string InvalidArgForCustomStepMessage { get; }
    internal static string ExpectedSignToControlNewStepInsertionTitle { get; }
    internal static string ExpectedSignToControlNewStepInsertionMessage { get; }
    internal static string PipelineStepCouldNotBeFoundTitle { get; }
    internal static string PipelineStepCouldNotBeFoundMessage { get; }
    internal static string CustomStepTypeCouldNotBeFoundTitle { get; }
    internal static string CustomStepTypeCouldNotBeFoundMessage { get; }
    internal static string CustomStepTypeIsIncompatibleWithLinkerVersionTitle { get; }
    internal static string CustomStepTypeIsIncompatibleWithLinkerVersionMessage { get; }
    internal static string InvalidOptimizationValueTitle { get; }
    internal static string InvalidOptimizationValueMessage { get; }
    internal static string InvalidArgumentForTokenOptionTitle { get; }
    internal static string InvalidArgumentForTokenOptionMessage { get; }
    internal static string InvalidAssemblyActionTitle { get; }
    internal static string InvalidAssemblyActionMessage { get; }
    internal static string RootAssemblyCouldNotBeFoundTitle { get; }
    internal static string RootAssemblyCouldNotBeFoundMessage { get; }
    internal static string XmlDescriptorCouldNotBeFoundTitle { get; }
    internal static string XmlDescriptorCouldNotBeFoundMessage { get; }
    internal static string RootAssemblyDoesNotHaveEntryPointTitle { get; }
    internal static string RootAssemblyDoesNotHaveEntryPointMessage { get; }
    internal static string RootAssemblyCannotUseActionTitle { get; }
    internal static string RootAssemblyCannotUseActionMessage { get; }
    internal static string InvalidAssemblyNameTitle { get; }
    internal static string InvalidAssemblyNameMessage { get; }
    internal static string InvalidAssemblyRootModeTitle { get; }
    internal static string InvalidAssemblyRootModeMessage { get; }
    internal static string ExportedTypeCannotBeResolvedTitle { get; }
    internal static string ExportedTypeCannotBeResolvedMessage { get; }
    internal static string ReferenceAssemblyCouldNotBeLoadedTitle { get; }
    internal static string ReferenceAssemblyCouldNotBeLoadedMessage { get; }
    internal static string FailedToResolveMetadataElementTitle { get; }
    internal static string FailedToResolveMetadataElementMessage { get; }
    internal static string FailedToResolveFieldElementTitle { get; }
    internal static string FailedToResolveFieldElementMessage { get; }
    internal static string FailedToResolveMethodElementTitle { get; }
    internal static string FailedToResolveMethodElementMessage { get; }
    internal static string FailedToResolveTypeElementTitle { get; }
    internal static string FailedToResolveTypeElementMessage { get; }
    internal static string TypeUsedWithAttributeValueCouldNotBeFoundTitle { get; }
    internal static string TypeUsedWithAttributeValueCouldNotBeFoundMessage { get; }
    internal static string CannotConverValueToTypeTitle { get; }
    internal static string CannotConverValueToTypeMessage { get; }
    internal static string CustomAttributeArgumentForTypeRequiresNestedNodeTitle { get; }
    internal static string CustomAttributeArgumentForTypeRequiresNestedNodeMessage { get; }
    internal static string CouldNotResolveCustomAttributeTypeValueTitle { get; }
    internal static string CouldNotResolveCustomAttributeTypeValueMessage { get; }
    internal static string UnexpectedAttributeArgumentTypeTitle { get; }
    internal static string UnexpectedAttributeArgumentTypeMessage { get; }
    internal static string InvalidMetadataOptionTitle { get; }
    internal static string InvalidMetadataOptionMessage { get; }
    internal static string TypeHasNoFieldsToPreserveTitle { get; }
    internal static string TypeHasNoFieldsToPreserveMessage { get; }
    internal static string TypeHasNoMethodsToPreserveTitle { get; }
    internal static string TypeHasNoMethodsToPreserveMessage { get; }
    internal static string CouldNotResolveDependencyAssemblyTitle { get; }
    internal static string CouldNotResolveDependencyAssemblyMessage { get; }
    internal static string CouldNotResolveDependencyTypeTitle { get; }
    internal static string CouldNotResolveDependencyTypeMessage { get; }
    internal static string CouldNotResolveDependencyMemberTitle { get; }
    internal static string CouldNotResolveDependencyMemberMessage { get; }
    internal static string XmlCouldNotResolveAssemblyTitle { get; }
    internal static string XmlCouldNotResolveAssemblyMessage { get; }
    internal static string XmlCouldNotResolveTypeTitle { get; }
    internal static string XmlCouldNotResolveTypeMessage { get; }
    internal static string XmlCouldNotFindMethodOnTypeTitle { get; }
    internal static string XmlCouldNotFindMethodOnTypeMessage { get; }
    internal static string XmlInvalidValueForStubTitle { get; }
    internal static string XmlInvalidValueForStubMessage { get; }
    internal static string XmlUnkownBodyModificationTitle { get; }
    internal static string XmlUnkownBodyModificationMessage { get; }
    internal static string XmlCouldNotFindFieldOnTypeTitle { get; }
    internal static string XmlCouldNotFindFieldOnTypeMessage { get; }
    internal static string XmlSubstitutedFieldNeedsToBeStaticTitle { get; }
    internal static string XmlSubstitutedFieldNeedsToBeStaticMessage { get; }
    internal static string XmlMissingSubstitutionValueForFieldTitle { get; }
    internal static string XmlMissingSubstitutionValueForFieldMessage { get; }
    internal static string XmlInvalidSubstitutionValueForFieldTitle { get; }
    internal static string XmlInvalidSubstitutionValueForFieldMessage { get; }
    internal static string XmlCouldNotFindEventOnTypeTitle { get; }
    internal static string XmlCouldNotFindEventOnTypeMessage { get; }
    internal static string XmlCouldNotFindPropertyOnTypeTitle { get; }
    internal static string XmlCouldNotFindPropertyOnTypeMessage { get; }
    internal static string XmlCouldNotFindGetAccesorOfPropertyOnTypeTitle { get; }
    internal static string XmlCouldNotFindGetAccesorOfPropertyOnTypeMessage { get; }
    internal static string XmlCouldNotFindSetAccesorOfPropertyOnTypeTitle { get; }
    internal static string XmlCouldNotFindSetAccesorOfPropertyOnTypeMessage { get; }
    internal static string XmlCouldNotFindMatchingConstructorForCustomAttributeTitle { get; }
    internal static string XmlCouldNotFindMatchingConstructorForCustomAttributeMessage { get; }
    internal static string XmlMoreThanOneReturnElementForMethodTitle { get; }
    internal static string XmlMoreThanOneReturnElementForMethodMessage { get; }
    internal static string XmlMoreThanOneValyForParameterOfMethodTitle { get; }
    internal static string XmlMoreThanOneValyForParameterOfMethodMessage { get; }
    internal static string XmlDuplicatePreserveMemberTitle { get; }
    internal static string XmlDuplicatePreserveMemberMessage { get; }
    internal static string RequiresUnreferencedCodeTitle { get; }
    internal static string RequiresUnreferencedCodeMessage { get; }
    internal static string DynamicTypeInvocationTitle { get; }
    internal static string DynamicTypeInvocationMessage { get; }
    internal static string AttributeShouldOnlyBeUsedOnceOnMemberTitle { get; }
    internal static string AttributeShouldOnlyBeUsedOnceOnMemberMessage { get; }
    internal static string AttributeDoesntHaveTheRequiredNumberOfParametersTitle { get; }
    internal static string AttributeDoesntHaveTheRequiredNumberOfParametersMessage { get; }
    internal static string XmlElementDoesNotContainRequiredAttributeFullnameTitle { get; }
    internal static string XmlElementDoesNotContainRequiredAttributeFullnameMessage { get; }
    internal static string XmlCouldNotResolveAssemblyForAttributeTitle { get; }
    internal static string XmlCouldNotResolveAssemblyForAttributeMessage { get; }
    internal static string XmlAttributeTypeCouldNotBeFoundTitle { get; }
    internal static string XmlAttributeTypeCouldNotBeFoundMessage { get; }
    internal static string UnrecognizedParameterInMethodCreateInstanceTitle { get; }
    internal static string UnrecognizedParameterInMethodCreateInstanceMessage { get; }
    internal static string DeprecatedPreserveDependencyAttributeTitle { get; }
    internal static string DeprecatedPreserveDependencyAttributeMessage { get; }
    internal static string DynamicDependencyAttributeCouldNotBeAnalyzedTitle { get; }
    internal static string DynamicDependencyAttributeCouldNotBeAnalyzedMessage { get; }
    internal static string UnresolvedAssemblyInDynamicDependencyAttributeTitle { get; }
    internal static string UnresolvedAssemblyInDynamicDependencyAttributeMessage { get; }
    internal static string UnresolvedTypeInDynamicDependencyAttributeTitle { get; }
    internal static string UnresolvedTypeInDynamicDependencyAttributeMessage { get; }
    internal static string NoMembersResolvedForMemberSignatureOrTypeTitle { get; }
    internal static string NoMembersResolvedForMemberSignatureOrTypeMessage { get; }
    internal static string XmlMissingNameAttributeInResourceTitle { get; }
    internal static string XmlMissingNameAttributeInResourceMessage { get; }
    internal static string XmlInvalidValueForAttributeActionForResourceTitle { get; }
    internal static string XmlInvalidValueForAttributeActionForResourceMessage { get; }
    internal static string XmlCouldNotFindResourceToRemoveInAssemblyTitle { get; }
    internal static string XmlCouldNotFindResourceToRemoveInAssemblyMessage { get; }
    internal static string DynamicallyAccessedMembersIsNotAllowedOnMethodsTitle { get; }
    internal static string DynamicallyAccessedMembersIsNotAllowedOnMethodsMessage { get; }
    internal static string DynamicallyAccessedMembersCouldNotFindBackingFieldTitle { get; }
    internal static string DynamicallyAccessedMembersCouldNotFindBackingFieldMessage { get; }
    internal static string DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorTitle { get; }
    internal static string DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorMessage { get; }
    internal static string XmlCouldNotFindAnyTypeInNamespaceTitle { get; }
    internal static string XmlCouldNotFindAnyTypeInNamespaceMessage { get; }
    internal static string AttributeIsReferencedButTrimmerRemoveAllInstancesTitle { get; }
    internal static string AttributeIsReferencedButTrimmerRemoveAllInstancesMessage { get; }
    internal static string RequiresUnreferencedCodeAttributeMismatchTitle { get; }
    internal static string RequiresUnreferencedCodeAttributeMismatchMessage { get; }
    internal static string XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeTitle { get; }
    internal static string XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeMessage { get; }
    internal static string CorrectnessOfCOMCannotBeGuaranteedTitle { get; }
    internal static string CorrectnessOfCOMCannotBeGuaranteedMessage { get; }
    internal static string XmlPropertyDoesNotContainAttributeNameTitle { get; }
    internal static string XmlPropertyDoesNotContainAttributeNameMessage { get; }
    internal static string XmlCouldNotFindPropertyTitle { get; }
    internal static string XmlCouldNotFindPropertyMessage { get; }
    internal static string MakeGenericTypeTitle { get; }
    internal static string MakeGenericTypeMessage { get; }
    internal static string DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldTitle { get; }
    internal static string DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldMessage { get; }
    internal static string UnrecognizedTypeNameInTypeGetTypeTitle { get; }
    internal static string UnrecognizedTypeNameInTypeGetTypeMessage { get; }
    internal static string ParametersOfAssemblyCreateInstanceCannotBeAnalyzedTitle { get; }
    internal static string ParametersOfAssemblyCreateInstanceCannotBeAnalyzedMessage { get; }
    internal static string UnrecognizedTypeInRuntimeHelpersRunClassConstructorTitle { get; }
    internal static string UnrecognizedTypeInRuntimeHelpersRunClassConstructorMessage { get; }
    internal static string MakeGenericMethodTitle { get; }
    internal static string MakeGenericMethodMessage { get; }
    internal static string UnresolvedAssemblyInCreateInstanceTitle { get; }
    internal static string UnresolvedAssemblyInCreateInstanceMessage { get; }
    internal static string MethodParameterCannotBeStaticallyDeterminedTitle { get; }
    internal static string MethodParameterCannotBeStaticallyDeterminedMessage { get; }
    internal static string MethodReturnValueCannotBeStaticallyDeterminedTitle { get; }
    internal static string MethodReturnValueCannotBeStaticallyDeterminedMessage { get; }
    internal static string FieldValueCannotBeStaticallyDeterminedTitle { get; }
    internal static string FieldValueCannotBeStaticallyDeterminedMessage { get; }
    internal static string ImplicitThisCannotBeStaticallyDeterminedTitle { get; }
    internal static string ImplicitThisCannotBeStaticallyDeterminedMessage { get; }
    internal static string TypePassedToGenericParameterCannotBeStaticallyDeterminedTitle { get; }
    internal static string TypePassedToGenericParameterCannotBeStaticallyDeterminedMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesMessage { get; }
    internal static string CaseInsensitiveTypeGetTypeCallIsNotSupportedTitle { get; }
    internal static string CaseInsensitiveTypeGetTypeCallIsNotSupportedMessage { get; }
    internal static string DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string XmlUnsuportedWildcardTitle { get; }
    internal static string XmlUnsuportedWildcardMessage { get; }
    internal static string AssemblyWithEmbeddedXmlApplyToAnotherAssemblyTitle { get; }
    internal static string AssemblyWithEmbeddedXmlApplyToAnotherAssemblyMessage { get; }
    internal static string InvalidIsTrimmableValueTitle { get; }
    internal static string InvalidIsTrimmableValueMessage { get; }
    internal static string PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedTitle { get; }
    internal static string PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedMessage { get; }
    internal static string AssemblyProducedTrimWarningsTitle { get; }
    internal static string AssemblyProducedTrimWarningsMessage { get; }
    internal static string TypeWasNotFoundInAssemblyNorBaseLibraryTitle { get; }
    internal static string TypeWasNotFoundInAssemblyNorBaseLibraryMessage { get; }
    internal static string DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string MethodsAreAssociatedWithStateMachineTitle { get; }
    internal static string MethodsAreAssociatedWithStateMachineMessage { get; }
    internal static string InvalidScopeInUnconditionalSuppressMessageTitle { get; }
    internal static string InvalidScopeInUnconditionalSuppressMessageMessage { get; }
    internal static string RequiresUnreferencedCodeOnBaseClassTitle { get; }
    internal static string RequiresUnreferencedCodeOnBaseClassMessage { get; }
    internal static string DynamicallyAccessedMembersFieldAccessedViaReflectionTitle { get; }
    internal static string DynamicallyAccessedMembersFieldAccessedViaReflectionMessage { get; }
    internal static string DynamicallyAccessedMembersMethodAccessedViaReflectionTitle { get; }
    internal static string DynamicallyAccessedMembersMethodAccessedViaReflectionMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersMessage { get; }
    internal static string RequiresUnreferencedCodeOnStaticConstructorTitle { get; }
    internal static string RequiresUnreferencedCodeOnStaticConstructorMessage { get; }
    internal static string MethodsAreAssociatedWithUserMethodTitle { get; }
    internal static string MethodsAreAssociatedWithUserMethodMessage { get; }
    internal static string CompilerGeneratedMemberAccessedViaReflectionTitle { get; }
    internal static string CompilerGeneratedMemberAccessedViaReflectionMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseMessage { get; }
    internal static string AvoidAssemblyLocationInSingleFileTitle { get; }
    internal static string AvoidAssemblyLocationInSingleFileMessage { get; }
    internal static string AvoidAssemblyGetFilesInSingleFileTitle { get; }
    internal static string AvoidAssemblyGetFilesInSingleFileMessage { get; }
    internal static string RequiresAssemblyFilesTitle { get; }
    internal static string RequiresAssemblyFilesMessage { get; }
    internal static string RequiresAssemblyFilesAttributeMismatchTitle { get; }
    internal static string RequiresAssemblyFilesAttributeMismatchMessage { get; }
    internal static string RequiresDynamicCodeTitle { get; }
    internal static string RequiresDynamicCodeMessage { get; }
    internal static string RequiresDynamicCodeAttributeMismatchTitle { get; }
    internal static string RequiresDynamicCodeAttributeMismatchMessage { get; }
    internal static string COMInteropNotSupportedInFullAOTTitle { get; }
    internal static string COMInteropNotSupportedInFullAOTMessage { get; }
    internal static string AssemblyProducedAOTWarningsTitle { get; }
    internal static string AssemblyProducedAOTWarningsMessage { get; }
    internal static string GenericRecursionCycleTitle { get; }
    internal static string GenericRecursionCycleMessage { get; }
    internal static string CorrectnessOfAbstractDelegatesCannotBeGuaranteedTitle { get; }
    internal static string CorrectnessOfAbstractDelegatesCannotBeGuaranteedMessage { get; }
    internal static string BaseRequiresMismatchMessage { get; }
    internal static string DerivedRequiresMismatchMessage { get; }
    internal static string ImplementationRequiresMismatchMessage { get; }
    internal static string InterfaceRequiresMismatchMessage { get; }
    internal static string RequiresOnBaseClassMessage { get; }
    internal static string RequiresOnBaseClassTitle { get; }
    internal static string RequiresDynamicCodeOnStaticConstructorMessage { get; }
    internal static string RequiresDynamicCodeOnStaticConstructorTitle { get; }
    internal static string RequiresAssemblyFilesOnStaticConstructorMessage { get; }
    internal static string RequiresAssemblyFilesOnStaticConstructorTitle { get; }
    internal static string UnrecognizedInternalAttributeMessage { get; }
    internal static string UnrecognizedInternalAttributeTitle { get; }
    internal static string InvalidDependenciesFileFormatMessage { get; }
    internal static string InvalidDependenciesFileFormatTitle { get; }
    internal static string RedundantSuppressionMessage { get; }
    internal static string RedundantSuppressionTitle { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_XmlFeatureDoesNotSpecifyFeatureValueTitle();
    internal static string get_XmlFeatureDoesNotSpecifyFeatureValueMessage();
    internal static string get_XmlUnsupportedNonBooleanValueForFeatureTitle();
    internal static string get_XmlUnsupportedNonBooleanValueForFeatureMessage();
    internal static string get_XmlExceptionTitle();
    internal static string get_XmlExceptionMessage();
    internal static string get_CouldNotFindMethodInAssemblyTitle();
    internal static string get_CouldNotFindMethodInAssemblyMessage();
    internal static string get_CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorTitle();
    internal static string get_CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorMessage();
    internal static string get_CouldNotFindTypeTitle();
    internal static string get_CouldNotFindTypeMessage();
    internal static string get_CouldNotFindConstructorTitle();
    internal static string get_CouldNotFindConstructorMessage();
    internal static string get_CouldNotFindAssemblyReferenceTitle();
    internal static string get_CouldNotFindAssemblyReferenceMessage();
    internal static string get_CouldNotLoadAssemblyTitle();
    internal static string get_CouldNotLoadAssemblyMessage();
    internal static string get_FailedToWriteOutputTitle();
    internal static string get_FailedToWriteOutputMessage();
    internal static string get_LinkerUnexpectedErrorTitle();
    internal static string get_LinkerUnexpectedErrorMessage();
    internal static string get_ErrorProcessingXmlLocationTitle();
    internal static string get_ErrorProcessingXmlLocationMessage();
    internal static string get_XmlDocumentLocationHasInvalidFeatureDefaultTitle();
    internal static string get_XmlDocumentLocationHasInvalidFeatureDefaultMessage();
    internal static string get_UnrecognizedCommandLineOptionTitle();
    internal static string get_UnrecognizedCommandLineOptionMessage();
    internal static string get_InvalidWarningVersionTitle();
    internal static string get_InvalidWarningVersionMessage();
    internal static string get_InvalidGenerateWarningSuppressionsValueTitle();
    internal static string get_InvalidGenerateWarningSuppressionsValueMessage();
    internal static string get_MissingArgumentForCommanLineOptionNameTitle();
    internal static string get_MissingArgumentForCommanLineOptionNameMessage();
    internal static string get_CustomDataFormatIsInvalidTitle();
    internal static string get_CustomDataFormatIsInvalidMessage();
    internal static string get_NoFilesToLinkSpecifiedTitle();
    internal static string get_NoFilesToLinkSpecifiedMessage();
    internal static string get_NewMvidAndDeterministicCannotBeUsedAtSameTimeTitle();
    internal static string get_NewMvidAndDeterministicCannotBeUsedAtSameTimeMessage();
    internal static string get_AssemblyInCustomStepOptionCouldNotBeFoundTitle();
    internal static string get_AssemblyInCustomStepOptionCouldNotBeFoundMessage();
    internal static string get_AssemblyPathInCustomStepMustBeFullyQualifiedTitle();
    internal static string get_AssemblyPathInCustomStepMustBeFullyQualifiedMessage();
    internal static string get_InvalidArgForCustomStepTitle();
    internal static string get_InvalidArgForCustomStepMessage();
    internal static string get_ExpectedSignToControlNewStepInsertionTitle();
    internal static string get_ExpectedSignToControlNewStepInsertionMessage();
    internal static string get_PipelineStepCouldNotBeFoundTitle();
    internal static string get_PipelineStepCouldNotBeFoundMessage();
    internal static string get_CustomStepTypeCouldNotBeFoundTitle();
    internal static string get_CustomStepTypeCouldNotBeFoundMessage();
    internal static string get_CustomStepTypeIsIncompatibleWithLinkerVersionTitle();
    internal static string get_CustomStepTypeIsIncompatibleWithLinkerVersionMessage();
    internal static string get_InvalidOptimizationValueTitle();
    internal static string get_InvalidOptimizationValueMessage();
    internal static string get_InvalidArgumentForTokenOptionTitle();
    internal static string get_InvalidArgumentForTokenOptionMessage();
    internal static string get_InvalidAssemblyActionTitle();
    internal static string get_InvalidAssemblyActionMessage();
    internal static string get_RootAssemblyCouldNotBeFoundTitle();
    internal static string get_RootAssemblyCouldNotBeFoundMessage();
    internal static string get_XmlDescriptorCouldNotBeFoundTitle();
    internal static string get_XmlDescriptorCouldNotBeFoundMessage();
    internal static string get_RootAssemblyDoesNotHaveEntryPointTitle();
    internal static string get_RootAssemblyDoesNotHaveEntryPointMessage();
    internal static string get_RootAssemblyCannotUseActionTitle();
    internal static string get_RootAssemblyCannotUseActionMessage();
    internal static string get_InvalidAssemblyNameTitle();
    internal static string get_InvalidAssemblyNameMessage();
    internal static string get_InvalidAssemblyRootModeTitle();
    internal static string get_InvalidAssemblyRootModeMessage();
    internal static string get_ExportedTypeCannotBeResolvedTitle();
    internal static string get_ExportedTypeCannotBeResolvedMessage();
    internal static string get_ReferenceAssemblyCouldNotBeLoadedTitle();
    internal static string get_ReferenceAssemblyCouldNotBeLoadedMessage();
    internal static string get_FailedToResolveMetadataElementTitle();
    internal static string get_FailedToResolveMetadataElementMessage();
    internal static string get_FailedToResolveFieldElementTitle();
    internal static string get_FailedToResolveFieldElementMessage();
    internal static string get_FailedToResolveMethodElementTitle();
    internal static string get_FailedToResolveMethodElementMessage();
    internal static string get_FailedToResolveTypeElementTitle();
    internal static string get_FailedToResolveTypeElementMessage();
    internal static string get_TypeUsedWithAttributeValueCouldNotBeFoundTitle();
    internal static string get_TypeUsedWithAttributeValueCouldNotBeFoundMessage();
    internal static string get_CannotConverValueToTypeTitle();
    internal static string get_CannotConverValueToTypeMessage();
    internal static string get_CustomAttributeArgumentForTypeRequiresNestedNodeTitle();
    internal static string get_CustomAttributeArgumentForTypeRequiresNestedNodeMessage();
    internal static string get_CouldNotResolveCustomAttributeTypeValueTitle();
    internal static string get_CouldNotResolveCustomAttributeTypeValueMessage();
    internal static string get_UnexpectedAttributeArgumentTypeTitle();
    internal static string get_UnexpectedAttributeArgumentTypeMessage();
    internal static string get_InvalidMetadataOptionTitle();
    internal static string get_InvalidMetadataOptionMessage();
    internal static string get_TypeHasNoFieldsToPreserveTitle();
    internal static string get_TypeHasNoFieldsToPreserveMessage();
    internal static string get_TypeHasNoMethodsToPreserveTitle();
    internal static string get_TypeHasNoMethodsToPreserveMessage();
    internal static string get_CouldNotResolveDependencyAssemblyTitle();
    internal static string get_CouldNotResolveDependencyAssemblyMessage();
    internal static string get_CouldNotResolveDependencyTypeTitle();
    internal static string get_CouldNotResolveDependencyTypeMessage();
    internal static string get_CouldNotResolveDependencyMemberTitle();
    internal static string get_CouldNotResolveDependencyMemberMessage();
    internal static string get_XmlCouldNotResolveAssemblyTitle();
    internal static string get_XmlCouldNotResolveAssemblyMessage();
    internal static string get_XmlCouldNotResolveTypeTitle();
    internal static string get_XmlCouldNotResolveTypeMessage();
    internal static string get_XmlCouldNotFindMethodOnTypeTitle();
    internal static string get_XmlCouldNotFindMethodOnTypeMessage();
    internal static string get_XmlInvalidValueForStubTitle();
    internal static string get_XmlInvalidValueForStubMessage();
    internal static string get_XmlUnkownBodyModificationTitle();
    internal static string get_XmlUnkownBodyModificationMessage();
    internal static string get_XmlCouldNotFindFieldOnTypeTitle();
    internal static string get_XmlCouldNotFindFieldOnTypeMessage();
    internal static string get_XmlSubstitutedFieldNeedsToBeStaticTitle();
    internal static string get_XmlSubstitutedFieldNeedsToBeStaticMessage();
    internal static string get_XmlMissingSubstitutionValueForFieldTitle();
    internal static string get_XmlMissingSubstitutionValueForFieldMessage();
    internal static string get_XmlInvalidSubstitutionValueForFieldTitle();
    internal static string get_XmlInvalidSubstitutionValueForFieldMessage();
    internal static string get_XmlCouldNotFindEventOnTypeTitle();
    internal static string get_XmlCouldNotFindEventOnTypeMessage();
    internal static string get_XmlCouldNotFindPropertyOnTypeTitle();
    internal static string get_XmlCouldNotFindPropertyOnTypeMessage();
    internal static string get_XmlCouldNotFindGetAccesorOfPropertyOnTypeTitle();
    internal static string get_XmlCouldNotFindGetAccesorOfPropertyOnTypeMessage();
    internal static string get_XmlCouldNotFindSetAccesorOfPropertyOnTypeTitle();
    internal static string get_XmlCouldNotFindSetAccesorOfPropertyOnTypeMessage();
    internal static string get_XmlCouldNotFindMatchingConstructorForCustomAttributeTitle();
    internal static string get_XmlCouldNotFindMatchingConstructorForCustomAttributeMessage();
    internal static string get_XmlMoreThanOneReturnElementForMethodTitle();
    internal static string get_XmlMoreThanOneReturnElementForMethodMessage();
    internal static string get_XmlMoreThanOneValyForParameterOfMethodTitle();
    internal static string get_XmlMoreThanOneValyForParameterOfMethodMessage();
    internal static string get_XmlDuplicatePreserveMemberTitle();
    internal static string get_XmlDuplicatePreserveMemberMessage();
    internal static string get_RequiresUnreferencedCodeTitle();
    internal static string get_RequiresUnreferencedCodeMessage();
    internal static string get_DynamicTypeInvocationTitle();
    internal static string get_DynamicTypeInvocationMessage();
    internal static string get_AttributeShouldOnlyBeUsedOnceOnMemberTitle();
    internal static string get_AttributeShouldOnlyBeUsedOnceOnMemberMessage();
    internal static string get_AttributeDoesntHaveTheRequiredNumberOfParametersTitle();
    internal static string get_AttributeDoesntHaveTheRequiredNumberOfParametersMessage();
    internal static string get_XmlElementDoesNotContainRequiredAttributeFullnameTitle();
    internal static string get_XmlElementDoesNotContainRequiredAttributeFullnameMessage();
    internal static string get_XmlCouldNotResolveAssemblyForAttributeTitle();
    internal static string get_XmlCouldNotResolveAssemblyForAttributeMessage();
    internal static string get_XmlAttributeTypeCouldNotBeFoundTitle();
    internal static string get_XmlAttributeTypeCouldNotBeFoundMessage();
    internal static string get_UnrecognizedParameterInMethodCreateInstanceTitle();
    internal static string get_UnrecognizedParameterInMethodCreateInstanceMessage();
    internal static string get_DeprecatedPreserveDependencyAttributeTitle();
    internal static string get_DeprecatedPreserveDependencyAttributeMessage();
    internal static string get_DynamicDependencyAttributeCouldNotBeAnalyzedTitle();
    internal static string get_DynamicDependencyAttributeCouldNotBeAnalyzedMessage();
    internal static string get_UnresolvedAssemblyInDynamicDependencyAttributeTitle();
    internal static string get_UnresolvedAssemblyInDynamicDependencyAttributeMessage();
    internal static string get_UnresolvedTypeInDynamicDependencyAttributeTitle();
    internal static string get_UnresolvedTypeInDynamicDependencyAttributeMessage();
    internal static string get_NoMembersResolvedForMemberSignatureOrTypeTitle();
    internal static string get_NoMembersResolvedForMemberSignatureOrTypeMessage();
    internal static string get_XmlMissingNameAttributeInResourceTitle();
    internal static string get_XmlMissingNameAttributeInResourceMessage();
    internal static string get_XmlInvalidValueForAttributeActionForResourceTitle();
    internal static string get_XmlInvalidValueForAttributeActionForResourceMessage();
    internal static string get_XmlCouldNotFindResourceToRemoveInAssemblyTitle();
    internal static string get_XmlCouldNotFindResourceToRemoveInAssemblyMessage();
    internal static string get_DynamicallyAccessedMembersIsNotAllowedOnMethodsTitle();
    internal static string get_DynamicallyAccessedMembersIsNotAllowedOnMethodsMessage();
    internal static string get_DynamicallyAccessedMembersCouldNotFindBackingFieldTitle();
    internal static string get_DynamicallyAccessedMembersCouldNotFindBackingFieldMessage();
    internal static string get_DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorTitle();
    internal static string get_DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorMessage();
    internal static string get_XmlCouldNotFindAnyTypeInNamespaceTitle();
    internal static string get_XmlCouldNotFindAnyTypeInNamespaceMessage();
    internal static string get_AttributeIsReferencedButTrimmerRemoveAllInstancesTitle();
    internal static string get_AttributeIsReferencedButTrimmerRemoveAllInstancesMessage();
    internal static string get_RequiresUnreferencedCodeAttributeMismatchTitle();
    internal static string get_RequiresUnreferencedCodeAttributeMismatchMessage();
    internal static string get_XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeTitle();
    internal static string get_XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeMessage();
    internal static string get_CorrectnessOfCOMCannotBeGuaranteedTitle();
    internal static string get_CorrectnessOfCOMCannotBeGuaranteedMessage();
    internal static string get_XmlPropertyDoesNotContainAttributeNameTitle();
    internal static string get_XmlPropertyDoesNotContainAttributeNameMessage();
    internal static string get_XmlCouldNotFindPropertyTitle();
    internal static string get_XmlCouldNotFindPropertyMessage();
    internal static string get_MakeGenericTypeTitle();
    internal static string get_MakeGenericTypeMessage();
    internal static string get_DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldTitle();
    internal static string get_DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldMessage();
    internal static string get_UnrecognizedTypeNameInTypeGetTypeTitle();
    internal static string get_UnrecognizedTypeNameInTypeGetTypeMessage();
    internal static string get_ParametersOfAssemblyCreateInstanceCannotBeAnalyzedTitle();
    internal static string get_ParametersOfAssemblyCreateInstanceCannotBeAnalyzedMessage();
    internal static string get_UnrecognizedTypeInRuntimeHelpersRunClassConstructorTitle();
    internal static string get_UnrecognizedTypeInRuntimeHelpersRunClassConstructorMessage();
    internal static string get_MakeGenericMethodTitle();
    internal static string get_MakeGenericMethodMessage();
    internal static string get_UnresolvedAssemblyInCreateInstanceTitle();
    internal static string get_UnresolvedAssemblyInCreateInstanceMessage();
    internal static string get_MethodParameterCannotBeStaticallyDeterminedTitle();
    internal static string get_MethodParameterCannotBeStaticallyDeterminedMessage();
    internal static string get_MethodReturnValueCannotBeStaticallyDeterminedTitle();
    internal static string get_MethodReturnValueCannotBeStaticallyDeterminedMessage();
    internal static string get_FieldValueCannotBeStaticallyDeterminedTitle();
    internal static string get_FieldValueCannotBeStaticallyDeterminedMessage();
    internal static string get_ImplicitThisCannotBeStaticallyDeterminedTitle();
    internal static string get_ImplicitThisCannotBeStaticallyDeterminedMessage();
    internal static string get_TypePassedToGenericParameterCannotBeStaticallyDeterminedTitle();
    internal static string get_TypePassedToGenericParameterCannotBeStaticallyDeterminedMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesMessage();
    internal static string get_CaseInsensitiveTypeGetTypeCallIsNotSupportedTitle();
    internal static string get_CaseInsensitiveTypeGetTypeCallIsNotSupportedMessage();
    internal static string get_DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_XmlUnsuportedWildcardTitle();
    internal static string get_XmlUnsuportedWildcardMessage();
    internal static string get_AssemblyWithEmbeddedXmlApplyToAnotherAssemblyTitle();
    internal static string get_AssemblyWithEmbeddedXmlApplyToAnotherAssemblyMessage();
    internal static string get_InvalidIsTrimmableValueTitle();
    internal static string get_InvalidIsTrimmableValueMessage();
    internal static string get_PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedTitle();
    internal static string get_PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedMessage();
    internal static string get_AssemblyProducedTrimWarningsTitle();
    internal static string get_AssemblyProducedTrimWarningsMessage();
    internal static string get_TypeWasNotFoundInAssemblyNorBaseLibraryTitle();
    internal static string get_TypeWasNotFoundInAssemblyNorBaseLibraryMessage();
    internal static string get_DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_MethodsAreAssociatedWithStateMachineTitle();
    internal static string get_MethodsAreAssociatedWithStateMachineMessage();
    internal static string get_InvalidScopeInUnconditionalSuppressMessageTitle();
    internal static string get_InvalidScopeInUnconditionalSuppressMessageMessage();
    internal static string get_RequiresUnreferencedCodeOnBaseClassTitle();
    internal static string get_RequiresUnreferencedCodeOnBaseClassMessage();
    internal static string get_DynamicallyAccessedMembersFieldAccessedViaReflectionTitle();
    internal static string get_DynamicallyAccessedMembersFieldAccessedViaReflectionMessage();
    internal static string get_DynamicallyAccessedMembersMethodAccessedViaReflectionTitle();
    internal static string get_DynamicallyAccessedMembersMethodAccessedViaReflectionMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersMessage();
    internal static string get_RequiresUnreferencedCodeOnStaticConstructorTitle();
    internal static string get_RequiresUnreferencedCodeOnStaticConstructorMessage();
    internal static string get_MethodsAreAssociatedWithUserMethodTitle();
    internal static string get_MethodsAreAssociatedWithUserMethodMessage();
    internal static string get_CompilerGeneratedMemberAccessedViaReflectionTitle();
    internal static string get_CompilerGeneratedMemberAccessedViaReflectionMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseMessage();
    internal static string get_AvoidAssemblyLocationInSingleFileTitle();
    internal static string get_AvoidAssemblyLocationInSingleFileMessage();
    internal static string get_AvoidAssemblyGetFilesInSingleFileTitle();
    internal static string get_AvoidAssemblyGetFilesInSingleFileMessage();
    internal static string get_RequiresAssemblyFilesTitle();
    internal static string get_RequiresAssemblyFilesMessage();
    internal static string get_RequiresAssemblyFilesAttributeMismatchTitle();
    internal static string get_RequiresAssemblyFilesAttributeMismatchMessage();
    internal static string get_RequiresDynamicCodeTitle();
    internal static string get_RequiresDynamicCodeMessage();
    internal static string get_RequiresDynamicCodeAttributeMismatchTitle();
    internal static string get_RequiresDynamicCodeAttributeMismatchMessage();
    internal static string get_COMInteropNotSupportedInFullAOTTitle();
    internal static string get_COMInteropNotSupportedInFullAOTMessage();
    internal static string get_AssemblyProducedAOTWarningsTitle();
    internal static string get_AssemblyProducedAOTWarningsMessage();
    internal static string get_GenericRecursionCycleTitle();
    internal static string get_GenericRecursionCycleMessage();
    internal static string get_CorrectnessOfAbstractDelegatesCannotBeGuaranteedTitle();
    internal static string get_CorrectnessOfAbstractDelegatesCannotBeGuaranteedMessage();
    internal static string get_BaseRequiresMismatchMessage();
    internal static string get_DerivedRequiresMismatchMessage();
    internal static string get_ImplementationRequiresMismatchMessage();
    internal static string get_InterfaceRequiresMismatchMessage();
    internal static string get_RequiresOnBaseClassMessage();
    internal static string get_RequiresOnBaseClassTitle();
    internal static string get_RequiresDynamicCodeOnStaticConstructorMessage();
    internal static string get_RequiresDynamicCodeOnStaticConstructorTitle();
    internal static string get_RequiresAssemblyFilesOnStaticConstructorMessage();
    internal static string get_RequiresAssemblyFilesOnStaticConstructorTitle();
    internal static string get_UnrecognizedInternalAttributeMessage();
    internal static string get_UnrecognizedInternalAttributeTitle();
    internal static string get_InvalidDependenciesFileFormatMessage();
    internal static string get_InvalidDependenciesFileFormatTitle();
    internal static string get_RedundantSuppressionMessage();
    internal static string get_RedundantSuppressionTitle();
}
internal class ILLink.Shared.TrimAnalysis.ArrayValue : SingleValue {
    public Dictionary`2<int, ValueSet`1<SingleValue>> IndexValues;
    public SingleValue Size;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    private static ValueSetLattice`1<SingleValue> MultiValueLattice { get; }
    private ArrayValue(SingleValue size);
    [CompilerGeneratedAttribute]
private ArrayValue(ArrayValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public static ValueSet`1<SingleValue> Create(ValueSet`1<SingleValue> size);
    public static ValueSet`1<SingleValue> Create(int size);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(ArrayValue otherArr);
    public virtual SingleValue DeepCopy();
    private static ValueSetLattice`1<SingleValue> get_MultiValueLattice();
    public bool TryGetValueByIndex(int index, ValueSet`1& value);
    public static ValueSet`1<SingleValue> SanitizeArrayElementValue(ValueSet`1<SingleValue> input);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ArrayValue left, ArrayValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ArrayValue left, ArrayValue right);
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.ConstIntValue : SingleValue {
    public int Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ConstIntValue(int value);
    [CompilerGeneratedAttribute]
private ConstIntValue(ConstIntValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ConstIntValue left, ConstIntValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ConstIntValue left, ConstIntValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConstIntValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
[IsReadOnlyAttribute]
internal class ILLink.Shared.TrimAnalysis.DiagnosticContext : ValueType {
    [CompilerGeneratedAttribute]
private List`1<Diagnostic> <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    public List`1<Diagnostic> Diagnostics { get; }
    private Location Location { get; private set; }
    public DiagnosticContext(Location location);
    [CompilerGeneratedAttribute]
public List`1<Diagnostic> get_Diagnostics();
    [CompilerGeneratedAttribute]
private Location get_Location();
    [CompilerGeneratedAttribute]
private Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Location(Location value);
    public static DiagnosticContext CreateDisabled();
    public void AddDiagnostic(DiagnosticId id, String[] args);
    public void AddDiagnostic(DiagnosticId id, ValueWithDynamicallyAccessedMembers actualValue, ValueWithDynamicallyAccessedMembers expectedAnnotationsValue, String[] args);
}
internal class ILLink.Shared.TrimAnalysis.FieldValue : ValueWithDynamicallyAccessedMembers {
    public IFieldSymbol FieldSymbol;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public FieldValue(IFieldSymbol fieldSymbol);
    [CompilerGeneratedAttribute]
private FieldValue(FieldValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FieldValue left, FieldValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FieldValue left, FieldValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FieldValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.Shared.TrimAnalysis.FlowAnnotations : object {
    private static Lazy`1<FlowAnnotations> _instance;
    public static FlowAnnotations Instance { get; }
    private static FlowAnnotations();
    public static FlowAnnotations get_Instance();
    public static bool RequiresDataFlowAnalysis(IMethodSymbol method);
    internal static DynamicallyAccessedMemberTypes GetMethodParameterAnnotation(ParameterProxy param);
    public static DynamicallyAccessedMemberTypes GetMethodReturnValueAnnotation(IMethodSymbol method);
    internal MethodParameterValue GetMethodThisParameterValue(MethodProxy method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes, bool overrideIsThis);
    internal MethodParameterValue GetMethodParameterValue(MethodProxy method, ParameterIndex parameterIndex, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal bool MethodRequiresDataFlowAnalysis(MethodProxy method);
    internal MethodReturnValue GetMethodReturnValue(MethodProxy method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal MethodReturnValue GetMethodReturnValue(MethodProxy method);
    internal GenericParameterValue GetGenericParameterValue(GenericParameterProxy genericParameter);
    internal MethodParameterValue GetMethodThisParameterValue(MethodProxy method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal MethodParameterValue GetMethodThisParameterValue(MethodProxy method);
    internal MethodParameterValue GetMethodParameterValue(ParameterProxy param, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal MethodParameterValue GetMethodParameterValue(ParameterProxy param);
}
internal class ILLink.Shared.TrimAnalysis.GenericParameterValue : ValueWithDynamicallyAccessedMembers {
    public GenericParameterProxy GenericParameter;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public GenericParameterValue(ITypeParameterSymbol typeParameterSymbol);
    [CompilerGeneratedAttribute]
private GenericParameterValue(GenericParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(GenericParameterValue left, GenericParameterValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(GenericParameterValue left, GenericParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(GenericParameterValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.HandleCallAction : ValueType {
    private ISymbol _owningSymbol;
    private IOperation _operation;
    private ReflectionAccessAnalyzer _reflectionAccessAnalyzer;
    private DiagnosticContext _diagnosticContext;
    private FlowAnnotations _annotations;
    private RequireDynamicallyAccessedMembersAction _requireDynamicallyAccessedMembersAction;
    private static ValueSetLattice`1<SingleValue> MultiValueLattice { get; }
    public HandleCallAction(DiagnosticContext& diagnosticContext, ISymbol owningSymbol, IOperation operation);
    private static ValueSetLattice`1<SingleValue> get_MultiValueLattice();
    public bool Invoke(MethodProxy calledMethod, ValueSet`1<SingleValue> instanceValue, IReadOnlyList`1<ValueSet`1<SingleValue>> argumentValues, IntrinsicId intrinsicId, ValueSet`1& methodReturnValue);
    [IteratorStateMachineAttribute("ILLink.Shared.TrimAnalysis.HandleCallAction/<ProcessGetMethodByName>d__10")]
private IEnumerable`1<ValueSet`1<SingleValue>> ProcessGetMethodByName(TypeProxy type, string methodName, Nullable`1<BindingFlags> bindingFlags);
    private bool AnalyzeGenericInstantiationTypeArray(ValueSet`1& arrayParam, MethodProxy& calledMethod, ImmutableArray`1<GenericParameterValue> genericParameters);
    private void ValidateGenericMethodInstantiation(MethodProxy genericMethod, ValueSet`1& genericParametersArray, MethodProxy reflectionMethod);
    private ImmutableArray`1<GenericParameterValue> GetGenericParameterValues(ImmutableArray`1<GenericParameterProxy> genericParameters);
    private void ProcessCreateInstanceByName(MethodProxy calledMethod, IReadOnlyList`1<ValueSet`1<SingleValue>> argumentValues);
    internal static Nullable`1<BindingFlags> GetBindingFlagsFromValue(ValueSet`1& parameter);
    internal static bool BindingFlagsAreUnsupported(Nullable`1<BindingFlags> bindingFlags);
    internal static bool HasBindingFlag(Nullable`1<BindingFlags> bindingFlags, Nullable`1<BindingFlags> search);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForNestedTypes(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForConstructors(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForMethods(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForFields(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForProperties(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForEvents(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForMembers(Nullable`1<BindingFlags> bindingFlags);
    private bool MethodIsTypeConstructor(MethodProxy method);
    private IEnumerable`1<SystemReflectionMethodBaseValue> GetMethodsOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private IEnumerable`1<SystemTypeValue> GetNestedTypesOnType(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private bool TryGetBaseType(TypeProxy type, Nullable`1& baseType);
    private bool TryResolveTypeNameForCreateInstanceAndMark(MethodProxy& calledMethod, string assemblyName, string typeName, TypeProxy& resolvedType);
    private void MarkStaticConstructor(TypeProxy type);
    private void MarkEventsOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private void MarkFieldsOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private void MarkPropertiesOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private void MarkPublicParameterlessConstructorOnType(TypeProxy type);
    private void MarkConstructorsOnType(TypeProxy type, Nullable`1<BindingFlags> bindingFlags, Nullable`1<int> parameterCount);
    private void MarkMethod(MethodProxy method);
    private void MarkType(TypeProxy type);
    private bool MarkAssociatedProperty(MethodProxy method);
    private string GetContainingSymbolDisplayName();
    [CompilerGeneratedAttribute]
internal static void <Invoke>g__AddReturnValue|9_0(ValueSet`1<SingleValue> value, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static DynamicallyAccessedMemberTypes <AnalyzeGenericInstantiationTypeArray>g__GetGenericParameterEffectiveMemberTypes|11_0(GenericParameterValue genericParameter);
}
internal enum ILLink.Shared.TrimAnalysis.IntrinsicId : Enum {
    public int value__;
    public static IntrinsicId None;
    public static IntrinsicId IntrospectionExtensions_GetTypeInfo;
    public static IntrinsicId Type_GetTypeFromHandle;
    public static IntrinsicId Type_get_TypeHandle;
    public static IntrinsicId Object_GetType;
    public static IntrinsicId TypeDelegator_Ctor;
    public static IntrinsicId Array_Empty;
    public static IntrinsicId TypeInfo_AsType;
    public static IntrinsicId MethodBase_GetMethodFromHandle;
    public static IntrinsicId MethodBase_get_MethodHandle;
    public static IntrinsicId RequiresReflectionBodyScanner_Sentinel;
    public static IntrinsicId Type_MakeGenericType;
    public static IntrinsicId Type_GetType;
    public static IntrinsicId Type_GetConstructor;
    public static IntrinsicId Type_GetConstructors__BindingFlags;
    public static IntrinsicId Type_GetMethod;
    public static IntrinsicId Type_GetMethods__BindingFlags;
    public static IntrinsicId Type_GetField;
    public static IntrinsicId Type_GetFields__BindingFlags;
    public static IntrinsicId Type_GetProperty;
    public static IntrinsicId Type_GetProperties__BindingFlags;
    public static IntrinsicId Type_GetEvent;
    public static IntrinsicId Type_GetEvents__BindingFlags;
    public static IntrinsicId Type_GetNestedType;
    public static IntrinsicId Type_GetNestedTypes__BindingFlags;
    public static IntrinsicId Type_GetMember;
    public static IntrinsicId Type_GetMembers__BindingFlags;
    public static IntrinsicId Type_GetInterface;
    public static IntrinsicId Type_get_AssemblyQualifiedName;
    public static IntrinsicId Type_get_UnderlyingSystemType;
    public static IntrinsicId Type_get_BaseType;
    public static IntrinsicId Expression_Call;
    public static IntrinsicId Expression_Field;
    public static IntrinsicId Expression_Property;
    public static IntrinsicId Expression_New;
    public static IntrinsicId Enum_GetValues;
    public static IntrinsicId Marshal_SizeOf;
    public static IntrinsicId Marshal_OffsetOf;
    public static IntrinsicId Marshal_PtrToStructure;
    public static IntrinsicId Marshal_DestroyStructure;
    public static IntrinsicId Marshal_GetDelegateForFunctionPointer;
    public static IntrinsicId Activator_CreateInstance__Type;
    public static IntrinsicId Activator_CreateInstance__AssemblyName_TypeName;
    public static IntrinsicId Activator_CreateInstanceFrom;
    public static IntrinsicId AppDomain_CreateInstance;
    public static IntrinsicId AppDomain_CreateInstanceAndUnwrap;
    public static IntrinsicId AppDomain_CreateInstanceFrom;
    public static IntrinsicId AppDomain_CreateInstanceFromAndUnwrap;
    public static IntrinsicId Assembly_CreateInstance;
    public static IntrinsicId Assembly_get_Location;
    public static IntrinsicId Assembly_GetFile;
    public static IntrinsicId Assembly_GetFiles;
    public static IntrinsicId AssemblyName_get_CodeBase;
    public static IntrinsicId AssemblyName_get_EscapedCodeBase;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeEvent;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeField;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeMethod;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeProperty;
    public static IntrinsicId RuntimeHelpers_RunClassConstructor;
    public static IntrinsicId MethodInfo_MakeGenericMethod;
    public static IntrinsicId Nullable_GetUnderlyingType;
}
internal static class ILLink.Shared.TrimAnalysis.Intrinsics : object {
    public static IntrinsicId GetIntrinsicIdForMethod(MethodProxy calledMethod);
}
internal class ILLink.Shared.TrimAnalysis.KnownStringValue : SingleValue {
    public string Contents;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public KnownStringValue(string contents);
    [CompilerGeneratedAttribute]
private KnownStringValue(KnownStringValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(KnownStringValue left, KnownStringValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(KnownStringValue left, KnownStringValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(KnownStringValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.MethodParameterValue : ValueWithDynamicallyAccessedMembers {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    private bool _overrideIsThis;
    [CompilerGeneratedAttribute]
private ParameterProxy <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public IMethodSymbol MethodSymbol { get; }
    public ParameterProxy Parameter { get; }
    public ParameterIndex Index { get; }
    public MethodParameterValue(IParameterSymbol parameterSymbol);
    public MethodParameterValue(IMethodSymbol methodSymbol, ParameterIndex parameterIndex, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    public MethodParameterValue(ParameterProxy parameter);
    public MethodParameterValue(ParameterProxy parameter, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes, bool overrideIsThis);
    [CompilerGeneratedAttribute]
private MethodParameterValue(MethodParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public IMethodSymbol get_MethodSymbol();
    [CompilerGeneratedAttribute]
public ParameterProxy get_Parameter();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual string ToString();
    public bool IsThisParameter();
    public virtual SingleValue DeepCopy();
    public ParameterIndex get_Index();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MethodParameterValue left, MethodParameterValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MethodParameterValue left, MethodParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodParameterValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.MethodReturnValue : ValueWithDynamicallyAccessedMembers {
    public IMethodSymbol MethodSymbol;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public MethodReturnValue(IMethodSymbol methodSymbol);
    public MethodReturnValue(IMethodSymbol methodSymbol, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    [CompilerGeneratedAttribute]
private MethodReturnValue(MethodReturnValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MethodReturnValue left, MethodReturnValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MethodReturnValue left, MethodReturnValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodReturnValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.NullableSystemTypeValue : SingleValue {
    public TypeProxy NullableType;
    public SystemTypeValue UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public NullableSystemTypeValue(TypeProxy& nullableType, SystemTypeValue& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private NullableSystemTypeValue(NullableSystemTypeValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NullableSystemTypeValue left, NullableSystemTypeValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NullableSystemTypeValue left, NullableSystemTypeValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullableSystemTypeValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.NullableValueWithDynamicallyAccessedMembers : ValueWithDynamicallyAccessedMembers {
    public TypeProxy NullableType;
    public ValueWithDynamicallyAccessedMembers UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public NullableValueWithDynamicallyAccessedMembers(TypeProxy& nullableType, ValueWithDynamicallyAccessedMembers& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private NullableValueWithDynamicallyAccessedMembers(NullableValueWithDynamicallyAccessedMembers original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NullableValueWithDynamicallyAccessedMembers left, NullableValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NullableValueWithDynamicallyAccessedMembers left, NullableValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullableValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.NullValue : SingleValue {
    [CompilerGeneratedAttribute]
private static NullValue <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public static NullValue Instance { get; }
    [CompilerGeneratedAttribute]
private NullValue(NullValue original);
    private static NullValue();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public static NullValue get_Instance();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NullValue left, NullValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NullValue left, NullValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.RequireDynamicallyAccessedMembersAction : ValueType {
    private ReflectionAccessAnalyzer _reflectionAccessAnalyzer;
    private DiagnosticContext _diagnosticContext;
    public RequireDynamicallyAccessedMembersAction(DiagnosticContext diagnosticContext, ReflectionAccessAnalyzer reflectionAccessAnalyzer);
    public void Invoke(ValueSet`1& value, ValueWithDynamicallyAccessedMembers targetValue);
    public bool TryResolveTypeNameAndMark(string typeName, bool needsAssemblyName, TypeProxy& type);
    private void MarkTypeForDynamicallyAccessedMembers(TypeProxy& type, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
}
internal class ILLink.Shared.TrimAnalysis.RuntimeMethodHandleValue : SingleValue {
    public MethodProxy RepresentedMethod;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeMethodHandleValue(MethodProxy& representedMethod);
    [CompilerGeneratedAttribute]
private RuntimeMethodHandleValue(RuntimeMethodHandleValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeMethodHandleValue left, RuntimeMethodHandleValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeMethodHandleValue left, RuntimeMethodHandleValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeMethodHandleValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleForGenericParameterValue : SingleValue {
    public GenericParameterProxy GenericParameter;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleForGenericParameterValue(GenericParameterProxy genericParameter);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleForGenericParameterValue(RuntimeTypeHandleForGenericParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleForGenericParameterValue left, RuntimeTypeHandleForGenericParameterValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleForGenericParameterValue left, RuntimeTypeHandleForGenericParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleForGenericParameterValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleForNullableSystemTypeValue : SingleValue {
    public TypeProxy NullableType;
    public SystemTypeValue UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleForNullableSystemTypeValue(TypeProxy& nullableType, SystemTypeValue& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleForNullableSystemTypeValue(RuntimeTypeHandleForNullableSystemTypeValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleForNullableSystemTypeValue left, RuntimeTypeHandleForNullableSystemTypeValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleForNullableSystemTypeValue left, RuntimeTypeHandleForNullableSystemTypeValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleForNullableSystemTypeValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers : SingleValue {
    public TypeProxy NullableType;
    public SingleValue UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers(TypeProxy& nullableType, SingleValue& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers left, RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers left, RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleValue : SingleValue {
    public TypeProxy RepresentedType;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleValue(TypeProxy& representedType);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleValue(RuntimeTypeHandleValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleValue left, RuntimeTypeHandleValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleValue left, RuntimeTypeHandleValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.SystemReflectionMethodBaseValue : SingleValue {
    public MethodProxy RepresentedMethod;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SystemReflectionMethodBaseValue(MethodProxy representedMethod);
    [CompilerGeneratedAttribute]
private SystemReflectionMethodBaseValue(SystemReflectionMethodBaseValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SystemReflectionMethodBaseValue left, SystemReflectionMethodBaseValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SystemReflectionMethodBaseValue left, SystemReflectionMethodBaseValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SystemReflectionMethodBaseValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.SystemTypeValue : SingleValue {
    public TypeProxy RepresentedType;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SystemTypeValue(TypeProxy& representedType);
    [CompilerGeneratedAttribute]
private SystemTypeValue(SystemTypeValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SystemTypeValue left, SystemTypeValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SystemTypeValue left, SystemTypeValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SystemTypeValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
internal class ILLink.Shared.TrimAnalysis.UnknownValue : SingleValue {
    [CompilerGeneratedAttribute]
private static UnknownValue <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public static UnknownValue Instance { get; }
    [CompilerGeneratedAttribute]
private UnknownValue(UnknownValue original);
    private static UnknownValue();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public static UnknownValue get_Instance();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(UnknownValue left, UnknownValue right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(UnknownValue left, UnknownValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnknownValue other);
    [CompilerGeneratedAttribute]
public virtual SingleValue <Clone>$();
}
[ExtensionAttribute]
internal static class ILLink.Shared.TrimAnalysis.ValueExtensions : object {
    private static Enumerable<SingleValue> Unknown;
    private static ValueExtensions();
    [ExtensionAttribute]
internal static string ValueToString(SingleValue value, Object[] args);
    [ExtensionAttribute]
internal static Nullable`1<int> AsConstInt(SingleValue value);
    [ExtensionAttribute]
internal static Nullable`1<int> AsConstInt(ValueSet`1& value);
    [ExtensionAttribute]
internal static SingleValue AsSingleValue(ValueSet`1& node);
    [ExtensionAttribute]
internal static Enumerable<SingleValue> AsEnumerable(ValueSet`1<SingleValue> multiValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ILLink.Shared.TrimAnalysis.ValueWithDynamicallyAccessedMembers : SingleValue {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    [CompilerGeneratedAttribute]
protected ValueWithDynamicallyAccessedMembers(ValueWithDynamicallyAccessedMembers original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public abstract virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ValueWithDynamicallyAccessedMembers left, ValueWithDynamicallyAccessedMembers right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ValueWithDynamicallyAccessedMembers left, ValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [CompilerGeneratedAttribute]
public abstract virtual SingleValue <Clone>$();
}
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.GenericParameterProxy : ValueType {
    public ITypeParameterSymbol TypeParameterSymbol;
    public GenericParameterProxy(ITypeParameterSymbol typeParameterSymbol);
    public virtual string ToString();
    internal bool HasDefaultConstructorConstraint();
}
internal interface ILLink.Shared.TypeSystemProxy.IMemberProxy {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual string GetDisplayName();
}
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.MethodProxy : ValueType {
    public IMethodSymbol Method;
    public string Name { get; }
    public MethodProxy(IMethodSymbol method);
    public sealed virtual string get_Name();
    public sealed virtual string GetDisplayName();
    private static bool IsTypeOf(ITypeSymbol type, string fullTypeName);
    public virtual string ToString();
    internal bool IsDeclaredOnType(string fullTypeName);
    internal int GetMetadataParametersCount();
    internal bool HasMetadataParameters();
    internal int GetParametersCount();
    internal ParameterProxyEnumerable GetParameters();
    internal ParameterProxy GetParameter(ParameterIndex index);
    internal bool HasMetadataParametersCount(int parameterCount);
    internal bool HasParameterOfType(ParameterIndex parameterIndex, string fullTypeName);
    internal bool HasGenericParameters();
    internal bool HasGenericParametersCount(int genericParameterCount);
    internal ImmutableArray`1<GenericParameterProxy> GetGenericParameters();
    internal bool IsStatic();
    internal bool HasImplicitThis();
    internal bool ReturnsVoid();
}
[IsReadOnlyAttribute]
public class ILLink.Shared.TypeSystemProxy.ParameterIndex : ValueType {
    public int Index;
    public ParameterIndex(int x);
    public static bool op_Equality(ParameterIndex left, ParameterIndex right);
    public static bool op_Inequality(ParameterIndex left, ParameterIndex right);
    public static ParameterIndex op_Increment(ParameterIndex val);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParameterIndex other);
    public virtual int GetHashCode();
    public static ParameterIndex op_Explicit(int x);
    public static int op_Explicit(ParameterIndex x);
    public static ParameterIndex op_Addition(ParameterIndex left, ParameterIndex right);
    public static ParameterIndex op_Subtraction(ParameterIndex left, ParameterIndex right);
    public static ParameterIndex op_Addition(ParameterIndex left, int right);
    public static ParameterIndex op_Subtraction(ParameterIndex left, int right);
}
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.ParameterProxy : ValueType {
    [CompilerGeneratedAttribute]
private MethodProxy <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterIndex <Index>k__BackingField;
    public IParameterSymbol ParameterSymbol { get; }
    public Location Location { get; }
    public TypeProxy ParameterType { get; }
    public MethodProxy Method { get; }
    public ParameterIndex Index { get; }
    public int MetadataIndex { get; }
    public bool IsImplicitThis { get; }
    public ParameterProxy(IParameterSymbol parameter);
    public ParameterProxy(MethodProxy method, ParameterIndex index);
    public IParameterSymbol get_ParameterSymbol();
    public Location get_Location();
    public TypeProxy get_ParameterType();
    public bool IsTypeOf(WellKnownType type);
    [CompilerGeneratedAttribute]
public MethodProxy get_Method();
    [CompilerGeneratedAttribute]
public ParameterIndex get_Index();
    public int get_MetadataIndex();
    public ReferenceKind GetReferenceKind();
    public string GetDisplayName();
    public bool get_IsImplicitThis();
    public bool IsTypeOf(string typeName);
    public IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
}
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.ParameterProxyEnumerable : ValueType {
    private int _start;
    private int _end;
    private MethodProxy _method;
    public ParameterProxyEnumerable(int start, int end, MethodProxy method);
    public ParameterEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<ParameterProxy> System.Collections.Generic.IEnumerable<ILLink.Shared.TypeSystemProxy.ParameterProxy>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum ILLink.Shared.TypeSystemProxy.ReferenceKind : Enum {
    public int value__;
    public static ReferenceKind Ref;
    public static ReferenceKind In;
    public static ReferenceKind Out;
    public static ReferenceKind None;
}
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.TypeProxy : ValueType {
    public ITypeSymbol Type;
    public string Name { get; }
    public string Namespace { get; }
    public TypeProxy(ITypeSymbol type);
    public sealed virtual string get_Name();
    public string get_Namespace();
    public bool IsTypeOf(string namespace, string name);
    public bool IsTypeOf(WellKnownType wellKnownType);
    public sealed virtual string GetDisplayName();
    public virtual string ToString();
    internal ImmutableArray`1<GenericParameterProxy> GetGenericParameters();
}
public enum ILLink.Shared.TypeSystemProxy.WellKnownType : Enum {
    public int value__;
    public static WellKnownType System_String;
    public static WellKnownType System_Nullable_T;
    public static WellKnownType System_Type;
    public static WellKnownType System_Reflection_IReflect;
    public static WellKnownType System_Array;
    public static WellKnownType System_Object;
    public static WellKnownType System_Attribute;
    public static WellKnownType System_NotSupportedException;
    public static WellKnownType System_Runtime_CompilerServices_DisablePrivateReflectionAttribute;
    public static WellKnownType System_Void;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.Shared.TypeSystemProxy.WellKnownTypeExtensions : object {
    [ExtensionAttribute]
public static ValueTuple`2<string, string> GetNamespaceAndName(WellKnownType type);
    [ExtensionAttribute]
public static string GetNamespace(WellKnownType type);
    [ExtensionAttribute]
public static string GetName(WellKnownType type);
    public static Nullable`1<WellKnownType> GetWellKnownType(string namespace, string name);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<DescendantOperations>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(BasicBlock basicBlock);
}
internal static class Microsoft.CodeAnalysis.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    [DebuggerStepThroughAttribute]
public static void EnsureSufficientExecutionStack(int recursionDepth);
}
[AttributeUsageAttribute("16")]
[ConditionalAttribute("EMIT_STATICCS_CLOSEDATTRIBUTE")]
internal class StaticCs.ClosedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[FlagsAttribute]
public enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
public class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
