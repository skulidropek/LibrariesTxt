internal static class Microsoft.Build.BackEnd.BinaryTranslator : object {
    [NullableContextAttribute("1")]
internal static ITranslator GetReadTranslator(Stream stream, BinaryReaderFactory buffer);
    internal static ITranslator GetWriteTranslator(Stream stream);
}
internal interface Microsoft.Build.BackEnd.ITranslatable {
    public abstract virtual void Translate(ITranslator translator);
}
internal interface Microsoft.Build.BackEnd.ITranslator {
    public TranslationDirection Mode { get; }
    public BinaryReader Reader { get; }
    public BinaryWriter Writer { get; }
    public abstract virtual TranslationDirection get_Mode();
    public abstract virtual BinaryReader get_Reader();
    public abstract virtual BinaryWriter get_Writer();
    public abstract virtual void Translate(Boolean& value);
    public abstract virtual void Translate(Boolean[]& array);
    public abstract virtual void Translate(Byte& value);
    public abstract virtual void Translate(Int16& value);
    public abstract virtual void Translate(UInt16& value);
    public abstract virtual void Translate(Int32& value);
    public abstract virtual void Translate(UInt32& unsignedInteger);
    public abstract virtual void Translate(Int32[]& array);
    public abstract virtual void Translate(Int64& value);
    public abstract virtual void Translate(String& value);
    public abstract virtual void Translate(Double& value);
    public abstract virtual void Translate(String[]& array);
    public abstract virtual void Translate(List`1& list);
    public abstract virtual void Translate(HashSet`1& set);
    public abstract virtual void Translate(List`1& list, ObjectTranslator`1<T> objectTranslator);
    public abstract virtual void Translate(IList`1& list, ObjectTranslator`1<T> objectTranslator, NodePacketCollectionCreator`1<L> collectionFactory);
    public abstract virtual void Translate(ICollection`1& collection, ObjectTranslator`1<T> objectTranslator, NodePacketCollectionCreator`1<L> collectionFactory);
    public abstract virtual void Translate(DateTime& value);
    public abstract virtual void Translate(TimeSpan& value);
    public abstract virtual void Translate(BuildEventContext& value);
    public abstract virtual void TranslateEnum(T& value, int numericValue);
    public abstract virtual void TranslateDotNet(T& value);
    public abstract virtual void TranslateException(Exception& value);
    public abstract virtual void Translate(T& value);
    public abstract virtual void TranslateCulture(CultureInfo& culture);
    public abstract virtual void Translate(Byte[]& byteArray);
    public abstract virtual void Translate(Byte[]& byteArray, Int32& length);
    public abstract virtual void TranslateArray(T[]& array);
    public abstract virtual void TranslateArray(T[]& array, ObjectTranslator`1<T> objectTranslator);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, IEqualityComparer`1<string> comparer);
    public abstract virtual void TranslateDictionary(IDictionary`2& dictionary, NodePacketCollectionCreator`1<IDictionary`2<string, string>> collectionCreator);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, StringComparer comparer);
    public abstract virtual void TranslateDictionary(IDictionary`2& dictionary, ObjectTranslator`1<K> keyTranslator, ObjectTranslator`1<V> valueTranslator, NodePacketCollectionCreator`1<IDictionary`2<K, V>> dictionaryCreator);
    public abstract virtual void TranslateDictionary(Dictionary`2& dictionary, IEqualityComparer`1<string> comparer, ObjectTranslator`1<T> objectTranslator);
    public abstract virtual void TranslateDictionary(D& dictionary, ObjectTranslator`1<T> objectTranslator);
    public abstract virtual void TranslateDictionary(D& dictionary, ObjectTranslator`1<T> objectTranslator, NodePacketCollectionCreator`1<D> collectionCreator);
    public abstract virtual bool TranslateNullable(T value);
}
internal class Microsoft.Build.BackEnd.NodePacketCollectionCreator`1 : MulticastDelegate {
    public NodePacketCollectionCreator`1(object object, IntPtr method);
    public virtual T Invoke(int capacity);
    public virtual IAsyncResult BeginInvoke(int capacity, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodePacketValueFactory`1 : MulticastDelegate {
    public NodePacketValueFactory`1(object object, IntPtr method);
    public virtual T Invoke(ITranslator translator);
    public virtual IAsyncResult BeginInvoke(ITranslator translator, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ObjectTranslator`1 : MulticastDelegate {
    public ObjectTranslator`1(object object, IntPtr method);
    public virtual void Invoke(ITranslator translator, T& objectToTranslate);
    public virtual IAsyncResult BeginInvoke(ITranslator translator, T& objectToTranslate, AsyncCallback callback, object object);
    public virtual void EndInvoke(T& objectToTranslate, IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.TranslationDirection : Enum {
    public int value__;
    public static TranslationDirection WriteToStream;
    public static TranslationDirection ReadFromStream;
}
internal abstract class Microsoft.Build.BinaryReaderFactory : object {
    [NullableContextAttribute("1")]
public abstract virtual BinaryReader Create(Stream stream);
}
[EventSourceAttribute]
internal class Microsoft.Build.Eventing.MSBuildEventSource : EventSource {
    public static MSBuildEventSource Log;
    private static MSBuildEventSource();
    [EventAttribute("1")]
public void ApplyLazyItemOperationsStart(string itemType);
    [EventAttribute("2")]
public void ApplyLazyItemOperationsStop(string itemType);
    [EventAttribute("3")]
public void BuildStart();
    [EventAttribute("4")]
public void BuildStop();
    [EventAttribute("5")]
public void BuildProjectStart(string projectPath);
    [EventAttribute("6")]
public void BuildProjectStop(string projectPath, string targets);
    [EventAttribute("7")]
public void RarComputeClosureStart();
    [EventAttribute("8")]
public void RarComputeClosureStop();
    [EventAttribute("9")]
public void EvaluateConditionStart(string condition);
    [EventAttribute("10")]
public void EvaluateConditionStop(string condition, bool result);
    [EventAttribute("11")]
public void EvaluateStart(string projectFile);
    [EventAttribute("12")]
public void EvaluateStop(string projectFile);
    [EventAttribute("13")]
public void EvaluatePass0Start(string projectFile);
    [EventAttribute("14")]
public void EvaluatePass0Stop(string projectFile);
    [EventAttribute("15")]
public void EvaluatePass1Start(string projectFile);
    [EventAttribute("16")]
public void EvaluatePass1Stop(string projectFile);
    [EventAttribute("17")]
public void EvaluatePass2Start(string projectFile);
    [EventAttribute("18")]
public void EvaluatePass2Stop(string projectFile);
    [EventAttribute("19")]
public void EvaluatePass3Start(string projectFile);
    [EventAttribute("20")]
public void EvaluatePass3Stop(string projectFile);
    [EventAttribute("21")]
public void EvaluatePass4Start(string projectFile);
    [EventAttribute("22")]
public void EvaluatePass4Stop(string projectFile);
    [EventAttribute("23")]
public void EvaluatePass5Start(string projectFile);
    [EventAttribute("24")]
public void EvaluatePass5Stop(string projectFile);
    [EventAttribute("25")]
public void GenerateResourceOverallStart();
    [EventAttribute("26")]
public void GenerateResourceOverallStop();
    [EventAttribute("27")]
public void RarOverallStart();
    [EventAttribute("28")]
public void RarOverallStop(int assembliesCount, int assemblyFilesCount, int resolvedFilesCount, int resolvedDependencyFilesCount, int copyLocalFilesCount, bool findDependencies);
    [EventAttribute("41")]
public void ExpandGlobStart(string rootDirectory, string glob, string excludedPatterns);
    [EventAttribute("42")]
public void ExpandGlobStop(string rootDirectory, string glob, string excludedPatterns);
    [EventAttribute("29")]
public void LoadDocumentStart(string fullPath);
    [EventAttribute("30")]
public void LoadDocumentStop(string fullPath);
    [EventAttribute("31")]
public void RarLogResultsStart();
    [EventAttribute("32")]
public void RarLogResultsStop();
    [EventAttribute("33")]
public void ParseStart(string projectFileName);
    [EventAttribute("34")]
public void ParseStop(string projectFileName);
    [EventAttribute("35")]
public void RarRemoveReferencesMarkedForExclusionStart();
    [EventAttribute("36")]
public void RarRemoveReferencesMarkedForExclusionStop();
    [EventAttribute("37")]
public void RequestThreadProcStart();
    [EventAttribute("38")]
public void RequestThreadProcStop();
    [EventAttribute("39")]
public void SaveStart(string fileLocation);
    [EventAttribute("40")]
public void SaveStop(string fileLocation);
    [EventAttribute("43")]
public void TargetStart(string targetName);
    [EventAttribute("44")]
public void TargetStop(string targetName);
    [EventAttribute("45")]
public void MSBuildExeStart(string commandLine);
    [EventAttribute("46")]
public void MSBuildExeStop(string commandLine);
    [EventAttribute("47")]
public void ExecuteTaskStart(string taskName, int taskID);
    [EventAttribute("48")]
public void ExecuteTaskStop(string taskName, int taskID);
    [EventAttribute("49")]
public void ExecuteTaskYieldStart(string taskName, int taskID);
    [EventAttribute("50")]
public void ExecuteTaskYieldStop(string taskName, int taskID);
    [EventAttribute("51")]
public void ExecuteTaskReacquireStart(string taskName, int taskID);
    [EventAttribute("52")]
public void ExecuteTaskReacquireStop(string taskName, int taskID);
    [EventAttribute("53")]
public void ProjectGraphConstructionStart(string graphEntryPoints);
    [EventAttribute("54")]
public void ProjectGraphConstructionStop(string graphEntryPoints);
    [EventAttribute("55")]
public void PacketReadSize(int size);
    [EventAttribute("56")]
public void TargetUpToDateStart();
    [EventAttribute("57")]
public void TargetUpToDateStop(int result);
    [EventAttribute("58")]
public void CopyUpToDateStart(string path);
    [EventAttribute("59")]
public void CopyUpToDateStop(string path, bool wasUpToDate);
    [EventAttribute("60")]
public void WriteLinesToFileUpToDateStart();
    [EventAttribute("61")]
public void WriteLinesToFileUpToDateStop(string fileItemSpec, bool wasUpToDate);
    [EventAttribute("62")]
public void SdkResolverServiceInitializeStart();
    [EventAttribute("63")]
public void SdkResolverServiceInitializeStop(int resolverCount);
    [EventAttribute("64")]
public void SdkResolverResolveSdkStart();
    [EventAttribute("65")]
public void SdkResolverResolveSdkStop(string resolverName, string sdkName, string solutionPath, string projectPath, string sdkPath, bool success);
    [EventAttribute("66")]
public void CachedSdkResolverServiceResolveSdkStart(string sdkName, string solutionPath, string projectPath);
    [EventAttribute("67")]
public void CachedSdkResolverServiceResolveSdkStop(string sdkName, string solutionPath, string projectPath, bool success, bool wasResultCached);
    [EventAttribute("68")]
public void ReusableStringBuilderFactoryStart(int hash, int newCapacity, int oldCapacity, string type);
    [EventAttribute("69")]
public void ReusableStringBuilderFactoryStop(int hash, int returningCapacity, int returningLength, string type);
    [EventAttribute("70")]
public void ReusableStringBuilderFactoryUnbalanced(int oldHash, int newHash);
    [EventAttribute("71")]
public void ProjectCacheCreatePluginInstanceStart(string pluginAssemblyPath);
    [EventAttribute("72")]
public void ProjectCacheCreatePluginInstanceStop(string pluginAssemblyPath, string pluginTypeName);
    [EventAttribute("73")]
public void ProjectCacheBeginBuildStart(string pluginTypeName);
    [EventAttribute("74")]
public void ProjectCacheBeginBuildStop(string pluginTypeName);
    [EventAttribute("75")]
public void ProjectCacheGetCacheResultStart(string pluginTypeName, string projectPath, string targets);
    [EventAttribute("76")]
public void ProjectCacheGetCacheResultStop(string pluginTypeName, string projectPath, string targets, string cacheResultType);
    [EventAttribute("77")]
public void ProjectCacheEndBuildStart(string pluginTypeName);
    [EventAttribute("78")]
public void ProjectCacheEndBuildStop(string pluginTypeName);
    [EventAttribute("79")]
public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStart(int submissionId, string sdkName, string solutionPath, string projectPath);
    [EventAttribute("80")]
public void OutOfProcSdkResolverServiceRequestSdkPathFromMainNodeStop(int submissionId, string sdkName, string solutionPath, string projectPath, bool success, bool wasResultCached);
    [EventAttribute("81")]
public void SdkResolverServiceFindResolversManifestsStart();
    [EventAttribute("82")]
public void SdkResolverServiceFindResolversManifestsStop(int resolverManifestCount);
    [EventAttribute("83")]
public void SdkResolverServiceLoadResolversStart();
    [EventAttribute("84")]
public void SdkResolverServiceLoadResolversStop(string manifestName, int resolverCount);
    [EventAttribute("85")]
public void CreateLoadedTypeStart(string assemblyName);
    [EventAttribute("86")]
public void CreateLoadedTypeStop(string assemblyName);
    [EventAttribute("87")]
public void LoadAssemblyAndFindTypeStart();
    [EventAttribute("88")]
public void LoadAssemblyAndFindTypeStop(string assemblyPath, int numberOfPublicTypesSearched);
    [EventAttribute("89")]
public void MSBuildServerBuildStart(string commandLine);
    [EventAttribute("90")]
public void MSBuildServerBuildStop(string commandLine, int countOfConsoleMessages, long sumSizeOfConsoleMessages, string clientExitType, string serverExitType);
    [EventAttribute("91")]
public void ProjectCacheHandleBuildResultStart(string pluginTypeName, string projectPath, string targets);
    [EventAttribute("92")]
public void ProjectCacheHandleBuildResultStop(string pluginTypeName, string projectPath, string targets);
}
public class Microsoft.Build.Framework.AnyEventHandler : MulticastDelegate {
    public AnyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.AssemblyLoadBuildEventArgs : BuildMessageEventArgs {
    [NullableAttribute("1")]
private static string DefaultAppDomainDescriptor;
    [CompilerGeneratedAttribute]
private AssemblyLoadingContext <LoadingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoadingInitiator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <MVID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainDescriptor>k__BackingField;
    public AssemblyLoadingContext LoadingContext { get; private set; }
    public string LoadingInitiator { get; private set; }
    public string AssemblyName { get; private set; }
    public string AssemblyPath { get; private set; }
    public Guid MVID { get; private set; }
    public string AppDomainDescriptor { get; private set; }
    [NullableAttribute("1")]
public string Message { get; }
    public AssemblyLoadBuildEventArgs(AssemblyLoadingContext loadingContext, string loadingInitiator, string assemblyName, string assemblyPath, Guid mvid, string customAppDomainDescriptor, MessageImportance importance);
    [CompilerGeneratedAttribute]
public AssemblyLoadingContext get_LoadingContext();
    [CompilerGeneratedAttribute]
private void set_LoadingContext(AssemblyLoadingContext value);
    [CompilerGeneratedAttribute]
public string get_LoadingInitiator();
    [CompilerGeneratedAttribute]
private void set_LoadingInitiator(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    [CompilerGeneratedAttribute]
private void set_AssemblyPath(string value);
    [CompilerGeneratedAttribute]
public Guid get_MVID();
    [CompilerGeneratedAttribute]
private void set_MVID(Guid value);
    [CompilerGeneratedAttribute]
public string get_AppDomainDescriptor();
    [CompilerGeneratedAttribute]
private void set_AppDomainDescriptor(string value);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
public enum Microsoft.Build.Framework.AssemblyLoadingContext : Enum {
    public int value__;
    public static AssemblyLoadingContext TaskRun;
    public static AssemblyLoadingContext Evaluation;
    public static AssemblyLoadingContext SdkResolution;
    public static AssemblyLoadingContext LoggerInitialization;
}
public class Microsoft.Build.Framework.BuildEngineResult : ValueType {
    private bool buildResult;
    private List`1<IDictionary`2<string, ITaskItem[]>> targetOutputsPerProject;
    public bool Result { get; }
    public IList`1<IDictionary`2<string, ITaskItem[]>> TargetOutputsPerProject { get; }
    public BuildEngineResult(bool result, List`1<IDictionary`2<string, ITaskItem[]>> targetOutputsPerProject);
    [IsReadOnlyAttribute]
public bool get_Result();
    public IList`1<IDictionary`2<string, ITaskItem[]>> get_TargetOutputsPerProject();
}
internal static class Microsoft.Build.Framework.BuildEnvironmentState : object {
    internal static bool s_runningInVisualStudio;
    internal static bool s_runningTests;
}
public class Microsoft.Build.Framework.BuildErrorEventArgs : LazyFormattedBuildEventArgs {
    private string subcategory;
    private string code;
    private string file;
    private string projectFile;
    private int lineNumber;
    private int columnNumber;
    private int endLineNumber;
    private int endColumnNumber;
    private string helpLink;
    public string Subcategory { get; }
    public string Code { get; }
    public string File { get; }
    public string ProjectFile { get; public set; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string HelpLink { get; }
    public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public BuildErrorEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, DateTime eventTimestamp, Object[] messageArgs);
    public string get_Subcategory();
    public string get_Code();
    public string get_File();
    public string get_ProjectFile();
    public void set_ProjectFile(string value);
    public int get_LineNumber();
    public int get_ColumnNumber();
    public int get_EndLineNumber();
    public int get_EndColumnNumber();
    public string get_HelpLink();
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public class Microsoft.Build.Framework.BuildErrorEventHandler : MulticastDelegate {
    public BuildErrorEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildErrorEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildErrorEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.Build.Framework.BuildEventArgs : EventArgs {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) message;
    private string helpKeyword;
    private string senderName;
    private DateTime timestamp;
    private Nullable`1<DateTime> _localTimestamp;
    private int threadId;
    [OptionalFieldAttribute]
private BuildEventContext buildEventContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static Func`3<string, String[], string> ResourceStringFormatter;
    public DateTime Timestamp { get; }
    protected internal DateTime RawTimestamp { get; protected internal set; }
    public int ThreadId { get; }
    public string Message { get; protected set; }
    protected internal string RawMessage { get; protected internal set; }
    private protected string FormattedMessage { get; }
    public string HelpKeyword { get; }
    public string SenderName { get; }
    public BuildEventContext BuildEventContext { get; public set; }
    protected BuildEventArgs(string message, string helpKeyword, string senderName);
    protected BuildEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    private static BuildEventArgs();
    public DateTime get_Timestamp();
    protected internal DateTime get_RawTimestamp();
    protected internal void set_RawTimestamp(DateTime value);
    public int get_ThreadId();
    public virtual string get_Message();
    protected virtual void set_Message(string value);
    protected internal string get_RawMessage();
    protected internal void set_RawMessage(string value);
    private protected virtual string get_FormattedMessage();
    public string get_HelpKeyword();
    public string get_SenderName();
    public BuildEventContext get_BuildEventContext();
    public void set_BuildEventContext(BuildEventContext value);
    [NullableContextAttribute("1")]
private protected void WriteToStreamWithExplicitMessage(BinaryWriter writer, string messageToWrite);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
    [OnDeserializingAttribute]
private void SetBuildEventContextDefaultBeforeSerialization(StreamingContext sc);
    [OnDeserializedAttribute]
private void SetBuildEventContextDefaultAfterSerialization(StreamingContext sc);
    [NullableContextAttribute("1")]
internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, String[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.BuildEventContext : object {
    private int _nodeId;
    private int _targetId;
    private int _projectContextId;
    private int _taskId;
    private int _projectInstanceId;
    private int _submissionId;
    private int _evaluationId;
    [CompilerGeneratedAttribute]
private static BuildEventContext <Invalid>k__BackingField;
    public static int InvalidProjectContextId;
    public static int InvalidTaskId;
    public static int InvalidTargetId;
    public static int InvalidNodeId;
    public static int InvalidProjectInstanceId;
    public static int InvalidSubmissionId;
    public static int InvalidEvaluationId;
    public static BuildEventContext Invalid { get; }
    public int EvaluationId { get; }
    public int NodeId { get; }
    public int TargetId { get; }
    public int ProjectContextId { get; }
    public int TaskId { get; }
    public int ProjectInstanceId { get; }
    public int SubmissionId { get; }
    public long BuildRequestId { get; }
    public BuildEventContext(int nodeId, int targetId, int projectContextId, int taskId);
    public BuildEventContext(int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId);
    public BuildEventContext(int submissionId, int nodeId, int projectInstanceId, int projectContextId, int targetId, int taskId);
    public BuildEventContext(int submissionId, int nodeId, int evaluationId, int projectInstanceId, int projectContextId, int targetId, int taskId);
    private static BuildEventContext();
    [CompilerGeneratedAttribute]
public static BuildEventContext get_Invalid();
    public int get_EvaluationId();
    public int get_NodeId();
    public int get_TargetId();
    public int get_ProjectContextId();
    public int get_TaskId();
    public int get_ProjectInstanceId();
    public int get_SubmissionId();
    public long get_BuildRequestId();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(BuildEventContext left, BuildEventContext right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(BuildEventContext left, BuildEventContext right);
    private bool InternalEquals(BuildEventContext buildEventContext);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Build.Framework.BuildException.BuildExceptionBase : Exception {
    [NullableAttribute("2")]
private string _remoteTypeName;
    [NullableAttribute("2")]
private string _remoteStackTrace;
    [NullableAttribute("2")]
public string StackTrace { get; }
    private protected BuildExceptionBase(string message);
    private protected BuildExceptionBase(string message, Exception inner);
    private protected BuildExceptionBase(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual string get_StackTrace();
    public virtual string ToString();
    protected virtual void InitializeCustomState(IDictionary`2<string, string> customKeyedSerializedData);
    protected virtual IDictionary`2<string, string> FlushCustomState();
    private void InitializeFromRemoteState(BuildExceptionRemoteState remoteState);
    internal static void WriteExceptionToTranslator(ITranslator translator, Exception exception);
    internal static Exception ReadExceptionFromTranslator(ITranslator translator);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.BuildException.BuildExceptionRemoteState : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <RemoteTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteStackTrace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HResult>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <CustomKeyedSerializedData>k__BackingField;
    [NullableAttribute("1")]
public string RemoteTypeName { get; public set; }
    public string RemoteStackTrace { get; public set; }
    public string Source { get; public set; }
    public string HelpLink { get; public set; }
    public int HResult { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> CustomKeyedSerializedData { get; public set; }
    public BuildExceptionRemoteState(string remoteTypeName, string remoteStackTrace, string source, string helpLink, int hResult, IDictionary`2<string, string> customKeyedSerializedData);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_RemoteTypeName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RemoteTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_RemoteStackTrace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RemoteStackTrace(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HelpLink(string value);
    [CompilerGeneratedAttribute]
public int get_HResult();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HResult(int value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_CustomKeyedSerializedData();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CustomKeyedSerializedData(IDictionary`2<string, string> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Framework.BuildException.BuildExceptionSerializationHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<string, Func`3<string, Exception, BuildExceptionBase>> s_exceptionFactories;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<string, Exception, BuildExceptionBase> s_defaultFactory;
    private static BuildExceptionSerializationHelper();
    internal static bool IsSupportedExceptionType(Type type);
    internal static void InitializeSerializationContract(TypeConstructionTuple[] exceptionsAllowlist);
    internal static void InitializeSerializationContract(IEnumerable`1<TypeConstructionTuple> exceptionsAllowlist);
    internal static string GetExceptionSerializationKey(Type exceptionType);
    internal static Func`3<string, Exception, BuildExceptionBase> CreateExceptionFactory(string serializationType);
}
internal class Microsoft.Build.Framework.BuildException.GenericBuildTransferredException : BuildExceptionBase {
    [NullableContextAttribute("1")]
internal GenericBuildTransferredException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.BuildFinishedEventArgs : BuildStatusEventArgs {
    private bool succeeded;
    public bool Succeeded { get; }
    public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded);
    public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, DateTime eventTimestamp);
    public BuildFinishedEventArgs(string message, string helpKeyword, bool succeeded, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
    public bool get_Succeeded();
}
public class Microsoft.Build.Framework.BuildFinishedEventHandler : MulticastDelegate {
    public BuildFinishedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildFinishedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildFinishedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Framework.BuildMessageEventArgs : LazyFormattedBuildEventArgs {
    private MessageImportance importance;
    [OptionalFieldAttribute]
private string subcategory;
    [OptionalFieldAttribute]
private string code;
    [OptionalFieldAttribute]
private string file;
    [OptionalFieldAttribute]
private string projectFile;
    [OptionalFieldAttribute]
private int lineNumber;
    [OptionalFieldAttribute]
private int columnNumber;
    [OptionalFieldAttribute]
private int endLineNumber;
    [OptionalFieldAttribute]
private int endColumnNumber;
    public MessageImportance Importance { get; internal set; }
    public string Subcategory { get; }
    public string Code { get; }
    public string File { get; }
    public int LineNumber { get; internal set; }
    public int ColumnNumber { get; internal set; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string ProjectFile { get; public set; }
    public BuildMessageEventArgs(string message, string helpKeyword, string senderName, MessageImportance importance);
    public BuildMessageEventArgs(string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp);
    public BuildMessageEventArgs(string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp, Object[] messageArgs);
    public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance);
    public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp);
    public BuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp, Object[] messageArgs);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public MessageImportance get_Importance();
    internal void set_Importance(MessageImportance value);
    public string get_Subcategory();
    public string get_Code();
    public string get_File();
    public int get_LineNumber();
    internal void set_LineNumber(int value);
    public int get_ColumnNumber();
    internal void set_ColumnNumber(int value);
    public int get_EndLineNumber();
    public int get_EndColumnNumber();
    public string get_ProjectFile();
    public void set_ProjectFile(string value);
}
public class Microsoft.Build.Framework.BuildMessageEventHandler : MulticastDelegate {
    public BuildMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildMessageEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildMessageEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.BuildStartedEventArgs : BuildStatusEventArgs {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, string> environmentOnBuildStart;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> BuildEnvironment { get; }
    [NullableContextAttribute("1")]
public BuildStartedEventArgs(string message, string helpKeyword);
    public BuildStartedEventArgs(string message, string helpKeyword, IDictionary`2<string, string> environmentOfBuild);
    public BuildStartedEventArgs(string message, string helpKeyword, DateTime eventTimestamp);
    public BuildStartedEventArgs(string message, string helpKeyword, DateTime eventTimestamp, Object[] messageArgs);
    public IDictionary`2<string, string> get_BuildEnvironment();
}
public class Microsoft.Build.Framework.BuildStartedEventHandler : MulticastDelegate {
    public BuildStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildStartedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildStartedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.Build.Framework.BuildStatusEventArgs : LazyFormattedBuildEventArgs {
    protected BuildStatusEventArgs(string message, string helpKeyword, string senderName);
    protected BuildStatusEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    protected BuildStatusEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
}
public class Microsoft.Build.Framework.BuildStatusEventHandler : MulticastDelegate {
    public BuildStatusEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildStatusEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildStatusEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Framework.BuildWarningEventArgs : LazyFormattedBuildEventArgs {
    private string subcategory;
    private string code;
    private string file;
    private string projectFile;
    private int lineNumber;
    private int columnNumber;
    private int endLineNumber;
    private int endColumnNumber;
    private string helpLink;
    public string Subcategory { get; }
    public string Code { get; }
    public string File { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string ProjectFile { get; public set; }
    public string HelpLink { get; }
    public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public BuildWarningEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, DateTime eventTimestamp, Object[] messageArgs);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public string get_Subcategory();
    public string get_Code();
    public string get_File();
    public int get_LineNumber();
    public int get_ColumnNumber();
    public int get_EndLineNumber();
    public int get_EndColumnNumber();
    public string get_ProjectFile();
    public void set_ProjectFile(string value);
    public string get_HelpLink();
}
public class Microsoft.Build.Framework.BuildWarningEventHandler : MulticastDelegate {
    public BuildWarningEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BuildWarningEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BuildWarningEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Framework.ChangeWaveConversionState : Enum {
    public int value__;
    public static ChangeWaveConversionState NotConvertedYet;
    public static ChangeWaveConversionState Valid;
    public static ChangeWaveConversionState InvalidFormat;
    public static ChangeWaveConversionState OutOfRotation;
}
internal class Microsoft.Build.Framework.ChangeWaves : object {
    internal static Version Wave17_4;
    internal static Version Wave17_6;
    internal static Version Wave17_8;
    internal static Version[] AllWaves;
    internal static Version EnableAllFeatures;
    private static Version _cachedWave;
    private static ChangeWaveConversionState _state;
    internal static Version LowestWave { get; }
    internal static Version HighestWave { get; }
    private static bool ShouldApplyChangeWave { get; }
    internal static Version DisabledWave { get; }
    internal static ChangeWaveConversionState ConversionState { get; internal set; }
    private static ChangeWaves();
    internal static Version get_LowestWave();
    internal static Version get_HighestWave();
    private static bool get_ShouldApplyChangeWave();
    internal static Version get_DisabledWave();
    internal static ChangeWaveConversionState get_ConversionState();
    internal static void set_ConversionState(ChangeWaveConversionState value);
    internal static void ApplyChangeWave();
    internal static bool AreFeaturesEnabled(Version wave);
    internal static void ResetStateForTests();
    private static bool TryParseVersion(string stringVersion, Version& version);
}
public class Microsoft.Build.Framework.CriticalBuildMessageEventArgs : BuildMessageEventArgs {
    public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public CriticalBuildMessageEventArgs(string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
}
public abstract class Microsoft.Build.Framework.CustomBuildEventArgs : LazyFormattedBuildEventArgs {
    protected CustomBuildEventArgs(string message, string helpKeyword, string senderName);
    protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    protected CustomBuildEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
}
public class Microsoft.Build.Framework.CustomBuildEventHandler : MulticastDelegate {
    public CustomBuildEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CustomBuildEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CustomBuildEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.Build.Framework.EngineServices : object {
    public static int Version1;
    public int Version { get; }
    public bool IsTaskInputLoggingEnabled { get; }
    public virtual int get_Version();
    public virtual bool LogsMessagesOfImportance(MessageImportance importance);
    public virtual bool get_IsTaskInputLoggingEnabled();
}
public class Microsoft.Build.Framework.EnvironmentVariableReadEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <EnvironmentVariableName>k__BackingField;
    public string EnvironmentVariableName { get; public set; }
    public EnvironmentVariableReadEventArgs(string environmentVariableName, string message, string helpKeyword, string senderName, MessageImportance importance);
    [CompilerGeneratedAttribute]
public string get_EnvironmentVariableName();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariableName(string value);
}
internal class Microsoft.Build.Framework.EscapeHatches : object {
    public bool DoNotSendDeferredMessagesToBuildManager;
    public bool DoNotExpandQualifiedMetadataInUpdateOperation;
    public Nullable`1<bool> EvaluateElementsWithFalseConditionInProjectEvaluation;
    public bool AlwaysUseContentTimestamp;
    public bool TruncateTaskInputs;
    public bool DoNotTruncateConditions;
    public bool AlwaysEvaluateDangerousGlobs;
    public bool AlwaysDoImmutableFilesUpToDateCheck;
    public bool CopyWithoutDelete;
    private Nullable`1<bool> _logProjectImports;
    private Nullable`1<bool> _logTaskInputs;
    private Nullable`1<bool> _logPropertiesAndItemsAfterEvaluation;
    private bool _logPropertiesAndItemsAfterEvaluationInitialized;
    public bool CacheAssemblyInformation;
    public Nullable`1<ProjectInstanceTranslationMode> ProjectInstanceTranslation;
    public bool UseSymlinkTimeInsteadOfTargetTime;
    public bool ReuseTaskHostNodes;
    public bool IgnoreEmptyImports;
    public bool IgnoreTreatAsLocalProperty;
    public bool DebugEvaluation;
    public bool WarnOnUninitializedProperty;
    public bool UseCaseSensitiveItemNames;
    public bool DisableLongPaths;
    public bool DisableSdkResolutionCache;
    public bool DisableNuGetSdkResolver;
    public bool TargetPathForRelatedFiles;
    public bool UseSingleLoadContext;
    public bool UseAutoRunWhenLaunchingProcessUnderCmd;
    public bool AvoidUnicodeWhenWritingToolTaskBatch;
    public bool EnsureStdOutForChildNodesIsPrimaryStdout;
    public bool UseMinimalResxParsingInCoreScenarios;
    private bool _sdkReferencePropertyExpansionInitialized;
    private Nullable`1<SdkReferencePropertyExpansionMode> _sdkReferencePropertyExpansionValue;
    private Nullable`1<bool> _isBinaryFormatterSerializationAllowed;
    public bool LogProjectImports { get; public set; }
    public bool LogTaskInputs { get; public set; }
    public Nullable`1<bool> LogPropertiesAndItemsAfterEvaluation { get; public set; }
    public Nullable`1<SdkReferencePropertyExpansionMode> SdkReferencePropertyExpansion { get; }
    public bool EnableWarningOnCustomBuildEvent { get; }
    public bool IsBinaryFormatterSerializationAllowed { get; }
    public bool get_LogProjectImports();
    public void set_LogProjectImports(bool value);
    public bool get_LogTaskInputs();
    public void set_LogTaskInputs(bool value);
    public Nullable`1<bool> get_LogPropertiesAndItemsAfterEvaluation();
    public void set_LogPropertiesAndItemsAfterEvaluation(Nullable`1<bool> value);
    public Nullable`1<SdkReferencePropertyExpansionMode> get_SdkReferencePropertyExpansion();
    public bool get_EnableWarningOnCustomBuildEvent();
    public bool get_IsBinaryFormatterSerializationAllowed();
    private static Nullable`1<bool> ParseNullableBoolFromEnvironmentVariable(string environmentVariable);
    private static Nullable`1<ProjectInstanceTranslationMode> ComputeProjectInstanceTranslation();
    private static Nullable`1<SdkReferencePropertyExpansionMode> ComputeSdkReferencePropertyExpansion();
    internal static void ThrowInternalError(string message);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedBuildErrorEventArgs : BuildErrorEventArgs {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    [NullableAttribute("1")]
public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [NullableContextAttribute("1")]
public ExtendedBuildErrorEventArgs(string type);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedBuildMessageEventArgs : BuildMessageEventArgs {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    [NullableAttribute("1")]
public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [NullableContextAttribute("1")]
public ExtendedBuildMessageEventArgs(string type);
    public ExtendedBuildMessageEventArgs(string type, string message, string helpKeyword, string senderName, MessageImportance importance);
    public ExtendedBuildMessageEventArgs(string type, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp);
    public ExtendedBuildMessageEventArgs(string type, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance);
    public ExtendedBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp);
    public ExtendedBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedBuildWarningEventArgs : BuildWarningEventArgs {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    [NullableAttribute("1")]
public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [NullableContextAttribute("1")]
public ExtendedBuildWarningEventArgs(string type);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedCustomBuildEventArgs : CustomBuildEventArgs {
    [CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> ExtendedMetadata { get; public set; }
    [NullableAttribute("2")]
public string ExtendedData { get; public set; }
    public ExtendedCustomBuildEventArgs(string type);
    [NullableContextAttribute("2")]
public ExtendedCustomBuildEventArgs(string type, string message, string helpKeyword, string senderName);
    [NullableContextAttribute("2")]
public ExtendedCustomBuildEventArgs(string type, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    [NullableContextAttribute("2")]
public ExtendedCustomBuildEventArgs(string type, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(Dictionary`2<string, string> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public class Microsoft.Build.Framework.ExternalProjectFinishedEventArgs : CustomBuildEventArgs {
    private string projectFile;
    private bool succeeded;
    public string ProjectFile { get; }
    public bool Succeeded { get; }
    public ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded);
    public ExternalProjectFinishedEventArgs(string message, string helpKeyword, string senderName, string projectFile, bool succeeded, DateTime eventTimestamp);
    public string get_ProjectFile();
    public bool get_Succeeded();
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public class Microsoft.Build.Framework.ExternalProjectStartedEventArgs : CustomBuildEventArgs {
    private string projectFile;
    private string targetNames;
    public string ProjectFile { get; }
    public string TargetNames { get; }
    public ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames);
    public ExternalProjectStartedEventArgs(string message, string helpKeyword, string senderName, string projectFile, string targetNames, DateTime eventTimestamp);
    public string get_ProjectFile();
    public string get_TargetNames();
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.FileClassifier : object {
    private static StringComparison PathComparison;
    private static Lazy`1<FileClassifier> s_sharedInstance;
    private ConcurrentDictionary`2<string, string> _knownImmutableDirectories;
    private IReadOnlyList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _knownImmutableDirectoriesSnapshot;
    public static FileClassifier Shared { get; }
    private static FileClassifier();
    public static FileClassifier get_Shared();
    [NullableContextAttribute("2")]
public void RegisterImmutableDirectory(string directory);
    private static string EnsureTrailingSlash(string fileSpec);
    public bool IsNonModifiable(string filePath);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string <.ctor>g__GetVSInstallationDirectory|4_0();
    [CompilerGeneratedAttribute]
internal static string <.ctor>g__GetVsRootFromMSBuildAssembly|4_2(string msBuildAssembly);
    [CompilerGeneratedAttribute]
internal static string <.ctor>g__GetFolderAbove|4_3(string path, int count);
}
internal class Microsoft.Build.Framework.FrameworkErrorUtilities : object {
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
}
public interface Microsoft.Build.Framework.IBuildEngine {
    public bool ContinueOnError { get; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    public abstract virtual void LogErrorEvent(BuildErrorEventArgs e);
    public abstract virtual void LogWarningEvent(BuildWarningEventArgs e);
    public abstract virtual void LogMessageEvent(BuildMessageEventArgs e);
    public abstract virtual void LogCustomEvent(CustomBuildEventArgs e);
    public abstract virtual bool get_ContinueOnError();
    public abstract virtual int get_LineNumberOfTaskNode();
    public abstract virtual int get_ColumnNumberOfTaskNode();
    public abstract virtual string get_ProjectFileOfTaskNode();
    public abstract virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
}
public interface Microsoft.Build.Framework.IBuildEngine10 {
    public EngineServices EngineServices { get; }
    public abstract virtual EngineServices get_EngineServices();
}
public interface Microsoft.Build.Framework.IBuildEngine2 {
    public bool IsRunningMultipleNodes { get; }
    public abstract virtual bool get_IsRunningMultipleNodes();
    public abstract virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion);
    public abstract virtual bool BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, String[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion);
}
public interface Microsoft.Build.Framework.IBuildEngine3 {
    public abstract virtual BuildEngineResult BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] removeGlobalProperties, String[] toolsVersion, bool returnTargetOutputs);
    public abstract virtual void Yield();
    public abstract virtual void Reacquire();
}
public interface Microsoft.Build.Framework.IBuildEngine4 {
    public abstract virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public abstract virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public abstract virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
}
public interface Microsoft.Build.Framework.IBuildEngine5 {
    public abstract virtual void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
}
public interface Microsoft.Build.Framework.IBuildEngine6 {
    public abstract virtual IReadOnlyDictionary`2<string, string> GetGlobalProperties();
}
public interface Microsoft.Build.Framework.IBuildEngine7 {
    public bool AllowFailureWithoutError { get; public set; }
    public abstract virtual bool get_AllowFailureWithoutError();
    public abstract virtual void set_AllowFailureWithoutError(bool value);
}
public interface Microsoft.Build.Framework.IBuildEngine8 {
    public abstract virtual bool ShouldTreatWarningAsError(string warningCode);
}
public interface Microsoft.Build.Framework.IBuildEngine9 {
    public abstract virtual int RequestCores(int requestedCores);
    public abstract virtual void ReleaseCores(int coresToRelease);
}
public interface Microsoft.Build.Framework.ICancelableTask {
    public abstract virtual void Cancel();
}
public interface Microsoft.Build.Framework.IEventRedirector {
    public abstract virtual void ForwardEvent(BuildEventArgs buildEvent);
}
public interface Microsoft.Build.Framework.IEventSource {
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AnyEventRaised(AnyEventHandler value);
}
public interface Microsoft.Build.Framework.IEventSource2 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_TelemetryLogged(TelemetryEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TelemetryLogged(TelemetryEventHandler value);
}
public interface Microsoft.Build.Framework.IEventSource3 {
    public abstract virtual void IncludeEvaluationMetaprojects();
    public abstract virtual void IncludeEvaluationProfiles();
    public abstract virtual void IncludeTaskInputs();
}
public interface Microsoft.Build.Framework.IEventSource4 {
    public abstract virtual void IncludeEvaluationPropertiesAndItems();
}
[NullableContextAttribute("1")]
public interface Microsoft.Build.Framework.IExtendedBuildEventArgs {
    public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> ExtendedMetadata { get; public set; }
    [NullableAttribute("2")]
public string ExtendedData { get; public set; }
    public abstract virtual string get_ExtendedType();
    public abstract virtual void set_ExtendedType(string value);
    public abstract virtual Dictionary`2<string, string> get_ExtendedMetadata();
    public abstract virtual void set_ExtendedMetadata(Dictionary`2<string, string> value);
    [NullableContextAttribute("2")]
public abstract virtual string get_ExtendedData();
    [NullableContextAttribute("2")]
public abstract virtual void set_ExtendedData(string value);
}
public interface Microsoft.Build.Framework.IForwardingLogger {
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public abstract virtual IEventRedirector get_BuildEventRedirector();
    public abstract virtual void set_BuildEventRedirector(IEventRedirector value);
    public abstract virtual int get_NodeId();
    public abstract virtual void set_NodeId(int value);
}
public interface Microsoft.Build.Framework.IGeneratedTask {
    public abstract virtual void SetPropertyValue(TaskPropertyInfo property, object value);
    public abstract virtual object GetPropertyValue(TaskPropertyInfo property);
}
public interface Microsoft.Build.Framework.IIncrementalTask {
    unknown bool FailIfNotIncremental {public set; }
    public abstract virtual void set_FailIfNotIncremental(bool value);
}
[ComVisibleAttribute("True")]
public interface Microsoft.Build.Framework.ILogger {
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public abstract virtual LoggerVerbosity get_Verbosity();
    public abstract virtual void set_Verbosity(LoggerVerbosity value);
    public abstract virtual string get_Parameters();
    public abstract virtual void set_Parameters(string value);
    public abstract virtual void Initialize(IEventSource eventSource);
    public abstract virtual void Shutdown();
}
internal interface Microsoft.Build.Framework.IMetadataContainer {
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, string>> EnumerateMetadata();
    public abstract virtual void ImportMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadata);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.ImmutableFilesTimestampCache : object {
    private ConcurrentDictionary`2<string, DateTime> _cache;
    [CompilerGeneratedAttribute]
private static ImmutableFilesTimestampCache <Shared>k__BackingField;
    public static ImmutableFilesTimestampCache Shared { get; }
    private static ImmutableFilesTimestampCache();
    [CompilerGeneratedAttribute]
public static ImmutableFilesTimestampCache get_Shared();
    public bool TryGetValue(string fullPath, DateTime& lastModified);
    public void TryAdd(string fullPath, DateTime lastModified);
}
[ComVisibleAttribute("True")]
public interface Microsoft.Build.Framework.INodeLogger {
    public abstract virtual void Initialize(IEventSource eventSource, int nodeCount);
}
internal static class Microsoft.Build.Framework.Internal.Strings : object {
}
internal class Microsoft.Build.Framework.InternalErrorException : BuildExceptionBase {
    internal InternalErrorException(string message);
    internal InternalErrorException(string message, Exception innerException);
    private InternalErrorException(string message, Exception innerException, bool calledFromDeserialization);
    private InternalErrorException(SerializationInfo info, StreamingContext context);
    internal static InternalErrorException CreateFromRemote(string message, Exception innerException);
    private static void ConsiderDebuggerLaunch(string message, Exception innerException);
    private static void LaunchDebugger(string message, string innerMessage);
    private static bool RunningTests();
}
public interface Microsoft.Build.Framework.IProjectElement {
    public string ElementName { get; }
    public string OuterElement { get; }
    public abstract virtual string get_ElementName();
    public abstract virtual string get_OuterElement();
}
internal interface Microsoft.Build.Framework.IStringBuilderProvider {
    public abstract virtual StringBuilder Acquire(int capacity);
    public abstract virtual string GetStringAndRelease(StringBuilder builder);
}
public interface Microsoft.Build.Framework.ITask {
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public abstract virtual IBuildEngine get_BuildEngine();
    public abstract virtual void set_BuildEngine(IBuildEngine value);
    public abstract virtual ITaskHost get_HostObject();
    public abstract virtual void set_HostObject(ITaskHost value);
    public abstract virtual bool Execute();
}
public interface Microsoft.Build.Framework.ITaskFactory {
    public string FactoryName { get; }
    public Type TaskType { get; }
    public abstract virtual string get_FactoryName();
    public abstract virtual Type get_TaskType();
    public abstract virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public abstract virtual TaskPropertyInfo[] GetTaskParameters();
    public abstract virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public abstract virtual void CleanupTask(ITask task);
}
public interface Microsoft.Build.Framework.ITaskFactory2 {
    public abstract virtual bool Initialize(string taskName, IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public abstract virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary`2<string, string> taskIdentityParameters);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("9049A481-D0E9-414f-8F92-D4F67A0359A6")]
public interface Microsoft.Build.Framework.ITaskHost {
}
[ComVisibleAttribute("True")]
[GuidAttribute("8661674F-2148-4F71-A92A-49875511C528")]
public interface Microsoft.Build.Framework.ITaskItem {
    public string ItemSpec { get; public set; }
    public ICollection MetadataNames { get; }
    public int MetadataCount { get; }
    public abstract virtual string get_ItemSpec();
    public abstract virtual void set_ItemSpec(string value);
    public abstract virtual ICollection get_MetadataNames();
    public abstract virtual int get_MetadataCount();
    public abstract virtual string GetMetadata(string metadataName);
    public abstract virtual void SetMetadata(string metadataName, string metadataValue);
    public abstract virtual void RemoveMetadata(string metadataName);
    public abstract virtual void CopyMetadataTo(ITaskItem destinationItem);
    public abstract virtual IDictionary CloneCustomMetadata();
}
[ComVisibleAttribute("True")]
[GuidAttribute("ac6d5a59-f877-461b-88e3-b2f06fce0cb9")]
public interface Microsoft.Build.Framework.ITaskItem2 {
    public string EvaluatedIncludeEscaped { get; public set; }
    public abstract virtual string get_EvaluatedIncludeEscaped();
    public abstract virtual void set_EvaluatedIncludeEscaped(string value);
    public abstract virtual string GetMetadataValueEscaped(string metadataName);
    public abstract virtual void SetMetadataValueLiteral(string metadataName, string metadataValue);
    public abstract virtual IDictionary CloneCustomMetadataEscaped();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Framework.ITaskItemExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateMetadata(ITaskItem taskItem);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.LazyFormattedBuildEventArgs : BuildEventArgs {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) argumentsOrFormattedMessage;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Object[] RawArguments { get; }
    private protected string FormattedMessage { get; }
    public string Message { get; }
    public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName);
    public LazyFormattedBuildEventArgs(string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    internal Object[] get_RawArguments();
    private protected virtual string get_FormattedMessage();
    public virtual string get_Message();
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
    [NullableContextAttribute("1")]
private static string FormatString(string unformatted, Object[] args);
}
[AttributeUsageAttribute("4")]
public class Microsoft.Build.Framework.LoadInSeparateAppDomainAttribute : Attribute {
}
public class Microsoft.Build.Framework.LoggerException : BuildExceptionBase {
    private string errorCode;
    private string helpKeyword;
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public LoggerException(string message);
    public LoggerException(string message, Exception innerException);
    public LoggerException(string message, Exception innerException, string errorCode, string helpKeyword);
    protected LoggerException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual IDictionary`2<string, string> FlushCustomState();
    protected virtual void InitializeCustomState(IDictionary`2<string, string> state);
    public string get_ErrorCode();
    public string get_HelpKeyword();
}
[ComVisibleAttribute("True")]
public enum Microsoft.Build.Framework.LoggerVerbosity : Enum {
    public int value__;
    public static LoggerVerbosity Quiet;
    public static LoggerVerbosity Minimal;
    public static LoggerVerbosity Normal;
    public static LoggerVerbosity Detailed;
    public static LoggerVerbosity Diagnostic;
}
public enum Microsoft.Build.Framework.MessageImportance : Enum {
    public int value__;
    public static MessageImportance High;
    public static MessageImportance Normal;
    public static MessageImportance Low;
}
public class Microsoft.Build.Framework.MetaprojectGeneratedEventArgs : BuildMessageEventArgs {
    public string metaprojectXml;
    public MetaprojectGeneratedEventArgs(string metaprojectXml, string metaprojectPath, string message);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
internal static class Microsoft.Build.Framework.NativeMethods : object {
    internal static UInt32 ERROR_INSUFFICIENT_BUFFER;
    internal static UInt32 STARTUP_LOADER_SAFEMODE;
    internal static UInt32 S_OK;
    internal static UInt32 S_FALSE;
    internal static UInt32 ERROR_ACCESS_DENIED;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 FUSION_E_PRIVATE_ASM_DISALLOWED;
    internal static UInt32 RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG;
    internal static UInt32 FILE_TYPE_CHAR;
    internal static int STD_OUTPUT_HANDLE;
    internal static int STD_ERROR_HANDLE;
    internal static UInt32 ENABLE_VIRTUAL_TERMINAL_PROCESSING;
    internal static UInt32 RPC_S_CALLPENDING;
    internal static UInt32 E_ABORT;
    internal static int FILE_ATTRIBUTE_READONLY;
    internal static int FILE_ATTRIBUTE_DIRECTORY;
    internal static int FILE_ATTRIBUTE_REPARSE_POINT;
    internal static int MAX_PATH;
    private static string kernel32Dll;
    private static string WINDOWS_FILE_SYSTEM_REGISTRY_KEY;
    private static string WINDOWS_LONG_PATHS_ENABLED_VALUE_NAME;
    [CompilerGeneratedAttribute]
private static DateTime <MinFileDate>k__BackingField;
    internal static HandleRef NullHandleRef;
    internal static IntPtr NullIntPtr;
    internal static IntPtr InvalidHandle;
    internal static ushort PROCESSOR_ARCHITECTURE_INTEL;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM;
    internal static ushort PROCESSOR_ARCHITECTURE_IA64;
    internal static ushort PROCESSOR_ARCHITECTURE_AMD64;
    internal static ushort PROCESSOR_ARCHITECTURE_ARM64;
    internal static UInt32 INFINITE;
    internal static UInt32 WAIT_ABANDONED_0;
    internal static UInt32 WAIT_OBJECT_0;
    internal static UInt32 WAIT_TIMEOUT;
    private static int _maxPath;
    [CompilerGeneratedAttribute]
private static bool <IsMaxPathSet>k__BackingField;
    private static object MaxPathLock;
    private static bool s_isUnixLike;
    private static object IsMonoLock;
    private static Nullable`1<bool> _isMono;
    private static Nullable`1<bool> _isWindows;
    private static Nullable`1<bool> _isOSX;
    private static string s_frameworkBasePath;
    private static string s_frameworkCurrentPath;
    private static SystemInformationData _systemInformation;
    private static bool _systemInformationInitialized;
    private static object SystemInformationLock;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 FILE_ATTRIBUTE_NORMAL;
    internal static UInt32 FILE_FLAG_OPEN_REPARSE_POINT;
    internal static UInt32 OPEN_EXISTING;
    internal static DateTime MinFileDate { get; }
    internal static bool HasMaxPath { get; }
    internal static int MaxPath { get; }
    private static bool IsMaxPathSet { get; private set; }
    internal static bool IsUnixLike { get; }
    [SupportedOSPlatformGuard("linux")]
internal static bool IsLinux { get; }
    internal static bool IsBSD { get; }
    internal static bool IsMono { get; }
    [SupportedOSPlatformGuard("windows")]
internal static bool IsWindows { get; }
    internal static bool IsOSX { get; }
    internal static string OSName { get; }
    internal static string FrameworkName { get; }
    internal static bool OSUsesCaseSensitivePaths { get; }
    internal static string FrameworkCurrentPath { get; }
    internal static string FrameworkBasePath { get; }
    private static SystemInformationData SystemInformation { get; }
    internal static ProcessorArchitectures ProcessorArchitecture { get; }
    internal static ProcessorArchitectures ProcessorArchitectureNative { get; }
    private static NativeMethods();
    [CompilerGeneratedAttribute]
internal static DateTime get_MinFileDate();
    public static int GetLogicalCoreCount();
    [SupportedOSPlatform("windows")]
private static int GetLogicalCoreCountOnWindows();
    internal static bool get_HasMaxPath();
    internal static int get_MaxPath();
    [CompilerGeneratedAttribute]
private static bool get_IsMaxPathSet();
    [CompilerGeneratedAttribute]
private static void set_IsMaxPathSet(bool value);
    private static void SetMaxPath();
    internal static bool IsMaxPathLegacyWindows();
    [SupportedOSPlatform("windows")]
private static bool IsLongPathsEnabledRegistry();
    internal static bool get_IsUnixLike();
    internal static bool get_IsLinux();
    internal static bool get_IsBSD();
    internal static bool get_IsMono();
    internal static bool get_IsWindows();
    internal static bool get_IsOSX();
    internal static string get_OSName();
    internal static string get_FrameworkName();
    internal static string GetOSNameForExtensionsPath();
    internal static bool get_OSUsesCaseSensitivePaths();
    internal static string get_FrameworkCurrentPath();
    internal static string get_FrameworkBasePath();
    private static SystemInformationData get_SystemInformation();
    internal static ProcessorArchitectures get_ProcessorArchitecture();
    internal static ProcessorArchitectures get_ProcessorArchitectureNative();
    [SupportedOSPlatform("windows")]
internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
    [SupportedOSPlatform("windows")]
internal static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    [SupportedOSPlatform("windows")]
internal static bool GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, IntPtr Buffer, UInt32& ReturnedLength);
    internal static bool GetLastWriteDirectoryUtcTime(string fullPath, DateTime& fileModifiedTimeUtc);
    internal static string GetShortFilePath(string path);
    [SupportedOSPlatform("windows")]
internal static string GetLongFilePath(string path);
    internal static MemoryStatus GetMemoryStatus();
    internal static bool MakeSymbolicLink(string newFileName, string existingFileName, String& errorMessage);
    internal static DateTime GetLastWriteFileUtcTime(string fullPath);
    [SupportedOSPlatform("windows")]
private static SafeFileHandle OpenFileThroughSymlinks(string fullPath);
    [SupportedOSPlatform("windows")]
private static DateTime GetContentLastWriteFileUtcTime(string fullPath);
    public static bool HResultSucceeded(int hr);
    public static bool HResultFailed(int hr);
    public static void ThrowExceptionForErrorCode(int errorCode);
    [SupportedOSPlatform("windows")]
internal static void KillTree(int processIdToKill);
    [SupportedOSPlatform("windows")]
internal static int GetParentProcessId(int processId);
    [SupportedOSPlatform("windows")]
internal static List`1<KeyValuePair`2<int, SafeProcessHandle>> GetChildProcessIds(int parentProcessId, DateTime parentStartTime);
    internal static string GetCurrentDirectory();
    [SupportedOSPlatform("windows")]
private static int GetCurrentDirectoryWin32(int nBufferLength, Char* lpBuffer);
    [SupportedOSPlatform("windows")]
internal static string GetFullPath(string path);
    [SupportedOSPlatform("windows")]
private static int GetFullPathWin32(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    private static bool AreStringsEqual(Char* buffer, int len, string s);
    internal static void VerifyThrowWin32Result(int result);
    internal static ValueTuple`3<bool, bool, Nullable`1<UInt32>> QueryIsScreenAndTryEnableAnsiColorCodes(StreamHandleType handleType);
    internal static void RestoreConsoleMode(Nullable`1<UInt32> originalConsoleMode, StreamHandleType handleType);
    [SupportedOSPlatform("linux")]
internal static int chmod(string pathname, int mode);
    [SupportedOSPlatform("linux")]
internal static int mkdir(string path, int mode);
    [SupportedOSPlatform("windows")]
internal static int GetOEMCP();
    [SupportedOSPlatform("windows")]
internal static bool GetFileAttributesEx(string name, int fileInfoLevel, WIN32_FILE_ATTRIBUTE_DATA& lpFileInformation);
    [SupportedOSPlatform("windows")]
internal static bool FreeLibrary(IntPtr module);
    [SupportedOSPlatform("windows")]
internal static IntPtr GetProcAddress(IntPtr module, string procName);
    [SupportedOSPlatform("windows")]
internal static IntPtr LoadLibrary(string fileName);
    [SupportedOSPlatform("windows")]
internal static int GetModuleFileName(HandleRef hModule, Char[] buffer, int length);
    [SupportedOSPlatform("windows")]
internal static IntPtr GetStdHandle(int nStdHandle);
    [SupportedOSPlatform("windows")]
internal static UInt32 GetFileType(IntPtr hFile);
    internal static bool GetConsoleMode(IntPtr hConsoleHandle, UInt32& lpMode);
    internal static bool SetConsoleMode(IntPtr hConsoleHandle, UInt32 dwMode);
    [SupportedOSPlatform("windows")]
internal static int GetCurrentDirectory(int nBufferLength, Char* lpBuffer);
    [SupportedOSPlatform("windows")]
internal static bool SetCurrentDirectoryWindows(string path);
    internal static bool SetCurrentDirectory(string path);
    [SupportedOSPlatform("windows")]
internal static int GetFullPathName(string target, int bufferLength, Char* buffer, IntPtr mustBeZero);
    [SupportedOSPlatform("windows")]
private static SafeProcessHandle OpenProcess(eDesiredAccess dwDesiredAccess, bool bInheritHandle, int dwProcessId);
    [SupportedOSPlatform("windows")]
private static int NtQueryInformationProcess(SafeProcessHandle hProcess, PROCESSINFOCLASS pic, PROCESS_BASIC_INFORMATION& pbi, UInt32 cb, Int32& pSize);
    [SupportedOSPlatform("windows")]
private static bool GlobalMemoryStatusEx(MemoryStatus lpBuffer);
    [SupportedOSPlatform("windows")]
internal static int GetShortPathName(string path, Char[] fullpath, int length);
    [SupportedOSPlatform("windows")]
internal static int GetLongPathName(string path, Char[] fullpath, int length);
    [SupportedOSPlatform("windows")]
internal static bool CreatePipe(SafeFileHandle& hReadPipe, SafeFileHandle& hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
    [SupportedOSPlatform("windows")]
internal static bool ReadFile(SafeFileHandle hFile, Byte[] lpBuffer, UInt32 nNumberOfBytesToRead, UInt32& lpNumberOfBytesRead, IntPtr lpOverlapped);
    [SupportedOSPlatform("windows")]
public static int CoWaitForMultipleHandles(COWAIT_FLAGS dwFlags, int dwTimeout, int cHandles, IntPtr[] pHandles, Int32& pdwIndex);
    [SupportedOSPlatform("windows")]
internal static SafeFileHandle CreateFile(string lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    [SupportedOSPlatform("windows")]
internal static bool GetFileTime(SafeFileHandle hFile, FILETIME& lpCreationTime, FILETIME& lpLastAccessTime, FILETIME& lpLastWriteTime);
    [SupportedOSPlatform("windows")]
internal static bool CloseHandle(IntPtr hObject);
    [SupportedOSPlatform("windows")]
internal static bool SetThreadErrorMode(int newMode, Int32& oldMode);
    [SupportedOSPlatform("windows")]
internal static bool CreateSymbolicLink(string symLinkFileName, string targetFileName, SymbolicLink dwFlags);
    internal static int symlink(string oldpath, string newpath);
    internal static bool DirectoryExists(string fullPath);
    [SupportedOSPlatform("windows")]
internal static bool DirectoryExistsWindows(string fullPath);
    internal static bool FileExists(string fullPath);
    [SupportedOSPlatform("windows")]
internal static bool FileExistsWindows(string fullPath);
    internal static bool FileOrDirectoryExists(string path);
    [SupportedOSPlatform("windows")]
internal static bool FileOrDirectoryExistsWindows(string path);
    [CompilerGeneratedAttribute]
internal static DateTime <GetLastWriteFileUtcTime>g__LastWriteFileUtcTime|114_0(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Framework.OperatingSystem : object {
    public static bool IsOSPlatform(string platform);
    public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor, int build, int revision);
    public static bool IsLinux();
    public static bool IsFreeBSD();
    public static bool IsFreeBSDVersionAtLeast(int major, int minor, int build, int revision);
    public static bool IsMacOS();
    public static bool IsMacOSVersionAtLeast(int major, int minor, int build);
    public static bool IsWindows();
    public static bool IsWindowsVersionAtLeast(int major, int minor, int build, int revision);
    private static bool IsOSVersionAtLeast(int major, int minor, int build, int revision);
}
[AttributeUsageAttribute("128")]
public class Microsoft.Build.Framework.OutputAttribute : Attribute {
}
internal static class Microsoft.Build.Framework.Profiler.EvaluationIdProvider : object {
    private static long _sAssignedId;
    private static long ProcessId;
    private static EvaluationIdProvider();
    public static long GetNextId();
}
public class Microsoft.Build.Framework.Profiler.EvaluationLocation : ValueType {
    private static Dictionary`2<EvaluationPass, string> PassDefaultDescription;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ParentId>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationPass <EvaluationPass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluationPassDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationLocationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private static EvaluationLocation <EmptyLocation>k__BackingField;
    public long Id { get; }
    public Nullable`1<long> ParentId { get; }
    public EvaluationPass EvaluationPass { get; }
    public string EvaluationPassDescription { get; }
    public string File { get; }
    public Nullable`1<int> Line { get; }
    public string ElementName { get; }
    public string ElementDescription { get; }
    public EvaluationLocationKind Kind { get; }
    public bool IsEvaluationPass { get; }
    public static EvaluationLocation EmptyLocation { get; }
    public EvaluationLocation(long id, Nullable`1<long> parentId, EvaluationPass evaluationPass, string evaluationPassDescription, string file, Nullable`1<int> line, string elementName, string elementDescription, EvaluationLocationKind kind);
    public EvaluationLocation(Nullable`1<long> parentId, EvaluationPass evaluationPass, string evaluationPassDescription, string file, Nullable`1<int> line, string elementName, string elementDescription, EvaluationLocationKind kind);
    public EvaluationLocation(EvaluationPass evaluationPass, string evaluationPassDescription, string file, Nullable`1<int> line, string elementName, string elementDescription, EvaluationLocationKind kind);
    private static EvaluationLocation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_Id();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_ParentId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EvaluationPass get_EvaluationPass();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_EvaluationPassDescription();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_File();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<int> get_Line();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ElementName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ElementDescription();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public EvaluationLocationKind get_Kind();
    [IsReadOnlyAttribute]
public bool get_IsEvaluationPass();
    public static EvaluationLocation CreateLocationForCondition(Nullable`1<long> parentId, EvaluationPass evaluationPass, string evaluationDescription, string file, Nullable`1<int> line, string condition);
    public static EvaluationLocation CreateLocationForProject(Nullable`1<long> parentId, EvaluationPass evaluationPass, string evaluationDescription, string file, Nullable`1<int> line, IProjectElement element);
    public static EvaluationLocation CreateLocationForGlob(Nullable`1<long> parentId, EvaluationPass evaluationPass, string evaluationDescription, string file, Nullable`1<int> line, string globDescription);
    public static EvaluationLocation CreateLocationForAggregatedGlob();
    [CompilerGeneratedAttribute]
public static EvaluationLocation get_EmptyLocation();
    [IsReadOnlyAttribute]
public EvaluationLocation WithEvaluationPass(EvaluationPass evaluationPass, string passDescription);
    public EvaluationLocation WithParentId(Nullable`1<long> parentId);
    public EvaluationLocation WithFile(string file);
    public EvaluationLocation WithFileLineAndElement(string file, Nullable`1<int> line, IProjectElement element);
    public EvaluationLocation WithFileLineAndCondition(string file, Nullable`1<int> line, string condition);
    public EvaluationLocation WithGlob(string globDescription);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
    private static EvaluationLocation CreateEmptyLocation();
}
public enum Microsoft.Build.Framework.Profiler.EvaluationLocationKind : Enum {
    public byte value__;
    public static EvaluationLocationKind Element;
    public static EvaluationLocationKind Condition;
    public static EvaluationLocationKind Glob;
}
public enum Microsoft.Build.Framework.Profiler.EvaluationPass : Enum {
    public byte value__;
    public static EvaluationPass TotalEvaluation;
    public static EvaluationPass TotalGlobbing;
    public static EvaluationPass InitialProperties;
    public static EvaluationPass Properties;
    public static EvaluationPass ItemDefinitionGroups;
    public static EvaluationPass Items;
    public static EvaluationPass LazyItems;
    public static EvaluationPass UsingTasks;
    public static EvaluationPass Targets;
}
public class Microsoft.Build.Framework.Profiler.ProfiledLocation : ValueType {
    [CompilerGeneratedAttribute]
private TimeSpan <InclusiveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExclusiveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfHits>k__BackingField;
    public TimeSpan InclusiveTime { get; }
    public TimeSpan ExclusiveTime { get; }
    public int NumberOfHits { get; }
    public ProfiledLocation(TimeSpan inclusiveTime, TimeSpan exclusiveTime, int numberOfHits);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeSpan get_InclusiveTime();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeSpan get_ExclusiveTime();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_NumberOfHits();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Microsoft.Build.Framework.Profiler.ProfilerResult : ValueType {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<EvaluationLocation, ProfiledLocation> <ProfiledLocations>k__BackingField;
    public IReadOnlyDictionary`2<EvaluationLocation, ProfiledLocation> ProfiledLocations { get; }
    public ProfilerResult(IDictionary`2<EvaluationLocation, ProfiledLocation> profiledLocations);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<EvaluationLocation, ProfiledLocation> get_ProfiledLocations();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ProjectEvaluationFinishedEventArgs : BuildStatusEventArgs {
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <GlobalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ProfilerResult> <ProfilerResult>k__BackingField;
    public string ProjectFile { get; public set; }
    public IEnumerable GlobalProperties { get; public set; }
    public IEnumerable Properties { get; public set; }
    public IEnumerable Items { get; public set; }
    public Nullable`1<ProfilerResult> ProfilerResult { get; public set; }
    public ProjectEvaluationFinishedEventArgs(string message, Object[] messageArgs);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
    [CompilerGeneratedAttribute]
public IEnumerable get_GlobalProperties();
    [CompilerGeneratedAttribute]
public void set_GlobalProperties(IEnumerable value);
    [CompilerGeneratedAttribute]
public IEnumerable get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IEnumerable value);
    [CompilerGeneratedAttribute]
public IEnumerable get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(IEnumerable value);
    [CompilerGeneratedAttribute]
public Nullable`1<ProfilerResult> get_ProfilerResult();
    [CompilerGeneratedAttribute]
public void set_ProfilerResult(Nullable`1<ProfilerResult> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ProjectEvaluationStartedEventArgs : BuildStatusEventArgs {
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    public string ProjectFile { get; public set; }
    public ProjectEvaluationStartedEventArgs(string message, Object[] messageArgs);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ProjectFinishedEventArgs : BuildStatusEventArgs {
    private string projectFile;
    private bool succeeded;
    public string ProjectFile { get; }
    public bool Succeeded { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded);
    public ProjectFinishedEventArgs(string message, string helpKeyword, string projectFile, bool succeeded, DateTime eventTimestamp);
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
    public string get_ProjectFile();
    public bool get_Succeeded();
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
public class Microsoft.Build.Framework.ProjectFinishedEventHandler : MulticastDelegate {
    public ProjectFinishedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProjectFinishedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProjectFinishedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Framework.ProjectImportedEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <UnexpandedProject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportedProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ImportIgnored>k__BackingField;
    public string UnexpandedProject { get; public set; }
    public string ImportedProjectFile { get; public set; }
    public bool ImportIgnored { get; public set; }
    public ProjectImportedEventArgs(int lineNumber, int columnNumber, string message, Object[] messageArgs);
    [CompilerGeneratedAttribute]
public string get_UnexpandedProject();
    [CompilerGeneratedAttribute]
public void set_UnexpandedProject(string value);
    [CompilerGeneratedAttribute]
public string get_ImportedProjectFile();
    [CompilerGeneratedAttribute]
public void set_ImportedProjectFile(string value);
    [CompilerGeneratedAttribute]
public bool get_ImportIgnored();
    [CompilerGeneratedAttribute]
public void set_ImportIgnored(bool value);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ProjectStartedEventArgs : BuildStatusEventArgs {
    public static int InvalidProjectId;
    [OptionalFieldAttribute]
private int projectId;
    [OptionalFieldAttribute]
private BuildEventContext parentProjectBuildEventContext;
    private string projectFile;
    private string targetNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OptionalFieldAttribute]
private IDictionary`2<string, string> globalProperties;
    [OptionalFieldAttribute]
private string toolsVersion;
    private IEnumerable properties;
    private IEnumerable items;
    public int ProjectId { get; }
    public BuildEventContext ParentProjectBuildEventContext { get; }
    public string ProjectFile { get; }
    public string TargetNames { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> GlobalProperties { get; internal set; }
    public string ToolsVersion { get; internal set; }
    public IEnumerable Properties { get; }
    public IEnumerable Items { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
public ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, IEnumerable properties, IEnumerable items);
    public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, IEnumerable properties, IEnumerable items, BuildEventContext parentBuildEventContext);
    public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, IEnumerable properties, IEnumerable items, BuildEventContext parentBuildEventContext, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public ProjectStartedEventArgs(string message, string helpKeyword, string projectFile, string targetNames, IEnumerable properties, IEnumerable items, DateTime eventTimestamp);
    public ProjectStartedEventArgs(int projectId, string message, string helpKeyword, string projectFile, string targetNames, IEnumerable properties, IEnumerable items, BuildEventContext parentBuildEventContext, DateTime eventTimestamp);
    public int get_ProjectId();
    public BuildEventContext get_ParentProjectBuildEventContext();
    public string get_ProjectFile();
    public string get_TargetNames();
    public IDictionary`2<string, string> get_GlobalProperties();
    internal void set_GlobalProperties(IDictionary`2<string, string> value);
    public string get_ToolsVersion();
    internal void set_ToolsVersion(string value);
    public IEnumerable get_Properties();
    public IEnumerable get_Items();
    [NullableContextAttribute("1")]
internal virtual void WriteToStream(BinaryWriter writer);
    [NullableContextAttribute("1")]
internal virtual void CreateFromStream(BinaryReader reader, int version);
    [OnDeserializingAttribute]
private void SetDefaultsBeforeSerialization(StreamingContext sc);
    [OnDeserializedAttribute]
private void SetDefaultsAfterSerialization(StreamingContext sc);
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
public class Microsoft.Build.Framework.ProjectStartedEventHandler : MulticastDelegate {
    public ProjectStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ProjectStartedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ProjectStartedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Framework.PropertyInitialValueSetEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertySource>k__BackingField;
    public string PropertyName { get; public set; }
    public string PropertyValue { get; public set; }
    public string PropertySource { get; public set; }
    public PropertyInitialValueSetEventArgs(string propertyName, string propertyValue, string propertySource, string message, string helpKeyword, string senderName, MessageImportance importance);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_PropertyValue();
    [CompilerGeneratedAttribute]
public void set_PropertyValue(string value);
    [CompilerGeneratedAttribute]
public string get_PropertySource();
    [CompilerGeneratedAttribute]
public void set_PropertySource(string value);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public class Microsoft.Build.Framework.PropertyReassignmentEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    public string PropertyName { get; public set; }
    public string PreviousValue { get; public set; }
    public string NewValue { get; public set; }
    public string Location { get; public set; }
    public string Message { get; }
    public PropertyReassignmentEventArgs(string propertyName, string previousValue, string newValue, string location, string message, string helpKeyword, string senderName, MessageImportance importance);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_PreviousValue();
    [CompilerGeneratedAttribute]
public void set_PreviousValue(string value);
    [CompilerGeneratedAttribute]
public string get_NewValue();
    [CompilerGeneratedAttribute]
public void set_NewValue(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(string value);
    public virtual string get_Message();
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public enum Microsoft.Build.Framework.RegisteredTaskObjectLifetime : Enum {
    public int value__;
    public static RegisteredTaskObjectLifetime Build;
    public static RegisteredTaskObjectLifetime AppDomain;
}
[AttributeUsageAttribute("128")]
public class Microsoft.Build.Framework.RequiredAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Microsoft.Build.Framework.RequiredRuntimeAttribute : Attribute {
    private string _runtimeVersion;
    public string RuntimeVersion { get; }
    public RequiredRuntimeAttribute(string runtimeVersion);
    public string get_RuntimeVersion();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ResponseFileUsedEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <ResponseFilePath>k__BackingField;
    public string ResponseFilePath { get; public set; }
    public ResponseFileUsedEventArgs(string responseFilePath);
    [CompilerGeneratedAttribute]
public void set_ResponseFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ResponseFilePath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.ReuseableStringBuilder : object {
    [NullableAttribute("2")]
private StringBuilder _borrowedBuilder;
    private int _borrowedWithCapacity;
    private int _capacity;
    public int Length { get; public set; }
    internal ReuseableStringBuilder(int capacity);
    public int get_Length();
    public void set_Length(int value);
    public virtual string ToString();
    public sealed virtual void Dispose();
    internal ReuseableStringBuilder Append(char value);
    internal ReuseableStringBuilder Append(string value);
    internal ReuseableStringBuilder Append(string value, int startIndex, int count);
    internal ReuseableStringBuilder AppendFormat(CultureInfo currentCulture, string format, Object[] args);
    internal ReuseableStringBuilder AppendLine();
    public ReuseableStringBuilder AppendSeparated(char separator, ICollection`1<string> strings);
    public ReuseableStringBuilder Clear();
    internal ReuseableStringBuilder Remove(int startIndex, int length);
    [MemberNotNullAttribute("_borrowedBuilder")]
private void LazyPrepare();
}
[AttributeUsageAttribute("4")]
public class Microsoft.Build.Framework.RunInMTAAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Microsoft.Build.Framework.RunInSTAAttribute : Attribute {
}
public abstract class Microsoft.Build.Framework.SdkLogger : object {
    public abstract virtual void LogMessage(string message, MessageImportance messageImportance);
}
[DebuggerDisplayAttribute("Name={Name} Version={Version} MinimumVersion={MinimumVersion}")]
public class Microsoft.Build.Framework.SdkReference : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinimumVersion>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public string MinimumVersion { get; }
    public SdkReference(string name, string version, string minimumVersion);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_MinimumVersion();
    public sealed virtual bool Equals(SdkReference other);
    public static bool TryParse(string sdk, SdkReference& sdkReference);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class Microsoft.Build.Framework.SdkResolver : object {
    public string Name { get; }
    public int Priority { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_Priority();
    public abstract virtual SdkResult Resolve(SdkReference sdkReference, SdkResolverContext resolverContext, SdkResultFactory factory);
}
public abstract class Microsoft.Build.Framework.SdkResolverContext : object {
    [CompilerGeneratedAttribute]
private bool <Interactive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private SdkLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <MSBuildVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private object <State>k__BackingField;
    public bool Interactive { get; protected set; }
    public bool IsRunningInVisualStudio { get; protected set; }
    public SdkLogger Logger { get; protected set; }
    public string ProjectFilePath { get; protected set; }
    public string SolutionFilePath { get; protected set; }
    public Version MSBuildVersion { get; protected set; }
    public object State { get; public set; }
    [CompilerGeneratedAttribute]
public virtual bool get_Interactive();
    [CompilerGeneratedAttribute]
protected virtual void set_Interactive(bool value);
    [CompilerGeneratedAttribute]
public virtual bool get_IsRunningInVisualStudio();
    [CompilerGeneratedAttribute]
protected virtual void set_IsRunningInVisualStudio(bool value);
    [CompilerGeneratedAttribute]
public virtual SdkLogger get_Logger();
    [CompilerGeneratedAttribute]
protected virtual void set_Logger(SdkLogger value);
    [CompilerGeneratedAttribute]
public virtual string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
protected virtual void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public virtual string get_SolutionFilePath();
    [CompilerGeneratedAttribute]
protected virtual void set_SolutionFilePath(string value);
    [CompilerGeneratedAttribute]
public virtual Version get_MSBuildVersion();
    [CompilerGeneratedAttribute]
protected virtual void set_MSBuildVersion(Version value);
    [CompilerGeneratedAttribute]
public virtual object get_State();
    [CompilerGeneratedAttribute]
public virtual void set_State(object value);
}
public abstract class Microsoft.Build.Framework.SdkResult : object {
    private protected bool _success;
    private protected string _path;
    private protected string _version;
    private protected IList`1<string> _additionalPaths;
    private protected IDictionary`2<string, string> _propertiesToAdd;
    private protected IDictionary`2<string, SdkResultItem> _itemsToAdd;
    private protected SdkReference _sdkReference;
    public bool Success { get; protected set; }
    public string Path { get; protected set; }
    public string Version { get; protected set; }
    public IList`1<string> AdditionalPaths { get; public set; }
    public IDictionary`2<string, string> PropertiesToAdd { get; protected set; }
    public IDictionary`2<string, SdkResultItem> ItemsToAdd { get; protected set; }
    public SdkReference SdkReference { get; protected set; }
    public virtual bool get_Success();
    protected virtual void set_Success(bool value);
    public virtual string get_Path();
    protected virtual void set_Path(string value);
    public virtual string get_Version();
    protected virtual void set_Version(string value);
    public virtual IList`1<string> get_AdditionalPaths();
    public virtual void set_AdditionalPaths(IList`1<string> value);
    public virtual IDictionary`2<string, string> get_PropertiesToAdd();
    protected virtual void set_PropertiesToAdd(IDictionary`2<string, string> value);
    public virtual IDictionary`2<string, SdkResultItem> get_ItemsToAdd();
    protected virtual void set_ItemsToAdd(IDictionary`2<string, SdkResultItem> value);
    public virtual SdkReference get_SdkReference();
    protected virtual void set_SdkReference(SdkReference value);
}
public abstract class Microsoft.Build.Framework.SdkResultFactory : object {
    public abstract virtual SdkResult IndicateSuccess(string path, string version, IEnumerable`1<string> warnings);
    public virtual SdkResult IndicateSuccess(string path, string version, IDictionary`2<string, string> propertiesToAdd, IDictionary`2<string, SdkResultItem> itemsToAdd, IEnumerable`1<string> warnings);
    public virtual SdkResult IndicateSuccess(IEnumerable`1<string> paths, string version, IDictionary`2<string, string> propertiesToAdd, IDictionary`2<string, SdkResultItem> itemsToAdd, IEnumerable`1<string> warnings);
    public abstract virtual SdkResult IndicateFailure(IEnumerable`1<string> errors, IEnumerable`1<string> warnings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.SdkResultItem : object {
    [CompilerGeneratedAttribute]
private string <ItemSpec>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Metadata>k__BackingField;
    public string ItemSpec { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> Metadata { get; }
    public SdkResultItem(string itemSpec, Dictionary`2<string, string> metadata);
    [CompilerGeneratedAttribute]
public string get_ItemSpec();
    [CompilerGeneratedAttribute]
public void set_ItemSpec(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Metadata();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.Build.Framework.StringBuilderCache : object {
    private static int MAX_BUILDER_SIZE;
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public enum Microsoft.Build.Framework.TargetBuiltReason : Enum {
    public int value__;
    public static TargetBuiltReason None;
    public static TargetBuiltReason BeforeTargets;
    public static TargetBuiltReason DependsOn;
    public static TargetBuiltReason AfterTargets;
}
public class Microsoft.Build.Framework.TargetFinishedEventArgs : BuildStatusEventArgs {
    private string projectFile;
    private string targetFile;
    private string targetName;
    private bool succeeded;
    private IEnumerable targetOutputs;
    public string TargetName { get; }
    public bool Succeeded { get; }
    public string ProjectFile { get; }
    public string TargetFile { get; }
    public IEnumerable TargetOutputs { get; public set; }
    public string Message { get; }
    public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded);
    public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, IEnumerable targetOutputs);
    public TargetFinishedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, bool succeeded, DateTime eventTimestamp, IEnumerable targetOutputs);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public string get_TargetName();
    public bool get_Succeeded();
    public string get_ProjectFile();
    public string get_TargetFile();
    public IEnumerable get_TargetOutputs();
    public void set_TargetOutputs(IEnumerable value);
    public virtual string get_Message();
}
public class Microsoft.Build.Framework.TargetFinishedEventHandler : MulticastDelegate {
    public TargetFinishedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TargetFinishedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TargetFinishedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Framework.TargetSkippedEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private TargetSkipReason <SkipReason>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFile>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetBuiltReason <BuildReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OriginallySucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildEventContext <OriginalBuildEventContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluatedCondition>k__BackingField;
    public TargetSkipReason SkipReason { get; public set; }
    public string TargetName { get; public set; }
    public string ParentTarget { get; public set; }
    public string TargetFile { get; public set; }
    public TargetBuiltReason BuildReason { get; public set; }
    public bool OriginallySucceeded { get; public set; }
    public BuildEventContext OriginalBuildEventContext { get; public set; }
    public string Condition { get; public set; }
    public string EvaluatedCondition { get; public set; }
    public string Message { get; }
    public TargetSkippedEventArgs(string message, Object[] messageArgs);
    [CompilerGeneratedAttribute]
public TargetSkipReason get_SkipReason();
    [CompilerGeneratedAttribute]
public void set_SkipReason(TargetSkipReason value);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public string get_ParentTarget();
    [CompilerGeneratedAttribute]
public void set_ParentTarget(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFile();
    [CompilerGeneratedAttribute]
public void set_TargetFile(string value);
    [CompilerGeneratedAttribute]
public TargetBuiltReason get_BuildReason();
    [CompilerGeneratedAttribute]
public void set_BuildReason(TargetBuiltReason value);
    [CompilerGeneratedAttribute]
public bool get_OriginallySucceeded();
    [CompilerGeneratedAttribute]
public void set_OriginallySucceeded(bool value);
    [CompilerGeneratedAttribute]
public BuildEventContext get_OriginalBuildEventContext();
    [CompilerGeneratedAttribute]
public void set_OriginalBuildEventContext(BuildEventContext value);
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
    [CompilerGeneratedAttribute]
public string get_EvaluatedCondition();
    [CompilerGeneratedAttribute]
public void set_EvaluatedCondition(string value);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public virtual string get_Message();
}
public enum Microsoft.Build.Framework.TargetSkipReason : Enum {
    public int value__;
    public static TargetSkipReason None;
    public static TargetSkipReason PreviouslyBuiltSuccessfully;
    public static TargetSkipReason PreviouslyBuiltUnsuccessfully;
    public static TargetSkipReason OutputsUpToDate;
    public static TargetSkipReason ConditionWasFalse;
}
public class Microsoft.Build.Framework.TargetStartedEventArgs : BuildStatusEventArgs {
    private string targetName;
    private string projectFile;
    private string targetFile;
    private string parentTarget;
    private TargetBuiltReason buildReason;
    public string TargetName { get; }
    public string ParentTarget { get; }
    public string ProjectFile { get; }
    public string TargetFile { get; }
    public TargetBuiltReason BuildReason { get; }
    public string Message { get; }
    public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile);
    public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, DateTime eventTimestamp);
    public TargetStartedEventArgs(string message, string helpKeyword, string targetName, string projectFile, string targetFile, string parentTarget, TargetBuiltReason buildReason, DateTime eventTimestamp);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public string get_TargetName();
    public string get_ParentTarget();
    public string get_ProjectFile();
    public string get_TargetFile();
    public TargetBuiltReason get_BuildReason();
    public virtual string get_Message();
}
public class Microsoft.Build.Framework.TargetStartedEventHandler : MulticastDelegate {
    public TargetStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TargetStartedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TargetStartedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Framework.TaskCommandLineEventArgs : BuildMessageEventArgs {
    public string CommandLine { get; }
    public string TaskName { get; }
    public TaskCommandLineEventArgs(string commandLine, string taskName, MessageImportance importance);
    public TaskCommandLineEventArgs(string commandLine, string taskName, MessageImportance importance, DateTime eventTimestamp);
    public string get_CommandLine();
    public string get_TaskName();
}
public class Microsoft.Build.Framework.TaskFinishedEventArgs : BuildStatusEventArgs {
    private string taskName;
    private string projectFile;
    private string taskFile;
    private bool succeeded;
    public string TaskName { get; }
    public bool Succeeded { get; }
    public string ProjectFile { get; }
    public string TaskFile { get; }
    public string Message { get; }
    public TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded);
    public TaskFinishedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, bool succeeded, DateTime eventTimestamp);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public string get_TaskName();
    public bool get_Succeeded();
    public string get_ProjectFile();
    public string get_TaskFile();
    public virtual string get_Message();
}
public class Microsoft.Build.Framework.TaskFinishedEventHandler : MulticastDelegate {
    public TaskFinishedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TaskFinishedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TaskFinishedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Framework.TaskItemData : object {
    private static Dictionary`2<string, string> _emptyMetadata;
    [CompilerGeneratedAttribute]
private string <ItemSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string ItemSpec { get; public set; }
    public IDictionary`2<string, string> Metadata { get; }
    public int MetadataCount { get; }
    public ICollection MetadataNames { get; }
    public TaskItemData(string itemSpec, IDictionary`2<string, string> metadata);
    public TaskItemData(ITaskItem original);
    private static TaskItemData();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ItemSpec();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ItemSpec(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    private sealed virtual override IEnumerable`1<KeyValuePair`2<string, string>> Microsoft.Build.Framework.IMetadataContainer.EnumerateMetadata();
    private sealed virtual override void Microsoft.Build.Framework.IMetadataContainer.ImportMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public sealed virtual int get_MetadataCount();
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual IDictionary CloneCustomMetadata();
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
    public virtual string ToString();
}
public class Microsoft.Build.Framework.TaskParameterEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private TaskParameterMessageKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private IList <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogItemMetadata>k__BackingField;
    internal static Func`2<TaskParameterEventArgs, string> MessageGetter;
    internal static Func`2<int, IDictionary`2<string, string>> DictionaryFactory;
    [ThreadStaticAttribute]
private static List`1<KeyValuePair`2<string, string>> reusableMetadataList;
    public TaskParameterMessageKind Kind { get; private set; }
    public string ItemType { get; private set; }
    public IList Items { get; private set; }
    public bool LogItemMetadata { get; private set; }
    public string Message { get; }
    public TaskParameterEventArgs(TaskParameterMessageKind kind, string itemType, IList items, bool logItemMetadata, DateTime eventTimestamp);
    private static TaskParameterEventArgs();
    [CompilerGeneratedAttribute]
public TaskParameterMessageKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(TaskParameterMessageKind value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
private void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public IList get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(IList value);
    [CompilerGeneratedAttribute]
public bool get_LogItemMetadata();
    [CompilerGeneratedAttribute]
private void set_LogItemMetadata(bool value);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    private IList ReadItems(BinaryReader reader);
    private object ReadItem(BinaryReader reader);
    internal virtual void WriteToStream(BinaryWriter writer);
    private void WriteItems(BinaryWriter writer, IList items);
    private void WriteItem(BinaryWriter writer, object item);
    private void WriteMetadata(BinaryWriter writer, ITaskItem taskItem);
    public virtual string get_Message();
}
public enum Microsoft.Build.Framework.TaskParameterMessageKind : Enum {
    public int value__;
    public static TaskParameterMessageKind TaskInput;
    public static TaskParameterMessageKind TaskOutput;
    public static TaskParameterMessageKind AddItem;
    public static TaskParameterMessageKind RemoveItem;
    public static TaskParameterMessageKind SkippedTargetInputs;
    public static TaskParameterMessageKind SkippedTargetOutputs;
}
public class Microsoft.Build.Framework.TaskPropertyInfo : object {
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogItemMetadata>k__BackingField;
    internal bool Initialized;
    [CompilerGeneratedAttribute]
private bool <IsValueTypeOutputParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAssignableToITask>k__BackingField;
    public Type PropertyType { get; private set; }
    public string Name { get; private set; }
    public bool Output { get; private set; }
    public bool Required { get; private set; }
    public bool Log { get; public set; }
    public bool LogItemMetadata { get; public set; }
    internal bool IsValueTypeOutputParameter { get; private set; }
    internal bool IsAssignableToITask { get; internal set; }
    public TaskPropertyInfo(string name, Type typeOfParameter, bool output, bool required);
    [CompilerGeneratedAttribute]
public Type get_PropertyType();
    [CompilerGeneratedAttribute]
private void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(bool value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
    [CompilerGeneratedAttribute]
public bool get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogItemMetadata();
    [CompilerGeneratedAttribute]
public void set_LogItemMetadata(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsValueTypeOutputParameter();
    [CompilerGeneratedAttribute]
private void set_IsValueTypeOutputParameter(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsAssignableToITask();
    [CompilerGeneratedAttribute]
internal void set_IsAssignableToITask(bool value);
}
public class Microsoft.Build.Framework.TaskStartedEventArgs : BuildStatusEventArgs {
    private string taskName;
    private string projectFile;
    private string taskFile;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    public string TaskName { get; }
    public string ProjectFile { get; }
    public string TaskFile { get; }
    public int LineNumber { get; internal set; }
    public int ColumnNumber { get; internal set; }
    public string Message { get; }
    public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName);
    public TaskStartedEventArgs(string message, string helpKeyword, string projectFile, string taskFile, string taskName, DateTime eventTimestamp);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
    public string get_TaskName();
    public string get_ProjectFile();
    public string get_TaskFile();
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
internal void set_ColumnNumber(int value);
    public virtual string get_Message();
}
public class Microsoft.Build.Framework.TaskStartedEventHandler : MulticastDelegate {
    public TaskStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TaskStartedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TaskStartedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.Telemetry.BuildTelemetry : TelemetryBase {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <StartAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <InnerStartAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <FinishedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerFallbackReason>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InitialServerState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkName>k__BackingField;
    [NullableAttribute("1")]
public string EventName { get; }
    public Nullable`1<DateTime> StartAt { get; public set; }
    public Nullable`1<DateTime> InnerStartAt { get; public set; }
    public Nullable`1<DateTime> FinishedAt { get; public set; }
    public Nullable`1<bool> Success { get; public set; }
    public string Target { get; public set; }
    public string ServerFallbackReason { get; public set; }
    public Version Version { get; public set; }
    public string DisplayVersion { get; public set; }
    public string Project { get; public set; }
    public string Host { get; public set; }
    public string InitialServerState { get; public set; }
    public string FrameworkName { get; public set; }
    [NullableContextAttribute("1")]
public virtual string get_EventName();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_StartAt();
    [CompilerGeneratedAttribute]
public void set_StartAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_InnerStartAt();
    [CompilerGeneratedAttribute]
public void set_InnerStartAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_FinishedAt();
    [CompilerGeneratedAttribute]
public void set_FinishedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Success();
    [CompilerGeneratedAttribute]
public void set_Success(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_ServerFallbackReason();
    [CompilerGeneratedAttribute]
public void set_ServerFallbackReason(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    [CompilerGeneratedAttribute]
public string get_DisplayVersion();
    [CompilerGeneratedAttribute]
public void set_DisplayVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Project();
    [CompilerGeneratedAttribute]
public void set_Project(string value);
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(string value);
    [CompilerGeneratedAttribute]
public string get_InitialServerState();
    [CompilerGeneratedAttribute]
public void set_InitialServerState(string value);
    [CompilerGeneratedAttribute]
public string get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(string value);
    public virtual void UpdateEventProperties();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Framework.Telemetry.KnownTelemetry : object {
    [CompilerGeneratedAttribute]
private static BuildTelemetry <PartialBuildTelemetry>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static LoggingConfigurationTelemetry <LoggingConfigurationTelemetry>k__BackingField;
    public static BuildTelemetry PartialBuildTelemetry { get; public set; }
    [NullableAttribute("1")]
public static LoggingConfigurationTelemetry LoggingConfigurationTelemetry { get; }
    private static KnownTelemetry();
    [CompilerGeneratedAttribute]
public static BuildTelemetry get_PartialBuildTelemetry();
    [CompilerGeneratedAttribute]
public static void set_PartialBuildTelemetry(BuildTelemetry value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static LoggingConfigurationTelemetry get_LoggingConfigurationTelemetry();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.Telemetry.LoggingConfigurationTelemetry : TelemetryBase {
    [CompilerGeneratedAttribute]
private bool <TerminalLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TerminalLoggerUserIntent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TerminalLoggerUserIntentSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TerminalLoggerDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TerminalLoggerDefaultSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConsoleLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsoleLoggerType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsoleLoggerVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FileLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileLoggerType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileLoggersCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileLoggerVerbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BinaryLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BinaryLoggerUsedDefaultName>k__BackingField;
    [NullableAttribute("1")]
public string EventName { get; }
    public bool TerminalLogger { get; public set; }
    public string TerminalLoggerUserIntent { get; public set; }
    public string TerminalLoggerUserIntentSource { get; public set; }
    public string TerminalLoggerDefault { get; public set; }
    public string TerminalLoggerDefaultSource { get; public set; }
    public bool ConsoleLogger { get; public set; }
    public string ConsoleLoggerType { get; public set; }
    public string ConsoleLoggerVerbosity { get; public set; }
    public bool FileLogger { get; public set; }
    public string FileLoggerType { get; public set; }
    public int FileLoggersCount { get; public set; }
    public string FileLoggerVerbosity { get; public set; }
    public bool BinaryLogger { get; public set; }
    public bool BinaryLoggerUsedDefaultName { get; public set; }
    [NullableContextAttribute("1")]
public virtual string get_EventName();
    [CompilerGeneratedAttribute]
public bool get_TerminalLogger();
    [CompilerGeneratedAttribute]
public void set_TerminalLogger(bool value);
    [CompilerGeneratedAttribute]
public string get_TerminalLoggerUserIntent();
    [CompilerGeneratedAttribute]
public void set_TerminalLoggerUserIntent(string value);
    [CompilerGeneratedAttribute]
public string get_TerminalLoggerUserIntentSource();
    [CompilerGeneratedAttribute]
public void set_TerminalLoggerUserIntentSource(string value);
    [CompilerGeneratedAttribute]
public string get_TerminalLoggerDefault();
    [CompilerGeneratedAttribute]
public void set_TerminalLoggerDefault(string value);
    [CompilerGeneratedAttribute]
public string get_TerminalLoggerDefaultSource();
    [CompilerGeneratedAttribute]
public void set_TerminalLoggerDefaultSource(string value);
    [CompilerGeneratedAttribute]
public bool get_ConsoleLogger();
    [CompilerGeneratedAttribute]
public void set_ConsoleLogger(bool value);
    [CompilerGeneratedAttribute]
public string get_ConsoleLoggerType();
    [CompilerGeneratedAttribute]
public void set_ConsoleLoggerType(string value);
    [CompilerGeneratedAttribute]
public string get_ConsoleLoggerVerbosity();
    [CompilerGeneratedAttribute]
public void set_ConsoleLoggerVerbosity(string value);
    [CompilerGeneratedAttribute]
public bool get_FileLogger();
    [CompilerGeneratedAttribute]
public void set_FileLogger(bool value);
    [CompilerGeneratedAttribute]
public string get_FileLoggerType();
    [CompilerGeneratedAttribute]
public void set_FileLoggerType(string value);
    [CompilerGeneratedAttribute]
public int get_FileLoggersCount();
    [CompilerGeneratedAttribute]
public void set_FileLoggersCount(int value);
    [CompilerGeneratedAttribute]
public string get_FileLoggerVerbosity();
    [CompilerGeneratedAttribute]
public void set_FileLoggerVerbosity(string value);
    [CompilerGeneratedAttribute]
public bool get_BinaryLogger();
    [CompilerGeneratedAttribute]
public void set_BinaryLogger(bool value);
    [CompilerGeneratedAttribute]
public bool get_BinaryLoggerUsedDefaultName();
    [CompilerGeneratedAttribute]
public void set_BinaryLoggerUsedDefaultName(bool value);
    public virtual void UpdateEventProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.Build.Framework.Telemetry.TelemetryBase : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string EventName { get; }
    public IDictionary`2<string, string> Properties { get; public set; }
    public abstract virtual string get_EventName();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
    public abstract virtual void UpdateEventProperties();
}
public class Microsoft.Build.Framework.TelemetryEventArgs : BuildEventArgs {
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string EventName { get; public set; }
    public IDictionary`2<string, string> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(IDictionary`2<string, string> value);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public class Microsoft.Build.Framework.TelemetryEventHandler : MulticastDelegate {
    public TelemetryEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TelemetryEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TelemetryEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Framework.TestInfo : object {
    public static bool s_runningTests;
}
internal class Microsoft.Build.Framework.Traits : object {
    private static Traits _instance;
    [CompilerGeneratedAttribute]
private EscapeHatches <EscapeHatches>k__BackingField;
    internal string MSBuildDisableFeaturesFromVersion;
    public bool UseLazyWildCardEvaluation;
    public bool LogExpandedWildcards;
    public bool ThrowOnDriveEnumeratingWildcard;
    public bool CacheFileExistence;
    public bool UseSimpleProjectRootElementCacheConcurrency;
    public bool MSBuildCacheFileEnumerations;
    public bool EnableAllPropertyFunctions;
    public bool EnableRestoreFirst;
    public static string MSBuildNodeHandshakeSalt;
    public bool ForceEvaluateAsFullFramework;
    public int CopyTaskParallelism;
    public bool EmitSolutionMetaproj;
    public bool SolutionBatchTargets;
    public bool LogPropertyFunctionsRequiringReflection;
    public bool LogAllAssemblyLoads;
    public static bool LogAllEnvironmentVariables;
    public int LogPropertyTracking;
    public int DictionaryBasedItemRemoveThreshold;
    public static string UseMSBuildServerEnvVarName;
    public bool DebugEngine;
    public bool DebugScheduler;
    public bool DebugNodeCommunication;
    public bool InProcNodeDisabled;
    public static Traits Instance { get; }
    public EscapeHatches EscapeHatches { get; }
    private static Traits();
    public static Traits get_Instance();
    [CompilerGeneratedAttribute]
public EscapeHatches get_EscapeHatches();
    private static int ParseIntFromEnvironmentVariableOrDefault(string environmentVariable, int defaultValue);
}
public class Microsoft.Build.Framework.UninitializedPropertyReadEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; public set; }
    public UninitializedPropertyReadEventArgs(string propertyName, string message, string helpKeyword, string senderName, MessageImportance importance);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    internal virtual void WriteToStream(BinaryWriter writer);
    internal virtual void CreateFromStream(BinaryReader reader, int version);
}
public class Microsoft.Build.Framework.XamlTypes.Argument : object {
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    public string Property { get; public set; }
    public bool IsRequired { get; public set; }
    public string Separator { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(string value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
[ContentPropertyAttribute("Arguments")]
public abstract class Microsoft.Build.Framework.XamlTypes.BaseProperty : object {
    private string _displayName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <F1Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HelpContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MultipleValuesAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Switch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SwitchPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Visible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInCommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private DataSource <DataSource>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NameValuePair> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Argument> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ValueEditor> <ValueEditors>k__BackingField;
    [CompilerGeneratedAttribute]
private Rule <ContainingRule>k__BackingField;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    [LocalizableAttribute("True")]
public string Description { get; public set; }
    [LocalizableAttribute("False")]
public string F1Keyword { get; public set; }
    [LocalizableAttribute("False")]
public string HelpUrl { get; public set; }
    [LocalizableAttribute("False")]
public string HelpFile { get; public set; }
    public int HelpContext { get; public set; }
    public string Category { get; public set; }
    public string Subcategory { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool MultipleValuesAllowed { get; public set; }
    public string Switch { get; public set; }
    public string SwitchPrefix { get; public set; }
    public string Separator { get; public set; }
    public bool Visible { get; public set; }
    public bool IncludeInCommandLine { get; public set; }
    public bool IsRequired { get; public set; }
    [LocalizableAttribute("True")]
public string Default { get; public set; }
    public DataSource DataSource { get; public set; }
    public List`1<NameValuePair> Metadata { get; public set; }
    public List`1<Argument> Arguments { get; public set; }
    public List`1<ValueEditor> ValueEditors { get; public set; }
    public Rule ContainingRule { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_F1Keyword();
    [CompilerGeneratedAttribute]
public void set_F1Keyword(string value);
    [CompilerGeneratedAttribute]
public string get_HelpUrl();
    [CompilerGeneratedAttribute]
public void set_HelpUrl(string value);
    [CompilerGeneratedAttribute]
public string get_HelpFile();
    [CompilerGeneratedAttribute]
public void set_HelpFile(string value);
    [CompilerGeneratedAttribute]
public int get_HelpContext();
    [CompilerGeneratedAttribute]
public void set_HelpContext(int value);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    [CompilerGeneratedAttribute]
public bool get_ReadOnly();
    [CompilerGeneratedAttribute]
public void set_ReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_MultipleValuesAllowed();
    [CompilerGeneratedAttribute]
public void set_MultipleValuesAllowed(bool value);
    [CompilerGeneratedAttribute]
public string get_Switch();
    [CompilerGeneratedAttribute]
public void set_Switch(string value);
    [CompilerGeneratedAttribute]
public string get_SwitchPrefix();
    [CompilerGeneratedAttribute]
public void set_SwitchPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public bool get_Visible();
    [CompilerGeneratedAttribute]
public void set_Visible(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeInCommandLine();
    [CompilerGeneratedAttribute]
public void set_IncludeInCommandLine(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public string get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(string value);
    [CompilerGeneratedAttribute]
public DataSource get_DataSource();
    [CompilerGeneratedAttribute]
public void set_DataSource(DataSource value);
    [CompilerGeneratedAttribute]
public List`1<NameValuePair> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(List`1<NameValuePair> value);
    [CompilerGeneratedAttribute]
public List`1<Argument> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<Argument> value);
    [CompilerGeneratedAttribute]
public List`1<ValueEditor> get_ValueEditors();
    [CompilerGeneratedAttribute]
public void set_ValueEditors(List`1<ValueEditor> value);
    [CompilerGeneratedAttribute]
public Rule get_ContainingRule();
    [CompilerGeneratedAttribute]
internal void set_ContainingRule(Rule value);
    public virtual void BeginInit();
    public virtual void EndInit();
}
public class Microsoft.Build.Framework.XamlTypes.BoolProperty : BaseProperty {
    [CompilerGeneratedAttribute]
private string <ReverseSwitch>k__BackingField;
    public string ReverseSwitch { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ReverseSwitch();
    [CompilerGeneratedAttribute]
public void set_ReverseSwitch(string value);
}
public class Microsoft.Build.Framework.XamlTypes.Category : CategorySchema {
    private string _displayName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subtype>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpString>k__BackingField;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    [LocalizableAttribute("True")]
public string Description { get; public set; }
    public string Subtype { get; public set; }
    [LocalizableAttribute("True")]
public string HelpString { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Subtype();
    [CompilerGeneratedAttribute]
public void set_Subtype(string value);
    [CompilerGeneratedAttribute]
public string get_HelpString();
    [CompilerGeneratedAttribute]
public void set_HelpString(string value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
public abstract class Microsoft.Build.Framework.XamlTypes.CategorySchema : object {
}
[ContentPropertyAttribute("Metadata")]
public class Microsoft.Build.Framework.XamlTypes.ContentType : object {
    private Lazy`1<Dictionary`2<string, string>> _metadata;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultContentTypeForItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemGroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NameValuePair> <Metadata>k__BackingField;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    public string ItemType { get; public set; }
    public bool DefaultContentTypeForItemType { get; public set; }
    [ObsoleteAttribute("Unused.  Use ItemType property instead.", "True")]
public string ItemGroupName { get; public set; }
    public List`1<NameValuePair> Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public bool get_DefaultContentTypeForItemType();
    [CompilerGeneratedAttribute]
public void set_DefaultContentTypeForItemType(bool value);
    [CompilerGeneratedAttribute]
public string get_ItemGroupName();
    [CompilerGeneratedAttribute]
public void set_ItemGroupName(string value);
    [CompilerGeneratedAttribute]
public List`1<NameValuePair> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(List`1<NameValuePair> value);
    public string GetMetadata(string metadataName);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.ContentType/<GetSchemaObjectTypes>d__29")]
public sealed virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.ContentType/<GetSchemaObjects>d__30")]
public sealed virtual IEnumerable`1<object> GetSchemaObjects(Type type);
    private Dictionary`2<string, string> InitializeMetadata();
}
public class Microsoft.Build.Framework.XamlTypes.DataSource : object {
    [CompilerGeneratedAttribute]
private string <Persistence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PersistenceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PersistedName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConfigurationCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private DefaultValueSourceLocation <SourceOfDefaultValue>k__BackingField;
    public string Persistence { get; public set; }
    public string PersistenceStyle { get; public set; }
    public string PersistedName { get; public set; }
    public string Label { get; public set; }
    public string ItemType { get; public set; }
    public bool HasConfigurationCondition { get; public set; }
    public string SourceType { get; public set; }
    public string MSBuildTarget { get; public set; }
    public DefaultValueSourceLocation SourceOfDefaultValue { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Persistence();
    [CompilerGeneratedAttribute]
public void set_Persistence(string value);
    [CompilerGeneratedAttribute]
public string get_PersistenceStyle();
    [CompilerGeneratedAttribute]
public void set_PersistenceStyle(string value);
    [CompilerGeneratedAttribute]
public string get_PersistedName();
    [CompilerGeneratedAttribute]
public void set_PersistedName(string value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public bool get_HasConfigurationCondition();
    [CompilerGeneratedAttribute]
public void set_HasConfigurationCondition(bool value);
    [CompilerGeneratedAttribute]
public string get_SourceType();
    [CompilerGeneratedAttribute]
public void set_SourceType(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildTarget();
    [CompilerGeneratedAttribute]
public void set_MSBuildTarget(string value);
    [CompilerGeneratedAttribute]
public DefaultValueSourceLocation get_SourceOfDefaultValue();
    [CompilerGeneratedAttribute]
public void set_SourceOfDefaultValue(DefaultValueSourceLocation value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
public enum Microsoft.Build.Framework.XamlTypes.DefaultValueSourceLocation : Enum {
    public int value__;
    public static DefaultValueSourceLocation BeforeContext;
    public static DefaultValueSourceLocation AfterContext;
}
public class Microsoft.Build.Framework.XamlTypes.DynamicEnumProperty : BaseProperty {
    [CompilerGeneratedAttribute]
private string <EnumProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NameValuePair> <ProviderSettings>k__BackingField;
    public string EnumProvider { get; public set; }
    public List`1<NameValuePair> ProviderSettings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EnumProvider();
    [CompilerGeneratedAttribute]
public void set_EnumProvider(string value);
    [CompilerGeneratedAttribute]
public List`1<NameValuePair> get_ProviderSettings();
    [CompilerGeneratedAttribute]
public void set_ProviderSettings(List`1<NameValuePair> value);
}
[ContentPropertyAttribute("AdmissibleValues")]
public class Microsoft.Build.Framework.XamlTypes.EnumProperty : BaseProperty {
    [CompilerGeneratedAttribute]
private List`1<EnumValue> <AdmissibleValues>k__BackingField;
    public List`1<EnumValue> AdmissibleValues { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<EnumValue> get_AdmissibleValues();
    [CompilerGeneratedAttribute]
public void set_AdmissibleValues(List`1<EnumValue> value);
    public virtual void EndInit();
}
[ContentPropertyAttribute("Arguments")]
public class Microsoft.Build.Framework.XamlTypes.EnumValue : object {
    private string _displayName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Switch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SwitchPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NameValuePair> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Argument> <Arguments>k__BackingField;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    [LocalizableAttribute("True")]
public string Description { get; public set; }
    [LocalizableAttribute("True")]
public string HelpString { get; public set; }
    public string Switch { get; public set; }
    public string SwitchPrefix { get; public set; }
    public bool IsDefault { get; public set; }
    public List`1<NameValuePair> Metadata { get; public set; }
    public List`1<Argument> Arguments { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_HelpString();
    [CompilerGeneratedAttribute]
public void set_HelpString(string value);
    [CompilerGeneratedAttribute]
public string get_Switch();
    [CompilerGeneratedAttribute]
public void set_Switch(string value);
    [CompilerGeneratedAttribute]
public string get_SwitchPrefix();
    [CompilerGeneratedAttribute]
public void set_SwitchPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public void set_IsDefault(bool value);
    [CompilerGeneratedAttribute]
public List`1<NameValuePair> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(List`1<NameValuePair> value);
    [CompilerGeneratedAttribute]
public List`1<Argument> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<Argument> value);
}
public class Microsoft.Build.Framework.XamlTypes.FileExtension : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    public string Name { get; public set; }
    public string ContentType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.FileExtension/<GetSchemaObjectTypes>d__9")]
public sealed virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.FileExtension/<GetSchemaObjects>d__10")]
public sealed virtual IEnumerable`1<object> GetSchemaObjects(Type type);
}
public class Microsoft.Build.Framework.XamlTypes.IntProperty : BaseProperty {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxValue>k__BackingField;
    public Nullable`1<int> MinValue { get; public set; }
    public Nullable`1<int> MaxValue { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinValue();
    [CompilerGeneratedAttribute]
public void set_MinValue(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxValue();
    [CompilerGeneratedAttribute]
public void set_MaxValue(Nullable`1<int> value);
    public virtual void EndInit();
}
public interface Microsoft.Build.Framework.XamlTypes.IProjectSchemaNode {
    public abstract virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    public abstract virtual IEnumerable`1<object> GetSchemaObjects(Type type);
}
public class Microsoft.Build.Framework.XamlTypes.ItemType : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpToDateCheckInput>k__BackingField;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    public string DefaultContentType { get; public set; }
    public bool UpToDateCheckInput { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultContentType();
    [CompilerGeneratedAttribute]
public void set_DefaultContentType(string value);
    [CompilerGeneratedAttribute]
public bool get_UpToDateCheckInput();
    [CompilerGeneratedAttribute]
public void set_UpToDateCheckInput(bool value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.ItemType/<GetSchemaObjectTypes>d__19")]
public sealed virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.ItemType/<GetSchemaObjects>d__20")]
public sealed virtual IEnumerable`1<object> GetSchemaObjects(Type type);
}
public class Microsoft.Build.Framework.XamlTypes.NameValuePair : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
}
[ContentPropertyAttribute("Nodes")]
public class Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions : object {
    [CompilerGeneratedAttribute]
private List`1<IProjectSchemaNode> <Nodes>k__BackingField;
    public List`1<IProjectSchemaNode> Nodes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<IProjectSchemaNode> get_Nodes();
    [CompilerGeneratedAttribute]
public void set_Nodes(List`1<IProjectSchemaNode> value);
    public sealed virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.ProjectSchemaDefinitions/<GetSchemaObjects>d__6")]
public sealed virtual IEnumerable`1<object> GetSchemaObjects(Type type);
}
[ContentPropertyAttribute("Properties")]
[DebuggerDisplayAttribute("Rule: {Name}")]
public class Microsoft.Build.Framework.XamlTypes.Rule : RuleSchema {
    private string _displayName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SwitchPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PageTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private DataSource <DataSource>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsFileBatching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowOnlyRuleProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExecutionDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Outputs>k__BackingField;
    [CompilerGeneratedAttribute]
private RuleOverrideMode <OverrideMode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BaseProperty> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Category> <Categories>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropertyPagesHidden>k__BackingField;
    private object _syncObject;
    private List`1<Category> _evaluatedCategories;
    private OrderedDictionary _categoryNamePropertyListMap;
    private ReadOnlyDictionary`2<string, BaseProperty> _propertiesByNameMap;
    public string Name { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    public string ToolName { get; public set; }
    [LocalizableAttribute("True")]
public string Description { get; public set; }
    [LocalizableAttribute("True")]
public string HelpString { get; public set; }
    public string SwitchPrefix { get; public set; }
    public string Separator { get; public set; }
    public string PageTemplate { get; public set; }
    public DataSource DataSource { get; public set; }
    public int Order { get; public set; }
    public bool SupportsFileBatching { get; public set; }
    public bool ShowOnlyRuleProperties { get; public set; }
    public string FileExtension { get; public set; }
    public string ExecutionDescription { get; public set; }
    public string CommandLine { get; public set; }
    public string AdditionalInputs { get; public set; }
    public string Outputs { get; public set; }
    public RuleOverrideMode OverrideMode { get; public set; }
    public List`1<BaseProperty> Properties { get; public set; }
    public List`1<Category> Categories { get; public set; }
    public Dictionary`2<string, object> Metadata { get; public set; }
    public bool PropertyPagesHidden { get; public set; }
    public List`1<Category> EvaluatedCategories { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_ToolName();
    [CompilerGeneratedAttribute]
public void set_ToolName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_HelpString();
    [CompilerGeneratedAttribute]
public void set_HelpString(string value);
    [CompilerGeneratedAttribute]
public string get_SwitchPrefix();
    [CompilerGeneratedAttribute]
public void set_SwitchPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public string get_PageTemplate();
    [CompilerGeneratedAttribute]
public void set_PageTemplate(string value);
    [CompilerGeneratedAttribute]
public DataSource get_DataSource();
    [CompilerGeneratedAttribute]
public void set_DataSource(DataSource value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public bool get_SupportsFileBatching();
    [CompilerGeneratedAttribute]
public void set_SupportsFileBatching(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowOnlyRuleProperties();
    [CompilerGeneratedAttribute]
public void set_ShowOnlyRuleProperties(bool value);
    [CompilerGeneratedAttribute]
public string get_FileExtension();
    [CompilerGeneratedAttribute]
public void set_FileExtension(string value);
    [CompilerGeneratedAttribute]
public string get_ExecutionDescription();
    [CompilerGeneratedAttribute]
public void set_ExecutionDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CommandLine();
    [CompilerGeneratedAttribute]
public void set_CommandLine(string value);
    [CompilerGeneratedAttribute]
public string get_AdditionalInputs();
    [CompilerGeneratedAttribute]
public void set_AdditionalInputs(string value);
    [CompilerGeneratedAttribute]
public string get_Outputs();
    [CompilerGeneratedAttribute]
public void set_Outputs(string value);
    [CompilerGeneratedAttribute]
public RuleOverrideMode get_OverrideMode();
    [CompilerGeneratedAttribute]
public void set_OverrideMode(RuleOverrideMode value);
    [CompilerGeneratedAttribute]
public List`1<BaseProperty> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<BaseProperty> value);
    [CompilerGeneratedAttribute]
public List`1<Category> get_Categories();
    [CompilerGeneratedAttribute]
public void set_Categories(List`1<Category> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(Dictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public bool get_PropertyPagesHidden();
    [CompilerGeneratedAttribute]
public void set_PropertyPagesHidden(bool value);
    public List`1<Category> get_EvaluatedCategories();
    public OrderedDictionary GetPropertiesByCategory();
    public IList`1<BaseProperty> GetPropertiesInCategory(string categoryName);
    public BaseProperty GetProperty(string propertyName);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.Rule/<GetSchemaObjectTypes>d__100")]
public sealed virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.Rule/<GetSchemaObjects>d__101")]
public sealed virtual IEnumerable`1<object> GetSchemaObjects(Type type);
    private void Initialize();
    private void CreateCategoryNamePropertyListMap();
}
[ContentPropertyAttribute("Rules")]
public class Microsoft.Build.Framework.XamlTypes.RuleBag : object {
    [CompilerGeneratedAttribute]
private List`1<Rule> <Rules>k__BackingField;
    public List`1<Rule> Rules { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Rule> get_Rules();
    [CompilerGeneratedAttribute]
public void set_Rules(List`1<Rule> value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.RuleBag/<GetSchemaObjectTypes>d__7")]
public sealed virtual IEnumerable`1<Type> GetSchemaObjectTypes();
    [IteratorStateMachineAttribute("Microsoft.Build.Framework.XamlTypes.RuleBag/<GetSchemaObjects>d__8")]
public sealed virtual IEnumerable`1<object> GetSchemaObjects(Type type);
}
public enum Microsoft.Build.Framework.XamlTypes.RuleOverrideMode : Enum {
    public int value__;
    public static RuleOverrideMode Replace;
    public static RuleOverrideMode Extend;
}
public abstract class Microsoft.Build.Framework.XamlTypes.RuleSchema : object {
}
public class Microsoft.Build.Framework.XamlTypes.StringListProperty : BaseProperty {
    [CompilerGeneratedAttribute]
private string <CommandLineValueSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RendererValueSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subtype>k__BackingField;
    public string CommandLineValueSeparator { get; public set; }
    public string RendererValueSeparator { get; public set; }
    public string Subtype { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CommandLineValueSeparator();
    [CompilerGeneratedAttribute]
public void set_CommandLineValueSeparator(string value);
    [CompilerGeneratedAttribute]
public string get_RendererValueSeparator();
    [CompilerGeneratedAttribute]
public void set_RendererValueSeparator(string value);
    [CompilerGeneratedAttribute]
public string get_Subtype();
    [CompilerGeneratedAttribute]
public void set_Subtype(string value);
}
public class Microsoft.Build.Framework.XamlTypes.StringProperty : BaseProperty {
    [CompilerGeneratedAttribute]
private string <Subtype>k__BackingField;
    public string Subtype { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Subtype();
    [CompilerGeneratedAttribute]
public void set_Subtype(string value);
}
[ContentPropertyAttribute("Metadata")]
public class Microsoft.Build.Framework.XamlTypes.ValueEditor : object {
    private string _displayName;
    [CompilerGeneratedAttribute]
private string <EditorType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<NameValuePair> <Metadata>k__BackingField;
    public string EditorType { get; public set; }
    [LocalizableAttribute("True")]
public string DisplayName { get; public set; }
    public List`1<NameValuePair> Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EditorType();
    [CompilerGeneratedAttribute]
public void set_EditorType(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public List`1<NameValuePair> get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(List`1<NameValuePair> value);
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Logging.TerminalLogger.AnsiCodes : object {
    public static string CSI;
    public static string SetColor;
    public static string SetBold;
    public static string SetDefaultColor;
    public static string LinkPrefix;
    public static string LinkInfix;
    public static string LinkSuffix;
    public static string MoveUpToLineStart;
    public static string MoveForward;
    public static string MoveBackward;
    public static string EraseInDisplay;
    public static string EraseInLine;
    public static string HideCursor;
    public static string ShowCursor;
    public static string SetProgressIndeterminate;
    public static string RemoveProgress;
    public static string Colorize(string s, TerminalColor color);
    public static string MakeBold(string s);
}
internal enum Microsoft.Build.Logging.TerminalLogger.TerminalColor : Enum {
    public int value__;
    public static TerminalColor Black;
    public static TerminalColor Red;
    public static TerminalColor Green;
    public static TerminalColor Yellow;
    public static TerminalColor Blue;
    public static TerminalColor Magenta;
    public static TerminalColor Cyan;
    public static TerminalColor White;
    public static TerminalColor Default;
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AssemblyUtilities : object {
    private static Lazy`1<Assembly> s_entryAssembly;
    public static Assembly EntryAssembly { get; }
    private static AssemblyUtilities();
    public static Assembly get_EntryAssembly();
    public static string GetAssemblyLocation(Assembly assembly);
    [ExtensionAttribute]
public static AssemblyName CloneIfPossible(AssemblyName assemblyNameToClone);
    public static CultureInfo[] GetAllCultures();
    private static Assembly GetEntryAssembly();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.BinaryReaderExtensions : object {
    [ExtensionAttribute]
public static string ReadOptionalString(BinaryReader reader);
    [ExtensionAttribute]
public static int ReadOptionalInt32(BinaryReader reader);
    [ExtensionAttribute]
public static int Read7BitEncodedInt(BinaryReader reader);
    [ExtensionAttribute]
public static DateTime ReadTimestamp(BinaryReader reader);
    [ExtensionAttribute]
public static BuildEventContext ReadOptionalBuildEventContext(BinaryReader reader);
    [ExtensionAttribute]
public static BuildEventContext ReadBuildEventContext(BinaryReader reader);
    [ExtensionAttribute]
public static Guid ReadGuid(BinaryReader reader);
    [ExtensionAttribute]
public static void ReadExtendedBuildEventData(BinaryReader reader, IExtendedBuildEventArgs data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.BinaryWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteOptionalString(BinaryWriter writer, string value);
    [ExtensionAttribute]
public static void WriteOptionalInt32(BinaryWriter writer, Nullable`1<int> value);
    [ExtensionAttribute]
public static void WriteTimestamp(BinaryWriter writer, DateTime timestamp);
    [ExtensionAttribute]
public static void Write7BitEncodedInt(BinaryWriter writer, int value);
    [ExtensionAttribute]
public static void WriteOptionalBuildEventContext(BinaryWriter writer, BuildEventContext context);
    [ExtensionAttribute]
public static void WriteBuildEventContext(BinaryWriter writer, BuildEventContext context);
    [ExtensionAttribute]
public static void WriteGuid(BinaryWriter writer, Guid value);
    [ExtensionAttribute]
public static void WriteExtendedBuildEventData(BinaryWriter writer, IExtendedBuildEventArgs data);
}
internal class Microsoft.Build.Shared.Debugging.CommonWriter : object {
    [CompilerGeneratedAttribute]
private static Action`3<string, string, IEnumerable`1<string>> <Writer>k__BackingField;
    public static Action`3<string, string, IEnumerable`1<string>> Writer { get; public set; }
    [CompilerGeneratedAttribute]
public static Action`3<string, string, IEnumerable`1<string>> get_Writer();
    [CompilerGeneratedAttribute]
public static void set_Writer(Action`3<string, string, IEnumerable`1<string>> value);
}
internal static class Microsoft.Build.Shared.DesignTimeProperties : object {
    internal static string DesignTimeBuild;
    internal static string BuildingProject;
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.EncodingUtilities : object {
    internal static Encoding Utf8WithoutBom;
    private static Encoding s_currentOemEncoding;
    internal static string UseUtf8Always;
    internal static string UseUtf8Never;
    internal static string UseUtf8Detect;
    internal static string UseUtf8System;
    internal static Encoding CurrentSystemOemEncoding { get; }
    private static EncodingUtilities();
    internal static Encoding get_CurrentSystemOemEncoding();
    [ExtensionAttribute]
internal static bool SimilarToEncoding(Encoding encoding1, Encoding encoding2);
    [ExtensionAttribute]
internal static bool IsUtf8Encoding(Encoding encoding);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream);
    [ExtensionAttribute]
internal static bool StartsWithPreamble(Stream stream, Byte[] preamble);
    internal static bool FileStartsWithPreamble(string file);
    internal static bool CanEncodeString(int codePage, string stringToEncode);
    internal static Encoding BatchFileEncoding(string contents, string encodingSpecification);
    [NullableContextAttribute("2")]
public static CultureInfo GetExternalOverriddenUILanguageIfSupportableWithEncoding();
    public static bool CurrentPlatformIsWindowsAndOfficiallySupportsUTF8Encoding();
    private static bool ForceUniversalEncodingOptInEnabled();
    [NullableContextAttribute("2")]
private static CultureInfo GetExternalOverriddenUILanguage();
}
internal static class Microsoft.Build.Shared.ItemMetadataNames : object {
    internal static string fusionName;
    internal static string hintPath;
    internal static string assemblyFolderKey;
    internal static string alias;
    internal static string aliases;
    internal static string parentFile;
    internal static string privateMetadata;
    internal static string copyLocal;
    internal static string isRedistRoot;
    internal static string redist;
    internal static string resolvedFrom;
    internal static string destinationSubDirectory;
    internal static string destinationSubPath;
    internal static string specificVersion;
    internal static string link;
    internal static string subType;
    internal static string executableExtension;
    internal static string embedInteropTypes;
    internal static string frameworkReferenceName;
    internal static string assemblyName;
    internal static string assemblyVersion;
    internal static string publicKeyToken;
    internal static string targetPath;
    internal static string dependentUpon;
    internal static string msbuildSourceProjectFile;
    internal static string msbuildSourceTargetName;
    internal static string isPrimary;
    internal static string targetFramework;
    internal static string frameworkDirectory;
    internal static string version;
    internal static string imageRuntime;
    internal static string winMDFile;
    internal static string winMDFileType;
    internal static string msbuildReferenceSourceTarget;
    internal static string msbuildReferenceGrouping;
    internal static string msbuildReferenceGroupingDisplayName;
    internal static string msbuildReferenceFromSDK;
    internal static string winmdImplmentationFile;
    internal static string projectReferenceOriginalItemSpec;
    internal static string IgnoreVersionForFrameworkReference;
    internal static string frameworkFile;
    internal static string ProjectReferenceTargetsMetadataName;
    internal static string PropertiesMetadataName;
    internal static string UndefinePropertiesMetadataName;
    internal static string AdditionalPropertiesMetadataName;
    internal static string ProjectConfigurationDescription;
}
internal static class Microsoft.Build.Shared.ItemTypeNames : object {
    internal static string ProjectReference;
    internal static string ProjectReferenceTargets;
    internal static string GraphIsolationExemptReference;
    internal static string ProjectCachePlugin;
    internal static string EmbedInBinlog;
}
internal static class Microsoft.Build.Shared.MSBuildConstants : object {
    internal static string ToolsPath;
    internal static string ToolsPath64;
    internal static string SdksPath;
    internal static string TreatWarningsAsErrors;
    internal static string WarningsAsErrors;
    internal static string WarningsNotAsErrors;
    internal static string WarningsAsMessages;
    internal static string NuGetAssemblyPathEnvironmentVariableName;
    internal static string RestoreTargetName;
    internal static string CurrentVisualStudioVersion;
    internal static string CurrentToolsVersion;
    internal static string MSBuildDummyGlobalPropertyHeader;
    internal static string CurrentAssemblyVersion;
    internal static string CurrentProductVersion;
    internal static string DefaultTargetsMarker;
    internal static string StandardTestTargetFrameworkVersion;
    internal static string ProjectReferenceTargetsOrDefaultTargetsMarker;
    internal static Char[] SemicolonChar;
    internal static Char[] SpaceChar;
    internal static Char[] SingleQuoteChar;
    internal static Char[] EqualsChar;
    internal static Char[] ColonChar;
    internal static Char[] BackslashChar;
    internal static Char[] NewlineChar;
    internal static Char[] CrLf;
    internal static Char[] ForwardSlash;
    internal static Char[] ForwardSlashBackslash;
    internal static Char[] WildcardChars;
    internal static String[] CharactersForExpansion;
    internal static Char[] CommaChar;
    internal static Char[] HyphenChar;
    internal static Char[] DirectorySeparatorChar;
    internal static Char[] DotChar;
    internal static String[] EnvironmentNewLine;
    internal static Char[] PipeChar;
    internal static Char[] PathSeparatorChar;
    private static MSBuildConstants();
}
internal static class Microsoft.Build.Shared.PropertyNames : object {
    internal static string IsGraphBuild;
    internal static string InnerBuildProperty;
    internal static string InnerBuildPropertyValues;
}
internal class Microsoft.Build.Shared.VisualStudioInstance : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal Version Version { get; }
    internal string Path { get; }
    internal string Name { get; }
    internal VisualStudioInstance(string name, string path, Version version);
    [CompilerGeneratedAttribute]
internal Version get_Version();
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal string get_Name();
}
internal class Microsoft.Build.Shared.VisualStudioLocationHelper : object {
    private static int REGDB_E_CLASSNOTREG;
    internal static IList`1<VisualStudioInstance> GetInstances();
    private static ISetupConfiguration GetQuery();
    private static int GetSetupConfiguration(ISetupConfiguration& configuration, IntPtr reserved);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary : object {
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create();
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedDictionary`2<TKey, TValue> Empty;
    private SegmentedDictionary`2<TKey, TValue> _dictionary;
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDefault { get; }
    public bool IsDefaultOrEmpty { get; }
    [NullableAttribute("0")]
public KeyCollection<TKey, TValue> Keys { get; }
    [NullableAttribute("0")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ImmutableSegmentedDictionary`2(SegmentedDictionary`2<TKey, TValue> dictionary);
    private static ImmutableSegmentedDictionary`2();
    public IEqualityComparer`1<TKey> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    [NullableContextAttribute("0")]
public KeyCollection<TKey, TValue> get_Keys();
    [NullableContextAttribute("0")]
public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public static bool op_Equality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Inequality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    public ImmutableSegmentedDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableSegmentedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> WithComparer(IEqualityComparer`1<TKey> keyComparer);
    public Builder<TKey, TValue> ToBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedDictionary`2<TKey, TValue> other);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private static bool TryCastToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, ImmutableSegmentedDictionary`2& other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> Create();
    public static ImmutableSegmentedList`1<T> Create(T item);
    public static ImmutableSegmentedList`1<T> Create(T[] items);
    public static Builder<T> CreateBuilder();
    public static ImmutableSegmentedList`1<T> CreateRange(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(Builder<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedList`1<T> Empty;
    private SegmentedList`1<T> _list;
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private ImmutableSegmentedList`1(SegmentedList`1<T> list);
    private static ImmutableSegmentedList`1();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static bool op_Equality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public ImmutableSegmentedList`1<T> Add(T value);
    public ImmutableSegmentedList`1<T> AddRange(IEnumerable`1<T> items);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T value);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Insert(int index, T item);
    public ImmutableSegmentedList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Remove(T value);
    public ImmutableSegmentedList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> RemoveAt(int index);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveRange(int index, int count);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Reverse();
    public ImmutableSegmentedList`1<T> Reverse(int index, int count);
    public ImmutableSegmentedList`1<T> SetItem(int index, T value);
    public ImmutableSegmentedList`1<T> Sort();
    public ImmutableSegmentedList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableSegmentedList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<T> ToValueBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedList`1<T> other);
    public bool TrueForAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument key;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument source;
    public static ExceptionArgument length;
    public static ExceptionArgument destinationArray;
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_IComparerFailed;
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.HashHelpers : object {
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    private static ImmutableArray`1<int> s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls : object {
    public static bool IsSynchronized(TCollection& collection);
    public static void CopyTo(TCollection& collection, Array array, int index);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1 : object {
    [NullableContextAttribute("1")]
public static bool IsReadOnly(TCollection& collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls : object {
    [NullableContextAttribute("1")]
public static IEnumerator GetEnumerator(TEnumerable& enumerable);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1 : object {
    [NullableContextAttribute("1")]
public static IEnumerator`1<T> GetEnumerator(TEnumerable& enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.IListCalls : object {
    public static object GetItem(TList& list, int index);
    public static void SetItem(TList& list, int index, object value);
    public static bool IsFixedSize(TList& list);
    public static bool IsReadOnly(TList& list);
    public static int Add(TList& list, object value);
    public static bool Contains(TList& list, object value);
    public static int IndexOf(TList& list, object value);
    public static void Insert(TList& list, int index, object value);
    public static void Remove(TList& list, object value);
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe : object {
    public static T& NullRef();
    public static bool IsNullRef(T& source);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper : object {
    internal static int IntrosortSizeThreshold;
    internal static MethodImplOptions FastPathMethodImplOptions;
    [NullableContextAttribute("2")]
internal static int GetSegmentSize();
    [NullableContextAttribute("2")]
internal static int GetSegmentShift();
    [NullableContextAttribute("2")]
internal static int GetOffsetMask();
    private static int CalculateSegmentSize(int elementSize);
    private static int CalculateSegmentShift(int segmentSize);
    private static int CalculateOffsetMask(int segmentSize);
    [CompilerGeneratedAttribute]
internal static int <CalculateSegmentSize>g__ArraySize|5_0(int elementSize, int segmentSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySegment`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SegmentedArray`1<T> <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SegmentedArray`1<T> Array { get; }
    public int Start { get; }
    public int Length { get; }
    public T& Item { get; }
    public SegmentedArraySegment`1(SegmentedArray`1<T> array, int start, int length);
    [CompilerGeneratedAttribute]
public SegmentedArray`1<T> get_Array();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public T& get_Item(int index);
    public SegmentedArraySegment`1<T> Slice(int start);
    public SegmentedArraySegment`1<T> Slice(int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<T> a, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void HeapSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils : object {
    private static ReadOnlySpan`1<byte> Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_Log2DeBruijn();
    [NullableContextAttribute("1")]
public static int MoveNansToFront(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    public static int Log2(UInt32 value);
    private static int Log2SoftwareFallback(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    private static void SwapIfGreater(T& i, T& j);
    private static void Swap(T& i, T& j);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys);
    private static void HeapSort(SegmentedArraySegment`1<T> keys);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n, int lo);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys);
    private static bool LessThan(T& left, T& right);
    private static bool GreaterThan(T& left, T& right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n, int lo);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static bool LessThan(TKey& left, TKey& right);
    private static bool GreaterThan(TKey& left, TKey& right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexException();
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
internal static void ThrowArgumentException_BadComparer(object comparer);
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_InvalidArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [NullableContextAttribute("2")]
internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked : object {
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`2<ImmutableSegmentedList`1<T>, ImmutableSegmentedList`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`3<ImmutableSegmentedList`1<T>, TArg, ImmutableSegmentedList`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedCompareExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value, ImmutableSegmentedList`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`2<ImmutableSegmentedDictionary`2<TKey, TValue>, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`3<ImmutableSegmentedDictionary`2<TKey, TValue>, TArg, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer, TArg transformerArgument);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedCompareExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value, ImmutableSegmentedDictionary`2<TKey, TValue> comparand);
    public static bool InterlockedInitialize(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static bool TryAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static bool TryUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool TryRemove(ImmutableSegmentedDictionary`2& location, TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.SegmentedArray : object {
    [NullableContextAttribute("2")]
internal static void Clear(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
internal static void Copy(SegmentedArray`1<T> sourceArray, SegmentedArray`1<T> destinationArray, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, Array destinationArray, int length);
    [NullableContextAttribute("2")]
public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, SegmentedArray`1<T> destinationArray, int destinationIndex, int length);
    [NullableContextAttribute("2")]
private static void CopyOverlapped(SegmentedArray`1<T> array, int sourceIndex, int destinationIndex, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static int BinarySearch(SegmentedArray`1<T> array, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    public static int IndexOf(SegmentedArray`1<T> array, T value);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(SegmentedArray`1<T> array, Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static SegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> array, int offset, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> first, SegmentedArray`1<T> second, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegmentsAligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
    [NullableContextAttribute("2")]
private static UnalignedSegmentEnumerable`1<T> GetSegmentsUnaligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedArray`1 : ValueType {
    private int _length;
    private T[][] _items;
    private static int SegmentSize { get; }
    private static int SegmentShift { get; }
    private static int OffsetMask { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public object SyncRoot { get; }
    public T& Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedArray`1(int length);
    private SegmentedArray`1(int length, T[][] items);
    private static int get_SegmentSize();
    private static int get_SegmentShift();
    private static int get_OffsetMask();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public sealed virtual object get_SyncRoot();
    public T& get_Item(int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SegmentedArray`1<T> other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("0")]
internal TestAccessor<T> GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2 : object {
    private static bool SupportsComparerDevirtualization;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<TKey, TValue>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> _keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> _values;
    private static int StartOfFreeList;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public SegmentedDictionary`2(int capacity);
    public SegmentedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private TValue& FindValue(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    private void Resize();
    private void Resize(int newSize);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private Int32& GetBucket(UInt32 hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedList`1 : object {
    private static int DefaultCapacity;
    private static int MaxArrayLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal SegmentedArray`1<T> _items;
    internal int _size;
    private int _version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SegmentedArray`1<T> s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedList`1(int capacity);
    public SegmentedList`1(IEnumerable`1<T> collection);
    private static SegmentedList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    public SegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public SegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public SegmentedList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public int IndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual void Insert(int index, T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
}
internal static class Microsoft.CodeAnalysis.Collections.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanDestArray { get; }
    internal static string Arg_LongerThanSrcArray { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string ArgumentOutOfRange_ArrayLB { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Rank_MustMatch { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string CannotFindOldValue { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanDestArray();
    internal static string get_Arg_LongerThanSrcArray();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_ArgumentOutOfRange_ArrayLB();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Rank_MustMatch();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_Arg_BogusIComparer();
    internal static string get_CannotFindOldValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[GuidAttribute("6380BCFF-41D3-4B2E-8B2E-BF8A6810C848")]
[InterfaceTypeAttribute("1")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.Setup.Configuration.IEnumSetupInstances {
    public abstract virtual void Next(int celt, ISetupInstance[] rgelt, Int32& pceltFetched);
}
[CompilerGeneratedAttribute]
[FlagsAttribute]
[TypeIdentifierAttribute("310100ba-5f84-4103-abe0-e8132ae862d9", "Microsoft.VisualStudio.Setup.Configuration.InstanceState")]
public enum Microsoft.VisualStudio.Setup.Configuration.InstanceState : Enum {
    public UInt32 value__;
    public static InstanceState None;
    public static InstanceState Local;
    public static InstanceState Registered;
    public static InstanceState NoRebootRequired;
    public static InstanceState NoErrors;
    public static InstanceState Complete;
}
[CompilerGeneratedAttribute]
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
[InterfaceTypeAttribute("1")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration {
}
[CompilerGeneratedAttribute]
[GuidAttribute("26AAB78C-4A60-49D6-AF3B-3C35BC93365D")]
[InterfaceTypeAttribute("1")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.Setup.Configuration.ISetupConfiguration2 {
    public void _VtblGap1_3();
    public abstract virtual IEnumSetupInstances EnumAllInstances();
}
[CompilerGeneratedAttribute]
[GuidAttribute("B41463C3-8866-43B5-BC33-2B0676F7F42E")]
[InterfaceTypeAttribute("1")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstance {
    public void _VtblGap1_3();
    public abstract virtual string GetInstallationPath();
    public abstract virtual string GetInstallationVersion();
    public abstract virtual string GetDisplayName(int lcid);
}
[CompilerGeneratedAttribute]
[GuidAttribute("89143C9A-05AF-49B0-B717-72E218A2185C")]
[InterfaceTypeAttribute("1")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.Setup.Configuration.ISetupInstance2 {
    public void _VtblGap1_8();
    public abstract virtual InstanceState GetState();
}
[CompilerGeneratedAttribute]
[GuidAttribute("42843719-DB4C-46C2-8E7C-64F1816EFD5B")]
[CoClassAttribute("System.Object")]
[TypeIdentifierAttribute]
public interface Microsoft.VisualStudio.Setup.Configuration.SetupConfiguration {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[ExtensionAttribute]
internal static class System.Linq.RoslynEnumerable : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SegmentedList`1<TSource> ToSegmentedList(IEnumerable`1<TSource> source);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("196")]
internal class System.Runtime.Versioning.SupportedOSPlatform : Attribute {
    [NullableContextAttribute("1")]
internal SupportedOSPlatform(string platformName);
}
[AttributeUsageAttribute("192")]
internal class System.Runtime.Versioning.SupportedOSPlatformGuard : Attribute {
    [NullableContextAttribute("1")]
internal SupportedOSPlatformGuard(string platformName);
}
