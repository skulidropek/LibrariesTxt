internal class GUID : ValueType {
    public int Data1;
    public ushort Data2;
    public ushort Data3;
    [NullableAttribute("1")]
public Byte[] Data4;
}
[NullableContextAttribute("1")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
internal interface IEnumString {
    public abstract virtual void RemoteNext(int celt, String& rgelt, Int32& pceltFetched);
    public abstract virtual void Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[NullableContextAttribute("1")]
[GuidAttribute("79EAC9EE-BAF9-11CE-8C82-00AA004BA90B")]
[InterfaceTypeAttribute("1")]
[ComConversionLossAttribute]
internal interface IInternetSecurityManager {
    public abstract virtual void SetSecuritySite(IInternetSecurityMgrSite pSite);
    public abstract virtual void GetSecuritySite(IInternetSecurityMgrSite& ppSite);
    public abstract virtual void MapUrlToZone(string pwszUrl, Int32& pdwZone, int dwFlags);
    public abstract virtual void GetSecurityId(string pwszUrl, Byte& pbSecurityId, Int32& pcbSecurityId, int dwReserved);
    public abstract virtual void ProcessUrlAction(string pwszUrl, int dwAction, Byte& pPolicy, int cbPolicy, Byte& pContext, int cbContext, int dwFlags, int dwReserved);
    public abstract virtual void QueryCustomPolicy(string pwszUrl, GUID& guidKey, IntPtr ppPolicy, Int32& pcbPolicy, Byte& pContext, int cbContext, int dwReserved);
    public abstract virtual void SetZoneMapping(int dwZone, string lpszPattern, int dwFlags);
    public abstract virtual void GetZoneMappings(int dwZone, IEnumString& ppenumString, int dwFlags);
}
[ComConversionLossAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("79EAC9ED-BAF9-11CE-8C82-00AA004BA90B")]
internal interface IInternetSecurityMgrSite {
    public abstract virtual void GetWindow(IntPtr phwnd);
    public abstract virtual void EnableModeless(int fEnable);
}
[ExtensionAttribute]
internal static class Microsoft.Build.BackEnd.TranslatorHelpers : object {
    [ExtensionAttribute]
public static void Translate(ITranslator translator, T& instance, NodePacketValueFactory`1<T> valueFactory);
    private static ObjectTranslator`1<T> AdaptFactory(NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, List`1& list, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, IList`1& list, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<L> collectionFactory);
    [ExtensionAttribute]
public static void TranslateArray(ITranslator translator, T[]& array, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void TranslateDictionary(ITranslator translator, Dictionary`2& dictionary, IEqualityComparer`1<string> comparer, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void TranslateDictionary(ITranslator translator, D& dictionary, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void TranslateDictionary(ITranslator translator, D& dictionary, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<D> collectionCreator);
    [ExtensionAttribute]
public static void TranslateHashSet(ITranslator translator, HashSet`1& hashSet, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<HashSet`1<T>> collectionFactory);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, CultureInfo& cultureInfo);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, Version& version);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, AssemblyName& assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`1 : object {
    private static ImmutableDictionary`2<string, V> NameComparerDictionaryPrototype;
    private static ImmutableDictionary`2<string, V> OrdinalIgnoreCaseComparerDictionaryPrototype;
    private ImmutableDictionary`2<string, V> _backing;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal IEqualityComparer`1<string> Comparer { get; private set; }
    public V Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`1(IEqualityComparer`1<string> keyComparer);
    protected CopyOnWriteDictionary`1(SerializationInfo info, StreamingContext context);
    private CopyOnWriteDictionary`1(CopyOnWriteDictionary`1<V> that);
    public CopyOnWriteDictionary`1(IDictionary`2<string, V> dictionary);
    private static CopyOnWriteDictionary`1();
    private static ImmutableDictionary`2<string, V> GetInitialDictionary(IEqualityComparer`1<string> keyComparer);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal IEqualityComparer`1<string> get_Comparer();
    private void set_Comparer(IEqualityComparer`1<string> value);
    public sealed virtual V get_Item(string key);
    public sealed virtual void set_Item(string key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(string key, V value);
    public void SetItems(IEnumerable`1<KeyValuePair`2<string, V>> items);
    public IEnumerable`1<KeyValuePair`2<string, V>> Where(Func`2<KeyValuePair`2<string, V>, bool> predicate);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    [NullableContextAttribute("0")]
public sealed virtual bool TryGetValue(string key, V& value);
    public sealed virtual void Add(KeyValuePair`2<string, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("0")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`1<V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`1<V> other);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.Build.Collections.IConstrainedEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y, int indexY, int length);
    public abstract virtual int GetHashCode(T obj, int index, int length);
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : object {
    private static ProcessorArchitectures s_runningProcessorArchitecture;
    [CompilerGeneratedAttribute]
private static MSBuildNameIgnoreCaseComparer <Default>k__BackingField;
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    private static MSBuildNameIgnoreCaseComparer();
    [CompilerGeneratedAttribute]
internal static MSBuildNameIgnoreCaseComparer get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public sealed virtual int GetHashCode(string obj, int start, int length);
}
internal class Microsoft.Build.Collections.ReadOnlyCollection`1 : object {
    private IEnumerable`1<T> _backing;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ICollection`1<T> BackingCollection { get; }
    internal ReadOnlyCollection`1(IEnumerable`1<T> backing);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private ICollection`1<T> get_BackingCollection();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    private static ReadOnlyEmptyCollection`1<T> s_instance;
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    private static Dictionary`2<K, V> s_backing;
    private static ReadOnlyEmptyDictionary`2<K, V> s_instance;
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Dictionary`2<string, int> s_counts;
    private static DateTime s_last;
    private static TimeSpan s_interval;
    private static string s_slot;
    private static string s_currentAssemblyName;
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
internal class Microsoft.Build.InterningBinaryReader : BinaryReader {
    private static int MaxCharsBuffer;
    private static Buffer s_bufferPool;
    private Buffer _buffer;
    private bool _isPrivateBuffer;
    private Decoder _decoder;
    internal static BinaryReaderFactory PoolingBuffer { get; }
    private InterningBinaryReader(Stream input, Buffer buffer, bool isPrivateBuffer);
    public virtual string ReadString();
    internal static BinaryReaderFactory CreateSharedBuffer();
    internal static BinaryReaderFactory get_PoolingBuffer();
    private static Buffer GetPooledBuffer();
    protected virtual void Dispose(bool disposing);
    private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuffer);
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Shared.AssemblyFoldersEx : object {
    private List`1<AssemblyFoldersExInfo> _directoryNames;
    private HashSet`1<string> _uniqueDirectoryPaths;
    internal IEnumerable`1<string> UniqueDirectoryPaths { get; }
    internal AssemblyFoldersEx(string registryKeyRoot, string targetRuntimeVersion, string registryKeySuffix, string osVersion, string platform, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, ProcessorArchitecture targetProcessorArchitecture, OpenBaseKey openBaseKey);
    private void FindDirectories(RegistryView view, RegistryHive hive, string registryKeyRoot, string targetRuntimeVersion, string registryKeySuffix, string osVersion, string platform, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey);
    private bool MatchingPlatformExists(string platform, string platformValue);
    private bool IsVersionInsideRange(Version v, RegistryKey keyPlatform);
    internal static List`1<ExtensionFoldersRegistryKey> GatherVersionStrings(string targetRuntimeVersion, IEnumerable`1<string> versions);
    private static void AddCandidateVersion(SortedDictionary`2<Version, List`1<string>> targetFrameworkVersionToRegistryVersions, string version, Version candidateVersion);
    private sealed virtual override IEnumerator`1<AssemblyFoldersExInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersExInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal IEnumerable`1<string> get_UniqueDirectoryPaths();
}
[DataContractAttribute]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderCollection : object {
    [CompilerGeneratedAttribute]
private List`1<AssemblyFolderItem> <AssemblyFolders>k__BackingField;
    [DataMemberAttribute]
internal List`1<AssemblyFolderItem> AssemblyFolders { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<AssemblyFolderItem> get_AssemblyFolders();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFolders(List`1<AssemblyFolderItem> value);
    internal static AssemblyFolderCollection Load(string filePath);
}
[DataContractAttribute]
[DebuggerDisplayAttribute("{Name}: FrameworkVersion = {FrameworkVersion}, Platform = {Platform}, Path= {Path}")]
internal class Microsoft.Build.Shared.AssemblyFoldersFromConfig.AssemblyFolderItem : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [DataMemberAttribute]
internal string Name { get; internal set; }
    [DataMemberAttribute]
internal string FrameworkVersion { get; internal set; }
    [DataMemberAttribute]
internal string Path { get; internal set; }
    [DataMemberAttribute]
internal string Platform { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_FrameworkVersion();
    [CompilerGeneratedAttribute]
internal void set_FrameworkVersion(string value);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
internal string get_Platform();
    [CompilerGeneratedAttribute]
internal void set_Platform(string value);
}
internal class Microsoft.Build.Shared.AssemblyNameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer ComparerConsiderRetargetable;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparer;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparerConsiderRetargetable;
    private bool considerRetargetableFlag;
    private AssemblyNameComparer(bool considerRetargetableFlag);
    private static AssemblyNameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual bool Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
    public sealed virtual bool Equals(AssemblyNameExtension x, AssemblyNameExtension y);
    public sealed virtual int GetHashCode(AssemblyNameExtension obj);
}
internal class Microsoft.Build.Shared.AssemblyNameExtension : object {
    private AssemblyName asAssemblyName;
    private string asString;
    private bool isSimpleName;
    private bool hasProcessorArchitectureInFusionName;
    private bool immutable;
    private HashSet`1<AssemblyNameExtension> remappedFrom;
    private static AssemblyNameExtension s_unnamedAssembly;
    internal string Name { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal Version Version { get; }
    internal bool IsSimpleName { get; }
    internal bool HasProcessorArchitectureInFusionName { get; }
    internal CultureInfo CultureInfo { get; }
    internal bool Retargetable { get; }
    internal IEnumerable`1<AssemblyNameExtension> RemappedFromEnumerator { get; }
    internal AssemblyName AssemblyName { get; }
    internal string FullName { get; }
    internal static AssemblyNameExtension UnnamedAssembly { get; }
    public bool Immutable { get; }
    internal bool IsUnnamedAssembly { get; }
    internal AssemblyNameExtension(AssemblyName assemblyName);
    internal AssemblyNameExtension(string assemblyName);
    internal AssemblyNameExtension(string assemblyName, bool validate);
    private AssemblyNameExtension(SerializationInfo info, StreamingContext context);
    internal AssemblyNameExtension(ITranslator translator);
    private static AssemblyNameExtension();
    internal static AssemblyNameExtension GetAssemblyNameEx(string path);
    [OnDeserializedAttribute]
private void SetRemappedFromDefaultAfterSerialization(StreamingContext sc);
    private void InitializeRemappedFrom();
    private static HashSet`1<AssemblyNameExtension> CreateRemappedFrom();
    private void CreateAssemblyName();
    private void CreateFullName();
    internal string get_Name();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal Version get_Version();
    internal bool get_IsSimpleName();
    internal bool get_HasProcessorArchitectureInFusionName();
    internal void ReplaceVersion(Version version);
    internal CultureInfo get_CultureInfo();
    internal bool get_Retargetable();
    internal IEnumerable`1<AssemblyNameExtension> get_RemappedFromEnumerator();
    internal void AddRemappedAssemblyName(AssemblyNameExtension extensionToAdd);
    internal AssemblyName get_AssemblyName();
    internal string get_FullName();
    internal Byte[] GetPublicKeyToken();
    internal static AssemblyNameExtension get_UnnamedAssembly();
    internal int CompareTo(AssemblyNameExtension that);
    internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal int GetHashCode();
    internal int CompareBaseNameTo(AssemblyNameExtension that);
    private int CompareBaseNameToImpl(AssemblyNameExtension that);
    private static int CompareBaseNamesStringWise(string asString1, string asString2);
    internal AssemblyNameExtension Clone();
    internal AssemblyNameExtension CloneImmutable();
    public bool get_Immutable();
    internal void MarkImmutable();
    internal bool Equals(AssemblyNameExtension that);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Shared.AssemblyNameExtension>.Equals(AssemblyNameExtension other);
    internal bool EqualsIgnoreVersion(AssemblyNameExtension that);
    internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag);
    private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool considerRetargetableFlag);
    internal static bool CompareCultures(AssemblyName a, AssemblyName b);
    internal bool ComparePublicKeyToken(AssemblyNameExtension that);
    internal static bool ComparePublicKeyTokens(Byte[] aPKT, Byte[] bPKT);
    internal bool get_IsUnnamedAssembly();
    private static AssemblyName GetAssemblyNameFromDisplayName(string displayName);
    internal static string EscapeDisplayNameCharacters(string displayName);
    public virtual string ToString();
    internal bool PartialNameCompare(AssemblyNameExtension that);
    internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void Translate(ITranslator translator);
}
internal class Microsoft.Build.Shared.AssemblyNameReverseVersionComparer : object {
    internal static IComparer`1<AssemblyNameExtension> GenericComparer;
    private static AssemblyNameReverseVersionComparer();
    public sealed virtual int Compare(AssemblyNameExtension x, AssemblyNameExtension y);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    [CompilerGeneratedAttribute]
private static ResourceManager <PrimaryResources>k__BackingField;
    [CompilerGeneratedAttribute]
private static ResourceManager <SharedResources>k__BackingField;
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static string GetString(string name);
    [CompilerGeneratedAttribute]
internal static ResourceManager get_PrimaryResources();
    [CompilerGeneratedAttribute]
internal static ResourceManager get_SharedResources();
}
internal class Microsoft.Build.Shared.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private BuildEnvironmentMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningTests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectoryRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectoryArm64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildExePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioInstallRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExtensionsPath>k__BackingField;
    internal BuildEnvironmentMode Mode { get; }
    internal bool RunningTests { get; }
    internal bool RunningInVisualStudio { get; }
    internal string MSBuildToolsDirectoryRoot { get; }
    internal string MSBuildToolsDirectory32 { get; }
    internal string MSBuildToolsDirectory64 { get; }
    internal string MSBuildToolsDirectoryArm64 { get; }
    internal string MSBuildSDKsPath { get; }
    internal string CurrentMSBuildConfigurationFile { get; }
    internal string CurrentMSBuildExePath { get; private set; }
    internal string CurrentMSBuildToolsDirectory { get; }
    internal string VisualStudioInstallRootDirectory { get; }
    internal string MSBuildExtensionsPath { get; internal set; }
    public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath);
    [CompilerGeneratedAttribute]
internal BuildEnvironmentMode get_Mode();
    [CompilerGeneratedAttribute]
internal bool get_RunningTests();
    [CompilerGeneratedAttribute]
internal bool get_RunningInVisualStudio();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectoryRoot();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory32();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory64();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectoryArm64();
    internal string get_MSBuildSDKsPath();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildConfigurationFile();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildExePath();
    [CompilerGeneratedAttribute]
private void set_CurrentMSBuildExePath(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildToolsDirectory();
    [CompilerGeneratedAttribute]
internal string get_VisualStudioInstallRootDirectory();
    [CompilerGeneratedAttribute]
internal string get_MSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPath(string value);
}
internal class Microsoft.Build.Shared.BuildEnvironmentHelper : object {
    private static string CurrentVisualStudioVersion;
    private static string CurrentToolsVersion;
    private static String[] s_visualStudioProcess;
    private static String[] s_msBuildProcess;
    private static String[] s_msBuildExeNames;
    private static Nullable`1<bool> _runningTests;
    private static object _runningTestsLock;
    private static Func`1<string> s_getProcessFromRunningProcess;
    private static Func`1<string> s_getExecutingAssemblyPath;
    private static Func`1<string> s_getAppContextBaseDirectory;
    private static Func`1<IEnumerable`1<VisualStudioInstance>> s_getVisualStudioInstances;
    private static Func`2<string, string> s_getEnvironmentVariable;
    private static Func`1<bool> s_runningTests;
    public static BuildEnvironment Instance { get; }
    private static BuildEnvironmentHelper();
    public static BuildEnvironment get_Instance();
    private static BuildEnvironment Initialize();
    private static BuildEnvironment TryFromEnvironmentVariable();
    private static BuildEnvironment TryFromVisualStudioProcess();
    private static BuildEnvironment TryFromMSBuildProcess();
    private static BuildEnvironment TryFromMSBuildAssembly();
    private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuildExe, bool allowLegacyToolsVersion);
    private static BuildEnvironment TryFromDevConsole();
    private static BuildEnvironment TryFromSetupApi();
    private static BuildEnvironment TryFromAppContextBaseDirectory();
    private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath);
    private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly);
    private static string GetMSBuildExeFromVsRoot(string visualStudioRoot);
    private static bool CheckIfRunningTests();
    private static bool IsProcessInList(string processName, String[] processList);
    private static string GetProcessFromRunningProcess();
    private static string GetExecutingAssemblyPath();
    private static string GetAppContextBaseDirectory();
    private static string GetEnvironmentVariable(string variable);
    internal static void ResetInstance_ForUnitTestsOnly(Func`1<string> getProcessFromRunningProcess, Func`1<string> getExecutingAssemblyPath, Func`1<string> getAppContextBaseDirectory, Func`1<IEnumerable`1<VisualStudioInstance>> getVisualStudioInstances, Func`2<string, string> getEnvironmentVariable, Func`1<bool> runningTests);
    internal static void ResetInstance_ForUnitTestsOnly(BuildEnvironment buildEnvironment);
}
internal enum Microsoft.Build.Shared.BuildEnvironmentMode : Enum {
    public int value__;
    public static BuildEnvironmentMode VisualStudio;
    public static BuildEnvironmentMode Standalone;
    public static BuildEnvironmentMode None;
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression;
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression2;
    private static Lazy`1<Regex> s_filenameLocationFromOrigin;
    private static Lazy`1<Regex> s_lineFromLocation;
    private static Lazy`1<Regex> s_lineLineFromLocation;
    private static Lazy`1<Regex> s_lineColFromLocation;
    private static Lazy`1<Regex> s_lineColColFromLocation;
    private static Lazy`1<Regex> s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
internal static class Microsoft.Build.Shared.ConversionUtilities : object {
    internal static bool ConvertStringToBool(string parameterValue);
    internal static bool ConvertStringToBool(string parameterValue, bool nullOrWhitespaceIsFalse);
    internal static string ConvertByteArrayToHex(Byte[] bytes);
    internal static bool TryConvertStringToBool(string parameterValue, Boolean& boolValue);
    internal static bool CanConvertStringToBool(string parameterValue);
    internal static bool ValidBooleanTrue(string parameterValue);
    internal static bool ValidBooleanFalse(string parameterValue);
    internal static double ConvertDecimalToDouble(string number);
    internal static double ConvertHexToDouble(string number);
    internal static double ConvertDecimalOrHexToDouble(string number);
    internal static bool TryConvertDecimalOrHexToDouble(string number, Double& doubleValue);
    private static bool ValidHexNumber(string number, Int32& value);
    private static bool ValidDecimalNumber(string number, Double& value);
    internal static bool ValidDecimalOrHexNumber(string number);
}
internal static class Microsoft.Build.Shared.Debugging.DebugUtils : object {
    private static Lazy`1<NodeMode> ProcessNodeMode;
    public static string ProcessInfoString;
    public static bool ShouldDebugCurrentProcess;
    [CompilerGeneratedAttribute]
private static string <DebugPath>k__BackingField;
    public static string DebugPath { get; }
    private static DebugUtils();
    private static bool CurrentProcessMatchesDebugName();
    [CompilerGeneratedAttribute]
public static string get_DebugPath();
    public static string FindNextAvailableDebugFilePath(string fileName);
    [CompilerGeneratedAttribute]
internal static NodeMode <.cctor>g__ScanNodeMode|1_1(string input);
}
internal class Microsoft.Build.Shared.Debugging.PrintLineDebugger : object {
    private static Lazy`1<PropertyInfo> CommonWriterProperty;
    public static Lazy`1<PrintLineDebugger> Default;
    public static Lazy`1<PrintLineDebugger> DefaultWithProcessInfo;
    private string _id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`3<string, string, IEnumerable`1<string>> _writerSetByThisInstance;
    public PrintLineDebugger(string id, Action`3<string, string, IEnumerable`1<string>> writer);
    private static PrintLineDebugger();
    public sealed virtual void Dispose();
    public static Action`3<string, string, IEnumerable`1<string>> GetStaticWriter();
    public static void SetWriter(Action`3<string, string, IEnumerable`1<string>> writer);
    public static void UnsetWriter();
    public static PrintLineDebugger Create(Action`3<string, string, IEnumerable`1<string>> writer, string id, bool prependProcessInfo);
    public Action`3<string, string, IEnumerable`1<string>> GetWriter();
    public void Log(string message, string memberName, string sourceFilePath, int sourceLineNumber);
    public void Log(IEnumerable`1<string> args, string memberName, string sourceFilePath, int sourceLineNumber);
    private static string CallsiteString(string sourceFilePath, string memberName, int sourceLineNumber);
    private void ReleaseUnmanagedResources();
    protected virtual override void Finalize();
}
internal static class Microsoft.Build.Shared.Debugging.PrintLineDebuggerWriters : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Action`3<string, string, IEnumerable`1<string>> StdOutWriter;
    private static Lazy`1<string> _artifactsLogs;
    public static string ArtifactsLogDirectory { get; }
    private static PrintLineDebuggerWriters();
    public static string get_ArtifactsLogDirectory();
    public static string SimpleFormat(string id, string callsite, IEnumerable`1<string> args);
    public static string CsvFormat(string id, string callsite, IEnumerable`1<string> args);
    [CompilerGeneratedAttribute]
internal static string <CsvFormat>g__EscapeCommas|7_1(string s);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal static class Microsoft.Build.Shared.EnvironmentUtilities : object {
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    [NullableContextAttribute("1")]
public static bool IsWellKnownEnvironmentDerivedProperty(string propertyName);
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static bool s_enableMSBuildDebugTracing;
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void VerifyThrowInternalError(bool condition, string message, Object[] args);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void VerifyThrowInternalErrorUnreachable(bool condition);
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    public static void VerifyThrowInternalLength(T[] parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgument(string resourceName, Object[] args);
    internal static void ThrowArgument(Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLength(IReadOnlyCollection`1<T> parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(IReadOnlyCollection`1<T> parameter, string parameterName);
    private static void ThrowArgumentLength(string parameterName);
    internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void ThrowArgumentNull(string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
    internal static void VerifyThrowObjectDisposed(bool condition, string objectName);
    internal static void ThrowObjectDisposed(string objectName);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static Char[] s_charsToEscape;
    private static EscapingUtilities();
    private static bool TryDecodeHexDigit(char character, Int32& value);
    internal static string UnescapeAll(string escapedString, bool trim);
    internal static string EscapeWithCaching(string unescapedString);
    internal static string Escape(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static char HexDigitChar(int x);
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    private static string s_debugDumpPath;
    private static string s_dumpFileName;
    internal static string DebugDumpPath { get; }
    private static ExceptionHandling();
    private static string GetDebugDumpPath();
    internal static string get_DebugDumpPath();
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    internal static void DumpExceptionToFile(Exception ex);
    internal static string ReadAnyExceptionFromFile(DateTime fromTimeUtc);
}
internal class Microsoft.Build.Shared.ExtensionFoldersRegistryKey : object {
    [CompilerGeneratedAttribute]
private string <RegistryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <TargetFrameworkVersion>k__BackingField;
    internal string RegistryKey { get; }
    internal Version TargetFrameworkVersion { get; }
    internal ExtensionFoldersRegistryKey(string registryKey, Version targetFrameworkVersion);
    [CompilerGeneratedAttribute]
internal string get_RegistryKey();
    [CompilerGeneratedAttribute]
internal Version get_TargetFrameworkVersion();
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileMatcher : object {
    private IFileSystem _fileSystem;
    private static string recursiveDirectoryMatch;
    private static string s_directorySeparator;
    private static string s_thisDirectory;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    private static String[] s_propertyAndItemReferences;
    internal static Char[] directorySeparatorCharacters;
    private static Lazy`1<ConcurrentDictionary`2<string, IReadOnlyList`1<string>>> s_cachedGlobExpansions;
    private static Lazy`1<ConcurrentDictionary`2<string, object>> s_cachedGlobExpansionsLock;
    private ConcurrentDictionary`2<string, IReadOnlyList`1<string>> _cachedGlobExpansions;
    private Lazy`1<ConcurrentDictionary`2<string, object>> _cachedGlobExpansionsLock;
    private static Char[] s_invalidPathChars;
    public static RegexOptions DefaultRegexOptions;
    private GetFileSystemEntries _getFileSystemEntries;
    private static int FileSpecRegexMinLength;
    public static FileMatcher Default;
    public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> fileEntryExpansionCache);
    internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> getFileSystemDirectoryEntriesCache);
    private static FileMatcher();
    internal static void ClearFileEnumerationsCache();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    internal static bool HasPropertyOrItemReferences(string filespec);
    private static IReadOnlyList`1<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static IReadOnlyList`1<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern);
    private static bool ShouldEnforceMatching(string searchPattern);
    private static IReadOnlyList`1<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static IReadOnlyList`1<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern);
    internal string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveInitialDotSlash>d__35")]
private static IEnumerable`1<string> RemoveInitialDotSlash(IEnumerable`1<string> paths);
    internal static bool IsDirectorySeparator(char c);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveProjectDirectory>d__37")]
internal static IEnumerable`1<string> RemoveProjectDirectory(IEnumerable`1<string> paths, string projectDirectory);
    private void GetFilesRecursive(ConcurrentStack`1<List`1<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList`1<RecursionState> searchesToExclude, Dictionary`2<string, List`1<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions);
    private IEnumerable`1<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory);
    private static bool MatchFileRecursionStep(RecursionState recursionState, string file);
    private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState);
    internal static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart);
    private static bool IsLegalFileSpec(string wildcardDirectoryPart, string filenamePart);
    private static bool HasDotDot(string str);
    private static bool HasMisplacedRecursiveOperator(string str);
    private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir);
    private static void AppendRegularExpressionFromWildcardDirectory(ReuseableStringBuilder regex, string wildcardDir);
    private static void AppendRegularExpressionFromFilename(ReuseableStringBuilder regex, string filename);
    private static void AppendRegularExpressionFromChar(ReuseableStringBuilder regex, char ch);
    private static bool IsSpecialRegexCharacter(char ch);
    private static int LastIndexOfDirectorySequence(string str, int startIndex);
    private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int startIndex);
    internal void GetFileSpecInfoWithRegexObject(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, Boolean& needsRecursion, Boolean& isLegalFileSpec, FixupParts fixupParts);
    internal static bool RawFileSpecIsValid(string filespec);
    internal static bool IsFileNameMatch(string path, string pattern);
    internal static bool IsMatch(string input, string pattern);
    internal static bool IsMatch(ReadOnlySpan`1<char> input, string pattern);
    internal Result FileMatch(string filespec, string fileToMatch);
    internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, Boolean& isMatch, String& wildcardDirectoryPart, String& filenamePart);
    internal ValueTuple`3<String[], SearchAction, string> GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludes);
    private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, Boolean& stripProjectDirectory, RecursionState& result);
    internal static string Normalize(string aString);
    internal static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart);
    private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue);
    private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPartLength, string directoryPart, string wildcardPart);
    private static bool IsValidDriveChar(char value);
    private static int SkipSlashes(string aString, int startingIndex);
    private static String[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private ValueTuple`3<String[], SearchAction, string> GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private bool InnerExceptionsAreAllIoRelated(AggregateException ex);
    private static bool IsSubdirectoryOf(string possibleChild, string possibleParent);
    private static bool DirectoryEndsWithPattern(string directoryPath, string pattern);
    internal static bool IsAllFilesWildcard(string pattern);
    internal static bool IsRecursiveDirectoryMatch(string path);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__CompareIgnoreCase|63_0(ReadOnlySpan`1& input, int iIndex, int pIndex, <>c__DisplayClass63_0& );
}
internal class Microsoft.Build.Shared.FileSystem.CachingFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private ConcurrentDictionary`2<string, bool> _existenceCache;
    private ConcurrentDictionary`2<string, DateTime> _lastWriteTimeCache;
    public CachingFileSystemWrapper(IFileSystem fileSystem);
    public sealed virtual bool FileOrDirectoryExists(string path);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private bool CachedExistenceCheck(string path, Func`2<string, bool> existenceCheck);
    [CompilerGeneratedAttribute]
private bool <FileOrDirectoryExists>b__4_0(string p);
    [CompilerGeneratedAttribute]
private DateTime <GetLastWriteTimeUtc>b__6_0(string p);
    [CompilerGeneratedAttribute]
private bool <DirectoryExists>b__7_0(string p);
    [CompilerGeneratedAttribute]
private bool <FileExists>b__8_0(string p);
}
internal enum Microsoft.Build.Shared.FileSystem.FileArtifactType : Enum {
    public byte value__;
    public static FileArtifactType File;
    public static FileArtifactType Directory;
    public static FileArtifactType FileOrDirectory;
}
internal static class Microsoft.Build.Shared.FileSystem.FileSystems : object {
    public static IFileSystem Default;
    private static FileSystems();
    private static IFileSystem GetFileSystem();
}
internal interface Microsoft.Build.Shared.FileSystem.IFileSystem {
    public abstract virtual TextReader ReadFile(string path);
    public abstract virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public abstract virtual string ReadFileAllText(string path);
    public abstract virtual Byte[] ReadFileAllBytes(string path);
    public abstract virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual FileAttributes GetAttributes(string path);
    public abstract virtual DateTime GetLastWriteTimeUtc(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool FileOrDirectoryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.ManagedFileSystem : object {
    private static ManagedFileSystem Instance;
    private static bool ShouldUseMicrosoftIO { get; }
    private static ManagedFileSystem();
    public static ManagedFileSystem Singleton();
    private static bool get_ShouldUseMicrosoftIO();
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    private static IEnumerable`1<string> HandleFileLoadException(Func`4<string, string, SearchOption, IEnumerable`1<string>> enumerateFunctionDelegate, string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual FileAttributes GetAttributes(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem : object {
    private static MSBuildOnWindowsFileSystem Instance;
    private static MSBuildOnWindowsFileSystem();
    public static MSBuildOnWindowsFileSystem Singleton();
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool FileOrDirectoryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.NativeWin32Exception : Win32Exception {
    public NativeWin32Exception(int nativeErrorCode, string messagePrefix);
    public NativeWin32Exception(int nativeErrorCode);
    public static string GetFormattedMessageForNativeErrorCode(int nativeErrorCode, string messagePrefix);
    public static int HResultFromWin32(int nativeErrorCode);
}
internal class Microsoft.Build.Shared.FileSystem.SafeFindFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Shared.FileSystem.WindowsFileSystem : ManagedFileSystem {
    private static WindowsFileSystem Instance;
    private static WindowsFileSystem();
    public static WindowsFileSystem Singleton();
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    private static IEnumerable`1<string> EnumerateFileOrDirectories(string directoryPath, FileArtifactType fileArtifactType, string searchPattern, SearchOption searchOption);
    private static EnumerateDirectoryResult CustomEnumerateDirectoryEntries(string directoryPath, FileArtifactType fileArtifactType, string pattern, SearchOption searchOption, ICollection`1<string> result);
}
internal static class Microsoft.Build.Shared.FileSystem.WindowsNative : object {
    public static int MaxPath;
    public static int ErrorSuccess;
    public static int ErrorFileNotFound;
    public static int ErrorPathNotFound;
    public static int ErrorDirectory;
    public static int ErrorAccessDenied;
    public static UInt32 ErrorNoMoreFiles;
    public static SafeFindFileHandle FindFirstFileW(string lpFileName, Win32FindData& lpFindFileData);
    public static bool FindNextFileW(SafeHandle hFindFile, Win32FindData& lpFindFileData);
    public static int PathMatchSpecExW(string pszFileParam, string pszSpec, int flags);
    internal static bool FindClose(IntPtr findFileHandle);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.FileUtilities : object {
    private static int userRWX;
    private static string tempFileDirectory;
    internal static string cacheDirectory;
    internal static StringComparison PathComparison;
    internal static StringComparer PathComparer;
    internal static Char[] InvalidPathChars;
    internal static Char[] InvalidFileNameChars;
    internal static Char[] Slashes;
    internal static string DirectorySeparatorString;
    private static ConcurrentDictionary`2<string, bool> FileExistenceCache;
    private static IFileSystem DefaultFileSystem;
    internal static string FileTimeFormat;
    internal static string TempFileDirectory { get; }
    internal static string ExecutingAssemblyPath { get; }
    private static FileUtilities();
    internal static string get_TempFileDirectory();
    internal static void ClearTempFileDirectory();
    private static string CreateFolderUnderTemp();
    internal static string GetTemporaryDirectory(bool createDirectory, string subfolder);
    internal static string GetTemporaryFileName();
    internal static string GetTemporaryFileName(string extension);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string fileName, string extension, bool createFile);
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string fileName, string extension, bool createFile);
    internal static void CopyDirectory(string source, string dest);
    internal static void ClearCacheDirectoryPath();
    public static bool GetIsFileSystemCaseSensitive();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static bool CanWriteToDirectory(string directory);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingOrTrailingSlash(string path, int start);
    internal static string EnsureTrailingNoLeadingSlash(string path, int start);
    internal static string EnsureNoTrailingSlash(string path);
    internal static string EnsureSingleQuotes(string path);
    internal static string EnsureDoubleQuotes(string path);
    internal static string EnsureQuotes(string path, bool isSingleQuote);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string TruncatePathToTrailingSegments(string path, int trailingSegmentsToKeep);
    internal static bool ContainsRelativePathSegments(string path);
    private static bool RelativePathBoundsAreValid(string path, int leftIndex, int rightIndex);
    private static bool IsValidRelativePathBound(Nullable`1<char> c);
    internal static string NormalizePath(string path);
    internal static string NormalizePath(string directory, string file);
    internal static string NormalizePath(String[] paths);
    private static string GetFullPath(string path);
    private static bool IsUNCPath(string path);
    internal static string FixFilePath(string path);
    internal static string MaybeAdjustFilePath(string value, string baseDirectory);
    internal static ReadOnlyMemory`1<char> MaybeAdjustFilePath(ReadOnlyMemory`1<char> value, string baseDirectory);
    private static Span`1<char> ConvertToUnixSlashes(Span`1<char> path);
    private static Span`1<char> CollapseSlashes(Span`1<char> str);
    private static Span`1<char> RemoveQuotes(Span`1<char> path);
    internal static bool IsAnySlash(char c);
    internal static bool LooksLikeUnixFilePath(string value, string baseDirectory);
    internal static bool LooksLikeUnixFilePath(ReadOnlySpan`1<char> value, string baseDirectory);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static bool ComparePathsNoThrow(string first, string second, string currentDirectory, bool alwaysIgnoreCase);
    internal static string NormalizePathForComparisonNoThrow(string path, string currentDirectory);
    internal static bool PathIsInvalid(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive, int retryCount, int retryTimeOut);
    internal static void DeleteWithoutTrailingBackslash(string path, bool recursive);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsSolutionFilterFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsDspFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static bool IsBinaryLogFilename(string filename);
    private static bool HasExtension(string filename, string extension);
    internal static string MakeRelative(string basePath, string path);
    internal static string AttemptToShortenPath(string path);
    private static bool IsPathTooLong(string path);
    private static bool IsPathTooLongIfRooted(string path);
    private static bool IsRootedNoThrow(string path);
    internal static string GetFolderAbove(string path, int count);
    internal static string CombinePaths(string root, String[] paths);
    [ExtensionAttribute]
internal static string TrimTrailingSlashes(string s);
    [ExtensionAttribute]
internal static string ToSlash(string s);
    [ExtensionAttribute]
internal static string ToBackslash(string s);
    [ExtensionAttribute]
internal static string ToPlatformSlash(string s);
    [ExtensionAttribute]
internal static string WithTrailingSlash(string s);
    [ExtensionAttribute]
internal static string NormalizeForPathComparison(string s);
    internal static bool PathsEqual(string path1, string path2);
    internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding);
    internal static StreamReader OpenRead(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem);
    internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem);
    internal static void EnsureDirectoryExists(string directoryPath);
    private static bool PathsEqualNonAscii(string strA, string strB, int i, int length);
    internal static void ClearFileExistenceCache();
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    private static char _backSlash;
    private static char _forwardSlash;
    internal static bool IsDrivePattern(string pattern);
    internal static bool IsDrivePatternWithSlash(string pattern);
    internal static bool StartsWithDrivePattern(string pattern);
    internal static bool StartsWithDrivePatternWithSlash(string pattern);
    internal static bool IsUncPattern(string pattern);
    internal static bool StartsWithUncPattern(string pattern);
    internal static int StartsWithUncPatternMatchLength(string pattern);
    internal static bool MeetsUncPatternMinimumRequirements(string pattern);
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyDefaultValue : MulticastDelegate {
    public GetRegistrySubKeyDefaultValue(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.GetRegistrySubKeyNames : MulticastDelegate {
    public GetRegistrySubKeyNames(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<string> Invoke(RegistryKey baseKey, string subKey);
    public virtual IAsyncResult BeginInvoke(RegistryKey baseKey, string subKey, AsyncCallback callback, object object);
    public virtual IEnumerable`1<string> EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.LanguageParser.BooleanLiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.CloseConditionalDirectiveToken : PreprocessorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.CommentToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenCharReader : TokenCharReader {
    internal CSharpTokenCharReader(Stream binaryStream, bool forceANSI);
    internal bool SinkLongIntegerSuffix();
    internal bool SinkOperatorOrPunctuator();
    internal bool SinkStringEscape();
    internal bool MatchRegularStringLiteral();
    internal bool SinkMultipleWhiteSpace();
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenEnumerator : TokenEnumerator {
    private CSharpTokenCharReader _reader;
    private static String[] s_keywordList;
    internal TokenCharReader Reader { get; }
    internal CSharpTokenEnumerator(Stream binaryStream, bool forceANSI);
    private static CSharpTokenEnumerator();
    internal virtual bool FindNextToken();
    internal virtual TokenCharReader get_Reader();
}
internal class Microsoft.Build.Shared.LanguageParser.CSharpTokenizer : object {
    private Stream _binaryStream;
    private bool _forceANSI;
    internal CSharpTokenizer(Stream binaryStream, bool forceANSI);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Shared.LanguageParser.DecimalIntegerLiteralToken : IntegerLiteralToken {
}
internal class Microsoft.Build.Shared.LanguageParser.EndOfFileInsideStringToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.ExpectedIdentifierToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.ExpectedValidHexDigitToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.HexIntegerLiteralToken : IntegerLiteralToken {
}
internal class Microsoft.Build.Shared.LanguageParser.IdentifierToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.IntegerLiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.KeywordToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.LiteralToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.OpenConditionalDirectiveToken : PreprocessorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.OperatorOrPunctuatorToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.OperatorToken : OperatorOrPunctuatorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.PreprocessorToken : Token {
}
internal class Microsoft.Build.Shared.LanguageParser.StreamMappedString : object {
    private Stream _binaryStream;
    private StreamReader _reader;
    private bool _forceANSI;
    private int _currentPageNumber;
    private int _finalPageNumber;
    private int _charactersRead;
    private Char[] _priorPage;
    private Char[] _currentPage;
    private int _pagesAllocated;
    private int _pageSize;
    public int PagesAllocated { get; }
    public static int DefaultPageSize { get; }
    public StreamMappedString(Stream binaryStream, bool forceANSI);
    internal StreamMappedString(Stream binaryStream, bool forceANSI, int pageSize);
    private void RestartReader();
    public int get_PagesAllocated();
    public static int get_DefaultPageSize();
    public char GetAt(int offset);
    private Char[] GetPage(int offset);
    private bool ReadNextPage();
    private void ReadBlockStripEOF();
    private void AppendCharacterToStream(char c);
    private char LastCharacterInStream();
    private void SwapPages();
    private bool IsZeroLengthStream();
    private int AbsoluteOffsetToPageOffset(int offset);
    private int PageFromAbsoluteOffset(int offset);
    public bool IsPastEnd(int offset);
    public string Substring(int startPosition, int length);
    private int GetCharactersOnPage(int offset);
}
internal class Microsoft.Build.Shared.LanguageParser.StringLiteralToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.SyntaxErrorToken : Token {
}
internal abstract class Microsoft.Build.Shared.LanguageParser.Token : object {
    private string _innerText;
    private int _line;
    internal string InnerText { get; internal set; }
    internal int Line { get; internal set; }
    internal string get_InnerText();
    internal void set_InnerText(string value);
    internal int get_Line();
    internal void set_Line(int value);
    internal bool EqualsIgnoreCase(string compareTo);
}
internal static class Microsoft.Build.Shared.LanguageParser.TokenChar : object {
    internal static bool IsNewLine(char c);
    internal static bool IsLetter(char c);
    internal static bool IsDecimalDigit(char c);
    internal static bool IsConnecting(char c);
    internal static bool IsCombining(char c);
    internal static bool IsFormatting(char c);
    internal static bool IsHexDigit(char c);
    internal static bool IsOctalDigit(char c);
}
internal class Microsoft.Build.Shared.LanguageParser.TokenCharReader : object {
    private StreamMappedString _sources;
    private int _position;
    private int _currentLine;
    internal int CurrentLine { get; }
    internal int Position { get; internal set; }
    internal char CurrentCharacter { get; }
    internal bool EndOfLines { get; }
    internal TokenCharReader(Stream binaryStream, bool forceANSI);
    internal void Reset();
    internal int get_CurrentLine();
    internal int get_Position();
    internal void set_Position(int value);
    protected void Skip();
    protected void Skip(int n);
    internal char get_CurrentCharacter();
    internal bool get_EndOfLines();
    internal string GetCurrentMatchedString(int startPosition);
    internal bool Sink(string match);
    private bool Sink(string match, bool ignoreCase);
    internal char SinkCharacter();
    internal bool SinkIgnoreCase(string match);
    internal bool MatchNextIdentifierStart();
    internal bool SinkIdentifierStart();
    internal bool SinkIdentifierPart();
    internal bool SinkNewLine();
    internal bool SinkToEndOfLine();
    internal bool SinkUntil(string find);
    internal bool SinkMultipleHexDigits();
    internal bool SinkMultipleDecimalDigits();
}
internal abstract class Microsoft.Build.Shared.LanguageParser.TokenEnumerator : object {
    protected Token current;
    internal TokenCharReader Reader { get; }
    public object Current { get; }
    internal abstract virtual TokenCharReader get_Reader();
    internal abstract virtual bool FindNextToken();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual object get_Current();
}
internal class Microsoft.Build.Shared.LanguageParser.UnrecognizedToken : SyntaxErrorToken {
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenCharReader : TokenCharReader {
    internal VisualBasicTokenCharReader(Stream binaryStream, bool forceANSI);
    internal bool SinkSeparatorCharacter();
    internal bool SinkLineContinuationCharacter();
    internal bool SinkLineCommentStart();
    internal bool SinkHexIntegerPrefix();
    internal bool SinkOctalIntegerPrefix();
    internal bool SinkWhiteSpace();
    internal bool SinkIntegerSuffix();
    internal bool SinkDecimalIntegerSuffix();
    internal bool SinkMultipleOctalDigits();
    internal bool SinkOperator();
    internal bool SinkTypeCharacter();
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenEnumerator : TokenEnumerator {
    private VisualBasicTokenCharReader _reader;
    private static String[] s_keywordList;
    internal TokenCharReader Reader { get; }
    internal VisualBasicTokenEnumerator(Stream binaryStream, bool forceANSI);
    private static VisualBasicTokenEnumerator();
    internal virtual bool FindNextToken();
    internal virtual TokenCharReader get_Reader();
}
internal class Microsoft.Build.Shared.LanguageParser.VisualBasicTokenizer : object {
    private Stream _binaryStream;
    private bool _forceANSI;
    internal VisualBasicTokenizer(Stream binaryStream, bool forceANSI);
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Shared.LanguageParser.WhitespaceToken : Token {
}
internal static class Microsoft.Build.Shared.MetadataConversionUtilities : object {
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName, Boolean& metadataFound);
    internal static bool TryConvertItemMetadataToBool(ITaskItem item, string itemMetadataName);
}
internal class Microsoft.Build.Shared.NGen`1 : ValueType {
    private T _value;
    public NGen`1(T value);
    public static T op_Implicit(NGen`1<T> value);
    public static NGen`1<T> op_Implicit(T value);
}
internal class Microsoft.Build.Shared.OpenBaseKey : MulticastDelegate {
    public OpenBaseKey(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual RegistryKey Invoke(RegistryHive hive, RegistryView view);
    public virtual IAsyncResult BeginInvoke(RegistryHive hive, RegistryView view, AsyncCallback callback, object object);
    public virtual RegistryKey EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum Microsoft.Build.Shared.PartialComparisonFlags : Enum {
    public int value__;
    public static PartialComparisonFlags SimpleName;
    public static PartialComparisonFlags Version;
    public static PartialComparisonFlags Culture;
    public static PartialComparisonFlags PublicKeyToken;
    public static PartialComparisonFlags Default;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Shared.PlatformNegotiation : object {
    internal static string GetNearestPlatform(string overridePlatformValue, string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper log);
    internal static Dictionary`2<string, string> ExtractLookupTable(string stringTable, TaskLoggingHelper log);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatform("windows")]
internal static class Microsoft.Build.Shared.RegistryHelper : object {
    internal static IEnumerable`1<string> GetSubKeyNames(RegistryKey baseKey, string subkey);
    internal static string GetDefaultValue(RegistryKey baseKey, string subkey);
    internal static RegistryKey OpenBaseKey(RegistryHive hive, RegistryView view);
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    private static string GetHelpKeyword(string resourceName);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceStringStripCodeAndKeyword(String& code, String& helpKeyword, string resourceName, Object[] args);
    [ObsoleteAttribute("Use GetResourceString instead.", "True")]
[EditorBrowsableAttribute("1")]
internal static string FormatResourceString(string resourceName);
    internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, Object[] args);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    [ConditionalAttribute("DEBUG")]
internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Shared.SolutionConfiguration : object {
    public static string ProjectAttribute;
    public static string AbsolutePathAttribute;
    public static string BuildProjectInSolutionAttribute;
    public static Char[] ConfigPlatformSeparator;
    private Dictionary`2<string, XmlElement> _cachedProjectElements;
    private Dictionary`2<string, XmlElement> _cachedProjectElementsByAbsolutePath;
    private Dictionary`2<string, string> _cachedProjectAbsolutePathsByGuid;
    private Dictionary`2<string, string> _cachedProjectGuidsByAbsolutePath;
    private Dictionary`2<string, List`1<string>> _cachedDependencyProjectGuidsByDependingProjectGuid;
    [CompilerGeneratedAttribute]
private static SolutionConfiguration <Empty>k__BackingField;
    public static SolutionConfiguration Empty { get; }
    public ICollection`1<XmlElement> ProjectConfigurations { get; }
    public SolutionConfiguration(string xmlString);
    private static SolutionConfiguration();
    [CompilerGeneratedAttribute]
public static SolutionConfiguration get_Empty();
    public ICollection`1<XmlElement> get_ProjectConfigurations();
    public static XmlNodeList GetProjectConfigurations(string xmlString);
    public bool TryGetProjectByGuid(string projectGuid, XmlElement& projectElement);
    public bool TryGetProjectByAbsolutePath(string projectFullPath, XmlElement& projectElement);
    public bool TryGetProjectGuidByAbsolutePath(string projectFullPath, String& projectGuid);
    public bool TryGetProjectDependencies(string projectGuid, List`1& dependencyProjectGuids);
    public bool TryGetProjectPathByGuid(string projectGuid, String& projectPath);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal static class Microsoft.Build.Shared.VisualStudioConstants : object {
    internal static int CurrentVisualStudioSolutionFileVersion;
    internal static string CurrentVisualStudioVersion;
}
internal static class Microsoft.Build.Shared.XMakeAttributes : object {
    internal static string condition;
    internal static string executeTargets;
    internal static string name;
    internal static string msbuildVersion;
    internal static string xmlns;
    internal static string defaultTargets;
    internal static string initialTargets;
    internal static string treatAsLocalProperty;
    internal static string dependsOnTargets;
    internal static string beforeTargets;
    internal static string afterTargets;
    internal static string include;
    internal static string exclude;
    internal static string remove;
    internal static string update;
    internal static string matchOnMetadata;
    internal static string matchOnMetadataOptions;
    internal static string overrideUsingTask;
    internal static string keepMetadata;
    internal static string removeMetadata;
    internal static string keepDuplicates;
    internal static string inputs;
    internal static string outputs;
    internal static string keepDuplicateOutputs;
    internal static string assemblyName;
    internal static string assemblyFile;
    internal static string taskName;
    internal static string continueOnError;
    internal static string project;
    internal static string taskParameter;
    internal static string itemName;
    internal static string propertyName;
    internal static string sdk;
    internal static string sdkName;
    internal static string sdkVersion;
    internal static string sdkMinimumVersion;
    internal static string toolsVersion;
    internal static string runtime;
    internal static string msbuildRuntime;
    internal static string architecture;
    internal static string msbuildArchitecture;
    internal static string taskFactory;
    internal static string parameterType;
    internal static string required;
    internal static string output;
    internal static string defaultValue;
    internal static string evaluate;
    internal static string label;
    internal static string returns;
    internal static string requiredRuntime;
    internal static string requiredPlatform;
    internal static string defaultXmlNamespace;
    private static HashSet`1<string> KnownSpecialTaskAttributes;
    private static HashSet`1<string> KnownSpecialTaskAttributesIgnoreCase;
    private static HashSet`1<string> KnownBatchingTargetAttributes;
    private static HashSet`1<string> ValidMSBuildRuntimeValues;
    private static HashSet`1<string> ValidMSBuildArchitectureValues;
    private static XMakeAttributes();
    internal static bool IsSpecialTaskAttribute(string attribute);
    internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute);
    internal static bool IsNonBatchingTargetAttribute(string attribute);
    internal static bool IsValidMSBuildRuntimeValue(string runtime);
    internal static bool IsValidMSBuildArchitectureValue(string architecture);
    internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB);
    internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, String& mergedRuntime);
    internal static bool ArchitectureValuesMatch(string architectureA, string architectureB);
    internal static string GetExplicitMSBuildRuntime(string runtime);
    internal static bool TryMergeArchitectureValues(string architectureA, string architectureB, String& mergedArchitecture);
    internal static string GetCurrentMSBuildArchitecture();
    internal static string GetCurrentMSBuildRuntime();
    internal static string GetExplicitMSBuildArchitecture(string architecture);
}
internal static class Microsoft.Build.Shared.XMakeElements : object {
    internal static string project;
    internal static string visualStudioProject;
    internal static string target;
    internal static string propertyGroup;
    internal static string output;
    internal static string itemGroup;
    internal static string itemDefinitionGroup;
    internal static string usingTask;
    internal static string projectExtensions;
    internal static string onError;
    internal static string error;
    internal static string warning;
    internal static string message;
    internal static string import;
    internal static string importGroup;
    internal static string choose;
    internal static string when;
    internal static string otherwise;
    internal static string usingTaskParameterGroup;
    internal static string usingTaskParameter;
    internal static string usingTaskBody;
    internal static string sdk;
    internal static Char[] InvalidTargetNameCharacters;
    internal static HashSet`1<string> ReservedItemNames;
    private static XMakeElements();
}
public class Microsoft.Build.Tasks.AL : ToolTaskExtension {
    public string AlgorithmId { get; public set; }
    public string BaseAddress { get; public set; }
    public string CompanyName { get; public set; }
    public string Configuration { get; public set; }
    public string Copyright { get; public set; }
    public string Culture { get; public set; }
    public bool DelaySign { get; public set; }
    public string Description { get; public set; }
    public string EvidenceFile { get; public set; }
    public string FileVersion { get; public set; }
    public string Flags { get; public set; }
    public bool GenerateFullPaths { get; public set; }
    public string KeyFile { get; public set; }
    public string KeyContainer { get; public set; }
    public string MainEntryPoint { get; public set; }
    [OutputAttribute]
[RequiredAttribute]
public ITaskItem OutputAssembly { get; public set; }
    public string Platform { get; public set; }
    internal string PlatformWith32BitPreference { get; }
    public bool Prefer32Bit { get; public set; }
    public string ProductName { get; public set; }
    public string ProductVersion { get; public set; }
    public String[] ResponseFiles { get; public set; }
    public string TargetType { get; public set; }
    public string TemplateFile { get; public set; }
    public string Title { get; public set; }
    public string Trademark { get; public set; }
    public string Version { get; public set; }
    public string Win32Icon { get; public set; }
    public string Win32Resource { get; public set; }
    public ITaskItem[] SourceModules { get; public set; }
    public ITaskItem[] EmbedResources { get; public set; }
    public ITaskItem[] LinkResources { get; public set; }
    public string SdkToolsPath { get; public set; }
    protected string ToolName { get; }
    public void set_AlgorithmId(string value);
    public string get_AlgorithmId();
    public void set_BaseAddress(string value);
    public string get_BaseAddress();
    public void set_CompanyName(string value);
    public string get_CompanyName();
    public void set_Configuration(string value);
    public string get_Configuration();
    public void set_Copyright(string value);
    public string get_Copyright();
    public void set_Culture(string value);
    public string get_Culture();
    public void set_DelaySign(bool value);
    public bool get_DelaySign();
    public void set_Description(string value);
    public string get_Description();
    public void set_EvidenceFile(string value);
    public string get_EvidenceFile();
    public void set_FileVersion(string value);
    public string get_FileVersion();
    public void set_Flags(string value);
    public string get_Flags();
    public void set_GenerateFullPaths(bool value);
    public bool get_GenerateFullPaths();
    public void set_KeyFile(string value);
    public string get_KeyFile();
    public void set_KeyContainer(string value);
    public string get_KeyContainer();
    public void set_MainEntryPoint(string value);
    public string get_MainEntryPoint();
    public void set_OutputAssembly(ITaskItem value);
    public ITaskItem get_OutputAssembly();
    public void set_Platform(string value);
    public string get_Platform();
    internal string get_PlatformWith32BitPreference();
    public void set_Prefer32Bit(bool value);
    public bool get_Prefer32Bit();
    public void set_ProductName(string value);
    public string get_ProductName();
    public void set_ProductVersion(string value);
    public string get_ProductVersion();
    public void set_ResponseFiles(String[] value);
    public String[] get_ResponseFiles();
    public void set_TargetType(string value);
    public string get_TargetType();
    public void set_TemplateFile(string value);
    public string get_TemplateFile();
    public void set_Title(string value);
    public string get_Title();
    public void set_Trademark(string value);
    public string get_Trademark();
    public void set_Version(string value);
    public string get_Version();
    public void set_Win32Icon(string value);
    public string get_Win32Icon();
    public void set_Win32Resource(string value);
    public string get_Win32Resource();
    public void set_SourceModules(ITaskItem[] value);
    public ITaskItem[] get_SourceModules();
    public void set_EmbedResources(ITaskItem[] value);
    public ITaskItem[] get_EmbedResources();
    public void set_LinkResources(ITaskItem[] value);
    public ITaskItem[] get_LinkResources();
    public void set_SdkToolsPath(string value);
    public string get_SdkToolsPath();
    protected virtual string get_ToolName();
    protected virtual string GenerateFullPathToTool();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.AppConfig : object {
    [CompilerGeneratedAttribute]
private RuntimeSection <Runtime>k__BackingField;
    internal RuntimeSection Runtime { get; }
    internal void Load(string appConfigFilePath);
    internal void Read(XmlReader reader);
    [CompilerGeneratedAttribute]
internal RuntimeSection get_Runtime();
    internal static bool StringEquals(string a, string b);
}
internal class Microsoft.Build.Tasks.AppConfigException : ApplicationException {
    private string fileName;
    private int line;
    private int column;
    internal string FileName { get; }
    internal int Line { get; }
    internal int Column { get; }
    public AppConfigException(string message, string fileName, int line, int column, Exception inner);
    protected AppConfigException(SerializationInfo info, StreamingContext context);
    internal string get_FileName();
    internal int get_Line();
    internal int get_Column();
}
[LoadInSeparateAppDomainAttribute]
public abstract class Microsoft.Build.Tasks.AppDomainIsolatedTaskExtension : AppDomainIsolatedTask {
    private TaskLoggingHelperExtension _logExtension;
    public TaskLoggingHelper Log { get; }
    public TaskLoggingHelper get_Log();
}
public class Microsoft.Build.Tasks.AspNetCompiler : ToolTaskExtension {
    [CompilerGeneratedAttribute]
private bool <AllowPartiallyTrustedCallers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FixedNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Updateable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Clean>k__BackingField;
    public bool AllowPartiallyTrustedCallers { get; public set; }
    public bool DelaySign { get; public set; }
    public bool FixedNames { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public string MetabasePath { get; public set; }
    public string PhysicalPath { get; public set; }
    public string TargetPath { get; public set; }
    public string VirtualPath { get; public set; }
    public bool Updateable { get; public set; }
    public bool Force { get; public set; }
    public bool Debug { get; public set; }
    public bool Clean { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    protected string ToolName { get; }
    private string ProjectName { get; }
    private string TargetName { get; }
    [CompilerGeneratedAttribute]
public bool get_AllowPartiallyTrustedCallers();
    [CompilerGeneratedAttribute]
public void set_AllowPartiallyTrustedCallers(bool value);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
    [CompilerGeneratedAttribute]
public void set_DelaySign(bool value);
    [CompilerGeneratedAttribute]
public bool get_FixedNames();
    [CompilerGeneratedAttribute]
public void set_FixedNames(bool value);
    public string get_KeyContainer();
    public void set_KeyContainer(string value);
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public string get_MetabasePath();
    public void set_MetabasePath(string value);
    public string get_PhysicalPath();
    public void set_PhysicalPath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public string get_VirtualPath();
    public void set_VirtualPath(string value);
    [CompilerGeneratedAttribute]
public bool get_Updateable();
    [CompilerGeneratedAttribute]
public void set_Updateable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Force();
    [CompilerGeneratedAttribute]
public void set_Force(bool value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public bool get_Clean();
    [CompilerGeneratedAttribute]
public void set_Clean(bool value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    protected virtual string get_ToolName();
    private string get_ProjectName();
    private string get_TargetName();
    public virtual bool Execute();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
}
internal class Microsoft.Build.Tasks.ASSEMBLY_INFO : ValueType {
    public UInt32 cbAssemblyInfo;
    public UInt32 dwAssemblyFlags;
    public ulong uliAssemblySizeInKB;
    public string pszCurrentAssemblyPathBuf;
    public UInt32 cchBuf;
}
[FlagsAttribute]
internal enum Microsoft.Build.Tasks.AssemblyCacheFlags : Enum {
    public int value__;
    public static AssemblyCacheFlags ZAP;
    public static AssemblyCacheFlags GAC;
    public static AssemblyCacheFlags DOWNLOAD;
}
internal class Microsoft.Build.Tasks.AssemblyDependency.AssemblyMetadata : object {
    public AssemblyNameExtension[] Dependencies;
    public FrameworkName FrameworkName;
    public String[] ScatterFiles;
    public AssemblyMetadata(string path);
}
internal class Microsoft.Build.Tasks.AssemblyEntry : object {
    private AssemblyNameExtension _assemblyName;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InGAC>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsRedistRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SimpleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Retargetable>k__BackingField;
    public string FullName { get; }
    public bool InGAC { get; }
    public Nullable`1<bool> IsRedistRoot { get; }
    public string RedistName { get; }
    public string SimpleName { get; }
    public string FrameworkDirectory { get; }
    public bool Retargetable { get; }
    public AssemblyNameExtension AssemblyNameExtension { get; }
    public AssemblyEntry(string name, string version, string publicKeyToken, string culture, bool inGAC, Nullable`1<bool> isRedistRoot, string redistName, string frameworkDirectory, bool retargetable);
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public bool get_InGAC();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsRedistRoot();
    [CompilerGeneratedAttribute]
public string get_RedistName();
    [CompilerGeneratedAttribute]
public string get_SimpleName();
    [CompilerGeneratedAttribute]
public string get_FrameworkDirectory();
    [CompilerGeneratedAttribute]
public bool get_Retargetable();
    public AssemblyNameExtension get_AssemblyNameExtension();
}
internal static class Microsoft.Build.Tasks.AssemblyFolder : object {
    private static Dictionary`2<string, string> s_assemblyFolders;
    private static object s_syncLock;
    private static AssemblyFolder();
    private static void AddFoldersFromRegistryKey(RegistryKey hive, string key, Dictionary`2<string, string> directories);
    private static void AddFoldersFromRegistryKey(string key, Dictionary`2<string, string> directories);
    private static void CreateAssemblyFolders();
    [IteratorStateMachineAttribute("Microsoft.Build.Tasks.AssemblyFolder/<GetAssemblyFolders>d__5")]
internal static IEnumerable`1<string> GetAssemblyFolders(string regKeyAlias);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersExCache : object {
    private HashSet`1<string> _filesInDirectories;
    private FileExists _fileExists;
    private bool _useOriginalFileExists;
    [CompilerGeneratedAttribute]
private AssemblyFoldersEx <AssemblyFoldersEx>k__BackingField;
    internal AssemblyFoldersEx AssemblyFoldersEx { get; }
    internal AssemblyFoldersExCache(AssemblyFoldersEx assemblyFoldersEx, FileExists fileExists);
    [CompilerGeneratedAttribute]
internal AssemblyFoldersEx get_AssemblyFoldersEx();
    internal bool FileExists(string path);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersExResolver : Resolver {
    private static Lazy`1<Regex> s_crackAssemblyFoldersExSentinel;
    private GetRegistrySubKeyNames _getRegistrySubKeyNames;
    private GetRegistrySubKeyDefaultValue _getRegistrySubKeyDefaultValue;
    private OpenBaseKey _openBaseKey;
    private bool _wasMatch;
    private string _registryKeyRoot;
    private string _targetRuntimeVersion;
    private string _registryKeySuffix;
    private string _osVersion;
    private string _platform;
    private bool _isInitialized;
    private AssemblyFoldersExCache _assemblyFoldersCache;
    private IBuildEngine4 _buildEngine;
    internal AssemblyFoldersEx AssemblyFoldersExLocations { get; }
    public AssemblyFoldersExResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine);
    private static AssemblyFoldersExResolver();
    internal AssemblyFoldersEx get_AssemblyFoldersExLocations();
    private void LazyInitialize();
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfig : object {
    private List`1<AssemblyFoldersFromConfigInfo> _directoryNames;
    internal AssemblyFoldersFromConfig(string configFile, string targetRuntimeVersion, ProcessorArchitecture targetArchitecture);
    private void FindDirectories(List`1<AssemblyFolderItem> assemblyTargets, Func`2<AssemblyFolderItem, bool> platformFilter);
    private static List`1<AssemblyFolderItem> GatherVersionStrings(string targetRuntimeVersion, AssemblyFolderCollection collection);
    private static Version GetFrameworkVersion(string version);
    private sealed virtual override IEnumerator`1<AssemblyFoldersFromConfigInfo> System.Collections.Generic.IEnumerable<Microsoft.Build.Utilities.AssemblyFoldersFromConfigInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigCache : object {
    private ImmutableHashSet`1<string> _filesInDirectories;
    private FileExists _fileExists;
    private bool _useOriginalFileExists;
    [CompilerGeneratedAttribute]
private AssemblyFoldersFromConfig <AssemblyFoldersFromConfig>k__BackingField;
    internal AssemblyFoldersFromConfig AssemblyFoldersFromConfig { get; }
    internal AssemblyFoldersFromConfigCache(AssemblyFoldersFromConfig assemblyFoldersFromConfig, FileExists fileExists);
    [CompilerGeneratedAttribute]
internal AssemblyFoldersFromConfig get_AssemblyFoldersFromConfig();
    internal bool FileExists(string path);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersFromConfig.AssemblyFoldersFromConfigResolver : Resolver {
    private static Lazy`1<Regex> s_crackAssemblyFoldersFromConfigSentinel;
    private bool _wasMatch;
    private string _targetRuntimeVersion;
    private bool _isInitialized;
    private AssemblyFoldersFromConfigCache _assemblyFoldersCache;
    private IBuildEngine4 _buildEngine;
    private TaskLoggingHelper _taskLogger;
    private string _assemblyFolderConfigFile;
    internal AssemblyFoldersFromConfig AssemblyFoldersExLocations { get; }
    public AssemblyFoldersFromConfigResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, ProcessorArchitecture targetProcessorArchitecture, bool compareProcessorArchitecture, IBuildEngine buildEngine, TaskLoggingHelper log);
    private static AssemblyFoldersFromConfigResolver();
    internal AssemblyFoldersFromConfig get_AssemblyFoldersExLocations();
    private void LazyInitialize();
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.AssemblyFoldersResolver : Resolver {
    public AssemblyFoldersResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal enum Microsoft.Build.Tasks.ASSEMBLYINFO_FLAG : Enum {
    public int value__;
    public static ASSEMBLYINFO_FLAG VALIDATE;
    public static ASSEMBLYINFO_FLAG GETSIZE;
}
internal class Microsoft.Build.Tasks.AssemblyInformation : DisposableBase {
    private AssemblyNameExtension[] _assemblyDependencies;
    private String[] _assemblyFiles;
    private IMetaDataDispenser _metadataDispenser;
    private IMetaDataAssemblyImport _assemblyImport;
    private static Guid s_importerGuid;
    private Assembly _assembly;
    private string _sourceFile;
    private FrameworkName _frameworkName;
    private static string s_targetFrameworkAttribute;
    private static int GENMAN_STRING_BUF_SIZE;
    private static int GENMAN_LOCALE_BUF_SIZE;
    private static int GENMAN_ENUM_TOKEN_BUF_SIZE;
    public AssemblyNameExtension[] Dependencies { get; }
    public String[] Files { get; }
    public FrameworkName FrameworkNameAttribute { get; }
    private static AssemblyInformation();
    internal AssemblyInformation(string sourceFile);
    private static Assembly ReflectionOnlyAssemblyResolve(object sender, ResolveEventArgs args);
    public AssemblyNameExtension[] get_Dependencies();
    public String[] get_Files();
    public FrameworkName get_FrameworkNameAttribute();
    internal static void GetAssemblyMetadata(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkName);
    internal static FrameworkName GetTargetFrameworkAttribute(string path);
    internal static bool IsWinMDFile(string fullPath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd);
    private FrameworkName GetFrameworkName();
    protected virtual void DisposeUnmanagedResources();
    internal static string GetRuntimeVersion(string path);
    private AssemblyNameExtension[] ImportAssemblyDependencies();
    private String[] ImportFiles();
    private static IntPtr AllocAsmMeta();
    private static AssemblyNameExtension ConstructAssemblyName(IntPtr asmMetaPtr, Char[] asmNameBuf, UInt32 asmNameLength, IntPtr pubKeyPtr, UInt32 pubKeyBytes, UInt32 flags);
    private static void FreeAsmMeta(IntPtr asmMetaPtr);
}
internal class Microsoft.Build.Tasks.ASSEMBLYMETADATA : ValueType {
    public ushort usMajorVersion;
    public ushort usMinorVersion;
    public ushort usBuildNumber;
    public ushort usRevisionNumber;
    public IntPtr rpLocale;
    public UInt32 cchLocale;
    public IntPtr rpProcessors;
    public UInt32 cProcessors;
    public IntPtr rOses;
    public UInt32 cOses;
}
[FlagsAttribute]
internal enum Microsoft.Build.Tasks.AssemblyNameDisplayFlags : Enum {
    public int value__;
    public static AssemblyNameDisplayFlags VERSION;
    public static AssemblyNameDisplayFlags CULTURE;
    public static AssemblyNameDisplayFlags PUBLIC_KEY_TOKEN;
    public static AssemblyNameDisplayFlags PROCESSORARCHITECTURE;
    public static AssemblyNameDisplayFlags RETARGETABLE;
    public static AssemblyNameDisplayFlags ALL;
}
internal class Microsoft.Build.Tasks.AssemblyNameReference : ValueType {
    internal AssemblyNameExtension assemblyName;
    internal Reference reference;
    [IsReadOnlyAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
public sealed virtual int CompareTo(AssemblyNameReference other);
    public static AssemblyNameReference Create(AssemblyNameExtension assemblyName, Reference reference);
}
internal class Microsoft.Build.Tasks.AssemblyNameReferenceAscendingVersionComparer : object {
    internal static IComparer`1<AssemblyNameReference> comparer;
    [CompilerGeneratedAttribute]
private static Version <DummyVersion>k__BackingField;
    private static Version DummyVersion { get; }
    private static AssemblyNameReferenceAscendingVersionComparer();
    [CompilerGeneratedAttribute]
private static Version get_DummyVersion();
    public sealed virtual int Compare(AssemblyNameReference i1, AssemblyNameReference i2);
}
internal class Microsoft.Build.Tasks.AssemblyNamesTypeResolutionService : object {
    private Hashtable _cachedAssemblies;
    private ITaskItem[] _referencePaths;
    private Hashtable _cachedTypes;
    internal AssemblyNamesTypeResolutionService(ITaskItem[] referencePaths);
    public sealed virtual Assembly GetAssembly(AssemblyName name);
    public sealed virtual Assembly GetAssembly(AssemblyName name, bool throwOnError);
    private Assembly GetAssemblyByPath(string pathToAssembly, bool throwOnError);
    public sealed virtual string GetPathOfAssembly(AssemblyName name);
    public sealed virtual Type GetType(string name);
    public sealed virtual Type GetType(string name, bool throwOnError);
    public sealed virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public sealed virtual void ReferenceAssembly(AssemblyName name);
}
internal class Microsoft.Build.Tasks.AssemblyRegistrationCache : StateFileBase {
    internal List`1<string> _assemblies;
    internal List`1<string> _typeLibraries;
    internal int Count { get; }
    public AssemblyRegistrationCache(ITranslator translator);
    internal int get_Count();
    internal void AddEntry(string assemblyPath, string typeLibraryPath);
    internal void GetEntry(int index, String& assemblyPath, String& typeLibraryPath);
    public virtual void Translate(ITranslator translator);
}
internal class Microsoft.Build.Tasks.AssemblyRemapping : object {
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <From>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <To>k__BackingField;
    public AssemblyNameExtension From { get; }
    public AssemblyNameExtension To { get; }
    public AssemblyRemapping(AssemblyNameExtension from, AssemblyNameExtension to);
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_From();
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_To();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AssemblyRemapping other);
}
internal static class Microsoft.Build.Tasks.AssemblyResolution : object {
    internal static string ResolveReference(IEnumerable`1<Resolver[]> jaggedResolvers, AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& resolvedSearchPath, Boolean& userRequestedSpecificFile);
    public static Resolver[] CompileSearchPaths(IBuildEngine buildEngine, String[] searchPaths, String[] candidateAssemblyFiles, ProcessorArchitecture targetProcessorArchitecture, String[] frameworkPaths, FileExists fileExists, GetAssemblyName getAssemblyName, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, InstalledAssemblies installedAssemblies, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, GetAssemblyPathInGac getAssemblyPathInGac, TaskLoggingHelper log);
    internal static Resolver[] CompileDirectories(List`1<string> directories, FileExists fileExists, GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion);
}
internal static class Microsoft.Build.Tasks.AssemblyResolutionConstants : object {
    public static string hintPathSentinel;
    public static string assemblyFoldersSentinel;
    public static string candidateAssemblyFilesSentinel;
    public static string gacSentinel;
    public static string frameworkPathSentinel;
    public static string rawFileNameSentinel;
    public static string assemblyFoldersExSentinel;
    public static string assemblyFoldersFromConfigSentinel;
}
internal class Microsoft.Build.Tasks.AssemblyTableInfo : object {
    private string _descriptor;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FrameworkDirectory>k__BackingField;
    internal string Path { get; }
    internal string FrameworkDirectory { get; }
    internal string Descriptor { get; }
    internal AssemblyTableInfo(string path, string frameworkDirectory);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal string get_FrameworkDirectory();
    internal string get_Descriptor();
    public sealed virtual int CompareTo(object obj);
}
public class Microsoft.Build.Tasks.AssignCulture : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFilesWithCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFilesWithNoCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CultureNeutralAssignedFiles>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedFiles { get; private set; }
    [OutputAttribute]
public ITaskItem[] AssignedFilesWithCulture { get; private set; }
    [OutputAttribute]
public ITaskItem[] AssignedFilesWithNoCulture { get; private set; }
    [OutputAttribute]
public ITaskItem[] CultureNeutralAssignedFiles { get; private set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFiles();
    [CompilerGeneratedAttribute]
private void set_AssignedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFilesWithCulture();
    [CompilerGeneratedAttribute]
private void set_AssignedFilesWithCulture(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFilesWithNoCulture();
    [CompilerGeneratedAttribute]
private void set_AssignedFilesWithNoCulture(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CultureNeutralAssignedFiles();
    [CompilerGeneratedAttribute]
private void set_CultureNeutralAssignedFiles(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.AssignLinkMetadata : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutputItems>k__BackingField;
    public ITaskItem[] Items { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputItems { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutputItems();
    [CompilerGeneratedAttribute]
public void set_OutputItems(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.AssignProjectConfiguration : ResolveProjectBase {
    [CompilerGeneratedAttribute]
private string <SolutionConfigurationContents>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddSyntheticProjectReferencesForSolutionDependencies>k__BackingField;
    private string _defaultToVcxPlatformMapping;
    private string _vcxToDefaultPlatformMapping;
    [CompilerGeneratedAttribute]
private string <CurrentProject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentProjectConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentProjectPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldUnsetParentConfigurationAndPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveConfigurationPlatformUsingMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <UnassignedProjects>k__BackingField;
    private static string attrFullConfiguration;
    private static string buildReferenceMetadataName;
    private static string referenceOutputAssemblyMetadataName;
    private static string attrConfiguration;
    private static string attrPlatform;
    private static string attrSetConfiguration;
    private static string attrSetPlatform;
    private IDictionary`2<string, string> _vcxToDefaultMap;
    private IDictionary`2<string, string> _defaultToVcxMap;
    private bool _mappingsPopulated;
    public string SolutionConfigurationContents { get; public set; }
    public bool AddSyntheticProjectReferencesForSolutionDependencies { get; public set; }
    public string DefaultToVcxPlatformMapping { get; public set; }
    public string VcxToDefaultPlatformMapping { get; public set; }
    public string CurrentProject { get; public set; }
    public string CurrentProjectConfiguration { get; public set; }
    public string CurrentProjectPlatform { get; public set; }
    public bool OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration { get; public set; }
    public bool ShouldUnsetParentConfigurationAndPlatform { get; public set; }
    public string OutputType { get; public set; }
    public bool ResolveConfigurationPlatformUsingMappings { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedProjects { get; public set; }
    [OutputAttribute]
public ITaskItem[] UnassignedProjects { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SolutionConfigurationContents();
    [CompilerGeneratedAttribute]
public void set_SolutionConfigurationContents(string value);
    [CompilerGeneratedAttribute]
public bool get_AddSyntheticProjectReferencesForSolutionDependencies();
    [CompilerGeneratedAttribute]
public void set_AddSyntheticProjectReferencesForSolutionDependencies(bool value);
    public string get_DefaultToVcxPlatformMapping();
    public void set_DefaultToVcxPlatformMapping(string value);
    public string get_VcxToDefaultPlatformMapping();
    public void set_VcxToDefaultPlatformMapping(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProject();
    [CompilerGeneratedAttribute]
public void set_CurrentProject(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProjectConfiguration();
    [CompilerGeneratedAttribute]
public void set_CurrentProjectConfiguration(string value);
    [CompilerGeneratedAttribute]
public string get_CurrentProjectPlatform();
    [CompilerGeneratedAttribute]
public void set_CurrentProjectPlatform(string value);
    [CompilerGeneratedAttribute]
public bool get_OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration();
    [CompilerGeneratedAttribute]
public void set_OnlyReferenceAndBuildProjectsEnabledInSolutionConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldUnsetParentConfigurationAndPlatform();
    [CompilerGeneratedAttribute]
public void set_ShouldUnsetParentConfigurationAndPlatform(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputType();
    [CompilerGeneratedAttribute]
public void set_OutputType(string value);
    [CompilerGeneratedAttribute]
public bool get_ResolveConfigurationPlatformUsingMappings();
    [CompilerGeneratedAttribute]
public void set_ResolveConfigurationPlatformUsingMappings(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedProjects();
    [CompilerGeneratedAttribute]
public void set_AssignedProjects(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_UnassignedProjects();
    [CompilerGeneratedAttribute]
public void set_UnassignedProjects(ITaskItem[] value);
    public virtual bool Execute();
    internal bool ResolveProject(ITaskItem projectRef, ITaskItem& resolvedProjectWithConfiguration);
    internal static void SetBuildInProjectAndReferenceOutputAssemblyMetadata(bool onlyReferenceAndBuildProjectsEnabledInSolutionConfiguration, ITaskItem resolvedProjectWithConfiguration, XmlElement projectConfigurationElement);
    private void SetupDefaultPlatformMappings();
    private void PopulateMappingDictionary(IDictionary`2<string, string> map, string mappingList);
}
public class Microsoft.Build.Tasks.AssignTargetPath : TaskExtension {
    [CompilerGeneratedAttribute]
private string <RootFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssignedFiles>k__BackingField;
    [RequiredAttribute]
public string RootFolder { get; public set; }
    public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] AssignedFiles { get; private set; }
    [CompilerGeneratedAttribute]
public string get_RootFolder();
    [CompilerGeneratedAttribute]
public void set_RootFolder(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedFiles();
    [CompilerGeneratedAttribute]
private void set_AssignedFiles(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.AxReference : AxTlbBaseReference {
    internal AxReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, string sdkToolsPath, IBuildEngine buildEngine, String[] environmentVariables);
    protected virtual string GetWrapperFileNameInternal(string typeLibName);
    internal bool GenerateWrapper(ComReferenceWrapperInfo& wrapperInfo);
}
internal abstract class Microsoft.Build.Tasks.AxTlbBaseReference : ComReference {
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private IComReferenceResolver <ResolverCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExecuteAsTool>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTypeLibVersionInName>k__BackingField;
    protected string OutputDirectory { get; }
    protected IComReferenceResolver ResolverCallback { get; }
    protected string KeyContainer { get; protected set; }
    protected string KeyFile { get; protected set; }
    protected bool DelaySign { get; protected set; }
    protected bool ExecuteAsTool { get; protected set; }
    protected IBuildEngine BuildEngine { get; protected set; }
    protected String[] EnvironmentVariables { get; protected set; }
    protected string ToolPath { get; protected set; }
    protected bool IncludeTypeLibVersionInName { get; protected set; }
    internal AxTlbBaseReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool delaySign, string keyFile, string keyContainer, bool includeTypeLibVersionInName, bool executeAsTool, string toolPath, IBuildEngine buildEngine, String[] environmentVariables);
    [CompilerGeneratedAttribute]
protected virtual string get_OutputDirectory();
    [CompilerGeneratedAttribute]
protected IComReferenceResolver get_ResolverCallback();
    [CompilerGeneratedAttribute]
protected string get_KeyContainer();
    [CompilerGeneratedAttribute]
protected void set_KeyContainer(string value);
    [CompilerGeneratedAttribute]
protected string get_KeyFile();
    [CompilerGeneratedAttribute]
protected void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
protected bool get_DelaySign();
    [CompilerGeneratedAttribute]
protected void set_DelaySign(bool value);
    [CompilerGeneratedAttribute]
protected bool get_ExecuteAsTool();
    [CompilerGeneratedAttribute]
protected void set_ExecuteAsTool(bool value);
    [CompilerGeneratedAttribute]
protected IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
protected void set_BuildEngine(IBuildEngine value);
    [CompilerGeneratedAttribute]
protected String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
protected void set_EnvironmentVariables(String[] value);
    [CompilerGeneratedAttribute]
protected string get_ToolPath();
    [CompilerGeneratedAttribute]
protected void set_ToolPath(string value);
    [CompilerGeneratedAttribute]
protected bool get_IncludeTypeLibVersionInName();
    [CompilerGeneratedAttribute]
protected void set_IncludeTypeLibVersionInName(bool value);
    internal virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
    protected virtual bool IsWrapperUpToDate(ComReferenceWrapperInfo wrapperInfo, DateTime componentTimestamp);
    internal string GetWrapperPath();
    internal string GetWrapperFileName();
    protected abstract virtual string GetWrapperFileNameInternal(string typeLibName);
    internal static string GetWrapperFileName(string interopDllHeader, string typeLibName, bool includeTypeLibVersionInName, short majorVerNum, short minorVerNum);
    internal void GetAndValidateStrongNameKey(StrongNameKeyPair& keyPair, Byte[]& publicKey);
    private bool SigningRequirementsMatchExistingWrapper(ComReferenceWrapperInfo wrapperInfo);
}
internal abstract class Microsoft.Build.Tasks.AxTlbBaseTask : ToolTaskExtension {
    private bool _delaySigningAndKeyFileOnlyContainsPublicKey;
    [CompilerGeneratedAttribute]
private string <ToolName>k__BackingField;
    public bool DelaySign { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public string SdkToolsPath { get; public set; }
    protected string ToolName { get; }
    public bool get_DelaySign();
    public void set_DelaySign(bool value);
    public string get_KeyContainer();
    public void set_KeyContainer(string value);
    public string get_KeyFile();
    public void set_KeyFile(string value);
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    [CompilerGeneratedAttribute]
protected virtual string get_ToolName();
    public virtual bool Execute();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    private void AddStrongNameOptions(CommandLineBuilderExtension commandLine);
    private bool ValidateStrongNameParameters();
}
internal class Microsoft.Build.Tasks.BadImageReferenceException : Exception {
    public string Message { get; }
    internal BadImageReferenceException(string message, Exception innerException);
    private BadImageReferenceException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
internal class Microsoft.Build.Tasks.BindingRedirect : object {
    [CompilerGeneratedAttribute]
private Version <OldVersionLow>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <OldVersionHigh>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <NewVersion>k__BackingField;
    internal Version OldVersionLow { get; internal set; }
    internal Version OldVersionHigh { get; internal set; }
    internal Version NewVersion { get; internal set; }
    [CompilerGeneratedAttribute]
internal void set_OldVersionLow(Version value);
    [CompilerGeneratedAttribute]
internal Version get_OldVersionLow();
    [CompilerGeneratedAttribute]
internal void set_OldVersionHigh(Version value);
    [CompilerGeneratedAttribute]
internal Version get_OldVersionHigh();
    [CompilerGeneratedAttribute]
internal void set_NewVersion(Version value);
    [CompilerGeneratedAttribute]
internal Version get_NewVersion();
    internal void Read(XmlReader reader);
}
internal class Microsoft.Build.Tasks.BuildCacheDisposeWrapper : object {
    private bool _disposed;
    private CallDuringDispose _callDuringDispose;
    internal BuildCacheDisposeWrapper(CallDuringDispose callDuringDispose);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[RunInMTAAttribute]
public class Microsoft.Build.Tasks.CallTarget : TaskExtension {
    private List`1<ITaskItem> _targetOutputs;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    public String[] Targets { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RunEachTargetSeparately { get; public set; }
    public bool UseResultsCache { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.CandidateAssemblyFilesResolver : Resolver {
    private String[] _candidateAssemblyFiles;
    public CandidateAssemblyFilesResolver(String[] candidateAssemblyFiles, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
public class Microsoft.Build.Tasks.CodeTaskFactory : object {
    private static IDictionary`2<string, Assembly> s_knownReferenceAssemblies;
    private static string _msbuildFrameworkName;
    private static string _msbuildFrameworkPath;
    private static string _msbuildUtilitiesName;
    private static string _msbuildUtilitiesPath;
    private static String[] s_defaultReferencedFrameworkAssemblyNames;
    private String[] _defaultUsingNamespaces;
    private static ConcurrentDictionary`2<FullTaskSpecification, Assembly> s_compiledTaskCache;
    private List`1<string> _referencedAssemblies;
    private List`1<string> _usingNamespaces;
    private string _type;
    private bool _typeIsFragment;
    private bool _typeIsMethod;
    private string _language;
    private string _sourceCode;
    private string _nameOfTask;
    private string _sourcePath;
    private XmlNode _taskNode;
    private Assembly _compiledAssembly;
    private TaskLoggingHelper _log;
    private IDictionary`2<string, TaskPropertyInfo> _taskParameterTypeInfo;
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    private static CodeTaskFactory();
    private static Assembly CurrentDomainOnAssemblyResolve(object sender, ResolveEventArgs args);
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine loggingHost);
    public sealed virtual void CleanupTask(ITask task);
    private static void CreateProperty(CodeTypeDeclaration ctd, string propertyName, Type propertyType, object defaultValue);
    private static void CreateExecuteMethodFromFragment(CodeTypeDeclaration codeTypeDeclaration, string executeCode);
    private static void CreateTaskBody(CodeTypeDeclaration codeTypeDeclaration, string taskCode);
    private static void CreateProperty(CodeTypeDeclaration codeTypeDeclaration, TaskPropertyInfo propInfo, object defaultValue);
    private List`1<string> ExtractReferencedAssemblies();
    private List`1<string> ExtractUsingNamespaces();
    private XmlNode ExtractTaskContent(string taskElementContents);
    private bool ValidateTaskNode();
    private bool HasInvalidChildNodes(XmlNode parentNode, XmlNodeType[] allowedNodeTypes);
    private void AddReferenceAssemblyToReferenceList(List`1<string> referenceAssemblyList, string referenceAssembly);
    private Assembly CompileInMemoryAssembly();
    private List`1<string> CombineReferencedAssemblies();
    private String[] CombineUsingNamespaces();
    private void CreateTaskProperties(CodeTypeDeclaration codeTypeDeclaration);
    private CodeTypeDeclaration CreateTaskClass();
    [CompilerGeneratedAttribute]
internal static string <AddReferenceAssemblyToReferenceList>g__GetPathFromPartialAssemblyName|42_0(string partialName);
    [CompilerGeneratedAttribute]
private bool <AddReferenceAssemblyToReferenceList>g__TryCacheAssemblyIdentityFromPath|42_1(string assemblyFile, String& candidateAssemblyLocation);
}
public class Microsoft.Build.Tasks.CombinePath : TaskExtension {
    private ITaskItem[] _paths;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CombinedPaths>k__BackingField;
    public string BasePath { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Paths { get; public set; }
    [OutputAttribute]
public ITaskItem[] CombinedPaths { get; public set; }
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    public ITaskItem[] get_Paths();
    public void set_Paths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CombinedPaths();
    [CompilerGeneratedAttribute]
public void set_CombinedPaths(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.CombineTargetFrameworkInfoProperties : TaskExtension {
    [CompilerGeneratedAttribute]
private string <RootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <PropertiesAndValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAttributeForTargetFrameworkInfoPropertyNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    public string RootElementName { get; public set; }
    public ITaskItem[] PropertiesAndValues { get; public set; }
    public bool UseAttributeForTargetFrameworkInfoPropertyNames { get; public set; }
    [OutputAttribute]
public string Result { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RootElementName();
    [CompilerGeneratedAttribute]
public void set_RootElementName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_PropertiesAndValues();
    [CompilerGeneratedAttribute]
public void set_PropertiesAndValues(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_UseAttributeForTargetFrameworkInfoPropertyNames();
    [CompilerGeneratedAttribute]
public void set_UseAttributeForTargetFrameworkInfoPropertyNames(bool value);
    [CompilerGeneratedAttribute]
public string get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.CombineXmlElements : TaskExtension {
    [CompilerGeneratedAttribute]
private string <RootElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <XmlElements>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    public string RootElementName { get; public set; }
    public ITaskItem[] XmlElements { get; public set; }
    [OutputAttribute]
public string Result { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RootElementName();
    [CompilerGeneratedAttribute]
public void set_RootElementName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_XmlElements();
    [CompilerGeneratedAttribute]
public void set_XmlElements(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(string value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ComDependencyWalker : object {
    private HashSet`1<TYPELIBATTR> _dependencies;
    private HashSet`1<AnalyzedTypesInfoKey> _analyzedTypes;
    private MarshalReleaseComObject _marshalReleaseComObject;
    [CompilerGeneratedAttribute]
private List`1<Exception> <EncounteredProblems>k__BackingField;
    internal List`1<Exception> EncounteredProblems { get; }
    internal ComDependencyWalker(MarshalReleaseComObject marshalReleaseComObject);
    [CompilerGeneratedAttribute]
internal List`1<Exception> get_EncounteredProblems();
    internal void AnalyzeTypeLibrary(ITypeLib typeLibrary);
    private void AnalyzeTypeInfo(ITypeInfo typeInfo);
    private static bool CanSkipType(ITypeInfo typeInfo, ITypeLib typeLib, TYPEATTR typeAttributes, TYPELIBATTR typeLibAttributes);
    private void ScanImplementedTypes(ITypeInfo typeInfo, TYPEATTR typeAttributes);
    private void ScanDefinedVariables(ITypeInfo typeInfo, TYPEATTR typeAttributes);
    private void ScanDefinedFunctions(ITypeInfo typeInfo, TYPEATTR typeAttributes);
    private void AnalyzeElement(ITypeInfo typeInfo, ELEMDESC elementDesc);
    internal TYPELIBATTR[] GetDependencies();
    internal ICollection`1<string> GetAnalyzedTypeNames();
    internal void ClearDependencyList();
    internal void ClearAnalyzedTypeCache();
}
public class Microsoft.Build.Tasks.CommandLineBuilderExtension : CommandLineBuilder {
    public CommandLineBuilderExtension(bool quoteHyphensOnCommandLine, bool useNewLineSeparator);
    internal void AppendWhenTrue(string switchName, Hashtable bag, string parameterName);
    internal void AppendPlusOrMinusSwitch(string switchName, Hashtable bag, string parameterName);
    internal void AppendPlusOrMinusSwitch(string switchName, Nullable`1<bool> value);
    internal void AppendByChoiceSwitch(string switchName, Hashtable bag, string parameterName, string choice1, string choice2);
    internal void AppendSwitchWithInteger(string switchName, Hashtable bag, string parameterName);
    internal void AppendSwitchAliased(string switchName, string alias, string parameter);
    internal void AppendNestedSwitch(string outerSwitchName, string innerSwitchName, string parameter);
    protected string GetQuotedText(string unquotedText);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] attributes);
    internal void AppendSwitchWithSplitting(string switchName, string parameter, string delimiter, Char[] splitOn);
    internal static bool IsParameterEmpty(string parameter, Char[] splitOn);
    internal void AppendSwitchIfNotNull(string switchName, ITaskItem[] parameters, String[] metadataNames, Boolean[] treatAsFlags);
    internal void AppendSwitchIfTrue(string switchName, Nullable`1<bool> value);
}
internal abstract class Microsoft.Build.Tasks.ComReference : object {
    [CompilerGeneratedAttribute]
private ComReferenceInfo <ReferenceInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemName>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskLoggingHelper <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Silent>k__BackingField;
    internal static bool ado27PropertyInitialized;
    internal static bool ado27Installed;
    internal static string ado27ErrorMessage;
    private static Guid s_guidADO20;
    private static Guid s_guidADO21;
    private static Guid s_guidADO25;
    private static Guid s_guidADO26;
    private static Guid s_guidADO27;
    internal ComReferenceInfo ReferenceInfo { get; }
    internal string ItemName { get; }
    protected internal TaskLoggingHelper Log { get; }
    protected internal bool Silent { get; }
    internal static bool Ado27Installed { get; }
    internal static string Ado27ErrorMessage { get; }
    internal ComReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComReferenceInfo referenceInfo, string itemName);
    private static ComReference();
    [CompilerGeneratedAttribute]
internal virtual ComReferenceInfo get_ReferenceInfo();
    [CompilerGeneratedAttribute]
internal virtual string get_ItemName();
    [CompilerGeneratedAttribute]
protected internal TaskLoggingHelper get_Log();
    [CompilerGeneratedAttribute]
protected internal bool get_Silent();
    internal static bool get_Ado27Installed();
    internal static string get_Ado27ErrorMessage();
    internal static string UniqueKeyFromTypeLibAttr(TYPELIBATTR attr);
    internal static bool AreTypeLibAttrEqual(TYPELIBATTR attr1, TYPELIBATTR attr2);
    internal static void GetTypeLibAttrForTypeLib(ITypeLib& typeLib, TYPELIBATTR& typeLibAttr);
    internal static void GetTypeAttrForTypeInfo(ITypeInfo typeInfo, TYPEATTR& typeAttr);
    internal static void GetVarDescForVarIndex(ITypeInfo typeInfo, int varIndex, VARDESC& varDesc, IntPtr& varDescHandle);
    internal static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex, FUNCDESC& funcDesc, IntPtr& funcDescHandle);
    internal static bool GetTypeLibNameForITypeLib(TaskLoggingHelper log, bool silent, ITypeLib typeLib, string typeLibId, String& typeLibName);
    internal static bool GetTypeLibNameForTypeLibAttrs(TaskLoggingHelper log, bool silent, TYPELIBATTR typeLibAttr, String& typeLibName);
    internal static string StripTypeLibNumberFromPath(string typeLibPath, FileExists fileExists);
    private static string GetModuleFileName(IntPtr handle);
    internal static bool GetPathOfTypeLib(TaskLoggingHelper log, bool silent, TYPELIBATTR& typeLibAttr, String& typeLibPath);
    internal static bool RemapAdoTypeLib(TaskLoggingHelper log, bool silent, TYPELIBATTR& typeLibAttr);
    internal abstract virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
}
internal class Microsoft.Build.Tasks.ComReferenceInfo : object {
    internal ITypeLib typeLibPointer;
    internal TYPELIBATTR attr;
    internal string typeLibName;
    internal string strippedTypeLibPath;
    internal string fullTypeLibPath;
    internal ITaskItem taskItem;
    internal ComReferenceInfo primaryOfAxImpRef;
    internal ComReferenceWrapperInfo resolvedWrapper;
    internal List`1<string> dependentWrapperPaths;
    internal ITaskItem referencePathItem;
    internal string SourceItemSpec { get; }
    internal ComReferenceInfo(ComReferenceInfo copyFrom);
    internal bool InitializeWithTypeLibAttrs(TaskLoggingHelper log, bool silent, TYPELIBATTR tlbAttr, ITaskItem originalTaskItem, string targetProcessorArchitecture);
    internal bool InitializeWithPath(TaskLoggingHelper log, bool silent, string path, ITaskItem originalTaskItem, string targetProcessorArchitecture);
    private string GetTypeLibId(TaskLoggingHelper log);
    internal string get_SourceItemSpec();
    internal void ReleaseTypeLibPtr();
}
internal static class Microsoft.Build.Tasks.ComReferenceItemMetadataNames : object {
    internal static string guid;
    internal static string versionMinor;
    internal static string versionMajor;
    internal static string lcid;
    internal static string privatized;
    internal static string wrapperTool;
    internal static string tlbReferenceName;
}
internal class Microsoft.Build.Tasks.ComReferenceResolutionException : Exception {
    internal ComReferenceResolutionException(Exception innerException);
    protected ComReferenceResolutionException(SerializationInfo info, StreamingContext context);
}
internal static class Microsoft.Build.Tasks.ComReferenceTypes : object {
    internal static string tlbimp;
    internal static string aximp;
    internal static string primary;
    internal static string primaryortlbimp;
    internal static bool IsTlbImp(string refType);
    internal static bool IsAxImp(string refType);
    internal static bool IsPia(string refType);
    internal static bool IsPiaOrTlbImp(string refType);
}
internal class Microsoft.Build.Tasks.ComReferenceWrapperInfo : object {
    internal string path;
    internal Assembly assembly;
    internal AssemblyNameExtension originalPiaName;
}
internal enum Microsoft.Build.Tasks.ConflictLossReason : Enum {
    public int value__;
    public static ConflictLossReason DidntLose;
    public static ConflictLossReason HadLowerVersion;
    public static ConflictLossReason InsolubleConflict;
    public static ConflictLossReason WasNotPrimary;
    public static ConflictLossReason FusionEquivalentWithSameVersion;
}
public class Microsoft.Build.Tasks.ConvertToAbsolutePath : TaskExtension {
    private ITaskItem[] _paths;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AbsolutePaths>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Paths { get; public set; }
    [OutputAttribute]
public ITaskItem[] AbsolutePaths { get; public set; }
    public ITaskItem[] get_Paths();
    public void set_Paths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AbsolutePaths();
    [CompilerGeneratedAttribute]
public void set_AbsolutePaths(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Copy : TaskExtension {
    internal static string AlwaysRetryEnvVar;
    internal static string AlwaysOverwriteReadOnlyFilesEnvVar;
    private static int DefaultCopyParallelism;
    private static string CreatesDirectory;
    private static string DidNotCopyBecauseOfFileMatch;
    private static string FileComment;
    private static string HardLinkComment;
    private static string RetryingAsFileCopy;
    private static string RetryingAsSymbolicLink;
    private static string RemovingReadOnlyAttribute;
    private static string SymbolicLinkComment;
    private CancellationTokenSource _cancellationTokenSource;
    private ConcurrentDictionary`2<string, bool> _directoriesKnownToExist;
    private static bool s_alwaysRetryCopy;
    private static bool s_forceSymlinks;
    private static int s_parallelism;
    private static int RetryDelayMillisecondsDefault;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseHardlinksIfPossible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseSymboliclinksIfPossible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorIfLinkFails>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnchangedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DestinationFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CopiedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WroteAtLeastOneFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverwriteReadOnlyFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public int Retries { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public bool UseHardlinksIfPossible { get; public set; }
    public bool UseSymboliclinksIfPossible { get; public set; }
    public bool ErrorIfLinkFails { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] CopiedFiles { get; private set; }
    [OutputAttribute]
public bool WroteAtLeastOneFile { get; private set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    private static Copy();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public int get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public bool get_UseHardlinksIfPossible();
    [CompilerGeneratedAttribute]
public void set_UseHardlinksIfPossible(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseSymboliclinksIfPossible();
    [CompilerGeneratedAttribute]
public void set_UseSymboliclinksIfPossible(bool value);
    [CompilerGeneratedAttribute]
public bool get_ErrorIfLinkFails();
    [CompilerGeneratedAttribute]
public void set_ErrorIfLinkFails(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnchangedFiles();
    [CompilerGeneratedAttribute]
public void set_SkipUnchangedFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DestinationFiles();
    [CompilerGeneratedAttribute]
public void set_DestinationFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CopiedFiles();
    [CompilerGeneratedAttribute]
private void set_CopiedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_WroteAtLeastOneFile();
    [CompilerGeneratedAttribute]
private void set_WroteAtLeastOneFile(bool value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public sealed virtual void Cancel();
    private static bool IsMatchingSizeAndTimeStamp(FileState sourceFile, FileState destinationFile);
    internal static void RefreshInternalEnvironmentValues();
    private void LogAlwaysRetryDiagnosticFromResources(string messageResourceName, Object[] messageArgs);
    private Nullable`1<bool> CopyFileWithLogging(FileState sourceFileState, FileState destinationFileState);
    private void TryCopyViaLink(string linkComment, MessageImportance messageImportance, FileState sourceFileState, FileState destinationFileState, Boolean& linkCreated, String& errorMessage, Func`4<string, string, string, bool> createLink);
    private void MakeFileWriteable(FileState file, bool logActivity);
    internal bool Execute(CopyFileWithState copyFile, int parallelism);
    private bool CopySingleThreaded(CopyFileWithState copyFile, List`1& destinationFilesSuccessfullyCopied);
    private bool CopyParallel(CopyFileWithState copyFile, int parallelism, List`1& destinationFilesSuccessfullyCopied);
    private bool ValidateInputs();
    private bool InitializeDestinationFiles();
    private bool DoCopyIfNecessary(FileState sourceFileState, FileState destinationFileState, CopyFileWithState copyFile);
    private bool DoCopyWithRetries(FileState sourceFileState, FileState destinationFileState, CopyFileWithState copyFile);
    private static string GetLockedFileMessage(string file);
    public virtual bool Execute();
    private static bool PathsAreIdentical(FileState source, FileState destination);
    private static int GetParallelismFromEnvironment();
}
internal class Microsoft.Build.Tasks.CopyFile : MulticastDelegate {
    public CopyFile(object object, IntPtr method);
    public virtual bool Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.CopyFileWithState : MulticastDelegate {
    public CopyFileWithState(object object, IntPtr method);
    public virtual Nullable`1<bool> Invoke(FileState source, FileState destination);
    public virtual IAsyncResult BeginInvoke(FileState source, FileState destination, AsyncCallback callback, object object);
    public virtual Nullable`1<bool> EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Tasks.CopyLocalState : Enum {
    public int value__;
    public static CopyLocalState Undecided;
    public static CopyLocalState YesBecauseOfHeuristic;
    public static CopyLocalState YesBecauseReferenceItemHadMetadata;
    public static CopyLocalState NoBecauseFrameworkFile;
    public static CopyLocalState NoBecausePrerequisite;
    public static CopyLocalState NoBecauseReferenceItemHadMetadata;
    public static CopyLocalState NoBecauseReferenceResolvedFromGAC;
    public static CopyLocalState NoBecauseReferenceFoundInGAC;
    public static CopyLocalState NoBecauseConflictVictim;
    public static CopyLocalState NoBecauseUnresolved;
    public static CopyLocalState NoBecauseEmbedded;
    public static CopyLocalState NoBecauseParentReferencesFoundInGAC;
    public static CopyLocalState NoBecauseBadImage;
}
internal static class Microsoft.Build.Tasks.CopyLocalStateUtility : object {
    internal static bool IsCopyLocal(CopyLocalState state);
}
internal enum Microsoft.Build.Tasks.CorAssemblyFlags : Enum {
    public UInt32 value__;
    public static CorAssemblyFlags afPublicKey;
    public static CorAssemblyFlags afRetargetable;
}
[GuidAttribute("E5CB7A31-7512-11d2-89CE-0080C792E5D8")]
[TypeLibTypeAttribute("2")]
[ClassInterfaceAttribute("0")]
internal class Microsoft.Build.Tasks.CorMetaDataDispenser : object {
}
internal enum Microsoft.Build.Tasks.CorOpenFlags : Enum {
    public int value__;
    public static CorOpenFlags ofRead;
    public static CorOpenFlags ofWrite;
    public static CorOpenFlags ofCopyMemory;
    public static CorOpenFlags ofCacheImage;
    public static CorOpenFlags ofNoTypeLib;
}
internal enum Microsoft.Build.Tasks.CreateAssemblyNameObjectFlags : Enum {
    public int value__;
    public static CreateAssemblyNameObjectFlags CANOF_DEFAULT;
    public static CreateAssemblyNameObjectFlags CANOF_PARSE_DISPLAY_NAME;
}
public class Microsoft.Build.Tasks.CreateCSharpManifestResourceName : CreateManifestResourceName {
    protected string SourceFileExtension { get; }
    protected virtual string get_SourceFileExtension();
    protected virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, Stream binaryStream);
    internal static string CreateManifestNameImpl(string fileName, string linkFileName, bool prependCultureAsDirectory, string rootNamespace, string dependentUponFileName, string culture, Stream binaryStream, TaskLoggingHelper log, bool treatAsCultureNeutral);
    protected virtual bool IsSourceFile(string fileName);
}
internal class Microsoft.Build.Tasks.CreateFileStream : MulticastDelegate {
    public CreateFileStream(object object, IntPtr method);
    public virtual Stream Invoke(string path, FileMode mode, FileAccess access);
    public virtual IAsyncResult BeginInvoke(string path, FileMode mode, FileAccess access, AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.CreateItem : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveExistingMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionalMetadata>k__BackingField;
    [OutputAttribute]
public ITaskItem[] Include { get; public set; }
    public ITaskItem[] Exclude { get; public set; }
    public bool PreserveExistingMetadata { get; public set; }
    public String[] AdditionalMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_PreserveExistingMetadata();
    [CompilerGeneratedAttribute]
public void set_PreserveExistingMetadata(bool value);
    [CompilerGeneratedAttribute]
public String[] get_AdditionalMetadata();
    [CompilerGeneratedAttribute]
public void set_AdditionalMetadata(String[] value);
    public virtual bool Execute();
    private List`1<ITaskItem> CreateOutputItems(Dictionary`2<string, string> metadataTable, Dictionary`2<string, string> excludeItems);
    private ValueTuple`2<ITaskItem[], bool> TryExpandingWildcards(ITaskItem[] expand, string attributeType);
    private static ValueTuple`3<ITaskItem[], SearchAction, string> ExpandWildcards(ITaskItem[] expand);
    private static Dictionary`2<string, string> GetUniqueItems(ITaskItem[] items);
}
public abstract class Microsoft.Build.Tasks.CreateManifestResourceName : TaskExtension {
    internal static string resxFileExtension;
    internal static string restextFileExtension;
    internal static string resourcesFileExtension;
    private ITaskItem[] _resourceFiles;
    protected Dictionary`2<string, ITaskItem> itemSpecToTaskitem;
    [CompilerGeneratedAttribute]
private bool <PrependCultureAsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDependentUponConvention>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ManifestResourceNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResourceFilesWithManifestResourceNames>k__BackingField;
    public bool PrependCultureAsDirectory { get; public set; }
    public bool UseDependentUponConvention { get; public set; }
    protected string SourceFileExtension { get; }
    [RequiredAttribute]
public ITaskItem[] ResourceFiles { get; public set; }
    public string RootNamespace { get; public set; }
    [OutputAttribute]
public ITaskItem[] ManifestResourceNames { get; private set; }
    [OutputAttribute]
public ITaskItem[] ResourceFilesWithManifestResourceNames { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PrependCultureAsDirectory();
    [CompilerGeneratedAttribute]
public void set_PrependCultureAsDirectory(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseDependentUponConvention();
    [CompilerGeneratedAttribute]
public void set_UseDependentUponConvention(bool value);
    protected abstract virtual string get_SourceFileExtension();
    public ITaskItem[] get_ResourceFiles();
    public void set_ResourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ManifestResourceNames();
    [CompilerGeneratedAttribute]
private void set_ManifestResourceNames(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ResourceFilesWithManifestResourceNames();
    [CompilerGeneratedAttribute]
public void set_ResourceFilesWithManifestResourceNames(ITaskItem[] value);
    protected abstract virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespaceName, string dependentUponFileName, Stream binaryStream);
    protected abstract virtual bool IsSourceFile(string fileName);
    private static Stream CreateFileStreamOverNewFileStream(string path, FileMode mode, FileAccess access);
    internal bool Execute(CreateFileStream createFileStream);
    public virtual bool Execute();
    private static bool IsValidEverettIdFirstChar(char c);
    private static bool IsValidEverettIdChar(char c);
    private static void MakeValidEverettSubFolderIdentifier(StringBuilder builder, string subName);
    internal static void MakeValidEverettFolderIdentifier(StringBuilder builder, string name);
    public static string MakeValidEverettIdentifier(string name);
}
public class Microsoft.Build.Tasks.CreateProperty : TaskExtension {
    [CompilerGeneratedAttribute]
private String[] <Value>k__BackingField;
    [OutputAttribute]
public String[] Value { get; public set; }
    [OutputAttribute]
public String[] ValueSetByTask { get; }
    [CompilerGeneratedAttribute]
public String[] get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(String[] value);
    public String[] get_ValueSetByTask();
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.CreateVisualBasicManifestResourceName : CreateManifestResourceName {
    protected string SourceFileExtension { get; }
    protected virtual string get_SourceFileExtension();
    protected virtual string CreateManifestName(string fileName, string linkFileName, string rootNamespace, string dependentUponFileName, Stream binaryStream);
    internal static string CreateManifestNameImpl(string fileName, string linkFileName, bool prependCultureAsDirectory, string rootNamespace, string dependentUponFileName, string culture, Stream binaryStream, TaskLoggingHelper log, bool treatAsCultureNeutral);
    protected virtual bool IsSourceFile(string fileName);
}
internal static class Microsoft.Build.Tasks.CSharpParserUtilities : object {
    internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream);
    private static ExtractedClassName Extract(CSharpTokenizer tokens);
}
internal static class Microsoft.Build.Tasks.Culture : object {
    internal static ItemCultureInfo GetItemCultureInfo(string name, string dependentUponFilename, bool treatAsCultureNeutral);
}
internal static class Microsoft.Build.Tasks.CultureInfoCache : object {
    private static Lazy`1<HashSet`1<string>> ValidCultureNames;
    private static String[] pseudoLocales;
    private static CultureInfoCache();
    private static HashSet`1<string> InitializeValidCultureNames();
    internal static bool IsValidCultureString(string name);
}
public class Microsoft.Build.Tasks.Delete : TaskExtension {
    private ITaskItem[] _files;
    private bool _canceling;
    [CompilerGeneratedAttribute]
private bool <TreatErrorsAsWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DeletedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public bool TreatErrorsAsWarnings { get; public set; }
    [OutputAttribute]
public ITaskItem[] DeletedFiles { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public int Retries { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_TreatErrorsAsWarnings();
    [CompilerGeneratedAttribute]
public void set_TreatErrorsAsWarnings(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DeletedFiles();
    [CompilerGeneratedAttribute]
public void set_DeletedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public int get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    private bool ValidateInputs();
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private void LogError(ITaskItem file, Exception e);
}
internal class Microsoft.Build.Tasks.DependencyFile : object {
    internal string filename;
    internal DateTime lastModified;
    internal bool exists;
    internal string FileName { get; }
    internal DateTime LastModified { get; }
    internal bool Exists { get; }
    internal DependencyFile(string filename);
    internal string get_FileName();
    internal DateTime get_LastModified();
    internal bool get_Exists();
    internal bool HasFileChanged();
}
internal class Microsoft.Build.Tasks.DependencyResolutionException : Exception {
    internal DependencyResolutionException(string message, Exception innerException);
    private DependencyResolutionException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.DependentAssembly : object {
    [CompilerGeneratedAttribute]
private AssemblyName <AssemblyNameReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<BindingRedirect> <BindingRedirects>k__BackingField;
    internal AssemblyName PartialAssemblyName { get; internal set; }
    internal AssemblyName AssemblyNameReadOnly { get; private set; }
    internal List`1<BindingRedirect> BindingRedirects { get; internal set; }
    internal void set_PartialAssemblyName(AssemblyName value);
    internal AssemblyName get_PartialAssemblyName();
    [CompilerGeneratedAttribute]
internal AssemblyName get_AssemblyNameReadOnly();
    [CompilerGeneratedAttribute]
private void set_AssemblyNameReadOnly(AssemblyName value);
    internal void Read(XmlReader reader);
    [CompilerGeneratedAttribute]
internal void set_BindingRedirects(List`1<BindingRedirect> value);
    [CompilerGeneratedAttribute]
internal List`1<BindingRedirect> get_BindingRedirects();
}
[ComVisibleAttribute("True")]
[GuidAttribute("1D9FE38A-0226-4b95-9C6B-6DFFA2236270")]
[ClassInterfaceAttribute("0")]
[SupportedOSPlatform("windows")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BootstrapperBuilder : object {
    private static bool s_logging;
    private static string s_logPath;
    private string _path;
    private XmlDocument _document;
    private XmlNamespaceManager _xmlNamespaceManager;
    private ProductCollection _products;
    private Dictionary`2<string, XmlNode> _cultures;
    private Dictionary`2<string, ProductValidationResults> _validationResults;
    private BuildResults _results;
    private BuildResults _loopDependenciesWarnings;
    private bool _fInitialized;
    private static string SETUP_EXE;
    private static string SETUP_BIN;
    private static string SETUP_RESOURCES_FILE;
    private static string ENGINE_PATH;
    private static string SCHEMA_PATH;
    private static string PACKAGE_PATH;
    private static string RESOURCES_PATH;
    private static string BOOTSTRAPPER_NAMESPACE;
    private static string BOOTSTRAPPER_PREFIX;
    private static string ROOT_MANIFEST_FILE;
    private static string CHILD_MANIFEST_FILE;
    private static string MANIFEST_FILE_SCHEMA;
    private static string CONFIG_TRANSFORM;
    private static string EULA_ATTRIBUTE;
    private static string HOMESITE_ATTRIBUTE;
    private static string PUBLICKEY_ATTRIBUTE;
    private static string URLNAME_ATTRIBUTE;
    private static string HASH_ATTRIBUTE;
    private static int MESSAGE_TABLE;
    private static int RESOURCE_TABLE;
    [CompilerGeneratedAttribute]
private bool <Validate>k__BackingField;
    public string Path { get; public set; }
    public ProductCollection Products { get; }
    internal String[] Cultures { get; }
    internal bool Validate { get; internal set; }
    private string BootstrapperPath { get; }
    private string PackagePath { get; }
    private string SchemaPath { get; }
    public BootstrapperBuilder(string visualStudioVersion);
    private static BootstrapperBuilder();
    public sealed virtual string get_Path();
    public sealed virtual void set_Path(string value);
    public sealed virtual ProductCollection get_Products();
    public sealed virtual BuildResults Build(BuildSettings settings);
    private static void Merge(Dictionary`2<string, Product> output, Dictionary`2<string, Product> input);
    private static void AddProduct(Dictionary`2<string, Product> output, Product product);
    private void AddBuiltProducts(BuildSettings settings);
    private bool CopySetupToOutputDirectory(BuildSettings settings, string strOutputExe);
    private void AddStringResourceForUrl(ResourceUpdater resourceUpdater, string name, string url, string nameToUseInLog);
    public String[] GetOutputFolders(String[] productCodes, string culture, string fallbackCulture, ComponentsLocation componentsLocation);
    internal bool ContainsCulture(string culture);
    internal String[] get_Cultures();
    [CompilerGeneratedAttribute]
internal bool get_Validate();
    [CompilerGeneratedAttribute]
internal void set_Validate(bool value);
    private string get_BootstrapperPath();
    private string get_PackagePath();
    private string get_SchemaPath();
    private void Refresh();
    private void RefreshResources();
    private void RefreshProducts();
    private void AddDependencies(Product p, Dictionary`2<string, Product> availableProducts);
    private void AddIncludes(Product p, Dictionary`2<string, Product> availableProducts);
    private String[] SelectRelatedProducts(Product p, string nodeName);
    private XmlNodeList SelectEitherProducts(Product p);
    private void OrderProducts(Dictionary`2<string, Product> availableProducts, Dictionary`2<string, Product> buildQueue);
    private static void RemoveDependency(Dictionary`2<string, Product> availableProducts, Product product);
    private XmlDocument LoadAndValidateXmlDocument(string filePath, bool validateFilePresent, string schemaPath, string schemaNamespace, XmlValidationResults results);
    private void ExploreDirectory(string strSubDirectory, XmlElement rootElement, string packagePath);
    private Product CreateProduct(XmlNode node);
    private static Package CreatePackage(XmlNode node, Product product);
    private void ReplaceAttributes(XmlNode targetNode, string attributeName, string oldValue, string newValue);
    private static void ReplaceAttribute(XmlNode targetNode, string attributeName, string attributeValue);
    private static void MergeAttribute(XmlNode targetNode, XmlAttribute attribute);
    private void UpdatePackageFileNodes(XmlNode packageFilesNode, string strSourcePath, string strTargetPath);
    private void AppendNode(XmlElement element, string nodeName, XmlElement mergeElement);
    private void CombineElements(XmlElement langElement, XmlElement baseElement, string strNodeName, string strSubNodeKey, XmlElement mergeElement);
    private XmlNode QueryForSubNode(XmlNode subNode, string strSubNodeKey, string strTargetValue);
    private void CorrectPackageFiles(XmlNode node);
    private void ReplaceStrings(XmlNode node);
    private bool BuildPackages(BuildSettings settings, XmlElement configElement, ResourceUpdater resourceUpdater, List`1<string> filesCopied, Dictionary`2<string, KeyValuePair`2<string, string>> eulas);
    private XmlNode CreateProductNode(XmlNode node);
    private static string ReadAttribute(XmlNode node, string strAttributeName);
    private static void EnsureFolderExists(string strFolderPath);
    private static void ClearReadOnlyAttribute(string strFileName);
    private static string ByteArrayToString(Byte[] byteArray);
    private static string GetFileHash(string filePath);
    private void ReplaceAttributeString(XmlNode node, string attributeName, XmlNode stringsNode);
    private Package GetPackageForSettings(BuildSettings settings, ProductBuilder builder, BuildResults results);
    private static Package GetPackageForSettings_Helper(CultureInfo culture, CultureInfo altCulture, ProductBuilder builder, BuildResults results, bool fShowWarning);
    private bool BuildResources(BuildSettings settings, ResourceUpdater resourceUpdater);
    private XmlNode GetResourcesNodeForSettings(BuildSettings settings, BuildResults results, Int32& codepage);
    private XmlNode GetResourcesNodeForSettings_Helper(CultureInfo culture, CultureInfo altCulture, BuildResults results, Int32& codepage, bool fShowWarning);
    private static void GetCodePage(string culture, Int32& codePage);
    private void ReplacePackageFileAttributes(XmlNode targetNodes, string targetAttribute, XmlNode sourceNodes, string sourceSubNodeName, string sourceOldName, string sourceNewName);
    private static XmlElement CreateApplicationElement(XmlElement configElement, BuildSettings settings);
    private static void AddAttribute(XmlNode node, string attributeName, string attributeValue);
    public static string XmlToConfigurationFile(XmlNode input);
    private static Stream GetEmbeddedResourceStream(string name);
    private static void DumpXmlToFile(XmlNode node, string fileName);
    private static void DumpStringToFile(string text, string fileName, bool append);
    private static bool VerifyHomeSiteInformation(XmlNode packageFileNode, ProductBuilder builder, BuildSettings settings, BuildResults results);
    private bool AddVerificationInformation(XmlNode packageFileNode, string fileSource, string fileName, ProductBuilder builder, BuildSettings settings, BuildResults results);
    private static string GetPublicKeyOfFile(string fileSource);
    private static void ConvertChildsNodeToAttributes(XmlNode node);
    private static string GetLogPath();
    private static Dictionary`2<string, Product> GetIncludedProducts(Product product);
    private static void AddIncludedProducts(Product product, Dictionary`2<string, Product> includedProducts);
    private static string MapLCIDToCultureName(int lcid);
}
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessage : object {
    private static Regex s_msbuildMessageCodePattern;
    [CompilerGeneratedAttribute]
private BuildMessageSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HelpId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpCode>k__BackingField;
    public BuildMessageSeverity Severity { get; }
    public string Message { get; }
    public string HelpKeyword { get; }
    public int HelpId { get; }
    internal string HelpCode { get; }
    private BuildMessage(BuildMessageSeverity severity, string message, string helpKeyword, string helpCode);
    private static BuildMessage();
    internal static BuildMessage CreateMessage(BuildMessageSeverity severity, string resourceName, Object[] args);
    [CompilerGeneratedAttribute]
public sealed virtual BuildMessageSeverity get_Severity();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public sealed virtual int get_HelpId();
    [CompilerGeneratedAttribute]
internal string get_HelpCode();
}
[ComVisibleAttribute("True")]
[GuidAttribute("936D32F9-1A68-4d5e-98EA-044AC9A1AADA")]
public enum Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildMessageSeverity : Enum {
    public int value__;
    public static BuildMessageSeverity Info;
    public static BuildMessageSeverity Warning;
    public static BuildMessageSeverity Error;
}
[ComVisibleAttribute("True")]
[GuidAttribute("FAD7BA7C-CA00-41e0-A5EF-2DA9A74E58E6")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildResults : object {
    private List`1<string> _componentFiles;
    private List`1<BuildMessage> _messages;
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public bool Succeeded { get; private set; }
    public string KeyFile { get; private set; }
    public String[] ComponentFiles { get; }
    public BuildMessage[] Messages { get; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Succeeded();
    [CompilerGeneratedAttribute]
private void set_Succeeded(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyFile();
    [CompilerGeneratedAttribute]
private void set_KeyFile(string value);
    public sealed virtual String[] get_ComponentFiles();
    public sealed virtual BuildMessage[] get_Messages();
    internal void AddMessage(BuildMessage message);
    internal void AddComponentFiles(String[] filePaths);
    internal void BuildSucceeded();
    internal void SetKeyFile(string filePath);
}
[ComVisibleAttribute("True")]
[GuidAttribute("5D13802C-C830-4b41-8E7A-F69D9DD6A095")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.BuildSettings : object {
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplicationRequiresElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private ComponentsLocation <ComponentsLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComponentsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LCID>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FallbackLCID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ProductBuilderCollection <ProductBuilders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Validate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FallbackCulture>k__BackingField;
    public string ApplicationName { get; public set; }
    public string ApplicationFile { get; public set; }
    public bool ApplicationRequiresElevation { get; public set; }
    public string ApplicationUrl { get; public set; }
    public ComponentsLocation ComponentsLocation { get; public set; }
    public string ComponentsUrl { get; public set; }
    public bool CopyComponents { get; public set; }
    public int LCID { get; public set; }
    public int FallbackLCID { get; public set; }
    public string OutputPath { get; public set; }
    public ProductBuilderCollection ProductBuilders { get; }
    public string SupportUrl { get; public set; }
    public bool Validate { get; public set; }
    internal string Culture { get; internal set; }
    internal string FallbackCulture { get; internal set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ApplicationName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ApplicationFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplicationFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ApplicationRequiresElevation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplicationRequiresElevation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ApplicationUrl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ApplicationUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ComponentsLocation get_ComponentsLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ComponentsLocation(ComponentsLocation value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ComponentsUrl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ComponentsUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CopyComponents();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CopyComponents(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_LCID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_LCID(int value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_FallbackLCID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FallbackLCID(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ProductBuilderCollection get_ProductBuilders();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SupportUrl();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SupportUrl(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Validate();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Validate(bool value);
    [CompilerGeneratedAttribute]
internal string get_Culture();
    [CompilerGeneratedAttribute]
internal void set_Culture(string value);
    [CompilerGeneratedAttribute]
internal string get_FallbackCulture();
    [CompilerGeneratedAttribute]
internal void set_FallbackCulture(string value);
}
[ComVisibleAttribute("True")]
[GuidAttribute("12F49949-7B60-49CD-B6A0-2B5E4A638AAF")]
public enum Microsoft.Build.Tasks.Deployment.Bootstrapper.ComponentsLocation : Enum {
    public int value__;
    public static ComponentsLocation HomeSite;
    public static ComponentsLocation Relative;
    public static ComponentsLocation Absolute;
}
internal enum Microsoft.Build.Tasks.Deployment.Bootstrapper.CopyAllFilesType : Enum {
    public int value__;
    public static CopyAllFilesType CopyAllFilesFalse;
    public static CopyAllFilesType CopyAllFilesTrue;
    public static CopyAllFilesType CopyAllFilesIfNotHomeSite;
}
[ComVisibleAttribute("True")]
[GuidAttribute("1D202366-5EEA-4379-9255-6F8CDB8587C9")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBootstrapperBuilder {
    [DispIdAttribute("1")]
public string Path { get; public set; }
    [DispIdAttribute("4")]
public ProductCollection Products { get; }
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual ProductCollection get_Products();
    [DispIdAttribute("5")]
public abstract virtual BuildResults Build(BuildSettings settings);
}
[ComVisibleAttribute("True")]
[GuidAttribute("E3C981EA-99E6-4f48-8955-1AAFDFB5ACE4")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildMessage {
    [DispIdAttribute("1")]
public BuildMessageSeverity Severity { get; }
    [DispIdAttribute("2")]
public string Message { get; }
    [DispIdAttribute("3")]
public string HelpKeyword { get; }
    [DispIdAttribute("4")]
public int HelpId { get; }
    public abstract virtual BuildMessageSeverity get_Severity();
    public abstract virtual string get_Message();
    public abstract virtual string get_HelpKeyword();
    public abstract virtual int get_HelpId();
}
[ComVisibleAttribute("True")]
[GuidAttribute("586B842C-D9C7-43b8-84E4-9CFC3AF9F13B")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildResults {
    [DispIdAttribute("1")]
public bool Succeeded { get; }
    [DispIdAttribute("2")]
public string KeyFile { get; }
    [DispIdAttribute("3")]
public String[] ComponentFiles { get; }
    [DispIdAttribute("4")]
public BuildMessage[] Messages { get; }
    public abstract virtual bool get_Succeeded();
    public abstract virtual string get_KeyFile();
    public abstract virtual String[] get_ComponentFiles();
    public abstract virtual BuildMessage[] get_Messages();
}
[ComVisibleAttribute("True")]
[GuidAttribute("87EEBC69-0948-4ce6-A2DE-819162B87CC6")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IBuildSettings {
    [DispIdAttribute("1")]
public string ApplicationName { get; public set; }
    [DispIdAttribute("2")]
public string ApplicationFile { get; public set; }
    [DispIdAttribute("3")]
public string ApplicationUrl { get; public set; }
    [DispIdAttribute("4")]
public string ComponentsUrl { get; public set; }
    [DispIdAttribute("5")]
public bool CopyComponents { get; public set; }
    [DispIdAttribute("6")]
public int LCID { get; public set; }
    [DispIdAttribute("7")]
public int FallbackLCID { get; public set; }
    [DispIdAttribute("8")]
public string OutputPath { get; public set; }
    [DispIdAttribute("9")]
public ProductBuilderCollection ProductBuilders { get; }
    [DispIdAttribute("10")]
public bool Validate { get; public set; }
    [DispIdAttribute("11")]
public ComponentsLocation ComponentsLocation { get; public set; }
    [DispIdAttribute("12")]
public string SupportUrl { get; public set; }
    [DispIdAttribute("13")]
public bool ApplicationRequiresElevation { get; public set; }
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
    public abstract virtual string get_ApplicationFile();
    public abstract virtual void set_ApplicationFile(string value);
    public abstract virtual string get_ApplicationUrl();
    public abstract virtual void set_ApplicationUrl(string value);
    public abstract virtual string get_ComponentsUrl();
    public abstract virtual void set_ComponentsUrl(string value);
    public abstract virtual bool get_CopyComponents();
    public abstract virtual void set_CopyComponents(bool value);
    public abstract virtual int get_LCID();
    public abstract virtual void set_LCID(int value);
    public abstract virtual int get_FallbackLCID();
    public abstract virtual void set_FallbackLCID(int value);
    public abstract virtual string get_OutputPath();
    public abstract virtual void set_OutputPath(string value);
    public abstract virtual ProductBuilderCollection get_ProductBuilders();
    public abstract virtual bool get_Validate();
    public abstract virtual void set_Validate(bool value);
    public abstract virtual ComponentsLocation get_ComponentsLocation();
    public abstract virtual void set_ComponentsLocation(ComponentsLocation value);
    public abstract virtual string get_SupportUrl();
    public abstract virtual void set_SupportUrl(string value);
    public abstract virtual bool get_ApplicationRequiresElevation();
    public abstract virtual void set_ApplicationRequiresElevation(bool value);
}
[ComVisibleAttribute("True")]
[GuidAttribute("9E81BE3D-530F-4a10-8349-5D5947BA59AD")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProduct {
    [DispIdAttribute("1")]
public ProductBuilder ProductBuilder { get; }
    [DispIdAttribute("2")]
public string Name { get; }
    [DispIdAttribute("3")]
public string ProductCode { get; }
    [DispIdAttribute("4")]
public ProductCollection Includes { get; }
    public abstract virtual ProductBuilder get_ProductBuilder();
    public abstract virtual string get_Name();
    public abstract virtual string get_ProductCode();
    public abstract virtual ProductCollection get_Includes();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0777432F-A60D-48b3-83DB-90326FE8C96E")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilder {
    [DispIdAttribute("1")]
public Product Product { get; }
    public abstract virtual Product get_Product();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0D593FC0-E3F1-4dad-A674-7EA4D327F79B")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductBuilderCollection {
    [DispIdAttribute("2")]
public abstract virtual void Add(ProductBuilder builder);
}
[ComVisibleAttribute("True")]
[GuidAttribute("63F63663-8503-4875-814C-09168E595367")]
[InterfaceTypeAttribute("0")]
public interface Microsoft.Build.Tasks.Deployment.Bootstrapper.IProductCollection {
    [DispIdAttribute("1")]
public int Count { get; }
    public abstract virtual int get_Count();
    [DispIdAttribute("2")]
public abstract virtual Product Item(int index);
    [DispIdAttribute("3")]
public abstract virtual Product Product(string productCode);
}
internal static class Microsoft.Build.Tasks.Deployment.Bootstrapper.NativeMethods : object {
    internal static IntPtr BeginUpdateResourceW(string fileName, bool deleteExistingResource);
    internal static bool UpdateResourceW(IntPtr hUpdate, IntPtr lpType, string lpName, short wLanguage, Byte[] data, int cbData);
    internal static bool EndUpdateResource(IntPtr hUpdate, bool fDiscard);
}
[ComVisibleAttribute("False")]
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.Package : object {
    [CompilerGeneratedAttribute]
private XmlNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private Product <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlValidationResults <ValidationResults>k__BackingField;
    internal XmlNode Node { get; }
    public string Name { get; }
    public string Culture { get; }
    public Product Product { get; }
    internal bool ValidationPassed { get; }
    internal XmlValidationResults ValidationResults { get; }
    public Package(Product product, XmlNode node, XmlValidationResults validationResults, string name, string culture);
    [CompilerGeneratedAttribute]
internal XmlNode get_Node();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public Product get_Product();
    internal bool get_ValidationPassed();
    [CompilerGeneratedAttribute]
internal XmlValidationResults get_ValidationResults();
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.PackageCollection : object {
    private List`1<Package> _list;
    private Dictionary`2<string, Package> _cultures;
    public int Count { get; }
    public Package Item(int index);
    public Package Package(string culture);
    public int get_Count();
    internal void Add(Package package);
    public sealed virtual IEnumerator GetEnumerator();
}
[ComVisibleAttribute("True")]
[GuidAttribute("532BF563-A85D-4088-8048-41F51AC5239F")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.Product : object {
    private Dictionary`2<string, Package> _cultures;
    [CompilerGeneratedAttribute]
private XmlNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyAllFilesType <CopyAllPackageFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductCode>k__BackingField;
    [CompilerGeneratedAttribute]
private ProductCollection <Includes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<List`1<Product>> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<List`1<string>> <MissingDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageCollection <Packages>k__BackingField;
    [CompilerGeneratedAttribute]
private ProductValidationResults <ValidationResults>k__BackingField;
    internal XmlNode Node { get; }
    internal CopyAllFilesType CopyAllPackageFiles { get; }
    public ProductBuilder ProductBuilder { get; }
    public string ProductCode { get; }
    public string Name { get; }
    public ProductCollection Includes { get; }
    internal List`1<List`1<Product>> Dependencies { get; }
    internal List`1<List`1<string>> MissingDependencies { get; }
    internal PackageCollection Packages { get; }
    internal bool ValidationPassed { get; }
    internal ProductValidationResults ValidationResults { get; }
    internal Product(XmlNode node, string code, ProductValidationResults validationResults, string copyAll);
    [CompilerGeneratedAttribute]
internal XmlNode get_Node();
    [CompilerGeneratedAttribute]
internal CopyAllFilesType get_CopyAllPackageFiles();
    public sealed virtual ProductBuilder get_ProductBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProductCode();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual ProductCollection get_Includes();
    [CompilerGeneratedAttribute]
internal List`1<List`1<Product>> get_Dependencies();
    internal bool ContainsCulture(string culture);
    internal bool ContainsDependencies(List`1<Product> dependenciesToCheck);
    [CompilerGeneratedAttribute]
internal List`1<List`1<string>> get_MissingDependencies();
    internal void AddPackage(Package package);
    internal void AddIncludedProduct(Product product);
    internal void AddDependentProduct(Product product);
    internal void AddMissingDependency(List`1<string> productCodes);
    [CompilerGeneratedAttribute]
internal PackageCollection get_Packages();
    internal XmlValidationResults GetPackageValidationResults(string culture);
    internal bool get_ValidationPassed();
    [CompilerGeneratedAttribute]
internal ProductValidationResults get_ValidationResults();
}
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilder : object {
    [CompilerGeneratedAttribute]
private Product <Product>k__BackingField;
    public Product Product { get; }
    internal string Name { get; }
    internal string ProductCode { get; }
    internal ProductBuilder(Product product);
    [CompilerGeneratedAttribute]
public sealed virtual Product get_Product();
    internal string get_Name();
    internal string get_ProductCode();
}
[ComVisibleAttribute("True")]
[GuidAttribute("D25C0741-99CA-49f7-9460-95E5F25EEF43")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductBuilderCollection : object {
    private List`1<ProductBuilder> _list;
    internal int Count { get; }
    public sealed virtual void Add(ProductBuilder builder);
    public sealed virtual IEnumerator GetEnumerator();
    internal int get_Count();
    internal ProductBuilder Item(int index);
    internal void Insert(int index, ProductBuilder builder);
}
[ComVisibleAttribute("True")]
[GuidAttribute("EFFA164B-3E87-4195-88DB-8AC004DDFE2A")]
[ClassInterfaceAttribute("0")]
public class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductCollection : object {
    private List`1<Product> _list;
    private Dictionary`2<string, Product> _table;
    public int Count { get; }
    internal void Add(Product product);
    public sealed virtual Product Item(int index);
    public sealed virtual Product Product(string productCode);
    public sealed virtual int get_Count();
    internal void Clear();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.ProductValidationResults : XmlValidationResults {
    private Dictionary`2<string, XmlValidationResults> _packageValidationResults;
    public ProductValidationResults(string filePath);
    public void AddPackageResults(string culture, XmlValidationResults results);
    public XmlValidationResults PackageResults(string culture);
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.ResourceUpdater : object {
    private static int ERROR_SHARING_VIOLATION;
    private List`1<StringResource> _stringResources;
    private List`1<FileResource> _fileResources;
    public void AddStringResource(int type, string name, string data);
    public void AddFileResource(string filename, string key);
    public bool UpdateResources(string filename, BuildResults results);
    private static Byte[] StringToByteArray(string str);
}
internal static class Microsoft.Build.Tasks.Deployment.Bootstrapper.Util : object {
    private static string BOOTSTRAPPER_REGISTRY_PATH_BASE;
    private static string BOOTSTRAPPER_WOW64_REGISTRY_PATH_BASE;
    private static string BOOTSTRAPPER_REGISTRY_PATH_VERSION_VS2010;
    private static string REGISTRY_DEFAULTPATH;
    private static string BOOTSTRAPPER_REGISTRY_ADDITIONAL_PACKAGE_PATHS_KEYNAME;
    private static string BOOTSTRAPPER_MSBUILD_ADDITIONAL_PACKAGES_PATH;
    private static string s_defaultPath;
    private static List`1<string> s_additionalPackagePaths;
    public static CultureInfo DefaultCultureInfo { get; }
    [SupportedOSPlatform("windows")]
public static string DefaultPath { get; }
    [SupportedOSPlatform("windows")]
public static List`1<string> AdditionalPackagePaths { get; }
    public static string AddTrailingChar(string str, char ch);
    public static bool IsUncPath(string path);
    public static bool IsWebUrl(string path);
    public static CultureInfo GetCultureInfoFromString(string cultureName);
    public static CultureInfo get_DefaultCultureInfo();
    public static string get_DefaultPath();
    [SupportedOSPlatform("windows")]
public static string GetDefaultPath(string visualStudioVersion);
    public static List`1<string> get_AdditionalPackagePaths();
    [SupportedOSPlatform("windows")]
private static string ReadRegistryString(RegistryKey key, string path, string registryValue);
}
internal class Microsoft.Build.Tasks.Deployment.Bootstrapper.XmlValidationResults : object {
    private List`1<string> _validationErrors;
    private List`1<string> _validationWarnings;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; }
    public String[] ValidationErrors { get; }
    public bool ValidationPassed { get; }
    public String[] ValidationWarnings { get; }
    public XmlValidationResults(string filePath);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    public void SchemaValidationEventHandler(object sender, ValidationEventArgs e);
    public String[] get_ValidationErrors();
    public bool get_ValidationPassed();
    public String[] get_ValidationWarnings();
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationIdentity : object {
    private AssemblyIdentity _applicationManifestIdentity;
    private AssemblyIdentity _deployManifestIdentity;
    private string _url;
    public ApplicationIdentity(string url, string deployManifestPath, string applicationManifestPath);
    public ApplicationIdentity(string url, AssemblyIdentity deployManifestIdentity, AssemblyIdentity applicationManifestIdentity);
    public virtual string ToString();
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("ApplicationManifest")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ApplicationManifest : AssemblyManifest {
    private string _configFile;
    private AssemblyIdentity _entryPointIdentity;
    private AssemblyReference _entryPoint;
    private string _entryPointParameters;
    private string _entryPointPath;
    private string _errorReportUrl;
    private string _iconFile;
    private bool _isClickOnceManifest;
    private string _oSMajor;
    private string _oSMinor;
    private string _oSBuild;
    private string _oSRevision;
    private string _oSSupportUrl;
    private string _oSDescription;
    private TrustInfo _trustInfo;
    private int _maxTargetPath;
    private bool _hostInBrowser;
    private bool _useApplicationTrust;
    private string _product;
    private string _publisher;
    private string _suiteName;
    private string _supportUrl;
    private FileAssociation[] _fileAssociations;
    private FileAssociationCollection _fileAssociationList;
    private string _targetFrameworkVersion;
    [XmlIgnoreAttribute]
public string ConfigFile { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReference EntryPoint { get; public set; }
    [XmlIgnoreAttribute]
public string TargetFrameworkVersion { get; public set; }
    [XmlIgnoreAttribute]
public string ErrorReportUrl { get; public set; }
    private bool WinXPRequired { get; }
    [XmlIgnoreAttribute]
public FileAssociationCollection FileAssociations { get; }
    [XmlIgnoreAttribute]
public bool HostInBrowser { get; public set; }
    [XmlIgnoreAttribute]
public string IconFile { get; public set; }
    [XmlIgnoreAttribute]
public bool IsClickOnceManifest { get; public set; }
    [XmlIgnoreAttribute]
public int MaxTargetPath { get; public set; }
    [XmlIgnoreAttribute]
public string OSDescription { get; public set; }
    [XmlIgnoreAttribute]
public string OSSupportUrl { get; public set; }
    [XmlIgnoreAttribute]
public string OSVersion { get; public set; }
    [XmlIgnoreAttribute]
public string Product { get; public set; }
    [XmlIgnoreAttribute]
public string Publisher { get; public set; }
    [XmlIgnoreAttribute]
public string SuiteName { get; public set; }
    [XmlIgnoreAttribute]
public string SupportUrl { get; public set; }
    [XmlIgnoreAttribute]
public TrustInfo TrustInfo { get; public set; }
    [XmlIgnoreAttribute]
public bool UseApplicationTrust { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ConfigFile")]
public string XmlConfigFile { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlElementAttribute("EntryPointIdentity")]
public AssemblyIdentity XmlEntryPointIdentity { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("EntryPointParameters")]
public string XmlEntryPointParameters { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("EntryPointPath")]
public string XmlEntryPointPath { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ErrorReportUrl")]
public string XmlErrorReportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("FileAssociations")]
public FileAssociation[] XmlFileAssociations { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("HostInBrowser")]
public string XmlHostInBrowser { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IconFile")]
public string XmlIconFile { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsClickOnceManifest")]
public string XmlIsClickOnceManifest { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSMajor")]
public string XmlOSMajor { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSMinor")]
public string XmlOSMinor { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSBuild")]
public string XmlOSBuild { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSRevision")]
public string XmlOSRevision { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSSupportUrl")]
public string XmlOSSupportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("OSDescription")]
public string XmlOSDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Product")]
public string XmlProduct { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Publisher")]
public string XmlPublisher { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SuiteName")]
public string XmlSuiteName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SupportUrl")]
public string XmlSupportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UseApplicationTrust")]
public string XmlUseApplicationTrust { get; public set; }
    public ApplicationManifest(string targetFrameworkVersion);
    public string get_ConfigFile();
    public void set_ConfigFile(string value);
    public virtual AssemblyReference get_EntryPoint();
    public virtual void set_EntryPoint(AssemblyReference value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    private void FixupClrVersion();
    private void FixupEntryPoint();
    private bool get_WinXPRequired();
    public FileAssociationCollection get_FileAssociations();
    public bool get_HostInBrowser();
    public void set_HostInBrowser(bool value);
    public string get_IconFile();
    public void set_IconFile(string value);
    public bool get_IsClickOnceManifest();
    public void set_IsClickOnceManifest(bool value);
    public int get_MaxTargetPath();
    public void set_MaxTargetPath(int value);
    internal virtual void OnBeforeSave();
    public string get_OSDescription();
    public void set_OSDescription(string value);
    public string get_OSSupportUrl();
    public void set_OSSupportUrl(string value);
    public string get_OSVersion();
    public void set_OSVersion(string value);
    public string get_Product();
    public void set_Product(string value);
    public string get_Publisher();
    public void set_Publisher(string value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public TrustInfo get_TrustInfo();
    public void set_TrustInfo(TrustInfo value);
    public bool get_UseApplicationTrust();
    public void set_UseApplicationTrust(bool value);
    private void UpdateEntryPoint();
    public virtual void Validate();
    private void ValidateCom();
    private void ValidateConfig();
    private void ValidateEntryPoint();
    private void ValidateFileAssociations();
    private void ValidateReferencesForNativeApplication();
    private void ValidateReferencesForClickOnceApplication();
    private void ValidateReferenceForPartialTrust(AssemblyReference assembly, TrustInfo trustInfo);
    public string get_XmlConfigFile();
    public void set_XmlConfigFile(string value);
    public AssemblyIdentity get_XmlEntryPointIdentity();
    public void set_XmlEntryPointIdentity(AssemblyIdentity value);
    public string get_XmlEntryPointParameters();
    public void set_XmlEntryPointParameters(string value);
    public string get_XmlEntryPointPath();
    public void set_XmlEntryPointPath(string value);
    public string get_XmlErrorReportUrl();
    public void set_XmlErrorReportUrl(string value);
    public FileAssociation[] get_XmlFileAssociations();
    public void set_XmlFileAssociations(FileAssociation[] value);
    public string get_XmlHostInBrowser();
    public void set_XmlHostInBrowser(string value);
    public string get_XmlIconFile();
    public void set_XmlIconFile(string value);
    public string get_XmlIsClickOnceManifest();
    public void set_XmlIsClickOnceManifest(string value);
    public string get_XmlOSMajor();
    public void set_XmlOSMajor(string value);
    public string get_XmlOSMinor();
    public void set_XmlOSMinor(string value);
    public string get_XmlOSBuild();
    public void set_XmlOSBuild(string value);
    public string get_XmlOSRevision();
    public void set_XmlOSRevision(string value);
    public string get_XmlOSSupportUrl();
    public void set_XmlOSSupportUrl(string value);
    public string get_XmlOSDescription();
    public void set_XmlOSDescription(string value);
    public string get_XmlProduct();
    public void set_XmlProduct(string value);
    public string get_XmlPublisher();
    public void set_XmlPublisher(string value);
    public string get_XmlSuiteName();
    public void set_XmlSuiteName(string value);
    public string get_XmlSupportUrl();
    public void set_XmlSupportUrl(string value);
    public string get_XmlUseApplicationTrust();
    public void set_XmlUseApplicationTrust(string value);
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("AssemblyIdentity")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyIdentity : object {
    private string _name;
    private string _version;
    private string _publicKeyToken;
    private string _culture;
    private string _processorArchitecture;
    private string _type;
    [XmlIgnoreAttribute]
public bool IsFrameworkAssembly { get; }
    [XmlIgnoreAttribute]
public string Culture { get; public set; }
    [XmlIgnoreAttribute]
public bool IsNeutralPlatform { get; }
    [XmlIgnoreAttribute]
public bool IsStrongName { get; }
    [XmlIgnoreAttribute]
public string Name { get; public set; }
    [XmlIgnoreAttribute]
public string ProcessorArchitecture { get; public set; }
    [XmlIgnoreAttribute]
public string PublicKeyToken { get; public set; }
    [XmlIgnoreAttribute]
public string Type { get; public set; }
    [XmlIgnoreAttribute]
public string Version { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Name")]
public string XmlName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Version")]
public string XmlVersion { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("PublicKeyToken")]
public string XmlPublicKeyToken { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Culture")]
public string XmlCulture { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ProcessorArchitecture")]
public string XmlProcessorArchitecture { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Type")]
public string XmlType { get; public set; }
    public AssemblyIdentity(string name);
    public AssemblyIdentity(string name, string version);
    public AssemblyIdentity(string name, string version, string publicKeyToken, string culture);
    public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture);
    public AssemblyIdentity(string name, string version, string publicKeyToken, string culture, string processorArchitecture, string type);
    public AssemblyIdentity(AssemblyIdentity identity);
    public static AssemblyIdentity FromAssemblyName(string assemblyName);
    public static AssemblyIdentity FromManifest(string path);
    private static AssemblyIdentity FromManifest(Stream s);
    private static AssemblyIdentity FromManifest(XmlDocument document);
    public static AssemblyIdentity FromManagedAssembly(string path);
    public static AssemblyIdentity FromNativeAssembly(string path);
    public static AssemblyIdentity FromFile(string path);
    internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2);
    internal static bool IsEqual(AssemblyIdentity a1, AssemblyIdentity a2, bool specificVersion);
    public bool get_IsFrameworkAssembly();
    public bool IsInFramework(string frameworkIdentifier, string frameworkVersion);
    public string get_Culture();
    public void set_Culture(string value);
    public string GetFullName(FullNameFlags flags);
    public bool get_IsNeutralPlatform();
    public bool get_IsStrongName();
    public string get_Name();
    public void set_Name(string value);
    public string get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(string value);
    public string get_PublicKeyToken();
    public void set_PublicKeyToken(string value);
    internal string Resolve(String[] searchPaths);
    internal string Resolve(String[] searchPaths, bool specificVersion);
    public virtual string ToString();
    public string get_Type();
    public void set_Type(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_XmlName();
    public void set_XmlName(string value);
    public string get_XmlVersion();
    public void set_XmlVersion(string value);
    public string get_XmlPublicKeyToken();
    public void set_XmlPublicKeyToken(string value);
    public string get_XmlCulture();
    public void set_XmlCulture(string value);
    public string get_XmlProcessorArchitecture();
    public void set_XmlProcessorArchitecture(string value);
    public string get_XmlType();
    public void set_XmlType(string value);
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("AssemblyManifest")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyManifest : Manifest {
    private ProxyStub[] _externalProxyStubs;
    [XmlIgnoreAttribute]
public ProxyStub[] ExternalProxyStubs { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("ExternalProxyStubs")]
public ProxyStub[] XmlExternalProxyStubs { get; public set; }
    public ProxyStub[] get_ExternalProxyStubs();
    public ProxyStub[] get_XmlExternalProxyStubs();
    public void set_XmlExternalProxyStubs(ProxyStub[] value);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReference : BaseReference {
    private AssemblyIdentity _assemblyIdentity;
    private bool _isPrerequisite;
    private AssemblyReferenceType _referenceType;
    private bool _isPrimary;
    [XmlIgnoreAttribute]
public AssemblyIdentity AssemblyIdentity { get; public set; }
    [XmlIgnoreAttribute]
public bool IsPrerequisite { get; public set; }
    [XmlIgnoreAttribute]
internal bool IsVirtual { get; }
    [XmlIgnoreAttribute]
public AssemblyReferenceType ReferenceType { get; public set; }
    [XmlIgnoreAttribute]
internal bool IsPrimary { get; internal set; }
    protected internal string SortName { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlElementAttribute("AssemblyIdentity")]
public AssemblyIdentity XmlAssemblyIdentity { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsNative")]
public string XmlIsNative { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsPrerequisite")]
public string XmlIsPrerequisite { get; public set; }
    public AssemblyReference(string path);
    public AssemblyIdentity get_AssemblyIdentity();
    public void set_AssemblyIdentity(AssemblyIdentity value);
    public bool get_IsPrerequisite();
    public void set_IsPrerequisite(bool value);
    internal bool get_IsVirtual();
    public AssemblyReferenceType get_ReferenceType();
    public void set_ReferenceType(AssemblyReferenceType value);
    internal bool get_IsPrimary();
    internal void set_IsPrimary(bool value);
    protected internal virtual string get_SortName();
    public virtual string ToString();
    public AssemblyIdentity get_XmlAssemblyIdentity();
    public void set_XmlAssemblyIdentity(AssemblyIdentity value);
    public string get_XmlIsNative();
    public void set_XmlIsNative(string value);
    public string get_XmlIsPrerequisite();
    public void set_XmlIsPrerequisite(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceCollection : object {
    private List`1<AssemblyReference> _list;
    public AssemblyReference Item { get; }
    public int Count { get; }
    internal AssemblyReferenceCollection(AssemblyReference[] array);
    public AssemblyReference get_Item(int index);
    public AssemblyReference Add(string path);
    public AssemblyReference Add(AssemblyReference assembly);
    public void Clear();
    public int get_Count();
    public AssemblyReference Find(string name);
    public AssemblyReference Find(AssemblyIdentity identity);
    public AssemblyReference FindTargetPath(string targetPath);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(AssemblyReference assemblyReference);
    internal AssemblyReference[] ToArray();
}
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.AssemblyReferenceType : Enum {
    public int value__;
    public static AssemblyReferenceType Unspecified;
    public static AssemblyReferenceType ClickOnceManifest;
    public static AssemblyReferenceType ManagedAssembly;
    public static AssemblyReferenceType NativeAssembly;
}
[ComVisibleAttribute("False")]
public abstract class Microsoft.Build.Tasks.Deployment.ManifestUtilities.BaseReference : object {
    private bool _includeHash;
    private string _group;
    private string _hash;
    private string _hashAlgorithm;
    private string _isOptional;
    private string _resolvedPath;
    private string _size;
    private string _sourcePath;
    private string _targetPath;
    internal bool IncludeHash { get; internal set; }
    [XmlIgnoreAttribute]
public string Group { get; public set; }
    [XmlIgnoreAttribute]
public string Hash { get; public set; }
    [XmlIgnoreAttribute]
public bool IsOptional { get; public set; }
    [XmlIgnoreAttribute]
public string ResolvedPath { get; public set; }
    [XmlIgnoreAttribute]
public long Size { get; public set; }
    protected internal string SortName { get; }
    [XmlIgnoreAttribute]
public string SourcePath { get; public set; }
    [XmlIgnoreAttribute]
public string TargetPath { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Group")]
public string XmlGroup { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Hash")]
public string XmlHash { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("HashAlg")]
public string XmlHashAlgorithm { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("IsOptional")]
public string XmlIsOptional { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Path")]
public string XmlPath { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Size")]
public string XmlSize { get; public set; }
    protected internal BaseReference(string path);
    internal static string GetDefaultTargetPath(string path);
    internal bool get_IncludeHash();
    internal void set_IncludeHash(bool value);
    public string get_Group();
    public void set_Group(string value);
    public string get_Hash();
    public void set_Hash(string value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public string get_ResolvedPath();
    public void set_ResolvedPath(string value);
    public long get_Size();
    public void set_Size(long value);
    protected internal abstract virtual string get_SortName();
    public string get_SourcePath();
    public void set_SourcePath(string value);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public virtual string ToString();
    public string get_XmlGroup();
    public void set_XmlGroup(string value);
    public string get_XmlHash();
    public void set_XmlHash(string value);
    public string get_XmlHashAlgorithm();
    public void set_XmlHashAlgorithm(string value);
    public string get_XmlIsOptional();
    public void set_XmlIsOptional(string value);
    public string get_XmlPath();
    public void set_XmlPath(string value);
    public string get_XmlSize();
    public void set_XmlSize(string value);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComClass : object {
    private string _clsid;
    private string _description;
    private string _progid;
    private string _threadingModel;
    private string _tlbid;
    [XmlIgnoreAttribute]
public string ClsId { get; }
    [XmlIgnoreAttribute]
public string Description { get; }
    [XmlIgnoreAttribute]
public string ProgId { get; }
    [XmlIgnoreAttribute]
public string ThreadingModel { get; }
    [XmlIgnoreAttribute]
public string TlbId { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Clsid")]
public string XmlClsId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Description")]
public string XmlDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Progid")]
public string XmlProgId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ThreadingModel")]
public string XmlThreadingModel { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Tlbid")]
public string XmlTlbId { get; public set; }
    internal ComClass(Guid tlbId, Guid clsId, string progId, string threadingModel, string description);
    public string get_ClsId();
    public string get_Description();
    public string get_ProgId();
    public string get_ThreadingModel();
    public string get_TlbId();
    public string get_XmlClsId();
    public void set_XmlClsId(string value);
    public string get_XmlDescription();
    public void set_XmlDescription(string value);
    public string get_XmlProgId();
    public void set_XmlProgId(string value);
    public string get_XmlThreadingModel();
    public void set_XmlThreadingModel(string value);
    public string get_XmlTlbId();
    public void set_XmlTlbId(string value);
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComImporter : object {
    private OutputMessageCollection _outputMessages;
    private string _outputDisplayName;
    private ResourceManager _resources;
    private static String[] s_knownImplementedCategories;
    private static String[] s_knownSubKeys;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ComClass[] <ComClasses>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeLib <TypeLib>k__BackingField;
    public bool Success { get; }
    public ComClass[] ComClasses { get; }
    public TypeLib TypeLib { get; }
    public ComImporter(string path, OutputMessageCollection outputMessages, string outputDisplayName);
    private static ComImporter();
    private void CheckForUnknownSubKeys(RegistryKey key);
    private void CheckForUnknownSubKeys(RegistryKey key, String[] knownNames);
    private void CheckForUnknownValues(RegistryKey key);
    private void CheckForUnknownValues(RegistryKey key, String[] knownNames);
    private ClassInfo GetRegisteredClassInfo(Guid clsid);
    private bool GetRegisteredClassInfo(RegistryKey rootKey, Guid clsid, ClassInfo& info);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public ComClass[] get_ComClasses();
    [CompilerGeneratedAttribute]
public TypeLib get_TypeLib();
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ComInfo : object {
    [CompilerGeneratedAttribute]
private string <ComponentFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClsId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TlbId>k__BackingField;
    public string ComponentFileName { get; }
    public string ClsId { get; }
    public string ManifestFileName { get; }
    public string TlbId { get; }
    public ComInfo(string manifestFileName, string componentFileName, string clsid, string tlbid);
    [CompilerGeneratedAttribute]
public string get_ComponentFileName();
    [CompilerGeneratedAttribute]
public string get_ClsId();
    [CompilerGeneratedAttribute]
public string get_ManifestFileName();
    [CompilerGeneratedAttribute]
public string get_TlbId();
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFramework : object {
    private string _version;
    private string _profile;
    private string _supportedRuntime;
    [XmlIgnoreAttribute]
public string Version { get; public set; }
    [XmlIgnoreAttribute]
public string Profile { get; public set; }
    [XmlIgnoreAttribute]
public string SupportedRuntime { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Version")]
public string XmlVersion { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Profile")]
public string XmlProfile { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SupportedRuntime")]
public string XmlSupportedRuntime { get; public set; }
    public string get_Version();
    public void set_Version(string value);
    public string get_Profile();
    public void set_Profile(string value);
    public string get_SupportedRuntime();
    public void set_SupportedRuntime(string value);
    public string get_XmlVersion();
    public void set_XmlVersion(string value);
    public string get_XmlProfile();
    public void set_XmlProfile(string value);
    public string get_XmlSupportedRuntime();
    public void set_XmlSupportedRuntime(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.CompatibleFrameworkCollection : object {
    private List`1<CompatibleFramework> _list;
    public CompatibleFramework Item { get; }
    public int Count { get; }
    internal CompatibleFrameworkCollection(IEnumerable`1<CompatibleFramework> compatibleFrameworks);
    public CompatibleFramework get_Item(int index);
    public void Add(CompatibleFramework compatibleFramework);
    public void Clear();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    internal CompatibleFramework[] ToArray();
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.Constants : object {
    public static string CLRPlatformAssemblyName;
    public static string DeployFileExtension;
    public static string OSVersion_Win9X;
    public static string OSVersion_WinXP;
    public static Version EntryPointMinimumImageVersion;
    public static string TargetFrameworkVersion20;
    public static string TargetFrameworkVersion30;
    public static string TargetFrameworkVersion35;
    public static string TargetFrameworkVersion40;
    public static String[] NET30AssemblyIdentity;
    public static String[] NET35AssemblyIdentity;
    public static String[] NET35SP1AssemblyIdentity;
    public static String[] NET35ClientAssemblyIdentity;
    public static string UACAsInvoker;
    public static string UACUIAccess;
    public static int MaxFileAssociationsCount;
    public static int MaxFileAssociationExtensionLength;
    public static string ClientFrameworkSubset;
    public static string DotNetFrameworkIdentifier;
    public static string DotNetCoreIdentifier;
    public static string DotNetCoreAppIdentifier;
    public static string AppHostExe;
    public static string SingleFileHostExe;
    private static Constants();
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ConvertUtil : object {
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, bool defaultValue);
}
[ComVisibleAttribute("False")]
[XmlRootAttribute("DeployManifest")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.DeployManifest : Manifest {
    private string _createDesktopShortcut;
    private string _deploymentUrl;
    private string _disallowUrlActivation;
    private AssemblyReference _entryPoint;
    private string _errorReportUrl;
    private string _install;
    private string _mapFileExtensions;
    private string _minimumRequiredVersion;
    private string _product;
    private string _publisher;
    private string _suiteName;
    private string _supportUrl;
    private string _trustUrlParameters;
    private string _updateEnabled;
    private string _updateInterval;
    private string _updateMode;
    private string _updateUnit;
    private CompatibleFrameworkCollection _compatibleFrameworkList;
    private List`1<CompatibleFramework> _compatibleFrameworks;
    private string _targetFrameworkMoniker;
    private static string _redistListFolder;
    private static string _redistListFile;
    [XmlIgnoreAttribute]
public bool CreateDesktopShortcut { get; public set; }
    [XmlIgnoreAttribute]
public string TargetFrameworkMoniker { get; public set; }
    [XmlIgnoreAttribute]
public CompatibleFrameworkCollection CompatibleFrameworks { get; }
    [XmlIgnoreAttribute]
public string DeploymentUrl { get; public set; }
    [XmlIgnoreAttribute]
public bool DisallowUrlActivation { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReference EntryPoint { get; public set; }
    [XmlIgnoreAttribute]
public string ErrorReportUrl { get; public set; }
    [XmlIgnoreAttribute]
public bool Install { get; public set; }
    [XmlIgnoreAttribute]
public bool MapFileExtensions { get; public set; }
    [XmlIgnoreAttribute]
public string MinimumRequiredVersion { get; public set; }
    [XmlIgnoreAttribute]
public string Product { get; public set; }
    [XmlIgnoreAttribute]
public string Publisher { get; public set; }
    [XmlIgnoreAttribute]
public string SuiteName { get; public set; }
    [XmlIgnoreAttribute]
public string SupportUrl { get; public set; }
    [XmlIgnoreAttribute]
public bool TrustUrlParameters { get; public set; }
    [XmlIgnoreAttribute]
public bool UpdateEnabled { get; public set; }
    [XmlIgnoreAttribute]
public int UpdateInterval { get; public set; }
    [XmlIgnoreAttribute]
public UpdateMode UpdateMode { get; public set; }
    [XmlIgnoreAttribute]
public UpdateUnit UpdateUnit { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("CreateDesktopShortcut")]
public string XmlCreateDesktopShortcut { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("CompatibleFrameworks")]
public CompatibleFramework[] XmlCompatibleFrameworks { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("DeploymentUrl")]
public string XmlDeploymentUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("DisallowUrlActivation")]
public string XmlDisallowUrlActivation { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ErrorReportUrl")]
public string XmlErrorReportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Install")]
public string XmlInstall { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("MapFileExtensions")]
public string XmlMapFileExtensions { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("MinimumRequiredVersion")]
public string XmlMinimumRequiredVersion { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Product")]
public string XmlProduct { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Publisher")]
public string XmlPublisher { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SuiteName")]
public string XmlSuiteName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("SupportUrl")]
public string XmlSupportUrl { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("TrustUrlParameters")]
public string XmlTrustUrlParameters { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateEnabled")]
public string XmlUpdateEnabled { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateInterval")]
public string XmlUpdateInterval { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateMode")]
public string XmlUpdateMode { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("UpdateUnit")]
public string XmlUpdateUnit { get; public set; }
    public DeployManifest(string targetFrameworkMoniker);
    private void DiscoverCompatFrameworks(string moniker);
    private void DiscoverCompatibleFrameworks(FrameworkName frameworkName);
    private static FrameworkName GetInstallableFrameworkName(FrameworkName frameworkName);
    private static string GetRedistListFilePath(string referenceAssemblyPath);
    private static IList`1<string> GetPathToReferenceAssemblies(FrameworkName targetFrameworkMoniker);
    private static string GetInstallableFramework(string redistListFilePath);
    private static CompatibleFramework GetSubsetCompatFramework(FrameworkName frameworkName);
    private static CompatibleFramework GetFullCompatFramework(FrameworkName frameworkName);
    private static string PatchCLRVersion(string version);
    public bool get_CreateDesktopShortcut();
    public void set_CreateDesktopShortcut(bool value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    public CompatibleFrameworkCollection get_CompatibleFrameworks();
    public string get_DeploymentUrl();
    public void set_DeploymentUrl(string value);
    public bool get_DisallowUrlActivation();
    public void set_DisallowUrlActivation(bool value);
    public virtual AssemblyReference get_EntryPoint();
    public virtual void set_EntryPoint(AssemblyReference value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public bool get_Install();
    public void set_Install(bool value);
    public bool get_MapFileExtensions();
    public void set_MapFileExtensions(bool value);
    public string get_MinimumRequiredVersion();
    public void set_MinimumRequiredVersion(string value);
    internal virtual void OnAfterLoad();
    internal virtual void OnBeforeSave();
    public string get_Product();
    public void set_Product(string value);
    public string get_Publisher();
    public void set_Publisher(string value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    public string get_SupportUrl();
    public void set_SupportUrl(string value);
    public bool get_TrustUrlParameters();
    public void set_TrustUrlParameters(bool value);
    public bool get_UpdateEnabled();
    public void set_UpdateEnabled(bool value);
    public int get_UpdateInterval();
    public void set_UpdateInterval(int value);
    public UpdateMode get_UpdateMode();
    public void set_UpdateMode(UpdateMode value);
    public UpdateUnit get_UpdateUnit();
    public void set_UpdateUnit(UpdateUnit value);
    public virtual void Validate();
    private void ValidateDeploymentProvider();
    private void ValidateEntryPoint();
    private void ValidateMinimumRequiredVersion();
    public string get_XmlCreateDesktopShortcut();
    public void set_XmlCreateDesktopShortcut(string value);
    public CompatibleFramework[] get_XmlCompatibleFrameworks();
    public void set_XmlCompatibleFrameworks(CompatibleFramework[] value);
    public string get_XmlDeploymentUrl();
    public void set_XmlDeploymentUrl(string value);
    public string get_XmlDisallowUrlActivation();
    public void set_XmlDisallowUrlActivation(string value);
    public string get_XmlErrorReportUrl();
    public void set_XmlErrorReportUrl(string value);
    public string get_XmlInstall();
    public void set_XmlInstall(string value);
    public string get_XmlMapFileExtensions();
    public void set_XmlMapFileExtensions(string value);
    public string get_XmlMinimumRequiredVersion();
    public void set_XmlMinimumRequiredVersion(string value);
    public string get_XmlProduct();
    public void set_XmlProduct(string value);
    public string get_XmlPublisher();
    public void set_XmlPublisher(string value);
    public string get_XmlSuiteName();
    public void set_XmlSuiteName(string value);
    public string get_XmlSupportUrl();
    public void set_XmlSupportUrl(string value);
    public string get_XmlTrustUrlParameters();
    public void set_XmlTrustUrlParameters(string value);
    public string get_XmlUpdateEnabled();
    public void set_XmlUpdateEnabled(string value);
    public string get_XmlUpdateInterval();
    public void set_XmlUpdateInterval(string value);
    public string get_XmlUpdateMode();
    public void set_XmlUpdateMode(string value);
    public string get_XmlUpdateUnit();
    public void set_XmlUpdateUnit(string value);
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.EmbeddedManifestReader : object {
    private static IntPtr s_id1;
    private Stream _manifest;
    private EmbeddedManifestReader(string path);
    private static EmbeddedManifestReader();
    private bool EnumResNameCallback(IntPtr hModule, IntPtr pType, IntPtr pName, IntPtr param);
    public static Stream Read(string path);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociation : object {
    private string _defaultIcon;
    private string _description;
    private string _extension;
    private string _progid;
    [XmlIgnoreAttribute]
public string DefaultIcon { get; public set; }
    [XmlIgnoreAttribute]
public string Description { get; public set; }
    [XmlIgnoreAttribute]
public string Extension { get; public set; }
    [XmlIgnoreAttribute]
public string ProgId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("DefaultIcon")]
public string XmlDefaultIcon { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Description")]
public string XmlDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Extension")]
public string XmlExtension { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Progid")]
public string XmlProgId { get; public set; }
    public string get_DefaultIcon();
    public void set_DefaultIcon(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_Extension();
    public void set_Extension(string value);
    public string get_ProgId();
    public void set_ProgId(string value);
    public string get_XmlDefaultIcon();
    public void set_XmlDefaultIcon(string value);
    public string get_XmlDescription();
    public void set_XmlDescription(string value);
    public string get_XmlExtension();
    public void set_XmlExtension(string value);
    public string get_XmlProgId();
    public void set_XmlProgId(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileAssociationCollection : object {
    private List`1<FileAssociation> _list;
    public FileAssociation Item { get; }
    public int Count { get; }
    internal FileAssociationCollection(FileAssociation[] fileAssociations);
    public FileAssociation get_Item(int index);
    public void Add(FileAssociation fileAssociation);
    public void Clear();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
    internal FileAssociation[] ToArray();
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReference : BaseReference {
    private ComClass[] _comClasses;
    private string _writeableType;
    private ProxyStub[] _proxyStubs;
    private TypeLib[] _typeLibs;
    [XmlIgnoreAttribute]
public ComClass[] ComClasses { get; }
    [XmlIgnoreAttribute]
public bool IsDataFile { get; public set; }
    [XmlIgnoreAttribute]
public ProxyStub[] ProxyStubs { get; }
    protected internal string SortName { get; }
    [XmlIgnoreAttribute]
public TypeLib[] TypeLibs { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("ComClasses")]
public ComClass[] XmlComClasses { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("ProxyStubs")]
public ProxyStub[] XmlProxyStubs { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("TypeLibs")]
public TypeLib[] XmlTypeLibs { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("WriteableType")]
public string XmlWriteableType { get; public set; }
    public FileReference(string path);
    public ComClass[] get_ComClasses();
    [SupportedOSPlatform("windows")]
internal bool ImportComComponent(string path, OutputMessageCollection outputMessages, string outputDisplayName);
    public bool get_IsDataFile();
    public void set_IsDataFile(bool value);
    public ProxyStub[] get_ProxyStubs();
    protected internal virtual string get_SortName();
    public TypeLib[] get_TypeLibs();
    public ComClass[] get_XmlComClasses();
    public void set_XmlComClasses(ComClass[] value);
    public ProxyStub[] get_XmlProxyStubs();
    public void set_XmlProxyStubs(ProxyStub[] value);
    public TypeLib[] get_XmlTypeLibs();
    public void set_XmlTypeLibs(TypeLib[] value);
    public string get_XmlWriteableType();
    public void set_XmlWriteableType(string value);
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.FileReferenceCollection : object {
    private List`1<FileReference> _list;
    public FileReference Item { get; }
    public int Count { get; }
    internal FileReferenceCollection(FileReference[] array);
    public FileReference get_Item(int index);
    public FileReference Add(string path);
    public FileReference Add(FileReference file);
    public void Clear();
    public int get_Count();
    public FileReference FindTargetPath(string targetPath);
    public sealed virtual IEnumerator GetEnumerator();
    public void Remove(FileReference file);
    internal FileReference[] ToArray();
}
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.LauncherBuilder : object {
    private static string LAUNCHER_RESOURCENAME;
    private static int LAUNCHER_RESOURCE_TABLE;
    private BuildResults _results;
    [CompilerGeneratedAttribute]
private string <LauncherPath>k__BackingField;
    public string LauncherPath { get; public set; }
    public LauncherBuilder(string launcherPath);
    [CompilerGeneratedAttribute]
public string get_LauncherPath();
    [CompilerGeneratedAttribute]
public void set_LauncherPath(string value);
    public BuildResults Build(string filename, string outputPath);
    private bool CopyLauncherToOutputDirectory(string strOutputExe);
    private static void EnsureFolderExists(string strFolderPath);
    private static void ClearReadOnlyAttribute(string strFileName);
}
[ComVisibleAttribute("False")]
public abstract class Microsoft.Build.Tasks.Deployment.ManifestUtilities.Manifest : object {
    private AssemblyIdentity _assemblyIdentity;
    private AssemblyReference[] _assemblyReferences;
    private string _description;
    private FileReference[] _fileReferences;
    private string _sourcePath;
    private Stream _inputStream;
    private FileReferenceCollection _fileReferenceList;
    private AssemblyReferenceCollection _assemblyReferenceList;
    private OutputMessageCollection _outputMessages;
    private bool _treatUnfoundNativeAssembliesAsPrerequisites;
    private bool _readOnly;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LauncherBasedDeployment>k__BackingField;
    [XmlIgnoreAttribute]
public AssemblyIdentity AssemblyIdentity { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReferenceCollection AssemblyReferences { get; }
    [XmlIgnoreAttribute]
public string AssemblyName { get; public set; }
    [XmlIgnoreAttribute]
public bool LauncherBasedDeployment { get; public set; }
    [XmlIgnoreAttribute]
public string Description { get; public set; }
    [XmlIgnoreAttribute]
public AssemblyReference EntryPoint { get; public set; }
    [XmlIgnoreAttribute]
public FileReferenceCollection FileReferences { get; }
    [XmlIgnoreAttribute]
public Stream InputStream { get; public set; }
    [XmlIgnoreAttribute]
public OutputMessageCollection OutputMessages { get; }
    [XmlIgnoreAttribute]
public bool ReadOnly { get; public set; }
    [XmlIgnoreAttribute]
public string SourcePath { get; public set; }
    internal bool TreatUnfoundNativeAssembliesAsPrerequisites { get; internal set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlElementAttribute("AssemblyIdentity")]
public AssemblyIdentity XmlAssemblyIdentity { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("AssemblyReferences")]
public AssemblyReference[] XmlAssemblyReferences { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Description")]
public string XmlDescription { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlArrayAttribute("FileReferences")]
public FileReference[] XmlFileReferences { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Schema")]
public string XmlSchema { get; public set; }
    public AssemblyIdentity get_AssemblyIdentity();
    public void set_AssemblyIdentity(AssemblyIdentity value);
    public AssemblyReferenceCollection get_AssemblyReferences();
    private void CollectionToArray();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public bool get_LauncherBasedDeployment();
    [CompilerGeneratedAttribute]
public void set_LauncherBasedDeployment(bool value);
    public string get_Description();
    public void set_Description(string value);
    public virtual AssemblyReference get_EntryPoint();
    public virtual void set_EntryPoint(AssemblyReference value);
    public FileReferenceCollection get_FileReferences();
    public Stream get_InputStream();
    public void set_InputStream(Stream value);
    internal virtual void OnAfterLoad();
    internal virtual void OnBeforeSave();
    public OutputMessageCollection get_OutputMessages();
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    private static bool ResolveAssembly(AssemblyReference a, String[] searchPaths);
    private static bool ResolveFile(BaseReference f, String[] searchPaths);
    public void ResolveFiles();
    public void ResolveFiles(String[] searchPaths);
    private void ResolveFiles_1(String[] searchPaths);
    private void ResolveFiles_2(String[] searchPaths);
    private static string ResolvePath(string path, String[] searchPaths);
    private void SortFiles();
    public string get_SourcePath();
    public void set_SourcePath(string value);
    public virtual string ToString();
    internal bool get_TreatUnfoundNativeAssembliesAsPrerequisites();
    internal void set_TreatUnfoundNativeAssembliesAsPrerequisites(bool value);
    internal static void UpdateEntryPoint(string inputPath, string outputPath, string updatedApplicationPath, string applicationManifestPath, string targetFrameworkVersion);
    private void UpdateAssemblyReference(AssemblyReference a, string targetFrameworkVersion);
    private void UpdateFileReference(BaseReference f, string targetFrameworkVersion);
    public void UpdateFileInfo();
    public void UpdateFileInfo(string targetFrameworkVersion);
    private void UpdateFileInfoImpl(string targetFrameworkVersion);
    public virtual void Validate();
    private void ValidateReferences();
    protected void ValidatePlatform();
    private bool IsMismatchedPlatform(AssemblyReference assembly);
    public AssemblyIdentity get_XmlAssemblyIdentity();
    public void set_XmlAssemblyIdentity(AssemblyIdentity value);
    public AssemblyReference[] get_XmlAssemblyReferences();
    public void set_XmlAssemblyReferences(AssemblyReference[] value);
    public string get_XmlDescription();
    public void set_XmlDescription(string value);
    public FileReference[] get_XmlFileReferences();
    public void set_XmlFileReferences(FileReference[] value);
    public string get_XmlSchema();
    public void set_XmlSchema(string value);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestFormatter : object {
    public static Stream Format(Stream input);
}
[ComVisibleAttribute("False")]
public static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestReader : object {
    internal static ComInfo[] GetComInfo(string path);
    private static XmlDocument GetXmlDocument(string path);
    private static Manifest ReadEmbeddedManifest(string path);
    public static Manifest ReadManifest(string path, bool preserveStream);
    public static Manifest ReadManifest(string manifestType, string path, bool preserveStream);
    public static Manifest ReadManifest(Stream input, bool preserveStream);
    public static Manifest ReadManifest(string manifestType, Stream input, bool preserveStream);
    private static Manifest Deserialize(Stream s);
}
[ComVisibleAttribute("False")]
public static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ManifestWriter : object {
    private static Stream Serialize(Manifest manifest);
    public static void WriteManifest(Manifest manifest);
    public static void WriteManifest(Manifest manifest, string path);
    public static void WriteManifest(Manifest manifest, string path, string targetframeWorkVersion);
    public static void WriteManifest(Manifest manifest, Stream output);
    private static void WriteManifest(Manifest manifest, Stream output, string targetframeWorkVersion);
}
internal class Microsoft.Build.Tasks.Deployment.ManifestUtilities.MetadataReader : object {
    private string _path;
    private StringDictionary _attributes;
    private IMetaDataDispenser _metaDispenser;
    private IMetaDataAssemblyImport _assemblyImport;
    private static Guid s_importerGuid;
    private static Guid s_refidGuid;
    public string Name { get; }
    public string Version { get; }
    public string PublicKeyToken { get; }
    public string Culture { get; }
    public string ProcessorArchitecture { get; }
    private StringDictionary Attributes { get; }
    private MetadataReader(string path);
    private static MetadataReader();
    public static MetadataReader Create(string path);
    public bool HasAssemblyAttribute(string name);
    public string get_Name();
    public string get_Version();
    public string get_PublicKeyToken();
    public string get_Culture();
    public string get_ProcessorArchitecture();
    private StringDictionary get_Attributes();
    public void Close();
    private void ImportAttributes();
    private sealed virtual override void System.IDisposable.Dispose();
    private static Guid GetGuidOfType(Type type);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.NativeMethods : object {
    public static UInt32 LOAD_LIBRARY_AS_DATAFILE;
    public static IntPtr RT_MANIFEST;
    private static NativeMethods();
    public static IntPtr LoadLibraryExW(string strFileName, IntPtr hFile, UInt32 ulFlags);
    public static int SetDllDirectoryW(string strPathName);
    public static bool FreeLibrary(IntPtr hModule);
    public static IntPtr FindResource(IntPtr hModule, IntPtr pName, IntPtr pType);
    public static IntPtr LoadResource(IntPtr hModule, IntPtr hResource);
    public static UInt32 SizeofResource(IntPtr hModule, IntPtr hResource);
    public static IntPtr LockResource(IntPtr hGlobal);
    public static int EnumResourceNames(IntPtr hModule, IntPtr pType, EnumResNameProc enumFunc, IntPtr param);
    public static void LoadTypeLibEx(string strTypeLibName, RegKind regKind, Object& typeLib);
    public static int SfcIsFileProtected(IntPtr RpcHandle, string ProtFileName);
    public static object GetAssemblyIdentityFromFile(string filePath, Guid& riid);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessage : object {
    private String[] _arguments;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputMessageType <Type>k__BackingField;
    public string Name { get; }
    public string Text { get; }
    public OutputMessageType Type { get; }
    internal OutputMessage(OutputMessageType type, string name, string text, String[] arguments);
    public String[] GetArguments();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public OutputMessageType get_Type();
}
[DefaultMemberAttribute("Item")]
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageCollection : object {
    private ResourceManager _taskResources;
    private List`1<OutputMessage> _list;
    [CompilerGeneratedAttribute]
private int <ErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningCount>k__BackingField;
    public OutputMessage Item { get; }
    public int ErrorCount { get; private set; }
    public int WarningCount { get; private set; }
    public OutputMessage get_Item(int index);
    internal void AddErrorMessage(string taskResourceName, String[] arguments);
    internal void AddWarningMessage(string taskResourceName, String[] arguments);
    public void Clear();
    [CompilerGeneratedAttribute]
public int get_ErrorCount();
    [CompilerGeneratedAttribute]
private void set_ErrorCount(int value);
    public sealed virtual IEnumerator GetEnumerator();
    internal bool LogTaskMessages(Task task);
    [CompilerGeneratedAttribute]
public int get_WarningCount();
    [CompilerGeneratedAttribute]
private void set_WarningCount(int value);
}
[ComVisibleAttribute("False")]
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.OutputMessageType : Enum {
    public int value__;
    public static OutputMessageType Info;
    public static OutputMessageType Warning;
    public static OutputMessageType Error;
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.PathUtil : object {
    public static string CanonicalizePath(string path);
    public static string CanonicalizeUrl(string url);
    public static String[] GetPathSegments(string path);
    public static string Format(string path);
    public static bool IsAssembly(string path);
    public static bool IsDataFile(string path);
    public static bool IsEqualPath(string path1, string path2);
    public static bool IsLocalPath(string path);
    public static bool IsManagedAssembly(string path);
    public static bool IsNativeAssembly(string path);
    public static bool IsPEFile(string path);
    public static bool IsProgramFile(string path);
    public static bool IsUncPath(string path);
    public static bool IsUrl(string path);
    public static string Resolve(string path);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.ProxyStub : object {
    private string _baseInterface;
    private string _iid;
    private string _name;
    private string _numMethods;
    private string _tlbid;
    [XmlIgnoreAttribute]
public string BaseInterface { get; }
    [XmlIgnoreAttribute]
public string IID { get; }
    [XmlIgnoreAttribute]
public string Name { get; }
    [XmlIgnoreAttribute]
public string NumMethods { get; }
    [XmlIgnoreAttribute]
public string TlbId { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("BaseInterface")]
public string XmlBaseInterface { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Iid")]
public string XmlIID { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Name")]
public string XmlName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("NumMethods")]
public string XmlNumMethods { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Tlbid")]
public string XmlTlbId { get; public set; }
    public string get_BaseInterface();
    public string get_IID();
    public string get_Name();
    public string get_NumMethods();
    public string get_TlbId();
    public string get_XmlBaseInterface();
    public void set_XmlBaseInterface(string value);
    public string get_XmlIID();
    public void set_XmlIID(string value);
    public string get_XmlName();
    public void set_XmlName(string value);
    public string get_XmlNumMethods();
    public void set_XmlNumMethods(string value);
    public string get_XmlTlbId();
    public void set_XmlTlbId(string value);
}
[ComVisibleAttribute("False")]
public static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.SecurityUtilities : object {
    private static string PermissionSetsFolder;
    private static string LocalIntranet;
    private static string Internet;
    private static string Custom;
    private static string ToolName;
    private static int Fx2MajorVersion;
    private static int Fx3MajorVersion;
    private static Version s_dotNet40Version;
    private static Version s_dotNet45Version;
    private static string InternetPermissionSetXml;
    private static string LocalIntranetPermissionSetXml;
    private static string InternetPermissionSetWithWPFXml;
    private static string LocalIntranetPermissionSetWithWPFXml;
    private static SecurityUtilities();
    public static PermissionSet ComputeZonePermissionSet(string targetZone, PermissionSet includedPermissionSet, String[] excludedPermissions);
    internal static PermissionSet ComputeZonePermissionSetHelper(string targetZone, PermissionSet includedPermissionSet, ITaskItem[] dependencies, string targetFrameworkMoniker);
    private static PermissionSet GetNamedPermissionSetFromZone(string targetZone, string targetFrameworkMoniker);
    private static PermissionSet GetNamedPermissionSet(string targetZone, string targetFrameworkMoniker);
    private static XmlElement GetXmlElement(string targetZone, FrameworkName fn);
    private static XmlElement GetCurrentCLRPermissions(string targetZone);
    private static XmlElement GetXmlElement(string targetZone, int majorVersion);
    private static XmlDocument CreateXmlDocV2(string targetZone);
    private static XmlDocument CreateXmlDocV3(string targetZone);
    internal static bool ParseElementForAssemblyIdentification(SecurityElement el, String& className, String& assemblyName, String& assemblyVersion);
    public static PermissionSet IdentityListToPermissionSet(String[] ids);
    public static String[] PermissionSetToIdentityList(PermissionSet permissionSet);
    internal static XmlDocument PermissionSetToXml(PermissionSet ps);
    private static SecurityElement XmlElementToSecurityElement(XmlElement xe);
    private static String[] XmlToIdentityList(XmlElement psElement);
    public static PermissionSet XmlToPermissionSet(XmlElement element);
    [SupportedOSPlatform("windows")]
public static void SignFile(string certThumbprint, Uri timestampUrl, string path);
    [SupportedOSPlatform("windows")]
public static void SignFile(string certThumbprint, Uri timestampUrl, string path, string targetFrameworkVersion);
    [SupportedOSPlatform("windows")]
public static void SignFile(string certThumbprint, Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier);
    [SupportedOSPlatform("windows")]
public static void SignFile(string certThumbprint, Uri timestampUrl, string path, string targetFrameworkVersion, string targetFrameworkIdentifier, bool disallowMansignTimestampFallback);
    [SupportedOSPlatform("windows")]
public static void SignFile(string certPath, SecureString certPassword, Uri timestampUrl, string path);
    private static bool UseSha256Algorithm(X509Certificate2 cert);
    [SupportedOSPlatform("windows")]
public static void SignFile(X509Certificate2 cert, Uri timestampUrl, string path);
    [SupportedOSPlatform("windows")]
private static void SignFileInternal(X509Certificate2 cert, Uri timestampUrl, string path, bool targetFrameworkSupportsSha256, ResourceManager resources, bool disallowMansignTimestampFallback);
    private static void SignPEFile(X509Certificate2 cert, Uri timestampUrl, string path, ResourceManager resources, bool useSha256);
    private static void SignPEFileInternal(X509Certificate2 cert, Uri timestampUrl, string path, ResourceManager resources, bool useSha256, bool useRFC3161Timestamp);
    internal static string GetCommandLineParameters(string certThumbprint, Uri timestampUrl, string path, bool useSha256, bool useRFC3161Timestamp);
    internal static string GetPathToTool(ResourceManager resources);
    internal static X509Certificate2 GetCert(string thumbprint);
    private static bool IsCertInStore(X509Certificate2 cert);
    [SupportedOSPlatform("windows")]
private static string GetVersionIndependentToolPath(string toolName);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.TrustInfo : object {
    private PermissionSet _inputPermissionSet;
    private PermissionSet _outputPermissionSet;
    private bool _sameSiteChanged;
    private XmlDocument _inputTrustInfoDocument;
    private bool _isFullTrust;
    private string _sameSiteSetting;
    [CompilerGeneratedAttribute]
private bool <PreserveFullTrustPermissionSet>k__BackingField;
    public bool HasUnmanagedCodePermission { get; }
    public bool IsFullTrust { get; public set; }
    public PermissionSet PermissionSet { get; public set; }
    public bool PreserveFullTrustPermissionSet { get; public set; }
    public string SameSiteAccess { get; public set; }
    private void AddSameSiteAttribute(XmlElement permissionSetElement);
    public void Clear();
    private void FixupPermissionSetElement(XmlElement permissionSetElement);
    private PermissionSet GetInputPermissionSet();
    private XmlElement GetInputPermissionSetElement();
    private XmlElement GetInputRequestedPrivilegeElement();
    private static XmlElement GetRequestedPrivilegeElement(XmlElement inputRequestedPrivilegeElement, XmlDocument document);
    private XmlElement GetPermissionSetElement(XmlDocument document);
    private PermissionSet GetOutputPermissionSet();
    private XmlDocument GetOutputPermissionSetDocument();
    public bool get_HasUnmanagedCodePermission();
    public bool get_IsFullTrust();
    public void set_IsFullTrust(bool value);
    public PermissionSet get_PermissionSet();
    public void set_PermissionSet(PermissionSet value);
    [CompilerGeneratedAttribute]
public bool get_PreserveFullTrustPermissionSet();
    [CompilerGeneratedAttribute]
public void set_PreserveFullTrustPermissionSet(bool value);
    public void Read(string path);
    public void Read(Stream input);
    private void Read(Stream s, string xpath);
    public void ReadManifest(string path);
    public void ReadManifest(Stream input);
    private void ReadTrustInfo(string xml);
    public string get_SameSiteAccess();
    public void set_SameSiteAccess(string value);
    public virtual string ToString();
    public void Write(string path);
    public void Write(Stream output);
    public void WriteManifest(string path);
    public void WriteManifest(Stream output);
    public void WriteManifest(Stream input, Stream output);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.TypeLib : object {
    private string _flags;
    private string _helpDirectory;
    private string _resourceid;
    private string _tlbid;
    private string _version;
    [XmlIgnoreAttribute]
public string Flags { get; }
    [XmlIgnoreAttribute]
public string HelpDirectory { get; }
    [XmlIgnoreAttribute]
public string ResourceId { get; }
    [XmlIgnoreAttribute]
public string TlbId { get; }
    [XmlIgnoreAttribute]
public string Version { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Flags")]
public string XmlFlags { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("HelpDir")]
public string XmlHelpDirectory { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("ResourceId")]
public string XmlResourceId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Tlbid")]
public string XmlTlbId { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Version")]
public string XmlVersion { get; public set; }
    internal TypeLib(Guid tlbId, Version version, string helpDirectory, int resourceId, int flags);
    public string get_Flags();
    private static string FlagsFromInt(int flags);
    public string get_HelpDirectory();
    public string get_ResourceId();
    public string get_TlbId();
    public string get_Version();
    public string get_XmlFlags();
    public void set_XmlFlags(string value);
    public string get_XmlHelpDirectory();
    public void set_XmlHelpDirectory(string value);
    public string get_XmlResourceId();
    public void set_XmlResourceId(string value);
    public string get_XmlTlbId();
    public void set_XmlTlbId(string value);
    public string get_XmlVersion();
    public void set_XmlVersion(string value);
}
[ComVisibleAttribute("False")]
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateMode : Enum {
    public int value__;
    public static UpdateMode Background;
    public static UpdateMode Foreground;
}
[ComVisibleAttribute("False")]
public enum Microsoft.Build.Tasks.Deployment.ManifestUtilities.UpdateUnit : Enum {
    public int value__;
    public static UpdateUnit Hours;
    public static UpdateUnit Days;
    public static UpdateUnit Weeks;
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.Util : object {
    internal static string Schema;
    internal static bool logging;
    internal static string logPath;
    private static Char[] s_fileNameInvalidChars;
    private static StreamWriter s_logFileWriter;
    private static Int32[] s_clrVersion2;
    private static String[] s_platforms;
    private static String[] s_processorArchitectures;
    private static ItemComparer s_itemComparer;
    private static Util();
    public static string ByteArrayToHex(Byte[] a);
    public static string ByteArrayToString(Byte[] a);
    public static int CopyStream(Stream input, Stream output);
    public static string FilterNonprintableChars(string value);
    public static string GetAssemblyPath();
    public static string GetClrVersion();
    public static string GetClrVersion(string targetFrameworkVersion);
    public static Version GetTargetFrameworkVersion(string targetFramework);
    public static string GetEmbeddedResourceString(string name);
    public static Stream GetEmbeddedResourceStream(string name);
    public static void GetFileInfo(string path, String& hash, Int64& length);
    public static void GetFileInfo(string path, string targetFrameworkVersion, String& hash, Int64& length);
    private static void GetFileInfoImpl(string path, string targetFrameWorkVersion, String& hash, Int64& length);
    private static string GetLogPath();
    [SupportedOSPlatform("windows")]
public static string GetRegisteredOrganization();
    public static bool IsValidAssemblyName(string value);
    public static bool IsValidCulture(string value);
    public static bool IsValidFileName(string value);
    public static bool IsValidVersion(string value, int octets);
    internal static bool IsValidFrameworkVersion(string value);
    public static string PlatformToProcessorArchitecture(string platform);
    private static ITaskItem[] RemoveDuplicateItems(ITaskItem[] items);
    public static ITaskItem[] SortItems(ITaskItem[] items);
    public static void WriteFile(string path, string s);
    public static void WriteFile(string path, Stream s);
    public static void WriteLog(string text);
    public static void WriteLogFile(string filename, Stream s);
    public static void WriteLogFile(string filename, string s);
    public static void WriteLogFile(string filename, XmlElement element);
    public static string WriteTempFile(Stream s);
    public static string WriteTempFile(string s);
    public static Version ConvertFrameworkVersionToString(string version);
    public static int CompareFrameworkVersions(string versionA, string versionB);
}
[ComVisibleAttribute("False")]
public class Microsoft.Build.Tasks.Deployment.ManifestUtilities.WindowClass : object {
    private string _name;
    private string _versioned;
    [XmlIgnoreAttribute]
public string Name { get; }
    [XmlIgnoreAttribute]
public bool Versioned { get; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Name")]
public string XmlName { get; public set; }
    [BrowsableAttribute("False")]
[EditorBrowsableAttribute("1")]
[XmlAttributeAttribute("Versioned")]
public string XmlVersioned { get; public set; }
    public WindowClass(string name, bool versioned);
    public string get_Name();
    public bool get_Versioned();
    public string get_XmlName();
    public void set_XmlName(string value);
    public string get_XmlVersioned();
    public void set_XmlVersioned(string value);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.XmlNamespaces : object {
    public static string asmv1;
    public static string asmv2;
    public static string asmv3;
    public static string dsig;
    public static string xrml;
    public static string xsi;
    public static XmlNamespaceManager GetNamespaceManager(XmlNameTable nameTable);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.XmlUtil : object {
    private static ResourceResolver s_resolver;
    private static XmlUtil();
    public static string GetQName(XmlTextReader r, XmlNamespaceManager nsmgr);
    public static XmlElement CloneElementToDocument(XmlElement element, XmlDocument document, string namespaceURI);
    public static string TrimPrefix(string s);
    public static Stream XslTransform(string resource, Stream input, DictionaryEntry[] entries);
}
internal static class Microsoft.Build.Tasks.Deployment.ManifestUtilities.XPaths : object {
    public static string applicationRequestMinimumElement;
    public static string assemblyElement;
    public static string assemblyIdentityPath;
    public static string clsidAttribute;
    public static string comFilesPath;
    public static string configBindingRedirect;
    public static string defaultAssemblyRequestElement;
    public static string dependencyPublicKeyTokenAttribute;
    public static string fileNameAttribute;
    public static string fileSizeAttribute;
    public static string hashElement;
    public static string idAttribute;
    public static string languageAttribute1;
    public static string languageAttribute2;
    public static string manifestTrustInfoPath;
    public static string permissionIdentityQuery;
    public static string permissionClassAttributeQuery;
    public static string permissionSetElement;
    public static string permissionSetReferenceAttribute;
    public static string publicKeyTokenAttribute;
    public static string requestedExecutionLevelPath;
    public static string requestedPrivilegeElement;
    public static string requestedExecutionLevelElement;
    public static string sameSiteAttribute;
    public static string securityElement;
    public static string signaturePath;
    public static string tlbidAttribute;
    public static string trustInfoElement;
    public static string trustInfoPath;
    public static string unrestrictedAttribute;
    public static String[] codebasePaths;
    public static String[] emptyAttributeList;
    private static XPaths();
}
internal class Microsoft.Build.Tasks.DirectoryResolver : Resolver {
    public DirectoryResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal abstract class Microsoft.Build.Tasks.DisposableBase : object {
    private bool _disposed;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual void DisposeManagedResources();
    protected virtual void DisposeUnmanagedResources();
}
public class Microsoft.Build.Tasks.DownloadFile : TaskExtension {
    private CancellationTokenSource _cancellationTokenSource;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DownloadedFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Retries>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayMilliseconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnchangedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMessageHandler <HttpMessageHandler>k__BackingField;
    public ITaskItem DestinationFileName { get; public set; }
    [RequiredAttribute]
public ITaskItem DestinationFolder { get; public set; }
    [OutputAttribute]
public ITaskItem DownloadedFile { get; public set; }
    public int Retries { get; public set; }
    public int RetryDelayMilliseconds { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [RequiredAttribute]
public string SourceUrl { get; public set; }
    public int Timeout { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    internal HttpMessageHandler HttpMessageHandler { get; internal set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFileName();
    [CompilerGeneratedAttribute]
public void set_DestinationFileName(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DownloadedFile();
    [CompilerGeneratedAttribute]
public void set_DownloadedFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public int get_Retries();
    [CompilerGeneratedAttribute]
public void set_Retries(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayMilliseconds();
    [CompilerGeneratedAttribute]
public void set_RetryDelayMilliseconds(int value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnchangedFiles();
    [CompilerGeneratedAttribute]
public void set_SkipUnchangedFiles(bool value);
    [CompilerGeneratedAttribute]
public string get_SourceUrl();
    [CompilerGeneratedAttribute]
public void set_SourceUrl(string value);
    [CompilerGeneratedAttribute]
public int get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    [CompilerGeneratedAttribute]
internal HttpMessageHandler get_HttpMessageHandler();
    [CompilerGeneratedAttribute]
internal void set_HttpMessageHandler(HttpMessageHandler value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    [AsyncStateMachineAttribute("Microsoft.Build.Tasks.DownloadFile/<ExecuteAsync>d__43")]
private Task`1<bool> ExecuteAsync();
    [AsyncStateMachineAttribute("Microsoft.Build.Tasks.DownloadFile/<DownloadAsync>d__44")]
private Task DownloadAsync(Uri uri, CancellationToken cancellationToken);
    private static bool IsRetriable(Exception exception, Exception& actualException);
    private bool TryGetFileName(HttpResponseMessage response, String& filename);
    private bool ShouldSkip(HttpResponseMessage response, FileInfo destinationFile);
}
public class Microsoft.Build.Tasks.Error : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    public string Text { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public string HelpLink { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
public void set_HelpLink(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.ErrorFromResources : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [RequiredAttribute]
public string Resource { get; public set; }
    public String[] Arguments { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(String[] value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Exec : ToolTaskExtension {
    private bool _encodingParametersValid;
    private string _workingDirectory;
    private ITaskItem[] _outputs;
    internal bool workingDirectoryIsUNC;
    private string _batchFile;
    private string _customErrorRegex;
    private string _customWarningRegex;
    private List`1<ITaskItem> _nonEmptyOutput;
    private Encoding _standardErrorEncoding;
    private Encoding _standardOutputEncoding;
    private string _command;
    private static Char[] _charactersToEscape;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConsoleToMSBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreStandardErrorWarningFormat>k__BackingField;
    private static Lazy`1<string> CommandProcessorPath;
    [RequiredAttribute]
public string Command { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool IgnoreExitCode { get; public set; }
    public bool ConsoleToMSBuild { get; public set; }
    public string CustomErrorRegularExpression { get; public set; }
    public string CustomWarningRegularExpression { get; public set; }
    public bool IgnoreStandardErrorWarningFormat { get; public set; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    [OutputAttribute]
public string StdOutEncoding { get; public set; }
    [OutputAttribute]
public string StdErrEncoding { get; public set; }
    [OutputAttribute]
public ITaskItem[] Outputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] ConsoleOutput { get; }
    protected string ToolName { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    private static Exec();
    public string get_Command();
    public void set_Command(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreExitCode();
    [CompilerGeneratedAttribute]
public void set_IgnoreExitCode(bool value);
    [CompilerGeneratedAttribute]
public bool get_ConsoleToMSBuild();
    [CompilerGeneratedAttribute]
public void set_ConsoleToMSBuild(bool value);
    public string get_CustomErrorRegularExpression();
    public void set_CustomErrorRegularExpression(string value);
    public string get_CustomWarningRegularExpression();
    public void set_CustomWarningRegularExpression(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreStandardErrorWarningFormat();
    [CompilerGeneratedAttribute]
public void set_IgnoreStandardErrorWarningFormat(bool value);
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    public string get_StdOutEncoding();
    public void set_StdOutEncoding(string value);
    public string get_StdErrEncoding();
    public void set_StdErrEncoding(string value);
    public ITaskItem[] get_Outputs();
    public void set_Outputs(ITaskItem[] value);
    public ITaskItem[] get_ConsoleOutput();
    private void CreateTemporaryBatchFile();
    protected virtual int ExecuteTool(string pathToTool, string responseFileCommands, string commandLineCommands);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual void LogPathToTool(string toolName, string pathToTool);
    protected virtual void LogToolCommand(string message);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    private bool OutputMatchesRegex(string singleLine, String& regularExpression);
    protected virtual bool ValidateParameters();
    internal bool ValidateParametersAccessor();
    protected virtual string GenerateFullPathToTool();
    protected virtual string GetWorkingDirectory();
    internal string GetWorkingDirectoryAccessor();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    private bool ShouldEscapeCharacter(char c);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
}
public class Microsoft.Build.Tasks.ExtractedClassName : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsInsideConditionalBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool IsInsideConditionalBlock { get; public set; }
    public string Name { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsInsideConditionalBlock();
    [CompilerGeneratedAttribute]
public void set_IsInsideConditionalBlock(bool value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
internal class Microsoft.Build.Tasks.FileState : object {
    private string _filename;
    public string FileNameFullPath;
    private Lazy`1<FileDirInfo> _data;
    internal bool IsReadOnly { get; }
    internal bool FileExists { get; }
    internal bool DirectoryExists { get; }
    internal DateTime LastWriteTime { get; }
    internal DateTime LastWriteTimeUtcFast { get; }
    internal long Length { get; }
    internal string Name { get; }
    internal bool IsDirectory { get; }
    internal FileState(string filename);
    internal bool get_IsReadOnly();
    internal bool get_FileExists();
    internal bool get_DirectoryExists();
    internal DateTime get_LastWriteTime();
    internal DateTime get_LastWriteTimeUtcFast();
    internal long get_Length();
    internal string get_Name();
    internal bool get_IsDirectory();
    internal void Reset();
    [CompilerGeneratedAttribute]
private FileDirInfo <.ctor>b__4_0();
    [CompilerGeneratedAttribute]
private FileDirInfo <Reset>b__21_0();
}
public class Microsoft.Build.Tasks.FindAppConfigFile : TaskExtension {
    private ITaskItem[] _primaryList;
    private ITaskItem[] _secondaryList;
    private static string appConfigFile;
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AppConfigFile>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] PrimaryList { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SecondaryList { get; public set; }
    [RequiredAttribute]
public string TargetPath { get; public set; }
    [OutputAttribute]
public ITaskItem AppConfigFile { get; public set; }
    public ITaskItem[] get_PrimaryList();
    public void set_PrimaryList(ITaskItem[] value);
    public ITaskItem[] get_SecondaryList();
    public void set_SecondaryList(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
public void set_TargetPath(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AppConfigFile();
    [CompilerGeneratedAttribute]
public void set_AppConfigFile(ITaskItem value);
    public virtual bool Execute();
    private bool ConsultLists(bool matchWholeItemSpec);
    private bool IsMatchingItem(ITaskItem item, bool matchWholeItemSpec);
}
public class Microsoft.Build.Tasks.FindInList : TaskExtension {
    private ITaskItem[] _list;
    [CompilerGeneratedAttribute]
private bool <MatchFileNameOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ItemFound>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemSpecToFind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindLastMatch>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] List { get; public set; }
    public bool MatchFileNameOnly { get; public set; }
    [OutputAttribute]
public ITaskItem ItemFound { get; public set; }
    [RequiredAttribute]
public string ItemSpecToFind { get; public set; }
    public bool CaseSensitive { get; public set; }
    public bool FindLastMatch { get; public set; }
    public ITaskItem[] get_List();
    public void set_List(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_MatchFileNameOnly();
    [CompilerGeneratedAttribute]
public void set_MatchFileNameOnly(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ItemFound();
    [CompilerGeneratedAttribute]
public void set_ItemFound(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_ItemSpecToFind();
    [CompilerGeneratedAttribute]
public void set_ItemSpecToFind(string value);
    [CompilerGeneratedAttribute]
public bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public bool get_FindLastMatch();
    [CompilerGeneratedAttribute]
public void set_FindLastMatch(bool value);
    public virtual bool Execute();
    private bool IsMatchingItem(StringComparison comparison, ITaskItem item);
}
public class Microsoft.Build.Tasks.FindInvalidProjectReferences : TaskExtension {
    private static Regex s_platformMonikerFormat;
    private static string ReferencePlatformMonikerMetadata;
    private static string PlatformSimpleNameGroup;
    private static string PlatformVersionGroup;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <InvalidReferences>k__BackingField;
    public ITaskItem[] ProjectReferences { get; public set; }
    [RequiredAttribute]
public string TargetPlatformVersion { get; public set; }
    [RequiredAttribute]
public string TargetPlatformIdentifier { get; public set; }
    [OutputAttribute]
public ITaskItem[] InvalidReferences { get; private set; }
    private static FindInvalidProjectReferences();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ProjectReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InvalidReferences();
    [CompilerGeneratedAttribute]
private void set_InvalidReferences(ITaskItem[] value);
    public virtual bool Execute();
    private static bool ParseMoniker(string reference, String& platformIdentity, Version& platformVersion);
}
public class Microsoft.Build.Tasks.FindUnderPath : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpdateToAbsolutePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <InPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutOfPath>k__BackingField;
    [RequiredAttribute]
public ITaskItem Path { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public bool UpdateToAbsolutePaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] InPath { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutOfPath { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_UpdateToAbsolutePaths();
    [CompilerGeneratedAttribute]
public void set_UpdateToAbsolutePaths(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InPath();
    [CompilerGeneratedAttribute]
public void set_InPath(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutOfPath();
    [CompilerGeneratedAttribute]
public void set_OutOfPath(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FormatUrl : TaskExtension {
    [CompilerGeneratedAttribute]
private string <InputUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputUrl>k__BackingField;
    public string InputUrl { get; public set; }
    [OutputAttribute]
public string OutputUrl { get; public set; }
    [CompilerGeneratedAttribute]
public string get_InputUrl();
    [CompilerGeneratedAttribute]
public void set_InputUrl(string value);
    [CompilerGeneratedAttribute]
public string get_OutputUrl();
    [CompilerGeneratedAttribute]
public void set_OutputUrl(string value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.FormatVersion : TaskExtension {
    private _FormatType _formatType;
    [CompilerGeneratedAttribute]
private string <OutputVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [OutputAttribute]
public string OutputVersion { get; public set; }
    public string FormatType { get; public set; }
    public int Revision { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OutputVersion();
    [CompilerGeneratedAttribute]
public void set_OutputVersion(string value);
    [CompilerGeneratedAttribute]
public string get_FormatType();
    [CompilerGeneratedAttribute]
public void set_FormatType(string value);
    [CompilerGeneratedAttribute]
public int get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(int value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public virtual bool Execute();
    private bool ValidateInputs();
}
internal class Microsoft.Build.Tasks.FrameworkPathResolver : Resolver {
    private String[] _frameworkPaths;
    private InstalledAssemblies _installedAssemblies;
    public FrameworkPathResolver(String[] frameworkPaths, InstalledAssemblies installedAssemblies, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
    internal static AssemblyNameExtension GetHighestVersionInRedist(InstalledAssemblies installedAssemblies, AssemblyNameExtension assemblyName);
}
internal class Microsoft.Build.Tasks.GacResolver : Resolver {
    private GetAssemblyPathInGac _getAssemblyPathInGac;
    public GacResolver(ProcessorArchitecture targetProcessorArchitecture, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion, GetAssemblyPathInGac getAssemblyPathInGac);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
[SupportedOSPlatform("windows")]
public class Microsoft.Build.Tasks.GenerateApplicationManifest : GenerateManifestBase {
    private ITaskItem[] _dependencies;
    private ITaskItem[] _files;
    private ITaskItem[] _isolatedComReferences;
    private _ManifestType _manifestType;
    private ITaskItem[] _fileAssociations;
    private bool _useApplicationTrust;
    [CompilerGeneratedAttribute]
private string <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HostInBrowser>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <IconFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManifestType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Publisher>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresMinimumFramework35SP1>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuiteName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkSubset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <TrustInfoFile>k__BackingField;
    public string ClrVersion { get; public set; }
    public ITaskItem ConfigFile { get; public set; }
    public ITaskItem[] Dependencies { get; public set; }
    public string ErrorReportUrl { get; public set; }
    public ITaskItem[] FileAssociations { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public bool HostInBrowser { get; public set; }
    public ITaskItem IconFile { get; public set; }
    public ITaskItem[] IsolatedComReferences { get; public set; }
    public string ManifestType { get; public set; }
    public string OSVersion { get; public set; }
    public string Product { get; public set; }
    public string Publisher { get; public set; }
    public bool RequiresMinimumFramework35SP1 { get; public set; }
    public string SuiteName { get; public set; }
    public string SupportUrl { get; public set; }
    public string TargetFrameworkSubset { get; public set; }
    public string TargetFrameworkProfile { get; public set; }
    public ITaskItem TrustInfoFile { get; public set; }
    public bool UseApplicationTrust { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClrVersion();
    [CompilerGeneratedAttribute]
public void set_ClrVersion(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(ITaskItem value);
    public ITaskItem[] get_Dependencies();
    public void set_Dependencies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportUrl();
    [CompilerGeneratedAttribute]
public void set_ErrorReportUrl(string value);
    public ITaskItem[] get_FileAssociations();
    public void set_FileAssociations(ITaskItem[] value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_HostInBrowser();
    [CompilerGeneratedAttribute]
public void set_HostInBrowser(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_IconFile();
    [CompilerGeneratedAttribute]
public void set_IconFile(ITaskItem value);
    public ITaskItem[] get_IsolatedComReferences();
    public void set_IsolatedComReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_ManifestType();
    [CompilerGeneratedAttribute]
public void set_ManifestType(string value);
    [CompilerGeneratedAttribute]
public string get_OSVersion();
    [CompilerGeneratedAttribute]
public void set_OSVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Product();
    [CompilerGeneratedAttribute]
public void set_Product(string value);
    [CompilerGeneratedAttribute]
public string get_Publisher();
    [CompilerGeneratedAttribute]
public void set_Publisher(string value);
    [CompilerGeneratedAttribute]
public bool get_RequiresMinimumFramework35SP1();
    [CompilerGeneratedAttribute]
public void set_RequiresMinimumFramework35SP1(bool value);
    [CompilerGeneratedAttribute]
public string get_SuiteName();
    [CompilerGeneratedAttribute]
public void set_SuiteName(string value);
    [CompilerGeneratedAttribute]
public string get_SupportUrl();
    [CompilerGeneratedAttribute]
public void set_SupportUrl(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkSubset();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkSubset(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkProfile();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkProfile(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_TrustInfoFile();
    [CompilerGeneratedAttribute]
public void set_TrustInfoFile(ITaskItem value);
    public bool get_UseApplicationTrust();
    public void set_UseApplicationTrust(bool value);
    public virtual bool Execute();
    protected virtual Type GetObjectType();
    protected virtual bool OnManifestLoaded(Manifest manifest);
    protected virtual bool OnManifestResolved(Manifest manifest);
    private bool BuildApplicationManifest(ApplicationManifest manifest);
    private bool AddIsolatedComReferences(ApplicationManifest manifest);
    private bool AddClickOnceFileAssociations(ApplicationManifest manifest);
    private bool AddClickOnceFiles(ApplicationManifest manifest);
    protected internal virtual bool ValidateInputs();
    private bool BuildResolvedSettings(ApplicationManifest manifest);
    private static AssemblyIdentity CreateAssemblyIdentity(String[] values);
    private static void EnsureAssemblyReferenceExists(ApplicationManifest manifest, AssemblyIdentity identity);
    private bool GetRequestedExecutionLevel(String& requestedExecutionLevel);
}
public class Microsoft.Build.Tasks.GenerateBindingRedirects : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <SuggestedRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AppConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputAppConfigFile>k__BackingField;
    public ITaskItem[] SuggestedRedirects { get; public set; }
    public ITaskItem AppConfigFile { get; public set; }
    public string TargetName { get; public set; }
    [OutputAttribute]
public ITaskItem OutputAppConfigFile { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SuggestedRedirects();
    [CompilerGeneratedAttribute]
public void set_SuggestedRedirects(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AppConfigFile();
    [CompilerGeneratedAttribute]
public void set_AppConfigFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public void set_TargetName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputAppConfigFile();
    [CompilerGeneratedAttribute]
public void set_OutputAppConfigFile(ITaskItem value);
    public virtual bool Execute();
    private static bool IsMatch(AssemblyName suggestedRedirect, string name, string culture, string publicKeyToken);
    private static bool ByteArrayMatchesString(Byte[] a, string s);
    private void UpdateExistingBindingRedirects(XElement runtimeNode, IDictionary`2<AssemblyName, string> redirects);
    private XDocument LoadAppConfig(ITaskItem appConfigItem);
    private IDictionary`2<AssemblyName, string> ParseSuggestedRedirects();
}
public class Microsoft.Build.Tasks.GenerateBootstrapper : TaskExtension {
    [CompilerGeneratedAttribute]
private string <ApplicationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplicationRequiresElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <BootstrapperItems>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComponentsLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComponentsUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FallbackCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Validate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BootstrapperKeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BootstrapperComponentFiles>k__BackingField;
    public string ApplicationName { get; public set; }
    public string ApplicationFile { get; public set; }
    public bool ApplicationRequiresElevation { get; public set; }
    public string ApplicationUrl { get; public set; }
    public ITaskItem[] BootstrapperItems { get; public set; }
    public string ComponentsLocation { get; public set; }
    public string ComponentsUrl { get; public set; }
    public bool CopyComponents { get; public set; }
    public string Culture { get; public set; }
    public string FallbackCulture { get; public set; }
    public string OutputPath { get; public set; }
    public string Path { get; public set; }
    public string SupportUrl { get; public set; }
    public string VisualStudioVersion { get; public set; }
    public bool Validate { get; public set; }
    [OutputAttribute]
public string BootstrapperKeyFile { get; public set; }
    [OutputAttribute]
public String[] BootstrapperComponentFiles { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationName();
    [CompilerGeneratedAttribute]
public void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationFile();
    [CompilerGeneratedAttribute]
public void set_ApplicationFile(string value);
    [CompilerGeneratedAttribute]
public bool get_ApplicationRequiresElevation();
    [CompilerGeneratedAttribute]
public void set_ApplicationRequiresElevation(bool value);
    [CompilerGeneratedAttribute]
public string get_ApplicationUrl();
    [CompilerGeneratedAttribute]
public void set_ApplicationUrl(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_BootstrapperItems();
    [CompilerGeneratedAttribute]
public void set_BootstrapperItems(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_ComponentsLocation();
    [CompilerGeneratedAttribute]
public void set_ComponentsLocation(string value);
    [CompilerGeneratedAttribute]
public string get_ComponentsUrl();
    [CompilerGeneratedAttribute]
public void set_ComponentsUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_CopyComponents();
    [CompilerGeneratedAttribute]
public void set_CopyComponents(bool value);
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(string value);
    [CompilerGeneratedAttribute]
public string get_FallbackCulture();
    [CompilerGeneratedAttribute]
public void set_FallbackCulture(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_SupportUrl();
    [CompilerGeneratedAttribute]
public void set_SupportUrl(string value);
    [CompilerGeneratedAttribute]
public string get_VisualStudioVersion();
    [CompilerGeneratedAttribute]
public void set_VisualStudioVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_Validate();
    [CompilerGeneratedAttribute]
public void set_Validate(bool value);
    [CompilerGeneratedAttribute]
public string get_BootstrapperKeyFile();
    [CompilerGeneratedAttribute]
public void set_BootstrapperKeyFile(string value);
    [CompilerGeneratedAttribute]
public String[] get_BootstrapperComponentFiles();
    [CompilerGeneratedAttribute]
public void set_BootstrapperComponentFiles(String[] value);
    public virtual bool Execute();
    private ComponentsLocation ConvertStringToComponentsLocation(string parameterValue);
}
[SupportedOSPlatform("windows")]
public class Microsoft.Build.Tasks.GenerateDeploymentManifest : GenerateManifestBase {
    private Nullable`1<bool> _createDesktopShortcut;
    private Nullable`1<bool> _disallowUrlActivation;
    private string _errorReportUrl;
    private Nullable`1<bool> _install;
    private Nullable`1<bool> _mapFileExtensions;
    private string _suiteName;
    private Nullable`1<bool> _trustUrlParameters;
    private Nullable`1<bool> _updateEnabled;
    private Nullable`1<int> _updateInterval;
    private Nullable`1<UpdateMode> _updateMode;
    private Nullable`1<UpdateUnit> _updateUnit;
    [CompilerGeneratedAttribute]
private string <DeploymentUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinimumRequiredVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Publisher>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SupportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UpdateUnit>k__BackingField;
    public bool CreateDesktopShortcut { get; public set; }
    public string DeploymentUrl { get; public set; }
    public bool DisallowUrlActivation { get; public set; }
    public string ErrorReportUrl { get; public set; }
    public bool Install { get; public set; }
    public string MinimumRequiredVersion { get; public set; }
    public bool MapFileExtensions { get; public set; }
    public string Product { get; public set; }
    public string Publisher { get; public set; }
    public string SuiteName { get; public set; }
    public string SupportUrl { get; public set; }
    public bool TrustUrlParameters { get; public set; }
    public bool UpdateEnabled { get; public set; }
    public int UpdateInterval { get; public set; }
    public string UpdateMode { get; public set; }
    public string UpdateUnit { get; public set; }
    public bool get_CreateDesktopShortcut();
    public void set_CreateDesktopShortcut(bool value);
    [CompilerGeneratedAttribute]
public string get_DeploymentUrl();
    [CompilerGeneratedAttribute]
public void set_DeploymentUrl(string value);
    public bool get_DisallowUrlActivation();
    public void set_DisallowUrlActivation(bool value);
    public string get_ErrorReportUrl();
    public void set_ErrorReportUrl(string value);
    public bool get_Install();
    public void set_Install(bool value);
    [CompilerGeneratedAttribute]
public string get_MinimumRequiredVersion();
    [CompilerGeneratedAttribute]
public void set_MinimumRequiredVersion(string value);
    public bool get_MapFileExtensions();
    public void set_MapFileExtensions(bool value);
    [CompilerGeneratedAttribute]
public string get_Product();
    [CompilerGeneratedAttribute]
public void set_Product(string value);
    [CompilerGeneratedAttribute]
public string get_Publisher();
    [CompilerGeneratedAttribute]
public void set_Publisher(string value);
    public string get_SuiteName();
    public void set_SuiteName(string value);
    [CompilerGeneratedAttribute]
public string get_SupportUrl();
    [CompilerGeneratedAttribute]
public void set_SupportUrl(string value);
    public bool get_TrustUrlParameters();
    public void set_TrustUrlParameters(bool value);
    public bool get_UpdateEnabled();
    public void set_UpdateEnabled(bool value);
    public int get_UpdateInterval();
    public void set_UpdateInterval(int value);
    [CompilerGeneratedAttribute]
public string get_UpdateMode();
    [CompilerGeneratedAttribute]
public void set_UpdateMode(string value);
    [CompilerGeneratedAttribute]
public string get_UpdateUnit();
    [CompilerGeneratedAttribute]
public void set_UpdateUnit(string value);
    private bool BuildResolvedSettings(DeployManifest manifest);
    public virtual bool Execute();
    protected virtual Type GetObjectType();
    protected virtual bool OnManifestLoaded(Manifest manifest);
    protected virtual bool OnManifestResolved(Manifest manifest);
    private bool BuildDeployManifest(DeployManifest manifest);
    protected internal virtual bool ValidateInputs();
}
[SupportedOSPlatform("windows")]
public class Microsoft.Build.Tasks.GenerateLauncher : TaskExtension {
    private static string LAUNCHER_EXE;
    private static string ENGINE_PATH;
    [CompilerGeneratedAttribute]
private ITaskItem <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LauncherPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputEntryPoint>k__BackingField;
    public ITaskItem EntryPoint { get; public set; }
    public string LauncherPath { get; public set; }
    public string OutputPath { get; public set; }
    public string VisualStudioVersion { get; public set; }
    public string AssemblyName { get; public set; }
    [OutputAttribute]
public ITaskItem OutputEntryPoint { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_LauncherPath();
    [CompilerGeneratedAttribute]
public void set_LauncherPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_VisualStudioVersion();
    [CompilerGeneratedAttribute]
public void set_VisualStudioVersion(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputEntryPoint();
    [CompilerGeneratedAttribute]
public void set_OutputEntryPoint(ITaskItem value);
    public virtual bool Execute();
}
public abstract class Microsoft.Build.Tasks.GenerateManifestBase : Task {
    private string _processorArchitecture;
    private int _startTime;
    private string _targetFrameworkVersion;
    private Manifest _manifest;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <InputManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LauncherBasedDeployment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    public string AssemblyName { get; public set; }
    public string AssemblyVersion { get; public set; }
    public string Description { get; public set; }
    public ITaskItem EntryPoint { get; public set; }
    public ITaskItem InputManifest { get; public set; }
    public bool LauncherBasedDeployment { get; public set; }
    public int MaxTargetPath { get; public set; }
    [OutputAttribute]
public ITaskItem OutputManifest { get; public set; }
    public string Platform { get; public set; }
    public string TargetCulture { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    protected abstract virtual bool OnManifestLoaded(Manifest manifest);
    protected abstract virtual bool OnManifestResolved(Manifest manifest);
    protected abstract virtual Type GetObjectType();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_InputManifest();
    [CompilerGeneratedAttribute]
public void set_InputManifest(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_LauncherBasedDeployment();
    [CompilerGeneratedAttribute]
public void set_LauncherBasedDeployment(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxTargetPath();
    [CompilerGeneratedAttribute]
public void set_MaxTargetPath(int value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputManifest();
    [CompilerGeneratedAttribute]
public void set_OutputManifest(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public string get_TargetCulture();
    [CompilerGeneratedAttribute]
public void set_TargetCulture(string value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMoniker(string value);
    protected internal AssemblyReference AddAssemblyNameFromItem(ITaskItem item, AssemblyReferenceType referenceType);
    protected internal AssemblyReference AddAssemblyFromItem(ITaskItem item);
    protected internal AssemblyReference AddEntryPointFromItem(ITaskItem item, AssemblyReferenceType referenceType);
    protected internal FileReference AddFileFromItem(ITaskItem item);
    private AssemblyIdentity CreateAssemblyIdentity(AssemblyIdentity baseIdentity, AssemblyIdentity entryPointIdentity);
    public virtual bool Execute();
    private bool BuildManifest();
    protected internal FileReference FindFileFromItem(ITaskItem item);
    private string GetDefaultFileName();
    private AssemblyType GetItemAssemblyType(ITaskItem item);
    private static bool IsEmbedInteropEnabledForAssembly(ITaskItem item);
    private DependencyType GetItemDependencyType(ITaskItem item);
    private string GetOutputPath();
    private bool InitializeManifest(Type manifestType);
    private bool ResolveFiles();
    private bool ResolveIdentity();
    private void SetItemAttributes(ITaskItem item, BaseReference file);
    protected internal virtual bool ValidateInputs();
    protected internal virtual bool ValidateOutput();
    private bool WriteManifest();
}
[RequiredRuntimeAttribute("v2.0")]
public class Microsoft.Build.Tasks.GenerateResource : TaskExtension {
    private ResGenDependencies _cache;
    private ITaskItem[] _sources;
    private bool _useSourcePath;
    private ITaskItem[] _references;
    private ITaskItem[] _additionalInputs;
    private ITaskItem _stateFile;
    private ITaskItem[] _outputResources;
    private ArrayList _unsuccessfullyCreatedOutFiles;
    private ArrayList _filesWritten;
    private string _stronglyTypedLanguage;
    private string _stronglyTypedNamespace;
    private string _stronglyTypedManifestPrefix;
    private string _stronglyTypedClassName;
    private string _stronglyTypedFileName;
    private bool _publicClass;
    private bool _stronglyTypedResourceSuccessfullyCreated;
    private bool _neverLockTypeAssemblies;
    private string _newestUncorrelatedInput;
    private DateTime _newestUncorrelatedInputWriteTime;
    private string _sdkToolsPath;
    private bool _executeAsTool;
    private string _resgenPath;
    private Dictionary`2<string, Type> _typeTable;
    private Dictionary`2<string, string> _aliases;
    private static int s_maximumCommandLength;
    private ITaskItem[] _excludedInputPaths;
    private List`1<ITaskItem> _remotedTaskItems;
    private List`1<ITaskItem> _satelliteInputs;
    [CompilerGeneratedAttribute]
private bool <UsePreserializedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WarnOnBinaryFormatterUse>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExtractResWFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EnvironmentVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    private static bool AllowMOTW;
    private static string CLSID_InternetSecurityManager;
    private static UInt32 ZoneInternet;
    private static IInternetSecurityManager internetSecurityManager;
    private static Char[] s_specialChars;
    [RequiredAttribute]
[OutputAttribute]
public ITaskItem[] Sources { get; public set; }
    public bool UseSourcePath { get; public set; }
    public ITaskItem[] References { get; public set; }
    public bool UsePreserializedResources { get; public set; }
    public ITaskItem[] AdditionalInputs { get; public set; }
    public ITaskItem StateFile { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputResources { get; public set; }
    [OutputAttribute]
public ITaskItem[] FilesWritten { get; }
    public string StronglyTypedLanguage { get; public set; }
    public bool WarnOnBinaryFormatterUse { get; public set; }
    public string StronglyTypedNamespace { get; public set; }
    public string StronglyTypedManifestPrefix { get; public set; }
    [OutputAttribute]
public string StronglyTypedClassName { get; public set; }
    [OutputAttribute]
public string StronglyTypedFileName { get; public set; }
    public bool PublicClass { get; public set; }
    public bool ExtractResWFiles { get; public set; }
    public bool NeverLockTypeAssemblies { get; public set; }
    public string SdkToolsPath { get; public set; }
    public bool ExecuteAsTool { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public ITaskItem[] ExcludedInputPaths { get; public set; }
    public bool MinimalRebuildFromTracking { get; public set; }
    public bool TrackFileAccess { get; public set; }
    public ITaskItem[] TLogReadFiles { get; }
    public ITaskItem[] TLogWriteFiles { get; }
    public string TrackerLogDirectory { get; public set; }
    public string ToolArchitecture { get; public set; }
    public string TrackerFrameworkPath { get; public set; }
    public string TrackerSdkPath { get; public set; }
    public string OutputDirectory { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    private static GenerateResource();
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_UseSourcePath(bool value);
    public bool get_UseSourcePath();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public bool get_UsePreserializedResources();
    [CompilerGeneratedAttribute]
public void set_UsePreserializedResources(bool value);
    public void set_AdditionalInputs(ITaskItem[] value);
    public ITaskItem[] get_AdditionalInputs();
    public void set_StateFile(ITaskItem value);
    public ITaskItem get_StateFile();
    public void set_OutputResources(ITaskItem[] value);
    public ITaskItem[] get_OutputResources();
    public ITaskItem[] get_FilesWritten();
    public void set_StronglyTypedLanguage(string value);
    public string get_StronglyTypedLanguage();
    [CompilerGeneratedAttribute]
public bool get_WarnOnBinaryFormatterUse();
    [CompilerGeneratedAttribute]
public void set_WarnOnBinaryFormatterUse(bool value);
    public void set_StronglyTypedNamespace(string value);
    public string get_StronglyTypedNamespace();
    public void set_StronglyTypedManifestPrefix(string value);
    public string get_StronglyTypedManifestPrefix();
    public void set_StronglyTypedClassName(string value);
    public string get_StronglyTypedClassName();
    public void set_StronglyTypedFileName(string value);
    public string get_StronglyTypedFileName();
    public void set_PublicClass(bool value);
    public bool get_PublicClass();
    [CompilerGeneratedAttribute]
public bool get_ExtractResWFiles();
    [CompilerGeneratedAttribute]
public void set_ExtractResWFiles(bool value);
    public void set_NeverLockTypeAssemblies(bool value);
    public bool get_NeverLockTypeAssemblies();
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    public void set_ExecuteAsTool(bool value);
    public bool get_ExecuteAsTool();
    [CompilerGeneratedAttribute]
public String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public void set_EnvironmentVariables(String[] value);
    public ITaskItem[] get_ExcludedInputPaths();
    public void set_ExcludedInputPaths(ITaskItem[] value);
    public bool get_MinimalRebuildFromTracking();
    public void set_MinimalRebuildFromTracking(bool value);
    public bool get_TrackFileAccess();
    public void set_TrackFileAccess(bool value);
    public ITaskItem[] get_TLogReadFiles();
    public ITaskItem[] get_TLogWriteFiles();
    public string get_TrackerLogDirectory();
    public void set_TrackerLogDirectory(string value);
    public string get_ToolArchitecture();
    public void set_ToolArchitecture(string value);
    public string get_TrackerFrameworkPath();
    public void set_TrackerFrameworkPath(string value);
    public string get_TrackerSdkPath();
    public void set_TrackerSdkPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    private void LogResgenCommandLine(List`1<ITaskItem> inputFiles, List`1<ITaskItem> outputFiles);
    private void GenerateResGenCommandLineWithoutResources(CommandLineBuilderExtension resGenCommand);
    public virtual bool Execute();
    private bool IsDangerous(string filename);
    private static ITaskItem[] CloneValuesInThisAppDomain(IList`1<ITaskItem> remoteValues);
    private void RecordItemsForDisconnectIfNecessary(IEnumerable`1<ITaskItem> items);
    private bool ComputePathToResGen();
    private bool GenerateResourcesUsingResGen(List`1<ITaskItem> inputsToProcess, List`1<ITaskItem> outputsToProcess);
    private bool TransformResourceFilesUsingResGen(List`1<ITaskItem> inputsToProcess, List`1<ITaskItem> outputsToProcess);
    private int CalculateResourceBatchSize(List`1<ITaskItem> inputsToProcess, List`1<ITaskItem> outputsToProcess, string resourcelessCommand, int initialResourceIndex);
    private bool GenerateStronglyTypedResourceUsingResGen(List`1<ITaskItem> inputsToProcess, List`1<ITaskItem> outputsToProcess);
    private ResGen CreateResGenTaskWithDefaultParameters();
    private bool ValidateParameters();
    private void GetResourcesToProcess(List`1& inputsToProcess, List`1& outputsToProcess, List`1& cachedOutputFiles);
    private void AppendCachedOutputTaskItems(PortableLibraryFile library, List`1<ITaskItem> cachedOutputFiles);
    private bool ContainsDuplicates(IList`1<ITaskItem> originalList);
    private bool ShouldRebuildResgenOutputFile(string sourceFilePath, string outputFilePath);
    private bool NeedToRebuildSourceFile(string sourceFilePath, DateTime sourceTime, string outputFilePath, DateTime outputTime);
    private void GetStronglyTypedResourceToProcess(List`1& inputsToProcess, List`1& outputsToProcess);
    private void UpdateNewestUncorrelatedInputWriteTime();
    private bool NeedSeparateAppDomain();
    private bool NeedSeparateAppDomainBasedOnSerializedType(XmlReader reader);
    private bool DetermineWhetherSerializedObjectLoads(string data);
    private static Byte[] ByteArrayFromBase64WrappedString(string text);
    private bool CreateOutputResourcesNames();
    private void RemoveUnsuccessfullyCreatedResourcesFromOutputResources();
    private void RecordFilesWritten();
    private void ReadStateFile();
    private void WriteStateFile();
}
public class Microsoft.Build.Tasks.GenerateTrustInfo : TaskExtension {
    private static string Custom;
    [CompilerGeneratedAttribute]
private ITaskItem <BaseManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExcludedPermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetZone>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ApplicationDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <TrustInfoFile>k__BackingField;
    public ITaskItem BaseManifest { get; public set; }
    public string ExcludedPermissions { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    public string TargetZone { get; public set; }
    public ITaskItem[] ApplicationDependencies { get; public set; }
    [OutputAttribute]
[RequiredAttribute]
public ITaskItem TrustInfoFile { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_BaseManifest();
    [CompilerGeneratedAttribute]
public void set_BaseManifest(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_ExcludedPermissions();
    [CompilerGeneratedAttribute]
public void set_ExcludedPermissions(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_TargetZone();
    [CompilerGeneratedAttribute]
public void set_TargetZone(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ApplicationDependencies();
    [CompilerGeneratedAttribute]
public void set_ApplicationDependencies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_TrustInfoFile();
    [CompilerGeneratedAttribute]
public void set_TrustInfoFile(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.GetAssemblyIdentity : TaskExtension {
    private ITaskItem[] _assemblyFiles;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Assemblies>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] AssemblyFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Assemblies();
    [CompilerGeneratedAttribute]
public void set_Assemblies(ITaskItem[] value);
    private static string ByteArrayToHex(Byte[] a);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetAssemblyMetadata : MulticastDelegate {
    public GetAssemblyMetadata(object object, IntPtr method);
    public virtual void Invoke(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute);
    public virtual IAsyncResult BeginInvoke(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute, AsyncCallback callback, object object);
    public virtual void EndInvoke(AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkNameAttribute, IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyName : MulticastDelegate {
    public GetAssemblyName(object object, IntPtr method);
    public virtual AssemblyNameExtension Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual AssemblyNameExtension EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyPathInGac : MulticastDelegate {
    public GetAssemblyPathInGac(object object, IntPtr method);
    public virtual string Invoke(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
    public virtual IAsyncResult BeginInvoke(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAssemblyRuntimeVersion : MulticastDelegate {
    public GetAssemblyRuntimeVersion(object object, IntPtr method);
    public virtual string Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetAttributes : MulticastDelegate {
    public GetAttributes(object object, IntPtr method);
    public virtual FileAttributes Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileAttributes EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Tasks.GetCompatiblePlatform : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <AnnotatedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentProjectPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformLookupTable>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ITaskItem[] <AssignedProjectsWithPlatform>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] AnnotatedProjects { get; public set; }
    [RequiredAttribute]
public string CurrentProjectPlatform { get; public set; }
    public string PlatformLookupTable { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputAttribute]
public ITaskItem[] AssignedProjectsWithPlatform { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AnnotatedProjects();
    [CompilerGeneratedAttribute]
public void set_AnnotatedProjects(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_CurrentProjectPlatform();
    [CompilerGeneratedAttribute]
public void set_CurrentProjectPlatform(string value);
    [CompilerGeneratedAttribute]
public string get_PlatformLookupTable();
    [CompilerGeneratedAttribute]
public void set_PlatformLookupTable(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssignedProjectsWithPlatform();
    [CompilerGeneratedAttribute]
public void set_AssignedProjectsWithPlatform(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetFileHash : TaskExtension {
    internal static string _defaultFileHashAlgorithm;
    internal static string _hashEncodingHex;
    internal static string _hashEncodingBase64;
    internal static Dictionary`2<string, Func`1<HashAlgorithm>> SupportedAlgorithms;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MetadataName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Items>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public string Algorithm { get; public set; }
    public string MetadataName { get; public set; }
    public string HashEncoding { get; public set; }
    [OutputAttribute]
public string Hash { get; public set; }
    [OutputAttribute]
public ITaskItem[] Items { get; public set; }
    private static GetFileHash();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    [CompilerGeneratedAttribute]
public string get_MetadataName();
    [CompilerGeneratedAttribute]
public void set_MetadataName(string value);
    [CompilerGeneratedAttribute]
public string get_HashEncoding();
    [CompilerGeneratedAttribute]
public void set_HashEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Items();
    [CompilerGeneratedAttribute]
public void set_Items(ITaskItem[] value);
    public virtual bool Execute();
    internal static string EncodeHash(HashEncoding encoding, Byte[] hash);
    internal static bool TryParseHashEncoding(string value, HashEncoding& encoding);
    internal static Byte[] ComputeHash(Func`1<HashAlgorithm> algorithmFactory, string filePath);
}
public class Microsoft.Build.Tasks.GetFrameworkPath : TaskExtension {
    private static Lazy`1<string> s_path;
    private static Lazy`1<string> s_version11Path;
    private static Lazy`1<string> s_version20Path;
    private static Lazy`1<string> s_version30Path;
    private static Lazy`1<string> s_version35Path;
    private static Lazy`1<string> s_version40Path;
    private static Lazy`1<string> s_version45Path;
    private static Lazy`1<string> s_version451Path;
    private static Lazy`1<string> s_version452Path;
    private static Lazy`1<string> s_version46Path;
    private static Lazy`1<string> s_version461Path;
    private static Lazy`1<string> s_version462Path;
    private static Lazy`1<string> s_version47Path;
    private static Lazy`1<string> s_version471Path;
    private static Lazy`1<string> s_version472Path;
    private static Lazy`1<string> s_version48Path;
    [OutputAttribute]
public string Path { get; }
    [OutputAttribute]
public string FrameworkVersion11Path { get; }
    [OutputAttribute]
public string FrameworkVersion20Path { get; }
    [OutputAttribute]
public string FrameworkVersion30Path { get; }
    [OutputAttribute]
public string FrameworkVersion35Path { get; }
    [OutputAttribute]
public string FrameworkVersion40Path { get; }
    [OutputAttribute]
public string FrameworkVersion45Path { get; }
    [OutputAttribute]
public string FrameworkVersion451Path { get; }
    [OutputAttribute]
public string FrameworkVersion452Path { get; }
    [OutputAttribute]
public string FrameworkVersion46Path { get; }
    [OutputAttribute]
public string FrameworkVersion461Path { get; }
    [OutputAttribute]
public string FrameworkVersion462Path { get; }
    [OutputAttribute]
public string FrameworkVersion47Path { get; }
    [OutputAttribute]
public string FrameworkVersion471Path { get; }
    [OutputAttribute]
public string FrameworkVersion472Path { get; }
    [OutputAttribute]
public string FrameworkVersion48Path { get; }
    private static GetFrameworkPath();
    public virtual bool Execute();
    public string get_Path();
    public string get_FrameworkVersion11Path();
    public string get_FrameworkVersion20Path();
    public string get_FrameworkVersion30Path();
    public string get_FrameworkVersion35Path();
    public string get_FrameworkVersion40Path();
    public string get_FrameworkVersion45Path();
    public string get_FrameworkVersion451Path();
    public string get_FrameworkVersion452Path();
    public string get_FrameworkVersion46Path();
    public string get_FrameworkVersion461Path();
    public string get_FrameworkVersion462Path();
    public string get_FrameworkVersion47Path();
    public string get_FrameworkVersion471Path();
    public string get_FrameworkVersion472Path();
    public string get_FrameworkVersion48Path();
}
public class Microsoft.Build.Tasks.GetFrameworkSdkPath : TaskExtension {
    private static string s_path;
    private static string s_version20Path;
    private static string s_version35Path;
    private static string s_version40Path;
    private static string s_version45Path;
    private static string s_version451Path;
    private static string s_version46Path;
    private static string s_version461Path;
    [OutputAttribute]
public string Path { get; public set; }
    [OutputAttribute]
public string FrameworkSdkVersion20Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion35Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion40Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion45Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion451Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion46Path { get; }
    [OutputAttribute]
public string FrameworkSdkVersion461Path { get; }
    public string get_Path();
    public void set_Path(string value);
    public string get_FrameworkSdkVersion20Path();
    public string get_FrameworkSdkVersion35Path();
    public string get_FrameworkSdkVersion40Path();
    public string get_FrameworkSdkVersion45Path();
    public string get_FrameworkSdkVersion451Path();
    public string get_FrameworkSdkVersion46Path();
    public string get_FrameworkSdkVersion461Path();
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetGacEnumerator : MulticastDelegate {
    public GetGacEnumerator(object object, IntPtr method);
    public virtual IEnumerable`1<AssemblyNameExtension> Invoke(string strongName);
    public virtual IAsyncResult BeginInvoke(string strongName, AsyncCallback callback, object object);
    public virtual IEnumerable`1<AssemblyNameExtension> EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetInstalledSDKLocations : TaskExtension {
    internal static string DirectoryRootsMetadataName;
    internal static string ExtensionDirectoryRootsMetadataName;
    internal static string SDKNameMetadataName;
    internal static string RegistryRootMetadataName;
    private static string StaticSDKCacheKey;
    private string _targetPlatformVersion;
    private string _targetPlatformIdentifier;
    [CompilerGeneratedAttribute]
private string <SDKRegistryRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SDKDirectoryRoots>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SDKExtensionDirectoryRoots>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WarnWhenNoSDKsFound>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <InstalledSDKs>k__BackingField;
    [RequiredAttribute]
public string TargetPlatformVersion { get; public set; }
    [RequiredAttribute]
public string TargetPlatformIdentifier { get; public set; }
    public string SDKRegistryRoot { get; public set; }
    public String[] SDKDirectoryRoots { get; public set; }
    public String[] SDKExtensionDirectoryRoots { get; public set; }
    public bool WarnWhenNoSDKsFound { get; public set; }
    [OutputAttribute]
public ITaskItem[] InstalledSDKs { get; public set; }
    public string get_TargetPlatformVersion();
    public void set_TargetPlatformVersion(string value);
    public string get_TargetPlatformIdentifier();
    public void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_SDKRegistryRoot();
    [CompilerGeneratedAttribute]
public void set_SDKRegistryRoot(string value);
    [CompilerGeneratedAttribute]
public String[] get_SDKDirectoryRoots();
    [CompilerGeneratedAttribute]
public void set_SDKDirectoryRoots(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_SDKExtensionDirectoryRoots();
    [CompilerGeneratedAttribute]
public void set_SDKExtensionDirectoryRoots(String[] value);
    [CompilerGeneratedAttribute]
public bool get_WarnWhenNoSDKsFound();
    [CompilerGeneratedAttribute]
public void set_WarnWhenNoSDKsFound(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InstalledSDKs();
    [CompilerGeneratedAttribute]
public void set_InstalledSDKs(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.GetLastWriteTime : MulticastDelegate {
    public GetLastWriteTime(object object, IntPtr method);
    public virtual DateTime Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual DateTime EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.GetPathFromFusionName : MulticastDelegate {
    public GetPathFromFusionName(object object, IntPtr method);
    public virtual string Invoke(string strongName);
    public virtual IAsyncResult BeginInvoke(string strongName, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.GetReferenceAssemblyPaths : TaskExtension {
    private static string NET35SP1SentinelAssemblyName;
    private static Nullable`1<bool> s_net35SP1SentinelAssemblyFound;
    private IList`1<string> _tfmPaths;
    private IList`1<string> _tfmPathsNoProfile;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BypassFrameworkInstallChecks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressNotFoundError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMonikerDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkFallbackSearchPaths>k__BackingField;
    [OutputAttribute]
public String[] ReferenceAssemblyPaths { get; }
    [OutputAttribute]
public String[] FullFrameworkReferenceAssemblyPaths { get; }
    public string TargetFrameworkMoniker { get; public set; }
    public string RootPath { get; public set; }
    public bool BypassFrameworkInstallChecks { get; public set; }
    public bool SuppressNotFoundError { get; public set; }
    [OutputAttribute]
public string TargetFrameworkMonikerDisplayName { get; public set; }
    public string TargetFrameworkFallbackSearchPaths { get; public set; }
    public String[] get_ReferenceAssemblyPaths();
    public String[] get_FullFrameworkReferenceAssemblyPaths();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_RootPath();
    [CompilerGeneratedAttribute]
public void set_RootPath(string value);
    [CompilerGeneratedAttribute]
public bool get_BypassFrameworkInstallChecks();
    [CompilerGeneratedAttribute]
public void set_BypassFrameworkInstallChecks(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressNotFoundError();
    [CompilerGeneratedAttribute]
public void set_SuppressNotFoundError(bool value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMonikerDisplayName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMonikerDisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkFallbackSearchPaths();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkFallbackSearchPaths(string value);
    public virtual bool Execute();
    private IList`1<string> GetPaths(string rootPath, string targetFrameworkFallbackSearchPaths, FrameworkName frameworkmoniker);
}
public class Microsoft.Build.Tasks.GetSDKReferenceFiles : TaskExtension {
    private ITaskItem[] _resolvedSDKReferences;
    private HashSet`1<ResolvedReferenceAssembly> _resolvedReferences;
    private HashSet`1<ResolvedRedistFile> _resolveRedistFiles;
    private String[] _referenceExtensions;
    private ConcurrentDictionary`2<string, SDKInfo> _cacheFileForSDKs;
    private ConcurrentQueue`1<string> _exceptions;
    private GetAssemblyName _getAssemblyName;
    private GetAssemblyRuntimeVersion _getRuntimeVersion;
    private FileExists _fileExists;
    private bool _synchronous;
    private string _cacheFilePath;
    [CompilerGeneratedAttribute]
private bool <LogReferencesList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogRedistFilesList>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetSDKIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetSDKVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <RedistFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <CopyLocalFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogRedistConflictWithinSDKAsWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogRedistConflictBetweenSDKsAsWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogReferenceConflictWithinSDKAsWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogReferenceConflictBetweenSDKsAsWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogCacheFileExceptions>k__BackingField;
    public string CacheFileFolderPath { get; public set; }
    public ITaskItem[] ResolvedSDKReferences { get; public set; }
    public String[] ReferenceExtensions { get; public set; }
    public bool LogReferencesList { get; public set; }
    public bool LogRedistFilesList { get; public set; }
    public string TargetSDKIdentifier { get; public set; }
    public string TargetSDKVersion { get; public set; }
    public string TargetPlatformIdentifier { get; public set; }
    public string TargetPlatformVersion { get; public set; }
    [OutputAttribute]
public ITaskItem[] References { get; private set; }
    [OutputAttribute]
public ITaskItem[] RedistFiles { get; private set; }
    [OutputAttribute]
public ITaskItem[] CopyLocalFiles { get; private set; }
    public bool LogRedistConflictWithinSDKAsWarning { get; public set; }
    public bool LogRedistConflictBetweenSDKsAsWarning { get; public set; }
    public bool LogReferenceConflictWithinSDKAsWarning { get; public set; }
    public bool LogReferenceConflictBetweenSDKsAsWarning { get; public set; }
    public bool LogCacheFileExceptions { get; public set; }
    public string get_CacheFileFolderPath();
    public void set_CacheFileFolderPath(string value);
    public ITaskItem[] get_ResolvedSDKReferences();
    public void set_ResolvedSDKReferences(ITaskItem[] value);
    public String[] get_ReferenceExtensions();
    public void set_ReferenceExtensions(String[] value);
    [CompilerGeneratedAttribute]
public bool get_LogReferencesList();
    [CompilerGeneratedAttribute]
public void set_LogReferencesList(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogRedistFilesList();
    [CompilerGeneratedAttribute]
public void set_LogRedistFilesList(bool value);
    [CompilerGeneratedAttribute]
public string get_TargetSDKIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetSDKIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetSDKVersion();
    [CompilerGeneratedAttribute]
public void set_TargetSDKVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
private void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_RedistFiles();
    [CompilerGeneratedAttribute]
private void set_RedistFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_CopyLocalFiles();
    [CompilerGeneratedAttribute]
private void set_CopyLocalFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_LogRedistConflictWithinSDKAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogRedistConflictWithinSDKAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogRedistConflictBetweenSDKsAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogRedistConflictBetweenSDKsAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogReferenceConflictWithinSDKAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogReferenceConflictWithinSDKAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogReferenceConflictBetweenSDKsAsWarning();
    [CompilerGeneratedAttribute]
public void set_LogReferenceConflictBetweenSDKsAsWarning(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogCacheFileExceptions();
    [CompilerGeneratedAttribute]
public void set_LogCacheFileExceptions(bool value);
    public virtual bool Execute();
    internal bool Execute(GetAssemblyName getAssemblyName, GetAssemblyRuntimeVersion getRuntimeVersion, FileExists fileExists, bool synchronous);
    private void FindRedistFiles(ITaskItem resolvedSDKReference, string sdkIdentity, string targetedConfiguration, string targetedArchitecture);
    private void FindReferences(ITaskItem resolvedSDKReference, string sdkIdentity, string sdkName, string rootDirectory, string targetedConfiguration, string targetedArchitecture);
    private void GenerateOutputItems();
    private void GatherReferenceAssemblies(HashSet`1<ResolvedReferenceAssembly> resolvedFiles, ITaskItem sdkReference, string path, SDKInfo info);
    private void GatherRedistFiles(HashSet`1<ResolvedRedistFile> resolvedRedistFiles, ITaskItem sdkReference, string redistFilePath, SDKInfo info);
    private void PopulateReferencesForSDK(IEnumerable`1<ITaskItem> sdks);
    private String[] GetReferencePathsFromManifest(ITaskItem sdk);
}
internal static class Microsoft.Build.Tasks.GlobalAssemblyCache : object {
    internal static GetPathFromFusionName pathFromFusionName;
    internal static GetGacEnumerator gacEnumerator;
    private static Lazy`1<string> _gacPath;
    internal static string GacPath { get; }
    private static GlobalAssemblyCache();
    internal static string get_GacPath();
    private static string GetLocationImpl(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion);
    [SupportedOSPlatform("windows")]
internal static IEnumerable`1<AssemblyNameExtension> GetGacNativeEnumerator(string strongName);
    private static SortedDictionary`2<Version, SortedDictionary`2<AssemblyNameExtension, string>> GenerateListOfAssembliesByRuntime(string strongName, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntime, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion);
    internal static string RetrievePathFromFusionName(string strongName);
    private static string CheckForFullFusionNameInGac(AssemblyNameExtension assemblyName, string targetProcessorArchitecture, GetPathFromFusionName getPathFromFusionName);
    internal static string GetLocation(AssemblyNameExtension strongName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, bool fullFusionName, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion);
    internal static string GetLocation(IBuildEngine4 buildEngine, AssemblyNameExtension strongName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, bool fullFusionName, FileExists fileExists, GetPathFromFusionName getPathFromFusionName, GetGacEnumerator getGacEnumerator, bool specificVersion);
    internal static string GetGacPath();
}
public class Microsoft.Build.Tasks.Hash : TaskExtension {
    private static char ItemSeparatorCharacter;
    private static Encoding s_encoding;
    private static Byte[] s_itemSeparatorCharacterBytes;
    private static int ShaBufferSize;
    private static int MaxInputChunkLength;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ItemsToHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashResult>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] ItemsToHash { get; public set; }
    public bool IgnoreCase { get; public set; }
    [OutputAttribute]
public string HashResult { get; public set; }
    private static Hash();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ItemsToHash();
    [CompilerGeneratedAttribute]
public void set_ItemsToHash(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    [CompilerGeneratedAttribute]
public string get_HashResult();
    [CompilerGeneratedAttribute]
public void set_HashResult(string value);
    public virtual bool Execute();
    private HashAlgorithm CreateHashAlgorithm();
    private int AddBytesToShaBuffer(HashAlgorithm sha, Byte[] shaBuffer, int shaBufferPosition, int shaBufferSize, Byte[] byteBuffer, int byteCount);
}
internal enum Microsoft.Build.Tasks.HashEncoding : Enum {
    public int value__;
    public static HashEncoding Hex;
    public static HashEncoding Base64;
}
internal class Microsoft.Build.Tasks.HintPathResolver : Resolver {
    public HintPathResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("B5A95716-2053-4B70-9FBF-E4148EBA96BC")]
public interface Microsoft.Build.Tasks.Hosting.IAnalyzerHostObject {
    public abstract virtual bool SetAnalyzers(ITaskItem[] analyzers);
    public abstract virtual bool SetRuleSet(string ruleSetFile);
    public abstract virtual bool SetAdditionalFiles(ITaskItem[] additionalFiles);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("8520CC4D-64DC-4855-BE3F-4C28CCE048EE")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject {
    public abstract virtual bool IsDesignTime();
    public abstract virtual bool Compile();
    public abstract virtual void BeginInitialization();
    public abstract virtual bool EndInitialization(String& errorMessage, Int32& errorCode);
    public abstract virtual bool SetAdditionalLibPaths(String[] additionalLibPaths);
    public abstract virtual bool SetAddModules(String[] addModules);
    public abstract virtual bool SetAllowUnsafeBlocks(bool allowUnsafeBlocks);
    public abstract virtual bool SetBaseAddress(string baseAddress);
    public abstract virtual bool SetCheckForOverflowUnderflow(bool checkForOverflowUnderflow);
    public abstract virtual bool SetCodePage(int codePage);
    public abstract virtual bool SetDebugType(string debugType);
    public abstract virtual bool SetDefineConstants(string defineConstants);
    public abstract virtual bool SetDelaySign(bool delaySignExplicitlySet, bool delaySign);
    public abstract virtual bool SetDisabledWarnings(string disabledWarnings);
    public abstract virtual bool SetDocumentationFile(string documentationFile);
    public abstract virtual bool SetEmitDebugInformation(bool emitDebugInformation);
    public abstract virtual bool SetErrorReport(string errorReport);
    public abstract virtual bool SetFileAlignment(int fileAlignment);
    public abstract virtual bool SetGenerateFullPaths(bool generateFullPaths);
    public abstract virtual bool SetKeyContainer(string keyContainer);
    public abstract virtual bool SetKeyFile(string keyFile);
    public abstract virtual bool SetLangVersion(string langVersion);
    public abstract virtual bool SetLinkResources(ITaskItem[] linkResources);
    public abstract virtual bool SetMainEntryPoint(string targetType, string mainEntryPoint);
    public abstract virtual bool SetModuleAssemblyName(string moduleAssemblyName);
    public abstract virtual bool SetNoConfig(bool noConfig);
    public abstract virtual bool SetNoStandardLib(bool noStandardLib);
    public abstract virtual bool SetOptimize(bool optimize);
    public abstract virtual bool SetOutputAssembly(string outputAssembly);
    public abstract virtual bool SetPlatform(string platform);
    public abstract virtual bool SetPdbFile(string pdbFile);
    public abstract virtual bool SetReferences(ITaskItem[] references);
    public abstract virtual bool SetResources(ITaskItem[] resources);
    public abstract virtual bool SetResponseFiles(ITaskItem[] responseFiles);
    public abstract virtual bool SetSources(ITaskItem[] sources);
    public abstract virtual bool SetTargetType(string targetType);
    public abstract virtual bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
    public abstract virtual bool SetWarningLevel(int warningLevel);
    public abstract virtual bool SetWarningsAsErrors(string warningsAsErrors);
    public abstract virtual bool SetWarningsNotAsErrors(string warningsNotAsErrors);
    public abstract virtual bool SetWin32Icon(string win32Icon);
    public abstract virtual bool SetWin32Resource(string win32Resource);
    public abstract virtual bool IsUpToDate();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("D6D4E228-259A-4076-B5D0-0627338BCC10")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject2 {
    public abstract virtual bool SetWin32Manifest(string win32Manifest);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("F9353662-F1ED-4a23-A323-5F5047E85F5D")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject3 {
    public abstract virtual bool SetApplicationConfiguration(string applicationConfiguration);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("0DDB496F-C93C-492C-87F1-90B6FDBAA833")]
public interface Microsoft.Build.Tasks.Hosting.ICscHostObject4 {
    public abstract virtual bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
    public abstract virtual bool SetHighEntropyVA(bool highEntropyVA);
    public abstract virtual bool SetSubsystemVersion(string subsystemVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("7D7AC3BE-253A-40e8-A3FF-357D0DA7C47A")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject {
    public abstract virtual void BeginInitialization();
    public abstract virtual void EndInitialization();
    public abstract virtual bool IsDesignTime();
    public abstract virtual bool Compile();
    public abstract virtual bool SetAdditionalLibPaths(String[] additionalLibPaths);
    public abstract virtual bool SetAddModules(String[] addModules);
    public abstract virtual bool SetBaseAddress(string targetType, string baseAddress);
    public abstract virtual bool SetCodePage(int codePage);
    public abstract virtual bool SetDebugType(bool emitDebugInformation, string debugType);
    public abstract virtual bool SetDefineConstants(string defineConstants);
    public abstract virtual bool SetDelaySign(bool delaySign);
    public abstract virtual bool SetDisabledWarnings(string disabledWarnings);
    public abstract virtual bool SetDocumentationFile(string documentationFile);
    public abstract virtual bool SetErrorReport(string errorReport);
    public abstract virtual bool SetFileAlignment(int fileAlignment);
    public abstract virtual bool SetGenerateDocumentation(bool generateDocumentation);
    public abstract virtual bool SetImports(ITaskItem[] importsList);
    public abstract virtual bool SetKeyContainer(string keyContainer);
    public abstract virtual bool SetKeyFile(string keyFile);
    public abstract virtual bool SetLinkResources(ITaskItem[] linkResources);
    public abstract virtual bool SetMainEntryPoint(string mainEntryPoint);
    public abstract virtual bool SetNoConfig(bool noConfig);
    public abstract virtual bool SetNoStandardLib(bool noStandardLib);
    public abstract virtual bool SetNoWarnings(bool noWarnings);
    public abstract virtual bool SetOptimize(bool optimize);
    public abstract virtual bool SetOptionCompare(string optionCompare);
    public abstract virtual bool SetOptionExplicit(bool optionExplicit);
    public abstract virtual bool SetOptionStrict(bool optionStrict);
    public abstract virtual bool SetOptionStrictType(string optionStrictType);
    public abstract virtual bool SetOutputAssembly(string outputAssembly);
    public abstract virtual bool SetPlatform(string platform);
    public abstract virtual bool SetReferences(ITaskItem[] references);
    public abstract virtual bool SetRemoveIntegerChecks(bool removeIntegerChecks);
    public abstract virtual bool SetResources(ITaskItem[] resources);
    public abstract virtual bool SetResponseFiles(ITaskItem[] responseFiles);
    public abstract virtual bool SetRootNamespace(string rootNamespace);
    public abstract virtual bool SetSdkPath(string sdkPath);
    public abstract virtual bool SetSources(ITaskItem[] sources);
    public abstract virtual bool SetTargetCompactFramework(bool targetCompactFramework);
    public abstract virtual bool SetTargetType(string targetType);
    public abstract virtual bool SetTreatWarningsAsErrors(bool treatWarningsAsErrors);
    public abstract virtual bool SetWarningsAsErrors(string warningsAsErrors);
    public abstract virtual bool SetWarningsNotAsErrors(string warningsNotAsErrors);
    public abstract virtual bool SetWin32Icon(string win32Icon);
    public abstract virtual bool SetWin32Resource(string win32Resource);
    public abstract virtual bool IsUpToDate();
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("f59afc84-d102-48b1-a090-1b90c79d3e09")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject2 {
    public abstract virtual bool SetOptionInfer(bool optionInfer);
    public abstract virtual bool SetModuleAssemblyName(string moduleAssemblyName);
    public abstract virtual bool SetWin32Manifest(string win32Manifest);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("1186fe8f-8aba-48d6-8ce3-32ca42f53728")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject3 {
    public abstract virtual bool SetLanguageVersion(string languageVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("2AE3233C-8AB3-48A0-9ED9-6E3545B3C566")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject4 {
    public abstract virtual bool SetVBRuntime(string VBRuntime);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("5ACF41FF-6F2B-4623-8146-740C89212B21")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObject5 {
    public abstract virtual IVbcHostObjectFreeThreaded GetFreeThreadedHostObject();
    public abstract virtual int CompileAsync(IntPtr& buildSucceededEvent, IntPtr& buildFailedEvent);
    public abstract virtual int EndCompile(bool buildSuccess);
    public abstract virtual bool SetPlatformWith32BitPreference(string platformWith32BitPreference);
    public abstract virtual bool SetHighEntropyVA(bool highEntropyVA);
    public abstract virtual bool SetSubsystemVersion(string subsystemVersion);
}
[InterfaceTypeAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("ECCF972F-8C2D-4F51-9746-9288661DE2CB")]
public interface Microsoft.Build.Tasks.Hosting.IVbcHostObjectFreeThreaded {
    public abstract virtual bool Compile();
}
[GuidAttribute("E707DCDE-D1CD-11D2-BAB9-00C04F8ECEAE")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IAssemblyCache {
    public abstract virtual int UninstallAssembly();
    public abstract virtual UInt32 QueryAssemblyInfo(UInt32 dwFlags, string pszAssemblyName, ASSEMBLY_INFO& pAsmInfo);
    public abstract virtual int CreateAssemblyCacheItem();
    public abstract virtual int CreateAssemblyScavenger();
    public abstract virtual int InstallAssembly();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("21b8916c-f28e-11d2-a473-00c04f8ef448")]
internal interface Microsoft.Build.Tasks.IAssemblyEnum {
    public abstract virtual int GetNextAssembly(IntPtr pvReserved, IAssemblyName& ppName, int flags);
    public abstract virtual int Reset();
    public abstract virtual int Clone(IAssemblyEnum& ppEnum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")]
internal interface Microsoft.Build.Tasks.IAssemblyName {
    public abstract virtual int SetProperty(int PropertyId, IntPtr pvProperty, int cbProperty);
    public abstract virtual int GetProperty(int PropertyId, IntPtr pvProperty, Int32& pcbProperty);
    public abstract virtual int Finalize();
    public abstract virtual int GetDisplayName(StringBuilder pDisplayName, Int32& pccDisplayName, int displayFlags);
    public abstract virtual int Reserved(Guid& guid, object obj1, object obj2, string string1, long llFlags, IntPtr pvReserved, int cbReserved, IntPtr& ppv);
    public abstract virtual int GetName(Int32& pccBuffer, StringBuilder pwzName);
    public abstract virtual int GetVersion(Int32& versionHi, Int32& versionLow);
    public abstract virtual int IsEqual(IAssemblyName pAsmName, int cmpFlags);
    public abstract virtual int Clone(IAssemblyName& pAsmName);
}
[GuidAttribute("00000001-0000-0000-c000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IClassFactory {
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObject);
    public abstract virtual void LockServer(bool fLock);
}
internal interface Microsoft.Build.Tasks.IComReferenceResolver {
    public abstract virtual bool ResolveComClassicReference(TYPELIBATTR typeLibAttr, string outputDirectory, string wrapperType, string refName, ComReferenceWrapperInfo& wrapperInfo);
    public abstract virtual bool ResolveNetAssemblyReference(string assemblyName, String& assemblyPath);
    public abstract virtual bool ResolveComAssemblyReference(string assemblyName, String& assemblyPath);
}
[GuidAttribute("00020406-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.ICreateTypeLib {
    public abstract virtual void CreateTypeInfo();
    public abstract virtual void SetName();
    public abstract virtual void SetVersion();
    public abstract virtual void SetGuid();
    public abstract virtual void SetDocString();
    public abstract virtual void SetHelpFileName();
    public abstract virtual void SetHelpContext();
    public abstract virtual void SetLcid();
    public abstract virtual void SetLibFlags();
    public abstract virtual void SaveAllChanges();
}
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
public interface Microsoft.Build.Tasks.IFixedTypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, IntPtr& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(IntPtr hRef, IFixedTypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[GuidAttribute("EE62470B-E94B-424e-9B7C-2F00C9249F93")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IMetaDataAssemblyImport {
    public abstract virtual void GetAssemblyProps(UInt32 mdAsm, IntPtr& pPublicKeyPtr, UInt32& ucbPublicKeyPtr, UInt32& uHashAlg, Char[] strName, UInt32 cchNameIn, UInt32& cchNameRequired, IntPtr amdInfo, UInt32& dwFlags);
    public abstract virtual void GetAssemblyRefProps(UInt32 mdAsmRef, IntPtr& ppbPublicKeyOrToken, UInt32& pcbPublicKeyOrToken, Char[] strName, UInt32 cchNameIn, UInt32& pchNameOut, IntPtr amdInfo, IntPtr& ppbHashValue, UInt32& pcbHashValue, UInt32& pdwAssemblyRefFlags);
    public abstract virtual void GetFileProps(UInt32 mdFile, Char[] strName, UInt32 cchName, UInt32& cchNameRequired, IntPtr& bHashData, UInt32& cchHashBytes, UInt32& dwFileFlags);
    public abstract virtual void GetExportedTypeProps();
    public abstract virtual void GetManifestResourceProps();
    public abstract virtual void EnumAssemblyRefs(IntPtr& phEnum, UInt32[] asmRefs, UInt32 asmRefCount, UInt32& iFetched);
    public abstract virtual void EnumFiles(IntPtr& phEnum, UInt32[] fileRefs, UInt32 fileRefCount, UInt32& iFetched);
    public abstract virtual void EnumExportedTypes();
    public abstract virtual void EnumManifestResources();
    public abstract virtual void GetAssemblyFromScope(UInt32& mdAsm);
    public abstract virtual void FindExportedTypeByName();
    public abstract virtual void FindManifestResourceByName();
    public abstract virtual void CloseEnum(IntPtr phEnum);
    public abstract virtual void FindAssembliesByName();
}
[GuidAttribute("809c652e-7396-11d2-9771-00a0c9b4d50c")]
[InterfaceTypeAttribute("1")]
[TypeLibTypeAttribute("512")]
internal interface Microsoft.Build.Tasks.IMetaDataDispenser {
    public abstract virtual object DefineScope(Guid& rclsid, UInt32 dwCreateFlags, Guid& riid);
    public abstract virtual object OpenScope(string szScope, UInt32 dwOpenFlags, Guid& riid);
    public abstract virtual object OpenScopeOnMemory(IntPtr pData, UInt32 cbData, UInt32 dwOpenFlags, Guid& riid);
}
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IMetaDataImport {
    public abstract virtual void CloseEnum();
    public abstract virtual void CountEnum(IntPtr iRef, UInt32& ulCount);
    public abstract virtual void ResetEnum();
    public abstract virtual void EnumTypeDefs();
    public abstract virtual void EnumInterfaceImpls();
    public abstract virtual void EnumTypeRefs();
    public abstract virtual void FindTypeDefByName();
    public abstract virtual void GetScopeProps();
    public abstract virtual void GetModuleFromScope();
    public abstract virtual void GetTypeDefProps();
    public abstract virtual void GetInterfaceImplProps();
    public abstract virtual void GetTypeRefProps();
    public abstract virtual void ResolveTypeRef();
    public abstract virtual void EnumMembers();
    public abstract virtual void EnumMembersWithName();
    public abstract virtual void EnumMethods();
    public abstract virtual void EnumMethodsWithName();
    public abstract virtual void EnumFields();
    public abstract virtual void EnumFieldsWithName();
    public abstract virtual void EnumParams();
    public abstract virtual void EnumMemberRefs();
    public abstract virtual void EnumMethodImpls();
    public abstract virtual void EnumPermissionSets();
    public abstract virtual void FindMember();
    public abstract virtual void FindMethod();
    public abstract virtual void FindField();
    public abstract virtual void FindMemberRef();
    public abstract virtual void GetMethodProps();
    public abstract virtual void GetMemberRefProps();
    public abstract virtual void EnumProperties();
    public abstract virtual void EnumEvents();
    public abstract virtual void GetEventProps();
    public abstract virtual void EnumMethodSemantics();
    public abstract virtual void GetMethodSemantics();
    public abstract virtual void GetClassLayout();
    public abstract virtual void GetFieldMarshal();
    public abstract virtual void GetRVA();
    public abstract virtual void GetPermissionSetProps();
    public abstract virtual void GetSigFromToken();
    public abstract virtual void GetModuleRefProps();
    public abstract virtual void EnumModuleRefs();
    public abstract virtual void GetTypeSpecFromToken();
    public abstract virtual void GetNameFromToken();
    public abstract virtual void EnumUnresolvedMethods();
    public abstract virtual void GetUserString();
    public abstract virtual void GetPinvokeMap();
    public abstract virtual void EnumSignatures();
    public abstract virtual void EnumTypeSpecs();
    public abstract virtual void EnumUserStrings();
    public abstract virtual void GetParamForMethodIndex();
    public abstract virtual void EnumCustomAttributes();
    public abstract virtual void GetCustomAttributeProps();
    public abstract virtual void FindTypeRef();
    public abstract virtual void GetMemberProps();
    public abstract virtual void GetFieldProps();
    public abstract virtual void GetPropertyProps();
    public abstract virtual void GetParamProps();
    public abstract virtual void GetCustomAttributeByName();
    public abstract virtual void IsValidToken();
    public abstract virtual void GetNestedClassProps();
    public abstract virtual void GetNativeCallConvFromSig();
    public abstract virtual void IsGlobal();
}
[GuidAttribute("FCE5EFA0-8BBA-4f8e-A036-8F2022B08466")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.Build.Tasks.IMetaDataImport2 {
    public abstract virtual void CloseEnum();
    public abstract virtual void CountEnum();
    public abstract virtual void ResetEnum();
    public abstract virtual void EnumTypeDefs();
    public abstract virtual void EnumInterfaceImpls();
    public abstract virtual void EnumTypeRefs();
    public abstract virtual void FindTypeDefByName();
    public abstract virtual void GetScopeProps();
    public abstract virtual void GetModuleFromScope();
    public abstract virtual void GetTypeDefProps();
    public abstract virtual void GetInterfaceImplProps();
    public abstract virtual void GetTypeRefProps();
    public abstract virtual void ResolveTypeRef();
    public abstract virtual void EnumMembers();
    public abstract virtual void EnumMembersWithName();
    public abstract virtual void EnumMethods();
    public abstract virtual void EnumMethodsWithName();
    public abstract virtual void EnumFields();
    public abstract virtual void EnumFieldsWithName();
    public abstract virtual void EnumParams();
    public abstract virtual void EnumMemberRefs();
    public abstract virtual void EnumMethodImpls();
    public abstract virtual void EnumPermissionSets();
    public abstract virtual void FindMember();
    public abstract virtual void FindMethod();
    public abstract virtual void FindField();
    public abstract virtual void FindMemberRef();
    public abstract virtual void GetMethodProps();
    public abstract virtual void GetMemberRefProps();
    public abstract virtual void EnumProperties();
    public abstract virtual void EnumEvents();
    public abstract virtual void GetEventProps();
    public abstract virtual void EnumMethodSemantics();
    public abstract virtual void GetMethodSemantics();
    public abstract virtual void GetClassLayout();
    public abstract virtual void GetFieldMarshal();
    public abstract virtual void GetRVA();
    public abstract virtual void GetPermissionSetProps();
    public abstract virtual void GetSigFromToken();
    public abstract virtual void GetModuleRefProps();
    public abstract virtual void EnumModuleRefs();
    public abstract virtual void GetTypeSpecFromToken();
    public abstract virtual void GetNameFromToken();
    public abstract virtual void EnumUnresolvedMethods();
    public abstract virtual void GetUserString();
    public abstract virtual void GetPinvokeMap();
    public abstract virtual void EnumSignatures();
    public abstract virtual void EnumTypeSpecs();
    public abstract virtual void EnumUserStrings();
    public abstract virtual void GetParamForMethodIndex();
    public abstract virtual void EnumCustomAttributes();
    public abstract virtual void GetCustomAttributeProps();
    public abstract virtual void FindTypeRef();
    public abstract virtual void GetMemberProps();
    public abstract virtual void GetFieldProps();
    public abstract virtual void GetPropertyProps();
    public abstract virtual void GetParamProps();
    public abstract virtual int GetCustomAttributeByName(UInt32 mdTokenObj, string szName, IntPtr& ppData, UInt32& pDataSize);
    public abstract virtual void IsValidToken();
    public abstract virtual void GetNestedClassProps();
    public abstract virtual void GetNativeCallConvFromSig();
    public abstract virtual void IsGlobal();
    public abstract virtual void EnumGenericParams();
    public abstract virtual void GetGenericParamProps();
    public abstract virtual void GetMethodSpecProps();
    public abstract virtual void EnumGenericParamConstraints();
    public abstract virtual void GetGenericParamConstraintProps();
    public abstract virtual void GetPEKind(UInt32& pdwPEKind, UInt32& pdwMachine);
    public abstract virtual void GetVersionString(Char[] pwzBuf, UInt32 ccBufSize, UInt32& pccBufSize);
}
internal class Microsoft.Build.Tasks.InstalledAssemblies : object {
    private RedistList _redistList;
    internal InstalledAssemblies(RedistList redistList);
    internal void GetInfo(AssemblyNameExtension assemblyName, Version& unifiedVersion, Boolean& isPrerequisite, Nullable`1& isRedistRoot, String& redistName);
    internal AssemblyNameExtension RemapAssemblyExtension(AssemblyNameExtension assemblyName);
    internal AssemblyEntry FindHighestVersionInRedistList(AssemblyNameExtension assemblyName);
    internal bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName);
    internal IEnumerable`1<AssemblyEntry> FindAssemblyNameFromSimpleName(string simpleName);
}
internal class Microsoft.Build.Tasks.InstalledSDKResolver : Resolver {
    private Dictionary`2<string, ITaskItem> _resolvedSDKs;
    public InstalledSDKResolver(Dictionary`2<string, ITaskItem> resolvedSDKs, string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
internal class Microsoft.Build.Tasks.InteropUtilities.RCWForCurrentContext`1 : object {
    private T _rcwForCurrentCtx;
    private bool _shouldReleaseRCW;
    public T RCW { get; }
    public RCWForCurrentContext`1(T rcw);
    protected virtual override void Finalize();
    public T get_RCW();
    public sealed virtual void Dispose();
    private void CleanupComObject();
}
internal class Microsoft.Build.Tasks.InvalidParameterValueException : Exception {
    [CompilerGeneratedAttribute]
private string <ParamName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActualValue>k__BackingField;
    public string ParamName { get; public set; }
    public string ActualValue { get; public set; }
    internal InvalidParameterValueException(string paramName, string actualValue, string message);
    internal InvalidParameterValueException(string paramName, string actualValue, string message, Exception innerException);
    private InvalidParameterValueException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ParamName();
    [CompilerGeneratedAttribute]
public void set_ParamName(string value);
    [CompilerGeneratedAttribute]
public string get_ActualValue();
    [CompilerGeneratedAttribute]
public void set_ActualValue(string value);
}
internal class Microsoft.Build.Tasks.InvalidReferenceAssemblyNameException : Exception {
    [CompilerGeneratedAttribute]
private string <SourceItemSpec>k__BackingField;
    internal string SourceItemSpec { get; }
    internal InvalidReferenceAssemblyNameException(string sourceItemSpec);
    private InvalidReferenceAssemblyNameException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal string get_SourceItemSpec();
}
internal interface Microsoft.Build.Tasks.IResolveComReferenceTaskContract {
    public ITaskItem[] TypeLibNames { get; public set; }
    public ITaskItem[] TypeLibFiles { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public string WrapperOutputDirectory { get; public set; }
    public bool IncludeVersionInInteropName { get; public set; }
    public ITaskItem[] ResolvedAssemblyReferences { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public bool DelaySign { get; public set; }
    public bool NoClassMembers { get; public set; }
    public bool Silent { get; public set; }
    public string TargetProcessorArchitecture { get; public set; }
    public bool ExecuteAsTool { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedModules { get; public set; }
    public string SdkToolsPath { get; public set; }
    public string StateFile { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public abstract virtual ITaskItem[] get_TypeLibNames();
    public abstract virtual void set_TypeLibNames(ITaskItem[] value);
    public abstract virtual ITaskItem[] get_TypeLibFiles();
    public abstract virtual void set_TypeLibFiles(ITaskItem[] value);
    public abstract virtual String[] get_EnvironmentVariables();
    public abstract virtual void set_EnvironmentVariables(String[] value);
    public abstract virtual string get_WrapperOutputDirectory();
    public abstract virtual void set_WrapperOutputDirectory(string value);
    public abstract virtual bool get_IncludeVersionInInteropName();
    public abstract virtual void set_IncludeVersionInInteropName(bool value);
    public abstract virtual ITaskItem[] get_ResolvedAssemblyReferences();
    public abstract virtual void set_ResolvedAssemblyReferences(ITaskItem[] value);
    public abstract virtual string get_KeyContainer();
    public abstract virtual void set_KeyContainer(string value);
    public abstract virtual string get_KeyFile();
    public abstract virtual void set_KeyFile(string value);
    public abstract virtual bool get_DelaySign();
    public abstract virtual void set_DelaySign(bool value);
    public abstract virtual bool get_NoClassMembers();
    public abstract virtual void set_NoClassMembers(bool value);
    public abstract virtual bool get_Silent();
    public abstract virtual void set_Silent(bool value);
    public abstract virtual string get_TargetProcessorArchitecture();
    public abstract virtual void set_TargetProcessorArchitecture(string value);
    public abstract virtual bool get_ExecuteAsTool();
    public abstract virtual void set_ExecuteAsTool(bool value);
    public abstract virtual ITaskItem[] get_ResolvedFiles();
    public abstract virtual void set_ResolvedFiles(ITaskItem[] value);
    public abstract virtual ITaskItem[] get_ResolvedModules();
    public abstract virtual void set_ResolvedModules(ITaskItem[] value);
    public abstract virtual string get_SdkToolsPath();
    public abstract virtual void set_SdkToolsPath(string value);
    public abstract virtual string get_StateFile();
    public abstract virtual void set_StateFile(string value);
    public abstract virtual string get_TargetFrameworkVersion();
    public abstract virtual void set_TargetFrameworkVersion(string value);
}
internal interface Microsoft.Build.Tasks.ISGenTaskContract {
    [RequiredAttribute]
public string BuildAssemblyName { get; public set; }
    [RequiredAttribute]
public string BuildAssemblyPath { get; public set; }
    [RequiredAttribute]
public bool ShouldGenerateSerializer { get; public set; }
    [RequiredAttribute]
public bool UseProxyTypes { get; public set; }
    public bool UseKeep { get; public set; }
    public String[] References { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public bool DelaySign { get; public set; }
    [OutputAttribute]
public ITaskItem[] SerializationAssembly { get; public set; }
    public string SerializationAssemblyName { get; }
    public string SdkToolsPath { get; public set; }
    public string Platform { get; public set; }
    public String[] Types { get; public set; }
    public abstract virtual string get_BuildAssemblyName();
    public abstract virtual void set_BuildAssemblyName(string value);
    public abstract virtual string get_BuildAssemblyPath();
    public abstract virtual void set_BuildAssemblyPath(string value);
    public abstract virtual bool get_ShouldGenerateSerializer();
    public abstract virtual void set_ShouldGenerateSerializer(bool value);
    public abstract virtual bool get_UseProxyTypes();
    public abstract virtual void set_UseProxyTypes(bool value);
    public abstract virtual bool get_UseKeep();
    public abstract virtual void set_UseKeep(bool value);
    public abstract virtual String[] get_References();
    public abstract virtual void set_References(String[] value);
    public abstract virtual string get_KeyContainer();
    public abstract virtual void set_KeyContainer(string value);
    public abstract virtual string get_KeyFile();
    public abstract virtual void set_KeyFile(string value);
    public abstract virtual bool get_DelaySign();
    public abstract virtual void set_DelaySign(bool value);
    public abstract virtual ITaskItem[] get_SerializationAssembly();
    public abstract virtual void set_SerializationAssembly(ITaskItem[] value);
    public abstract virtual string get_SerializationAssemblyName();
    public abstract virtual string get_SdkToolsPath();
    public abstract virtual void set_SdkToolsPath(string value);
    public abstract virtual string get_Platform();
    public abstract virtual void set_Platform(string value);
    public abstract virtual String[] get_Types();
    public abstract virtual void set_Types(String[] value);
}
internal class Microsoft.Build.Tasks.IsWinMDFile : MulticastDelegate {
    public IsWinMDFile(object object, IntPtr method);
    public virtual bool Invoke(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd);
    public virtual IAsyncResult BeginInvoke(string fullpath, GetAssemblyRuntimeVersion getAssemblyRuntimeVersion, FileExists fileExists, String& imageRuntimeVersion, Boolean& isManagedWinmd, AsyncCallback callback, object object);
    public virtual bool EndInvoke(String& imageRuntimeVersion, Boolean& isManagedWinmd, IAsyncResult result);
}
public class Microsoft.Build.Tasks.LC : ToolTaskExtension {
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Sources { get; public set; }
    [OutputAttribute]
public ITaskItem OutputLicense { get; public set; }
    [RequiredAttribute]
public ITaskItem LicenseTarget { get; public set; }
    public string OutputDirectory { get; public set; }
    public ITaskItem[] ReferencedAssemblies { get; public set; }
    public bool NoLogo { get; public set; }
    public string SdkToolsPath { get; public set; }
    [RequiredAttribute]
public string TargetFrameworkVersion { get; public set; }
    protected string ToolName { get; }
    public void set_Sources(ITaskItem[] value);
    public ITaskItem[] get_Sources();
    public void set_OutputLicense(ITaskItem value);
    public ITaskItem get_OutputLicense();
    public void set_LicenseTarget(ITaskItem value);
    public ITaskItem get_LicenseTarget();
    public void set_OutputDirectory(string value);
    public string get_OutputDirectory();
    public void set_ReferencedAssemblies(ITaskItem[] value);
    public ITaskItem[] get_ReferencedAssemblies();
    public void set_NoLogo(bool value);
    public bool get_NoLogo();
    public void set_SdkToolsPath(string value);
    public string get_SdkToolsPath();
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkVersion(string value);
    protected virtual string get_ToolName();
    protected virtual bool ValidateParameters();
    protected virtual string GenerateFullPathToTool();
    private void AddCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Tasks.LockCheck : object {
    private static string RestartManagerDll;
    private static int CCH_RM_MAX_APP_NAME;
    private static int CCH_RM_MAX_SVC_NAME;
    private static int ERROR_SEM_TIMEOUT;
    private static int ERROR_BAD_ARGUMENTS;
    private static int ERROR_MAX_SESSIONS_REACHED;
    private static int ERROR_WRITE_FAULT;
    private static int ERROR_OUTOFMEMORY;
    private static int ERROR_MORE_DATA;
    private static int ERROR_ACCESS_DENIED;
    private static int ERROR_INVALID_HANDLE;
    private static int ERROR_CANCELLED;
    private static int RM_SESSION_KEY_LEN;
    private static int CCH_RM_SESSION_KEY;
    private static LockCheck();
    private static int RmRegisterResources(UInt32 pSessionHandle, UInt32 nFiles, String[] rgsFilenames, UInt32 nApplications, RM_UNIQUE_PROCESS[] rgApplications, UInt32 nServices, String[] rgsServiceNames);
    private static int RmStartSession(UInt32& pSessionHandle, int dwSessionFlags, Char* strSessionKey);
    private static int RmEndSession(UInt32 pSessionHandle);
    public static int RmGetList(UInt32 dwSessionHandle, UInt32& pnProcInfoNeeded, UInt32& pnProcInfo, RM_PROCESS_INFO[] rgAffectedApps, UInt32& lpdwRebootReasons);
    internal static string GetProcessesLockingFile(string filePath);
    internal static IEnumerable`1<ProcessInfo> GetLockingProcessInfos(String[] paths);
    private static Exception GetException(int res, string apiName, string message);
}
public class Microsoft.Build.Tasks.MakeDir : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <DirectoriesCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    private ITaskItem[] _directories;
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    [OutputAttribute]
public ITaskItem[] DirectoriesCreated { get; private set; }
    public bool FailIfNotIncremental { get; public set; }
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DirectoriesCreated();
    [CompilerGeneratedAttribute]
private void set_DirectoriesCreated(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public virtual bool Execute();
}
internal static class Microsoft.Build.Tasks.ManagedRuntimeVersionReader : object {
    public static string GetRuntimeVersion(string path);
    internal static string GetRuntimeVersion(BinaryReader sr);
    private static bool ReadBytes(BinaryReader r, Byte[] bytes);
    private static UInt32 RvaToOffset(HeaderInfo[] sections, UInt32 rva);
}
internal class Microsoft.Build.Tasks.MarshalReleaseComObject : MulticastDelegate {
    public MarshalReleaseComObject(object object, IntPtr method);
    public virtual int Invoke(object o);
    public virtual IAsyncResult BeginInvoke(object o, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Tasks.Message : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Importance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCritical>k__BackingField;
    public string Text { get; public set; }
    public string Importance { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public bool IsCritical { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Importance();
    [CompilerGeneratedAttribute]
public void set_Importance(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public bool get_IsCritical();
    [CompilerGeneratedAttribute]
public void set_IsCritical(bool value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.Move : TaskExtension {
    private static MoveFileFlags Flags;
    private bool _canceling;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverwriteReadOnlyFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DestinationFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <MovedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] MovedFiles { get; private set; }
    public bool FailIfNotIncremental { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DestinationFiles();
    [CompilerGeneratedAttribute]
public void set_DestinationFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_MovedFiles();
    [CompilerGeneratedAttribute]
private void set_MovedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private static void MakeWriteableIfReadOnly(string file);
    private bool MoveFileWithLogging(string sourceFile, string destinationFile);
}
[RunInMTAAttribute]
public class Microsoft.Build.Tasks.MSBuild : TaskExtension {
    private List`1<ITaskItem> _targetOutputs;
    private SkipNonExistentProjectsBehavior _skipNonExistentProjects;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoveProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebaseOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFirstFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildInParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnloadProjectsOnCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TargetAndPropertyListSeparators>k__BackingField;
    public String[] Properties { get; public set; }
    public string RemoveProperties { get; public set; }
    public String[] Targets { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RebaseOutputs { get; public set; }
    public bool StopOnFirstFailure { get; public set; }
    public bool RunEachTargetSeparately { get; public set; }
    public string ToolsVersion { get; public set; }
    public bool BuildInParallel { get; public set; }
    public bool UnloadProjectsOnCompletion { get; public set; }
    public bool UseResultsCache { get; public set; }
    public string SkipNonexistentProjects { get; public set; }
    public String[] TargetAndPropertyListSeparators { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(String[] value);
    [CompilerGeneratedAttribute]
public string get_RemoveProperties();
    [CompilerGeneratedAttribute]
public void set_RemoveProperties(string value);
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Projects();
    [CompilerGeneratedAttribute]
public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RebaseOutputs();
    [CompilerGeneratedAttribute]
public void set_RebaseOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_StopOnFirstFailure();
    [CompilerGeneratedAttribute]
public void set_StopOnFirstFailure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_BuildInParallel();
    [CompilerGeneratedAttribute]
public void set_BuildInParallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnloadProjectsOnCompletion();
    [CompilerGeneratedAttribute]
public void set_UnloadProjectsOnCompletion(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    public string get_SkipNonexistentProjects();
    public void set_SkipNonexistentProjects(string value);
    [CompilerGeneratedAttribute]
public String[] get_TargetAndPropertyListSeparators();
    [CompilerGeneratedAttribute]
public void set_TargetAndPropertyListSeparators(String[] value);
    public virtual bool Execute();
    private bool BuildProjectsInParallel(Dictionary`2<string, string> propertiesTable, String[] undefinePropertiesArray, List`1<String[]> targetLists, bool success, Boolean[] skipProjects);
    private void ExpandAllTargetsAndProperties();
    internal static List`1<String[]> CreateTargetLists(String[] targets, bool runEachTargetSeparately);
    internal static bool ExecuteTargets(List`1<ITaskItem> projects, Dictionary`2<string, string> propertiesTable, String[] undefineProperties, List`1<String[]> targetLists, bool stopOnFirstFailure, bool rebaseOutputs, IBuildEngine3 buildEngine, TaskLoggingHelper log, List`1<ITaskItem> targetOutputs, bool unloadProjectsOnCompletion, string toolsVersion);
    private bool TryParseSkipNonExistentProjects(string value, SkipNonExistentProjectsBehavior& behavior);
}
internal static class Microsoft.Build.Tasks.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidIntPtr;
    internal static UInt32 NORMAL_PRIORITY_CLASS;
    internal static UInt32 CREATE_NO_WINDOW;
    internal static int STARTF_USESTDHANDLES;
    internal static int ERROR_SUCCESS;
    internal static int TYPE_E_REGISTRYACCESS;
    internal static int TYPE_E_CANTLOADLIBRARY;
    internal static int HRESULT_E_CLASSNOTREGISTERED;
    internal static int ERROR_INVALID_FILENAME;
    internal static int ERROR_ACCESS_DENIED;
    internal static int ERROR_SHARING_VIOLATION;
    internal static Guid GUID_TYPELIB_NAMESPACE;
    internal static Guid GUID_ExportedFromComPlus;
    internal static Guid IID_IUnknown;
    internal static Guid IID_IDispatch;
    internal static Guid IID_ITypeInfo;
    internal static Guid IID_IEnumVariant;
    internal static Guid IID_IDispatchEx;
    internal static Guid IID_StdOle;
    internal static ushort IMAGE_FILE_MACHINE_UNKNOWN;
    internal static ushort IMAGE_FILE_MACHINE_INVALID;
    internal static ushort IMAGE_FILE_MACHINE_AMD64;
    internal static ushort IMAGE_FILE_MACHINE_ARM;
    internal static ushort IMAGE_FILE_MACHINE_ARMV7;
    internal static ushort IMAGE_FILE_MACHINE_I386;
    internal static ushort IMAGE_FILE_MACHINE_IA64;
    internal static ushort IMAGE_FILE_MACHINE_ARM64;
    internal static ushort IMAGE_FILE_MACHINE_R4000;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 PAGE_READONLY;
    internal static UInt32 FILE_MAP_READ;
    internal static UInt32 FILE_TYPE_DISK;
    internal static int SE_ERR_ACCESSDENIED;
    internal static UInt32 IMAGE_NT_OPTIONAL_HDR32_MAGIC;
    internal static UInt32 IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    internal static UInt32 IMAGE_DIRECTORY_ENTRY_COMHEADER;
    internal static UInt32 COMIMAGE_FLAGS_STRONGNAMESIGNED;
    private static string Crypt32DLL;
    private static string Advapi32DLL;
    private static string MscoreeDLL;
    private static NativeMethods();
    private static bool CreateHardLink(string newFileName, string exitingFileName, IntPtr securityAttributes);
    internal static int link(string oldpath, string newpath);
    internal static bool MakeHardLink(string newFileName, string exitingFileName, String& errorMessage, TaskLoggingHelper log);
    internal static bool MoveFileExWindows(string existingFileName, string newFileName, MoveFileFlags flags);
    internal static bool MoveFileEx(string existingFileName, string newFileName, MoveFileFlags flags);
    internal static void RegisterTypeLib(object pTypeLib, string szFullPath, string szHelpDir);
    internal static void UnregisterTypeLib(Guid& guid, short wMajorVerNum, short wMinorVerNum, int lcid, SYSKIND syskind);
    internal static object LoadTypeLibEx(string szFullPath, int regKind);
    internal static object LoadRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    internal static string QueryPathOfRegTypeLib(Guid& clsid, short majorVersion, short minorVersion, int lcid);
    internal static IntPtr CreateFile(string lpFileName, UInt32 dwDesiredAccess, FileShare dwShareMode, IntPtr lpSecurityAttributes, FileMode dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static UInt32 GetFileType(IntPtr hFile);
    internal static bool CloseHandle(IntPtr hObject);
    internal static IntPtr CreateFileMapping(IntPtr hFile, IntPtr lpFileMappingAttributes, UInt32 flProtect, UInt32 dwMaximumSizeHigh, UInt32 dwMaximumSizeLow, string lpName);
    internal static IntPtr MapViewOfFile(IntPtr hFileMapping, UInt32 dwDesiredAccess, UInt32 dwFileOffsetHigh, UInt32 dwFileOffsetLow, IntPtr dwNumberOfBytesToMap);
    internal static bool UnmapViewOfFile(IntPtr lpBaseAddress);
    internal static bool CreateProcess(string lpApplicationName, string lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    internal static IntPtr ImageNtHeader(IntPtr imageBase);
    internal static IntPtr ImageRvaToVa(IntPtr ntHeaders, IntPtr imageBase, UInt32 Rva, IntPtr& LastRvaSection);
    private static UInt32 GetLogicalDrives();
    internal static bool AllDrivesMapped();
    [SupportedOSPlatform("windows")]
internal static UInt32 CreateAssemblyCache(IAssemblyCache& ppAsmCache, UInt32 dwReserved);
    internal static int CreateAssemblyEnum(IAssemblyEnum& ppEnum, IntPtr pUnkReserved, IAssemblyName pName, AssemblyCacheFlags flags, IntPtr pvReserved);
    [SupportedOSPlatform("windows")]
internal static int CreateAssemblyNameObject(IAssemblyName& ppAssemblyNameObj, string szAssemblyName, CreateAssemblyNameObjectFlags flags, IntPtr pvReserved);
    [SupportedOSPlatform("windows")]
internal static int GetCachePath(AssemblyCacheFlags cacheFlags, Char* cachePath, Int32& pcchPath);
    internal static IntPtr PFXImportCertStore(IntPtr blob, string password, CryptFlags flags);
    internal static bool CertCloseStore(IntPtr CertStore, CertStoreClose Flags);
    internal static IntPtr CertEnumCertificatesInStore(IntPtr CertStore, IntPtr PrevCertContext);
    internal static bool CryptAcquireCertificatePrivateKey(IntPtr CertContext, UInt32 flags, IntPtr reserved, IntPtr& CryptProv, KeySpec& KeySpec, Boolean& CallerFreeProv);
    internal static bool CryptGetUserKey(IntPtr CryptProv, KeySpec KeySpec, IntPtr& Key);
    internal static bool CryptExportKey(IntPtr Key, IntPtr ExpKey, BlobType type, UInt32 Flags, IntPtr Data, UInt32& DataLen);
    internal static bool CryptDestroyKey(IntPtr hKey);
    internal static bool CryptReleaseContext(IntPtr Prov, UInt32 Flags);
    internal static bool CertFreeCertificateContext(IntPtr CertContext);
    internal static UInt32 GetFileVersion(string szFileName, Char* szBuffer, int cchBuffer, Int32& dwLength);
    [HandleProcessCorruptedStateExceptionsAttribute]
internal static bool TryReadMetadataString(string fullPath, IntPtr attrData, UInt32 attrDataSize, String& strValue);
    internal static int CorSigUncompressData(IntPtr data, Int32& uncompressedDataLength);
}
internal enum Microsoft.Build.Tasks.NoMatchReason : Enum {
    public int value__;
    public static NoMatchReason Unknown;
    public static NoMatchReason FileNotFound;
    public static NoMatchReason FusionNamesDidNotMatch;
    public static NoMatchReason TargetHadNoFusionName;
    public static NoMatchReason NotInGac;
    public static NoMatchReason NotAFileNameOnDisk;
    public static NoMatchReason ProcessorArchitectureDoesNotMatch;
}
internal class Microsoft.Build.Tasks.ParseState : object {
    private int _openConditionalDirectives;
    private Stack`1<string> _namespaceStack;
    [CompilerGeneratedAttribute]
private bool <ResolvingNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolvingClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    internal bool ResolvingNamespace { get; internal set; }
    internal bool ResolvingClass { get; internal set; }
    internal bool InsideConditionalDirective { get; }
    internal string Namespace { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_ResolvingNamespace();
    [CompilerGeneratedAttribute]
internal void set_ResolvingNamespace(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ResolvingClass();
    [CompilerGeneratedAttribute]
internal void set_ResolvingClass(bool value);
    internal bool get_InsideConditionalDirective();
    [CompilerGeneratedAttribute]
internal string get_Namespace();
    [CompilerGeneratedAttribute]
internal void set_Namespace(string value);
    internal void Reset();
    internal void OpenConditionalDirective();
    internal void CloseConditionalDirective();
    internal void PushNamespacePart(string namespacePart);
    internal string PopNamespacePart();
    internal string ComposeQualifiedClassName(string className);
}
internal class Microsoft.Build.Tasks.PiaReference : ComReference {
    internal PiaReference(TaskLoggingHelper taskLoggingHelper, bool silent, ComReferenceInfo referenceInfo, string itemName);
    internal virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
}
internal class Microsoft.Build.Tasks.PROCESS_INFORMATION : ValueType {
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}
internal class Microsoft.Build.Tasks.ProcessResourceFiles : MarshalByRefObject {
    private List`1<ReaderInfo> _readers;
    private TaskLoggingHelper _logger;
    private string _stronglyTypedLanguage;
    private string _stronglyTypedFilename;
    private string _stronglyTypedNamespace;
    private string _stronglyTypedResourcesNamespace;
    private string _stronglyTypedClassName;
    private bool _stronglyTypedClassIsPublic;
    private AssemblyNamesTypeResolutionService _typeResolver;
    private ResolveEventHandler _eventHandler;
    private ITaskItem[] _assemblyFiles;
    private AssemblyNameExtension[] _assemblyNames;
    private List`1<ITaskItem> _inFiles;
    private List`1<ITaskItem> _satelliteInFiles;
    private List`1<ITaskItem> _outFiles;
    private bool _extractResWFiles;
    private string _resWOutputDirectory;
    private bool _usePreserializedResources;
    private List`1<ITaskItem> _extractedResWFiles;
    private List`1<PortableLibraryFile> _portableLibraryCacheInfo;
    private ArrayList _unsuccessfullyCreatedOutFiles;
    private bool _stronglyTypedResourceSuccessfullyCreated;
    private bool _useSourcePath;
    private bool _logWarningForBinaryFormatter;
    private Nullable`1<bool> _haveSystemResourcesExtensionsReference;
    internal string StronglyTypedFilename { get; }
    internal string StronglyTypedClassName { get; }
    internal List`1<ITaskItem> ExtractedResWFiles { get; }
    internal List`1<PortableLibraryFile> PortableLibraryCacheInfo { get; }
    internal ArrayList UnsuccessfullyCreatedOutFiles { get; }
    internal bool StronglyTypedResourceSuccessfullyCreated { get; }
    private bool HaveSystemResourcesExtensionsReference { get; }
    internal string get_StronglyTypedFilename();
    internal string get_StronglyTypedClassName();
    internal List`1<ITaskItem> get_ExtractedResWFiles();
    internal List`1<PortableLibraryFile> get_PortableLibraryCacheInfo();
    internal ArrayList get_UnsuccessfullyCreatedOutFiles();
    internal bool get_StronglyTypedResourceSuccessfullyCreated();
    internal void Run(TaskLoggingHelper log, ITaskItem[] assemblyFilesList, List`1<ITaskItem> inputs, List`1<ITaskItem> satelliteInputs, List`1<ITaskItem> outputs, bool sourcePath, bool usePreserializedResources, string language, string namespacename, string resourcesNamespace, string filename, string classname, bool publicClass, bool extractingResWFiles, string resWOutputDirectory, bool logWarningForBinaryFormatter);
    internal Assembly ResolveAssembly(object sender, ResolveEventArgs args);
    private void PopulateAssemblyNames();
    private bool ProcessFile(string inFile, string outFileOrDir);
    private string EnsurePathIsShortEnough(string currentOutputFile, string currentOutputFileNoPath, string outputDirectory, string cultureName);
    private void RemoveCorruptedFile(string filename);
    private Format GetFormat(string filename);
    private void ReadResources(string filename, bool shouldUseSourcePath, string outFileOrDir);
    private void AddResourcesUsingMinimalCoreResxParsing(string filename, ReaderInfo reader);
    internal void ReadAssemblyResources(string name, string outFileOrDir);
    private NeutralResourcesLanguageAttribute CheckAssemblyCultureInfo(string name, AssemblyName assemblyName, CultureInfo culture, Assembly a, bool mainAssembly);
    private static bool ContainsProperlyNamedResourcesFiles(Assembly a, bool mainAssembly);
    private void WriteResources(ReaderInfo reader, string filename);
    private void WriteBinaryResources(ReaderInfo reader, string filename);
    private bool get_HaveSystemResourcesExtensionsReference();
    private void CreateStronglyTypedResources(ReaderInfo reader, string outFile, string inputFileName, String& sourceFile);
    public static string GenerateDefaultStronglyTypedFilename(CodeDomProvider provider, string outputResourcesFile);
    public static bool TryCreateCodeDomProvider(TaskLoggingHelper logger, string stronglyTypedLanguage, CodeDomProvider& provider);
    private void ReadResources(ReaderInfo readerInfo, IResourceReader reader, string fileName);
    private void ReadTextResources(ReaderInfo reader, string fileName);
    private void WriteResources(ReaderInfo reader, IResourceWriter writer);
    private void WriteTextResources(ReaderInfo reader, string fileName);
    private void AddResource(ReaderInfo reader, string name, object value, string inputFileName, int lineNumber, int linePosition);
    private void AddResource(ReaderInfo reader, IResource entry, string inputFileName, int lineNumber, int linePosition);
    private void AddResource(ReaderInfo reader, string name, object value, string inputFileName);
}
internal static class Microsoft.Build.Tasks.PropertyParser : object {
    internal static bool GetTable(TaskLoggingHelper log, string parameterName, String[] propertyList, Dictionary`2& propertiesTable);
    internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, String[] propertyNameValueStrings, Dictionary`2& finalPropertiesTable);
}
internal class Microsoft.Build.Tasks.RawFilenameResolver : Resolver {
    public RawFilenameResolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVesion);
    public virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
}
public class Microsoft.Build.Tasks.ReadLinesFromFile : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem <File>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Lines>k__BackingField;
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    [OutputAttribute]
public ITaskItem[] Lines { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_File();
    [CompilerGeneratedAttribute]
public void set_File(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(ITaskItem[] value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ReadMachineTypeFromPEHeader : MulticastDelegate {
    public ReadMachineTypeFromPEHeader(object object, IntPtr method);
    public virtual ushort Invoke(string dllPath);
    public virtual IAsyncResult BeginInvoke(string dllPath, AsyncCallback callback, object object);
    public virtual ushort EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.RedistList : object {
    private static Dictionary`2<string, RedistList> s_cachedRedistList;
    private static Dictionary`2<string, String[]> s_redistListPathCache;
    private static object s_locker;
    private ConcurrentDictionary`2<AssemblyNameExtension, NGen`1<bool>> _assemblyNameInRedist;
    private ConcurrentDictionary`2<string, AssemblyEntry> _assemblyNameToUnifiedAssemblyName;
    private ConcurrentDictionary`2<string, AssemblyNameExtension> _assemblyNameToAssemblyNameExtension;
    private ConcurrentDictionary`2<AssemblyNameExtension, AssemblyNameExtension> _remappingCache;
    private ConcurrentDictionary`2<string, Dictionary`2<string, string>> _cachedDenyList;
    private ReadOnlyCollection`1<Exception> _errors;
    private ReadOnlyCollection`1<string> _errorFilenames;
    private ReadOnlyCollection`1<AssemblyEntry> _assemblyList;
    private ReadOnlyDictionary`2<string, int> _simpleNameMap;
    private ReadOnlyCollection`1<AssemblyRemapping> _remapEntries;
    private static string MatchPattern;
    internal static string RedistListFolder;
    private static IComparer`1<AssemblyEntry> s_sortByVersionDescending;
    internal Exception[] Errors { get; }
    internal String[] ErrorFileNames { get; }
    internal int Count { get; }
    private RedistList(AssemblyTableInfo[] assemblyTableInfos);
    private static RedistList();
    internal Exception[] get_Errors();
    internal String[] get_ErrorFileNames();
    internal int get_Count();
    public bool IsFrameworkAssembly(string assemblyName);
    public bool IsPrerequisiteAssembly(string assemblyName);
    public AssemblyNameExtension RemapAssembly(AssemblyNameExtension extensionToRemap);
    internal Nullable`1<bool> IsRedistRoot(string assemblyName);
    public static RedistList GetFrameworkList20();
    public static RedistList GetFrameworkList30();
    public static RedistList GetFrameworkList35();
    public static RedistList GetRedistListFromPath(string path);
    private static RedistList GetFrameworkListFromReferenceAssembliesPath(TargetDotNetFrameworkVersion version);
    public static String[] GetRedistListPathsFromDisk(string frameworkDirectory);
    internal string RedistName(string assemblyName);
    public static RedistList GetRedistList(AssemblyTableInfo[] assemblyTables);
    private static string GetSimpleName(string assemblyName);
    private AssemblyEntry GetUnifiedAssemblyEntry(string assemblyName);
    private AssemblyNameExtension GetAssemblyNameExtension(string assemblyName);
    public bool FrameworkAssemblyEntryInRedist(AssemblyNameExtension assemblyName);
    public string GetUnifiedAssemblyName(string assemblyName);
    [IteratorStateMachineAttribute("Microsoft.Build.Tasks.RedistList/<FindAssemblyNameFromSimpleName>d__39")]
internal IEnumerable`1<AssemblyEntry> FindAssemblyNameFromSimpleName(string simpleName);
    internal Dictionary`2<string, string> GenerateDenyList(AssemblyTableInfo[] allowListAssemblyTableInfo, List`1<Exception> allowListErrors, List`1<string> allowListErrorFileNames);
    internal static string ReadFile(AssemblyTableInfo assemblyTableInfo, List`1<AssemblyEntry> assembliesList, List`1<Exception> errorsList, List`1<string> errorFilenamesList, List`1<AssemblyRemapping> remapEntries);
    private static void ParseRemapSection(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, List`1<AssemblyRemapping> mapping);
    private static void ParseFileListSection(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, Dictionary`2<string, AssemblyEntry> assemblyEntries, List`1<AssemblyRemapping> remapEntries);
    private static AssemblyEntry ReadFileListEntry(AssemblyTableInfo assemblyTableInfo, string path, string redistName, XmlReader reader, bool fullFusionNameRequired);
}
internal class Microsoft.Build.Tasks.Reference : object {
    private Dictionary`2<string, ITaskItem> _sourceItems;
    private HashSet`1<Reference> _dependees;
    private HashSet`1<Reference> _dependencies;
    private String[] _scatterFiles;
    private List`1<Exception> _errors;
    private List`1<string> _relatedFileExtensions;
    private List`1<string> _satelliteFiles;
    private List`1<string> _serializationAssemblyFiles;
    private List`1<AssemblyNameExtension> _conflictVictims;
    private Dictionary`2<string, UnificationVersion> _preUnificationVersions;
    private ITaskItem _primarySourceItem;
    private string _fullPath;
    private string _directoryName;
    private string _fileNameWithoutExtension;
    private string _fullPathWithoutExtension;
    private List`1<string> _expectedExtensions;
    private bool _isManagedWinMDFile;
    private string _imageRuntimeVersion;
    private HashSet`1<AssemblyRemapping> _remappedAssemblyNames;
    private IsWinMDFile _isWinMDFile;
    private FileExists _fileExists;
    private GetAssemblyRuntimeVersion _getRuntimeVersion;
    [CompilerGeneratedAttribute]
private bool <WantSpecificVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmbedInteropTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UserRequestedSpecificFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ReferenceVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FoundInGac>k__BackingField;
    [CompilerGeneratedAttribute]
private ExclusionListProperties <ExclusionListLoggingProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HintPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFolderKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrerequisite>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsRedistRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBadImage>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <ConflictVictorName>k__BackingField;
    [CompilerGeneratedAttribute]
private ConflictLossReason <ConflictLossExplanation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWinMDFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImplementationAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private CopyLocalState <CopyLocal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DependenciesFound>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SDKName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ResolutionSearchLocation> <AssembliesConsideredAndRejected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedSearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkName <FrameworkNameAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExternallyResolved>k__BackingField;
    internal bool WantSpecificVersion { get; private set; }
    internal bool EmbedInteropTypes { get; internal set; }
    internal bool UserRequestedSpecificFile { get; internal set; }
    internal Version ReferenceVersion { get; internal set; }
    internal Nullable`1<bool> FoundInGac { get; private set; }
    internal bool ResolvedFromGac { get; }
    internal ExclusionListProperties ExclusionListLoggingProperties { get; }
    internal string FullPath { get; internal set; }
    internal string DirectoryName { get; }
    internal string FileNameWithoutExtension { get; }
    internal string FullPathWithoutExtension { get; }
    internal string HintPath { get; internal set; }
    internal string AssemblyFolderKey { get; internal set; }
    internal bool IsPrimary { get; private set; }
    internal bool IsPrerequisite { get; internal set; }
    internal Nullable`1<bool> IsRedistRoot { get; internal set; }
    internal string RedistName { get; internal set; }
    internal ITaskItem PrimarySourceItem { get; }
    internal bool IsBadImage { get; private set; }
    internal bool IsConflictVictim { get; }
    internal AssemblyNameExtension ConflictVictorName { get; internal set; }
    internal ConflictLossReason ConflictLossExplanation { get; internal set; }
    internal bool IsWinMDFile { get; internal set; }
    internal bool IsManagedWinMDFile { get; internal set; }
    public string ImplementationAssembly { get; public set; }
    internal string ImageRuntime { get; internal set; }
    internal bool IsUnified { get; }
    internal CopyLocalState CopyLocal { get; private set; }
    internal bool IsCopyLocal { get; }
    internal bool IsResolved { get; }
    internal bool IsUnresolvable { get; }
    internal bool DependenciesFound { get; internal set; }
    internal string SDKName { get; private set; }
    internal List`1<ResolutionSearchLocation> AssembliesConsideredAndRejected { get; private set; }
    internal string ResolvedSearchPath { get; internal set; }
    internal FrameworkName FrameworkNameAttribute { get; internal set; }
    internal bool ExternallyResolved { get; private set; }
    internal Reference(IsWinMDFile isWinMDFile, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion);
    internal void AddSourceItem(ITaskItem sourceItem);
    internal void AddSourceItems(IEnumerable`1<ITaskItem> sourceItemsToAdd);
    internal void PropagateSourceItems(ITaskItem sourceItem);
    internal ICollection`1<ITaskItem> GetSourceItems();
    internal void AddDependency(Reference dependency);
    internal void AddDependee(Reference dependee);
    internal void RemoveDependee(Reference dependeeToRemove);
    internal void RemoveDependency(Reference dependencyToRemove);
    internal HashSet`1<Reference> GetDependees();
    internal void AttachScatterFiles(String[] scatterFilesToAttach);
    internal String[] GetScatterFiles();
    internal void SetExecutableExtension(string extension);
    internal String[] GetExecutableExtensions(String[] allowedAssemblyExtensions);
    [CompilerGeneratedAttribute]
internal bool get_WantSpecificVersion();
    [CompilerGeneratedAttribute]
private void set_WantSpecificVersion(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EmbedInteropTypes();
    [CompilerGeneratedAttribute]
internal void set_EmbedInteropTypes(bool value);
    [CompilerGeneratedAttribute]
internal bool get_UserRequestedSpecificFile();
    [CompilerGeneratedAttribute]
internal void set_UserRequestedSpecificFile(bool value);
    [CompilerGeneratedAttribute]
internal Version get_ReferenceVersion();
    [CompilerGeneratedAttribute]
internal void set_ReferenceVersion(Version value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_FoundInGac();
    [CompilerGeneratedAttribute]
private void set_FoundInGac(Nullable`1<bool> value);
    internal bool get_ResolvedFromGac();
    [CompilerGeneratedAttribute]
internal ExclusionListProperties get_ExclusionListLoggingProperties();
    internal bool CheckForSpecificVersionMetadataOnParentsReference(bool anyParentHasMetadata);
    internal void AddError(Exception e);
    internal List`1<Exception> GetErrors();
    internal void AddRelatedFileExtension(string filenameExtension);
    internal List`1<string> GetRelatedFileExtensions();
    internal void AddSatelliteFile(string filename);
    internal void AddSerializationAssemblyFile(string filename);
    internal List`1<string> GetSatelliteFiles();
    internal List`1<string> GetSerializationAssemblyFiles();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    internal void NormalizeFullPath();
    internal string get_DirectoryName();
    internal string get_FileNameWithoutExtension();
    internal string get_FullPathWithoutExtension();
    [CompilerGeneratedAttribute]
internal string get_HintPath();
    [CompilerGeneratedAttribute]
internal void set_HintPath(string value);
    [CompilerGeneratedAttribute]
internal string get_AssemblyFolderKey();
    [CompilerGeneratedAttribute]
internal void set_AssemblyFolderKey(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsPrimary();
    [CompilerGeneratedAttribute]
private void set_IsPrimary(bool value);
    [CompilerGeneratedAttribute]
internal void set_IsPrerequisite(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsPrerequisite();
    [CompilerGeneratedAttribute]
internal void set_IsRedistRoot(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_IsRedistRoot();
    [CompilerGeneratedAttribute]
internal void set_RedistName(string value);
    [CompilerGeneratedAttribute]
internal string get_RedistName();
    internal ITaskItem get_PrimarySourceItem();
    [CompilerGeneratedAttribute]
internal bool get_IsBadImage();
    [CompilerGeneratedAttribute]
private void set_IsBadImage(bool value);
    internal bool get_IsConflictVictim();
    internal void AddConflictVictim(AssemblyNameExtension victim);
    internal List`1<AssemblyNameExtension> GetConflictVictims();
    [CompilerGeneratedAttribute]
internal AssemblyNameExtension get_ConflictVictorName();
    [CompilerGeneratedAttribute]
internal void set_ConflictVictorName(AssemblyNameExtension value);
    [CompilerGeneratedAttribute]
internal ConflictLossReason get_ConflictLossExplanation();
    [CompilerGeneratedAttribute]
internal void set_ConflictLossExplanation(ConflictLossReason value);
    [CompilerGeneratedAttribute]
internal bool get_IsWinMDFile();
    [CompilerGeneratedAttribute]
internal void set_IsWinMDFile(bool value);
    internal bool get_IsManagedWinMDFile();
    internal void set_IsManagedWinMDFile(bool value);
    [CompilerGeneratedAttribute]
public string get_ImplementationAssembly();
    [CompilerGeneratedAttribute]
public void set_ImplementationAssembly(string value);
    internal string get_ImageRuntime();
    internal void set_ImageRuntime(string value);
    internal List`1<UnificationVersion> GetPreUnificationVersions();
    internal HashSet`1<AssemblyRemapping> RemappedAssemblyNames();
    internal void AddPreUnificationVersion(string referencePath, Version version, UnificationReason reason);
    internal void AddRemapping(AssemblyNameExtension remappedFrom, AssemblyNameExtension remappedTo);
    internal bool get_IsUnified();
    [CompilerGeneratedAttribute]
internal CopyLocalState get_CopyLocal();
    [CompilerGeneratedAttribute]
private void set_CopyLocal(CopyLocalState value);
    internal bool get_IsCopyLocal();
    internal bool get_IsResolved();
    internal bool get_IsUnresolvable();
    [CompilerGeneratedAttribute]
internal bool get_DependenciesFound();
    [CompilerGeneratedAttribute]
internal void set_DependenciesFound(bool value);
    [CompilerGeneratedAttribute]
internal string get_SDKName();
    [CompilerGeneratedAttribute]
private void set_SDKName(string value);
    internal void AddAssembliesConsideredAndRejected(List`1<ResolutionSearchLocation> assembliesConsideredAndRejectedToAdd);
    [CompilerGeneratedAttribute]
internal List`1<ResolutionSearchLocation> get_AssembliesConsideredAndRejected();
    [CompilerGeneratedAttribute]
private void set_AssembliesConsideredAndRejected(List`1<ResolutionSearchLocation> value);
    [CompilerGeneratedAttribute]
internal string get_ResolvedSearchPath();
    [CompilerGeneratedAttribute]
internal void set_ResolvedSearchPath(string value);
    [CompilerGeneratedAttribute]
internal FrameworkName get_FrameworkNameAttribute();
    [CompilerGeneratedAttribute]
internal void set_FrameworkNameAttribute(FrameworkName value);
    [CompilerGeneratedAttribute]
internal bool get_ExternallyResolved();
    [CompilerGeneratedAttribute]
private void set_ExternallyResolved(bool value);
    internal void MakeDependentAssemblyReference(Reference sourceReference);
    internal void MakePrimaryAssemblyReference(ITaskItem sourceItem, bool wantSpecificVersionValue, string executableExtension);
    internal static bool IsFrameworkFile(string fullPath, String[] frameworkPaths);
    internal void SetFinalCopyLocalState(AssemblyNameExtension assemblyName, String[] frameworkPaths, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, GetAssemblyPathInGac getAssemblyPathInGac, bool copyLocalDependenciesWhenParentReferenceInGac, bool doNotCopyLocalIfInGac, ReferenceTable referenceTable);
    public virtual string ToString();
}
internal class Microsoft.Build.Tasks.ReferenceResolutionException : Exception {
    internal ReferenceResolutionException(string message, Exception innerException);
    private ReferenceResolutionException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.ReferenceTable : object {
    private static Version s_targetFrameworkVersion_40;
    private static Dictionary`2<string, Tuple`2<RedistList, string>> s_monikerToHighestRedistList;
    private HashSet`1<string> _externallyResolvedPrimaryReferences;
    private Dictionary`2<string, AssemblyNameExtension> _externallyResolvedImmutableFiles;
    private IEnumerable`1<DependentAssembly> _remappedAssemblies;
    private bool _findDependencies;
    private bool _ignoreVersionForFrameworkReferences;
    private bool _findSatellites;
    private bool _findSerializationAssemblies;
    private bool _findRelatedFiles;
    private bool _checkAssemblyVersionAgainstTargetFrameworkVersion;
    private String[] _frameworkPaths;
    private String[] _allowedAssemblyExtensions;
    private String[] _relatedFileExtensions;
    private Dictionary`2<string, ITaskItem> _resolvedSDKReferences;
    private InstalledAssemblies _installedAssemblies;
    private ProcessorArchitecture _targetProcessorArchitecture;
    private FileExists _fileExists;
    private DirectoryExists _directoryExists;
    private GetDirectories _getDirectories;
    private GetAssemblyName _getAssemblyName;
    private GetAssemblyMetadata _getAssemblyMetadata;
    private GetAssemblyRuntimeVersion _getRuntimeVersion;
    private OpenBaseKey _openBaseKey;
    private Version _targetedRuntimeVersion;
    private ReadMachineTypeFromPEHeader _readMachineTypeFromPEHeader;
    private IsWinMDFile _isWinMDFile;
    private Version _projectTargetFramework;
    private FrameworkName _targetFrameworkMoniker;
    private TaskLoggingHelper _log;
    private String[] _latestTargetFrameworkDirectories;
    private bool _copyLocalDependenciesWhenParentReferenceInGac;
    private bool _doNotCopyLocalIfInGac;
    private bool _ignoreFrameworkAttributeVersionMismatch;
    private GetAssemblyPathInGac _getAssemblyPathInGac;
    private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch;
    private ConcurrentDictionary`2<string, AssemblyMetadata> _assemblyMetadataCache;
    private static int PEOFFSET;
    private static int PEHEADER;
    [CompilerGeneratedAttribute]
private Resolver[] <Resolvers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<AssemblyNameExtension, Reference> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ListOfExcludedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkippedFindingExternallyResolvedDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FindDependenciesOfExternallyResolvedReferences>k__BackingField;
    internal Resolver[] Resolvers { get; }
    internal Dictionary`2<AssemblyNameExtension, Reference> References { get; private set; }
    internal List`1<string> ListOfExcludedAssemblies { get; private set; }
    internal bool SkippedFindingExternallyResolvedDependencies { get; private set; }
    internal bool FindDependenciesOfExternallyResolvedReferences { get; internal set; }
    internal ReferenceTable(IBuildEngine buildEngine, bool findDependencies, bool findSatellites, bool findSerializationAssemblies, bool findRelatedFiles, String[] searchPaths, String[] allowedAssemblyExtensions, String[] relatedFileExtensions, String[] candidateAssemblyFiles, ITaskItem[] resolvedSDKItems, String[] frameworkPaths, InstalledAssemblies installedAssemblies, ProcessorArchitecture targetProcessorArchitecture, FileExists fileExists, DirectoryExists directoryExists, GetDirectories getDirectories, GetAssemblyName getAssemblyName, GetAssemblyMetadata getAssemblyMetadata, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, OpenBaseKey openBaseKey, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, Version projectTargetFramework, FrameworkName targetFrameworkMoniker, TaskLoggingHelper log, String[] latestTargetFrameworkDirectories, bool copyLocalDependenciesWhenParentReferenceInGac, bool doNotCopyLocalIfInGac, GetAssemblyPathInGac getAssemblyPathInGac, IsWinMDFile isWinMDFile, bool ignoreVersionForFrameworkReferences, ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader, WarnOrErrorOnTargetArchitectureMismatchBehavior warnOrErrorOnTargetArchitectureMismatch, bool ignoreFrameworkAttributeVersionMismatch, bool unresolveFrameworkAssembliesFromHigherFrameworks, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache);
    private static ReferenceTable();
    [CompilerGeneratedAttribute]
internal Resolver[] get_Resolvers();
    [CompilerGeneratedAttribute]
internal Dictionary`2<AssemblyNameExtension, Reference> get_References();
    [CompilerGeneratedAttribute]
private void set_References(Dictionary`2<AssemblyNameExtension, Reference> value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_ListOfExcludedAssemblies();
    [CompilerGeneratedAttribute]
private void set_ListOfExcludedAssemblies(List`1<string> value);
    [CompilerGeneratedAttribute]
internal bool get_SkippedFindingExternallyResolvedDependencies();
    [CompilerGeneratedAttribute]
private void set_SkippedFindingExternallyResolvedDependencies(bool value);
    [CompilerGeneratedAttribute]
internal bool get_FindDependenciesOfExternallyResolvedReferences();
    [CompilerGeneratedAttribute]
internal void set_FindDependenciesOfExternallyResolvedReferences(bool value);
    internal void AddReference(AssemblyNameExtension assemblyName, Reference reference);
    internal Reference GetReference(AssemblyNameExtension assemblyName);
    private AssemblyNameExtension NameAssemblyFileReference(Reference reference, string assemblyFileName);
    private void SetPrimaryItems(ITaskItem[] referenceAssemblyFiles, ITaskItem[] referenceAssemblyNames, List`1<Exception> exceptions);
    private Exception SetPrimaryAssemblyReferenceItem(ITaskItem referenceAssemblyName);
    private static void TryConvertToAssemblyName(string itemSpec, string fusionName, AssemblyNameExtension& assemblyName);
    private static void TryGatherAssemblyNameEssentials(string fusionName, AssemblyNameExtension& assemblyName);
    private static void TryGetAssemblyNameComponent(string fusionName, string component, String& value);
    private static AssemblyNameExtension GetAssemblyNameFromItemMetadata(ITaskItem item);
    private void SetPrimaryFileItem(ITaskItem referenceAssemblyFile);
    private void FindRelatedFiles(Reference reference);
    private void FindSatellites(Reference reference);
    private void FindSerializationAssemblies(Reference reference);
    private void GetUnifiedAssemblyMetadata(Reference reference, IEnumerable`1& unifiedDependencies, String[]& scatterFiles);
    [IteratorStateMachineAttribute("Microsoft.Build.Tasks.ReferenceTable/<GetUnifiedAssemblyNames>d__74")]
private IEnumerable`1<UnifiedAssemblyName> GetUnifiedAssemblyNames(IEnumerable`1<AssemblyNameExtension> preUnificationAssemblyNames);
    private void FindDependenciesAndScatterFiles(Reference reference, List`1<KeyValuePair`2<AssemblyNameExtension, Reference>> newEntries);
    private static bool IsPseudoAssembly(string name);
    internal static void CalculateParentAssemblyDirectories(List`1<string> parentReferenceFolders, Reference parentReference);
    private void ResolveReference(AssemblyNameExtension assemblyName, string rawFileNameCandidate, Reference reference);
    internal void RemoveReferencesMarkedForExclusion(bool removeOnlyNoWarning, string subsetName);
    private static void AddToDependencyGraph(Dictionary`2<Reference, List`1<ReferenceAssemblyExtensionPair>> dependencyGraph, AssemblyNameExtension assemblyName, Reference assemblyReference);
    private void RemoveDependencyMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, Dictionary`2<AssemblyNameExtension, Reference> goodReferences, List`1<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference);
    private static void RemovePrimaryReferenceMarkedForExclusion(LogExclusionReason logExclusionReason, bool removeOnlyNoWarning, string subsetName, List`1<Reference> removedReferences, AssemblyNameExtension assemblyName, Reference assemblyReference);
    internal AssemblyNameExtension GetReferenceFromItemSpec(string itemSpec);
    private static void RemoveDependencies(Reference removedReference, Dictionary`2<AssemblyNameExtension, Reference> referenceList, Dictionary`2<Reference, List`1<ReferenceAssemblyExtensionPair>> dependencyList);
    internal void ComputeClosure(IEnumerable`1<DependentAssembly> remappedAssembliesValue, ITaskItem[] referenceAssemblyFiles, ITaskItem[] referenceAssemblyNames, List`1<Exception> exceptions);
    private void ComputeClosure();
    private bool FindAssociatedFiles();
    private void ResolveAssemblyFilenames();
    private void ResolveConflictsBetweenReferences(Dictionary`2<string, List`1<AssemblyNameReference>> baseNameToReferences);
    private void ResolveConflictsBetweenReferences(List`1<AssemblyNameReference> assemblyReferences);
    internal void ResolveConflicts(List`1& idealRemappings, List`1& conflictingReferences);
    internal bool MarkReferencesExcludedDueToOtherFramework(AssemblyNameExtension assemblyName, Reference reference);
    private bool InLatestRedistList(AssemblyNameExtension assemblyName);
    private Tuple`2<RedistList, string> GetHighestVersionFullFrameworkForTFM(FrameworkName targetFrameworkMoniker);
    private static IList`1<string> GetHighestVersionReferenceAssemblyDirectories(FrameworkName targetFrameworkMoniker, FrameworkName& highestVersionMoniker);
    internal void MarkReferenceWithHighestVersionInCurrentRedistList(AssemblyNameExtension assemblyName, Reference reference);
    internal bool MarkReferenceForExclusionDueToHigherThanCurrentFramework(AssemblyNameExtension assemblyName, Reference reference);
    internal bool MarkReferenceForExclusionDueToHigherThanCurrentFrameworkAttribute(AssemblyNameExtension assemblyName, Reference reference);
    private Dictionary`2<string, List`1<AssemblyNameReference>> BuildSimpleNameTable();
    private static void RemoveReferencesWithoutConflicts(Dictionary`2<string, List`1<AssemblyNameReference>> baseNameToReferences);
    private static bool AreAssembliesEquivalent(string assemblyIdentity1, bool fUnified1, string assemblyIdentity2, bool fUnified2);
    private static bool RefMatchesDef(AssemblyName ref, AssemblyName def);
    private static bool IsStrongNamed(AssemblyName assembly);
    private static bool CompareRefToDef(AssemblyName ref, AssemblyName def);
    private static int ResolveAssemblyNameConflict(AssemblyNameReference assemblyReference0, AssemblyNameReference assemblyReference1);
    private static bool IsAssemblyRemovedFromDotNetFramework(AssemblyNameExtension assemblyName, string fullPath, String[] frameworkPaths, InstalledAssemblies installedAssemblies);
    private bool UnifyAssemblyNameVersions(AssemblyNameExtension assemblyName, Version& unifiedVersion, UnificationReason& unificationReason, Boolean& isPrerequisite, Nullable`1& isRedistRoot, String& redistName);
    private bool CompareAssembliesIgnoringVersion(AssemblyName a, AssemblyName b);
    internal void GetReferenceItems(ITaskItem[]& primaryFiles, ITaskItem[]& dependencyFiles, ITaskItem[]& relatedFiles, ITaskItem[]& satelliteFiles, ITaskItem[]& serializationAssemblyFiles, ITaskItem[]& scatterFiles, ITaskItem[]& copyLocalFiles);
    private ITaskItem SetItemMetadata(List`1<ITaskItem> relatedItems, List`1<ITaskItem> satelliteItems, List`1<ITaskItem> serializationAssemblyItems, List`1<ITaskItem> scatterItems, string fusionName, Reference reference, AssemblyNameExtension assemblyName);
    private bool VerifyArchitectureOfImplementationDll(string dllPath, string winmdFile);
    internal static ushort ReadMachineTypeFromPEHeader(string dllPath);
    private static Dictionary`2<string, string> RemoveNonForwardableMetadata(ITaskItem item);
    private static void RemoveMetadatum(string key, ITaskItem item, Dictionary`2<string, string> removedMetadata);
    private static void FindCopyLocalItems(ITaskItem[] items, List`1<ITaskItem> copyLocalItems);
    internal void LogHigherVersionUnresolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogHigherVersionUnresolveDueToAttribute(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogAnotherFrameworkUnResolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal void LogProfileExclusionUnresolve(bool displayPrimaryReferenceMessage, AssemblyNameExtension assemblyName, Reference reference, ITaskItem referenceItem, string targetedFramework);
    internal bool MarkReferencesForExclusion(Dictionary`2<string, string> exclusionList);
    internal bool IsImmutableFile(string path);
    internal AssemblyNameExtension GetImmutableFileAssemblyName(string path);
}
public class Microsoft.Build.Tasks.RegisterAssembly : AppDomainIsolatedTaskExtension {
    private ITaskItem[] _assemblies;
    [CompilerGeneratedAttribute]
private ITaskItem[] <TypeLibFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateCodeBase>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AssemblyListFile>k__BackingField;
    private bool _typeLibExportFailed;
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    [OutputAttribute]
public ITaskItem[] TypeLibFiles { get; public set; }
    public bool CreateCodeBase { get; public set; }
    public ITaskItem AssemblyListFile { get; public set; }
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_TypeLibFiles();
    [CompilerGeneratedAttribute]
public void set_TypeLibFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_CreateCodeBase();
    [CompilerGeneratedAttribute]
public void set_CreateCodeBase(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AssemblyListFile();
    [CompilerGeneratedAttribute]
public void set_AssemblyListFile(ITaskItem value);
    public virtual bool Execute();
    public sealed virtual void ReportEvent(ExporterEventKind kind, int code, string msg);
    public sealed virtual object ResolveRef(Assembly assemblyToResolve);
    private bool Register(string assemblyPath, string typeLibPath);
    private bool ExportTypeLib(Assembly asm, string typeLibFileName);
}
public class Microsoft.Build.Tasks.RemoveDir : TaskExtension {
    private ITaskItem[] _directories;
    [CompilerGeneratedAttribute]
private ITaskItem[] <RemovedDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    [OutputAttribute]
public ITaskItem[] RemovedDirectories { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_RemovedDirectories();
    [CompilerGeneratedAttribute]
public void set_RemovedDirectories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public virtual bool Execute();
    private bool RemoveDirectory(ITaskItem directory, bool logUnauthorizedError, Boolean& unauthorizedAccess);
    private bool RemoveReadOnlyAttributeRecursively(DirectoryInfo directory);
}
public class Microsoft.Build.Tasks.RemoveDuplicates : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Filtered>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HadAnyDuplicates>k__BackingField;
    public ITaskItem[] Inputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] Filtered { get; public set; }
    [OutputAttribute]
public bool HadAnyDuplicates { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Filtered();
    [CompilerGeneratedAttribute]
public void set_Filtered(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_HadAnyDuplicates();
    [CompilerGeneratedAttribute]
public void set_HadAnyDuplicates(bool value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.RequiresFramework35SP1Assembly : TaskExtension {
    private string _targetFrameworkVersion;
    private Nullable`1<bool> _createDesktopShortcut;
    [CompilerGeneratedAttribute]
private string <ErrorReportUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SigningManifests>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ReferencedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <DeploymentManifestEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuiteName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresMinimumFramework35SP1>k__BackingField;
    public string ErrorReportUrl { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public bool CreateDesktopShortcut { get; public set; }
    public bool SigningManifests { get; public set; }
    public ITaskItem[] ReferencedAssemblies { get; public set; }
    public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem DeploymentManifestEntryPoint { get; public set; }
    public ITaskItem EntryPoint { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public string SuiteName { get; public set; }
    [OutputAttribute]
public bool RequiresMinimumFramework35SP1 { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ErrorReportUrl();
    [CompilerGeneratedAttribute]
public void set_ErrorReportUrl(string value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public bool get_CreateDesktopShortcut();
    public void set_CreateDesktopShortcut(bool value);
    [CompilerGeneratedAttribute]
public bool get_SigningManifests();
    [CompilerGeneratedAttribute]
public void set_SigningManifests(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ReferencedAssemblies();
    [CompilerGeneratedAttribute]
public void set_ReferencedAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Assemblies();
    [CompilerGeneratedAttribute]
public void set_Assemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_DeploymentManifestEntryPoint();
    [CompilerGeneratedAttribute]
public void set_DeploymentManifestEntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_SuiteName();
    [CompilerGeneratedAttribute]
public void set_SuiteName(string value);
    [CompilerGeneratedAttribute]
public bool get_RequiresMinimumFramework35SP1();
    [CompilerGeneratedAttribute]
public void set_RequiresMinimumFramework35SP1(bool value);
    private static Version ConvertFrameworkVersionToString(string version);
    private static int CompareFrameworkVersions(string versionA, string versionB);
    private bool HasErrorUrl();
    private bool HasCreatedShortcut();
    private bool UncheckedSigning();
    private bool ExcludeReferenceFromHashing();
    private static bool HasExcludedFileOrSP1File(ITaskItem[] candidateFiles);
    private static bool IsExcludedFileOrSP1File(ITaskItem candidateFile);
    private bool HasSuiteName();
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.ResGenDependencies : StateFileBase {
    internal IDictionary`2<string, ResXFile> resXFiles;
    internal IDictionary`2<string, PortableLibraryFile> portableLibraries;
    private bool _isDirty;
    internal string baseLinkedFileDirectory;
    internal string BaseLinkedFileDirectory { get; internal set; }
    unknown bool UseSourcePath {internal set; }
    internal bool IsDirty { get; }
    public ResGenDependencies(ITranslator translator);
    internal string get_BaseLinkedFileDirectory();
    internal void set_BaseLinkedFileDirectory(string value);
    internal void set_UseSourcePath(bool value);
    public virtual void Translate(ITranslator translator);
    internal ResXFile GetResXFileInfo(string resxFile, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter);
    private ResXFile AddResxFile(string file, bool useMSBuildResXReader, TaskLoggingHelper log, bool logWarningForBinaryFormatter);
    internal PortableLibraryFile TryGetPortableLibraryInfo(string libraryPath);
    internal void UpdatePortableLibrary(PortableLibraryFile library);
    internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState);
    internal static ResGenDependencies DeserializeCache(string stateFile, bool useSourcePath, TaskLoggingHelper log);
    internal bool get_IsDirty();
}
internal class Microsoft.Build.Tasks.ResolutionSearchLocation : object {
    [CompilerGeneratedAttribute]
private string <FileNameAttempted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private NoMatchReason <Reason>k__BackingField;
    internal string FileNameAttempted { get; internal set; }
    internal string SearchPath { get; internal set; }
    internal AssemblyNameExtension AssemblyName { get; internal set; }
    internal NoMatchReason Reason { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_FileNameAttempted();
    [CompilerGeneratedAttribute]
internal void set_FileNameAttempted(string value);
    [CompilerGeneratedAttribute]
internal string get_SearchPath();
    [CompilerGeneratedAttribute]
internal void set_SearchPath(string value);
    [CompilerGeneratedAttribute]
internal AssemblyNameExtension get_AssemblyName();
    [CompilerGeneratedAttribute]
internal void set_AssemblyName(AssemblyNameExtension value);
    [CompilerGeneratedAttribute]
internal NoMatchReason get_Reason();
    [CompilerGeneratedAttribute]
internal void set_Reason(NoMatchReason value);
}
public class Microsoft.Build.Tasks.ResolveAssemblyReference : TaskExtension {
    private static string SystemRuntimeAssemblyName;
    private static string NETStandardAssemblyName;
    private static string DotNetAssemblyRuntimeVersion;
    internal SystemState _cache;
    private ITaskItem[] _assemblyFiles;
    private ITaskItem[] _assemblyNames;
    private ITaskItem[] _installedAssemblyTables;
    private ITaskItem[] _installedAssemblySubsetTables;
    private ITaskItem[] _fullFrameworkAssemblyTables;
    private ITaskItem[] _resolvedSDKReferences;
    private bool _ignoreDefaultInstalledAssemblyTables;
    private bool _ignoreDefaultInstalledAssemblySubsetTables;
    private String[] _candidateAssemblyFiles;
    private String[] _targetFrameworkDirectories;
    private String[] _searchPaths;
    private String[] _allowedAssemblyExtensions;
    private String[] _relatedFileExtensions;
    private string _appConfigFile;
    private bool _supportsBindingRedirectGeneration;
    private bool _autoUnify;
    private bool _ignoreVersionForFrameworkReferences;
    private bool _ignoreTargetFrameworkAttributeVersionMismatch;
    private ITaskItem[] _resolvedFiles;
    private ITaskItem[] _resolvedDependencyFiles;
    private ITaskItem[] _relatedFiles;
    private ITaskItem[] _satelliteFiles;
    private ITaskItem[] _serializationAssemblyFiles;
    private ITaskItem[] _scatterFiles;
    private ITaskItem[] _copyLocalFiles;
    private ITaskItem[] _suggestedRedirects;
    private List`1<ITaskItem> _unresolvedConflicts;
    private String[] _targetFrameworkSubsets;
    private String[] _fullTargetFrameworkSubsetNames;
    private string _targetedFrameworkMoniker;
    private bool _findDependencies;
    private bool _findSatellites;
    private bool _findSerializationAssemblies;
    private bool _findRelatedFiles;
    private bool _silent;
    private string _projectTargetFrameworkAsString;
    private string _targetedRuntimeVersionRawValue;
    private Version _projectTargetFramework;
    private string _stateFile;
    private string _targetProcessorArchitecture;
    private string _profileName;
    private String[] _fullFrameworkFolders;
    private String[] _latestTargetFrameworkDirectories;
    private bool _copyLocalDependenciesWhenParentReferenceInGac;
    private Dictionary`2<string, MessageImportance> _showAssemblyFoldersExLocations;
    private bool _logVerboseSearchResults;
    private WarnOrErrorOnTargetArchitectureMismatchBehavior _warnOrErrorOnTargetArchitectureMismatch;
    private bool _unresolveFrameworkAssembliesFromHigherFrameworks;
    [CompilerGeneratedAttribute]
private bool <FindDependenciesOfExternallyResolvedReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputUnresolvedAssemblyConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyInformationCacheOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssemblyInformationCachePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DoNotCopyLocalIfInGac>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMonikerDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    private List`1<ITaskItem> _filesWritten;
    [CompilerGeneratedAttribute]
private string <DependsOnSystemRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnNETStandard>k__BackingField;
    public bool UnresolveFrameworkAssembliesFromHigherFrameworks { get; public set; }
    public string WarnOrErrorOnTargetArchitectureMismatch { get; public set; }
    public ITaskItem[] AssemblyFiles { get; public set; }
    public String[] LatestTargetFrameworkDirectories { get; public set; }
    public bool IgnoreTargetFrameworkAttributeVersionMismatch { get; public set; }
    public bool FindDependenciesOfExternallyResolvedReferences { get; public set; }
    public bool OutputUnresolvedAssemblyConflicts { get; public set; }
    public String[] TargetFrameworkSubsets { get; public set; }
    public ITaskItem[] Assemblies { get; public set; }
    public String[] CandidateAssemblyFiles { get; public set; }
    public ITaskItem[] ResolvedSDKReferences { get; public set; }
    public String[] TargetFrameworkDirectories { get; public set; }
    public ITaskItem[] InstalledAssemblyTables { get; public set; }
    public ITaskItem[] InstalledAssemblySubsetTables { get; public set; }
    public ITaskItem[] FullFrameworkAssemblyTables { get; public set; }
    public bool IgnoreDefaultInstalledAssemblyTables { get; public set; }
    public bool IgnoreDefaultInstalledAssemblySubsetTables { get; public set; }
    public bool IgnoreVersionForFrameworkReferences { get; public set; }
    public string TargetProcessorArchitecture { get; public set; }
    public string TargetedRuntimeVersion { get; public set; }
    public string AssemblyInformationCacheOutputPath { get; public set; }
    public ITaskItem[] AssemblyInformationCachePaths { get; public set; }
    [RequiredAttribute]
public String[] SearchPaths { get; public set; }
    public String[] AllowedAssemblyExtensions { get; public set; }
    public String[] AllowedRelatedFileExtensions { get; public set; }
    public string AppConfigFile { get; public set; }
    public bool SupportsBindingRedirectGeneration { get; public set; }
    public bool AutoUnify { get; public set; }
    public bool CopyLocalDependenciesWhenParentReferenceInGac { get; public set; }
    public bool DoNotCopyLocalIfInGac { get; public set; }
    public string StateFile { get; public set; }
    public bool FindDependencies { get; public set; }
    public bool FindSatellites { get; public set; }
    public bool FindSerializationAssemblies { get; public set; }
    public bool FindRelatedFiles { get; public set; }
    public bool Silent { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TargetFrameworkMoniker { get; public set; }
    public string TargetFrameworkMonikerDisplayName { get; public set; }
    public String[] FullTargetFrameworkSubsetNames { get; public set; }
    public string ProfileName { get; public set; }
    public String[] FullFrameworkFolders { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedFiles { get; }
    [OutputAttribute]
public ITaskItem[] ResolvedDependencyFiles { get; }
    [OutputAttribute]
public ITaskItem[] RelatedFiles { get; }
    [OutputAttribute]
public ITaskItem[] SatelliteFiles { get; }
    [OutputAttribute]
public ITaskItem[] SerializationAssemblyFiles { get; }
    [OutputAttribute]
public ITaskItem[] ScatterFiles { get; }
    [OutputAttribute]
public ITaskItem[] CopyLocalFiles { get; }
    [OutputAttribute]
public ITaskItem[] SuggestedRedirects { get; }
    [OutputAttribute]
public ITaskItem[] FilesWritten { get; public set; }
    [OutputAttribute]
public string DependsOnSystemRuntime { get; private set; }
    [OutputAttribute]
public string DependsOnNETStandard { get; private set; }
    [OutputAttribute]
public ITaskItem[] UnresolvedAssemblyConflicts { get; }
    public bool get_UnresolveFrameworkAssembliesFromHigherFrameworks();
    public void set_UnresolveFrameworkAssembliesFromHigherFrameworks(bool value);
    public string get_WarnOrErrorOnTargetArchitectureMismatch();
    public void set_WarnOrErrorOnTargetArchitectureMismatch(string value);
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    public String[] get_LatestTargetFrameworkDirectories();
    public void set_LatestTargetFrameworkDirectories(String[] value);
    public bool get_IgnoreTargetFrameworkAttributeVersionMismatch();
    public void set_IgnoreTargetFrameworkAttributeVersionMismatch(bool value);
    [CompilerGeneratedAttribute]
public bool get_FindDependenciesOfExternallyResolvedReferences();
    [CompilerGeneratedAttribute]
public void set_FindDependenciesOfExternallyResolvedReferences(bool value);
    [CompilerGeneratedAttribute]
public bool get_OutputUnresolvedAssemblyConflicts();
    [CompilerGeneratedAttribute]
public void set_OutputUnresolvedAssemblyConflicts(bool value);
    public String[] get_TargetFrameworkSubsets();
    public void set_TargetFrameworkSubsets(String[] value);
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public String[] get_CandidateAssemblyFiles();
    public void set_CandidateAssemblyFiles(String[] value);
    public ITaskItem[] get_ResolvedSDKReferences();
    public void set_ResolvedSDKReferences(ITaskItem[] value);
    public String[] get_TargetFrameworkDirectories();
    public void set_TargetFrameworkDirectories(String[] value);
    public ITaskItem[] get_InstalledAssemblyTables();
    public void set_InstalledAssemblyTables(ITaskItem[] value);
    public ITaskItem[] get_InstalledAssemblySubsetTables();
    public void set_InstalledAssemblySubsetTables(ITaskItem[] value);
    public ITaskItem[] get_FullFrameworkAssemblyTables();
    public void set_FullFrameworkAssemblyTables(ITaskItem[] value);
    public bool get_IgnoreDefaultInstalledAssemblyTables();
    public void set_IgnoreDefaultInstalledAssemblyTables(bool value);
    public bool get_IgnoreDefaultInstalledAssemblySubsetTables();
    public void set_IgnoreDefaultInstalledAssemblySubsetTables(bool value);
    public bool get_IgnoreVersionForFrameworkReferences();
    public void set_IgnoreVersionForFrameworkReferences(bool value);
    public string get_TargetProcessorArchitecture();
    public void set_TargetProcessorArchitecture(string value);
    public string get_TargetedRuntimeVersion();
    public void set_TargetedRuntimeVersion(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyInformationCacheOutputPath();
    [CompilerGeneratedAttribute]
public void set_AssemblyInformationCacheOutputPath(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssemblyInformationCachePaths();
    [CompilerGeneratedAttribute]
public void set_AssemblyInformationCachePaths(ITaskItem[] value);
    public String[] get_SearchPaths();
    public void set_SearchPaths(String[] value);
    public String[] get_AllowedAssemblyExtensions();
    public void set_AllowedAssemblyExtensions(String[] value);
    public String[] get_AllowedRelatedFileExtensions();
    public void set_AllowedRelatedFileExtensions(String[] value);
    public string get_AppConfigFile();
    public void set_AppConfigFile(string value);
    public bool get_SupportsBindingRedirectGeneration();
    public void set_SupportsBindingRedirectGeneration(bool value);
    public bool get_AutoUnify();
    public void set_AutoUnify(bool value);
    public bool get_CopyLocalDependenciesWhenParentReferenceInGac();
    public void set_CopyLocalDependenciesWhenParentReferenceInGac(bool value);
    [CompilerGeneratedAttribute]
public bool get_DoNotCopyLocalIfInGac();
    [CompilerGeneratedAttribute]
public void set_DoNotCopyLocalIfInGac(bool value);
    public string get_StateFile();
    public void set_StateFile(string value);
    public bool get_FindDependencies();
    public void set_FindDependencies(bool value);
    public bool get_FindSatellites();
    public void set_FindSatellites(bool value);
    public bool get_FindSerializationAssemblies();
    public void set_FindSerializationAssemblies(bool value);
    public bool get_FindRelatedFiles();
    public void set_FindRelatedFiles(bool value);
    public bool get_Silent();
    public void set_Silent(bool value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_TargetFrameworkMoniker();
    public void set_TargetFrameworkMoniker(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkMonikerDisplayName();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkMonikerDisplayName(string value);
    public String[] get_FullTargetFrameworkSubsetNames();
    public void set_FullTargetFrameworkSubsetNames(String[] value);
    public string get_ProfileName();
    public void set_ProfileName(string value);
    public String[] get_FullFrameworkFolders();
    public void set_FullFrameworkFolders(String[] value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public ITaskItem[] get_ResolvedFiles();
    public ITaskItem[] get_ResolvedDependencyFiles();
    public ITaskItem[] get_RelatedFiles();
    public ITaskItem[] get_SatelliteFiles();
    public ITaskItem[] get_SerializationAssemblyFiles();
    public ITaskItem[] get_ScatterFiles();
    public ITaskItem[] get_CopyLocalFiles();
    public ITaskItem[] get_SuggestedRedirects();
    public void set_FilesWritten(ITaskItem[] value);
    public ITaskItem[] get_FilesWritten();
    [CompilerGeneratedAttribute]
public string get_DependsOnSystemRuntime();
    [CompilerGeneratedAttribute]
private void set_DependsOnSystemRuntime(string value);
    [CompilerGeneratedAttribute]
public string get_DependsOnNETStandard();
    [CompilerGeneratedAttribute]
private void set_DependsOnNETStandard(string value);
    public ITaskItem[] get_UnresolvedAssemblyConflicts();
    private bool LogResults(ReferenceTable dependencyTable, List`1<DependentAssembly> idealAssemblyRemappings, List`1<AssemblyNameReference> idealAssemblyRemappingsIdentities, List`1<Exception> generalResolutionExceptions);
    internal static string ByteArrayToString(Byte[] a);
    private void LogReferenceDependenciesAndSourceItemsToStringBuilder(string fusionName, Reference conflictCandidate, StringBuilder log);
    private void LogDependeeReferenceToStringBuilder(Reference dependeeReference, StringBuilder log);
    private void LogReference(Reference reference, string fusionName);
    private MessageImportance ChooseReferenceLoggingImportance(Reference reference);
    private void LogInputs();
    private void LogAttribute(ITaskItem item, string metadataName);
    private void LogPrimaryOrDependency(Reference reference, string fusionName, MessageImportance importance);
    private void LogReferenceErrors(Reference reference, MessageImportance importance);
    private void LogFullName(Reference reference, MessageImportance importance);
    private void LogAssembliesConsideredAndRejected(Reference reference, string fusionName, MessageImportance importance);
    private void LogDependees(Reference reference, MessageImportance importance);
    private void LogRelatedFiles(Reference reference, MessageImportance importance);
    private void LogSatellites(Reference reference, MessageImportance importance);
    private void LogScatterFiles(Reference reference, MessageImportance importance);
    private void LogCopyLocalState(Reference reference, MessageImportance importance);
    private void LogImageRuntime(Reference reference, MessageImportance importance);
    private void LogConflict(Reference reference, string fusionName, StringBuilder log);
    internal void ReadStateFile(FileExists fileExists);
    internal void WriteStateFile();
    private List`1<DependentAssembly> GetAssemblyRemappingsFromAppConfig();
    internal bool Execute(FileExists fileExists, DirectoryExists directoryExists, GetDirectories getDirectories, GetAssemblyName getAssemblyName, GetAssemblyMetadata getAssemblyMetadata, GetRegistrySubKeyNames getRegistrySubKeyNames, GetRegistrySubKeyDefaultValue getRegistrySubKeyDefaultValue, GetLastWriteTime getLastWriteTime, GetAssemblyRuntimeVersion getRuntimeVersion, OpenBaseKey openBaseKey, GetAssemblyPathInGac getAssemblyPathInGac, IsWinMDFile isWinMDFile, ReadMachineTypeFromPEHeader readMachineTypeFromPEHeader);
    private AssemblyNameExtension[] GetDependencies(Reference resolvedReference, FileExists fileExists, GetAssemblyMetadata getAssemblyMetadata, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache);
    private static IReadOnlyCollection`1<DependentAssembly> CombineRemappedAssemblies(IReadOnlyCollection`1<DependentAssembly> first, IReadOnlyCollection`1<DependentAssembly> second);
    internal static Version SetTargetedRuntimeVersion(string targetedRuntimeVersionRawValue);
    private void HandleProfile(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[]& fullRedistAssemblyTableInfo, Dictionary`2& exclusionList, RedistList& fullFrameworkRedistList);
    internal static string GenerateSubSetName(String[] frameworkSubSetNames, ITaskItem[] installedSubSetNames);
    private bool VerifyInputConditions();
    private void DumpTargetProfileLists(AssemblyTableInfo[] installedAssemblyTableInfo, AssemblyTableInfo[] inclusionListSubsetTableInfo, ReferenceTable referenceTable);
    private bool ShouldUseSubsetExclusionList();
    private void PopulateSuggestedRedirects(List`1<DependentAssembly> idealAssemblyRemappings, List`1<AssemblyNameReference> idealAssemblyRemappedReferences);
    private AssemblyTableInfo[] GetInstalledAssemblyTableInfo(bool ignoreInstalledAssemblyTables, ITaskItem[] assemblyTables, GetListPath GetAssemblyListPaths, String[] targetFrameworkDirectories);
    private Version FrameworkVersionFromString(string version);
    private bool IsAvailableForTargetFramework(string assemblyFXVersionAsString);
    private void FilterBySubtypeAndTargetFramework();
    internal static string ProcessorArchitectureToString(ProcessorArchitecture processorArchitecture);
    internal static ProcessorArchitecture TargetProcessorArchitectureToEnumeration(string targetedProcessorArchitecture);
    private string GetAssemblyPathInGac(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
    public virtual bool Execute();
    [CompilerGeneratedAttribute]
private string <Execute>b__260_10(AssemblyNameExtension assemblyName, ProcessorArchitecture targetProcessorArchitecture, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, FileExists fileExists, bool fullFusionName, bool specificVersion);
}
public class Microsoft.Build.Tasks.ResolveCodeAnalysisRuleSet : TaskExtension {
    [CompilerGeneratedAttribute]
private string <CodeAnalysisRuleSet>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CodeAnalysisRuleSetDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedCodeAnalysisRuleSet>k__BackingField;
    public string CodeAnalysisRuleSet { get; public set; }
    public String[] CodeAnalysisRuleSetDirectories { get; public set; }
    public string MSBuildProjectDirectory { get; public set; }
    [OutputAttribute]
public string ResolvedCodeAnalysisRuleSet { get; private set; }
    [CompilerGeneratedAttribute]
public string get_CodeAnalysisRuleSet();
    [CompilerGeneratedAttribute]
public void set_CodeAnalysisRuleSet(string value);
    [CompilerGeneratedAttribute]
public String[] get_CodeAnalysisRuleSetDirectories();
    [CompilerGeneratedAttribute]
public void set_CodeAnalysisRuleSetDirectories(String[] value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectDirectory();
    [CompilerGeneratedAttribute]
public void set_MSBuildProjectDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_ResolvedCodeAnalysisRuleSet();
    [CompilerGeneratedAttribute]
private void set_ResolvedCodeAnalysisRuleSet(string value);
    public virtual bool Execute();
    private string GetResolvedRuleSetPath();
}
public class Microsoft.Build.Tasks.ResolveComReference : AppDomainIsolatedTaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <TypeLibNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <TypeLibFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EnvironmentVariables>k__BackingField;
    internal List`1<ComReferenceInfo> allProjectRefs;
    internal List`1<ComReferenceInfo> allDependencyRefs;
    [CompilerGeneratedAttribute]
private string <WrapperOutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeVersionInInteropName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResolvedAssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoClassMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Silent>k__BackingField;
    private string _targetProcessorArchitecture;
    [CompilerGeneratedAttribute]
private bool <ExecuteAsTool>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResolvedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResolvedModules>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkToolsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StateFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    private Version _projectTargetFramework;
    private static Version s_targetFrameworkVersion_40;
    private ResolveComReferenceCache _timestampCache;
    private Dictionary`2<string, ComReferenceWrapperInfo> _cachePia;
    private Dictionary`2<string, ComReferenceWrapperInfo> _cacheTlb;
    private Dictionary`2<string, ComReferenceWrapperInfo> _cacheAx;
    private string _aximpPath;
    private string _tlbimpPath;
    private static String[] s_requiredMetadataForNameItem;
    public ITaskItem[] TypeLibNames { get; public set; }
    public ITaskItem[] TypeLibFiles { get; public set; }
    public String[] EnvironmentVariables { get; public set; }
    public string WrapperOutputDirectory { get; public set; }
    public bool IncludeVersionInInteropName { get; public set; }
    public ITaskItem[] ResolvedAssemblyReferences { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public bool DelaySign { get; public set; }
    public bool NoClassMembers { get; public set; }
    public bool Silent { get; public set; }
    public string TargetProcessorArchitecture { get; public set; }
    public bool ExecuteAsTool { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedModules { get; public set; }
    public string SdkToolsPath { get; public set; }
    public string StateFile { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    private static ResolveComReference();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_TypeLibNames();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeLibNames(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_TypeLibFiles();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeLibFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_EnvironmentVariables();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EnvironmentVariables(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_WrapperOutputDirectory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WrapperOutputDirectory(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IncludeVersionInInteropName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IncludeVersionInInteropName(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ResolvedAssemblyReferences();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResolvedAssemblyReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyContainer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_KeyContainer(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_DelaySign();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DelaySign(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_NoClassMembers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NoClassMembers(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Silent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Silent(bool value);
    public sealed virtual string get_TargetProcessorArchitecture();
    public sealed virtual void set_TargetProcessorArchitecture(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExecuteAsTool();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExecuteAsTool(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ResolvedFiles();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResolvedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual ITaskItem[] get_ResolvedModules();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResolvedModules(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SdkToolsPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SdkToolsPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StateFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_StateFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetFrameworkVersion(string value);
    public virtual bool Execute();
    internal void SetFrameworkVersionFromString(string version);
    private bool ComputePathToTlbImp();
    private bool ComputePathToAxImp();
    private string GetPathToSDKFileWithCurrentlyTargetedArchitecture(string file, TargetDotNetFrameworkVersion targetFrameworkVersion, VisualStudioVersion visualStudioVersion);
    private void Cleanup();
    private bool VerifyAndInitializeInputs();
    private void ConvertAttrReferencesToComReferenceInfo(List`1<ComReferenceInfo> projectRefs, ITaskItem[] typeLibAttrs);
    private void ConvertFileReferencesToComReferenceInfo(List`1<ComReferenceInfo> projectRefs, ITaskItem[] tlbFiles);
    internal void AddMissingTlbReferences();
    private bool ResolveReferenceAndAddToList(ComDependencyWalker dependencyWalker, ComReferenceInfo projectRefInfo, List`1<ITaskItem> resolvedReferenceList, List`1<ITaskItem> moduleList);
    internal bool ResolveReference(ComDependencyWalker dependencyWalker, ComReferenceInfo referenceInfo, string outputDirectory, ITaskItem& referencePathItem);
    internal bool IsExistingProjectReference(TYPELIBATTR typeLibAttr, string neededRefType, ComReferenceInfo& referenceInfo);
    internal bool IsExistingDependencyReference(TYPELIBATTR typeLibAttr, ComReferenceInfo& referenceInfo);
    internal bool ResolveComClassicReference(ComReferenceInfo referenceInfo, string outputDirectory, string wrapperType, string refName, bool topLevelRef, List`1<string> dependencyPaths, ComReferenceWrapperInfo& wrapperInfo);
    private sealed virtual override bool Microsoft.Build.Tasks.IComReferenceResolver.ResolveComClassicReference(TYPELIBATTR typeLibAttr, string outputDirectory, string wrapperType, string refName, ComReferenceWrapperInfo& wrapperInfo);
    private sealed virtual override bool Microsoft.Build.Tasks.IComReferenceResolver.ResolveNetAssemblyReference(string assemblyName, String& assemblyPath);
    private sealed virtual override bool Microsoft.Build.Tasks.IComReferenceResolver.ResolveComAssemblyReference(string fullAssemblyName, String& assemblyPath);
    internal bool ResolveComReferencePia(ComReferenceInfo referenceInfo, string refName, ComReferenceWrapperInfo& wrapperInfo);
    internal IEnumerable`1<string> GetResolvedAssemblyReferenceItemSpecs();
    internal bool ResolveComReferenceTlb(ComReferenceInfo referenceInfo, string outputDirectory, string refName, bool topLevelRef, List`1<string> dependencyPaths, ComReferenceWrapperInfo& wrapperInfo);
    internal bool ResolveComReferenceAx(ComReferenceInfo referenceInfo, string outputDirectory, string refName, ComReferenceWrapperInfo& wrapperInfo);
    internal static bool VerifyReferenceMetadataForNameItem(ITaskItem reference, String& missingOrInvalidMetadata);
    internal static void InitializeDefaultMetadataForNameItem(ITaskItem reference);
    internal static void InitializeDefaultMetadataForFileItem(ITaskItem reference);
    internal bool CheckForConflictingReferences();
    internal void SetCopyLocalToFalseOnGacOrNoPIAAssemblies(List`1<ITaskItem> outputTaskItems, string gacPath);
    private List`1<string> ScanAndResolveAllDependencies(ComDependencyWalker dependencyWalker, ComReferenceInfo reference);
    internal static TYPELIBATTR TaskItemToTypeLibAttr(ITaskItem taskItem);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Tasks.ResolveComReferenceCache : StateFileBase {
    internal Dictionary`2<string, DateTime> componentTimestamps;
    internal string tlbImpLocation;
    internal string axImpLocation;
    private bool _dirty;
    internal bool Dirty { get; }
    internal DateTime Item { get; internal set; }
    internal ResolveComReferenceCache(string tlbImpPath, string axImpPath);
    public ResolveComReferenceCache(ITranslator translator);
    internal bool get_Dirty();
    internal bool ToolPathsMatchCachePaths(string tlbImpPath, string axImpPath);
    internal DateTime get_Item(string componentPath);
    internal void set_Item(string componentPath, DateTime value);
    public virtual void Translate(ITranslator translator);
}
public class Microsoft.Build.Tasks.ResolveKeySource : TaskExtension {
    private static string pfxFileExtension;
    private static string pfxFileContainerPrefix;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateThumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressAutoClosePasswordPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowImportDialogDespitePreviousFailures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoClosePasswordPromptTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoClosePasswordPromptShow>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedThumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedKeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedKeyFile>k__BackingField;
    public string KeyFile { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public string CertificateFile { get; public set; }
    public bool SuppressAutoClosePasswordPrompt { get; public set; }
    public bool ShowImportDialogDespitePreviousFailures { get; public set; }
    public int AutoClosePasswordPromptTimeout { get; public set; }
    public int AutoClosePasswordPromptShow { get; public set; }
    [OutputAttribute]
public string ResolvedThumbprint { get; public set; }
    [OutputAttribute]
public string ResolvedKeyContainer { get; public set; }
    [OutputAttribute]
public string ResolvedKeyFile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateThumbprint();
    [CompilerGeneratedAttribute]
public void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public string get_CertificateFile();
    [CompilerGeneratedAttribute]
public void set_CertificateFile(string value);
    [CompilerGeneratedAttribute]
public bool get_SuppressAutoClosePasswordPrompt();
    [CompilerGeneratedAttribute]
public void set_SuppressAutoClosePasswordPrompt(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowImportDialogDespitePreviousFailures();
    [CompilerGeneratedAttribute]
public void set_ShowImportDialogDespitePreviousFailures(bool value);
    [CompilerGeneratedAttribute]
public int get_AutoClosePasswordPromptTimeout();
    [CompilerGeneratedAttribute]
public void set_AutoClosePasswordPromptTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_AutoClosePasswordPromptShow();
    [CompilerGeneratedAttribute]
public void set_AutoClosePasswordPromptShow(int value);
    [CompilerGeneratedAttribute]
public string get_ResolvedThumbprint();
    [CompilerGeneratedAttribute]
public void set_ResolvedThumbprint(string value);
    [CompilerGeneratedAttribute]
public string get_ResolvedKeyContainer();
    [CompilerGeneratedAttribute]
public void set_ResolvedKeyContainer(string value);
    [CompilerGeneratedAttribute]
public string get_ResolvedKeyFile();
    [CompilerGeneratedAttribute]
public void set_ResolvedKeyFile(string value);
    public virtual bool Execute();
    private static ulong HashFromBlob(Byte[] data);
    private bool ResolveAssemblyKey();
    private bool ResolveManifestKey();
}
public class Microsoft.Build.Tasks.ResolveManifestFiles : TaskExtension {
    private ITaskItem[] _extraFiles;
    private ITaskItem[] _files;
    private ITaskItem[] _managedAssemblies;
    private ITaskItem[] _nativeAssemblies;
    private ITaskItem[] _publishFiles;
    private ITaskItem[] _satelliteAssemblies;
    private CultureInfo _targetCulture;
    private bool _includeAllSatellites;
    private string _targetFrameworkIdentifier;
    private string _targetFrameworkVersion;
    private bool _canPublish;
    private Dictionary`2<string, ITaskItem> _runtimePackAssets;
    private SatelliteRefAssemblyMap _satelliteAssembliesPassedAsReferences;
    [CompilerGeneratedAttribute]
private ITaskItem <DeploymentManifestEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <RuntimePackAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSelfContainedPublish>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSingleFilePublish>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutputAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputDeploymentManifestEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <OutputFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SigningManifests>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LauncherBasedDeployment>k__BackingField;
    public ITaskItem DeploymentManifestEntryPoint { get; public set; }
    public ITaskItem EntryPoint { get; public set; }
    public ITaskItem[] ExtraFiles { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public ITaskItem[] ManagedAssemblies { get; public set; }
    public ITaskItem[] NativeAssemblies { get; public set; }
    public ITaskItem[] RuntimePackAssets { get; public set; }
    public bool IsSelfContainedPublish { get; public set; }
    public bool IsSingleFilePublish { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputAssemblies { get; public set; }
    [OutputAttribute]
public ITaskItem OutputDeploymentManifestEntryPoint { get; public set; }
    [OutputAttribute]
public ITaskItem OutputEntryPoint { get; public set; }
    [OutputAttribute]
public ITaskItem[] OutputFiles { get; public set; }
    public ITaskItem[] PublishFiles { get; public set; }
    public ITaskItem[] SatelliteAssemblies { get; public set; }
    public string TargetCulture { get; public set; }
    public bool SigningManifests { get; public set; }
    public string AssemblyName { get; public set; }
    public bool LauncherBasedDeployment { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TargetFrameworkIdentifier { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DeploymentManifestEntryPoint();
    [CompilerGeneratedAttribute]
public void set_DeploymentManifestEntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(ITaskItem value);
    public ITaskItem[] get_ExtraFiles();
    public void set_ExtraFiles(ITaskItem[] value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public ITaskItem[] get_ManagedAssemblies();
    public void set_ManagedAssemblies(ITaskItem[] value);
    public ITaskItem[] get_NativeAssemblies();
    public void set_NativeAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_RuntimePackAssets();
    [CompilerGeneratedAttribute]
public void set_RuntimePackAssets(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_IsSelfContainedPublish();
    [CompilerGeneratedAttribute]
public void set_IsSelfContainedPublish(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSingleFilePublish();
    [CompilerGeneratedAttribute]
public void set_IsSingleFilePublish(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutputAssemblies();
    [CompilerGeneratedAttribute]
public void set_OutputAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputDeploymentManifestEntryPoint();
    [CompilerGeneratedAttribute]
public void set_OutputDeploymentManifestEntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputEntryPoint();
    [CompilerGeneratedAttribute]
public void set_OutputEntryPoint(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_OutputFiles();
    [CompilerGeneratedAttribute]
public void set_OutputFiles(ITaskItem[] value);
    public ITaskItem[] get_PublishFiles();
    public void set_PublishFiles(ITaskItem[] value);
    public ITaskItem[] get_SatelliteAssemblies();
    public void set_SatelliteAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetCulture();
    [CompilerGeneratedAttribute]
public void set_TargetCulture(string value);
    [CompilerGeneratedAttribute]
public bool get_SigningManifests();
    [CompilerGeneratedAttribute]
public void set_SigningManifests(bool value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public bool get_LauncherBasedDeployment();
    [CompilerGeneratedAttribute]
public void set_LauncherBasedDeployment(bool value);
    public string get_TargetFrameworkVersion();
    public void set_TargetFrameworkVersion(string value);
    public string get_TargetFrameworkIdentifier();
    public void set_TargetFrameworkIdentifier(string value);
    public virtual bool Execute();
    private static Version ConvertFrameworkVersionToString(string version);
    private static int CompareFrameworkVersions(string versionA, string versionB);
    private bool ValidateInputs();
    private static ITaskItem CreateAssemblyItem(ITaskItem item, string group, string targetPath, string includeHash);
    private ITaskItem CreateFileItem(ITaskItem item, string group, string targetPath, string includeHash, bool isDataFile);
    private static ITaskItem CreatePrerequisiteItem(ITaskItem item);
    private static bool GetItemCopyLocal(ITaskItem item);
    private static CultureInfo GetItemCulture(ITaskItem item);
    private static string GetItemTargetPath(ITaskItem item);
    private void GetOutputAssemblies(List`1<PublishInfo> publishInfos, List`1<ITaskItem> assemblyList);
    private ITaskItem[] GetOutputAssembliesAndSatellites(List`1<PublishInfo> assemblyPublishInfos, List`1<PublishInfo> satellitePublishInfos);
    private ITaskItem[] GetOutputFiles(List`1<PublishInfo> publishInfos, IEnumerable`1<ITaskItem> outputAssemblies);
    private void GetOutputSatellites(List`1<PublishInfo> publishInfos, List`1<ITaskItem> assemblyList);
    private ITaskItem GetOutputEntryPoint(ITaskItem entryPoint, List`1<PublishInfo> manifestEntryPointList);
    private void GetPublishInfo(List`1& assemblyPublishInfos, List`1& filePublishInfos, List`1& satellitePublishInfos, List`1& manifestEntryPointPublishInfos);
    private bool IsFiltered(ITaskItem item);
    private static PublishState StringToPublishState(string value);
}
public class Microsoft.Build.Tasks.ResolveNativeReference : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <ContainingReferenceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ContainedPrerequisiteAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ContainedComComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ContainedTypeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ContainedLooseTlbFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ContainedLooseEtcFiles>k__BackingField;
    private ITaskItem[] _nativeReferences;
    private String[] _additionalSearchPaths;
    [RequiredAttribute]
public ITaskItem[] NativeReferences { get; public set; }
    [RequiredAttribute]
public String[] AdditionalSearchPaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainingReferenceFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedPrerequisiteAssemblies { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedComComponents { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedTypeLibraries { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedLooseTlbFiles { get; public set; }
    [OutputAttribute]
public ITaskItem[] ContainedLooseEtcFiles { get; public set; }
    public ITaskItem[] get_NativeReferences();
    public void set_NativeReferences(ITaskItem[] value);
    public String[] get_AdditionalSearchPaths();
    public void set_AdditionalSearchPaths(String[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ContainingReferenceFiles();
    [CompilerGeneratedAttribute]
public void set_ContainingReferenceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ContainedPrerequisiteAssemblies();
    [CompilerGeneratedAttribute]
public void set_ContainedPrerequisiteAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ContainedComComponents();
    [CompilerGeneratedAttribute]
public void set_ContainedComComponents(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ContainedTypeLibraries();
    [CompilerGeneratedAttribute]
public void set_ContainedTypeLibraries(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ContainedLooseTlbFiles();
    [CompilerGeneratedAttribute]
public void set_ContainedLooseTlbFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ContainedLooseEtcFiles();
    [CompilerGeneratedAttribute]
public void set_ContainedLooseEtcFiles(ITaskItem[] value);
    public virtual bool Execute();
    internal bool ExtractFromManifest(ITaskItem taskItem, string path, Dictionary`2<string, ITaskItem> containingReferenceFilesTable, Dictionary`2<string, ITaskItem> containedPrerequisiteAssembliesTable, Dictionary`2<string, ITaskItem> containedComComponentsTable, Dictionary`2<string, ITaskItem> containedTypeLibrariesTable, Dictionary`2<string, ITaskItem> containedLooseTlbFilesTable, Dictionary`2<string, ITaskItem> containedLooseEtcFilesTable);
}
public class Microsoft.Build.Tasks.ResolveNonMSBuildProjectOutput : ResolveProjectBase {
    [CompilerGeneratedAttribute]
private string <PreresolvedProjectOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResolvedOutputPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <UnresolvedProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private GetAssemblyNameDelegate <GetAssemblyName>k__BackingField;
    public string PreresolvedProjectOutputs { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedOutputPaths { get; public set; }
    [OutputAttribute]
public ITaskItem[] UnresolvedProjectReferences { get; public set; }
    internal GetAssemblyNameDelegate GetAssemblyName { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_PreresolvedProjectOutputs();
    [CompilerGeneratedAttribute]
public void set_PreresolvedProjectOutputs(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ResolvedOutputPaths();
    [CompilerGeneratedAttribute]
public void set_ResolvedOutputPaths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_UnresolvedProjectReferences();
    [CompilerGeneratedAttribute]
public void set_UnresolvedProjectReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
internal GetAssemblyNameDelegate get_GetAssemblyName();
    [CompilerGeneratedAttribute]
internal void set_GetAssemblyName(GetAssemblyNameDelegate value);
    public virtual bool Execute();
    internal bool ResolveProject(ITaskItem projectRef, ITaskItem& resolvedPath);
}
public abstract class Microsoft.Build.Tasks.ResolveProjectBase : TaskExtension {
    private ITaskItem[] _projectReferences;
    private HashSet`1<string> _cachedProjectReferencesByAbsolutePath;
    private SolutionConfiguration _solutionConfiguration;
    private static string attributeProject;
    [RequiredAttribute]
public ITaskItem[] ProjectReferences { get; public set; }
    public ITaskItem[] get_ProjectReferences();
    public void set_ProjectReferences(ITaskItem[] value);
    internal bool VerifyReferenceAttributes(ITaskItem reference, String& missingAttribute);
    internal bool VerifyProjectReferenceItems(ITaskItem[] references, bool treatAsError);
    internal void CacheProjectElementsFromXml(string xmlString);
    protected string GetProjectItem(ITaskItem projectRef);
    protected XmlElement GetProjectElement(ITaskItem projectRef);
    protected void AddSyntheticProjectReferences(string currentProjectAbsolutePath);
}
internal abstract class Microsoft.Build.Tasks.Resolver : object {
    protected string searchPathElement;
    protected GetAssemblyName getAssemblyName;
    protected FileExists fileExists;
    protected GetAssemblyRuntimeVersion getRuntimeVersion;
    protected Version targetedRuntimeVersion;
    protected ProcessorArchitecture targetProcessorArchitecture;
    protected bool compareProcessorArchitecture;
    public string SearchPath { get; }
    protected Resolver(string searchPathElement, GetAssemblyName getAssemblyName, FileExists fileExists, GetAssemblyRuntimeVersion getRuntimeVersion, Version targetedRuntimeVersion, ProcessorArchitecture targetedProcessorArchitecture, bool compareProcessorArchitecture);
    public abstract virtual bool Resolve(AssemblyNameExtension assemblyName, string sdkName, string rawFileNameCandidate, bool isPrimaryProjectReference, bool isImmutableFrameworkReference, bool wantSpecificVersion, String[] executableExtensions, string hintPath, string assemblyFolderKey, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected, String& foundPath, Boolean& userRequestedSpecificFile);
    public string get_SearchPath();
    protected bool ResolveAsFile(string fullPath, AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, bool allowMismatchBetweenFusionNameAndFileName, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected);
    protected bool FileMatchesAssemblyName(AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, bool allowMismatchBetweenFusionNameAndFileName, string pathToCandidateAssembly, ResolutionSearchLocation searchLocation);
    protected string ResolveFromDirectory(AssemblyNameExtension assemblyName, bool isPrimaryProjectReference, bool wantSpecificVersion, String[] executableExtensions, string directory, List`1<ResolutionSearchLocation> assembliesConsideredAndRejected);
}
public class Microsoft.Build.Tasks.ResolveSDKReference : TaskExtension {
    private static Dictionary`2<string, string> PlatformAliases;
    private static Regex s_sdkReferenceFormat;
    private static string SDKsimpleNameGroup;
    private static string SDKVersionGroup;
    private static string CommaSpaceDelimiter;
    private static Char[] s_appxSplitChar;
    private static string SDKName;
    private static string SDKPlatformVersion;
    private static Version s_defaultTargetPlatformVersion;
    private ITaskItem[] _sdkReferences;
    private ITaskItem[] _installedSDKs;
    private Version _targetPlatformVersion;
    private string _targetPlatformIdentifier;
    private string _projectName;
    private Dictionary`2<string, string> _runtimeReferenceOnlyDependenciesByName;
    [CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <DisallowedSDKDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <RuntimeReferenceOnlySDKDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetedSDKConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetedSDKArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WarnOnMissingPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogResolutionErrorsAsWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prefer32Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ResolvedSDKReferences>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SDKReferences { get; public set; }
    [RequiredAttribute]
public ITaskItem[] InstalledSDKs { get; public set; }
    [RequiredAttribute]
public string TargetPlatformIdentifier { get; public set; }
    [RequiredAttribute]
public string ProjectName { get; public set; }
    [RequiredAttribute]
public string TargetPlatformVersion { get; public set; }
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] DisallowedSDKDependencies { get; public set; }
    public ITaskItem[] RuntimeReferenceOnlySDKDependencies { get; public set; }
    public string TargetedSDKConfiguration { get; public set; }
    public string TargetedSDKArchitecture { get; public set; }
    public bool WarnOnMissingPlatformVersion { get; public set; }
    public bool LogResolutionErrorsAsWarnings { get; public set; }
    public bool Prefer32Bit { get; public set; }
    [OutputAttribute]
public ITaskItem[] ResolvedSDKReferences { get; private set; }
    private Version TargetPlatformAsVersion { get; private set; }
    private static ResolveSDKReference();
    public ITaskItem[] get_SDKReferences();
    public void set_SDKReferences(ITaskItem[] value);
    public ITaskItem[] get_InstalledSDKs();
    public void set_InstalledSDKs(ITaskItem[] value);
    public string get_TargetPlatformIdentifier();
    public void set_TargetPlatformIdentifier(string value);
    public string get_ProjectName();
    public void set_ProjectName(string value);
    public string get_TargetPlatformVersion();
    public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_DisallowedSDKDependencies();
    [CompilerGeneratedAttribute]
public void set_DisallowedSDKDependencies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_RuntimeReferenceOnlySDKDependencies();
    [CompilerGeneratedAttribute]
public void set_RuntimeReferenceOnlySDKDependencies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetedSDKConfiguration();
    [CompilerGeneratedAttribute]
public void set_TargetedSDKConfiguration(string value);
    [CompilerGeneratedAttribute]
public string get_TargetedSDKArchitecture();
    [CompilerGeneratedAttribute]
public void set_TargetedSDKArchitecture(string value);
    [CompilerGeneratedAttribute]
public bool get_WarnOnMissingPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_WarnOnMissingPlatformVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogResolutionErrorsAsWarnings();
    [CompilerGeneratedAttribute]
public void set_LogResolutionErrorsAsWarnings(bool value);
    [CompilerGeneratedAttribute]
public bool get_Prefer32Bit();
    [CompilerGeneratedAttribute]
public void set_Prefer32Bit(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ResolvedSDKReferences();
    [CompilerGeneratedAttribute]
private void set_ResolvedSDKReferences(ITaskItem[] value);
    private Version get_TargetPlatformAsVersion();
    private void set_TargetPlatformAsVersion(Version value);
    public virtual bool Execute();
    internal static void AddMetadataToReferences(TaskLoggingHelper log, HashSet`1<SDKReference> sdkReferenceItems, Dictionary`2<string, string> referencesToAddMetadata, string metadataName, string metadataValue);
    internal static void VerifySDKDependsOn(TaskLoggingHelper log, HashSet`1<SDKReference> sdkReferenceItems);
    internal static String[] GetUnresolvedDependentSDKs(HashSet`1<SDKReference> sdkReferenceItems, List`1<string> dependentSDKs);
    internal static List`1<string> ParseDependsOnSDK(string dependsOnSDK);
    internal SDKReference ParseSDKReference(ITaskItem referenceItem);
    private static bool ParseSDKReference(string reference, String& sdkSimpleName, String& rawSdkVersion);
    private void LogResolution(SDKReference reference);
    private void LogErrorOrWarning(Tuple`2<string, Object[]> errorOrWarning);
}
internal class Microsoft.Build.Tasks.ResourceHandling.BinaryFormatterByteArrayResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginatingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    public string Name { get; }
    public string OriginatingFile { get; }
    public Byte[] Bytes { get; }
    public string TypeAssemblyQualifiedName { get; }
    public string TypeFullName { get; }
    public BinaryFormatterByteArrayResource(string name, Byte[] bytes, string originatingFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public string get_OriginatingFile();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    public sealed virtual string get_TypeAssemblyQualifiedName();
    public sealed virtual string get_TypeFullName();
    public sealed virtual void AddTo(IResourceWriter writer);
}
internal class Microsoft.Build.Tasks.ResourceHandling.FileStreamResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeAssemblyQualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginatingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string Name { get; }
    public string TypeAssemblyQualifiedName { get; }
    public string OriginatingFile { get; }
    public string FileName { get; }
    public string TypeFullName { get; }
    public FileStreamResource(string name, string assemblyQualifiedTypeName, string fileName, string originatingFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeAssemblyQualifiedName();
    [CompilerGeneratedAttribute]
public string get_OriginatingFile();
    [CompilerGeneratedAttribute]
public string get_FileName();
    public sealed virtual string get_TypeFullName();
    public sealed virtual void AddTo(IResourceWriter writer);
}
internal class Microsoft.Build.Tasks.ResourceHandling.InputFormatNotSupportedException : Exception {
    public InputFormatNotSupportedException(string message);
    public InputFormatNotSupportedException(string message, Exception innerException);
    protected InputFormatNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal interface Microsoft.Build.Tasks.ResourceHandling.IResource {
    public string Name { get; }
    public string TypeAssemblyQualifiedName { get; }
    public string TypeFullName { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_TypeAssemblyQualifiedName();
    public abstract virtual string get_TypeFullName();
    public abstract virtual void AddTo(IResourceWriter writer);
}
internal class Microsoft.Build.Tasks.ResourceHandling.LiveObjectResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    public string TypeAssemblyQualifiedName { get; }
    public string TypeFullName { get; }
    public LiveObjectResource(string name, object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    public sealed virtual string get_TypeAssemblyQualifiedName();
    public sealed virtual string get_TypeFullName();
    public sealed virtual void AddTo(IResourceWriter writer);
}
internal class Microsoft.Build.Tasks.ResourceHandling.MSBuildResXException : Exception {
    public MSBuildResXException(string message);
    public MSBuildResXException(string message, Exception innerException);
    protected MSBuildResXException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.ResourceHandling.MSBuildResXReader : object {
    private static string Beta2CompatSerializedObjectMimeType;
    private static string CompatBinSerializedObjectMimeType;
    private static string BinSerializedObjectMimeType;
    private static string ByteArraySerializedObjectMimeType;
    private static string StringTypeNamePrefix;
    private static string StringTypeName40;
    private static string MemoryStreamTypeNamePrefix;
    public static IReadOnlyList`1<IResource> ReadResources(Stream s, string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter);
    private static void ParseAssemblyAlias(Dictionary`2<string, string> aliases, XElement elem);
    private static string GetFullTypeNameFromAlias(string aliasedTypeName, Dictionary`2<string, string> aliases);
    private static void ParseData(string resxFilename, bool pathsRelativeToBasePath, List`1<IResource> resources, Dictionary`2<string, string> aliases, XElement elem, TaskLoggingHelper log, bool logWarningForBinaryFormatter);
    private static void AddLinkedResource(string resxFilename, bool pathsRelativeToBasePath, List`1<IResource> resources, string name, string value);
    private static bool IsByteArray(string fileRefType);
    internal static bool IsString(string fileRefType);
    internal static bool IsMemoryStream(string fileRefType);
    public static IReadOnlyList`1<IResource> GetResourcesFromFile(string filename, bool pathsRelativeToBasePath, TaskLoggingHelper log, bool logWarningForBinaryFormatter);
    public static IReadOnlyList`1<IResource> GetResourcesFromString(string resxContent, TaskLoggingHelper log, bool logWarningForBinaryFormatter, string basePath, Nullable`1<bool> useRelativePath);
    internal static String[] ParseResxFileRefString(string stringValue);
}
internal static class Microsoft.Build.Tasks.ResourceHandling.NameUtilities : object {
    internal static string FullNameFromAssemblyQualifiedName(string assemblyQualifiedName);
}
internal class Microsoft.Build.Tasks.ResourceHandling.PreserializedResourceWriterRequiredException : Exception {
    private PreserializedResourceWriterRequiredException(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.Tasks.ResourceHandling.StringResource : LiveObjectResource {
    [CompilerGeneratedAttribute]
private string <OriginatingFile>k__BackingField;
    public string OriginatingFile { get; }
    public string TypeFullName { get; }
    public StringResource(string name, string value, string filename);
    [CompilerGeneratedAttribute]
public string get_OriginatingFile();
    public string get_TypeFullName();
    public void AddTo(IResourceWriter writer);
    public virtual string ToString();
}
internal class Microsoft.Build.Tasks.ResourceHandling.TypeConverterByteArrayResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeAssemblyQualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginatingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    public string Name { get; }
    public string TypeAssemblyQualifiedName { get; }
    public string OriginatingFile { get; }
    public Byte[] Bytes { get; }
    public string TypeFullName { get; }
    public TypeConverterByteArrayResource(string name, string assemblyQualifiedTypeName, Byte[] bytes, string originatingFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeAssemblyQualifiedName();
    [CompilerGeneratedAttribute]
public string get_OriginatingFile();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    public sealed virtual string get_TypeFullName();
    public sealed virtual void AddTo(IResourceWriter writer);
}
internal class Microsoft.Build.Tasks.ResourceHandling.TypeConverterStringResource : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeAssemblyQualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OriginatingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StringRepresentation>k__BackingField;
    public string Name { get; }
    public string TypeAssemblyQualifiedName { get; }
    public string OriginatingFile { get; }
    public string StringRepresentation { get; }
    public string TypeFullName { get; }
    public TypeConverterStringResource(string name, string assemblyQualifiedTypeName, string stringRepresentation, string originatingFile);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeAssemblyQualifiedName();
    [CompilerGeneratedAttribute]
public string get_OriginatingFile();
    [CompilerGeneratedAttribute]
public string get_StringRepresentation();
    public sealed virtual string get_TypeFullName();
    public sealed virtual void AddTo(IResourceWriter writer);
}
public class Microsoft.Build.Tasks.RoslynCodeTaskFactory : object {
    internal static IList`1<string> DefaultNamespaces;
    internal static IDictionary`2<string, IEnumerable`1<string>> DefaultReferences;
    internal static IDictionary`2<string, ISet`1<string>> ValidCodeLanguages;
    private static string ReferenceAssemblyDirectoryName;
    private static String[] MonoLibDirs;
    private static ConcurrentDictionary`2<RoslynCodeTaskFactoryTaskInfo, Assembly> CompiledAssemblyCache;
    private static Lazy`1<string> ThisAssemblyDirectoryLazy;
    private TaskLoggingHelper _log;
    private ResolveEventHandler handlerAddedToAppDomain;
    private TaskPropertyInfo[] _parameters;
    private string _taskName;
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    private static RoslynCodeTaskFactory();
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual void CleanupTask(ITask task);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    internal static string GetSourceCode(RoslynCodeTaskFactoryTaskInfo taskInfo, ICollection`1<TaskPropertyInfo> parameters);
    internal static bool TryLoadTaskBody(TaskLoggingHelper log, string taskName, string taskBody, ICollection`1<TaskPropertyInfo> parameters, RoslynCodeTaskFactoryTaskInfo& taskInfo);
    internal bool TryResolveAssemblyReferences(TaskLoggingHelper log, RoslynCodeTaskFactoryTaskInfo taskInfo, ITaskItem[]& items);
    private static CodeMemberProperty CreateProperty(CodeTypeDeclaration codeTypeDeclaration, string name, Type type, object defaultValue);
    private bool TryCompileInMemoryAssembly(IBuildEngine buildEngine, RoslynCodeTaskFactoryTaskInfo taskInfo, Assembly& assembly);
    private static String[] GetMonoLibDirs();
    [CompilerGeneratedAttribute]
internal static Assembly <TryResolveAssemblyReferences>g__TryLoadAssembly|23_2(List`1<string> directories, AssemblyName name);
}
internal enum Microsoft.Build.Tasks.RoslynCodeTaskFactoryCodeType : Enum {
    public int value__;
    public static RoslynCodeTaskFactoryCodeType Fragment;
    public static RoslynCodeTaskFactoryCodeType Method;
    public static RoslynCodeTaskFactoryCodeType Class;
}
internal abstract class Microsoft.Build.Tasks.RoslynCodeTaskFactoryCompilerBase : ToolTaskExtension {
    private Lazy`1<string> _executablePath;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoStandardLib>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <UseSharedCompilation>k__BackingField;
    public Nullable`1<bool> Deterministic { get; public set; }
    public Nullable`1<bool> NoConfig { get; public set; }
    public Nullable`1<bool> NoLogo { get; public set; }
    public Nullable`1<bool> NoStandardLib { get; public set; }
    public Nullable`1<bool> Optimize { get; public set; }
    public ITaskItem OutputAssembly { get; public set; }
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] Sources { get; public set; }
    public string TargetType { get; public set; }
    public Nullable`1<bool> UseSharedCompilation { get; public set; }
    protected string ReferenceSwitch { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Deterministic();
    [CompilerGeneratedAttribute]
public void set_Deterministic(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoConfig();
    [CompilerGeneratedAttribute]
public void set_NoConfig(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoLogo();
    [CompilerGeneratedAttribute]
public void set_NoLogo(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoStandardLib();
    [CompilerGeneratedAttribute]
public void set_NoStandardLib(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public void set_Optimize(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputAssembly();
    [CompilerGeneratedAttribute]
public void set_OutputAssembly(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Sources();
    [CompilerGeneratedAttribute]
public void set_Sources(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetType();
    [CompilerGeneratedAttribute]
public void set_TargetType(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_UseSharedCompilation();
    [CompilerGeneratedAttribute]
public void set_UseSharedCompilation(Nullable`1<bool> value);
    protected virtual string get_ReferenceSwitch();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    [CompilerGeneratedAttribute]
private string <.ctor>b__1_0();
}
internal class Microsoft.Build.Tasks.RoslynCodeTaskFactoryCSharpCompiler : RoslynCodeTaskFactoryCompilerBase {
    protected string ToolName { get; }
    protected virtual string get_ToolName();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
internal class Microsoft.Build.Tasks.RoslynCodeTaskFactoryTaskInfo : object {
    [CompilerGeneratedAttribute]
private string <CodeLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private RoslynCodeTaskFactoryCodeType <CodeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <References>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceCode>k__BackingField;
    public string CodeLanguage { get; public set; }
    public RoslynCodeTaskFactoryCodeType CodeType { get; public set; }
    public string Name { get; public set; }
    public ISet`1<string> Namespaces { get; }
    public ISet`1<string> References { get; }
    public string SourceCode { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CodeLanguage();
    [CompilerGeneratedAttribute]
public void set_CodeLanguage(string value);
    [CompilerGeneratedAttribute]
public RoslynCodeTaskFactoryCodeType get_CodeType();
    [CompilerGeneratedAttribute]
public void set_CodeType(RoslynCodeTaskFactoryCodeType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_Namespaces();
    [CompilerGeneratedAttribute]
public ISet`1<string> get_References();
    [CompilerGeneratedAttribute]
public string get_SourceCode();
    [CompilerGeneratedAttribute]
public void set_SourceCode(string value);
    public sealed virtual bool Equals(RoslynCodeTaskFactoryTaskInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.Tasks.RoslynCodeTaskFactoryVisualBasicCompiler : RoslynCodeTaskFactoryCompilerBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <OptionExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootNamespace>k__BackingField;
    public Nullable`1<bool> OptionExplicit { get; public set; }
    public string RootNamespace { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_OptionExplicit();
    [CompilerGeneratedAttribute]
public void set_OptionExplicit(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_RootNamespace();
    [CompilerGeneratedAttribute]
public void set_RootNamespace(string value);
    protected virtual string get_ToolName();
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
internal class Microsoft.Build.Tasks.RuntimeSection : object {
    [CompilerGeneratedAttribute]
private List`1<DependentAssembly> <DependentAssemblies>k__BackingField;
    internal List`1<DependentAssembly> DependentAssemblies { get; }
    internal void Read(XmlReader reader);
    [CompilerGeneratedAttribute]
internal List`1<DependentAssembly> get_DependentAssemblies();
}
internal static class Microsoft.Build.Tasks.SdkToolsPathUtility : object {
    private static FileExists s_fileInfoExists;
    internal static FileExists FileInfoExists { get; }
    internal static FileExists get_FileInfoExists();
    internal static string GeneratePathToTool(FileExists fileExists, string currentArchitecture, string sdkToolsPath, string toolName, TaskLoggingHelper log, bool logErrorsAndWarnings);
    internal static string FindSDKToolUsingToolsLocationHelper(string toolName);
    private static bool FileExists(string filePath);
}
internal class Microsoft.Build.Tasks.SetAttributes : MulticastDelegate {
    public SetAttributes(object object, IntPtr method);
    public virtual void Invoke(string path, FileAttributes attributes);
    public virtual IAsyncResult BeginInvoke(string path, FileAttributes attributes, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.SetLastAccessTime : MulticastDelegate {
    public SetLastAccessTime(object object, IntPtr method);
    public virtual void Invoke(string path, DateTime timestamp);
    public virtual IAsyncResult BeginInvoke(string path, DateTime timestamp, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Tasks.SetLastWriteTime : MulticastDelegate {
    public SetLastWriteTime(object object, IntPtr method);
    public virtual void Invoke(string path, DateTime timestamp);
    public virtual IAsyncResult BeginInvoke(string path, DateTime timestamp, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Tasks.SetRidAgnosticValueForProjects : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <UpdatedProjects>k__BackingField;
    public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] UpdatedProjects { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Projects();
    [CompilerGeneratedAttribute]
public void set_Projects(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_UpdatedProjects();
    [CompilerGeneratedAttribute]
public void set_UpdatedProjects(ITaskItem[] value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.SGen : ToolTaskExtension {
    private string _buildAssemblyPath;
    [RequiredAttribute]
public string BuildAssemblyName { get; public set; }
    [RequiredAttribute]
public string BuildAssemblyPath { get; public set; }
    [RequiredAttribute]
public bool ShouldGenerateSerializer { get; public set; }
    [RequiredAttribute]
public bool UseProxyTypes { get; public set; }
    public bool UseKeep { get; public set; }
    public String[] References { get; public set; }
    public string KeyContainer { get; public set; }
    public string KeyFile { get; public set; }
    public bool DelaySign { get; public set; }
    [OutputAttribute]
public ITaskItem[] SerializationAssembly { get; public set; }
    public string SerializationAssemblyName { get; }
    private string SerializationAssemblyPath { get; }
    private string AssemblyFullPath { get; }
    public string SdkToolsPath { get; public set; }
    public string Platform { get; public set; }
    public String[] Types { get; public set; }
    protected string ToolName { get; }
    public sealed virtual void set_BuildAssemblyName(string value);
    public sealed virtual string get_BuildAssemblyName();
    public sealed virtual void set_BuildAssemblyPath(string value);
    public sealed virtual string get_BuildAssemblyPath();
    public sealed virtual void set_ShouldGenerateSerializer(bool value);
    public sealed virtual bool get_ShouldGenerateSerializer();
    public sealed virtual void set_UseProxyTypes(bool value);
    public sealed virtual bool get_UseProxyTypes();
    public sealed virtual void set_UseKeep(bool value);
    public sealed virtual bool get_UseKeep();
    public sealed virtual void set_References(String[] value);
    public sealed virtual String[] get_References();
    public sealed virtual void set_KeyContainer(string value);
    public sealed virtual string get_KeyContainer();
    public sealed virtual void set_KeyFile(string value);
    public sealed virtual string get_KeyFile();
    public sealed virtual void set_DelaySign(bool value);
    public sealed virtual bool get_DelaySign();
    public sealed virtual void set_SerializationAssembly(ITaskItem[] value);
    public sealed virtual ITaskItem[] get_SerializationAssembly();
    public sealed virtual string get_SerializationAssemblyName();
    private string get_SerializationAssemblyPath();
    private string get_AssemblyFullPath();
    public sealed virtual void set_SdkToolsPath(string value);
    public sealed virtual string get_SdkToolsPath();
    public sealed virtual void set_Platform(string value);
    public sealed virtual string get_Platform();
    public sealed virtual void set_Types(String[] value);
    public sealed virtual String[] get_Types();
    protected virtual string get_ToolName();
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
    protected virtual string GenerateCommandLineCommands();
}
[SupportedOSPlatform("windows")]
public class Microsoft.Build.Tasks.SignFile : Task {
    [CompilerGeneratedAttribute]
private string <CertificateThumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <SigningTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TimestampUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisallowMansignTimestampFallback>k__BackingField;
    [RequiredAttribute]
public string CertificateThumbprint { get; public set; }
    [RequiredAttribute]
public ITaskItem SigningTarget { get; public set; }
    public string TargetFrameworkIdentifier { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    public string TimestampUrl { get; public set; }
    public bool DisallowMansignTimestampFallback { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CertificateThumbprint();
    [CompilerGeneratedAttribute]
public void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_SigningTarget();
    [CompilerGeneratedAttribute]
public void set_SigningTarget(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkIdentifier();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TimestampUrl();
    [CompilerGeneratedAttribute]
public void set_TimestampUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_DisallowMansignTimestampFallback();
    [CompilerGeneratedAttribute]
public void set_DisallowMansignTimestampFallback(bool value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.SR : object {
    internal static string ClassDocComment;
    internal static string ClassComments1;
    internal static string ClassComments3;
    internal static string StringPropertyComment;
    internal static string StringPropertyTruncatedComment;
    internal static string NonStringPropertyComment;
    internal static string NonStringPropertyDetailedComment;
    internal static string CulturePropertyComment1;
    internal static string CulturePropertyComment2;
    internal static string ResMgrPropertyComment;
    internal static string MismatchedResourceName;
    internal static string InvalidIdentifier;
    private static SR s_loader;
    private MainAssemblyFallbackResourceManager _resources;
    private static CultureInfo Culture { get; }
    public static ResourceManager Resources { get; }
    private static SR GetLoader();
    private static CultureInfo get_Culture();
    public static ResourceManager get_Resources();
    public static string GetString(string name, Object[] args);
    public static string GetString(string name);
    public static string GetString(string name, Boolean& usedFallback);
    public static object GetObject(string name);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Build.Tasks.SRCategoryAttribute : CategoryAttribute {
    public SRCategoryAttribute(string category);
    protected virtual string GetLocalizedString(string value);
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Build.Tasks.SRDescriptionAttribute : DescriptionAttribute {
    private bool _replaced;
    public string Description { get; }
    public SRDescriptionAttribute(string description);
    public virtual string get_Description();
}
internal class Microsoft.Build.Tasks.STARTUPINFO : ValueType {
    internal int cb;
    internal string lpReserved;
    internal string lpDesktop;
    internal string lpTitle;
    internal int dwX;
    internal int dwY;
    internal int dwXSize;
    internal int dwYSize;
    internal int dwXCountChars;
    internal int dwYCountChars;
    internal int dwFillAttribute;
    internal int dwFlags;
    internal short wShowWindow;
    internal short cbReserved2;
    internal IntPtr lpReserved2;
    internal IntPtr hStdInput;
    internal IntPtr hStdOutput;
    internal IntPtr hStdError;
}
internal abstract class Microsoft.Build.Tasks.StateFileBase : object {
    internal static byte CurrentSerializationVersion;
    private byte _serializedVersion;
    internal bool HasStateToSave { get; }
    internal virtual bool get_HasStateToSave();
    internal virtual void SerializeCache(string stateFile, TaskLoggingHelper log, bool serializeEmptyState);
    public abstract virtual void Translate(ITranslator translator);
    internal static T DeserializeCache(string stateFile, TaskLoggingHelper log);
    internal static void DeleteFile(string stateFile, TaskLoggingHelper log);
}
internal static class Microsoft.Build.Tasks.StronglyTypedResourceBuilder : object {
    private static string ResMgrFieldName;
    private static string ResMgrPropertyName;
    private static string CultureInfoFieldName;
    private static string CultureInfoPropertyName;
    private static Char[] s_charsToReplace;
    private static char ReplacementChar;
    private static string DocCommentSummaryStart;
    private static string DocCommentSummaryEnd;
    private static int DocCommentLengthThreshold;
    private static StronglyTypedResourceBuilder();
    internal static CodeCompileUnit Create(Dictionary`2<string, IResource> resourceList, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    private static CodeCompileUnit InternalCreate(Dictionary`2<string, ResourceData> resourceList, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    internal static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    internal static CodeCompileUnit Create(string resxFile, string baseName, string generatedCodeNamespace, string resourcesNamespace, CodeDomProvider codeProvider, bool internalClass, String[]& unmatchable);
    private static void AddGeneratedCodeAttributeforMember(CodeTypeMember typeMember);
    private static void EmitBasicClassMembers(CodeTypeDeclaration srClass, string nameSpace, string baseName, string resourcesNamespace, bool internalClass, bool useStatic);
    private static string TruncateAndFormatCommentStringForOutput(string commentString);
    private static bool DefineResourceFetchingProperty(string propertyName, string resourceName, ResourceData data, CodeTypeDeclaration srClass, bool internalClass, bool useStatic);
    internal static string VerifyResourceName(string key, CodeDomProvider provider);
    private static string VerifyResourceName(string key, CodeDomProvider provider, bool isNameSpace);
    private static SortedList`2<string, ResourceData> VerifyResourceNames(Dictionary`2<string, ResourceData> resourceList, CodeDomProvider codeProvider, List`1<string> errors, Dictionary`2& reverseFixupTable);
}
internal class Microsoft.Build.Tasks.StrongNameException : Exception {
    internal StrongNameException(Exception innerException);
    protected StrongNameException(SerializationInfo info, StreamingContext context);
}
internal enum Microsoft.Build.Tasks.StrongNameLevel : Enum {
    public int value__;
    public static StrongNameLevel None;
    public static StrongNameLevel DelaySigned;
    public static StrongNameLevel FullySigned;
    public static StrongNameLevel Unknown;
}
internal static class Microsoft.Build.Tasks.StrongNameUtils : object {
    internal static void ReadKeyFile(TaskLoggingHelper log, string keyFile, StrongNameKeyPair& keyPair, Byte[]& publicKey);
    internal static void GetStrongNameKey(TaskLoggingHelper log, string keyFile, string keyContainer, StrongNameKeyPair& keyPair, Byte[]& publicKey);
    internal static StrongNameLevel GetAssemblyStrongNameLevel(string assemblyPath);
    private static UInt32 GetCor20HeaderRva(IntPtr ntHeadersPtr);
}
internal class Microsoft.Build.Tasks.SubsetListFinder : object {
    private static Dictionary`2<string, String[]> s_subsetListPathCache;
    private static object s_subsetListPathCacheLock;
    private static string subsetListFolder;
    private String[] _subsetToSearchFor;
    public static string SubsetListFolder { get; }
    internal SubsetListFinder(String[] subsetToSearchFor);
    private static SubsetListFinder();
    public static string get_SubsetListFolder();
    public String[] GetSubsetListPathsFromDisk(string frameworkDirectory);
}
internal class Microsoft.Build.Tasks.SystemState : StateFileBase {
    private Dictionary`2<string, FileState> upToDateLocalFileStateCache;
    internal Dictionary`2<string, FileState> instanceLocalFileStateCache;
    internal Dictionary`2<string, FileState> instanceLocalOutgoingFileStateCache;
    private Dictionary`2<string, DateTime> instanceLocalLastModifiedCache;
    private Dictionary`2<string, bool> instanceLocalDirectoryExists;
    private Dictionary`2<string, String[]> instanceLocalDirectories;
    private static ConcurrentDictionary`2<string, FileState> s_processWideFileStateCache;
    private RedistList redistList;
    private bool isDirty;
    private GetLastWriteTime getLastWriteTime;
    private GetAssemblyName getAssemblyName;
    private GetAssemblyMetadata getAssemblyMetadata;
    private DirectoryExists directoryExists;
    private GetDirectories getDirectories;
    private GetAssemblyRuntimeVersion getAssemblyRuntimeVersion;
    internal bool HasStateToSave { get; }
    internal bool IsDirty { get; internal set; }
    public SystemState(ITranslator translator);
    private static SystemState();
    internal void SetInstalledAssemblyInformation(AssemblyTableInfo[] installedAssemblyTableInfos);
    public virtual void Translate(ITranslator translator);
    internal virtual bool get_HasStateToSave();
    internal bool get_IsDirty();
    internal void set_IsDirty(bool value);
    internal void SetGetLastWriteTime(GetLastWriteTime getLastWriteTimeValue);
    internal GetAssemblyName CacheDelegate(GetAssemblyName getAssemblyNameValue);
    internal GetAssemblyMetadata CacheDelegate(GetAssemblyMetadata getAssemblyMetadataValue);
    internal FileExists CacheDelegate();
    public DirectoryExists CacheDelegate(DirectoryExists directoryExistsValue);
    internal GetDirectories CacheDelegate(GetDirectories getDirectoriesValue);
    internal GetAssemblyRuntimeVersion CacheDelegate(GetAssemblyRuntimeVersion getAssemblyRuntimeVersion);
    internal FileState GetFileState(string path);
    private FileState ComputeFileStateFromCachesAndDisk(string path);
    private DateTime GetAndCacheLastModified(string path);
    private FileState InitializeFileState(string path, DateTime lastModified);
    private AssemblyNameExtension GetAssemblyName(string path);
    private string GetRuntimeVersion(string path);
    private void GetAssemblyMetadata(string path, ConcurrentDictionary`2<string, AssemblyMetadata> assemblyMetadataCache, AssemblyNameExtension[]& dependencies, String[]& scatterFiles, FrameworkName& frameworkName);
    internal static SystemState DeserializePrecomputedCaches(ITaskItem[] stateFiles, TaskLoggingHelper log, FileExists fileExists);
    internal void SerializePrecomputedCache(string stateFile, TaskLoggingHelper log);
    private String[] GetDirectories(string path, string pattern);
    private bool FileExists(string path);
    private bool FileTimestampIndicatesFileExists(DateTime lastModified);
    private bool DirectoryExists(string path);
}
public abstract class Microsoft.Build.Tasks.TaskExtension : Task {
    private TaskLoggingHelperExtension _logExtension;
    public TaskLoggingHelper Log { get; }
    public TaskLoggingHelper get_Log();
}
internal class Microsoft.Build.Tasks.TaskItemSpecFilenameComparer : object {
    internal static IComparer`1<ITaskItem> GenericComparer;
    private static TaskItemSpecFilenameComparer();
    public int Compare(object o1, object o2);
    public sealed virtual int Compare(ITaskItem x, ITaskItem y);
}
public class Microsoft.Build.Tasks.TaskLoggingHelperExtension : TaskLoggingHelper {
    private ResourceManager _taskSharedResources;
    public ResourceManager TaskSharedResources { get; public set; }
    public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix);
    public ResourceManager get_TaskSharedResources();
    public void set_TaskSharedResources(ResourceManager value);
    public virtual string FormatResourceString(string resourceName, Object[] args);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Tasks.TaskTranslatorHelpers : object {
    [ExtensionAttribute]
public static void Translate(ITranslator translator, FrameworkName& frameworkName);
}
public class Microsoft.Build.Tasks.Telemetry : TaskExtension {
    [CompilerGeneratedAttribute]
private string <EventData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    public string EventData { get; public set; }
    [RequiredAttribute]
public string EventName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_EventData();
    [CompilerGeneratedAttribute]
public void set_EventData(string value);
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public void set_EventName(string value);
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.TlbReference : AxTlbBaseReference {
    [CompilerGeneratedAttribute]
private bool <HasTemporaryWrapper>k__BackingField;
    private bool _noClassMembers;
    private string _targetProcessorArchitecture;
    private IEnumerable`1<string> _referenceFiles;
    private bool HasTemporaryWrapper { get; }
    protected string OutputDirectory { get; }
    internal TlbReference(TaskLoggingHelper taskLoggingHelper, bool silent, IComReferenceResolver resolverCallback, IEnumerable`1<string> referenceFiles, ComReferenceInfo referenceInfo, string itemName, string outputDirectory, bool hasTemporaryWrapper, bool delaySign, string keyFile, string keyContainer, bool noClassMembers, string targetProcessorArchitecture, bool includeTypeLibVersionInName, bool executeAsTool, string sdkToolsPath, IBuildEngine buildEngine, String[] environmentVariables);
    [CompilerGeneratedAttribute]
private bool get_HasTemporaryWrapper();
    protected virtual string get_OutputDirectory();
    protected virtual string GetWrapperFileNameInternal(string typeLibName);
    internal static string GetWrapperFileName(string typeLibName);
    internal static string GetWrapperFileName(string typeLibName, bool includeTypeLibVersionInName, short majorVerNum, short minorVerNum);
    internal virtual bool FindExistingWrapper(ComReferenceWrapperInfo& wrapperInfo, DateTime componentTimestamp);
    internal bool GenerateWrapper(ComReferenceWrapperInfo& wrapperInfo);
    private void WriteWrapperToDisk(AssemblyBuilder assemblyBuilder, string wrapperPath);
    private sealed virtual override Assembly System.Runtime.InteropServices.ITypeLibImporterNotifySink.ResolveRef(object objTypeLib);
    private sealed virtual override void System.Runtime.InteropServices.ITypeLibImporterNotifySink.ReportEvent(ImporterEventKind eventKind, int eventCode, string eventMsg);
}
public abstract class Microsoft.Build.Tasks.ToolTaskExtension : ToolTask {
    private TaskLoggingHelperExtension _logExtension;
    [CompilerGeneratedAttribute]
private Hashtable <Bag>k__BackingField;
    public TaskLoggingHelper Log { get; }
    protected bool HasLoggedErrors { get; }
    protected internal Hashtable Bag { get; }
    protected bool UseNewLineSeparatorInResponseFile { get; }
    public TaskLoggingHelper get_Log();
    protected virtual bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
protected internal Hashtable get_Bag();
    protected virtual bool get_UseNewLineSeparatorInResponseFile();
    protected internal bool GetBoolParameterWithDefault(string parameterName, bool defaultValue);
    protected internal int GetIntParameterWithDefault(string parameterName, int defaultValue);
    protected virtual string GenerateResponseFileCommands();
    protected virtual string GenerateCommandLineCommands();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected internal virtual void AddCommandLineCommands(CommandLineBuilderExtension commandLine);
}
public class Microsoft.Build.Tasks.Touch : TaskExtension {
    private MessageImportance messageImportance;
    [CompilerGeneratedAttribute]
private bool <ForceTouch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysCreate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <TouchedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Importance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    public bool ForceTouch { get; public set; }
    public bool AlwaysCreate { get; public set; }
    public string Time { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public ITaskItem[] TouchedFiles { get; public set; }
    public string Importance { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceTouch();
    [CompilerGeneratedAttribute]
public void set_ForceTouch(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysCreate();
    [CompilerGeneratedAttribute]
public void set_AlwaysCreate(bool value);
    [CompilerGeneratedAttribute]
public string get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_TouchedFiles();
    [CompilerGeneratedAttribute]
public void set_TouchedFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Importance();
    [CompilerGeneratedAttribute]
public void set_Importance(string value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    internal bool ExecuteImpl(FileExists fileExists, FileCreate fileCreate, GetAttributes fileGetAttributes, SetAttributes fileSetAttributes, SetLastAccessTime fileSetLastAccessTime, SetLastWriteTime fileSetLastWriteTime);
    public virtual bool Execute();
    private bool CreateFile(string file, FileCreate fileCreate);
    private bool TouchFile(string file, DateTime dt, FileExists fileExists, FileCreate fileCreate, GetAttributes fileGetAttributes, SetAttributes fileSetAttributes, SetLastAccessTime fileSetLastAccessTime, SetLastWriteTime fileSetLastWriteTime);
    private DateTime GetTouchDateTime();
}
internal enum Microsoft.Build.Tasks.UnificationReason : Enum {
    public int value__;
    public static UnificationReason DidntUnify;
    public static UnificationReason FrameworkRetarget;
    public static UnificationReason BecauseOfBindingRedirect;
}
internal class Microsoft.Build.Tasks.UnificationVersion : ValueType {
    internal string referenceFullPath;
    internal Version version;
    internal UnificationReason reason;
}
internal class Microsoft.Build.Tasks.UnifiedAssemblyName : object {
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <PreUnified>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameExtension <PostUnified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUnified>k__BackingField;
    [CompilerGeneratedAttribute]
private UnificationReason <UnificationReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrerequisite>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsRedistRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistName>k__BackingField;
    public AssemblyNameExtension PreUnified { get; }
    public AssemblyNameExtension PostUnified { get; }
    public bool IsUnified { get; }
    public UnificationReason UnificationReason { get; }
    public bool IsPrerequisite { get; }
    public Nullable`1<bool> IsRedistRoot { get; }
    public string RedistName { get; }
    public UnifiedAssemblyName(AssemblyNameExtension preUnified, AssemblyNameExtension postUnified, bool isUnified, UnificationReason unificationReason, bool isPrerequisite, Nullable`1<bool> isRedistRoot, string redistName);
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_PreUnified();
    [CompilerGeneratedAttribute]
public AssemblyNameExtension get_PostUnified();
    [CompilerGeneratedAttribute]
public bool get_IsUnified();
    [CompilerGeneratedAttribute]
public UnificationReason get_UnificationReason();
    [CompilerGeneratedAttribute]
public bool get_IsPrerequisite();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsRedistRoot();
    [CompilerGeneratedAttribute]
public string get_RedistName();
}
public class Microsoft.Build.Tasks.UnregisterAssembly : AppDomainIsolatedTaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem[] <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <TypeLibFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AssemblyListFile>k__BackingField;
    private static Mutex s_unregisteringLock;
    private static string unregisteringLockName;
    public ITaskItem[] Assemblies { get; public set; }
    public ITaskItem[] TypeLibFiles { get; public set; }
    public ITaskItem AssemblyListFile { get; public set; }
    private static UnregisterAssembly();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Assemblies();
    [CompilerGeneratedAttribute]
public void set_Assemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_TypeLibFiles();
    [CompilerGeneratedAttribute]
public void set_TypeLibFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AssemblyListFile();
    [CompilerGeneratedAttribute]
public void set_AssemblyListFile(ITaskItem value);
    public virtual bool Execute();
    private bool Unregister(string assemblyPath, string typeLibPath);
}
public class Microsoft.Build.Tasks.Unzip : TaskExtension {
    private static int _DefaultCopyBufferSize;
    private CancellationTokenSource _cancellationToken;
    private String[] _includePatterns;
    private String[] _excludePatterns;
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OverwriteReadOnlyFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUnchangedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem DestinationFolder { get; public set; }
    public bool OverwriteReadOnlyFiles { get; public set; }
    public bool SkipUnchangedFiles { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFolder();
    [CompilerGeneratedAttribute]
public void set_DestinationFolder(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_OverwriteReadOnlyFiles();
    [CompilerGeneratedAttribute]
public void set_OverwriteReadOnlyFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnchangedFiles();
    [CompilerGeneratedAttribute]
public void set_SkipUnchangedFiles(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SourceFiles();
    [CompilerGeneratedAttribute]
public void set_SourceFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
public void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public sealed virtual void Cancel();
    public virtual bool Execute();
    private void Extract(ZipArchive sourceArchive, DirectoryInfo destinationDirectory);
    private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry);
    private bool ShouldSkipEntry(ZipArchiveEntry zipArchiveEntry, FileInfo fileInfo);
    private void ParseIncludeExclude();
    private void ParsePattern(string pattern, String[]& patterns);
    [CompilerGeneratedAttribute]
private bool <Execute>b__33_0(ITaskItem i);
    [CompilerGeneratedAttribute]
private bool <Extract>b__34_0(ZipArchiveEntry i);
}
public class Microsoft.Build.Tasks.UpdateManifest : Task {
    [CompilerGeneratedAttribute]
private string <ApplicationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ApplicationManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <InputManifest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputManifest>k__BackingField;
    [RequiredAttribute]
public string ApplicationPath { get; public set; }
    public string TargetFrameworkVersion { get; public set; }
    [RequiredAttribute]
public ITaskItem ApplicationManifest { get; public set; }
    [RequiredAttribute]
public ITaskItem InputManifest { get; public set; }
    [OutputAttribute]
public ITaskItem OutputManifest { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationPath();
    [CompilerGeneratedAttribute]
public void set_ApplicationPath(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkVersion();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkVersion(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ApplicationManifest();
    [CompilerGeneratedAttribute]
public void set_ApplicationManifest(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_InputManifest();
    [CompilerGeneratedAttribute]
public void set_InputManifest(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputManifest();
    [CompilerGeneratedAttribute]
public void set_OutputManifest(ITaskItem value);
    public virtual bool Execute();
}
public class Microsoft.Build.Tasks.VerifyFileHash : TaskExtension {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [RequiredAttribute]
public string File { get; public set; }
    [RequiredAttribute]
public string Hash { get; public set; }
    public string HashEncoding { get; public set; }
    public string Algorithm { get; public set; }
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(string value);
    [CompilerGeneratedAttribute]
public string get_HashEncoding();
    [CompilerGeneratedAttribute]
public void set_HashEncoding(string value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    public virtual bool Execute();
}
internal static class Microsoft.Build.Tasks.VisualBasicParserUtilities : object {
    internal static ExtractedClassName GetFirstClassNameFullyQualified(Stream binaryStream);
    private static ExtractedClassName Extract(VisualBasicTokenizer tokens);
}
public class Microsoft.Build.Tasks.Warning : TaskExtension {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLink>k__BackingField;
    public string Text { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string HelpKeyword { get; public set; }
    public string HelpLink { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_HelpLink();
    [CompilerGeneratedAttribute]
public void set_HelpLink(string value);
    public virtual bool Execute();
}
internal enum Microsoft.Build.Tasks.WarnOrErrorOnTargetArchitectureMismatchBehavior : Enum {
    public int value__;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior Error;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior Warning;
    public static WarnOrErrorOnTargetArchitectureMismatchBehavior None;
}
public class Microsoft.Build.Tasks.WinMDExp : ToolTaskExtension {
    [RequiredAttribute]
public ITaskItem[] References { get; public set; }
    public string DisabledWarnings { get; public set; }
    public string InputDocumentationFile { get; public set; }
    public string OutputDocumentationFile { get; public set; }
    public string InputPDBFile { get; public set; }
    public string OutputPDBFile { get; public set; }
    [RequiredAttribute]
public string WinMDModule { get; public set; }
    [OutputAttribute]
public string OutputWindowsMetadataFile { get; public set; }
    public string SdkToolsPath { get; public set; }
    public bool UTF8Output { get; public set; }
    public bool TreatWarningsAsErrors { get; public set; }
    public string AssemblyUnificationPolicy { get; public set; }
    protected string ToolName { get; }
    protected Encoding StandardOutputEncoding { get; }
    protected Encoding StandardErrorEncoding { get; }
    protected bool UseNewLineSeparatorInResponseFile { get; }
    public ITaskItem[] get_References();
    public void set_References(ITaskItem[] value);
    public string get_DisabledWarnings();
    public void set_DisabledWarnings(string value);
    public string get_InputDocumentationFile();
    public void set_InputDocumentationFile(string value);
    public string get_OutputDocumentationFile();
    public void set_OutputDocumentationFile(string value);
    public string get_InputPDBFile();
    public void set_InputPDBFile(string value);
    public string get_OutputPDBFile();
    public void set_OutputPDBFile(string value);
    public string get_WinMDModule();
    public void set_WinMDModule(string value);
    public string get_OutputWindowsMetadataFile();
    public void set_OutputWindowsMetadataFile(string value);
    public string get_SdkToolsPath();
    public void set_SdkToolsPath(string value);
    public bool get_UTF8Output();
    public void set_UTF8Output(bool value);
    public bool get_TreatWarningsAsErrors();
    public void set_TreatWarningsAsErrors(bool value);
    public string get_AssemblyUnificationPolicy();
    public void set_AssemblyUnificationPolicy(string value);
    protected virtual string get_ToolName();
    protected virtual Encoding get_StandardOutputEncoding();
    protected virtual Encoding get_StandardErrorEncoding();
    protected virtual bool get_UseNewLineSeparatorInResponseFile();
    protected internal virtual void AddResponseFileCommands(CommandLineBuilderExtension commandLine);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    protected virtual bool SkipTaskExecution();
}
public class Microsoft.Build.Tasks.WriteCodeFragment : TaskExtension {
    private static string TypeNameSuffix;
    private static string IsLiteralSuffix;
    private static IEnumerable`1<string> NamespaceImports;
    private static IReadOnlyDictionary`2<string, ParameterType> EmptyParameterTypes;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <AssemblyAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputFile>k__BackingField;
    [RequiredAttribute]
public string Language { get; public set; }
    public ITaskItem[] AssemblyAttributes { get; public set; }
    public ITaskItem OutputDirectory { get; public set; }
    [OutputAttribute]
public ITaskItem OutputFile { get; public set; }
    private static WriteCodeFragment();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AssemblyAttributes();
    [CompilerGeneratedAttribute]
public void set_AssemblyAttributes(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    public virtual bool Execute();
    private string GenerateCode(String& extension);
    private IReadOnlyDictionary`2<string, ParameterType> ExtractParameterTypes(IDictionary customMetadata);
    private bool AddArguments(CodeAttributeDeclaration attribute, Lazy`1<Type> attributeType, IReadOnlyList`1<AttributeParameter> parameters, bool isPositional);
    private Type[] FindPositionalParameterTypes(Type attributeType, IReadOnlyList`1<AttributeParameter> positionalParameters);
    private bool TryConvertParameterValue(string typeName, string rawValue, CodeExpression& value);
    private CodeExpression ConvertParameterValueToInferredType(Type inferredType, string rawValue, string parameterName);
    private CodeExpression ConvertToCodeExpression(string value, Type targetType);
}
public class Microsoft.Build.Tasks.WriteLinesToFile : TaskExtension {
    private static Encoding s_defaultEncoding;
    [CompilerGeneratedAttribute]
private ITaskItem <File>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteOnlyWhenDifferent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    public ITaskItem[] Lines { get; public set; }
    public bool Overwrite { get; public set; }
    public string Encoding { get; public set; }
    public bool WriteOnlyWhenDifferent { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    public bool CanBeIncremental { get; }
    private static WriteLinesToFile();
    [CompilerGeneratedAttribute]
public ITaskItem get_File();
    [CompilerGeneratedAttribute]
public void set_File(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public string get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(string value);
    [CompilerGeneratedAttribute]
public bool get_WriteOnlyWhenDifferent();
    [CompilerGeneratedAttribute]
public void set_WriteOnlyWhenDifferent(bool value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public bool get_CanBeIncremental();
    public virtual bool Execute();
}
internal class Microsoft.Build.Tasks.Xaml.Argument : object {
    [CompilerGeneratedAttribute]
private string <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public string Parameter { get; public set; }
    public string Separator { get; public set; }
    public bool Required { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(string value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
}
public class Microsoft.Build.Tasks.Xaml.CommandLineArgumentRelation : PropertyRelation {
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    public string Separator { get; public set; }
    public CommandLineArgumentRelation(string argument, string value, bool required, string separator);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
}
public class Microsoft.Build.Tasks.Xaml.CommandLineGenerator : object {
    private IEnumerable`1<string> _switchOrderList;
    private Dictionary`2<string, CommandLineToolSwitch> _activeCommandLineToolSwitches;
    [CompilerGeneratedAttribute]
private string <AdditionalOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLineTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AlwaysAppend>k__BackingField;
    public string AdditionalOptions { get; public set; }
    public string CommandLineTemplate { get; public set; }
    public string AlwaysAppend { get; public set; }
    public CommandLineGenerator(Rule rule, Dictionary`2<string, object> parameterValues);
    internal CommandLineGenerator(Dictionary`2<string, CommandLineToolSwitch> activeCommandLineToolSwitches, IEnumerable`1<string> switchOrderList);
    [CompilerGeneratedAttribute]
public string get_AdditionalOptions();
    [CompilerGeneratedAttribute]
public void set_AdditionalOptions(string value);
    [CompilerGeneratedAttribute]
public string get_CommandLineTemplate();
    [CompilerGeneratedAttribute]
public void set_CommandLineTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_AlwaysAppend();
    [CompilerGeneratedAttribute]
public void set_AlwaysAppend(string value);
    public string GenerateCommandLine();
    internal void BuildAdditionalArgs(CommandLineBuilder cmdLine);
    internal void GenerateCommandsAccordingToType(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, bool recursive);
    internal bool VerifyRequiredArgumentsArePresent(CommandLineToolSwitch property, bool throwOnError);
    internal bool VerifyDependenciesArePresent(CommandLineToolSwitch property);
    internal bool IsPropertySet(string propertyName);
    internal bool HasSwitch(string propertyName);
    internal bool PropertyExists(string propertyName);
    private static void EmitTaskItemArraySwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch);
    private static void EmitStringArraySwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch);
    private static bool PerformSwitchValueSubstition(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch, string switchValue);
    private static void EmitIntegerSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch);
    private void EmitStringSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch);
    private string GatherArguments(string parentSwitch, ICollection`1<Tuple`2<string, bool>> arguments, string separator);
    private static void EmitBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch);
    private static void EmitReversibleBooleanSwitch(CommandLineBuilder clb, CommandLineToolSwitch commandLineToolSwitch);
    private void GenerateStandardCommandLine(CommandLineBuilder builder, bool allOptionsMode);
    private void GenerateTemplatedCommandLine(CommandLineBuilder builder);
}
public class Microsoft.Build.Tasks.Xaml.CommandLineToolSwitch : object {
    private static string TypeBoolean;
    private static string TypeInteger;
    private static string TypeITaskItemArray;
    private static string TypeStringArray;
    private bool _booleanValue;
    private int _number;
    private String[] _stringList;
    private ITaskItem[] _taskItemArray;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInCommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SwitchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReverseSwitchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<Tuple`2<string, bool>> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandLineToolSwitchType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Reversible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FalseSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TrueSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FallbackArgumentParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ArgumentRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<string> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<KeyValuePair`2<string, string>> <Overrides>k__BackingField;
    public string Name { get; public set; }
    public bool IncludeInCommandLine { get; public set; }
    public string Value { get; public set; }
    public bool IsValid { get; public set; }
    public string SwitchValue { get; public set; }
    public string ReverseSwitchValue { get; public set; }
    public ICollection`1<Tuple`2<string, bool>> Arguments { get; public set; }
    public string DisplayName { get; public set; }
    public string Description { get; public set; }
    public CommandLineToolSwitchType Type { get; public set; }
    public bool Reversible { get; public set; }
    public bool AllowMultipleValues { get; public set; }
    public string FalseSuffix { get; public set; }
    public string TrueSuffix { get; public set; }
    public string Separator { get; public set; }
    public string FallbackArgumentParameter { get; public set; }
    public bool ArgumentRequired { get; public set; }
    public bool Required { get; public set; }
    public LinkedList`1<string> Parents { get; }
    public LinkedList`1<KeyValuePair`2<string, string>> Overrides { get; }
    public bool BooleanValue { get; public set; }
    public int Number { get; public set; }
    public String[] StringList { get; public set; }
    public ITaskItem[] TaskItemArray { get; public set; }
    public CommandLineToolSwitch(CommandLineToolSwitchType toolType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeInCommandLine();
    [CompilerGeneratedAttribute]
public void set_IncludeInCommandLine(bool value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_IsValid();
    [CompilerGeneratedAttribute]
public void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
public string get_SwitchValue();
    [CompilerGeneratedAttribute]
public void set_SwitchValue(string value);
    [CompilerGeneratedAttribute]
public string get_ReverseSwitchValue();
    [CompilerGeneratedAttribute]
public void set_ReverseSwitchValue(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<Tuple`2<string, bool>> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(ICollection`1<Tuple`2<string, bool>> value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public CommandLineToolSwitchType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(CommandLineToolSwitchType value);
    [CompilerGeneratedAttribute]
public bool get_Reversible();
    [CompilerGeneratedAttribute]
public void set_Reversible(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleValues();
    [CompilerGeneratedAttribute]
public void set_AllowMultipleValues(bool value);
    [CompilerGeneratedAttribute]
public string get_FalseSuffix();
    [CompilerGeneratedAttribute]
public void set_FalseSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_TrueSuffix();
    [CompilerGeneratedAttribute]
public void set_TrueSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public string get_FallbackArgumentParameter();
    [CompilerGeneratedAttribute]
public void set_FallbackArgumentParameter(string value);
    [CompilerGeneratedAttribute]
public bool get_ArgumentRequired();
    [CompilerGeneratedAttribute]
public void set_ArgumentRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
    [CompilerGeneratedAttribute]
public LinkedList`1<string> get_Parents();
    [CompilerGeneratedAttribute]
public LinkedList`1<KeyValuePair`2<string, string>> get_Overrides();
    public bool get_BooleanValue();
    public void set_BooleanValue(bool value);
    public int get_Number();
    public void set_Number(int value);
    public String[] get_StringList();
    public void set_StringList(String[] value);
    public ITaskItem[] get_TaskItemArray();
    public void set_TaskItemArray(ITaskItem[] value);
}
public enum Microsoft.Build.Tasks.Xaml.CommandLineToolSwitchType : Enum {
    public int value__;
    public static CommandLineToolSwitchType Boolean;
    public static CommandLineToolSwitchType Integer;
    public static CommandLineToolSwitchType String;
    public static CommandLineToolSwitchType StringArray;
    public static CommandLineToolSwitchType ITaskItemArray;
}
internal class Microsoft.Build.Tasks.Xaml.Property : object {
    [CompilerGeneratedAttribute]
private PropertyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInCommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reversible>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SwitchName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReverseSwitchName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FalseSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TrueSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Separator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fallback>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Required>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<string> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<Property> <DependentArgumentProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Value> <Values>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Argument> <Arguments>k__BackingField;
    public PropertyType Type { get; public set; }
    public bool IncludeInCommandLine { get; public set; }
    public string Reversible { get; public set; }
    public string SwitchName { get; public set; }
    public string ReverseSwitchName { get; public set; }
    public string FalseSuffix { get; public set; }
    public string TrueSuffix { get; public set; }
    public string Max { get; public set; }
    public string Min { get; public set; }
    public string Separator { get; public set; }
    public string DefaultValue { get; public set; }
    public string Argument { get; public set; }
    public string Fallback { get; public set; }
    public string Required { get; public set; }
    public bool Output { get; public set; }
    public LinkedList`1<string> Parents { get; }
    public string Name { get; public set; }
    public LinkedList`1<Property> DependentArgumentProperties { get; }
    public List`1<Value> Values { get; }
    public string Prefix { get; public set; }
    public string Category { get; public set; }
    public string DisplayName { get; public set; }
    public string Description { get; public set; }
    public List`1<Argument> Arguments { get; public set; }
    [CompilerGeneratedAttribute]
public PropertyType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(PropertyType value);
    [CompilerGeneratedAttribute]
public bool get_IncludeInCommandLine();
    [CompilerGeneratedAttribute]
public void set_IncludeInCommandLine(bool value);
    [CompilerGeneratedAttribute]
public string get_Reversible();
    [CompilerGeneratedAttribute]
public void set_Reversible(string value);
    [CompilerGeneratedAttribute]
public string get_SwitchName();
    [CompilerGeneratedAttribute]
public void set_SwitchName(string value);
    [CompilerGeneratedAttribute]
public string get_ReverseSwitchName();
    [CompilerGeneratedAttribute]
public void set_ReverseSwitchName(string value);
    [CompilerGeneratedAttribute]
public string get_FalseSuffix();
    [CompilerGeneratedAttribute]
public void set_FalseSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_TrueSuffix();
    [CompilerGeneratedAttribute]
public void set_TrueSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(string value);
    [CompilerGeneratedAttribute]
public string get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(string value);
    [CompilerGeneratedAttribute]
public string get_Separator();
    [CompilerGeneratedAttribute]
public void set_Separator(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    [CompilerGeneratedAttribute]
public void set_DefaultValue(string value);
    [CompilerGeneratedAttribute]
public string get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(string value);
    [CompilerGeneratedAttribute]
public string get_Fallback();
    [CompilerGeneratedAttribute]
public void set_Fallback(string value);
    [CompilerGeneratedAttribute]
public string get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(string value);
    [CompilerGeneratedAttribute]
public bool get_Output();
    [CompilerGeneratedAttribute]
public void set_Output(bool value);
    [CompilerGeneratedAttribute]
public LinkedList`1<string> get_Parents();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public LinkedList`1<Property> get_DependentArgumentProperties();
    [CompilerGeneratedAttribute]
public List`1<Value> get_Values();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public List`1<Argument> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<Argument> value);
    public Property Clone();
}
public class Microsoft.Build.Tasks.Xaml.PropertyRelation : object {
    [CompilerGeneratedAttribute]
private string <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public string Argument { get; public set; }
    public string Value { get; public set; }
    public bool Required { get; public set; }
    public PropertyRelation(string argument, string value, bool required);
    [CompilerGeneratedAttribute]
public string get_Argument();
    [CompilerGeneratedAttribute]
public void set_Argument(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
public void set_Required(bool value);
}
internal enum Microsoft.Build.Tasks.Xaml.PropertyType : Enum {
    public int value__;
    public static PropertyType None;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Integer;
    public static PropertyType StringArray;
    public static PropertyType ItemArray;
}
internal class Microsoft.Build.Tasks.Xaml.RelationsParser : object {
    private bool _isImport;
    private static string xmlNamespace;
    private static string toolNameString;
    private static string prefixString;
    private static string baseClassAttribute;
    private static string namespaceAttribute;
    private static string resourceNamespaceAttribute;
    private static string importType;
    private static string tasksAttribute;
    private static string task;
    private static string nameProperty;
    private static string status;
    private static string switchName;
    private static string argumentValueName;
    private static string relations;
    private static string switchGroupType;
    private static string switchType;
    private static string includedPlatformType;
    private static string excludedPlatformType;
    private static string overridesType;
    private static string requiresType;
    private static string toolAttribute;
    private static string switchAttribute;
    [CompilerGeneratedAttribute]
private string <GeneratedTaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<Property> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<Property> <DefaultSet>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <FallbackSet>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<string> <ErrorLog>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, SwitchRelations> <SwitchRelationsList>k__BackingField;
    public string GeneratedTaskName { get; public set; }
    public string BaseClass { get; private set; }
    public string Namespace { get; private set; }
    public string ResourceNamespace { get; private set; }
    public string ToolName { get; private set; }
    public string DefaultPrefix { get; private set; }
    public LinkedList`1<Property> Properties { get; }
    public LinkedList`1<Property> DefaultSet { get; }
    public Dictionary`2<string, string> FallbackSet { get; }
    public int ErrorCount { get; private set; }
    public LinkedList`1<string> ErrorLog { get; }
    public Dictionary`2<string, SwitchRelations> SwitchRelationsList { get; }
    [CompilerGeneratedAttribute]
public string get_GeneratedTaskName();
    [CompilerGeneratedAttribute]
public void set_GeneratedTaskName(string value);
    [CompilerGeneratedAttribute]
public string get_BaseClass();
    [CompilerGeneratedAttribute]
private void set_BaseClass(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
private void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceNamespace();
    [CompilerGeneratedAttribute]
private void set_ResourceNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_ToolName();
    [CompilerGeneratedAttribute]
private void set_ToolName(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultPrefix();
    [CompilerGeneratedAttribute]
private void set_DefaultPrefix(string value);
    [CompilerGeneratedAttribute]
public LinkedList`1<Property> get_Properties();
    [CompilerGeneratedAttribute]
public LinkedList`1<Property> get_DefaultSet();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_FallbackSet();
    [CompilerGeneratedAttribute]
public int get_ErrorCount();
    [CompilerGeneratedAttribute]
private void set_ErrorCount(int value);
    [CompilerGeneratedAttribute]
public LinkedList`1<string> get_ErrorLog();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, SwitchRelations> get_SwitchRelationsList();
    private XmlDocument LoadFile(string filePath);
    internal XmlDocument LoadXml(string xml);
    public bool ParseXmlDocument(string fileName);
    internal bool ParseXmlDocument(XmlDocument xmlDocument);
    private static bool VerifyAttributeExists(XmlNode node, string attributeName);
    private static bool VerifyNodeName(XmlNode node);
    private bool ParseSwitchGroupOrSwitch(XmlNode node, Dictionary`2<string, SwitchRelations> switchRelationsList, SwitchRelations switchRelations);
    private bool ParseImportOption(XmlNode node);
    private static bool ParseSwitch(XmlNode node, Dictionary`2<string, SwitchRelations> switchRelationsList, SwitchRelations switchRelations);
    private static SwitchRelations ObtainAttributes(XmlNode node, SwitchRelations switchGroup);
    private void LogError(string messageResourceName, Object[] messageArgs);
    private static bool IsXmlRootElement(XmlNode node);
}
internal class Microsoft.Build.Tasks.Xaml.SwitchRelations : object {
    [CompilerGeneratedAttribute]
private string <SwitchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Conflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IncludedPlatforms>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExcludedPlatforms>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Overrides>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Requires>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <ExternalOverrides>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <ExternalConflicts>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, List`1<string>> <ExternalRequires>k__BackingField;
    public string SwitchValue { get; public set; }
    public string Status { get; public set; }
    public List`1<string> Conflicts { get; public set; }
    public List`1<string> IncludedPlatforms { get; public set; }
    public List`1<string> ExcludedPlatforms { get; public set; }
    public List`1<string> Overrides { get; public set; }
    public List`1<string> Requires { get; public set; }
    public Dictionary`2<string, List`1<string>> ExternalOverrides { get; public set; }
    public Dictionary`2<string, List`1<string>> ExternalConflicts { get; public set; }
    public Dictionary`2<string, List`1<string>> ExternalRequires { get; public set; }
    public SwitchRelations Clone();
    [CompilerGeneratedAttribute]
public string get_SwitchValue();
    [CompilerGeneratedAttribute]
public void set_SwitchValue(string value);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Conflicts();
    [CompilerGeneratedAttribute]
public void set_Conflicts(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_IncludedPlatforms();
    [CompilerGeneratedAttribute]
public void set_IncludedPlatforms(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ExcludedPlatforms();
    [CompilerGeneratedAttribute]
public void set_ExcludedPlatforms(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Overrides();
    [CompilerGeneratedAttribute]
public void set_Overrides(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Requires();
    [CompilerGeneratedAttribute]
public void set_Requires(List`1<string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_ExternalOverrides();
    [CompilerGeneratedAttribute]
public void set_ExternalOverrides(Dictionary`2<string, List`1<string>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_ExternalConflicts();
    [CompilerGeneratedAttribute]
public void set_ExternalConflicts(Dictionary`2<string, List`1<string>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, List`1<string>> get_ExternalRequires();
    [CompilerGeneratedAttribute]
public void set_ExternalRequires(Dictionary`2<string, List`1<string>> value);
}
internal class Microsoft.Build.Tasks.Xaml.TaskGenerator : object {
    private static string ToolNamePropertyName;
    private static string IsOn;
    private static string IsOff;
    private static string ValueAttribute;
    private static string TypeBoolean;
    private static string TypeInteger;
    private static string TypeString;
    private static string TypeStringArray;
    private static string TypeITaskItemArray;
    private static string TypeKeyValuePairStrings;
    private static string ImportType;
    private static string TypeToolSwitch;
    private static string TypeToolSwitchType;
    private static string SwitchToAdd;
    private static string DictionaryOfSwitches;
    private static string SwitchMap;
    private static string MultiValues;
    private static string AddLastMethod;
    private static string ValidateIntegerMethod;
    private static string ReadSwitchMapMethod;
    private static string IsPropertySetMethod;
    private static string IsSwitchValueSetMethod;
    private static string AddDefaultsToActiveSwitchList;
    private static string AddFallbacksToActiveSwitchList;
    private static string ValidateRelationsMethod;
    private static string ReplaceToolSwitchMethod;
    private static string Overrides;
    private static string NameProperty;
    private static string BooleanValueProperty;
    private static string FileNameProperty;
    private static string TaskItemArrayProperty;
    private static string StringListProperty;
    private static string NumberProperty;
    private static string FalseSuffixProperty;
    private static string TrueSuffixProperty;
    private static string SeparatorProperty;
    private static string FallbackProperty;
    private static string OutputProperty;
    private static string ArgumentProperty;
    private static string PropertyRequiredProperty;
    private static string ParentProperty;
    private static string ReversibleProperty;
    private static string SwitchValueProperty;
    private static string ValueProperty;
    private static string RequiredProperty;
    private static string DisplayNameProperty;
    private static string DescriptionProperty;
    private static string ReverseSwitchValueProperty;
    private static string IsValidProperty;
    private static String[] PropertiesTypesToIgnore;
    private TaskParser _taskParser;
    private RelationsParser _relationsParser;
    [CompilerGeneratedAttribute]
private bool <GenerateComments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<string> <ErrorLog>k__BackingField;
    public bool GenerateComments { get; public set; }
    private string Platform { get; }
    internal int ErrorCount { get; private set; }
    internal LinkedList`1<string> ErrorLog { get; }
    internal TaskGenerator(TaskParser parser);
    private static TaskGenerator();
    [CompilerGeneratedAttribute]
public bool get_GenerateComments();
    [CompilerGeneratedAttribute]
public void set_GenerateComments(bool value);
    [CompilerGeneratedAttribute]
private string get_Platform();
    internal void RemovePropertiesWithIgnoredTypes(LinkedList`1<Property> propertyList);
    internal CodeCompileUnit GenerateCode();
    private void GenerateDefaultSetProperties(CodeTypeDeclaration taskClass);
    private void GenerateFallbacks(CodeTypeDeclaration taskClass);
    private void GenerateProperties(CodeTypeDeclaration taskClass, LinkedList`1<Property> propertyList);
    private static void GenerateAssignPropertyToString(CodeMemberProperty propertyName, string property, string value);
    private static void GenerateAssignPropertyToValue(CodeMemberProperty propertyName, string property, CodeExpression value);
    private static void GenerateAssignToolSwitch(CodeMemberProperty propertyName, string property, string prefix, string toolSwitchName);
    private void GenerateCommon(Property property, CodeMemberProperty propertyName, string type, Type returnType, string valueName);
    private static void GenerateCommonSetStatements(CodeMemberProperty propertyName, string referencedProperty);
    private void GenerateITaskItemArray(Property property, CodeMemberProperty propertyName);
    private void GenerateIntegers(Property property, CodeMemberProperty propertyName);
    private void GenerateBooleans(Property property, CodeMemberProperty propertyName);
    private void GenerateStrings(Property property, CodeMemberProperty propertyName);
    private bool ContainsCurrentPlatform(Property property);
    private bool ContainsCurrentPlatform(string SwitchValue);
    private void GenerateOverrides(Property property, CodeMemberProperty propertyName);
    private void GenerateStringArrays(Property property, CodeMemberProperty propertyName);
    private void GenerateToolNameProperty(CodeTypeDeclaration taskClass);
    private static void GenerateImports(CodeNamespace codeNamespace);
    private void GenerateConstructor(CodeTypeDeclaration taskClass);
    private void GenerateRelations(CodeTypeDeclaration taskClass);
    private void LogError(string messageResourceName, Object[] messageArgs);
    private static string SurroundWithQuotes(string unformattedText);
    [CompilerGeneratedAttribute]
internal int get_ErrorCount();
    [CompilerGeneratedAttribute]
private void set_ErrorCount(int value);
    [CompilerGeneratedAttribute]
internal LinkedList`1<string> get_ErrorLog();
}
internal class Microsoft.Build.Tasks.Xaml.TaskParser : object {
    private List`1<string> _switchOrderList;
    [CompilerGeneratedAttribute]
private string <GeneratedTaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<Property> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<Property> <DefaultSet>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <FallbackSet>k__BackingField;
    [CompilerGeneratedAttribute]
private LinkedList`1<string> <ErrorLog>k__BackingField;
    public string GeneratedTaskName { get; public set; }
    public string BaseClass { get; }
    public string Namespace { get; }
    public string ResourceNamespace { get; }
    public string ToolName { get; private set; }
    public string DefaultPrefix { get; private set; }
    public LinkedList`1<Property> Properties { get; }
    public LinkedList`1<Property> DefaultSet { get; }
    public Dictionary`2<string, string> FallbackSet { get; }
    public IEnumerable`1<string> SwitchOrderList { get; }
    public LinkedList`1<string> ErrorLog { get; }
    [CompilerGeneratedAttribute]
public string get_GeneratedTaskName();
    [CompilerGeneratedAttribute]
public void set_GeneratedTaskName(string value);
    [CompilerGeneratedAttribute]
public string get_BaseClass();
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public string get_ResourceNamespace();
    [CompilerGeneratedAttribute]
public string get_ToolName();
    [CompilerGeneratedAttribute]
private void set_ToolName(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultPrefix();
    [CompilerGeneratedAttribute]
private void set_DefaultPrefix(string value);
    [CompilerGeneratedAttribute]
public LinkedList`1<Property> get_Properties();
    [CompilerGeneratedAttribute]
public LinkedList`1<Property> get_DefaultSet();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_FallbackSet();
    public IEnumerable`1<string> get_SwitchOrderList();
    [CompilerGeneratedAttribute]
public LinkedList`1<string> get_ErrorLog();
    public bool Parse(string contentOrFile, string desiredRule);
    private bool ParseAsContentOrFile(string contentOrFile, string desiredRule);
    internal bool ParseXamlDocument(TextReader reader, string desiredRule);
    internal bool ParseXamlDocument(Rule rule);
    private bool ParseParameterGroupOrParameter(BaseProperty baseProperty, LinkedList`1<Property> propertyList, Property property, Dictionary`2<string, Property> argumentDependencyLookup);
    private bool ParseParameter(BaseProperty baseProperty, LinkedList`1<Property> propertyList, Property property, Dictionary`2<string, Property> argumentDependencyLookup);
    private static Property ObtainAttributes(BaseProperty baseProperty, Property parameterGroup);
}
internal class Microsoft.Build.Tasks.Xaml.Value : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SwitchName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReverseSwitchName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Argument> <Arguments>k__BackingField;
    public string Name { get; public set; }
    public string SwitchName { get; public set; }
    public string ReverseSwitchName { get; public set; }
    public string Description { get; public set; }
    public string DisplayName { get; public set; }
    public string Prefix { get; public set; }
    public List`1<Argument> Arguments { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_SwitchName();
    [CompilerGeneratedAttribute]
public void set_SwitchName(string value);
    [CompilerGeneratedAttribute]
public string get_ReverseSwitchName();
    [CompilerGeneratedAttribute]
public void set_ReverseSwitchName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public List`1<Argument> get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(List`1<Argument> value);
}
public abstract class Microsoft.Build.Tasks.Xaml.XamlDataDrivenToolTask : ToolTask {
    private bool _skipResponseFileCommandGeneration;
    private TaskLoggingHelper _logPrivate;
    private string _commandLine;
    [CompilerGeneratedAttribute]
private string <CommandLineTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AcceptableNonZeroExitCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CommandLineToolSwitch> <ActiveToolSwitchesValues>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SwitchOrderList>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CommandLineToolSwitch> <ActiveToolSwitches>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <ResponseFileEncoding>k__BackingField;
    public string CommandLineTemplate { get; public set; }
    public string AdditionalOptions { get; public set; }
    public String[] AcceptableNonZeroExitCodes { get; public set; }
    public Dictionary`2<string, CommandLineToolSwitch> ActiveToolSwitchesValues { get; public set; }
    internal IEnumerable`1<string> SwitchOrderList { get; }
    protected internal Dictionary`2<string, CommandLineToolSwitch> ActiveToolSwitches { get; }
    protected Encoding ResponseFileEncoding { get; }
    private string CommandLine { get; private set; }
    protected XamlDataDrivenToolTask(String[] switchOrderList, ResourceManager taskResources);
    [CompilerGeneratedAttribute]
public string get_CommandLineTemplate();
    [CompilerGeneratedAttribute]
public void set_CommandLineTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_AdditionalOptions();
    [CompilerGeneratedAttribute]
public void set_AdditionalOptions(string value);
    [CompilerGeneratedAttribute]
public virtual String[] get_AcceptableNonZeroExitCodes();
    [CompilerGeneratedAttribute]
public virtual void set_AcceptableNonZeroExitCodes(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, CommandLineToolSwitch> get_ActiveToolSwitchesValues();
    [CompilerGeneratedAttribute]
public void set_ActiveToolSwitchesValues(Dictionary`2<string, CommandLineToolSwitch> value);
    [CompilerGeneratedAttribute]
internal virtual IEnumerable`1<string> get_SwitchOrderList();
    [CompilerGeneratedAttribute]
protected internal Dictionary`2<string, CommandLineToolSwitch> get_ActiveToolSwitches();
    [CompilerGeneratedAttribute]
protected virtual Encoding get_ResponseFileEncoding();
    private string get_CommandLine();
    private void set_CommandLine(string value);
    public bool IsPropertySet(string propertyName);
    public void ReplaceToolSwitch(CommandLineToolSwitch switchToAdd);
    public void AddActiveSwitchToolValue(CommandLineToolSwitch switchToAdd);
    public virtual bool Execute();
    internal string GetCommandLine_ForUnitTestsOnly();
    internal bool HasSwitch(string propertyName);
    internal bool IsAcceptableReturnValue();
    internal void PostProcessSwitchList();
    internal void ValidateRelations();
    internal void ValidateOverrides();
    protected virtual string GenerateResponseFileCommands();
    protected virtual bool HandleTaskExecutionErrors();
    private string GenerateCommands();
    public bool ValidateInteger(string switchName, int min, int max, int value);
    public string ReadSwitchMap(string propertyName, String[][] switchMap, string value);
    public int ReadSwitchMap2(string propertyName, Tuple`3[] switchMap, string value);
    public string CreateSwitchValue(string propertyName, string baseSwitch, string separator, Tuple`2[] arguments);
    internal void InitializeLogger(ResourceManager taskResources);
    protected virtual string GenerateFullPathToTool();
    protected virtual bool ValidateParameters();
    protected virtual string GenerateCommandLineCommands();
}
public class Microsoft.Build.Tasks.XamlTaskFactory : object {
    private static string XamlTaskNamespace;
    private Assembly _taskAssembly;
    private Type _taskType;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskElementContents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FactoryName>k__BackingField;
    public string TaskName { get; private set; }
    public string TaskNamespace { get; private set; }
    public string TaskElementContents { get; private set; }
    public string FactoryName { get; }
    public Type TaskType { get; }
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
private void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public string get_TaskNamespace();
    [CompilerGeneratedAttribute]
private void set_TaskNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_TaskElementContents();
    [CompilerGeneratedAttribute]
private void set_TaskElementContents(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FactoryName();
    public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
}
public class Microsoft.Build.Tasks.XmlPeek : TaskExtension {
    private string _query;
    [CompilerGeneratedAttribute]
private ITaskItem <XmlInputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlContent>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProhibitDtd>k__BackingField;
    public ITaskItem XmlInputPath { get; public set; }
    public string XmlContent { get; public set; }
    public string Query { get; public set; }
    [OutputAttribute]
public ITaskItem[] Result { get; private set; }
    public string Namespaces { get; public set; }
    public bool ProhibitDtd { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_XmlInputPath();
    [CompilerGeneratedAttribute]
public void set_XmlInputPath(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_XmlContent();
    [CompilerGeneratedAttribute]
public void set_XmlContent(string value);
    public string get_Query();
    public void set_Query(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(string value);
    [CompilerGeneratedAttribute]
public bool get_ProhibitDtd();
    [CompilerGeneratedAttribute]
public void set_ProhibitDtd(bool value);
    public virtual bool Execute();
    private static void LoadNamespaces(XmlNamespaceManager& namespaceManager, string namepaces);
}
public class Microsoft.Build.Tasks.XmlPoke : TaskExtension {
    private ITaskItem _xmlInputPath;
    private string _query;
    [CompilerGeneratedAttribute]
private ITaskItem <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespaces>k__BackingField;
    public ITaskItem XmlInputPath { get; public set; }
    public string Query { get; public set; }
    public ITaskItem Value { get; public set; }
    public string Namespaces { get; public set; }
    public ITaskItem get_XmlInputPath();
    public void set_XmlInputPath(ITaskItem value);
    public string get_Query();
    public void set_Query(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_Namespaces();
    [CompilerGeneratedAttribute]
public void set_Namespaces(string value);
    public virtual bool Execute();
    private static void LoadNamespaces(XmlNamespaceManager& namespaceManager, string namepaces);
}
public class Microsoft.Build.Tasks.XslTransformation : TaskExtension {
    private ITaskItem[] _outputPaths;
    [CompilerGeneratedAttribute]
private ITaskItem[] <XmlInputPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlContent>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <XslInputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XslContent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveWhitespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <XslCompiledDllPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseTrustedSettings>k__BackingField;
    public ITaskItem[] XmlInputPaths { get; public set; }
    public string XmlContent { get; public set; }
    public ITaskItem XslInputPath { get; public set; }
    public string XslContent { get; public set; }
    public bool PreserveWhitespace { get; public set; }
    public ITaskItem XslCompiledDllPath { get; public set; }
    [RequiredAttribute]
public ITaskItem[] OutputPaths { get; public set; }
    public string Parameters { get; public set; }
    public bool UseTrustedSettings { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_XmlInputPaths();
    [CompilerGeneratedAttribute]
public void set_XmlInputPaths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_XmlContent();
    [CompilerGeneratedAttribute]
public void set_XmlContent(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_XslInputPath();
    [CompilerGeneratedAttribute]
public void set_XslInputPath(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_XslContent();
    [CompilerGeneratedAttribute]
public void set_XslContent(string value);
    [CompilerGeneratedAttribute]
public bool get_PreserveWhitespace();
    [CompilerGeneratedAttribute]
public void set_PreserveWhitespace(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_XslCompiledDllPath();
    [CompilerGeneratedAttribute]
public void set_XslCompiledDllPath(ITaskItem value);
    public ITaskItem[] get_OutputPaths();
    public void set_OutputPaths(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(string value);
    [CompilerGeneratedAttribute]
public bool get_UseTrustedSettings();
    [CompilerGeneratedAttribute]
public void set_UseTrustedSettings(bool value);
    public virtual bool Execute();
    private static XsltArgumentList ProcessXsltArguments(string xsltParametersXml);
}
public class Microsoft.Build.Tasks.ZipDirectory : TaskExtension {
    [CompilerGeneratedAttribute]
private ITaskItem <DestinationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <SourceDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailIfNotIncremental>k__BackingField;
    [RequiredAttribute]
public ITaskItem DestinationFile { get; public set; }
    public bool Overwrite { get; public set; }
    [RequiredAttribute]
public ITaskItem SourceDirectory { get; public set; }
    public bool FailIfNotIncremental { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_DestinationFile();
    [CompilerGeneratedAttribute]
public void set_DestinationFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_SourceDirectory();
    [CompilerGeneratedAttribute]
public void set_SourceDirectory(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_FailIfNotIncremental();
    [CompilerGeneratedAttribute]
public sealed virtual void set_FailIfNotIncremental(bool value);
    public virtual bool Execute();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[SecurityCriticalAttribute]
[ComConversionLossAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
internal interface Microsoft.Runtime.Hosting.IClrStrongName {
    public abstract virtual int GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2, Int32& dwResult);
    public abstract virtual int StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual int StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetPublicKey(string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg, Int32& cbSize);
    public abstract virtual int StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual int StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyInstall(string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob);
    public abstract virtual int StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual int StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, Byte[] pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual int StrongNameSignatureSize(Byte[] pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& fWasVerified);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual int StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameTokenFromPublicKey(Byte[] pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
[SecurityCriticalAttribute]
[ComConversionLossAttribute]
[InterfaceTypeAttribute("1")]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
internal interface Microsoft.Runtime.Hosting.IClrStrongNameUsingIntPtr {
    public abstract virtual int GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2, Int32& dwResult);
    public abstract virtual int StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual int StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual int StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg, Int32& cbSize);
    public abstract virtual int StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual int StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual int StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    public abstract virtual int StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual int StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual int StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& fWasVerified);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags, Int32& dwOutFlags);
    public abstract virtual int StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual int StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
internal static class Microsoft.Runtime.Hosting.StrongNameHelpers : object {
    [ThreadStaticAttribute]
private static int t_ts_LastStrongNameHR;
    [SecurityCriticalAttribute]
[ThreadStaticAttribute]
private static IClrStrongName s_StrongName;
    [ThreadStaticAttribute]
private static MethodInfo s_GetRuntimeInterfaceAsObjectMethod;
    private static IClrStrongName StrongName { get; }
    private static IClrStrongNameUsingIntPtr StrongNameUsingIntPtr { get; }
    [SecurityCriticalAttribute]
private static IClrStrongName get_StrongName();
    [SecurityCriticalAttribute]
private static IClrStrongNameUsingIntPtr get_StrongNameUsingIntPtr();
    [SecurityCriticalAttribute]
public static int StrongNameErrorInfo();
    [SecurityCriticalAttribute]
public static void StrongNameFreeBuffer(IntPtr pbMemory);
    [SecurityCriticalAttribute]
public static bool StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyDelete(string pwzKeyContainer);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureVerification(string pwzFilePath, int dwInFlags, Int32& pdwOutFlags);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, Boolean& pfWasVerified);
    [SecurityCriticalAttribute]
public static bool StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureSize(Byte[] bPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    [SecurityCriticalAttribute]
public static bool StrongNameTokenFromPublicKey(Byte[] bPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    [SecurityCriticalAttribute]
public static bool StrongNameGetPublicKey(string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameKeyInstall(string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob);
    [SecurityCriticalAttribute]
public static bool StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, Byte[] bKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob);
}
[SupportedOSPlatform("windows")]
internal class System.Deployment.Internal.CodeSigning.CmiAuthenticodeSignerInfo : object {
    private int _error;
    private X509Chain _signerChain;
    private UInt32 _algHash;
    private string _hash;
    private string _description;
    private string _descriptionUrl;
    private CmiAuthenticodeTimestamperInfo _timestamperInfo;
    internal int ErrorCode { get; internal set; }
    internal UInt32 HashAlgId { get; internal set; }
    internal string Hash { get; internal set; }
    internal string Description { get; internal set; }
    internal string DescriptionUrl { get; internal set; }
    internal CmiAuthenticodeTimestamperInfo TimestamperInfo { get; }
    internal X509Chain SignerChain { get; internal set; }
    internal CmiAuthenticodeSignerInfo(int errorCode);
    internal CmiAuthenticodeSignerInfo(AXL_SIGNER_INFO signerInfo, AXL_TIMESTAMPER_INFO timestamperInfo);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    internal UInt32 get_HashAlgId();
    internal void set_HashAlgId(UInt32 value);
    internal string get_Hash();
    internal void set_Hash(string value);
    internal string get_Description();
    internal void set_Description(string value);
    internal string get_DescriptionUrl();
    internal void set_DescriptionUrl(string value);
    internal CmiAuthenticodeTimestamperInfo get_TimestamperInfo();
    internal X509Chain get_SignerChain();
    internal void set_SignerChain(X509Chain value);
}
[SupportedOSPlatform("windows")]
internal class System.Deployment.Internal.CodeSigning.CmiAuthenticodeTimestamperInfo : object {
    private int _error;
    private X509Chain _timestamperChain;
    private DateTime _timestampTime;
    private UInt32 _algHash;
    internal int ErrorCode { get; }
    internal UInt32 HashAlgId { get; }
    internal DateTime TimestampTime { get; }
    internal X509Chain TimestamperChain { get; }
    internal CmiAuthenticodeTimestamperInfo(AXL_TIMESTAMPER_INFO timestamperInfo);
    internal int get_ErrorCode();
    internal UInt32 get_HashAlgId();
    internal DateTime get_TimestampTime();
    internal X509Chain get_TimestamperChain();
}
internal class System.Deployment.Internal.CodeSigning.CmiManifestSigner2 : object {
    private AsymmetricAlgorithm _strongNameKey;
    private X509Certificate2 _certificate;
    private string _description;
    private string _url;
    private X509Certificate2Collection _certificates;
    private X509IncludeOption _includeOption;
    private CmiManifestSignerFlag _signerFlag;
    private bool _useSha256;
    internal static UInt32 CimManifestSignerFlagMask;
    internal bool UseSha256 { get; }
    internal AsymmetricAlgorithm StrongNameKey { get; }
    internal X509Certificate2 Certificate { get; }
    internal string Description { get; internal set; }
    internal string DescriptionUrl { get; internal set; }
    internal X509Certificate2Collection ExtraStore { get; }
    internal X509IncludeOption IncludeOption { get; internal set; }
    internal CmiManifestSignerFlag Flag { get; internal set; }
    internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey);
    internal CmiManifestSigner2(AsymmetricAlgorithm strongNameKey, X509Certificate2 certificate, bool useSha256);
    internal bool get_UseSha256();
    internal AsymmetricAlgorithm get_StrongNameKey();
    internal X509Certificate2 get_Certificate();
    internal string get_Description();
    internal void set_Description(string value);
    internal string get_DescriptionUrl();
    internal void set_DescriptionUrl(string value);
    internal X509Certificate2Collection get_ExtraStore();
    internal X509IncludeOption get_IncludeOption();
    internal void set_IncludeOption(X509IncludeOption value);
    internal CmiManifestSignerFlag get_Flag();
    internal void set_Flag(CmiManifestSignerFlag value);
}
[FlagsAttribute]
internal enum System.Deployment.Internal.CodeSigning.CmiManifestSignerFlag : Enum {
    public int value__;
    public static CmiManifestSignerFlag None;
    public static CmiManifestSignerFlag DontReplacePublicKeyToken;
}
[FlagsAttribute]
internal enum System.Deployment.Internal.CodeSigning.CmiManifestVerifyFlags : Enum {
    public int value__;
    public static CmiManifestVerifyFlags None;
    public static CmiManifestVerifyFlags RevocationNoCheck;
    public static CmiManifestVerifyFlags RevocationCheckEndCertOnly;
    public static CmiManifestVerifyFlags RevocationCheckEntireChain;
    public static CmiManifestVerifyFlags UrlCacheOnlyRetrieval;
    public static CmiManifestVerifyFlags LifetimeSigning;
    public static CmiManifestVerifyFlags TrustMicrosoftRootOnly;
    public static CmiManifestVerifyFlags StrongNameOnly;
}
internal class System.Deployment.Internal.CodeSigning.CmiStrongNameSignerInfo : object {
    private int _error;
    private string _publicKeyToken;
    private AsymmetricAlgorithm _snKey;
    internal int ErrorCode { get; internal set; }
    internal string PublicKeyToken { get; internal set; }
    internal AsymmetricAlgorithm PublicKey { get; internal set; }
    internal CmiStrongNameSignerInfo(int errorCode, string publicKeyToken);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    internal string get_PublicKeyToken();
    internal void set_PublicKeyToken(string value);
    internal AsymmetricAlgorithm get_PublicKey();
    internal void set_PublicKey(AsymmetricAlgorithm value);
}
internal class System.Deployment.Internal.CodeSigning.ManifestSignedXml2 : SignedXml {
    private bool _verify;
    private static string Sha256SignatureMethodUri;
    private static string Sha256DigestMethod;
    internal ManifestSignedXml2(XmlElement elem);
    internal ManifestSignedXml2(XmlDocument document);
    internal ManifestSignedXml2(XmlDocument document, bool verify);
    private void init();
    public virtual XmlElement GetIdElement(XmlDocument document, string idValue);
}
public class System.Deployment.Internal.CodeSigning.RSAPKCS1SHA256SignatureDescription : SignatureDescription {
    public virtual AsymmetricSignatureDeformatter CreateDeformatter(AsymmetricAlgorithm key);
    public virtual AsymmetricSignatureFormatter CreateFormatter(AsymmetricAlgorithm key);
}
[SupportedOSPlatform("windows")]
internal class System.Deployment.Internal.CodeSigning.SignedCmiManifest2 : object {
    private XmlDocument _manifestDom;
    private CmiStrongNameSignerInfo _strongNameSignerInfo;
    private CmiAuthenticodeSignerInfo _authenticodeSignerInfo;
    private bool _useSha256;
    private static string Sha256SignatureMethodUri;
    private static string Sha256DigestMethod;
    private static string Sha1SignatureMethodUri;
    private static string Sha1DigestMethod;
    private static string AssemblyNamespaceUri;
    private static string AssemblyV2NamespaceUri;
    private static string MSRelNamespaceUri;
    private static string LicenseNamespaceUri;
    private static string AuthenticodeNamespaceUri;
    private static string licenseTemplate;
    private static Char[] s_hexValues;
    internal CmiStrongNameSignerInfo StrongNameSignerInfo { get; }
    internal CmiAuthenticodeSignerInfo AuthenticodeSignerInfo { get; }
    internal SignedCmiManifest2(XmlDocument manifestDom, bool useSha256);
    private static SignedCmiManifest2();
    internal void Sign(CmiManifestSigner2 signer);
    internal void Sign(CmiManifestSigner2 signer, string timeStampUrl, bool disallowMansignTimestampFallback);
    internal CmiStrongNameSignerInfo get_StrongNameSignerInfo();
    internal CmiAuthenticodeSignerInfo get_AuthenticodeSignerInfo();
    private XmlElement ExtractPrincipalFromManifest();
    private static void InsertPublisherIdentity(XmlDocument manifestDom, X509Certificate2 signerCert);
    private static void RemoveExistingSignature(XmlDocument manifestDom);
    internal static RSACryptoServiceProvider GetFixedRSACryptoServiceProvider(RSACryptoServiceProvider oldCsp, bool useSha256);
    private static void ReplacePublicKeyToken(XmlDocument manifestDom, AsymmetricAlgorithm snKey, bool useSha256);
    private static Byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool useSha256);
    private static Byte[] ComputeHashFromManifest(XmlDocument manifestDom, bool oldFormat, bool useSha256);
    private static XmlDocument CreateLicenseDom(CmiManifestSigner2 signer, XmlElement principal, Byte[] hash);
    private static void AuthenticodeSignLicenseDom(XmlDocument licenseDom, CmiManifestSigner2 signer, string timeStampUrl, bool useSha256, bool disallowMansignTimestampFallback);
    private static string ObtainRFC3161Timestamp(string timeStampUrl, string signatureValue, bool useSha256);
    private static void TimestampSignedLicenseDom(XmlDocument licenseDom, string timeStampUrl, bool useSha256, bool disallowMansignTimestampFallback);
    private static void StrongNameSignManifestDom(XmlDocument manifestDom, XmlDocument licenseDom, CmiManifestSigner2 signer, bool useSha256);
    private static string BytesToHexString(Byte[] array, int start, int end);
}
internal static class System.Deployment.Internal.CodeSigning.Win32 : object {
    internal static string CRYPT32;
    internal static string KERNEL32;
    internal static string MSCORWKS;
    internal static int S_OK;
    internal static int NTE_BAD_KEY;
    internal static int TRUST_E_SYSTEM_ERROR;
    internal static int TRUST_E_NO_SIGNER_CERT;
    internal static int TRUST_E_COUNTER_SIGNER;
    internal static int TRUST_E_CERT_SIGNATURE;
    internal static int TRUST_E_TIME_STAMP;
    internal static int TRUST_E_BAD_DIGEST;
    internal static int TRUST_E_BASIC_CONSTRAINTS;
    internal static int TRUST_E_FINANCIAL_CRITERIA;
    internal static int TRUST_E_PROVIDER_UNKNOWN;
    internal static int TRUST_E_ACTION_UNKNOWN;
    internal static int TRUST_E_SUBJECT_FORM_UNKNOWN;
    internal static int TRUST_E_SUBJECT_NOT_TRUSTED;
    internal static int TRUST_E_NOSIGNATURE;
    internal static int CERT_E_UNTRUSTEDROOT;
    internal static int TRUST_E_FAIL;
    internal static int TRUST_E_EXPLICIT_DISTRUST;
    internal static int CERT_E_CHAINING;
    internal static int AXL_REVOCATION_NO_CHECK;
    internal static int AXL_REVOCATION_CHECK_END_CERT_ONLY;
    internal static int AXL_REVOCATION_CHECK_ENTIRE_CHAIN;
    internal static int AXL_URL_CACHE_ONLY_RETRIEVAL;
    internal static int AXL_LIFETIME_SIGNING;
    internal static int AXL_TRUST_MICROSOFT_ROOT_ONLY;
    internal static int WTPF_IGNOREREVOKATION;
    internal static string szOID_KP_LIFETIME_SIGNING;
    internal static string szOID_RSA_signingTime;
    internal static string szOID_OIWSEC_sha1;
    internal static string szOID_NIST_sha256;
    internal static IntPtr GetProcessHeap();
    internal static bool HeapFree(IntPtr hHeap, UInt32 dwFlags, IntPtr lpMem);
    internal static int CertTimestampAuthenticodeLicense(CRYPT_DATA_BLOB& pSignedLicenseBlob, string pwszTimestampURI, CRYPT_DATA_BLOB& pTimestampSignatureBlob);
    internal static int CertVerifyAuthenticodeLicense(CRYPT_DATA_BLOB& pLicenseBlob, UInt32 dwFlags, AXL_SIGNER_INFO& pSignerInfo, AXL_TIMESTAMPER_INFO& pTimestamperInfo);
    internal static int CertFreeAuthenticodeSignerInfo(AXL_SIGNER_INFO& pSignerInfo);
    internal static int CertFreeAuthenticodeTimestamperInfo(AXL_TIMESTAMPER_INFO& pTimestamperInfo);
    internal static int _AxlGetIssuerPublicKeyHash(IntPtr pCertContext, IntPtr& ppwszPublicKeyHash);
    internal static int _AxlRSAKeyValueToPublicKeyToken(CRYPT_DATA_BLOB& pModulusBlob, CRYPT_DATA_BLOB& pExponentBlob, IntPtr& ppwszPublicKeyToken);
    internal static int _AxlPublicKeyBlobToPublicKeyToken(CRYPT_DATA_BLOB& pCspPublicKeyBlob, IntPtr& ppwszPublicKeyToken);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CryptRetrieveTimeStamp(string wszUrl, UInt32 dwRetrievalFlags, int dwTimeout, string pszHashId, CRYPT_TIMESTAMP_PARA& pPara, Byte[] pbData, int cbData, IntPtr& ppTsContext, IntPtr& ppTsSigner, IntPtr& phStore);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertFreeCertificateContext(IntPtr pCertContext);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static bool CertCloseStore(IntPtr pCertContext, int dwFlags);
    [DefaultDllImportSearchPathsAttribute("2048")]
internal static void CryptMemFree(IntPtr pv);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.Security.Cryptography.CngLightup : object {
    private static string DsaOid;
    private static string RsaOid;
    private static string HashAlgorithmNameTypeName;
    private static string RSASignaturePaddingTypeName;
    private static string RSAEncryptionPaddingTypeName;
    private static string RSACngTypeName;
    private static string DSACngTypeName;
    private static Type s_hashAlgorithmNameType;
    private static Type s_rsaSignaturePaddingType;
    private static Type s_rsaEncryptionPaddingType;
    private static object s_pkcs1SignaturePadding;
    private static object s_pkcs1EncryptionPadding;
    private static object s_oaepSha1EncryptionPadding;
    private static Lazy`1<bool> s_preferRsaCng;
    private static Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_getDsaPublicKey;
    private static Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_getDsaPrivateKey;
    private static Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_getRsaPublicKey;
    private static Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_getRsaPrivateKey;
    private static Func`4 modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaPkcs1SignMethod;
    private static Func`5 modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaPkcs1VerifyMethod;
    private static Func`3 modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaPkcs1EncryptMethod;
    private static Func`3 modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaPkcs1DecryptMethod;
    private static Func`3 modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaOaepSha1EncryptMethod;
    private static Func`3 modreq(System.Runtime.CompilerServices.IsVolatile) s_rsaOaepSha1DecryptMethod;
    private static Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_getECDsaPublicKey;
    private static Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_getECDsaPrivateKey;
    private static CngLightup();
    internal static RSA GetRSAPublicKey(X509Certificate2 cert);
    internal static RSA GetRSAPrivateKey(X509Certificate2 cert);
    internal static DSA GetDSAPublicKey(X509Certificate2 cert);
    internal static DSA GetDSAPrivateKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPublicKey(X509Certificate2 cert);
    internal static ECDsa GetECDsaPrivateKey(X509Certificate2 cert);
    internal static Byte[] Pkcs1SignData(RSA rsa, Byte[] data, string hashAlgorithmName);
    internal static bool Pkcs1VerifyData(RSA rsa, Byte[] data, Byte[] signature, string hashAlgorithmName);
    internal static Byte[] Pkcs1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] Pkcs1Decrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Encrypt(RSA rsa, Byte[] data);
    internal static Byte[] OaepSha1Decrypt(RSA rsa, Byte[] data);
    private static Delegate BindRsaCryptMethod(string methodName);
    private static bool DetectRsaCngSupport();
    private static Func`2<X509Certificate2, T> BindGetCapiPublicKey(string algorithmOid);
    private static Func`2<X509Certificate2, T> BindGetCapiPrivateKey(string algorithmOid, Func`2<CspParameters, T> instanceFactory);
    private static Func`2<X509Certificate2, T> BindCoreDelegate(string algorithmName, bool isPublic);
    private static CspParameters CopyCspParameters(ICspAsymmetricAlgorithm cspAlgorithm);
    private static Type GetSystemCoreType(string namespaceQualifiedTypeName, bool throwOnError);
}
