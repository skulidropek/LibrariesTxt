internal static class FxResources.System.Threading.Tasks.Dataflow.SR : object {
}
internal class Internal.PaddingFor32 : ValueType {
}
internal static class Internal.PaddingHelpers : object {
    internal static int CACHE_LINE_SIZE;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("64")]
internal class System.Runtime.InteropServices.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    public LibraryImportAttribute(string libraryName);
    [CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
internal enum System.Runtime.InteropServices.StringMarshalling : Enum {
    public int value__;
    public static StringMarshalling Custom;
    public static StringMarshalling Utf8;
    public static StringMarshalling Utf16;
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity { get; }
    internal static string ArgumentOutOfRange_GenericPositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string Argument_BoundedCapacityNotSupported { get; }
    internal static string Argument_CantConsumeFromANullSource { get; }
    internal static string Argument_InvalidMessageHeader { get; }
    internal static string Argument_InvalidMessageId { get; }
    internal static string Argument_NonGreedyNotSupported { get; }
    internal static string InvalidOperation_DataNotAvailableForReceive { get; }
    internal static string InvalidOperation_FailedToConsumeReservedMessage { get; }
    internal static string InvalidOperation_MessageNotReservedByTarget { get; }
    internal static string NotSupported_MemberNotNeeded { get; }
    internal static string InvalidOperation_ErrorDuringCleanup { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentOutOfRange_BatchSizeMustBeNoGreaterThanBoundedCapacity();
    internal static string get_ArgumentOutOfRange_GenericPositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_Argument_BoundedCapacityNotSupported();
    internal static string get_Argument_CantConsumeFromANullSource();
    internal static string get_Argument_InvalidMessageHeader();
    internal static string get_Argument_InvalidMessageId();
    internal static string get_Argument_NonGreedyNotSupported();
    internal static string get_InvalidOperation_DataNotAvailableForReceive();
    internal static string get_InvalidOperation_FailedToConsumeReservedMessage();
    internal static string get_InvalidOperation_MessageNotReservedByTarget();
    internal static string get_NotSupported_MemberNotNeeded();
    internal static string get_InvalidOperation_ErrorDuringCleanup();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.ActionBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.ActionBlock`1 : object {
    private TargetCore`1<TInput> _defaultTarget;
    private SpscTargetCore`1<TInput> _spscTarget;
    public Task Completion { get; }
    public int InputCount { get; }
    private int InputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public ActionBlock`1(Action`1<TInput> action);
    public ActionBlock`1(Action`1<TInput> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    public ActionBlock`1(Func`2<TInput, Task> action);
    public ActionBlock`1(Func`2<TInput, Task> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private ActionBlock`1(Delegate action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private void ProcessMessage(Action`1<TInput> action, KeyValuePair`2<TInput, long> messageWithId);
    private void ProcessMessageWithTask(Func`2<TInput, Task> action, KeyValuePair`2<TInput, long> messageWithId);
    private void AsyncCompleteProcessMessageWithTask(Task completed);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual Task get_Completion();
    public bool Post(TInput item);
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    public int get_InputCount();
    private int get_InputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BatchBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.BatchBlock`1 : object {
    private BatchBlockTargetCore<T> _target;
    private SourceCore`1<T[]> _source;
    public int OutputCount { get; }
    public Task Completion { get; }
    public int BatchSize { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BatchBlock`1(int batchSize);
    public BatchBlock`1(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public void TriggerBatch();
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T[]> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<T[]> filter, T[]& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public int get_BatchSize();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    private sealed virtual override T[] System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T[]> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T[]> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T[]>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T[]> target);
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_3(Task <p0>);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BatchedJoinBlock`2/DebugView")]
public class System.Threading.Tasks.Dataflow.BatchedJoinBlock`2 : object {
    private int _batchSize;
    private BatchedJoinBlockTargetSharedResources _sharedResources;
    private BatchedJoinBlockTarget`1<T1> _target1;
    private BatchedJoinBlockTarget`1<T2> _target2;
    private SourceCore`1<Tuple`2<IList`1<T1>, IList`1<T2>>> _source;
    public int BatchSize { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    public int OutputCount { get; }
    public Task Completion { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BatchedJoinBlock`2(int batchSize);
    public BatchedJoinBlock`2(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
    public int get_BatchSize();
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`2<IList`1<T1>, IList`1<T2>>> filter, Tuple`2& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override Tuple`2<IList`1<T1>, IList`1<T2>> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<IList`1<T1>, IList`1<T2>>> target);
    private void CompleteEachTarget();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BatchedJoinBlock`3/DebugView")]
public class System.Threading.Tasks.Dataflow.BatchedJoinBlock`3 : object {
    private int _batchSize;
    private BatchedJoinBlockTargetSharedResources _sharedResources;
    private BatchedJoinBlockTarget`1<T1> _target1;
    private BatchedJoinBlockTarget`1<T2> _target2;
    private BatchedJoinBlockTarget`1<T3> _target3;
    private SourceCore`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> _source;
    public int BatchSize { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    public ITargetBlock`1<T3> Target3 { get; }
    public int OutputCount { get; }
    public Task Completion { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BatchedJoinBlock`3(int batchSize);
    public BatchedJoinBlock`3(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions);
    public int get_BatchSize();
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    public ITargetBlock`1<T3> get_Target3();
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> filter, Tuple`3& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<System.Collections.Generic.IList<T1>,System.Collections.Generic.IList<T2>,System.Collections.Generic.IList<T3>>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<IList`1<T1>, IList`1<T2>, IList`1<T3>>> target);
    private void CompleteEachTarget();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <.ctor>b__7_1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BroadcastBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.BroadcastBlock`1 : object {
    private BroadcastingSourceCore`1<T, T> _source;
    private BoundingStateWithPostponedAndTask`1<T> _boundingState;
    private bool _decliningPermanently;
    private bool _completionReserved;
    private object IncomingLock { get; }
    public Task Completion { get; }
    private bool HasValueForDebugger { get; }
    private T ValueForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BroadcastBlock`1(Func`2<T, T> cloningFunction);
    public BroadcastBlock`1(Func`2<T, T> cloningFunction, DataflowBlockOptions dataflowBlockOptions);
    private object get_IncomingLock();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    internal void CompleteCore(Exception exception, bool storeExceptionEvenIfAlreadyCompleting, bool revertProcessingState);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.IReceivableSourceBlock<T>.TryReceiveAll(IList`1& items);
    public sealed virtual Task get_Completion();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    private void OnItemsRemoved(int numItemsRemoved);
    internal void ConsumeAsyncIfNecessary(bool isReplacementReplica);
    private void ConsumeMessagesLoopCore();
    private bool ConsumeAndStoreOneMessageIfAvailable();
    private void CompleteTargetIfPossible();
    private sealed virtual override T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private bool get_HasValueForDebugger();
    private T get_ValueForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <ConsumeAsyncIfNecessary>b__18_1(object exc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.BufferBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.BufferBlock`1 : object {
    private SourceCore`1<T> _source;
    private BoundingStateWithPostponedAndTask`1<T> _boundingState;
    private bool _targetDecliningPermanently;
    private bool _targetCompletionReserved;
    private object IncomingLock { get; }
    public int Count { get; }
    public Task Completion { get; }
    private int CountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public BufferBlock`1(DataflowBlockOptions dataflowBlockOptions);
    private object get_IncomingLock();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private void CompleteCore(Exception exception, bool storeExceptionEvenIfAlreadyCompleting, bool revertProcessingState);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_Count();
    public sealed virtual Task get_Completion();
    private sealed virtual override T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private void OnItemsRemoved(int numItemsRemoved);
    internal void ConsumeAsyncIfNecessary(bool isReplacementReplica);
    private void ConsumeMessagesLoopCore();
    private bool ConsumeAndStoreOneMessageIfAvailable();
    private void CompleteTargetIfPossible();
    private int get_CountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <ConsumeAsyncIfNecessary>b__23_1(object exc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.Tasks.Dataflow.DataflowBlock : object {
    private static Action`1<object> _cancelCts;
    private static ExecutionDataflowBlockOptions _nonGreedyExecutionOptions;
    private static DataflowBlock();
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<TOutput> source, ITargetBlock`1<TOutput> target);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<TOutput> source, ITargetBlock`1<TOutput> target, Predicate`1<TOutput> predicate);
    [ExtensionAttribute]
public static IDisposable LinkTo(ISourceBlock`1<TOutput> source, ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions, Predicate`1<TOutput> predicate);
    [ExtensionAttribute]
public static bool Post(ITargetBlock`1<TInput> target, TInput item);
    [ExtensionAttribute]
public static Task`1<bool> SendAsync(ITargetBlock`1<TInput> target, TInput item);
    [ExtensionAttribute]
public static Task`1<bool> SendAsync(ITargetBlock`1<TInput> target, TInput item, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceive(IReceivableSourceBlock`1<TOutput> source, TOutput& item);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source, TimeSpan timeout);
    [ExtensionAttribute]
public static Task`1<TOutput> ReceiveAsync(ISourceBlock`1<TOutput> source, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source, TimeSpan timeout);
    [ExtensionAttribute]
public static TOutput Receive(ISourceBlock`1<TOutput> source, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static Task`1<TOutput> ReceiveCore(ISourceBlock`1<TOutput> source, bool attemptTryReceive, TimeSpan timeout, CancellationToken cancellationToken);
    private static Task`1<TOutput> ReceiveCoreByLinking(ISourceBlock`1<TOutput> source, int millisecondsTimeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> OutputAvailableAsync(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static Task`1<bool> OutputAvailableAsync(ISourceBlock`1<TOutput> source, CancellationToken cancellationToken);
    public static IPropagatorBlock`2<TInput, TOutput> Encapsulate(ITargetBlock`1<TInput> target, ISourceBlock`1<TOutput> source);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, DataflowBlockOptions dataflowBlockOptions);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3);
    public static Task`1<int> Choose(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3, DataflowBlockOptions dataflowBlockOptions);
    private static Task`1<int> ChooseCore(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3, DataflowBlockOptions dataflowBlockOptions);
    private static bool TryChooseFromSource(ISourceBlock`1<T> source, Action`1<T> action, int branchId, TaskScheduler scheduler, Task`1& task);
    private static Task`1<int> ChooseCoreByLinking(ISourceBlock`1<T1> source1, Action`1<T1> action1, ISourceBlock`1<T2> source2, Action`1<T2> action2, ISourceBlock`1<T3> source3, Action`1<T3> action3, DataflowBlockOptions dataflowBlockOptions);
    private static Task`1<int> CreateChooseBranch(StrongBox`1<Task> boxedCompleted, CancellationTokenSource cts, TaskScheduler scheduler, int branchId, ISourceBlock`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IObservable`1<TOutput> AsObservable(ISourceBlock`1<TOutput> source);
    [ExtensionAttribute]
public static IObserver`1<TInput> AsObserver(ITargetBlock`1<TInput> target);
    public static ITargetBlock`1<TInput> NullTarget();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("TaskScheduler = {TaskScheduler}, MaxMessagesPerTask = {MaxMessagesPerTask}, BoundedCapacity = {BoundedCapacity}")]
public class System.Threading.Tasks.Dataflow.DataflowBlockOptions : object {
    public static int Unbounded;
    private TaskScheduler _taskScheduler;
    private CancellationToken _cancellationToken;
    private int _maxMessagesPerTask;
    private int _boundedCapacity;
    private string _nameFormat;
    private bool _ensureOrdered;
    internal static DataflowBlockOptions Default;
    public TaskScheduler TaskScheduler { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public int MaxMessagesPerTask { get; public set; }
    internal int ActualMaxMessagesPerTask { get; }
    public int BoundedCapacity { get; public set; }
    public string NameFormat { get; public set; }
    public bool EnsureOrdered { get; public set; }
    private static DataflowBlockOptions();
    internal DataflowBlockOptions DefaultOrClone();
    public TaskScheduler get_TaskScheduler();
    public void set_TaskScheduler(TaskScheduler value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    public int get_MaxMessagesPerTask();
    public void set_MaxMessagesPerTask(int value);
    internal int get_ActualMaxMessagesPerTask();
    public int get_BoundedCapacity();
    public void set_BoundedCapacity(int value);
    public string get_NameFormat();
    public void set_NameFormat(string value);
    public bool get_EnsureOrdered();
    public void set_EnsureOrdered(bool value);
}
[DebuggerDisplayAttribute("PropagateCompletion = {PropagateCompletion}, MaxMessages = {MaxMessages}, Append = {Append}")]
public class System.Threading.Tasks.Dataflow.DataflowLinkOptions : object {
    internal static int Unbounded;
    private bool _propagateCompletion;
    private int _maxNumberOfMessages;
    private bool _append;
    internal static DataflowLinkOptions Default;
    internal static DataflowLinkOptions UnlinkAfterOneAndPropagateCompletion;
    public bool PropagateCompletion { get; public set; }
    public int MaxMessages { get; public set; }
    public bool Append { get; public set; }
    private static DataflowLinkOptions();
    public bool get_PropagateCompletion();
    public void set_PropagateCompletion(bool value);
    public int get_MaxMessages();
    public void set_MaxMessages(int value);
    public bool get_Append();
    public void set_Append(bool value);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Id = {Id}")]
public class System.Threading.Tasks.Dataflow.DataflowMessageHeader : ValueType {
    private long _id;
    public bool IsValid { get; }
    public long Id { get; }
    public DataflowMessageHeader(long id);
    public bool get_IsValid();
    public long get_Id();
    public sealed virtual bool Equals(DataflowMessageHeader other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DataflowMessageHeader left, DataflowMessageHeader right);
    public static bool op_Inequality(DataflowMessageHeader left, DataflowMessageHeader right);
}
public enum System.Threading.Tasks.Dataflow.DataflowMessageStatus : Enum {
    public int value__;
    public static DataflowMessageStatus Accepted;
    public static DataflowMessageStatus Declined;
    public static DataflowMessageStatus Postponed;
    public static DataflowMessageStatus NotAvailable;
    public static DataflowMessageStatus DecliningPermanently;
}
[DebuggerDisplayAttribute("TaskScheduler = {TaskScheduler}, MaxMessagesPerTask = {MaxMessagesPerTask}, BoundedCapacity = {BoundedCapacity}, MaxDegreeOfParallelism = {MaxDegreeOfParallelism}")]
public class System.Threading.Tasks.Dataflow.ExecutionDataflowBlockOptions : DataflowBlockOptions {
    internal static ExecutionDataflowBlockOptions Default;
    private int _maxDegreeOfParallelism;
    private bool _singleProducerConstrained;
    public int MaxDegreeOfParallelism { get; public set; }
    public bool SingleProducerConstrained { get; public set; }
    internal int ActualMaxDegreeOfParallelism { get; }
    internal bool SupportsParallelExecution { get; }
    private static ExecutionDataflowBlockOptions();
    internal ExecutionDataflowBlockOptions DefaultOrClone();
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    public bool get_SingleProducerConstrained();
    public void set_SingleProducerConstrained(bool value);
    internal int get_ActualMaxDegreeOfParallelism();
    internal bool get_SupportsParallelExecution();
}
[DebuggerDisplayAttribute("TaskScheduler = {TaskScheduler}, MaxMessagesPerTask = {MaxMessagesPerTask}, BoundedCapacity = {BoundedCapacity}, Greedy = {Greedy}, MaxNumberOfGroups = {MaxNumberOfGroups}")]
public class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions : DataflowBlockOptions {
    internal static GroupingDataflowBlockOptions Default;
    private bool _greedy;
    private long _maxNumberOfGroups;
    public bool Greedy { get; public set; }
    public long MaxNumberOfGroups { get; public set; }
    internal long ActualMaxNumberOfGroups { get; }
    private static GroupingDataflowBlockOptions();
    internal GroupingDataflowBlockOptions DefaultOrClone();
    public bool get_Greedy();
    public void set_Greedy(bool value);
    public long get_MaxNumberOfGroups();
    public void set_MaxNumberOfGroups(long value);
    internal long get_ActualMaxNumberOfGroups();
}
[NullableContextAttribute("1")]
public interface System.Threading.Tasks.Dataflow.IDataflowBlock {
    public Task Completion { get; }
    public abstract virtual Task get_Completion();
    public abstract virtual void Complete();
    public abstract virtual void Fault(Exception exception);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.BatchedJoinBlockTarget`1/DebugView")]
internal class System.Threading.Tasks.Dataflow.Internal.BatchedJoinBlockTarget`1 : object {
    private BatchedJoinBlockTargetSharedResources _sharedResources;
    private bool _decliningPermanently;
    private IList`1<T> _messages;
    internal int Count { get; }
    private Task System.Threading.Tasks.Dataflow.IDataflowBlock.Completion { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    internal BatchedJoinBlockTarget`1(BatchedJoinBlockTargetSharedResources sharedResources);
    internal int get_Count();
    internal IList`1<T> GetAndEmptyMessages();
    public sealed virtual DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    private sealed virtual override Task System.Threading.Tasks.Dataflow.IDataflowBlock.get_Completion();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
internal class System.Threading.Tasks.Dataflow.Internal.BatchedJoinBlockTargetSharedResources : object {
    internal object _incomingLock;
    internal int _batchSize;
    internal Action _batchSizeReachedAction;
    internal Action _allTargetsDecliningPermanentlyAction;
    internal Action`1<Exception> _exceptionAction;
    internal Action _completionAction;
    internal int _remainingItemsInBatch;
    internal int _remainingAliveTargets;
    internal bool _decliningPermanently;
    internal long _batchesCreated;
    internal BatchedJoinBlockTargetSharedResources(int batchSize, GroupingDataflowBlockOptions dataflowBlockOptions, Action batchSizeReachedAction, Action allTargetsDecliningAction, Action`1<Exception> exceptionAction, Action completionAction);
}
[DebuggerDisplayAttribute("BoundedCapacity={BoundedCapacity}}")]
internal class System.Threading.Tasks.Dataflow.Internal.BoundingState : object {
    internal int BoundedCapacity;
    internal int CurrentCount;
    internal bool CountIsLessThanBound { get; }
    internal BoundingState(int boundedCapacity);
    internal bool get_CountIsLessThanBound();
}
[DebuggerDisplayAttribute("BoundedCapacity={BoundedCapacity}, PostponedMessages={PostponedMessagesCountForDebugger}")]
internal class System.Threading.Tasks.Dataflow.Internal.BoundingStateWithPostponed`1 : BoundingState {
    internal QueuedMap`2<ISourceBlock`1<TInput>, DataflowMessageHeader> PostponedMessages;
    internal int OutstandingTransfers;
    private int PostponedMessagesCountForDebugger { get; }
    internal BoundingStateWithPostponed`1(int boundedCapacity);
    private int get_PostponedMessagesCountForDebugger();
}
internal class System.Threading.Tasks.Dataflow.Internal.BoundingStateWithPostponedAndTask`1 : BoundingStateWithPostponed`1<TInput> {
    internal Task TaskForInputProcessing;
    internal BoundingStateWithPostponedAndTask`1(int boundedCapacity);
}
internal static class System.Threading.Tasks.Dataflow.Internal.Common : object {
    internal static long INVALID_REORDERING_ID;
    internal static int SINGLE_MESSAGE_ID;
    internal static DataflowMessageHeader SingleMessageHeader;
    internal static Task`1<bool> CompletedTaskWithTrueResult;
    internal static Task`1<bool> CompletedTaskWithFalseResult;
    internal static TaskCompletionSource`1<VoidResult> CompletedVoidResultTaskCompletionSource;
    internal static int KEEP_ALIVE_NUMBER_OF_MESSAGES_THRESHOLD;
    internal static int KEEP_ALIVE_BAN_COUNT;
    internal static string EXCEPTIONDATAKEY_DATAFLOWMESSAGEVALUE;
    internal static TimeSpan InfiniteTimeSpan;
    internal static Action`1<Exception> AsyncExceptionHandler;
    private static Common();
    [ConditionalAttribute("DEBUG")]
internal static void ContractAssertMonitorStatus(object syncObj, bool held);
    internal static bool TryKeepAliveUntil(KeepAlivePredicate`2<TStateIn, TStateOut> predicate, TStateIn stateIn, TStateOut& stateOut);
    internal static T UnwrapWeakReference(object state);
    internal static int GetBlockId(IDataflowBlock block);
    internal static string GetNameForDebugger(IDataflowBlock block, DataflowBlockOptions options);
    internal static bool IsCooperativeCancellation(Exception exception);
    internal static void WireCancellationToComplete(CancellationToken cancellationToken, Task completionTask, Action`1<object> completeAction, object completeState);
    internal static Exception InitializeStackTrace(Exception exception);
    internal static void StoreDataflowMessageValueIntoExceptionData(Exception exc, T messageValue, bool targetInnerExceptions);
    private static void StoreStringIntoExceptionData(Exception exception, string key, string value);
    internal static void ThrowAsync(Exception error);
    internal static void AddException(List`1& list, Exception exception, bool unwrapInnerExceptions);
    private static Task`1<bool> CreateCachedBooleanTask(bool value);
    private static TaskCompletionSource`1<T> CreateCachedTaskCompletionSource();
    internal static Task`1<TResult> CreateTaskFromException(Exception exception);
    internal static Task`1<TResult> CreateTaskFromCancellation(CancellationToken cancellationToken);
    internal static Task GetPotentiallyNotSupportedCompletionTask(IDataflowBlock block);
    internal static IDisposable CreateUnlinker(object outgoingLock, TargetRegistry`1<TOutput> targetRegistry, ITargetBlock`1<TOutput> targetBlock);
    internal static bool IsValidTimeout(TimeSpan timeout);
    internal static TaskContinuationOptions GetContinuationOptions(TaskContinuationOptions toInclude);
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
    internal static Exception StartTaskSafe(Task task, TaskScheduler scheduler);
    private static Exception StartTaskSafeCore(Task task, TaskScheduler scheduler);
    internal static void ReleaseAllPostponedMessages(ITargetBlock`1<T> target, QueuedMap`2<ISourceBlock`1<T>, DataflowMessageHeader> postponedMessages, List`1& exceptions);
    internal static void PropagateCompletion(Task sourceCompletionTask, IDataflowBlock target, Action`1<Exception> exceptionHandler);
    private static void PropagateCompletionAsContinuation(Task sourceCompletionTask, IDataflowBlock target);
    internal static void PropagateCompletionOnceCompleted(Task sourceCompletionTask, IDataflowBlock target);
}
[EventSourceAttribute]
internal class System.Threading.Tasks.Dataflow.Internal.DataflowEtwProvider : EventSource {
    internal static DataflowEtwProvider Log;
    private static EventKeywords ALL_KEYWORDS;
    private static int DATAFLOWBLOCKCREATED_EVENTID;
    private static int TASKLAUNCHED_EVENTID;
    private static int BLOCKCOMPLETED_EVENTID;
    private static int BLOCKLINKED_EVENTID;
    private static int BLOCKUNLINKED_EVENTID;
    private static DataflowEtwProvider();
    [NonEventAttribute]
internal void DataflowBlockCreated(IDataflowBlock block, DataflowBlockOptions dataflowBlockOptions);
    [EventAttribute("1")]
private void DataflowBlockCreated(string blockName, int blockId);
    [NonEventAttribute]
internal void TaskLaunchedForMessageHandling(IDataflowBlock block, Task task, TaskLaunchedReason reason, int availableMessages);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("2")]
private void TaskLaunchedForMessageHandling(int blockId, TaskLaunchedReason reason, int availableMessages, int taskId);
    [NonEventAttribute]
internal void DataflowBlockCompleted(IDataflowBlock block);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("3")]
private void DataflowBlockCompleted(int blockId, BlockCompletionReason reason, string exceptionData);
    [NonEventAttribute]
internal void DataflowBlockLinking(ISourceBlock`1<T> source, ITargetBlock`1<T> target);
    [EventAttribute("4")]
private void DataflowBlockLinking(int sourceId, int targetId);
    [NonEventAttribute]
internal void DataflowBlockUnlinking(ISourceBlock`1<T> source, ITargetBlock`1<T> target);
    [EventAttribute("5")]
private void DataflowBlockUnlinking(int sourceId, int targetId);
}
internal static class System.Threading.Tasks.Dataflow.Internal.Disposables : object {
    internal static IDisposable Nop;
    private static Disposables();
    internal static IDisposable Create(Action`2<T1, T2> action, T1 arg1, T2 arg2);
    internal static IDisposable Create(Action`3<T1, T2, T3> action, T1 arg1, T2 arg2, T3 arg3);
}
internal class System.Threading.Tasks.Dataflow.Internal.EnumerableDebugView`2 : object {
    private IEnumerable`1<KeyValuePair`2<TKey, TValue>> _enumerable;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public EnumerableDebugView`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> enumerable);
    public KeyValuePair`2[] get_Items();
}
internal interface System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay {
    public object Content { get; }
    public abstract virtual object get_Content();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Count={Count}")]
internal class System.Threading.Tasks.Dataflow.Internal.ImmutableArray`1 : ValueType {
    private static ImmutableArray`1<T> s_empty;
    private T[] _array;
    public static ImmutableArray`1<T> Empty { get; }
    public int Count { get; }
    private ImmutableArray`1(T[] elements);
    private static ImmutableArray`1();
    public static ImmutableArray`1<T> get_Empty();
    public ImmutableArray`1<T> Add(T item);
    public ImmutableArray`1<T> Remove(T item);
    public int get_Count();
    public bool Contains(T item);
    public IEnumerator`1<T> GetEnumerator();
    public T[] ToArray();
}
internal interface System.Threading.Tasks.Dataflow.Internal.IReorderingBuffer {
    public abstract virtual void IgnoreItem(long id);
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.JoinBlockTarget`1/DebugView")]
internal class System.Threading.Tasks.Dataflow.Internal.JoinBlockTarget`1 : JoinBlockTargetBase {
    private JoinBlockTargetSharedResources _sharedResources;
    private TaskCompletionSource`1<VoidResult> _completionTask;
    private Queue`1<T> _messages;
    private NonGreedyState<T> _nonGreedy;
    private bool _decliningPermanently;
    internal bool IsDecliningPermanently { get; }
    internal bool HasAtLeastOneMessageAvailable { get; }
    internal bool HasAtLeastOnePostponedMessage { get; }
    internal int NumberOfMessagesAvailableOrPostponed { get; }
    internal bool HasTheHighestNumberOfMessagesAvailable { get; }
    public Task Completion { get; }
    internal Task CompletionTaskInternal { get; }
    private int InputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    internal JoinBlockTarget`1(JoinBlockTargetSharedResources sharedResources);
    internal T GetOneMessage();
    internal virtual bool get_IsDecliningPermanently();
    internal virtual bool get_HasAtLeastOneMessageAvailable();
    internal virtual bool get_HasAtLeastOnePostponedMessage();
    internal virtual int get_NumberOfMessagesAvailableOrPostponed();
    internal virtual bool get_HasTheHighestNumberOfMessagesAvailable();
    internal virtual bool ReserveOneMessage();
    internal virtual bool ConsumeReservedMessage();
    internal virtual bool ConsumeOnePostponedMessage();
    private void CompleteIfLastJoinIsFeasible();
    internal virtual void ReleaseReservedMessage();
    internal virtual void ClearReservation();
    internal virtual void CompleteOncePossible();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    internal virtual void CompleteCore(Exception exception, bool dropPendingMessages, bool releaseReservedMessages);
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual Task get_Completion();
    internal Task get_CompletionTaskInternal();
    private int get_InputCountForDebugger();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
internal abstract class System.Threading.Tasks.Dataflow.Internal.JoinBlockTargetBase : object {
    internal bool IsDecliningPermanently { get; }
    internal bool HasAtLeastOneMessageAvailable { get; }
    internal bool HasAtLeastOnePostponedMessage { get; }
    internal int NumberOfMessagesAvailableOrPostponed { get; }
    internal bool HasTheHighestNumberOfMessagesAvailable { get; }
    internal abstract virtual bool get_IsDecliningPermanently();
    internal abstract virtual bool get_HasAtLeastOneMessageAvailable();
    internal abstract virtual bool get_HasAtLeastOnePostponedMessage();
    internal abstract virtual int get_NumberOfMessagesAvailableOrPostponed();
    internal abstract virtual bool get_HasTheHighestNumberOfMessagesAvailable();
    internal abstract virtual bool ReserveOneMessage();
    internal abstract virtual bool ConsumeReservedMessage();
    internal abstract virtual bool ConsumeOnePostponedMessage();
    internal abstract virtual void ReleaseReservedMessage();
    internal abstract virtual void ClearReservation();
    public sealed virtual void Complete();
    internal abstract virtual void CompleteCore(Exception exception, bool dropPendingMessages, bool releaseReservedMessages);
    internal abstract virtual void CompleteOncePossible();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.JoinBlockTargetSharedResources : object {
    internal IDataflowBlock _ownerJoin;
    internal JoinBlockTargetBase[] _targets;
    internal Action`1<Exception> _exceptionAction;
    internal Action _joinFilledAction;
    internal GroupingDataflowBlockOptions _dataflowBlockOptions;
    internal BoundingState _boundingState;
    internal bool _decliningPermanently;
    internal Task _taskForInputProcessing;
    internal bool _hasExceptions;
    internal long _joinsCreated;
    private bool _completionReserved;
    internal object IncomingLock { get; }
    internal bool AllTargetsHaveAtLeastOneMessage { get; }
    private bool TargetsHaveAtLeastOneMessageQueuedOrPostponed { get; }
    private bool CanceledOrFaulted { get; }
    internal bool JoinNeedsProcessing { get; }
    private object DebuggerDisplayContent { get; }
    internal JoinBlockTargetSharedResources(IDataflowBlock ownerJoin, JoinBlockTargetBase[] targets, Action joinFilledAction, Action`1<Exception> exceptionAction, GroupingDataflowBlockOptions dataflowBlockOptions);
    internal object get_IncomingLock();
    internal void CompleteEachTarget();
    internal bool get_AllTargetsHaveAtLeastOneMessage();
    private bool get_TargetsHaveAtLeastOneMessageQueuedOrPostponed();
    private bool RetrievePostponedItemsNonGreedy();
    private bool RetrievePostponedItemsGreedyBounded();
    private bool get_CanceledOrFaulted();
    internal bool get_JoinNeedsProcessing();
    internal void ProcessAsyncIfNecessary(bool isReplacementReplica);
    private void ProcessAsyncIfNecessary_Slow(bool isReplacementReplica);
    internal void CompleteBlockIfPossible();
    private void ProcessMessagesLoopCore();
    internal void OnItemsRemoved(int numItemsRemoved);
    private object get_DebuggerDisplayContent();
}
internal class System.Threading.Tasks.Dataflow.Internal.PaddedInt64 : ValueType {
    internal long Value;
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.EnumerableDebugView`2")]
internal class System.Threading.Tasks.Dataflow.Internal.QueuedMap`2 : object {
    private ArrayBasedLinkedQueue`1<TKey, TValue, KeyValuePair`2<TKey, TValue>> _queue;
    private Dictionary`2<TKey, int> _mapKeyToIndex;
    internal int Count { get; }
    internal QueuedMap`2(int capacity);
    internal void Push(TKey key, TValue value);
    internal bool TryPop(KeyValuePair`2& item);
    internal int PopRange(KeyValuePair`2[] items, int arrayOffset, int count);
    internal int get_Count();
}
[DebuggerDisplayAttribute("Count={CountForDebugging}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.ReorderingBuffer`1/DebugView")]
internal class System.Threading.Tasks.Dataflow.Internal.ReorderingBuffer`1 : object {
    private object _owningSource;
    private Dictionary`2<long, KeyValuePair`2<bool, TOutput>> _reorderingBuffer;
    private Action`2<object, TOutput> _outputAction;
    private long _nextReorderedIdToOutput;
    private object ValueLock { get; }
    private int CountForDebugging { get; }
    internal ReorderingBuffer`1(object owningSource, Action`2<object, TOutput> outputAction);
    private object get_ValueLock();
    internal void AddItem(long id, TOutput item, bool itemIsValid);
    internal bool IsNext(long id);
    internal Nullable`1<bool> AddItemIfNextAndTrusted(long id, TOutput item, bool isTrusted);
    public sealed virtual void IgnoreItem(long id);
    private void OutputNextItem(TOutput theNextItem, bool itemIsValid);
    private int get_CountForDebugging();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.SourceCore`1 : object {
    private TaskCompletionSource`1<VoidResult> _completionTask;
    private TargetRegistry`1<TOutput> _targetRegistry;
    private SingleProducerSingleConsumerQueue`1<TOutput> _messages;
    private ISourceBlock`1<TOutput> _owningSource;
    private DataflowBlockOptions _dataflowBlockOptions;
    private Action`1<ISourceBlock`1<TOutput>> _completeAction;
    private Action`2<ISourceBlock`1<TOutput>, int> _itemsRemovedAction;
    private Func`4<ISourceBlock`1<TOutput>, TOutput, IList`1<TOutput>, int> _itemCountingFunc;
    private Task _taskForOutputProcessing;
    private PaddedInt64 _nextMessageId;
    private ITargetBlock`1<TOutput> _nextMessageReservedFor;
    private bool _decliningPermanently;
    private bool _enableOffering;
    private bool _completionReserved;
    private List`1<Exception> _exceptions;
    private object OutgoingLock { get; }
    private object ValueLock { get; }
    internal Task Completion { get; }
    internal int OutputCount { get; }
    internal bool HasExceptions { get; }
    internal DataflowBlockOptions DataflowBlockOptions { get; }
    private bool CanceledOrFaulted { get; }
    private object DebuggerDisplayContent { get; }
    internal SourceCore`1(ISourceBlock`1<TOutput> owningSource, DataflowBlockOptions dataflowBlockOptions, Action`1<ISourceBlock`1<TOutput>> completeAction, Action`2<ISourceBlock`1<TOutput>, int> itemsRemovedAction, Func`4<ISourceBlock`1<TOutput>, TOutput, IList`1<TOutput>, int> itemCountingFunc);
    private object get_OutgoingLock();
    private object get_ValueLock();
    internal IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    internal TOutput ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    internal bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    internal void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    internal Task get_Completion();
    internal bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    internal bool TryReceiveAll(IList`1& items);
    internal int get_OutputCount();
    internal void AddMessage(TOutput item);
    internal void AddMessages(IEnumerable`1<TOutput> items);
    internal void AddException(Exception exception);
    internal void AddExceptions(List`1<Exception> exceptions);
    internal void AddAndUnwrapAggregateException(AggregateException aggregateException);
    internal bool get_HasExceptions();
    internal void Complete();
    internal DataflowBlockOptions get_DataflowBlockOptions();
    private bool OfferToTargets(ITargetBlock`1<TOutput> linkToTarget);
    private bool OfferMessageToTarget(DataflowMessageHeader header, TOutput message, ITargetBlock`1<TOutput> target, Boolean& messageWasAccepted);
    private void OfferAsyncIfNecessaryWithValueLock();
    private void OfferAsyncIfNecessary(bool isReplacementReplica, bool outgoingLockKnownAcquired);
    private void OfferAsyncIfNecessary_Slow(bool isReplacementReplica, bool outgoingLockKnownAcquired);
    private void OfferMessagesLoopCore();
    private bool get_CanceledOrFaulted();
    private void CompleteBlockIfPossible();
    private void CompleteBlockIfPossible_Slow();
    private void CompleteBlockOncePossible();
    private object get_DebuggerDisplayContent();
    internal DebuggingInformation<TOutput> GetDebuggingInformation();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.SpscTargetCore`1 : object {
    private ITargetBlock`1<TInput> _owningTarget;
    private SingleProducerSingleConsumerQueue`1<TInput> _messages;
    private ExecutionDataflowBlockOptions _dataflowBlockOptions;
    private Action`1<TInput> _action;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) _exceptions;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _decliningPermanently;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _completionReserved;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _activeConsumer;
    private TaskCompletionSource`1<VoidResult> _completionTask;
    internal int InputCount { get; }
    internal Task Completion { get; }
    private TaskCompletionSource`1<VoidResult> CompletionSource { get; }
    internal ExecutionDataflowBlockOptions DataflowBlockOptions { get; }
    private object DebuggerDisplayContent { get; }
    internal SpscTargetCore`1(ITargetBlock`1<TInput> owningTarget, Action`1<TInput> action, ExecutionDataflowBlockOptions dataflowBlockOptions);
    internal bool Post(TInput messageValue);
    internal DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private DataflowMessageStatus OfferMessage_Slow(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private void ScheduleConsumerIfNecessary(bool isReplica);
    private void ProcessMessagesLoopCore();
    internal int get_InputCount();
    internal void Complete(Exception exception);
    private void StoreException(Exception exception);
    private void CompleteBlockOncePossible();
    internal Task get_Completion();
    private TaskCompletionSource`1<VoidResult> get_CompletionSource();
    internal ExecutionDataflowBlockOptions get_DataflowBlockOptions();
    internal DebuggingInformation<TInput> GetDebuggingInformation();
    private object get_DebuggerDisplayContent();
}
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
internal class System.Threading.Tasks.Dataflow.Internal.TargetCore`1 : object {
    private static KeepAlivePredicate`2<TargetCore`1<TInput>, KeyValuePair`2<TInput, long>> _keepAlivePredicate;
    private TaskCompletionSource`1<VoidResult> _completionSource;
    private ITargetBlock`1<TInput> _owningTarget;
    private IProducerConsumerQueue`1<KeyValuePair`2<TInput, long>> _messages;
    private ExecutionDataflowBlockOptions _dataflowBlockOptions;
    private Action`1<KeyValuePair`2<TInput, long>> _callAction;
    private TargetCoreOptions _targetCoreOptions;
    private BoundingStateWithPostponed`1<TInput> _boundingState;
    private IReorderingBuffer _reorderingBuffer;
    private List`1<Exception> _exceptions;
    private bool _decliningPermanently;
    private int _numberOfOutstandingOperations;
    private int _numberOfOutstandingServiceTasks;
    private PaddedInt64 _nextAvailableInputMessageId;
    private bool _completionReserved;
    private int _keepAliveBanCounter;
    private object IncomingLock { get; }
    internal Task Completion { get; }
    internal int InputCount { get; }
    private bool UsesAsyncCompletion { get; }
    private bool HasRoomForMoreOperations { get; }
    private bool HasRoomForMoreServiceTasks { get; }
    private bool CanceledOrFaulted { get; }
    internal bool IsBounded { get; }
    private object DebuggerDisplayContent { get; }
    internal ExecutionDataflowBlockOptions DataflowBlockOptions { get; }
    internal TargetCore`1(ITargetBlock`1<TInput> owningTarget, Action`1<KeyValuePair`2<TInput, long>> callAction, IReorderingBuffer reorderingBuffer, ExecutionDataflowBlockOptions dataflowBlockOptions, TargetCoreOptions targetCoreOptions);
    private static TargetCore`1();
    private object get_IncomingLock();
    internal void Complete(Exception exception, bool dropPendingMessages, bool storeExceptionEvenIfAlreadyCompleting, bool unwrapInnerExceptions, bool revertProcessingState);
    internal DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    internal Task get_Completion();
    internal int get_InputCount();
    internal void SignalOneAsyncMessageCompleted();
    internal void SignalOneAsyncMessageCompleted(int boundingCountChange);
    private bool get_UsesAsyncCompletion();
    private bool get_HasRoomForMoreOperations();
    private bool get_HasRoomForMoreServiceTasks();
    private void ProcessAsyncIfNecessary(bool repeat);
    private void ProcessAsyncIfNecessary_Slow(bool repeat);
    private void ProcessMessagesLoopCore();
    private bool TryGetNextMessageForNewAsyncOperation(KeyValuePair`2& messageWithId);
    private bool TryGetNextAvailableOrPostponedMessage(KeyValuePair`2& messageWithId);
    private bool TryConsumePostponedMessage(bool forPostponementTransfer, KeyValuePair`2& result);
    private bool get_CanceledOrFaulted();
    private void CompleteBlockIfPossible();
    private void CompleteBlockIfPossible_Slow();
    private void CompleteBlockOncePossible();
    internal bool get_IsBounded();
    internal void ChangeBoundingCount(int count);
    private object get_DebuggerDisplayContent();
    internal ExecutionDataflowBlockOptions get_DataflowBlockOptions();
    internal DebuggingInformation<TInput> GetDebuggingInformation();
    [CompilerGeneratedAttribute]
private void <ProcessAsyncIfNecessary_Slow>b__34_1(object exc);
}
[FlagsAttribute]
internal enum System.Threading.Tasks.Dataflow.Internal.TargetCoreOptions : Enum {
    public byte value__;
    public static TargetCoreOptions None;
    public static TargetCoreOptions UsesAsyncCompletion;
    public static TargetCoreOptions RepresentsBlockCompletion;
}
[DebuggerDisplayAttribute("Count={Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.Internal.TargetRegistry`1/DebugView")]
internal class System.Threading.Tasks.Dataflow.Internal.TargetRegistry`1 : object {
    private ISourceBlock`1<T> _owningSource;
    private Dictionary`2<ITargetBlock`1<T>, LinkedTargetInfo<T>> _targetInformation;
    private LinkedTargetInfo<T> _firstTarget;
    private LinkedTargetInfo<T> _lastTarget;
    private int _linksWithRemainingMessages;
    internal LinkedTargetInfo<T> FirstTargetNode { get; }
    private int Count { get; }
    private ITargetBlock`1[] TargetsForDebugger { get; }
    internal TargetRegistry`1(ISourceBlock`1<T> owningSource);
    internal void Add(ITargetBlock`1& target, DataflowLinkOptions linkOptions);
    internal bool Contains(ITargetBlock`1<T> target);
    internal void Remove(ITargetBlock`1<T> target, bool onlyIfReachedMaxMessages);
    private void Remove_Slow(ITargetBlock`1<T> target, bool onlyIfReachedMaxMessages);
    internal LinkedTargetInfo<T> ClearEntryPoints();
    internal void PropagateCompletion(LinkedTargetInfo<T> firstTarget);
    internal LinkedTargetInfo<T> get_FirstTargetNode();
    internal void AddToList(LinkedTargetInfo<T> node, bool append);
    internal void RemoveFromList(LinkedTargetInfo<T> node);
    private int get_Count();
    private ITargetBlock`1[] get_TargetsForDebugger();
}
[DebuggerNonUserCodeAttribute]
internal class System.Threading.Tasks.Dataflow.Internal.VoidResult : ValueType {
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Dataflow.IPropagatorBlock`2 {
}
public interface System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1 {
    [NullableContextAttribute("1")]
public abstract virtual bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    public abstract virtual bool TryReceiveAll(IList`1& items);
}
[NullableContextAttribute("1")]
public interface System.Threading.Tasks.Dataflow.ISourceBlock`1 {
    public abstract virtual IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    public abstract virtual TOutput ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    public abstract virtual bool ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    public abstract virtual void ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
}
public interface System.Threading.Tasks.Dataflow.ITargetBlock`1 {
    [NullableContextAttribute("1")]
public abstract virtual DataflowMessageStatus OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.JoinBlock`2/DebugView")]
public class System.Threading.Tasks.Dataflow.JoinBlock`2 : object {
    private JoinBlockTargetSharedResources _sharedResources;
    private SourceCore`1<Tuple`2<T1, T2>> _source;
    private JoinBlockTarget`1<T1> _target1;
    private JoinBlockTarget`1<T2> _target2;
    public int OutputCount { get; }
    public Task Completion { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public JoinBlock`2(GroupingDataflowBlockOptions dataflowBlockOptions);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`2<T1, T2>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`2<T1, T2>> filter, Tuple`2& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    private sealed virtual override Tuple`2<T1, T2> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<T1, T2>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<T1, T2>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`2<T1, T2>> target);
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_3(Exception exception);
    [CompilerGeneratedAttribute]
private void <.ctor>b__5_4(Task[] _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.JoinBlock`3/DebugView")]
public class System.Threading.Tasks.Dataflow.JoinBlock`3 : object {
    private JoinBlockTargetSharedResources _sharedResources;
    private SourceCore`1<Tuple`3<T1, T2, T3>> _source;
    private JoinBlockTarget`1<T1> _target1;
    private JoinBlockTarget`1<T2> _target2;
    private JoinBlockTarget`1<T3> _target3;
    public int OutputCount { get; }
    public Task Completion { get; }
    public ITargetBlock`1<T1> Target1 { get; }
    public ITargetBlock`1<T2> Target2 { get; }
    public ITargetBlock`1<T3> Target3 { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public JoinBlock`3(GroupingDataflowBlockOptions dataflowBlockOptions);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<Tuple`3<T1, T2, T3>> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<Tuple`3<T1, T2, T3>> filter, Tuple`3& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public int get_OutputCount();
    public sealed virtual Task get_Completion();
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public ITargetBlock`1<T1> get_Target1();
    public ITargetBlock`1<T2> get_Target2();
    public ITargetBlock`1<T3> get_Target3();
    private sealed virtual override Tuple`3<T1, T2, T3> System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<T1, T2, T3>> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<T1, T2, T3>> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<System.Tuple<T1,T2,T3>>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<Tuple`3<T1, T2, T3>> target);
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_2();
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_3(Exception exception);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_4(Task[] _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.TransformBlock`2/DebugView")]
public class System.Threading.Tasks.Dataflow.TransformBlock`2 : object {
    private TargetCore`1<TInput> _target;
    private ReorderingBuffer`1<TOutput> _reorderingBuffer;
    private SourceCore`1<TOutput> _source;
    private object ParallelSourceLock { get; }
    public Task Completion { get; }
    public int InputCount { get; }
    public int OutputCount { get; }
    private int InputCountForDebugger { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public TransformBlock`2(Func`2<TInput, TOutput> transform);
    public TransformBlock`2(Func`2<TInput, TOutput> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    public TransformBlock`2(Func`2<TInput, Task`1<TOutput>> transform);
    public TransformBlock`2(Func`2<TInput, Task`1<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private TransformBlock`2(Func`2<TInput, TOutput> transformSync, Func`2<TInput, Task`1<TOutput>> transformAsync, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private object get_ParallelSourceLock();
    private void ProcessMessage(Func`2<TInput, TOutput> transform, KeyValuePair`2<TInput, long> messageWithId);
    private void ProcessMessageWithTask(Func`2<TInput, Task`1<TOutput>> transform, KeyValuePair`2<TInput, long> messageWithId);
    private void AsyncCompleteProcessMessageWithTask(Task`1<TOutput> completed, KeyValuePair`2<TInput, long> messageWithId);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public sealed virtual Task get_Completion();
    public int get_InputCount();
    public int get_OutputCount();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private sealed virtual override TOutput System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private int get_InputCountForDebugger();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.TransformManyBlock`2/DebugView")]
public class System.Threading.Tasks.Dataflow.TransformManyBlock`2 : object {
    private TargetCore`1<TInput> _target;
    private ReorderingBuffer`1<IEnumerable`1<TOutput>> _reorderingBuffer;
    private SourceCore`1<TOutput> _source;
    private object ParallelSourceLock { get; }
    public Task Completion { get; }
    public int InputCount { get; }
    public int OutputCount { get; }
    private int InputCountForDebugger { get; }
    private int OutputCountForDebugger { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public TransformManyBlock`2(Func`2<TInput, IEnumerable`1<TOutput>> transform);
    public TransformManyBlock`2(Func`2<TInput, IEnumerable`1<TOutput>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    public TransformManyBlock`2(Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> transform);
    public TransformManyBlock`2(Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> transform, ExecutionDataflowBlockOptions dataflowBlockOptions);
    private object get_ParallelSourceLock();
    private void Initialize(Action`1<KeyValuePair`2<TInput, long>> processMessageAction, ExecutionDataflowBlockOptions dataflowBlockOptions, SourceCore`1& source, TargetCore`1& target, ReorderingBuffer`1& reorderingBuffer, TargetCoreOptions targetCoreOptions);
    private void ProcessMessage(Func`2<TInput, IEnumerable`1<TOutput>> transformFunction, KeyValuePair`2<TInput, long> messageWithId);
    private void ProcessMessageWithTask(Func`2<TInput, Task`1<IEnumerable`1<TOutput>>> function, KeyValuePair`2<TInput, long> messageWithId);
    private void AsyncCompleteProcessMessageWithTask(Task`1<IEnumerable`1<TOutput>> completed, KeyValuePair`2<TInput, long> messageWithId);
    private void StoreOutputItems(KeyValuePair`2<TInput, long> messageWithId, IEnumerable`1<TOutput> outputItems);
    private void StoreOutputItemsReordered(long id, IEnumerable`1<TOutput> item);
    private void StoreOutputItemsNonReorderedAtomic(IEnumerable`1<TOutput> outputItems);
    private void StoreOutputItemsNonReorderedWithIteration(IEnumerable`1<TOutput> outputItems);
    private void UpdateBoundingCountWithOutputCount(int count);
    public sealed virtual void Complete();
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<TOutput> target, DataflowLinkOptions linkOptions);
    public sealed virtual bool TryReceive(Predicate`1<TOutput> filter, TOutput& item);
    public sealed virtual bool TryReceiveAll(IList`1& items);
    public sealed virtual Task get_Completion();
    public int get_InputCount();
    public int get_OutputCount();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<TInput>.OfferMessage(DataflowMessageHeader messageHeader, TInput messageValue, ISourceBlock`1<TInput> source, bool consumeToAccept);
    private sealed virtual override TOutput System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<TOutput>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<TOutput> target);
    private int get_InputCountForDebugger();
    private int get_OutputCountForDebugger();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplayContent,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.Dataflow.WriteOnceBlock`1/DebugView")]
public class System.Threading.Tasks.Dataflow.WriteOnceBlock`1 : object {
    private TargetRegistry`1<T> _targetRegistry;
    private Func`2<T, T> _cloningFunction;
    private DataflowBlockOptions _dataflowBlockOptions;
    private TaskCompletionSource`1<VoidResult> _lazyCompletionTaskSource;
    private bool _decliningPermanently;
    private bool _completionReserved;
    private DataflowMessageHeader _header;
    private T _value;
    private object ValueLock { get; }
    public Task Completion { get; }
    private TaskCompletionSource`1<VoidResult> CompletionTaskSource { get; }
    private bool HasValue { get; }
    [NullableAttribute("2")]
private T Value { get; }
    private object DebuggerDisplayContent { get; }
    private object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.Content { get; }
    public WriteOnceBlock`1(Func`2<T, T> cloningFunction);
    public WriteOnceBlock`1(Func`2<T, T> cloningFunction, DataflowBlockOptions dataflowBlockOptions);
    private object get_ValueLock();
    private void CompleteBlockAsync(IList`1<Exception> exceptions);
    private void OfferToTargetsAndCompleteBlock();
    private void CompleteBlock(IList`1<Exception> exceptions);
    private sealed virtual override void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception exception);
    public sealed virtual void Complete();
    private void CompleteCore(Exception exception, bool storeExceptionEvenIfAlreadyCompleting);
    public sealed virtual bool TryReceive(Predicate`1<T> filter, T& item);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.IReceivableSourceBlock<T>.TryReceiveAll(IList`1& items);
    public sealed virtual IDisposable LinkTo(ITargetBlock`1<T> target, DataflowLinkOptions linkOptions);
    public sealed virtual Task get_Completion();
    private sealed virtual override DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock<T>.OfferMessage(DataflowMessageHeader messageHeader, T messageValue, ISourceBlock`1<T> source, bool consumeToAccept);
    private sealed virtual override T System.Threading.Tasks.Dataflow.ISourceBlock<T>.ConsumeMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target, Boolean& messageConsumed);
    private sealed virtual override bool System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReserveMessage(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private sealed virtual override void System.Threading.Tasks.Dataflow.ISourceBlock<T>.ReleaseReservation(DataflowMessageHeader messageHeader, ITargetBlock`1<T> target);
    private T CloneItem(T item);
    private List`1<Exception> OfferToTargets();
    private TaskCompletionSource`1<VoidResult> get_CompletionTaskSource();
    private bool get_HasValue();
    private T get_Value();
    public virtual string ToString();
    private object get_DebuggerDisplayContent();
    private sealed virtual override object System.Threading.Tasks.Dataflow.Internal.IDebuggerDisplay.get_Content();
}
internal interface System.Threading.Tasks.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Threading.Tasks.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Threading.Tasks.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Threading.Tasks.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Threading.Tasks.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Threading.Tasks.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Threading.Tasks.SingleProducerSingleConsumerQueue`1 : object {
    private static int INIT_SEGMENT_SIZE;
    private static int MAX_SEGMENT_SIZE;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    private bool TryDequeueSlow(Segment& segment, T[]& array, T& result);
    public bool TryPeek(T& result);
    private bool TryPeekSlow(Segment& segment, T[]& array, T& result);
    public bool TryDequeueIf(Predicate`1<T> predicate, T& result);
    private bool TryDequeueIfSlow(Predicate`1<T> predicate, Segment& segment, T[]& array, T& result);
    public void Clear();
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Threading.Tasks.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Threading.Tasks.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
