internal class Microsoft.Build.BackEnd.AssemblyTaskFactory : object {
    private TypeLoader _typeLoader;
    private string _taskName;
    private LoadedType _loadedType;
    private Dictionary`2<ITask, AppDomain> _tasksAndAppDomains;
    private IDictionary`2<string, string> _factoryIdentityParameters;
    private bool _taskHostFactoryExplicitlyRequested;
    private TaskLoggingContext _taskLoggingContext;
    public string FactoryName { get; }
    public Type TaskType { get; }
    public sealed virtual string get_FactoryName();
    public sealed virtual Type get_TaskType();
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost, IDictionary`2<string, string> taskIdentityParameters);
    public sealed virtual void CleanupTask(ITask task);
    internal LoadedType InitializeFactory(AssemblyLoadInfo loadInfo, string taskName, IDictionary`2<string, TaskPropertyInfo> taskParameters, string taskElementContents, IDictionary`2<string, string> taskFactoryIdentityParameters, bool taskHostFactoryExplicitlyRequested, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation, string taskProjectFile);
    internal ITask CreateTaskInstance(ElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary`2<string, string> taskIdentityParameters, AppDomainSetup appDomainSetup, bool isOutOfProc);
    internal bool TaskNameCreatableByFactory(string taskName, IDictionary`2<string, string> taskIdentityParameters, string taskProjectFile, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    private static void VerifyThrowIdentityParametersValid(IDictionary`2<string, string> identityParameters, IElementLocation errorLocation, string taskName, string runtimeName, string architectureName);
    private static bool TaskIdentityParametersMatchFactory(IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, string> taskIdentityParameters);
    private static IDictionary`2<string, string> MergeTaskFactoryParameterSets(IDictionary`2<string, string> factoryIdentityParameters, IDictionary`2<string, string> taskIdentityParameters);
    private static bool TaskHostParametersMatchCurrentProcess(IDictionary`2<string, string> mergedParameters);
    private void ErrorLoggingDelegate(string taskLocation, int taskLine, int taskColumn, string message, Object[] messageArgs);
}
internal static class Microsoft.Build.BackEnd.BatchingEngine : object {
    internal static List`1<ItemBucket> PrepareBatchingBuckets(List`1<string> batchableObjectParameters, Lookup lookup, ElementLocation elementLocation);
    internal static List`1<ItemBucket> PrepareBatchingBuckets(List`1<string> batchableObjectParameters, Lookup lookup, string implicitBatchableItemType, ElementLocation elementLocation);
    private static Dictionary`2<string, ICollection`1<ProjectItemInstance>> GetItemListsToBeBatched(Dictionary`2<string, MetadataReference> consumedMetadataReferences, HashSet`1<string> consumedItemReferenceNames, Lookup lookup, ElementLocation elementLocation);
    private static List`1<ItemBucket> BucketConsumedItems(Lookup lookup, Dictionary`2<string, ICollection`1<ProjectItemInstance>> itemListsToBeBatched, Dictionary`2<string, MetadataReference> consumedMetadataReferences, ElementLocation elementLocation);
    private static Dictionary`2<string, string> GetItemMetadataValues(ProjectItemInstance item, Dictionary`2<string, MetadataReference> consumedMetadataReferences, ElementLocation elementLocation);
}
internal class Microsoft.Build.BackEnd.BufferedReadStream : Stream {
    private static int BUFFER_SIZE;
    private Stream _innerStream;
    private Byte[] _buffer;
    private int _currentlyBufferedByteCount;
    private int _currentIndexInBuffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedReadStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.BuildComponentFactoryCollection : object {
    private Dictionary`2<BuildComponentType, BuildComponentEntry> _componentEntriesByType;
    private IBuildComponentHost _host;
    public BuildComponentFactoryCollection(IBuildComponentHost host);
    public void RegisterDefaultFactories();
    public void ShutdownComponents();
    public void ShutdownComponent(BuildComponentType componentType);
    public void ReplaceFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory);
    public void ReplaceFactory(BuildComponentType componentType, IBuildComponent instance);
    public void AddFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory, CreationPattern creationPattern);
    public IBuildComponent GetComponent(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.BuildComponentFactoryDelegate : MulticastDelegate {
    public BuildComponentFactoryDelegate(object object, IntPtr method);
    public virtual IBuildComponent Invoke(BuildComponentType type);
    public virtual IAsyncResult BeginInvoke(BuildComponentType type, AsyncCallback callback, object object);
    public virtual IBuildComponent EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.BuildComponentType : Enum {
    public int value__;
    public static BuildComponentType RequestManager;
    public static BuildComponentType Scheduler;
    public static BuildComponentType ResultsCache;
    public static BuildComponentType PropertyCache;
    public static BuildComponentType ConfigCache;
    public static BuildComponentType NodeManager;
    public static BuildComponentType InProcNodeProvider;
    public static BuildComponentType OutOfProcNodeProvider;
    public static BuildComponentType RemoteNodeProvider;
    public static BuildComponentType NodePacketFactory;
    public static BuildComponentType RequestEngine;
    public static BuildComponentType FileMonitor;
    public static BuildComponentType NodeEndpoint;
    public static BuildComponentType LoggingService;
    public static BuildComponentType RequestBuilder;
    public static BuildComponentType TargetBuilder;
    public static BuildComponentType TaskBuilder;
    public static BuildComponentType TestDataProvider;
    public static BuildComponentType OutOfProcTaskHostNodeProvider;
    public static BuildComponentType TaskHostNodeManager;
    public static BuildComponentType RegisteredTaskObjectCache;
    public static BuildComponentType SdkResolverService;
    public static BuildComponentType FileAccessManager;
    public static BuildComponentType NodeLauncher;
}
internal class Microsoft.Build.BackEnd.BuildRequest : object {
    public static int InvalidGlobalRequestId;
    public static int InvalidNodeRequestId;
    public static int ResultsTransferNodeRequestId;
    private int _submissionId;
    private int _configurationId;
    private int _projectContextId;
    private int _globalRequestId;
    private int _parentGlobalRequestId;
    private int _nodeRequestId;
    private List`1<string> _targets;
    private ProxyTargets _proxyTargets;
    private BuildEventContext _parentBuildEventContext;
    private BuildEventContext _buildEventContext;
    private BuildRequestDataFlags _buildRequestDataFlags;
    private RequestedProjectState _requestedProjectState;
    private bool _skipStaticGraphIsolationConstraints;
    [CompilerGeneratedAttribute]
private BuildEventContext <CurrentTaskContext>k__BackingField;
    private HostServices _hostServices;
    public bool IsConfigurationResolved { get; }
    public int SubmissionId { get; }
    public int ConfigurationId { get; }
    public int ProjectContextId { get; }
    public int GlobalRequestId { get; public set; }
    public int ParentGlobalRequestId { get; }
    public int NodeRequestId { get; public set; }
    public List`1<string> Targets { get; }
    public ProxyTargets ProxyTargets { get; }
    public NodePacketType Type { get; }
    public BuildEventContext ParentBuildEventContext { get; }
    public BuildEventContext BuildEventContext { get; public set; }
    public BuildEventContext CurrentTaskContext { get; public set; }
    public BuildRequestDataFlags BuildRequestDataFlags { get; public set; }
    public RequestedProjectState RequestedProjectState { get; public set; }
    internal HostServices HostServices { get; internal set; }
    internal bool IsRootRequest { get; }
    internal bool SkipStaticGraphIsolationConstraints { get; }
    private BuildRequest(int submissionId, int nodeRequestId, int configurationId, HostServices hostServices, BuildRequestDataFlags buildRequestDataFlags, RequestedProjectState requestedProjectState, int projectContextId);
    public BuildRequest(int submissionId, int nodeRequestId, int configurationId, ProxyTargets proxyTargets, HostServices hostServices, BuildRequestDataFlags buildRequestDataFlags, RequestedProjectState requestedProjectState, int projectContextId);
    public BuildRequest(int submissionId, int nodeRequestId, int configurationId, ICollection`1<string> escapedTargets, HostServices hostServices, BuildEventContext parentBuildEventContext, BuildRequest parentRequest, BuildRequestDataFlags buildRequestDataFlags, RequestedProjectState requestedProjectState, bool skipStaticGraphIsolationConstraints, int projectContextId);
    private BuildRequest(ITranslator translator);
    [DebuggerStepThroughAttribute]
public bool get_IsConfigurationResolved();
    [DebuggerStepThroughAttribute]
public int get_SubmissionId();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public int get_ProjectContextId();
    [DebuggerStepThroughAttribute]
public int get_GlobalRequestId();
    public void set_GlobalRequestId(int value);
    [DebuggerStepThroughAttribute]
public int get_ParentGlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_NodeRequestId();
    [DebuggerStepThroughAttribute]
public void set_NodeRequestId(int value);
    [DebuggerStepThroughAttribute]
public List`1<string> get_Targets();
    [DebuggerStepThroughAttribute]
public ProxyTargets get_ProxyTargets();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_ParentBuildEventContext();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_BuildEventContext();
    public void set_BuildEventContext(BuildEventContext value);
    [CompilerGeneratedAttribute]
public BuildEventContext get_CurrentTaskContext();
    [CompilerGeneratedAttribute]
public void set_CurrentTaskContext(BuildEventContext value);
    public BuildRequestDataFlags get_BuildRequestDataFlags();
    public void set_BuildRequestDataFlags(BuildRequestDataFlags value);
    public RequestedProjectState get_RequestedProjectState();
    public void set_RequestedProjectState(RequestedProjectState value);
    [DebuggerStepThroughAttribute]
internal HostServices get_HostServices();
    internal void set_HostServices(HostServices value);
    [DebuggerStepThroughAttribute]
internal bool get_IsRootRequest();
    internal bool get_SkipStaticGraphIsolationConstraints();
    public void ResolveConfiguration(int newConfigId);
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
    public bool IsProxyBuildRequest();
}
internal class Microsoft.Build.BackEnd.BuildRequestBlockedDelegate : MulticastDelegate {
    public BuildRequestBlockedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry issuingEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry issuingEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestBlocker : object {
    private YieldAction _yieldAction;
    private int _blockedGlobalRequestId;
    private String[] _targetsInProgress;
    private int _blockingGlobalRequestId;
    private string _blockingTarget;
    private BuildResult _partialBuildResult;
    private BuildRequest[] _buildRequests;
    public NodePacketType Type { get; }
    public int BlockedRequestId { get; }
    public String[] TargetsInProgress { get; }
    public int BlockingRequestId { get; }
    public string BlockingTarget { get; }
    public BuildRequest[] BuildRequests { get; }
    public YieldAction YieldAction { get; }
    public BuildResult PartialBuildResult { get; }
    internal BuildRequestBlocker(ITranslator translator);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, int blockingGlobalRequestId, string blockingTarget);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, BuildRequest[] buildRequests);
    internal BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress, YieldAction action);
    internal BuildRequestBlocker(int blockedGlobalRequestId);
    private BuildRequestBlocker(int blockedGlobalRequestId, String[] targetsInProgress);
    public BuildRequestBlocker(int requestGlobalRequestId, String[] targetsInProgress, int unsubmittedRequestBlockingGlobalRequestId, string unsubmittedRequestBlockingTarget, BuildResult partialBuildResult);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public int get_BlockedRequestId();
    [DebuggerStepThroughAttribute]
public String[] get_TargetsInProgress();
    [DebuggerStepThroughAttribute]
public int get_BlockingRequestId();
    [DebuggerStepThroughAttribute]
public string get_BlockingTarget();
    [DebuggerStepThroughAttribute]
public BuildRequest[] get_BuildRequests();
    [DebuggerStepThroughAttribute]
public YieldAction get_YieldAction();
    public BuildResult get_PartialBuildResult();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.BuildRequestCompletedDelegate : MulticastDelegate {
    public BuildRequestCompletedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry completedEntry);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry completedEntry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestConfiguration : object {
    public static int InvalidConfigurationId;
    private int _configId;
    private string _projectFullPath;
    private string _toolsVersion;
    private bool _explicitToolsVersionSpecified;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private Nullable`1<bool> _isTraversalProject;
    private object _syncLock;
    private ProjectInstance _project;
    private ProjectInstance _transferredState;
    private List`1<ProjectPropertyInstance> _transferredProperties;
    private List`1<string> _projectInitialTargets;
    private List`1<string> _projectDefaultTargets;
    private HashSet`1<string> _projectTargets;
    private Lookup _baseLookup;
    private Dictionary`2<string, int> _activelyBuildingTargets;
    private int _resultsNodeId;
    private Dictionary`2<string, string> _savedEnvironmentVariables;
    private string _savedCurrentDirectory;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <RequestedTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCacheable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitlyLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCached>k__BackingField;
    private Func`2<string, bool> shouldSkipStaticGraphIsolationOnReference;
    internal IReadOnlyCollection`1<string> RequestedTargets { get; }
    public bool IsCacheable { get; public set; }
    public bool ExplicitlyLoaded { get; public set; }
    public bool IsActivelyBuilding { get; }
    public bool IsLoaded { get; }
    public bool IsCached { get; private set; }
    public bool IsTraversal { get; }
    public bool WasGeneratedByNode { get; }
    public int ConfigurationId { get; public set; }
    public string ProjectFullPath { get; }
    public string ToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalProperties { get; }
    public ProjectInstance Project { get; public set; }
    public bool HasTargetsResolved { get; }
    public List`1<string> ProjectInitialTargets { get; public set; }
    public List`1<string> ProjectDefaultTargets { get; public set; }
    internal HashSet`1<string> ProjectTargets { get; internal set; }
    public NodePacketType Type { get; }
    public Lookup BaseLookup { get; }
    public Dictionary`2<string, int> ActivelyBuildingTargets { get; }
    public Dictionary`2<string, string> SavedEnvironmentVariables { get; public set; }
    public string SavedCurrentDirectory { get; public set; }
    public bool ExplicitToolsVersionSpecified { get; }
    internal int ResultsNodeId { get; internal set; }
    internal BuildRequestConfiguration(BuildRequestData data, string defaultToolsVersion);
    internal BuildRequestConfiguration(int configId, BuildRequestData data, string defaultToolsVersion);
    internal BuildRequestConfiguration(int configId, ProjectInstance instance);
    private BuildRequestConfiguration(int configId, BuildRequestConfiguration other);
    private BuildRequestConfiguration(ITranslator translator);
    [CompilerGeneratedAttribute]
internal IReadOnlyCollection`1<string> get_RequestedTargets();
    [CompilerGeneratedAttribute]
public bool get_IsCacheable();
    [CompilerGeneratedAttribute]
public void set_IsCacheable(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitlyLoaded();
    [CompilerGeneratedAttribute]
public void set_ExplicitlyLoaded(bool value);
    public bool get_IsActivelyBuilding();
    public bool get_IsLoaded();
    [CompilerGeneratedAttribute]
public bool get_IsCached();
    [CompilerGeneratedAttribute]
private void set_IsCached(bool value);
    public bool get_IsTraversal();
    public bool get_WasGeneratedByNode();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public void set_ConfigurationId(int value);
    public string get_ProjectFullPath();
    public string get_ToolsVersion();
    public PropertyDictionary`1<ProjectPropertyInstance> get_GlobalProperties();
    [DebuggerStepThroughAttribute]
public ProjectInstance get_Project();
    [DebuggerStepThroughAttribute]
public void set_Project(ProjectInstance value);
    private void SetProjectBasedState(ProjectInstance project);
    internal void LoadProjectIntoConfiguration(IBuildComponentHost componentHost, BuildRequestDataFlags buildRequestDataFlags, int submissionId, int nodeId);
    private void InitializeProject(BuildParameters buildParameters, Func`1<ProjectInstance> loadProjectFromFile);
    internal void CreateUniqueGlobalProperty();
    public bool get_HasTargetsResolved();
    public List`1<string> get_ProjectInitialTargets();
    [DebuggerStepThroughAttribute]
public void set_ProjectInitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public List`1<string> get_ProjectDefaultTargets();
    [DebuggerStepThroughAttribute]
public void set_ProjectDefaultTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal HashSet`1<string> get_ProjectTargets();
    [DebuggerStepThroughAttribute]
internal void set_ProjectTargets(HashSet`1<string> value);
    public sealed virtual NodePacketType get_Type();
    public Lookup get_BaseLookup();
    public Dictionary`2<string, int> get_ActivelyBuildingTargets();
    public Dictionary`2<string, string> get_SavedEnvironmentVariables();
    public void set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    public string get_SavedCurrentDirectory();
    public void set_SavedCurrentDirectory(string value);
    public bool get_ExplicitToolsVersionSpecified();
    internal int get_ResultsNodeId();
    internal void set_ResultsNodeId(int value);
    public static bool op_Equality(BuildRequestConfiguration left, BuildRequestConfiguration right);
    public static bool op_Inequality(BuildRequestConfiguration left, BuildRequestConfiguration right);
    public void CacheIfPossible();
    public void RetrieveFromCache();
    public List`1<string> GetTargetsUsedToBuildRequest(BuildRequest request);
    public bool ShouldSkipIsolationConstraintsForReference(string referenceFullPath);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BuildRequestConfiguration other);
    public sealed virtual void Translate(ITranslator translator);
    internal void TranslateForFutureUse(ITranslator translator);
    internal static BuildRequestConfiguration FactoryForDeserialization(ITranslator translator);
    internal void ApplyTransferredState(ProjectInstance instance);
    internal string GetCacheFile();
    internal void ClearCacheFile();
    internal BuildRequestConfiguration ShallowCloneWithNewId(int newId);
    private bool InternalEquals(BuildRequestConfiguration other);
    private HashSet`1<string> GetProjectTargets(IDictionary`2<string, ProjectTargetInstance> projectTargets);
    private static string ResolveToolsVersion(BuildRequestData data, string defaultToolsVersion);
    private ITranslator GetConfigurationTranslator(TranslationDirection direction);
    [CompilerGeneratedAttribute]
private Func`2<string, bool> <ShouldSkipIsolationConstraintsForReference>g__GetReferenceFilter|98_0();
    [CompilerGeneratedAttribute]
private MSBuildGlob <ShouldSkipIsolationConstraintsForReference>b__98_4(string s);
}
internal class Microsoft.Build.BackEnd.BuildRequestConfigurationResponse : object {
    private int _nodeConfigId;
    private int _globalConfigId;
    private int _resultsNodeId;
    public int NodeConfigurationId { get; }
    public int GlobalConfigurationId { get; }
    public int ResultsNodeId { get; }
    public NodePacketType Type { get; }
    public BuildRequestConfigurationResponse(int nodeConfigId, int globalConfigId, int resultsNodeId);
    private BuildRequestConfigurationResponse(ITranslator translator);
    public int get_NodeConfigurationId();
    public int get_GlobalConfigurationId();
    public int get_ResultsNodeId();
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.BuildRequestEngine : object {
    private static int StartingUnresolvedConfigId;
    private static int StartingBuildRequestId;
    private BuildRequestEngineStatus _status;
    private IBuildComponentHost _componentHost;
    private ActionBlock`1<Action> _workQueue;
    private List`1<BuildRequestEntry> _requests;
    private Dictionary`2<int, BuildRequestEntry> _requestsByGlobalRequestId;
    private Queue`1<PendingUnsubmittedBuildRequests> _unsubmittedRequests;
    private int _nextUnresolvedConfigurationId;
    private int _nextBuildRequestId;
    private IConfigCache _configCache;
    private IConfigCache _unresolvedConfigurations;
    private NodeLoggingContext _nodeLoggingContext;
    private bool _debugDumpState;
    private string _debugDumpPath;
    private bool _debugForceCaching;
    [CompilerGeneratedAttribute]
private RequestCompleteDelegate OnRequestComplete;
    [CompilerGeneratedAttribute]
private RequestResumedDelegate OnRequestResumed;
    [CompilerGeneratedAttribute]
private RequestBlockedDelegate OnRequestBlocked;
    [CompilerGeneratedAttribute]
private EngineStatusChangedDelegate OnStatusChanged;
    [CompilerGeneratedAttribute]
private NewConfigurationRequestDelegate OnNewConfigurationRequest;
    [CompilerGeneratedAttribute]
private EngineExceptionDelegate OnEngineException;
    [CompilerGeneratedAttribute]
private ResourceRequestDelegate OnResourceRequest;
    public BuildRequestEngineStatus Status { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnEngineException(EngineExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnEngineException(EngineExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnResourceRequest(ResourceRequestDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnResourceRequest(ResourceRequestDelegate value);
    public sealed virtual BuildRequestEngineStatus get_Status();
    public sealed virtual void InitializeForBuild(NodeLoggingContext loggingContext);
    public sealed virtual void CleanupForBuild();
    public sealed virtual void SubmitBuildRequest(BuildRequest request);
    public sealed virtual void UnblockBuildRequest(BuildRequestUnblocker unblocker);
    public sealed virtual void GrantResources(ResourceResponse response);
    public sealed virtual void ReportConfigurationResponse(BuildRequestConfigurationResponse response);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private void BuildRequestEntry_StateChanged(BuildRequestEntry entry, BuildRequestEntryState newState);
    private void RaiseRequestComplete(BuildRequest request, BuildResult result);
    private void RaiseRequestResumed(BuildRequest request);
    private void RaiseEngineException(Exception e);
    private void RaiseRequestBlocked(BuildRequestBlocker blocker);
    private void RaiseEngineStatusChanged(BuildRequestEngineStatus newStatus);
    private void RaiseNewConfigurationRequest(BuildRequestConfiguration config);
    private void ChangeStatus(BuildRequestEngineStatus newStatus);
    private void EvaluateRequestStates();
    private void CheckMemoryUsage();
    private void ActivateBuildRequest(BuildRequestEntry entry);
    private IRequestBuilder GetRequestBuilder();
    private static void BeginDeactivateBuildRequest(BuildRequestEntry entry);
    private static void WaitForDeactivateCompletion(BuildRequestEntry entry);
    private void Builder_OnNewBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBuildRequest[] newRequests);
    private void Builder_OnBlockedRequest(BuildRequestEntry issuingEntry, int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    private void Builder_OnResourceRequest(ResourceRequest request);
    private void IssueUnsubmittedRequests();
    private void IssueBuildRequests(BuildRequestEntry issuingEntry, FullyQualifiedBuildRequest[] newRequests);
    private int GetNextUnresolvedConfigurationId();
    private int GetNextBuildRequestId();
    private void IssueConfigurationRequest(BuildRequestConfiguration config);
    private void IssueBuildRequest(BuildRequestBlocker blocker);
    private void QueueAction(Action action, bool isLastTask);
    private void TraceEngine(string format, Object[] stuff);
    [CompilerGeneratedAttribute]
private void <CleanupForBuild>b__41_0();
    [CompilerGeneratedAttribute]
private void <BuildRequestEntry_StateChanged>b__49_0();
}
internal enum Microsoft.Build.BackEnd.BuildRequestEngineStatus : Enum {
    public int value__;
    public static BuildRequestEngineStatus Uninitialized;
    public static BuildRequestEngineStatus Idle;
    public static BuildRequestEngineStatus Active;
    public static BuildRequestEngineStatus Waiting;
    public static BuildRequestEngineStatus Shutdown;
}
internal class Microsoft.Build.BackEnd.BuildRequestEntry : object {
    private Dictionary`2<int, List`1<BuildRequest>> _unresolvedConfigurations;
    private List`1<BuildRequest> _requestsToIssue;
    private List`1<BuildRequestConfiguration> _unresolvedConfigurationsToIssue;
    private Dictionary`2<int, BuildRequest> _outstandingRequests;
    private Dictionary`2<int, BuildResult> _outstandingResults;
    private int _blockingGlobalRequestId;
    private IRequestBuilder _requestBuilder;
    private string _projectRootDirectory;
    [CompilerGeneratedAttribute]
private BuildRequestEntryStateChangedDelegate OnStateChanged;
    [CompilerGeneratedAttribute]
private object <GlobalLock>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestEntryState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestConfiguration <RequestConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <Result>k__BackingField;
    public object GlobalLock { get; }
    public string ProjectRootDirectory { get; }
    public BuildRequestEntryState State { get; private set; }
    public BuildRequest Request { get; }
    public BuildRequestConfiguration RequestConfiguration { get; }
    public BuildResult Result { get; private set; }
    public IRequestBuilder Builder { get; public set; }
    internal BuildRequestEntry(BuildRequest request, BuildRequestConfiguration requestConfiguration);
    [CompilerGeneratedAttribute]
public void add_OnStateChanged(BuildRequestEntryStateChangedDelegate value);
    [CompilerGeneratedAttribute]
public void remove_OnStateChanged(BuildRequestEntryStateChangedDelegate value);
    [CompilerGeneratedAttribute]
public object get_GlobalLock();
    public string get_ProjectRootDirectory();
    [CompilerGeneratedAttribute]
public BuildRequestEntryState get_State();
    [CompilerGeneratedAttribute]
private void set_State(BuildRequestEntryState value);
    [CompilerGeneratedAttribute]
public BuildRequest get_Request();
    [CompilerGeneratedAttribute]
public BuildRequestConfiguration get_RequestConfiguration();
    [CompilerGeneratedAttribute]
public BuildResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(BuildResult value);
    [DebuggerStepThroughAttribute]
public IRequestBuilder get_Builder();
    [DebuggerStepThroughAttribute]
public void set_Builder(IRequestBuilder value);
    public void WaitForConfiguration(BuildRequestConfiguration configuration);
    public void WaitForResult(BuildRequest newRequest);
    public void WaitForBlockingRequest(int blockingGlobalRequestId);
    public bool ResolveConfigurationRequest(int unresolvedConfigId, int configId);
    public List`1<BuildRequest> GetRequestsToIssueIfReady();
    public List`1<BuildRequestConfiguration> GetUnresolvedConfigurationsToIssue();
    public String[] GetActiveTargets();
    public void ReportResult(BuildResult result);
    public void Unblock();
    public IDictionary`2<int, BuildResult> Continue();
    public void BeginCancel();
    public void WaitForCancelCompletion();
    public void Complete(BuildResult result);
    private void WaitForResult(BuildRequest newRequest, bool addToIssueList);
    private void ChangeState(BuildRequestEntryState newState);
}
internal enum Microsoft.Build.BackEnd.BuildRequestEntryState : Enum {
    public int value__;
    public static BuildRequestEntryState Active;
    public static BuildRequestEntryState Ready;
    public static BuildRequestEntryState Waiting;
    public static BuildRequestEntryState Complete;
}
internal class Microsoft.Build.BackEnd.BuildRequestEntryStateChangedDelegate : MulticastDelegate {
    public BuildRequestEntryStateChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry entry, BuildRequestEntryState newState);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry entry, BuildRequestEntryState newState, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.BuildRequestUnblocker : object {
    private int _blockedGlobalRequestId;
    private BuildResult _buildResult;
    public NodePacketType Type { get; }
    public int BlockedRequestId { get; }
    public BuildResult Result { get; }
    internal BuildRequestUnblocker(ITranslator translator);
    internal BuildRequestUnblocker(int globalRequestIdToResume);
    internal BuildRequestUnblocker(BuildResult buildResult);
    internal BuildRequestUnblocker(BuildRequest parentRequest, BuildResult buildResult);
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public int get_BlockedRequestId();
    [DebuggerStepThroughAttribute]
public BuildResult get_Result();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
[RunInMTAAttribute]
internal class Microsoft.Build.BackEnd.CallTarget : object {
    private TaskLoggingHelper _logHelper;
    private List`1<ITaskItem> _targetOutputs;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    public String[] Targets { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RunEachTargetSeparately { get; public set; }
    public bool UseResultsCache { get; public set; }
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public ITaskHost HostObject { get; public set; }
    public TaskLoggingHelper Log { get; }
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    public TaskLoggingHelper get_Log();
    public sealed virtual bool Execute();
    public Task`1<bool> ExecuteInternal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.Client.MSBuildClientPacketPump : object {
    [CompilerGeneratedAttribute]
private ConcurrentQueue`1<INodePacket> <ReceivedPacketsQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoResetEvent <PacketReceivedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEvent <PacketPumpCompleted>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <PacketPumpException>k__BackingField;
    private ManualResetEvent _packetPumpShutdownEvent;
    private NodePacketFactory _packetFactory;
    private MemoryStream _readBufferMemoryStream;
    [NullableAttribute("2")]
private Thread _packetPumpThread;
    private Stream _stream;
    private ITranslator _binaryReadTranslator;
    private bool _isServerDisconnecting;
    public ConcurrentQueue`1<INodePacket> ReceivedPacketsQueue { get; }
    public AutoResetEvent PacketReceivedEvent { get; }
    public ManualResetEvent PacketPumpCompleted { get; }
    [NullableAttribute("2")]
public Exception PacketPumpException { get; public set; }
    public MSBuildClientPacketPump(Stream stream);
    [CompilerGeneratedAttribute]
public ConcurrentQueue`1<INodePacket> get_ReceivedPacketsQueue();
    [CompilerGeneratedAttribute]
public AutoResetEvent get_PacketReceivedEvent();
    [CompilerGeneratedAttribute]
public ManualResetEvent get_PacketPumpCompleted();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Exception get_PacketPumpException();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PacketPumpException(Exception value);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    public void Start();
    public void Stop();
    private void PacketPumpProc();
    private void RunReadLoop(Stream localStream, ManualResetEvent localPacketPumpShutdownEvent);
    public sealed virtual void Dispose();
    public void ServerWillDisconnect();
}
internal interface Microsoft.Build.BackEnd.Components.Caching.IRegisteredTaskObjectCache {
    public abstract virtual void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime);
    public abstract virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public abstract virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public abstract virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
}
internal class Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCache : RegisteredTaskObjectCacheBase {
    protected virtual override void Finalize();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void Dispose();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.Build.BackEnd.Components.Caching.RegisteredTaskObjectCacheBase : object {
    private static Lazy`1<ConcurrentDictionary`2<object, object>> s_appDomainLifetimeObjects;
    private Lazy`1<ConcurrentDictionary`2<object, object>> _buildLifetimeObjects;
    private static RegisteredTaskObjectCacheBase();
    public sealed virtual void DisposeCacheObjects(RegisteredTaskObjectLifetime lifetime);
    public sealed virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public sealed virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    protected bool IsCollectionEmptyOrUncreated(RegisteredTaskObjectLifetime lifetime);
    protected ConcurrentDictionary`2<object, object> GetCollectionForLifetime(RegisteredTaskObjectLifetime lifetime, bool dontCreate);
    protected Lazy`1<ConcurrentDictionary`2<object, object>> GetLazyCollectionForLifetime(RegisteredTaskObjectLifetime lifetime);
    private static void DisposeObjects(Lazy`1<ConcurrentDictionary`2<object, object>> lifetimeObjects);
}
internal class Microsoft.Build.BackEnd.Components.Logging.EvaluationLoggingContext : LoggingContext {
    private string _projectFile;
    public EvaluationLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, string projectFile);
    public void LogProjectEvaluationStarted();
    internal void LogProjectEvaluationFinished(IEnumerable globalProperties, IEnumerable properties, IEnumerable items, Nullable`1<ProfilerResult> profilerResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.Components.RequestBuilder.AssemblyLoadsTracker : MarshalByRefObject {
    private static List`1<AssemblyLoadsTracker> s_instances;
    [NullableAttribute("2")]
private LoggingContext _loggingContext;
    [NullableAttribute("2")]
private LoggingService _loggingService;
    private AssemblyLoadingContext _context;
    [NullableAttribute("2")]
private string _initiator;
    private AppDomain _appDomain;
    [NullableContextAttribute("2")]
private AssemblyLoadsTracker(LoggingContext loggingContext, LoggingService loggingService, AssemblyLoadingContext context, Type initiator, AppDomain appDomain);
    private static AssemblyLoadsTracker();
    public static IDisposable StartTracking(LoggingContext loggingContext, AssemblyLoadingContext context, Type initiator, AppDomain appDomain);
    public static IDisposable StartTracking(LoggingContext loggingContext, AssemblyLoadingContext context, string initiator, AppDomain appDomain);
    public static IDisposable StartTracking(LoggingService loggingService, AssemblyLoadingContext context, Type initiator, AppDomain appDomain);
    public static void StopTracking(AppDomain appDomain);
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
private static bool IsBuiltinType(string typeName);
    [NullableContextAttribute("2")]
private static IDisposable StartTracking(LoggingContext loggingContext, LoggingService loggingService, AssemblyLoadingContext context, Type initiatorType, string initiatorName, AppDomain appDomain);
    private void StartTracking();
    private void StopTracking();
    private void CurrentDomainOnAssemblyLoad(object sender, AssemblyLoadEventArgs args);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.BackEnd.ConfigCache : object {
    private IDictionary`2<int, BuildRequestConfiguration> _configurations;
    private object _lockObject;
    private IDictionary`2<ConfigurationMetadata, int> _configurationIdsByMetadata;
    private int _sweepThreshhold;
    public BuildRequestConfiguration Item { get; }
    public sealed virtual BuildRequestConfiguration get_Item(int configId);
    public sealed virtual void AddConfiguration(BuildRequestConfiguration config);
    public sealed virtual void RemoveConfiguration(int configId);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public sealed virtual bool HasConfiguration(int configId);
    public sealed virtual void ClearConfigurations();
    public int GetSmallestConfigId();
    public sealed virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public sealed virtual bool IsConfigCacheSizeLargerThanThreshold();
    public sealed virtual bool WriteConfigurationsToDisk();
    public sealed virtual IEnumerator`1<BuildRequestConfiguration> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void Translate(ITranslator translator);
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    protected int GetKeyForConfiguration(BuildRequestConfiguration config);
}
internal class Microsoft.Build.BackEnd.ConfigCreateCallback : MulticastDelegate {
    public ConfigCreateCallback(object object, IntPtr method);
    public virtual BuildRequestConfiguration Invoke(BuildRequestConfiguration existingConfiguration, bool loadProject);
    public virtual IAsyncResult BeginInvoke(BuildRequestConfiguration existingConfiguration, bool loadProject, AsyncCallback callback, object object);
    public virtual BuildRequestConfiguration EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("{DebugString()}")]
internal class Microsoft.Build.BackEnd.ConfigurationMetadata : object {
    private string _projectFullPath;
    private string _toolsVersion;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    public string ProjectFullPath { get; }
    public string ToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalProperties { get; }
    public ConfigurationMetadata(BuildRequestConfiguration configuration);
    public ConfigurationMetadata(Project project);
    public ConfigurationMetadata(string projectFullPath, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    public ConfigurationMetadata(ITranslator translator);
    public string get_ProjectFullPath();
    public string get_ToolsVersion();
    public PropertyDictionary`1<ProjectPropertyInstance> get_GlobalProperties();
    public virtual int GetHashCode();
    public sealed virtual void Translate(ITranslator translator);
    public static ConfigurationMetadata FactoryForDeserialization(ITranslator translator);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ConfigurationMetadata other);
    private bool InternalEquals(ConfigurationMetadata other);
    private string DebugString();
}
internal enum Microsoft.Build.BackEnd.ConsoleOutput : Enum {
    public int value__;
    public static ConsoleOutput Standard;
    public static ConsoleOutput Error;
}
internal enum Microsoft.Build.BackEnd.ContinueOnError : Enum {
    public int value__;
    public static ContinueOnError ErrorAndStop;
    public static ContinueOnError ErrorAndContinue;
    public static ContinueOnError WarnAndContinue;
}
internal static class Microsoft.Build.BackEnd.CurrentHost : object {
    public static string GetCurrentHost();
}
internal class Microsoft.Build.BackEnd.DataReceivedDelegate : MulticastDelegate {
    public DataReceivedDelegate(object object, IntPtr method);
    public virtual void Invoke(INodeEndpoint endpoint, INodePacket packet);
    public virtual IAsyncResult BeginInvoke(INodeEndpoint endpoint, INodePacket packet, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.DependencyAnalysisLogDetail : object {
    private OutofdateReason _reason;
    private string _inputItemName;
    private string _outputItemName;
    private string _input;
    private string _output;
    internal OutofdateReason Reason { get; }
    public string InputItemName { get; }
    public string OutputItemName { get; }
    public string Input { get; }
    public string Output { get; }
    public DependencyAnalysisLogDetail(string input, string output, string inputItemName, string outputItemName, OutofdateReason reason);
    internal OutofdateReason get_Reason();
    public string get_InputItemName();
    public string get_OutputItemName();
    public string get_Input();
    public string get_Output();
}
internal enum Microsoft.Build.BackEnd.DependencyAnalysisResult : Enum {
    public int value__;
    public static DependencyAnalysisResult SkipUpToDate;
    public static DependencyAnalysisResult SkipNoInputs;
    public static DependencyAnalysisResult SkipNoOutputs;
    public static DependencyAnalysisResult IncrementalBuild;
    public static DependencyAnalysisResult FullBuild;
}
internal class Microsoft.Build.BackEnd.DetouredNodeLauncher : object {
    private List`1<ISandboxedProcess> _sandboxedProcesses;
    private IBuildParameters _environmentVariables;
    private IFileAccessManager _fileAccessManager;
    public static IBuildComponent CreateComponent(BuildComponentType type);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
    private static IBuildParameters CreateEnvironmentVariables();
}
internal class Microsoft.Build.BackEnd.EngineExceptionDelegate : MulticastDelegate {
    public EngineExceptionDelegate(object object, IntPtr method);
    public virtual void Invoke(Exception e);
    public virtual IAsyncResult BeginInvoke(Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.EngineStatusChangedDelegate : MulticastDelegate {
    public EngineStatusChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEngineStatus newStatus);
    public virtual IAsyncResult BeginInvoke(BuildRequestEngineStatus newStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.FullTracking : object {
    private static string FullTrackingDirectoryPropertyName;
    private string _tlogDirectory;
    private TrackingMode _trackingMode;
    private string _taskName;
    public sealed virtual void Dispose();
    internal static IDisposable Track(string targetName, string taskName, string projectRootDirectory, PropertyDictionary`1<ProjectPropertyInstance> projectProperties);
    internal static IDisposable Suspend();
    protected virtual void Dispose(bool disposing);
    private static string GenerateUniqueTaskName(string targetName, string taskName);
}
internal class Microsoft.Build.BackEnd.FullyQualifiedBuildRequest : object {
    [CompilerGeneratedAttribute]
private BuildRequestConfiguration <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResultsNeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestDataFlags <BuildRequestDataFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipStaticGraphIsolationConstraints>k__BackingField;
    public BuildRequestConfiguration Config { get; }
    public String[] Targets { get; }
    public bool ResultsNeeded { get; }
    public BuildRequestDataFlags BuildRequestDataFlags { get; public set; }
    public bool SkipStaticGraphIsolationConstraints { get; }
    public FullyQualifiedBuildRequest(BuildRequestConfiguration config, String[] targets, bool resultsNeeded, bool skipStaticGraphIsolationConstraints, BuildRequestDataFlags flags);
    [CompilerGeneratedAttribute]
public BuildRequestConfiguration get_Config();
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public bool get_ResultsNeeded();
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_BuildRequestDataFlags();
    [CompilerGeneratedAttribute]
public void set_BuildRequestDataFlags(BuildRequestDataFlags value);
    [CompilerGeneratedAttribute]
public bool get_SkipStaticGraphIsolationConstraints();
    public static bool op_Equality(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right);
    public static bool op_Inequality(FullyQualifiedBuildRequest left, FullyQualifiedBuildRequest right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool InternalEquals(FullyQualifiedBuildRequest other);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.BackEnd.IBuildComponent {
    public abstract virtual void InitializeComponent(IBuildComponentHost host);
    public abstract virtual void ShutdownComponent();
}
internal interface Microsoft.Build.BackEnd.IBuildComponentHost {
    public string Name { get; }
    public BuildParameters BuildParameters { get; }
    public LegacyThreadingData LegacyThreadingData { get; }
    public ILoggingService LoggingService { get; }
    public abstract virtual string get_Name();
    public abstract virtual BuildParameters get_BuildParameters();
    public abstract virtual LegacyThreadingData get_LegacyThreadingData();
    public abstract virtual ILoggingService get_LoggingService();
    public abstract virtual void RegisterFactory(BuildComponentType factoryType, BuildComponentFactoryDelegate factory);
    public abstract virtual IBuildComponent GetComponent(BuildComponentType type);
}
internal interface Microsoft.Build.BackEnd.IBuildRequestEngine {
    public BuildRequestEngineStatus Status { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRequestComplete(RequestCompleteDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRequestResumed(RequestResumedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnRequestBlocked(RequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnStatusChanged(EngineStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnNewConfigurationRequest(NewConfigurationRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnResourceRequest(ResourceRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnResourceRequest(ResourceRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnEngineException(EngineExceptionDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnEngineException(EngineExceptionDelegate value);
    public abstract virtual BuildRequestEngineStatus get_Status();
    public abstract virtual void InitializeForBuild(NodeLoggingContext loggingContext);
    public abstract virtual void CleanupForBuild();
    public abstract virtual void SubmitBuildRequest(BuildRequest request);
    public abstract virtual void UnblockBuildRequest(BuildRequestUnblocker unblocker);
    public abstract virtual void GrantResources(ResourceResponse response);
    public abstract virtual void ReportConfigurationResponse(BuildRequestConfigurationResponse response);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Build.BackEnd.IBuildResults {
    public Exception Exception { get; }
    public BuildResultCode OverallResult { get; }
    public IDictionary`2<string, TargetResult> ResultsByTarget { get; }
    public Dictionary`2<string, string> SavedEnvironmentVariables { get; public set; }
    public string SavedCurrentDirectory { get; public set; }
    public ITargetResult Item { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual BuildResultCode get_OverallResult();
    public abstract virtual IDictionary`2<string, TargetResult> get_ResultsByTarget();
    public abstract virtual Dictionary`2<string, string> get_SavedEnvironmentVariables();
    public abstract virtual void set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    public abstract virtual string get_SavedCurrentDirectory();
    public abstract virtual void set_SavedCurrentDirectory(string value);
    public abstract virtual ITargetResult get_Item(string target);
    public abstract virtual bool HasResultsForTarget(string target);
}
[DefaultMemberAttribute("Item")]
internal interface Microsoft.Build.BackEnd.IConfigCache {
    public BuildRequestConfiguration Item { get; }
    public abstract virtual BuildRequestConfiguration get_Item(int configId);
    public abstract virtual void AddConfiguration(BuildRequestConfiguration config);
    public abstract virtual void RemoveConfiguration(int configId);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public abstract virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public abstract virtual bool HasConfiguration(int configId);
    public abstract virtual void ClearConfigurations();
    public abstract virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public abstract virtual bool IsConfigCacheSizeLargerThanThreshold();
    public abstract virtual bool WriteConfigurationsToDisk();
}
internal interface Microsoft.Build.BackEnd.INode {
    public abstract virtual NodeEngineShutdownReason Run(Exception& shutdownException);
}
internal interface Microsoft.Build.BackEnd.INodeEndpoint {
    public LinkStatus LinkStatus { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public abstract virtual LinkStatus get_LinkStatus();
    public abstract virtual void Listen(INodePacketFactory factory);
    public abstract virtual void Connect(INodePacketFactory factory);
    public abstract virtual void Disconnect();
    public abstract virtual void SendData(INodePacket packet);
    public abstract virtual void ClientWillDisconnect();
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.BackEnd.INodeLauncher {
    public abstract virtual Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.BackEnd.INodeManager {
    public abstract virtual IList`1<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity affinity, int numberOfNodesToCreate);
    public abstract virtual void SendData(int node, INodePacket packet);
    public abstract virtual void ShutdownConnectedNodes(bool enableReuse);
    public abstract virtual void ShutdownAllNodes();
    public abstract virtual void ClearPerBuildState();
    public abstract virtual IEnumerable`1<Process> GetProcesses();
}
internal interface Microsoft.Build.BackEnd.INodePacket {
    public NodePacketType Type { get; }
    public abstract virtual NodePacketType get_Type();
}
internal interface Microsoft.Build.BackEnd.INodePacketFactory {
    public abstract virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public abstract virtual void UnregisterPacketHandler(NodePacketType packetType);
    public abstract virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public abstract virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal interface Microsoft.Build.BackEnd.INodePacketHandler {
    public abstract virtual void PacketReceived(int node, INodePacket packet);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.BackEnd.INodeProvider {
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    public abstract virtual NodeProviderType get_ProviderType();
    public abstract virtual int get_AvailableNodes();
    public abstract virtual IList`1<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory packetFactory, Func`2<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate);
    public abstract virtual void SendData(int node, INodePacket packet);
    public abstract virtual void ShutdownConnectedNodes(bool enableReuse);
    public abstract virtual void ShutdownAllNodes();
    public abstract virtual IEnumerable`1<Process> GetProcesses();
}
internal class Microsoft.Build.BackEnd.InProcNode : object {
    private IBuildComponentHost _componentHost;
    private IDictionary`2<string, string> _savedEnvironment;
    private string _savedCurrentDirectory;
    private NodeLoggingContext _loggingContext;
    private IBuildRequestEngine _buildRequestEngine;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private AutoResetEvent _packetReceivedEvent;
    private AutoResetEvent _shutdownEvent;
    private NodeEngineShutdownReason _shutdownReason;
    private Exception _shutdownException;
    private INodeEndpoint _nodeEndpoint;
    private EngineExceptionDelegate _engineExceptionEventHandler;
    private NewConfigurationRequestDelegate _newConfigurationRequestEventHandler;
    private RequestBlockedDelegate _requestBlockedEventHandler;
    private RequestCompleteDelegate _requestCompleteEventHandler;
    private ResourceRequestDelegate _resourceRequestHandler;
    public InProcNode(IBuildComponentHost componentHost, INodeEndpoint inProcNodeEndpoint);
    public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    private void OnRequestComplete(BuildRequest request, BuildResult result);
    private void OnNewRequest(BuildRequestBlocker blocker);
    private void OnNewConfigurationRequest(BuildRequestConfiguration config);
    private void OnResourceRequest(ResourceRequest request);
    private void OnLoggingThreadException(Exception e);
    private void OnEngineException(Exception e);
    private NodeEngineShutdownReason HandleShutdown(Exception& exception);
    private void HandlePacket(INodePacket packet);
    private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void HandleBuildRequest(BuildRequest request);
    private static void HandleBuildRequestConfiguration();
    private void HandleBuildRequestConfigurationResponse(BuildRequestConfigurationResponse response);
    private void HandleBuildResult(BuildRequestUnblocker unblocker);
    private void HandleNodeConfiguration(NodeConfiguration configuration);
    private void HandleNodeBuildComplete(NodeBuildComplete buildComplete);
    private void HandleResourceResponse(ResourceResponse response);
}
internal abstract class Microsoft.Build.BackEnd.IntrinsicTask : object {
    [CompilerGeneratedAttribute]
private TargetLoggingContext <LoggingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectInstance <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogTaskInputs>k__BackingField;
    internal TargetLoggingContext LoggingContext { get; private set; }
    internal ProjectInstance Project { get; private set; }
    protected bool LogTaskInputs { get; private set; }
    protected IntrinsicTask(TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    [CompilerGeneratedAttribute]
internal TargetLoggingContext get_LoggingContext();
    [CompilerGeneratedAttribute]
private void set_LoggingContext(TargetLoggingContext value);
    [CompilerGeneratedAttribute]
internal ProjectInstance get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(ProjectInstance value);
    [CompilerGeneratedAttribute]
protected bool get_LogTaskInputs();
    [CompilerGeneratedAttribute]
private void set_LogTaskInputs(bool value);
    internal static IntrinsicTask InstantiateTask(ProjectTargetInstanceChild taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    internal abstract virtual void ExecuteTask(Lookup lookup);
    protected static void AddIfNotEmptyString(List`1<string> list, string value);
}
internal class Microsoft.Build.BackEnd.IntrinsicTaskFactory : object {
    [CompilerGeneratedAttribute]
private Type <TaskType>k__BackingField;
    public string FactoryName { get; }
    public Type TaskType { get; private set; }
    public IntrinsicTaskFactory(Type intrinsicType);
    public sealed virtual string get_FactoryName();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_TaskType();
    [CompilerGeneratedAttribute]
private void set_TaskType(Type value);
    public sealed virtual bool Initialize(string taskName, IDictionary`2<string, TaskPropertyInfo> parameterGroup, string taskBody, IBuildEngine taskFactoryLoggingHost);
    public sealed virtual TaskPropertyInfo[] GetTaskParameters();
    public sealed virtual ITask CreateTask(IBuildEngine taskFactoryLoggingHost);
    public sealed virtual void CleanupTask(ITask task);
}
internal interface Microsoft.Build.BackEnd.IPropertyCache {
}
internal interface Microsoft.Build.BackEnd.IRequestBuilder {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnResourceRequest(ResourceRequestDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnResourceRequest(ResourceRequestDelegate value);
    public abstract virtual void BuildRequest(NodeLoggingContext nodeLoggingContext, BuildRequestEntry entry);
    public abstract virtual void ContinueRequest();
    public abstract virtual void ContinueRequestWithResources(ResourceResponse response);
    public abstract virtual void CancelRequest();
    public abstract virtual void BeginCancel();
    public abstract virtual void WaitForCancelCompletion();
}
internal interface Microsoft.Build.BackEnd.IRequestBuilderCallback {
    public abstract virtual Task`1<BuildResult[]> BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults, bool skipNonexistentTargets);
    public abstract virtual Task BlockOnTargetInProgress(int blockingRequestId, string blockingTarget, BuildResult partialBuildResult);
    public abstract virtual void Yield();
    public abstract virtual void Reacquire();
    public abstract virtual void EnterMSBuildCallbackState();
    public abstract virtual void ExitMSBuildCallbackState();
    public abstract virtual int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores);
    public abstract virtual void ReleaseCores(int coresToRelease);
}
internal interface Microsoft.Build.BackEnd.IResultsCache {
    public abstract virtual void AddResult(BuildResult result);
    public abstract virtual void ClearResults();
    public abstract virtual BuildResult GetResultForRequest(BuildRequest request);
    public abstract virtual BuildResult GetResultsForConfiguration(int configurationId);
    public abstract virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss);
    public abstract virtual void ClearResultsForConfiguration(int configurationId);
    public abstract virtual void WriteResultsToDisk();
}
internal interface Microsoft.Build.BackEnd.IScheduler {
    public int MinimumAssignableConfigurationId { get; }
    public abstract virtual int get_MinimumAssignableConfigurationId();
    public abstract virtual bool IsCurrentlyBuildingConfiguration(int configurationId);
    public abstract virtual int GetConfigurationIdFromPlan(string configurationPath);
    public abstract virtual BuildRequest GetExecutingRequestByNode(int nodeId);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildRequestBlocker blocker);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportResult(int nodeId, BuildResult result);
    public abstract virtual IEnumerable`1<ScheduleResponse> ReportNodesCreated(IEnumerable`1<NodeInfo> nodeInfo);
    public abstract virtual void ReportBuildAborted(int nodeId);
    public abstract virtual void Reset();
    public abstract virtual void WriteDetailedSummary(int submissionId);
    public abstract virtual Task`1<int> RequestCores(int requestId, int requestedCores, bool waitForCores);
    public abstract virtual List`1<ScheduleResponse> ReleaseCores(int requestId, int coresToRelease);
}
internal interface Microsoft.Build.BackEnd.ITargetBuilder {
    public abstract virtual Task`1<BuildResult> BuildTargets(ProjectLoggingContext projectLoggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, String[] targets, Lookup baseLookup, CancellationToken cancellationToken);
}
internal interface Microsoft.Build.BackEnd.ITargetBuilderCallback {
    public abstract virtual Task`1<ITargetResult[]> LegacyCallTarget(String[] targets, bool continueOnError, ElementLocation referenceLocation);
}
internal interface Microsoft.Build.BackEnd.ITaskBuilder {
    public abstract virtual Task`1<WorkUnitResult> ExecuteTask(TargetLoggingContext targetLoggingContext, BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, ProjectTargetInstanceChild task, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution, CancellationToken cancellationToken);
}
internal interface Microsoft.Build.BackEnd.ITaskExecutionHost {
    public ProjectInstance ProjectInstance { get; }
    public bool LogTaskInputs { get; }
    public abstract virtual ProjectInstance get_ProjectInstance();
    public abstract virtual bool get_LogTaskInputs();
    public abstract virtual void InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError, AppDomainSetup appDomainSetup, bool isOutOfProc, CancellationToken cancellationToken);
    public abstract virtual Nullable`1<TaskRequirements> FindTask(IDictionary`2<string, string> taskIdentityParameters);
    public abstract virtual bool InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary`2<string, string> taskIdentityParameters);
    public abstract virtual bool SetTaskParameters(IDictionary`2<string, ValueTuple`2<string, ElementLocation>> parameters);
    public abstract virtual bool GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
    public abstract virtual void CleanupForBatch();
    public abstract virtual void CleanupForTask();
    public abstract virtual bool Execute();
}
internal class Microsoft.Build.BackEnd.ItemBucket : object {
    private Expander`2<ProjectPropertyInstance, ProjectItemInstance> _expander;
    private Dictionary`2<string, string> _metadata;
    private Lookup _lookup;
    private int _bucketSequenceNumber;
    private Scope _lookupEntry;
    internal Expander`2<ProjectPropertyInstance, ProjectItemInstance> Expander { get; }
    internal int BucketSequenceNumber { get; }
    internal Lookup Lookup { get; }
    internal ItemBucket(ICollection`1<string> itemNames, Dictionary`2<string, string> metadata, Lookup lookup, int bucketSequenceNumber);
    public sealed virtual int CompareTo(object obj);
    internal static ItemBucket GetDummyBucketForComparisons(Dictionary`2<string, string> metadata);
    internal Expander`2<ProjectPropertyInstance, ProjectItemInstance> get_Expander();
    internal int get_BucketSequenceNumber();
    internal Lookup get_Lookup();
    internal void AddItem(ProjectItemInstance item);
    internal void LeaveScope();
}
internal class Microsoft.Build.BackEnd.ItemGroupIntrinsicTask : IntrinsicTask {
    private ProjectItemGroupTaskInstance _taskInstance;
    public ItemGroupIntrinsicTask(ProjectItemGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    internal virtual void ExecuteTask(Lookup lookup);
    private void ExecuteAdd(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet`1<string> keepMetadata, ISet`1<string> removeMetadata, LoggingContext loggingContext);
    private void ExecuteRemove(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, HashSet`1<string> matchOnMetadata, MatchOnMetadataOptions matchingOptions);
    private void ExecuteModify(ProjectItemGroupTaskItemInstance child, ItemBucket bucket, ISet`1<string> keepMetadata, ISet`1<string> removeMetadata, LoggingContext loggingContext);
    private void GetBatchableValuesFromBuildItemGroupChild(List`1<string> parameterValues, ProjectItemGroupTaskItemInstance child);
    private List`1<ProjectItemInstance> ExpandItemIntoItems(ProjectItemGroupTaskItemInstance originalItem, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander, ISet`1<string> keepMetadata, ISet`1<string> removeMetadata, LoggingContext loggingContext);
    private HashSet`1<string> EvaluateExcludePaths(IReadOnlyList`1<string> excludes, ElementLocation excludeLocation);
    private List`1<ProjectItemInstance> FindItemsMatchingSpecification(ICollection`1<ProjectItemInstance> items, string specification, ElementLocation specificationLocation, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander, LoggingContext loggingContext);
    private List`1<ProjectItemInstance> FindItemsMatchingMetadataSpecification(ICollection`1<ProjectItemInstance> group, ProjectItemGroupTaskItemInstance child, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander, HashSet`1<string> matchOnMetadata, MatchOnMetadataOptions matchingOptions);
}
internal static class Microsoft.Build.BackEnd.ItemGroupLoggingHelper : object {
    internal static int parameterCharacterLimit;
    internal static int parameterLimit;
    internal static string ItemGroupIncludeLogMessagePrefix;
    internal static string ItemGroupRemoveLogMessage;
    internal static string OutputItemParameterMessagePrefix;
    internal static string TaskParameterPrefix;
    internal static string SkipTargetUpToDateInputs;
    internal static string SkipTargetUpToDateOutputs;
    [ThreadStaticAttribute]
private static List`1<KeyValuePair`2<string, string>> keyValuePairList;
    private static ItemGroupLoggingHelper();
    internal static string GetParameterText(string prefix, string parameterName, IList parameterValue, bool logItemMetadata);
    internal static string GetStringFromParameterValue(object parameterValue, bool logItemMetadata);
    private static void AppendStringFromParameterValue(ReuseableStringBuilder sb, object parameterValue, bool logItemMetadata);
    internal static void LogTaskParameter(LoggingContext loggingContext, TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata, IElementLocation location);
    internal static TaskParameterEventArgs CreateTaskParameterEventArgs(BuildEventContext buildEventContext, TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata, DateTime timestamp, int line, int column);
    private static void CreateItemsSnapshot(IList& items);
    internal static string GetTaskParameterText(TaskParameterEventArgs args);
    internal static string GetTaskParameterText(TaskParameterMessageKind messageKind, string itemType, IList items, bool logItemMetadata);
}
internal enum Microsoft.Build.BackEnd.LinkStatus : Enum {
    public int value__;
    public static LinkStatus Inactive;
    public static LinkStatus Active;
    public static LinkStatus Failed;
    public static LinkStatus ConnectionFailed;
}
internal class Microsoft.Build.BackEnd.LinkStatusChangedDelegate : MulticastDelegate {
    public LinkStatusChangedDelegate(object object, IntPtr method);
    public virtual void Invoke(INodeEndpoint endpoint, LinkStatus status);
    public virtual IAsyncResult BeginInvoke(INodeEndpoint endpoint, LinkStatus status, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class Microsoft.Build.BackEnd.Logging.BaseConsoleLogger : object {
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipProjectStartedText>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShowSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private WriteHandler <WriteHandler>k__BackingField;
    internal DateTime buildStarted;
    internal ColorSetter setColor;
    internal ColorResetter resetColor;
    internal static int tabWidth;
    internal int currentIndentLevel;
    internal static String[] newLines;
    internal static string projectSeparatorLine;
    internal static Char[] parameterDelimiters;
    private static Char[] s_parameterValueSplitCharacter;
    internal bool showPerfSummary;
    internal bool showItemAndPropertyList;
    internal bool showTargetOutputs;
    protected bool showOnlyWarnings;
    protected bool showOnlyErrors;
    protected bool showEnvironment;
    protected bool showProjectFile;
    internal bool ignoreLoggerErrors;
    internal bool runningWithCharacterFileType;
    private StringBuilder _sharedStringBuilder;
    internal int errorCount;
    internal int warningCount;
    internal List`1<BuildErrorEventArgs> errorList;
    internal List`1<BuildWarningEventArgs> warningList;
    internal Dictionary`2<string, PerformanceCounter> projectPerformanceCounters;
    internal Dictionary`2<string, PerformanceCounter> targetPerformanceCounters;
    internal Dictionary`2<string, PerformanceCounter> taskPerformanceCounters;
    internal Dictionary`2<string, PerformanceCounter> projectEvaluationPerformanceCounters;
    public LoggerVerbosity Verbosity { get; public set; }
    public int NumberOfProcessors { get; public set; }
    public string Parameters { get; public set; }
    internal bool SkipProjectStartedText { get; internal set; }
    internal Nullable`1<bool> ShowSummary { get; internal set; }
    protected internal WriteHandler WriteHandler { get; protected internal set; }
    private static BaseConsoleLogger();
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public int get_NumberOfProcessors();
    [CompilerGeneratedAttribute]
public void set_NumberOfProcessors(int value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    [CompilerGeneratedAttribute]
internal bool get_SkipProjectStartedText();
    [CompilerGeneratedAttribute]
internal void set_SkipProjectStartedText(bool value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_ShowSummary();
    [CompilerGeneratedAttribute]
internal void set_ShowSummary(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
protected internal WriteHandler get_WriteHandler();
    [CompilerGeneratedAttribute]
protected internal void set_WriteHandler(WriteHandler value);
    public void ParseParameters();
    internal string IndentString(string s, int indent);
    internal static String[] SplitStringOnNewLines(string s);
    internal void WriteNewLine();
    internal void WriteLinePrettyFromResource(string resourceString, Object[] args);
    internal void WriteLinePrettyFromResource(int indentLevel, string resourceString, Object[] args);
    internal void WritePretty(string formattedString);
    internal void ShowPerfSummary();
    internal void WritePretty(int indentLevel, string formattedString);
    internal void WriteLinePretty(string formattedString);
    internal void WriteLinePretty(int indentLevel, string formattedString);
    internal void IsRunningWithCharacterFileType();
    internal bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
    internal static LoggerVerbosity ImportanceToMinimumVerbosity(MessageImportance importance, Boolean& lightenText);
    internal static void SetColor(ConsoleColor c);
    internal static void ResetColor();
    internal static void SetColorAnsi(ConsoleColor c);
    internal static void ResetColorAnsi();
    internal static ConsoleColor TransformColor(ConsoleColor foreground, ConsoleColor background);
    internal static void DontSetColor(ConsoleColor c);
    internal static void DontResetColor();
    internal void InitializeConsoleMethods(LoggerVerbosity logverbosity, WriteHandler logwriter, ColorSetter colorSet, ColorResetter colorReset);
    internal void WriteProperties(List`1<DictionaryEntry> properties);
    internal void WriteEnvironment(IDictionary`2<string, string> environment);
    internal List`1<DictionaryEntry> ExtractPropertyList(IEnumerable properties);
    internal virtual void OutputEnvironment(IDictionary`2<string, string> environment);
    internal virtual void OutputProperties(List`1<DictionaryEntry> list);
    internal void WriteItems(SortedList itemTypes);
    internal SortedList ExtractItemList(IEnumerable items);
    internal virtual void OutputItems(string itemType, ArrayList itemTypeList);
    protected virtual void WriteItemType(string itemType);
    protected virtual void WriteItemSpec(string itemSpec);
    protected virtual void WriteMetadata(string name, string value);
    internal static PerformanceCounter GetPerformanceCounter(string scopeName, Dictionary`2& table);
    internal void DisplayCounters(Dictionary`2<string, PerformanceCounter> counters);
    public virtual void Shutdown();
    internal abstract virtual void ResetConsoleLoggerState();
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Initialize(IEventSource eventSource);
    internal virtual bool ApplyParameter(string parameterName, string parameterValue);
    private bool ApplyVerbosityParameter(string parameterValue);
    public abstract virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public abstract virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public abstract virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public abstract virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public abstract virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public abstract virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public abstract virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public abstract virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public abstract virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public abstract virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public abstract virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public abstract virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    public abstract virtual void StatusEventHandler(object sender, BuildStatusEventArgs e);
    private sealed virtual override StringBuilder Microsoft.Build.Framework.IStringBuilderProvider.Acquire(int capacity);
    private sealed virtual override string Microsoft.Build.Framework.IStringBuilderProvider.GetStringAndRelease(StringBuilder builder);
}
internal class Microsoft.Build.BackEnd.Logging.BuildEventArgTransportSink : object {
    private SendDataDelegate _sendDataDelegate;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildStartedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildFinishedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<int, ISet`1<string>> <WarningsAsErrorsByProject>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<int, ISet`1<string>> <WarningsAsMessagesByProject>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<int> <BuildSubmissionIdsThatHaveLoggedErrors>k__BackingField;
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public IDictionary`2<int, ISet`1<string>> WarningsAsErrorsByProject { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public IDictionary`2<int, ISet`1<string>> WarningsAsMessagesByProject { get; public set; }
    public ISet`1<int> BuildSubmissionIdsThatHaveLoggedErrors { get; }
    internal BuildEventArgTransportSink(SendDataDelegate sendData);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildStartedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildStartedEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildFinishedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<int, ISet`1<string>> get_WarningsAsErrorsByProject();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrorsByProject(IDictionary`2<int, ISet`1<string>> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsMessages();
    [CompilerGeneratedAttribute]
public void set_WarningsAsMessages(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<int, ISet`1<string>> get_WarningsAsMessagesByProject();
    [CompilerGeneratedAttribute]
public void set_WarningsAsMessagesByProject(IDictionary`2<int, ISet`1<string>> value);
    [CompilerGeneratedAttribute]
public ISet`1<int> get_BuildSubmissionIdsThatHaveLoggedErrors();
    public sealed virtual void Consume(BuildEventArgs buildEvent);
    public sealed virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public sealed virtual void ShutDown();
}
internal class Microsoft.Build.BackEnd.Logging.BuildEventManager : object {
    private Dictionary`2<BuildEventContext, ProjectStartedEventMinimumFields> _projectStartedEvents;
    private Dictionary`2<BuildEventContext, TargetStartedEventMinimumFields> _targetStartedEvents;
    private Dictionary`2<string, int> _projectTargetKey;
    private Dictionary`2<string, int> _projectKey;
    private static ComparerContextNodeId`1<BuildEventContext> s_compareContextNodeId;
    private static ComparerContextNodeIdTargetId`1<BuildEventContext> s_compareContextNodeIdTargetId;
    private int _projectIncrementKey;
    private static BuildEventManager();
    internal void AddProjectStartedEvent(ProjectStartedEventArgs e, bool requireTimestamp);
    internal void AddTargetStartedEvent(TargetStartedEventArgs e, bool requireTimeStamp);
    internal List`1<ProjectStartedEventMinimumFields> GetProjectCallStack(BuildEventContext e);
    internal void SetErrorWarningFlagOnCallStack(BuildEventContext e);
    internal String[] ProjectCallStackFromProject(BuildEventContext e);
    internal ProjectStartedEventMinimumFields GetProjectStartedEvent(BuildEventContext e);
    internal TargetStartedEventMinimumFields GetTargetStartedEvent(BuildEventContext e);
    internal void RemoveProjectStartedEvent(BuildEventContext e);
    internal void RemoveTargetStartedEvent(BuildEventContext e);
}
internal class Microsoft.Build.BackEnd.Logging.BuildLoggingContext : LoggingContext {
    private bool _isInProcNode;
    public bool IsInProcNode { get; }
    protected BuildLoggingContext(ILoggingService loggingService, BuildEventContext buildEventContext, bool inProc);
    protected BuildLoggingContext(BuildLoggingContext baseContext);
    [DebuggerStepThroughAttribute]
public bool get_IsInProcNode();
    internal void LogFatalTaskError(Exception exception, BuildEventFileInfo file, string taskName);
}
internal class Microsoft.Build.BackEnd.Logging.CentralForwardingLogger : object {
    [CompilerGeneratedAttribute]
private IEventRedirector <BuildEventRedirector>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IEventRedirector get_BuildEventRedirector();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_NodeId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_NodeId(int value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    private void EventSource_AnyEventRaised(object sender, BuildEventArgs buildEvent);
}
internal class Microsoft.Build.BackEnd.Logging.ComparerContextNodeId`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T x);
}
internal class Microsoft.Build.BackEnd.Logging.ComparerContextNodeIdTargetId`1 : object {
    public sealed virtual bool Equals(T x, T y);
    public sealed virtual int GetHashCode(T x);
}
internal static class Microsoft.Build.BackEnd.Logging.ConsoleConfiguration : object {
    public static IConsoleConfiguration Provider { get; public set; }
    public static int BufferWidth { get; }
    public static bool AcceptAnsiColorCodes { get; }
    public static ConsoleColor BackgroundColor { get; }
    public static bool OutputIsScreen { get; }
    public static IConsoleConfiguration get_Provider();
    public static void set_Provider(IConsoleConfiguration value);
    public static int get_BufferWidth();
    public static bool get_AcceptAnsiColorCodes();
    public static ConsoleColor get_BackgroundColor();
    public static bool get_OutputIsScreen();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.Logging.ConsoleOutputAligner : object {
    internal static int ConsoleTabWidth;
    private int _bufferWidth;
    private bool _alignMessages;
    private IStringBuilderProvider _stringBuilderProvider;
    public ConsoleOutputAligner(int bufferWidth, bool alignMessages, IStringBuilderProvider stringBuilderProvider);
    public string AlignConsoleOutput(string message, bool prefixAlreadyWritten, int prefixWidth);
    private void AlignAndIndentLineOfMessage(StringBuilder sb, bool prefixAlreadyWritten, int prefixWidth, string message, int start, int count);
}
internal class Microsoft.Build.BackEnd.Logging.ErrorWarningSummaryDictionaryKey : object {
    private BuildEventContext _entryPointContext;
    private string _targetName;
    private static ComparerContextNodeId`1<BuildEventContext> s_eventComparer;
    internal BuildEventContext EntryPointContext { get; }
    internal string TargetName { get; }
    internal ErrorWarningSummaryDictionaryKey(BuildEventContext entryPoint, string targetName);
    private static ErrorWarningSummaryDictionaryKey();
    internal BuildEventContext get_EntryPointContext();
    internal string get_TargetName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.Logging.EventRedirectorToSink : object {
    private int _centralLoggerId;
    private IBuildEventSink _sink;
    internal EventRedirectorToSink(int loggerId, IBuildEventSink eventSink);
    private sealed virtual override void Microsoft.Build.Framework.IEventRedirector.ForwardEvent(BuildEventArgs buildEvent);
}
internal class Microsoft.Build.BackEnd.Logging.EventSourceSink : MarshalByRefObject {
    [CompilerGeneratedAttribute]
private BuildMessageEventHandler MessageRaised;
    [CompilerGeneratedAttribute]
private BuildErrorEventHandler ErrorRaised;
    [CompilerGeneratedAttribute]
private BuildWarningEventHandler WarningRaised;
    [CompilerGeneratedAttribute]
private BuildStartedEventHandler BuildStarted;
    [CompilerGeneratedAttribute]
private BuildFinishedEventHandler BuildFinished;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler ProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler ProjectFinished;
    [CompilerGeneratedAttribute]
private TargetStartedEventHandler TargetStarted;
    [CompilerGeneratedAttribute]
private TargetFinishedEventHandler TargetFinished;
    [CompilerGeneratedAttribute]
private TaskStartedEventHandler TaskStarted;
    [CompilerGeneratedAttribute]
private TaskFinishedEventHandler TaskFinished;
    [CompilerGeneratedAttribute]
private CustomBuildEventHandler CustomEventRaised;
    [CompilerGeneratedAttribute]
private BuildStatusEventHandler StatusEventRaised;
    [CompilerGeneratedAttribute]
private AnyEventHandler AnyEventRaised;
    [CompilerGeneratedAttribute]
private TelemetryEventHandler TelemetryLogged;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildStartedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HaveLoggedBuildFinishedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationMetaprojects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTaskInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEvaluationPropertiesAndItems>k__BackingField;
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; private set; }
    public bool IncludeEvaluationProfiles { get; private set; }
    public bool IncludeTaskInputs { get; private set; }
    public bool IncludeEvaluationPropertiesAndItems { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TelemetryLogged(TelemetryEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TelemetryLogged(TelemetryEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Name(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildStartedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildStartedEvent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HaveLoggedBuildFinishedEvent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationMetaprojects();
    [CompilerGeneratedAttribute]
private void set_IncludeEvaluationMetaprojects(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationProfiles();
    [CompilerGeneratedAttribute]
private void set_IncludeEvaluationProfiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTaskInputs();
    [CompilerGeneratedAttribute]
private void set_IncludeTaskInputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEvaluationPropertiesAndItems();
    [CompilerGeneratedAttribute]
private void set_IncludeEvaluationPropertiesAndItems(bool value);
    private sealed virtual override void Microsoft.Build.Framework.IEventSource3.IncludeEvaluationMetaprojects();
    private sealed virtual override void Microsoft.Build.Framework.IEventSource3.IncludeEvaluationProfiles();
    private sealed virtual override void Microsoft.Build.Framework.IEventSource3.IncludeTaskInputs();
    private sealed virtual override void Microsoft.Build.Framework.IEventSource4.IncludeEvaluationPropertiesAndItems();
    public sealed virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public sealed virtual void Consume(BuildEventArgs buildEvent);
    public sealed virtual void ShutDown();
    internal void UnregisterAllEventHandlers();
    private void RaiseMessageEvent(object sender, BuildMessageEventArgs buildEvent);
    private void RaiseErrorEvent(object sender, BuildErrorEventArgs buildEvent);
    private void RaiseWarningEvent(object sender, BuildWarningEventArgs buildEvent);
    private void RaiseBuildStartedEvent(object sender, BuildStartedEventArgs buildEvent);
    private void RaiseBuildFinishedEvent(object sender, BuildFinishedEventArgs buildEvent);
    private void RaiseProjectStartedEvent(object sender, ProjectStartedEventArgs buildEvent);
    private void RaiseProjectFinishedEvent(object sender, ProjectFinishedEventArgs buildEvent);
    private void RaiseTargetStartedEvent(object sender, TargetStartedEventArgs buildEvent);
    private void RaiseTargetFinishedEvent(object sender, TargetFinishedEventArgs buildEvent);
    private void RaiseTaskStartedEvent(object sender, TaskStartedEventArgs buildEvent);
    private void RaiseTaskFinishedEvent(object sender, TaskFinishedEventArgs buildEvent);
    private void RaiseCustomEvent(object sender, CustomBuildEventArgs buildEvent);
    private void RaiseStatusEvent(object sender, BuildStatusEventArgs buildEvent);
    private void RaiseAnyEvent(object sender, BuildEventArgs buildEvent);
    private void RaiseTelemetryEvent(object sender, TelemetryEventArgs buildEvent);
}
internal interface Microsoft.Build.BackEnd.Logging.IBuildEventSink {
    public string Name { get; public set; }
    public bool HaveLoggedBuildStartedEvent { get; public set; }
    public bool HaveLoggedBuildFinishedEvent { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual bool get_HaveLoggedBuildStartedEvent();
    public abstract virtual void set_HaveLoggedBuildStartedEvent(bool value);
    public abstract virtual bool get_HaveLoggedBuildFinishedEvent();
    public abstract virtual void set_HaveLoggedBuildFinishedEvent(bool value);
    public abstract virtual void Consume(BuildEventArgs buildEvent, int sinkId);
    public abstract virtual void Consume(BuildEventArgs buildEvent);
    public abstract virtual void ShutDown();
}
internal interface Microsoft.Build.BackEnd.Logging.IConsoleConfiguration {
    public int BufferWidth { get; }
    public bool AcceptAnsiColorCodes { get; }
    public bool OutputIsScreen { get; }
    public ConsoleColor BackgroundColor { get; }
    public abstract virtual int get_BufferWidth();
    public abstract virtual bool get_AcceptAnsiColorCodes();
    public abstract virtual bool get_OutputIsScreen();
    public abstract virtual ConsoleColor get_BackgroundColor();
}
internal interface Microsoft.Build.BackEnd.Logging.ILoggingService {
    public LoggingServiceState ServiceState { get; }
    public LoggerMode LoggingMode { get; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public int MaxCPUCount { get; public set; }
    public ICollection`1<ILogger> Loggers { get; }
    public ICollection`1<LoggerDescription> LoggerDescriptions { get; }
    public ICollection`1<string> RegisteredLoggerTypeNames { get; }
    public ICollection`1<string> RegisteredSinkNames { get; }
    public String[] PropertiesToSerialize { get; public set; }
    public bool SerializeAllProperties { get; public set; }
    public bool RunningOnRemoteNode { get; public set; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public ISet`1<string> WarningsNotAsErrors { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; public set; }
    public bool IncludeEvaluationProfile { get; public set; }
    public bool IncludeEvaluationPropertiesAndItems { get; public set; }
    public bool IncludeTaskInputs { get; public set; }
    public MessageImportance MinimumRequiredMessageImportance { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnProjectFinished(ProjectFinishedEventHandler value);
    public abstract virtual LoggingServiceState get_ServiceState();
    public abstract virtual LoggerMode get_LoggingMode();
    public abstract virtual bool get_OnlyLogCriticalEvents();
    public abstract virtual void set_OnlyLogCriticalEvents(bool value);
    public abstract virtual int get_MaxCPUCount();
    public abstract virtual void set_MaxCPUCount(int value);
    public abstract virtual ICollection`1<ILogger> get_Loggers();
    public abstract virtual ICollection`1<LoggerDescription> get_LoggerDescriptions();
    public abstract virtual ICollection`1<string> get_RegisteredLoggerTypeNames();
    public abstract virtual ICollection`1<string> get_RegisteredSinkNames();
    public abstract virtual String[] get_PropertiesToSerialize();
    public abstract virtual void set_PropertiesToSerialize(String[] value);
    public abstract virtual bool get_SerializeAllProperties();
    public abstract virtual void set_SerializeAllProperties(bool value);
    public abstract virtual bool get_RunningOnRemoteNode();
    public abstract virtual void set_RunningOnRemoteNode(bool value);
    public abstract virtual ISet`1<string> get_WarningsAsErrors();
    public abstract virtual void set_WarningsAsErrors(ISet`1<string> value);
    public abstract virtual ISet`1<string> get_WarningsNotAsErrors();
    public abstract virtual void set_WarningsNotAsErrors(ISet`1<string> value);
    public abstract virtual ISet`1<string> get_WarningsAsMessages();
    public abstract virtual void set_WarningsAsMessages(ISet`1<string> value);
    public abstract virtual bool get_IncludeEvaluationMetaprojects();
    public abstract virtual void set_IncludeEvaluationMetaprojects(bool value);
    public abstract virtual bool get_IncludeEvaluationProfile();
    public abstract virtual void set_IncludeEvaluationProfile(bool value);
    public abstract virtual bool get_IncludeEvaluationPropertiesAndItems();
    public abstract virtual void set_IncludeEvaluationPropertiesAndItems(bool value);
    public abstract virtual bool get_IncludeTaskInputs();
    public abstract virtual void set_IncludeTaskInputs(bool value);
    public abstract virtual MessageImportance get_MinimumRequiredMessageImportance();
    public abstract virtual void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet`1<string> codes);
    public abstract virtual void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet`1<string> codes);
    public abstract virtual void AddWarningsNotAsErrors(BuildEventContext buildEventContext, ISet`1<string> codes);
    public abstract virtual bool HasBuildSubmissionLoggedErrors(int submissionId);
    public abstract virtual ICollection`1<string> GetWarningsAsErrors(BuildEventContext context);
    public abstract virtual ICollection`1<string> GetWarningsNotAsErrors(BuildEventContext context);
    public abstract virtual ICollection`1<string> GetWarningsAsMessages(BuildEventContext context);
    public abstract virtual bool RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger);
    public abstract virtual bool RegisterLogger(ILogger logger);
    public abstract virtual void UnregisterAllLoggers();
    public abstract virtual void InitializeNodeLoggers(ICollection`1<LoggerDescription> loggerDescriptions, IBuildEventSink forwardingLoggerSink, int nodeId);
    public abstract virtual void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message);
    public abstract virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, Object[] messageArgs);
    public abstract virtual void LogBuildEvent(BuildEventArgs buildEvent);
    public abstract virtual void LogError(BuildEventContext buildEventContext, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    public abstract virtual void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException);
    public abstract virtual void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file);
    public abstract virtual void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public abstract virtual void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public abstract virtual void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public abstract virtual void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    public abstract virtual void LogBuildStarted();
    public abstract virtual void LogBuildFinished(bool success);
    public abstract virtual BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
    public abstract virtual BuildEventContext CreateProjectCacheBuildEventContext(int submissionId, int evaluationId, int projectInstanceId, string projectFile);
    public abstract virtual void LogProjectEvaluationStarted(BuildEventContext eventContext, string projectFile);
    public abstract virtual void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile, IEnumerable globalProperties, IEnumerable properties, IEnumerable items, Nullable`1<ProfilerResult> profilerResult);
    public abstract virtual BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int configurationId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable`1<DictionaryEntry> properties, IEnumerable`1<DictionaryEntry> items, int evaluationId, int projectContextId);
    public abstract virtual void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success);
    public abstract virtual BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName, TargetBuiltReason buildReason);
    public abstract virtual void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable`1<TaskItem> targetOutputs);
    public abstract virtual void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public abstract virtual BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column);
    public abstract virtual void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success);
    public abstract virtual void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary`2<string, string> properties);
    public abstract virtual void LogIncludeFile(BuildEventContext buildEventContext, string filePath);
}
internal class Microsoft.Build.BackEnd.Logging.InProcessConsoleConfiguration : object {
    private static bool s_supportReadingBackgroundColor;
    public int BufferWidth { get; }
    public bool AcceptAnsiColorCodes { get; }
    public ConsoleColor BackgroundColor { get; }
    public bool OutputIsScreen { get; }
    private static InProcessConsoleConfiguration();
    public sealed virtual int get_BufferWidth();
    public sealed virtual bool get_AcceptAnsiColorCodes();
    public sealed virtual ConsoleColor get_BackgroundColor();
    public sealed virtual bool get_OutputIsScreen();
}
internal static class Microsoft.Build.BackEnd.Logging.LogFormatter : object {
    internal static string FormatLogTimeStamp(DateTime timeStamp);
    internal static string FormatTimeSpan(TimeSpan t);
}
internal enum Microsoft.Build.BackEnd.Logging.LoggerMode : Enum {
    public int value__;
    public static LoggerMode Synchronous;
    public static LoggerMode Asynchronous;
}
internal class Microsoft.Build.BackEnd.Logging.LoggingContext : object {
    private ILoggingService _loggingService;
    private BuildEventContext _eventContext;
    private bool _isValid;
    protected bool _hasLoggedErrors;
    public ILoggingService LoggingService { get; }
    public BuildEventContext BuildEventContext { get; protected set; }
    public bool IsValid { get; protected set; }
    internal bool HasLoggedErrors { get; internal set; }
    public LoggingContext(ILoggingService loggingService, BuildEventContext eventContext);
    public LoggingContext(LoggingContext baseContext);
    [DebuggerStepThroughAttribute]
public ILoggingService get_LoggingService();
    [DebuggerStepThroughAttribute]
public BuildEventContext get_BuildEventContext();
    protected void set_BuildEventContext(BuildEventContext value);
    [DebuggerStepThroughAttribute]
public bool get_IsValid();
    [DebuggerStepThroughAttribute]
protected void set_IsValid(bool value);
    internal bool get_HasLoggedErrors();
    internal void set_HasLoggedErrors(bool value);
    internal void LogComment(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    internal void LogComment(MessageImportance importance, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogCommentFromText(MessageImportance importance, string message);
    internal void LogCommentFromText(MessageImportance importance, string message, Object[] messageArgs);
    internal void LogError(BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogErrorWithSubcategory(string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogErrorFromText(string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    internal void LogInvalidProjectFileError(InvalidProjectFileException invalidProjectFileException);
    internal void LogFatalError(Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogWarning(string messageResourceName, Object[] messageArgs);
    internal void LogWarning(string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    internal void LogWarningFromText(string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    internal void LogBuildEvent(BuildEventArgs buildEvent);
    internal void LogFatalBuildError(Exception exception, BuildEventFileInfo file);
    internal void LogIncludeFile(string filePath);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingExceptionDelegate : MulticastDelegate {
    public LoggingExceptionDelegate(object object, IntPtr method);
    public virtual void Invoke(Exception e);
    public virtual IAsyncResult BeginInvoke(Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingService : object {
    private static UInt32 DefaultQueueCapacity;
    private object _lockObject;
    private static Lazy`1<PropertyInfo> s_projectStartedEventArgsGlobalProperties;
    private static Lazy`1<PropertyInfo> s_projectStartedEventArgsToolsVersion;
    private ConcurrentDictionary`2<int, string> _projectFileMap;
    private LoggingServiceState _serviceState;
    private bool _onlyLogCriticalEvents;
    private Dictionary`2<int, IBuildEventSink> _eventSinkDictionary;
    private List`1<ILogger> _loggers;
    private List`1<LoggerDescription> _loggerDescriptions;
    private EventSourceSink _filterEventSource;
    private int _centralForwardingLoggerSinkId;
    private int _nextSinkId;
    private int _maxCPUCount;
    private IBuildComponentHost _componentHost;
    private Lazy`1<IConfigCache> _configCache;
    private int _nextEvaluationId;
    private int _nextProjectId;
    private int _nextTargetId;
    private int _nextTaskId;
    private int _nodeId;
    private Nullable`1<bool> _includeEvaluationMetaprojects;
    private Nullable`1<bool> _includeEvaluationProfile;
    private Nullable`1<bool> _includeEvaluationPropertiesAndItems;
    private Nullable`1<bool> _includeTaskInputs;
    private ISet`1<int> _buildSubmissionIdsThatHaveLoggedErrors;
    private IDictionary`2<WarningsConfigKey, ISet`1<string>> _warningsAsErrorsByProject;
    private IDictionary`2<WarningsConfigKey, ISet`1<string>> _warningsNotAsErrorsByProject;
    private IDictionary`2<WarningsConfigKey, ISet`1<string>> _warningsAsMessagesByProject;
    private Nullable`1<MessageImportance> _minimumRequiredMessageImportance;
    private ConcurrentQueue`1<object> _eventQueue;
    private AutoResetEvent _dequeueEvent;
    private ManualResetEvent _emptyQueueEvent;
    private AutoResetEvent _enqueueEvent;
    private CancellationTokenSource _loggingEventProcessingCancellation;
    private Thread _loggingEventProcessingThread;
    private UInt32 _queueCapacity;
    private LoggerMode _logMode;
    [CompilerGeneratedAttribute]
private LoggingExceptionDelegate OnLoggingThreadException;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler OnProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler OnProjectFinished;
    [CompilerGeneratedAttribute]
private String[] <PropertiesToSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeAllProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningOnRemoteNode>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsNotAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsMessages>k__BackingField;
    public String[] PropertiesToSerialize { get; public set; }
    public bool SerializeAllProperties { get; public set; }
    public bool RunningOnRemoteNode { get; public set; }
    public int NextEvaluationId { get; }
    public int NextProjectId { get; }
    public int NextTargetId { get; }
    public int NextTaskId { get; }
    public LoggingServiceState ServiceState { get; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public int MaxCPUCount { get; public set; }
    public ICollection`1<LoggerDescription> LoggerDescriptions { get; }
    public ICollection`1<ILogger> Loggers { get; }
    public LoggerMode LoggingMode { get; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public ISet`1<string> WarningsNotAsErrors { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public bool IncludeEvaluationMetaprojects { get; public set; }
    public bool IncludeEvaluationProfile { get; public set; }
    public bool IncludeTaskInputs { get; public set; }
    public bool IncludeEvaluationPropertiesAndItems { get; public set; }
    public ICollection`1<string> RegisteredLoggerTypeNames { get; }
    public ICollection`1<string> RegisteredSinkNames { get; }
    public MessageImportance MinimumRequiredMessageImportance { get; }
    protected LoggingService(LoggerMode loggerMode, int nodeId);
    private static LoggingService();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnLoggingThreadException(LoggingExceptionDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual String[] get_PropertiesToSerialize();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PropertiesToSerialize(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_SerializeAllProperties();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SerializeAllProperties(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_RunningOnRemoteNode();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RunningOnRemoteNode(bool value);
    public int get_NextEvaluationId();
    public int get_NextProjectId();
    public int get_NextTargetId();
    public int get_NextTaskId();
    public sealed virtual LoggingServiceState get_ServiceState();
    public sealed virtual bool get_OnlyLogCriticalEvents();
    public sealed virtual void set_OnlyLogCriticalEvents(bool value);
    public sealed virtual int get_MaxCPUCount();
    public sealed virtual void set_MaxCPUCount(int value);
    public sealed virtual ICollection`1<LoggerDescription> get_LoggerDescriptions();
    public sealed virtual ICollection`1<ILogger> get_Loggers();
    public sealed virtual LoggerMode get_LoggingMode();
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<string> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningsAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<string> get_WarningsNotAsErrors();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningsNotAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual ISet`1<string> get_WarningsAsMessages();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WarningsAsMessages(ISet`1<string> value);
    public sealed virtual bool get_IncludeEvaluationMetaprojects();
    public sealed virtual void set_IncludeEvaluationMetaprojects(bool value);
    public sealed virtual bool get_IncludeEvaluationProfile();
    public sealed virtual void set_IncludeEvaluationProfile(bool value);
    public sealed virtual bool get_IncludeTaskInputs();
    public sealed virtual void set_IncludeTaskInputs(bool value);
    public sealed virtual bool get_IncludeEvaluationPropertiesAndItems();
    public sealed virtual void set_IncludeEvaluationPropertiesAndItems(bool value);
    public sealed virtual bool HasBuildSubmissionLoggedErrors(int submissionId);
    public sealed virtual ICollection`1<string> GetWarningsAsErrors(BuildEventContext context);
    public sealed virtual ICollection`1<string> GetWarningsNotAsErrors(BuildEventContext context);
    public sealed virtual ICollection`1<string> GetWarningsAsMessages(BuildEventContext context);
    private ICollection`1<string> GetWarningsForProject(BuildEventContext context, IDictionary`2<WarningsConfigKey, ISet`1<string>> warningsByProject, ISet`1<string> warnings);
    public sealed virtual void AddWarningsAsErrors(BuildEventContext buildEventContext, ISet`1<string> codes);
    public sealed virtual void AddWarningsNotAsErrors(BuildEventContext buildEventContext, ISet`1<string> codes);
    public sealed virtual void AddWarningsAsMessages(BuildEventContext buildEventContext, ISet`1<string> codes);
    private void AddWarningsAsMessagesOrErrors(IDictionary`2& warningsByProject, BuildEventContext buildEventContext, ISet`1<string> codes);
    public sealed virtual ICollection`1<string> get_RegisteredLoggerTypeNames();
    public sealed virtual ICollection`1<string> get_RegisteredSinkNames();
    public sealed virtual MessageImportance get_MinimumRequiredMessageImportance();
    public static ILoggingService CreateLoggingService(LoggerMode mode, int node);
    public sealed virtual void InitializeComponent(IBuildComponentHost buildComponentHost);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    private void WarnOnDeprecatedCustomArgsSerialization(LogMessagePacket loggingPacket);
    public sealed virtual bool RegisterLogger(ILogger logger);
    public sealed virtual void UnregisterAllLoggers();
    public sealed virtual bool RegisterDistributedLogger(ILogger centralLogger, LoggerDescription forwardingLogger);
    public sealed virtual void InitializeNodeLoggers(ICollection`1<LoggerDescription> descriptions, IBuildEventSink forwardingLoggerSink, int nodeId);
    public sealed virtual void LogBuildEvent(BuildEventArgs buildEvent);
    internal virtual void ProcessLoggingEvent(object buildEvent);
    public void WaitForLoggingToProcessEvents();
    internal void InjectNonSerializedData(LogMessagePacket loggingPacket);
    private static WarningsConfigKey GetWarningsConfigKey(BuildEventContext buildEventContext);
    private static WarningsConfigKey GetWarningsConfigKey(BuildEventArgs buildEventArgs);
    private void StartLoggingEventProcessing();
    private void CleanLoggingEventProcessing();
    private void TerminateLoggingEventProcessing();
    private void ShutdownLogger(ILogger logger);
    private void CreateFilterEventSource();
    private void LoggingEventProcessor(object loggingEvent);
    private void RouteBuildEvent(object loggingEvent);
    private void RouteBuildEvent(KeyValuePair`2<int, BuildEventArgs> nodeEvent);
    private void RouteBuildEvent(BuildEventArgs eventArg);
    private void InitializeLogger(ILogger logger, IEventSource sourceForLogger);
    private void UpdateMinimumMessageImportance(ILogger logger);
    private void RaiseLoggingExceptionEvent(Exception ex);
    private void TryRaiseProjectStartedEvent(BuildEventArgs args);
    private void TryRaiseProjectFinishedEvent(BuildEventArgs args);
    private string GetAndVerifyProjectFileFromContext(BuildEventContext context);
    private bool ShouldTreatWarningAsMessage(BuildWarningEventArgs warningEvent);
    private bool WarningAsErrorNotOverriden(BuildWarningEventArgs warningEvent);
    private bool ShouldTreatWarningAsError(BuildWarningEventArgs warningEvent);
    public sealed virtual void LogComment(BuildEventContext buildEventContext, MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message);
    public sealed virtual void LogCommentFromText(BuildEventContext buildEventContext, MessageImportance importance, string message, Object[] messageArgs);
    public sealed virtual void LogError(BuildEventContext location, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogError(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogErrorFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string errorCode, string helpKeyword, BuildEventFileInfo file, string message);
    public sealed virtual void LogInvalidProjectFileError(BuildEventContext buildEventContext, InvalidProjectFileException invalidProjectFileException);
    public sealed virtual void LogFatalBuildError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file);
    public sealed virtual void LogFatalTaskError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public sealed virtual void LogFatalError(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogTaskWarningFromException(BuildEventContext buildEventContext, Exception exception, BuildEventFileInfo file, string taskName);
    public sealed virtual void LogWarning(BuildEventContext buildEventContext, string subcategoryResourceName, BuildEventFileInfo file, string messageResourceName, Object[] messageArgs);
    public sealed virtual void LogWarningFromText(BuildEventContext buildEventContext, string subcategoryResourceName, string warningCode, string helpKeyword, BuildEventFileInfo file, string message);
    public sealed virtual void LogBuildStarted();
    public sealed virtual void LogBuildFinished(bool success);
    public sealed virtual BuildEventContext CreateEvaluationBuildEventContext(int nodeId, int submissionId);
    public sealed virtual BuildEventContext CreateProjectCacheBuildEventContext(int submissionId, int evaluationId, int projectInstanceId, string projectFile);
    public sealed virtual void LogProjectEvaluationStarted(BuildEventContext projectEvaluationEventContext, string projectFile);
    public sealed virtual void LogProjectEvaluationFinished(BuildEventContext projectEvaluationEventContext, string projectFile, IEnumerable globalProperties, IEnumerable properties, IEnumerable items, Nullable`1<ProfilerResult> profilerResult);
    public sealed virtual BuildEventContext LogProjectStarted(BuildEventContext nodeBuildEventContext, int submissionId, int configurationId, BuildEventContext parentBuildEventContext, string projectFile, string targetNames, IEnumerable`1<DictionaryEntry> properties, IEnumerable`1<DictionaryEntry> items, int evaluationId, int projectContextId);
    public sealed virtual void LogProjectFinished(BuildEventContext projectBuildEventContext, string projectFile, bool success);
    public sealed virtual BuildEventContext LogTargetStarted(BuildEventContext projectBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, string parentTargetName, TargetBuiltReason buildReason);
    public sealed virtual void LogTargetFinished(BuildEventContext targetBuildEventContext, string targetName, string projectFile, string projectFileOfTargetElement, bool success, IEnumerable`1<TaskItem> targetOutputs);
    public sealed virtual void LogTaskStarted(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode);
    public sealed virtual BuildEventContext LogTaskStarted2(BuildEventContext targetBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, int line, int column);
    public sealed virtual void LogTaskFinished(BuildEventContext taskBuildEventContext, string taskName, string projectFile, string projectFileOfTaskNode, bool success);
    public sealed virtual void LogTelemetry(BuildEventContext buildEventContext, string eventName, IDictionary`2<string, string> properties);
    public sealed virtual void LogIncludeFile(BuildEventContext buildEventContext, string filePath);
    [CompilerGeneratedAttribute]
private IConfigCache <.ctor>b__38_0();
    [CompilerGeneratedAttribute]
private void <StartLoggingEventProcessing>g__LoggingEventProc|137_0();
    [CompilerGeneratedAttribute]
internal static ILogger <InitializeLogger>g__UnwrapLoggerType|146_0(ILogger log);
}
internal class Microsoft.Build.BackEnd.Logging.LoggingServiceFactory : object {
    private LoggerMode _logMode;
    private int _nodeId;
    internal LoggingServiceFactory(LoggerMode mode, int nodeId);
    public IBuildComponent CreateInstance(BuildComponentType type);
}
internal enum Microsoft.Build.BackEnd.Logging.LoggingServiceState : Enum {
    public int value__;
    public static LoggingServiceState Instantiated;
    public static LoggingServiceState Initialized;
    public static LoggingServiceState ShuttingDown;
    public static LoggingServiceState Shutdown;
}
internal class Microsoft.Build.BackEnd.Logging.NodeLoggingContext : BuildLoggingContext {
    internal NodeLoggingContext(ILoggingService loggingService, int nodeId, bool inProcNode);
    internal void LogBuildFinished(bool success);
    internal ProjectLoggingContext LogProjectStarted(BuildRequestEntry requestEntry);
    internal ProjectLoggingContext LogProjectStarted(BuildRequest request, BuildRequestConfiguration configuration);
    internal void LogRequestHandledFromCache(BuildRequest request, BuildRequestConfiguration configuration, BuildResult result);
}
internal class Microsoft.Build.BackEnd.Logging.NullCentralLogger : object {
    private string _parameters;
    private LoggerVerbosity _verbosity;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    public void AnyEventRaisedHandler(object sender, BuildEventArgs e);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
}
internal static class Microsoft.Build.BackEnd.Logging.OptimizedStringIndenter : object {
    [NullableContextAttribute("1")]
internal static string IndentString(string s, int indent, IStringBuilderProvider stringBuilderProvider);
    private static Span`1<StringSegment> GetStringSegments(ReadOnlySpan`1<char> input, Span`1<StringSegment> segments, StringSegment[]& pooledArray);
}
internal class Microsoft.Build.BackEnd.Logging.ParallelConsoleLogger : BaseConsoleLogger {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Dictionary`2<ValueTuple`2<int, int>, string> propertyOutputMap;
    private static ComparerContextNodeId`1<BuildEventContext> s_compareContextNodeId;
    private static ComparerContextNodeIdTargetId`1<BuildEventContext> s_compareContextNodeIdTargetId;
    private BuildEventContext _lastDisplayedBuildEventContext;
    private int _bufferWidth;
    private object _lockObject;
    private int _prefixWidth;
    private ProjectFullKey _lastProjectFullKey;
    private bool _alignMessages;
    private bool _forceNoAlign;
    private bool _showEventId;
    private Dictionary`2<BuildEventContext, List`1<BuildMessageEventArgs>> _deferredMessages;
    private BuildEventManager _buildEventManager;
    private bool _hasBuildStarted;
    private Nullable`1<bool> _showCommandLine;
    private bool _showTimeStamp;
    private ConsoleOutputAligner _consoleOutputAligner;
    public ParallelConsoleLogger(LoggerVerbosity verbosity);
    public ParallelConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    private static ParallelConsoleLogger();
    private void CheckIfOutputSupportsAlignment();
    internal virtual bool ApplyParameter(string parameterName, string parameterValue);
    public virtual void Initialize(IEventSource eventSource);
    private void ShownBuildEventContext(BuildEventContext e);
    internal virtual void ResetConsoleLoggerState();
    public virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    private void ShowFlatErrorWarningSummary();
    private void ShowNestedErrorWarningSummary();
    private void ShowErrorWarningSummary(IEnumerable`1<BuildEventArgs> listToProcess);
    public virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    private string ReadProjectConfigurationDescription(IEnumerable items);
    private ValueTuple`2<int, int> GetEvaluationKey(BuildEventContext buildEventContext);
    public virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    internal void WriteProperties(BuildEventArgs e, IEnumerable properties);
    internal virtual void OutputProperties(List`1<DictionaryEntry> list);
    internal virtual void OutputEnvironment(IDictionary`2<string, string> environment);
    internal void WriteItems(BuildEventArgs e, IEnumerable items);
    protected virtual void WriteItemType(string itemType);
    protected virtual void WriteItemSpec(string itemSpec);
    protected virtual void WriteMetadata(string name, string value);
    public virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    internal string FindLogOutputProperties(BuildEventArgs e);
    public virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public virtual void StatusEventHandler(object sender, BuildStatusEventArgs e);
    private void DisplayDeferredStartedEvents(BuildEventContext e);
    private void PrintMessage(BuildMessageEventArgs e, bool lightenText);
    private void PrintTargetNamePerMessage(BuildMessageEventArgs e, bool lightenText);
    private bool WriteTargetMessagePrefix(BuildEventArgs e, BuildEventContext context, DateTime timeStamp);
    private void WriteMessageAligned(string message, bool prefixAlreadyWritten);
    private void WriteMessageAligned(string message, bool prefixAlreadyWritten, int prefixAdjustment);
    private void WriteBasedOnPrefix(string nonNullMessage, bool prefixAlreadyWritten, int adjustedPrefixWidth);
    private void DisplayDeferredTargetStartedEvent(BuildEventContext e);
    private void DisplayDeferredProjectStartedEvent(BuildEventContext e);
    public virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    private void WriteLinePrefix(BuildEventContext e, DateTime eventTimeStamp, bool isMessagePrefix);
    private void WriteLinePrefix(string key, DateTime eventTimeStamp, bool isMessagePrefix);
    private ProjectFullKey GetFullProjectKey(BuildEventContext e);
    internal static MPPerformanceCounter GetPerformanceCounter(string scopeName, Dictionary`2& table);
}
internal class Microsoft.Build.BackEnd.Logging.ProjectFullKey : object {
    private int _projectKey;
    private int _entryPointKey;
    internal int ProjectKey { get; internal set; }
    internal int EntryPointKey { get; internal set; }
    internal ProjectFullKey(int projectKey, int entryPointKey);
    internal int get_ProjectKey();
    internal void set_ProjectKey(int value);
    internal int get_EntryPointKey();
    internal void set_EntryPointKey(int value);
    public string ToString(LoggerVerbosity verbosity);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.Logging.ProjectLoggingContext : BuildLoggingContext {
    private string _projectFullPath;
    internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequestEntry requestEntry);
    internal ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, BuildRequest request, string projectFullPath, string toolsVersion, int evaluationId);
    private ProjectLoggingContext(NodeLoggingContext nodeLoggingContext, int submissionId, int configurationId, string projectFullPath, List`1<string> targets, string toolsVersion, PropertyDictionary`1<ProjectPropertyInstance> projectProperties, ItemDictionary`1<ProjectItemInstance> projectItems, BuildEventContext parentBuildEventContext, int evaluationId, int projectContextId);
    internal void LogProjectFinished(bool success);
    internal TargetLoggingContext LogTargetBatchStarted(string projectFullPath, ProjectTargetInstance target, string parentTargetName, TargetBuiltReason buildReason);
}
internal class Microsoft.Build.BackEnd.Logging.ProjectStartedEventMinimumFields : object {
    private DateTime _timeStamp;
    private string _targetNames;
    private string _projectFile;
    private bool _showProjectFinishedEvent;
    private bool _errorInProject;
    private int _projectId;
    private ProjectFullKey _projectFullKey;
    private BuildEventContext _buildEventContext;
    private ProjectStartedEventMinimumFields _parentProjectStartedEvent;
    internal DateTime TimeStamp { get; }
    internal int ProjectKey { get; }
    internal int EntryPointKey { get; }
    internal string FullProjectKey { get; }
    internal ProjectStartedEventMinimumFields ParentProjectStartedEvent { get; }
    internal string TargetNames { get; }
    internal int ProjectId { get; }
    internal string ProjectFile { get; }
    internal bool ShowProjectFinishedEvent { get; internal set; }
    internal bool ErrorInProject { get; internal set; }
    internal BuildEventContext ProjectBuildEventContext { get; }
    internal ProjectStartedEventMinimumFields(int projectKey, int entryPointKey, ProjectStartedEventArgs startedEvent, ProjectStartedEventMinimumFields parentProjectStartedEvent, bool requireTimeStamp);
    internal DateTime get_TimeStamp();
    internal int get_ProjectKey();
    internal int get_EntryPointKey();
    internal string get_FullProjectKey();
    internal ProjectStartedEventMinimumFields get_ParentProjectStartedEvent();
    internal string get_TargetNames();
    internal int get_ProjectId();
    internal string get_ProjectFile();
    internal bool get_ShowProjectFinishedEvent();
    internal void set_ShowProjectFinishedEvent(bool value);
    internal bool get_ErrorInProject();
    internal void set_ErrorInProject(bool value);
    internal BuildEventContext get_ProjectBuildEventContext();
}
internal class Microsoft.Build.BackEnd.Logging.SendDataDelegate : MulticastDelegate {
    public SendDataDelegate(object object, IntPtr method);
    public virtual void Invoke(INodePacket packetToSend);
    public virtual IAsyncResult BeginInvoke(INodePacket packetToSend, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.Logging.SerialConsoleLogger : BaseConsoleLogger {
    internal FrameStack contextStack;
    public SerialConsoleLogger(LoggerVerbosity verbosity);
    public SerialConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    internal virtual void ResetConsoleLoggerState();
    public virtual void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public virtual void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    private void ShowErrorWarningSummary();
    public virtual void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public virtual void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public virtual void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public virtual void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public virtual void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public virtual void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public virtual void ErrorHandler(object sender, BuildErrorEventArgs e);
    public virtual void WarningHandler(object sender, BuildWarningEventArgs e);
    public virtual void MessageHandler(object sender, BuildMessageEventArgs e);
    public virtual void CustomEventHandler(object sender, CustomBuildEventArgs e);
    public virtual void StatusEventHandler(object sender, BuildStatusEventArgs e);
    internal void WriteProjectStarted();
    private void WriteProjectStartedText(string current, string targetNames, string previous, int indentLevel);
    private void WriteTargetStarted();
    private string GetCurrentlyBuildingProjectFile();
    private void ShowDeferredMessages();
    private void SetErrorsOrWarningsOnCurrentFrame();
    private void VerifyStack(bool condition, string unformattedMessage, Object[] args);
}
internal class Microsoft.Build.BackEnd.Logging.TargetConsoleConfiguration : object {
    private int _bufferWidth;
    private bool _acceptAnsiColorCodes;
    private bool _outputIsScreen;
    private ConsoleColor _backgroundColor;
    public int BufferWidth { get; }
    public bool AcceptAnsiColorCodes { get; }
    public bool OutputIsScreen { get; }
    public ConsoleColor BackgroundColor { get; }
    public TargetConsoleConfiguration(int bufferWidth, bool acceptAnsiColorCodes, bool outputIsScreen, ConsoleColor backgroundColor);
    public sealed virtual int get_BufferWidth();
    public sealed virtual bool get_AcceptAnsiColorCodes();
    public sealed virtual bool get_OutputIsScreen();
    public sealed virtual ConsoleColor get_BackgroundColor();
    public sealed virtual void Translate(ITranslator translator);
    internal static TargetConsoleConfiguration FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.Logging.TargetLoggingContext : BuildLoggingContext {
    private static bool s_enableTargetOutputLogging;
    private ProjectLoggingContext _projectLoggingContext;
    private ProjectTargetInstance _target;
    internal static bool EnableTargetOutputLogging { get; internal set; }
    internal ProjectLoggingContext ProjectLoggingContext { get; }
    internal ProjectTargetInstance Target { get; }
    internal TargetLoggingContext(ProjectLoggingContext projectLoggingContext, string projectFullPath, ProjectTargetInstance target, string parentTargetName, TargetBuiltReason buildReason);
    internal TargetLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext);
    private static TargetLoggingContext();
    internal static bool get_EnableTargetOutputLogging();
    internal static void set_EnableTargetOutputLogging(bool value);
    internal ProjectLoggingContext get_ProjectLoggingContext();
    internal ProjectTargetInstance get_Target();
    internal void LogTargetBatchFinished(string projectFullPath, bool success, IEnumerable`1<TaskItem> targetOutputs);
    internal TaskLoggingContext LogTaskBatchStarted(string projectFullPath, ProjectTargetInstanceChild task);
}
internal class Microsoft.Build.BackEnd.Logging.TargetStartedEventMinimumFields : object {
    private DateTime _timeStamp;
    private string _targetName;
    private string _targetFile;
    private string _projectFile;
    private string _parentTarget;
    private bool _showTargetFinishedEvent;
    private bool _errorInTarget;
    private string _message;
    private BuildEventContext _buildEventContext;
    internal DateTime TimeStamp { get; }
    internal string TargetName { get; }
    internal string TargetFile { get; }
    internal string ProjectFile { get; }
    internal string Message { get; }
    internal bool ShowTargetFinishedEvent { get; internal set; }
    internal bool ErrorInTarget { get; internal set; }
    internal BuildEventContext ProjectBuildEventContext { get; }
    internal string ParentTarget { get; }
    internal TargetStartedEventMinimumFields(TargetStartedEventArgs startedEvent, bool requireTimeStamp);
    internal DateTime get_TimeStamp();
    internal string get_TargetName();
    internal string get_TargetFile();
    internal string get_ProjectFile();
    internal string get_Message();
    internal bool get_ShowTargetFinishedEvent();
    internal void set_ShowTargetFinishedEvent(bool value);
    internal bool get_ErrorInTarget();
    internal void set_ErrorInTarget(bool value);
    internal BuildEventContext get_ProjectBuildEventContext();
    internal string get_ParentTarget();
}
internal class Microsoft.Build.BackEnd.Logging.TaskEngineAssemblyResolver : MarshalByRefObject {
    private ResolveEventHandler _eventHandler;
    private string _taskAssemblyFile;
    internal void Initialize(string taskAssemblyFileToResolve);
    internal void InstallHandler();
    internal void RemoveHandler();
    internal Assembly ResolveAssembly(object sender, ResolveEventArgs args);
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
}
internal class Microsoft.Build.BackEnd.Logging.TaskLoggingContext : BuildLoggingContext {
    private TargetLoggingContext _targetLoggingContext;
    private ProjectTargetInstanceChild _task;
    private string _taskName;
    internal TargetLoggingContext TargetLoggingContext { get; }
    internal ProjectTargetInstanceChild Task { get; }
    internal string TaskName { get; }
    internal TaskLoggingContext(TargetLoggingContext targetLoggingContext, string projectFullPath, ProjectTargetInstanceChild task);
    internal TaskLoggingContext(ILoggingService loggingService, BuildEventContext outOfProcContext);
    internal TargetLoggingContext get_TargetLoggingContext();
    internal ProjectTargetInstanceChild get_Task();
    internal string get_TaskName();
    internal void LogTaskBatchFinished(string projectFullPath, bool success);
    internal void LogTaskWarningFromException(Exception exception, BuildEventFileInfo file, string taskName);
    internal ICollection`1<string> GetWarningsAsErrors();
    internal ICollection`1<string> GetWarningsNotAsErrors();
    internal ICollection`1<string> GetWarningsAsMessages();
}
internal class Microsoft.Build.BackEnd.Logging.WriteLinePrettyFromResourceDelegate : MulticastDelegate {
    public WriteLinePrettyFromResourceDelegate(object object, IntPtr method);
    public virtual void Invoke(int indentLevel, string resourceString, Object[] args);
    public virtual IAsyncResult BeginInvoke(int indentLevel, string resourceString, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.LoggingNodeConfiguration : object {
    private bool _includeEvaluationMetaprojects;
    private bool _includeEvaluationProfiles;
    private bool _includeEvaluationPropertiesAndItems;
    private bool _includeTaskInputs;
    public bool IncludeEvaluationMetaprojects { get; }
    public bool IncludeEvaluationProfiles { get; }
    public bool IncludeEvaluationPropertiesAndItems { get; }
    public bool IncludeTaskInputs { get; }
    public LoggingNodeConfiguration(bool includeEvaluationMetaprojects, bool includeEvaluationProfiles, bool includeEvaluationPropertiesAndItems, bool includeTaskInputs);
    public bool get_IncludeEvaluationMetaprojects();
    public bool get_IncludeEvaluationProfiles();
    public bool get_IncludeEvaluationPropertiesAndItems();
    public bool get_IncludeTaskInputs();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.LogMessagePacket : LogMessagePacketBase {
    internal LogMessagePacket(Nullable`1<KeyValuePair`2<int, BuildEventArgs>> nodeBuildEvent);
    private LogMessagePacket(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
    private static void TranslateTargetFinishedEvent(ITranslator translator, TargetFinishedEventArgs finishedEvent);
}
internal class Microsoft.Build.BackEnd.Lookup : object {
    private LinkedList`1<Scope> _lookupScopes;
    private Dictionary`2<ProjectItemInstance, ProjectItemInstance> _cloneTable;
    private ItemDictionary`1<ProjectItemInstance> PrimaryTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> PrimaryAddTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> PrimaryRemoveTable { get; private set; }
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> PrimaryModifyTable { get; private set; }
    private PropertyDictionary`1<ProjectPropertyInstance> PrimaryPropertySets { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> SecondaryTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> SecondaryAddTable { get; private set; }
    private ItemDictionary`1<ProjectItemInstance> SecondaryRemoveTable { get; private set; }
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> SecondaryModifyTable { get; private set; }
    private PropertyDictionary`1<ProjectPropertyInstance> SecondaryProperties { get; private set; }
    private PropertyDictionary`1<ProjectPropertyInstance> SecondaryPropertySets { get; private set; }
    internal Lookup(ItemDictionary`1<ProjectItemInstance> projectItems, PropertyDictionary`1<ProjectPropertyInstance> properties);
    private Lookup(Lookup that);
    private ItemDictionary`1<ProjectItemInstance> get_PrimaryTable();
    private void set_PrimaryTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_PrimaryAddTable();
    private void set_PrimaryAddTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_PrimaryRemoveTable();
    private void set_PrimaryRemoveTable(ItemDictionary`1<ProjectItemInstance> value);
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> get_PrimaryModifyTable();
    private void set_PrimaryModifyTable(Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> value);
    private PropertyDictionary`1<ProjectPropertyInstance> get_PrimaryPropertySets();
    private void set_PrimaryPropertySets(PropertyDictionary`1<ProjectPropertyInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_SecondaryTable();
    private void set_SecondaryTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_SecondaryAddTable();
    private void set_SecondaryAddTable(ItemDictionary`1<ProjectItemInstance> value);
    private ItemDictionary`1<ProjectItemInstance> get_SecondaryRemoveTable();
    private void set_SecondaryRemoveTable(ItemDictionary`1<ProjectItemInstance> value);
    private Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> get_SecondaryModifyTable();
    private void set_SecondaryModifyTable(Dictionary`2<string, Dictionary`2<ProjectItemInstance, MetadataModifications>> value);
    private PropertyDictionary`1<ProjectPropertyInstance> get_SecondaryProperties();
    private void set_SecondaryProperties(PropertyDictionary`1<ProjectPropertyInstance> value);
    private PropertyDictionary`1<ProjectPropertyInstance> get_SecondaryPropertySets();
    private void set_SecondaryPropertySets(PropertyDictionary`1<ProjectPropertyInstance> value);
    internal List`1<string> GetPropertyOverrideMessages(Dictionary`2<string, string> lookupHash);
    internal Lookup Clone();
    internal Scope EnterScope(string description);
    private void LeaveScope(Scope scopeToLeave);
    private void MergeScopeIntoNotLastScope();
    private void MergeScopeIntoLastScope();
    public sealed virtual ProjectPropertyInstance GetProperty(string name, int startIndex, int endIndex);
    public sealed virtual ProjectPropertyInstance GetProperty(string name);
    public sealed virtual ICollection`1<ProjectItemInstance> GetItems(string itemType);
    internal void PopulateWithItems(string itemType, ICollection`1<ProjectItemInstance> group);
    internal void PopulateWithItem(ProjectItemInstance item);
    internal void SetProperty(ProjectPropertyInstance property);
    internal void AddNewItemsOfItemType(string itemType, ICollection`1<ProjectItemInstance> group, bool doNotAddDuplicates);
    internal void AddNewItem(ProjectItemInstance item);
    internal void RemoveItems(IEnumerable`1<ProjectItemInstance> items);
    internal void RemoveItem(ProjectItemInstance item);
    internal void ModifyItems(string itemType, ICollection`1<ProjectItemInstance> group, MetadataModifications metadataChanges);
    private void ApplyModifies(ItemDictionary`1<ProjectItemInstance> result, Dictionary`2<ProjectItemInstance, MetadataModifications> allModifies);
    private static void ApplyMetadataModificationsToItem(MetadataModifications modificationsToApply, ProjectItemInstance itemToModify);
    private ProjectItemInstance RetrieveOriginalFromCloneTable(ProjectItemInstance item);
    private void ApplyModificationsToTable(ItemDictionary`1<ProjectItemInstance> table, string itemType, Dictionary`2<ProjectItemInstance, MetadataModifications> modify);
    private void MergeModificationsIntoModificationTable(Dictionary`2<ProjectItemInstance, MetadataModifications> modifiesOfType, KeyValuePair`2<ProjectItemInstance, MetadataModifications> modify, ModifyMergeType mergeType);
    private void MustNotBeOuterScope();
}
internal class Microsoft.Build.BackEnd.MSBuild : object {
    private List`1<ITaskItem> _targetOutputs;
    private SkipNonExistentProjectsBehavior _skipNonExistentProjects;
    private TaskLoggingHelper _logHelper;
    [CompilerGeneratedAttribute]
private IBuildEngine <BuildEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskHost <HostObject>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoveProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebaseOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFirstFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunEachTargetSeparately>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildInParallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnloadProjectsOnCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <TargetAndPropertyListSeparators>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipNonexistentTargets>k__BackingField;
    public IBuildEngine BuildEngine { get; public set; }
    public IBuildEngine2 BuildEngine2 { get; }
    public IBuildEngine3 BuildEngine3 { get; }
    public TaskLoggingHelper Log { get; }
    public ITaskHost HostObject { get; public set; }
    public String[] Properties { get; public set; }
    public string RemoveProperties { get; public set; }
    public String[] Targets { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Projects { get; public set; }
    [OutputAttribute]
public ITaskItem[] TargetOutputs { get; }
    public bool RebaseOutputs { get; public set; }
    public bool StopOnFirstFailure { get; public set; }
    public bool RunEachTargetSeparately { get; public set; }
    public string ToolsVersion { get; public set; }
    public bool BuildInParallel { get; public set; }
    public bool UnloadProjectsOnCompletion { get; public set; }
    public bool UseResultsCache { get; public set; }
    public string SkipNonexistentProjects { get; public set; }
    public String[] TargetAndPropertyListSeparators { get; public set; }
    public bool SkipNonexistentTargets { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BuildEngine(IBuildEngine value);
    public IBuildEngine2 get_BuildEngine2();
    public IBuildEngine3 get_BuildEngine3();
    public TaskLoggingHelper get_Log();
    [CompilerGeneratedAttribute]
public sealed virtual ITaskHost get_HostObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_HostObject(ITaskHost value);
    [CompilerGeneratedAttribute]
public String[] get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(String[] value);
    [CompilerGeneratedAttribute]
public string get_RemoveProperties();
    [CompilerGeneratedAttribute]
public void set_RemoveProperties(string value);
    [CompilerGeneratedAttribute]
public String[] get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(String[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Projects();
    [CompilerGeneratedAttribute]
public void set_Projects(ITaskItem[] value);
    public ITaskItem[] get_TargetOutputs();
    [CompilerGeneratedAttribute]
public bool get_RebaseOutputs();
    [CompilerGeneratedAttribute]
public void set_RebaseOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_StopOnFirstFailure();
    [CompilerGeneratedAttribute]
public void set_StopOnFirstFailure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RunEachTargetSeparately();
    [CompilerGeneratedAttribute]
public void set_RunEachTargetSeparately(bool value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_BuildInParallel();
    [CompilerGeneratedAttribute]
public void set_BuildInParallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnloadProjectsOnCompletion();
    [CompilerGeneratedAttribute]
public void set_UnloadProjectsOnCompletion(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseResultsCache();
    [CompilerGeneratedAttribute]
public void set_UseResultsCache(bool value);
    public string get_SkipNonexistentProjects();
    public void set_SkipNonexistentProjects(string value);
    [CompilerGeneratedAttribute]
public String[] get_TargetAndPropertyListSeparators();
    [CompilerGeneratedAttribute]
public void set_TargetAndPropertyListSeparators(String[] value);
    [CompilerGeneratedAttribute]
public bool get_SkipNonexistentTargets();
    [CompilerGeneratedAttribute]
public void set_SkipNonexistentTargets(bool value);
    public sealed virtual bool Execute();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<ExecuteInternal>d__76")]
public Task`1<bool> ExecuteInternal();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<BuildProjectsInParallel>d__77")]
private Task`1<bool> BuildProjectsInParallel(Dictionary`2<string, string> propertiesTable, String[] undefinePropertiesArray, List`1<String[]> targetLists, bool success, Boolean[] skipProjects);
    private void ExpandAllTargetsAndProperties();
    internal static List`1<String[]> CreateTargetLists(String[] targets, bool runEachTargetSeparately);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.MSBuild/<ExecuteTargets>d__80")]
internal static Task`1<bool> ExecuteTargets(ITaskItem[] projects, Dictionary`2<string, string> propertiesTable, String[] undefineProperties, List`1<String[]> targetLists, bool stopOnFirstFailure, bool rebaseOutputs, IBuildEngine3 buildEngine, TaskLoggingHelper log, List`1<ITaskItem> targetOutputs, bool unloadProjectsOnCompletion, string toolsVersion, bool skipNonexistentTargets);
    private bool TryParseSkipNonExistentProjects(string value, SkipNonExistentProjectsBehavior& behavior);
}
internal static class Microsoft.Build.BackEnd.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidHandle;
    internal static UInt32 NORMALPRIORITYCLASS;
    internal static UInt32 CREATENOWINDOW;
    internal static int STARTFUSESTDHANDLES;
    internal static int CREATE_NEW_CONSOLE;
    private static NativeMethods();
    internal static bool CreateProcess(string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES& lpProcessAttributes, SECURITY_ATTRIBUTES& lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUP_INFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
}
internal class Microsoft.Build.BackEnd.NewBuildRequestsDelegate : MulticastDelegate {
    public NewBuildRequestsDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestEntry issuingEntry, FullyQualifiedBuildRequest[] requests);
    public virtual IAsyncResult BeginInvoke(BuildRequestEntry issuingEntry, FullyQualifiedBuildRequest[] requests, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NewConfigurationRequestDelegate : MulticastDelegate {
    public NewConfigurationRequestDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestConfiguration config);
    public virtual IAsyncResult BeginInvoke(BuildRequestConfiguration config, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.NodeBuildComplete : object {
    private bool _prepareForReuse;
    public bool PrepareForReuse { get; }
    public NodePacketType Type { get; }
    public NodeBuildComplete(bool prepareForReuse);
    [DebuggerStepThroughAttribute]
public bool get_PrepareForReuse();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(ITranslator translator);
    internal static NodeBuildComplete FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.NodeConfiguration : object {
    private int _nodeId;
    private BuildParameters _buildParameters;
    private AppDomainSetup _appDomainSetup;
    private LoggerDescription[] _forwardingLoggers;
    private LoggingNodeConfiguration _loggingNodeConfiguration;
    public int NodeId { get; public set; }
    public BuildParameters BuildParameters { get; }
    public LoggerDescription[] LoggerDescriptions { get; }
    public AppDomainSetup AppDomainSetup { get; }
    public LoggingNodeConfiguration LoggingNodeConfiguration { get; }
    public NodePacketType Type { get; }
    public NodeConfiguration(int nodeId, BuildParameters buildParameters, LoggerDescription[] forwardingLoggers, AppDomainSetup appDomainSetup, LoggingNodeConfiguration loggingNodeConfiguration);
    [DebuggerStepThroughAttribute]
public int get_NodeId();
    [DebuggerStepThroughAttribute]
public void set_NodeId(int value);
    [DebuggerStepThroughAttribute]
public BuildParameters get_BuildParameters();
    [DebuggerStepThroughAttribute]
public LoggerDescription[] get_LoggerDescriptions();
    [DebuggerStepThroughAttribute]
public AppDomainSetup get_AppDomainSetup();
    [DebuggerStepThroughAttribute]
public LoggingNodeConfiguration get_LoggingNodeConfiguration();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
    internal NodeConfiguration Clone();
}
internal class Microsoft.Build.BackEnd.NodeEndpointInProc : object {
    private static object s_locker;
    private LinkStatus _status;
    private EndpointMode _mode;
    private NodeEndpointInProc _peerEndpoint;
    private IBuildComponentHost _componentHost;
    private INodePacketFactory _packetFactory;
    private object _asyncDataMonitor;
    private AutoResetEvent _packetAvailable;
    private AutoResetEvent _terminatePacketPump;
    private Thread _packetPump;
    private bool _peerConnected;
    private ConcurrentQueue`1<INodePacket> _packetQueue;
    [CompilerGeneratedAttribute]
private LinkStatusChangedDelegate OnLinkStatusChanged;
    public LinkStatus LinkStatus { get; }
    private NodeEndpointInProc(EndpointMode commMode, IBuildComponentHost host);
    private static NodeEndpointInProc();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual LinkStatus get_LinkStatus();
    public sealed virtual void Listen(INodePacketFactory factory);
    public sealed virtual void Connect(INodePacketFactory factory);
    public sealed virtual void Disconnect();
    public sealed virtual void SendData(INodePacket packet);
    public sealed virtual void ClientWillDisconnect();
    internal static EndpointPair CreateInProcEndpoints(EndpointMode mode, IBuildComponentHost host);
    private void RaiseLinkStatusChanged(LinkStatus newStatus);
    private void SetPeerNodeConnected();
    private void SetPeerNodeDisconnected();
    private void InternalDisconnect();
    private void ChangeLinkStatus(LinkStatus newStatus);
    private void EnqueuePacket(INodePacket packet);
    private void InitializeAsyncPacketThread();
    private void TerminateAsyncPacketThread();
    private void PacketPumpProc();
}
internal class Microsoft.Build.BackEnd.NodeEndpointOutOfProc : NodeEndpointOutOfProcBase {
    private bool _enableReuse;
    [CompilerGeneratedAttribute]
private bool <LowPriority>k__BackingField;
    internal bool LowPriority { get; private set; }
    internal NodeEndpointOutOfProc(bool enableReuse, bool lowPriority);
    [CompilerGeneratedAttribute]
internal bool get_LowPriority();
    [CompilerGeneratedAttribute]
private void set_LowPriority(bool value);
    [NullableContextAttribute("1")]
protected virtual Handshake GetHandshake();
}
internal abstract class Microsoft.Build.BackEnd.NodeEndpointOutOfProcBase : object {
    private static int PipeBufferSize;
    private LinkStatus _status;
    private NamedPipeServerStream _pipeServer;
    private object _asyncDataMonitor;
    private AutoResetEvent _packetAvailable;
    private AutoResetEvent _terminatePacketPump;
    private bool _isClientDisconnecting;
    private Thread _packetPump;
    private INodePacketFactory _packetFactory;
    private ConcurrentQueue`1<INodePacket> _packetQueue;
    private BinaryReaderFactory _sharedReadBuffer;
    private MemoryStream _packetStream;
    private BinaryWriter _binaryWriter;
    [CompilerGeneratedAttribute]
private LinkStatusChangedDelegate OnLinkStatusChanged;
    public LinkStatus LinkStatus { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnLinkStatusChanged(LinkStatusChangedDelegate value);
    public sealed virtual LinkStatus get_LinkStatus();
    public sealed virtual void Listen(INodePacketFactory factory);
    public sealed virtual void Connect(INodePacketFactory factory);
    public sealed virtual void Disconnect();
    public sealed virtual void SendData(INodePacket packet);
    public sealed virtual void ClientWillDisconnect();
    internal void InternalConstruct(string pipeName);
    protected abstract virtual Handshake GetHandshake();
    protected void ChangeLinkStatus(LinkStatus newStatus);
    private void RaiseLinkStatusChanged(LinkStatus newStatus);
    private void InternalDisconnect();
    private void EnqueuePacket(INodePacket packet);
    private void InitializeAsyncPacketThread();
    private void PacketPumpProc();
    private void RunReadLoop(Stream localReadPipe, Stream localWritePipe, ConcurrentQueue`1<INodePacket> localPacketQueue, AutoResetEvent localPacketAvailable, AutoResetEvent localTerminatePacketPump);
}
internal class Microsoft.Build.BackEnd.NodeFailedToLaunchException : BuildExceptionBase {
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    public string ErrorCode { get; private set; }
    public string ErrorDescription { get; private set; }
    internal NodeFailedToLaunchException(Exception innerException);
    public NodeFailedToLaunchException(string message, Exception inner);
    internal NodeFailedToLaunchException(string errorCode, string message);
    protected NodeFailedToLaunchException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
private void set_ErrorDescription(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class Microsoft.Build.BackEnd.NodeInfo : object {
    private int _nodeId;
    private NodeProviderType _providerType;
    private HashSet`1<int> _configurationIDs;
    public int NodeId { get; }
    public NodeProviderType ProviderType { get; }
    public NodeInfo(int nodeId, NodeProviderType providerType);
    public int get_NodeId();
    public NodeProviderType get_ProviderType();
    public bool AssignConfiguration(int configId);
    public bool HasConfiguration(int configId);
    internal bool CanServiceRequestWithAffinity(NodeAffinity nodeAffinity);
}
internal class Microsoft.Build.BackEnd.NodeLauncher : object {
    public static IBuildComponent CreateComponent(BuildComponentType type);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual Process Start(string msbuildLocation, string commandLineArgs, int nodeId);
    private Process StartInternal(string msbuildLocation, string commandLineArgs);
    private static Process DisableMSBuildServer(Func`1<Process> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.NodeManager : object {
    [NullableAttribute("2")]
private INodeProvider _inProcNodeProvider;
    [NullableAttribute("2")]
private INodeProvider _outOfProcNodeProvider;
    [NullableAttribute("2")]
private IBuildComponentHost _componentHost;
    private Dictionary`2<int, INodeProvider> _nodeIdToProvider;
    private NodePacketFactory _packetFactory;
    private int _nextNodeId;
    private int _inprocNodeId;
    private bool _nodesShutdown;
    private bool _componentShutdown;
    public sealed virtual IList`1<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity nodeAffinity, int numberOfNodesToCreate);
    public sealed virtual void SendData(int node, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ClearPerBuildState();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private void RemoveNodeFromMapping(int nodeId);
    private IList`1<NodeInfo> AttemptCreateNode(INodeProvider nodeProvider, NodeConfiguration nodeConfiguration, int numberOfNodesToCreate);
    public sealed virtual IEnumerable`1<Process> GetProcesses();
}
internal class Microsoft.Build.BackEnd.NodePacketFactory : object {
    private Dictionary`2<NodePacketType, PacketFactoryRecord> _packetFactories;
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
}
internal class Microsoft.Build.BackEnd.NodePacketFactoryMethod : MulticastDelegate {
    public NodePacketFactoryMethod(object object, IntPtr method);
    public virtual INodePacket Invoke(ITranslator translator);
    public virtual IAsyncResult BeginInvoke(ITranslator translator, AsyncCallback callback, object object);
    public virtual INodePacket EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.NodePacketType : Enum {
    public byte value__;
    public static NodePacketType NodeConfiguration;
    public static NodePacketType BuildRequestConfiguration;
    public static NodePacketType BuildRequestConfigurationResponse;
    public static NodePacketType ProjectLoadInfo;
    public static NodePacketType BuildRequestBlocker;
    public static NodePacketType BuildRequestUnblocker;
    public static NodePacketType BuildRequest;
    public static NodePacketType BuildResult;
    public static NodePacketType LogMessage;
    public static NodePacketType NodeBuildComplete;
    public static NodePacketType NodeShutdown;
    public static NodePacketType TaskHostConfiguration;
    public static NodePacketType TaskHostTaskComplete;
    public static NodePacketType TaskHostTaskCancelled;
    public static NodePacketType ResolveSdkRequest;
    public static NodePacketType ResolveSdkResponse;
    public static NodePacketType ResourceRequest;
    public static NodePacketType ResourceResponse;
    public static NodePacketType FileAccessReport;
    public static NodePacketType ProcessReport;
    public static NodePacketType ServerNodeBuildCommand;
    public static NodePacketType ServerNodeBuildResult;
    public static NodePacketType ServerNodeConsoleWrite;
    public static NodePacketType ServerNodeBuildCancel;
}
internal class Microsoft.Build.BackEnd.NodeProviderInProc : object {
    private static int InvalidInProcNodeId;
    private bool _disposed;
    private static Semaphore InProcNodeOwningOperatingEnvironment;
    private IBuildComponentHost _componentHost;
    private INode _inProcNode;
    private INodeEndpoint _inProcNodeEndpoint;
    private INodePacketFactory _packetFactory;
    private Thread _inProcNodeThread;
    private AutoResetEvent _endpointConnectedEvent;
    private int _inProcNodeId;
    private bool _exclusiveOperatingEnvironment;
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    protected virtual override void Finalize();
    public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual IList`1<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func`2<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate);
    private bool CreateNode(int nodeId, INodePacketFactory factory, NodeConfiguration configuration);
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void Dispose();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private bool InstantiateNode(INodePacketFactory factory);
    private void InProcNodeThreadProc();
    private void InProcNodeEndpoint_OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void InProcNodeShutdown(NodeEngineShutdownReason reason, Exception e);
    private void Dispose(bool disposing);
    public sealed virtual IEnumerable`1<Process> GetProcesses();
}
internal class Microsoft.Build.BackEnd.NodeProviderOutOfProc : NodeProviderOutOfProcBase {
    private ConcurrentDictionary`2<int, NodeContext> _nodeContexts;
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    internal static Handshake GetHandshake(bool enableNodeReuse, bool enableLowPriority);
    public sealed virtual IList`1<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory factory, Func`2<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate);
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    private void NodeContextTerminated(int nodeId);
    public sealed virtual IEnumerable`1<Process> GetProcesses();
}
internal abstract class Microsoft.Build.BackEnd.NodeProviderOutOfProcBase : object {
    private static int MaxPacketWriteSize;
    private static int NodeCreationRetries;
    private static int TimeoutForNewNodeCreation;
    private static int TimeoutForWaitForExit;
    private IBuildComponentHost _componentHost;
    private ConcurrentDictionary`2<string, byte> _processesToIgnore;
    protected IBuildComponentHost ComponentHost { get; protected set; }
    protected IBuildComponentHost get_ComponentHost();
    protected void set_ComponentHost(IBuildComponentHost value);
    protected void SendData(NodeContext context, INodePacket packet);
    protected void ShutdownConnectedNodes(List`1<NodeContext> contextsToShutDown, bool enableReuse);
    protected void ShutdownAllNodes(bool nodeReuse, NodeContextTerminateDelegate terminateNode);
    protected IList`1<NodeContext> GetNodes(string msbuildLocation, string commandLineArgs, int nextNodeId, INodePacketFactory factory, Handshake hostHandshake, NodeContextCreatedDelegate createNode, NodeContextTerminateDelegate terminateNode, int numberOfNodesToCreate);
    private ValueTuple`2<string, IList`1<Process>> GetPossibleRunningNodes(string msbuildLocation);
    private string GetProcessesToIgnoreKey(Handshake hostHandshake, int nodeProcessId);
    private static void ValidateRemotePipeSecurityOnWindows(NamedPipeClientStream nodeStream);
    private Stream TryConnectToProcess(int nodeProcessId, int timeout, Handshake handshake);
    internal static void ConnectToPipeStream(NamedPipeClientStream nodeStream, string pipeName, Handshake handshake, int timeout);
}
internal class Microsoft.Build.BackEnd.NodeProviderOutOfProcTaskHost : NodeProviderOutOfProcBase {
    private static int MaxNodeCount;
    private static string s_baseTaskHostPath;
    private static string s_baseTaskHostPath64;
    private static string s_baseTaskHostPathArm64;
    private static string s_pathToX32Clr2;
    private static string s_pathToX64Clr2;
    private static string s_pathToX32Clr4;
    private static string s_pathToX64Clr4;
    private static string s_pathToArm64Clr4;
    private static string s_msbuildName;
    private static string s_msbuildTaskHostName;
    private ManualResetEvent _noNodesActiveEvent;
    private Dictionary`2<HandshakeOptions, NodeContext> _nodeContexts;
    private IDictionary`2<int, INodePacketFactory> _nodeIdToPacketFactory;
    private IDictionary`2<int, INodePacketHandler> _nodeIdToPacketHandler;
    private HashSet`1<int> _activeNodes;
    private NodePacketFactory _localPacketFactory;
    public NodeProviderType ProviderType { get; }
    public int AvailableNodes { get; }
    internal static string TaskHostNameForClr2TaskHost { get; }
    [DebuggerStepThroughAttribute]
public sealed virtual NodeProviderType get_ProviderType();
    public sealed virtual int get_AvailableNodes();
    internal static string get_TaskHostNameForClr2TaskHost();
    public sealed virtual IList`1<NodeInfo> CreateNodes(int nextNodeId, INodePacketFactory packetFactory, Func`2<NodeInfo, NodeConfiguration> configurationFactory, int numberOfNodesToCreate);
    public sealed virtual void SendData(int nodeId, INodePacket packet);
    public void SendData(HandshakeOptions hostContext, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    internal static void ClearCachedTaskHostPaths();
    internal static string GetTaskHostNameFromHostContext(HandshakeOptions hostContext);
    internal static string GetMSBuildLocationFromHostContext(HandshakeOptions hostContext);
    internal bool AcquireAndSetUpHost(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration);
    internal void DisconnectFromHost(HandshakeOptions hostContext);
    internal bool CreateNode(HandshakeOptions hostContext, INodePacketFactory factory, INodePacketHandler handler, TaskHostConfiguration configuration);
    private void NodeContextCreated(NodeContext context);
    private void NodeContextTerminated(int nodeId);
    public sealed virtual IEnumerable`1<Process> GetProcesses();
}
internal enum Microsoft.Build.BackEnd.NodeProviderType : Enum {
    public int value__;
    public static NodeProviderType InProc;
    public static NodeProviderType OutOfProc;
    public static NodeProviderType Remote;
}
internal class Microsoft.Build.BackEnd.NodeShutdown : object {
    private NodeShutdownReason _reason;
    private Exception _exception;
    public NodePacketType Type { get; }
    public NodeShutdownReason Reason { get; }
    public Exception Exception { get; }
    public NodeShutdown(NodeShutdownReason reason);
    public NodeShutdown(NodeShutdownReason reason, Exception e);
    public sealed virtual NodePacketType get_Type();
    public NodeShutdownReason get_Reason();
    public Exception get_Exception();
    public sealed virtual void Translate(ITranslator translator);
    internal static NodeShutdown FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.NodeShutdownDelegate : MulticastDelegate {
    public NodeShutdownDelegate(object object, IntPtr method);
    public virtual void Invoke(NodeEngineShutdownReason reason, Exception e);
    public virtual IAsyncResult BeginInvoke(NodeEngineShutdownReason reason, Exception e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.BackEnd.NodeShutdownReason : Enum {
    public int value__;
    public static NodeShutdownReason Requested;
    public static NodeShutdownReason Error;
    public static NodeShutdownReason ConnectionFailed;
}
internal enum Microsoft.Build.BackEnd.OutofdateReason : Enum {
    public int value__;
    public static OutofdateReason MissingInput;
    public static OutofdateReason MissingOutput;
    public static OutofdateReason NewerInput;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.PartialBuildTelemetry : object {
    private DateTime _startedAt;
    private string _initialServerState;
    private string _serverFallbackReason;
    public Nullable`1<DateTime> StartedAt { get; }
    public string InitialServerState { get; }
    public string ServerFallbackReason { get; }
    public PartialBuildTelemetry(DateTime startedAt, string initialServerState, string serverFallbackReason);
    public Nullable`1<DateTime> get_StartedAt();
    public string get_InitialServerState();
    public string get_ServerFallbackReason();
    [NullableContextAttribute("1")]
public sealed virtual void Translate(ITranslator translator);
    [NullableContextAttribute("1")]
internal static PartialBuildTelemetry FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.PropertyGroupIntrinsicTask : IntrinsicTask {
    private ProjectPropertyGroupTaskInstance _taskInstance;
    public PropertyGroupIntrinsicTask(ProjectPropertyGroupTaskInstance taskInstance, TargetLoggingContext loggingContext, ProjectInstance projectInstance, bool logTaskInputs);
    internal virtual void ExecuteTask(Lookup lookup);
    private void GetBatchableValuesFromProperty(List`1<string> parameterValues, ProjectPropertyGroupTaskPropertyInstance property);
}
internal static class Microsoft.Build.BackEnd.PropertyParser : object {
    internal static bool GetTable(TaskLoggingHelper log, string parameterName, String[] propertyList, Dictionary`2& propertiesTable);
    internal static bool GetTableWithEscaping(TaskLoggingHelper log, string parameterName, string syntaxName, String[] propertyNameValueStrings, Dictionary`2& finalPropertiesTable);
}
internal class Microsoft.Build.BackEnd.RequestBlockedDelegate : MulticastDelegate {
    public RequestBlockedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequestBlocker blocker);
    public virtual IAsyncResult BeginInvoke(BuildRequestBlocker blocker, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.RequestBuilder : object {
    private static TaskScheduler s_dedicatedScheduler;
    private ManualResetEvent _terminateEvent;
    private AutoResetEvent _continueEvent;
    private IDictionary`2<int, BuildResult> _continueResults;
    private ConcurrentQueue`1<Action`1<ResourceResponse>> _pendingResourceRequests;
    private Task _requestTask;
    private CancellationTokenSource _cancellationTokenSource;
    private BuildRequestEntry _requestEntry;
    private IBuildComponentHost _componentHost;
    private NodeLoggingContext _nodeLoggingContext;
    private ProjectLoggingContext _projectLoggingContext;
    private ITargetBuilder _targetBuilder;
    private BlockType _blockType;
    private bool _inMSBuildCallback;
    private bool _isZombie;
    [CompilerGeneratedAttribute]
private NewBuildRequestsDelegate OnNewBuildRequests;
    [CompilerGeneratedAttribute]
private BuildRequestCompletedDelegate OnBuildRequestCompleted;
    [CompilerGeneratedAttribute]
private BuildRequestBlockedDelegate OnBuildRequestBlocked;
    [CompilerGeneratedAttribute]
private ResourceRequestDelegate OnResourceRequest;
    internal BuildRequestEntry RequestEntry { get; }
    internal bool HasActiveBuildRequest { get; }
    private static RequestBuilder();
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnNewBuildRequests(NewBuildRequestsDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBuildRequestCompleted(BuildRequestCompletedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnBuildRequestBlocked(BuildRequestBlockedDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OnResourceRequest(ResourceRequestDelegate value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OnResourceRequest(ResourceRequestDelegate value);
    internal BuildRequestEntry get_RequestEntry();
    internal bool get_HasActiveBuildRequest();
    public sealed virtual void BuildRequest(NodeLoggingContext loggingContext, BuildRequestEntry entry);
    public sealed virtual void ContinueRequest();
    public sealed virtual void ContinueRequestWithResources(ResourceResponse response);
    public sealed virtual void CancelRequest();
    public sealed virtual void BeginCancel();
    public sealed virtual void WaitForCancelCompletion();
    private bool InnerExceptionsAreAllCancelledExceptions(AggregateException e);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildProjects>d__40")]
public sealed virtual Task`1<BuildResult[]> BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults, bool skipNonexistentTargets);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BlockOnTargetInProgress>d__41")]
public sealed virtual Task BlockOnTargetInProgress(int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    public sealed virtual void Yield();
    public sealed virtual void Reacquire();
    public sealed virtual void EnterMSBuildCallbackState();
    public sealed virtual void ExitMSBuildCallbackState();
    public sealed virtual int RequestCores(object monitorLockObject, int requestedCores, bool waitForCores);
    public sealed virtual void ReleaseCores(int coresToRelease);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static bool IsBuilderUsingLegacyThreadingSemantics(IBuildComponentHost host, BuildRequestEntry entry);
    internal static int WaitWithBuilderThreadStart(WaitHandle[] handles, bool recursive, LegacyThreadingData threadingData, int submissionId);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private void StartBuilderThread();
    private void SetCommonWorkerThreadParameters();
    private void VerifyEntryInReadyState();
    private void VerifyEntryInActiveState();
    private void VerifyEntryInActiveOrWaitingState();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<RequestThreadProc>d__58")]
private Task RequestThreadProc(bool setThreadParameters);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildAndReport>d__59")]
private Task BuildAndReport();
    private void ReportResultAndCleanUp(BuildResult result);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<StartNewBuildRequests>d__61")]
private Task`1<BuildResult[]> StartNewBuildRequests(FullyQualifiedBuildRequest[] requests);
    private BuildResult[] GetResultsForContinuation(FullyQualifiedBuildRequest[] requests, bool isContinue);
    private void RaiseOnNewBuildRequests(FullyQualifiedBuildRequest[] requests);
    private void RaiseBuildRequestCompleted(BuildRequestEntry entryToComplete);
    private void RaiseOnBlockedRequest(int blockingGlobalRequestId, string blockingTarget, BuildResult partialBuildResult);
    private void RaiseResourceRequest(ResourceRequest request);
    private void SetProjectCurrentDirectory();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.RequestBuilder/<BuildProject>d__68")]
private Task`1<BuildResult> BuildProject();
    private void SaveOperatingEnvironment();
    private void InitializeOperatingEnvironment();
    private void RestoreOperatingEnvironment();
    private void SetEnvironmentVariableBlock(IDictionary`2<string, string> savedEnvironment);
    private void ClearVariablesNotInEnvironment(IDictionary`2<string, string> savedEnvironment, IDictionary`2<string, string> currentEnvironment);
    private void UpdateEnvironmentVariables(IDictionary`2<string, string> savedEnvironment, IDictionary`2<string, string> currentEnvironment);
    private void VerifyIsNotZombie();
    private void ConfigureWarningsAsErrorsAndMessages();
    private void ConfigureKnownImmutableFolders();
    private ISet`1<string> ParseWarningCodes(string warnings);
    [CompilerGeneratedAttribute]
private Task <StartBuilderThread>b__53_0();
    [CompilerGeneratedAttribute]
private Task <StartBuilderThread>b__53_1();
    [CompilerGeneratedAttribute]
private Task <StartBuilderThread>b__53_2();
    [CompilerGeneratedAttribute]
private BuildResult <BuildProject>g__CopyTargetResultsFromProxyTargetsToRealTargets|68_0(BuildResult resultFromTargetBuilder);
}
internal class Microsoft.Build.BackEnd.RequestCompleteDelegate : MulticastDelegate {
    public RequestCompleteDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequest request, BuildResult result);
    public virtual IAsyncResult BeginInvoke(BuildRequest request, BuildResult result, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.RequestResumedDelegate : MulticastDelegate {
    public RequestResumedDelegate(object object, IntPtr method);
    public virtual void Invoke(BuildRequest request);
    public virtual IAsyncResult BeginInvoke(BuildRequest request, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ResourceRequest : object {
    private int _globalRequestId;
    private bool _isResourceAcquire;
    private bool _isBlocking;
    private int _numCores;
    public NodePacketType Type { get; }
    public int GlobalRequestId { get; }
    public bool IsResourceAcquire { get; }
    public bool IsBlocking { get; }
    public int NumCores { get; }
    internal ResourceRequest(ITranslator translator);
    private ResourceRequest(bool isResourceAcquire, int globalRequestId, int numCores, bool isBlocking);
    public static ResourceRequest CreateAcquireRequest(int globalRequestId, int numCores, bool isBlocking);
    public static ResourceRequest CreateReleaseRequest(int globalRequestId, int numCores);
    public sealed virtual NodePacketType get_Type();
    public int get_GlobalRequestId();
    public bool get_IsResourceAcquire();
    public bool get_IsBlocking();
    public int get_NumCores();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.ResourceRequestDelegate : MulticastDelegate {
    public ResourceRequestDelegate(object object, IntPtr method);
    public virtual void Invoke(ResourceRequest request);
    public virtual IAsyncResult BeginInvoke(ResourceRequest request, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.BackEnd.ResourceResponse : object {
    private int _globalRequestId;
    private int _numCores;
    public NodePacketType Type { get; }
    public int GlobalRequestId { get; }
    public int NumCores { get; }
    internal ResourceResponse(ITranslator translator);
    internal ResourceResponse(int globalRequestId, int numCores);
    public sealed virtual NodePacketType get_Type();
    public int get_GlobalRequestId();
    public int get_NumCores();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.ResultsCache : object {
    private ConcurrentDictionary`2<int, BuildResult> _resultsByConfiguration;
    internal IDictionary`2<int, BuildResult> ResultsDictionary { get; }
    public ResultsCache(ITranslator translator);
    internal IDictionary`2<int, BuildResult> get_ResultsDictionary();
    public sealed virtual void AddResult(BuildResult result);
    public sealed virtual void ClearResults();
    public sealed virtual BuildResult GetResultForRequest(BuildRequest request);
    public sealed virtual BuildResult GetResultsForConfiguration(int configurationId);
    public sealed virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss);
    public sealed virtual void ClearResultsForConfiguration(int configurationId);
    public sealed virtual void Translate(ITranslator translator);
    public sealed virtual void WriteResultsToDisk();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    private static bool CheckResults(BuildResult result, List`1<string> targets, HashSet`1<string> targetsMissingResults, bool skippedResultsAreOK);
    public sealed virtual IEnumerator`1<BuildResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.BackEnd.ResultsCacheResponse : ValueType {
    public ResultsCacheResponseType Type;
    public BuildResult Results;
    public HashSet`1<string> ExplicitTargetsToBuild;
    public ResultsCacheResponse(ResultsCacheResponseType type);
}
internal enum Microsoft.Build.BackEnd.ResultsCacheResponseType : Enum {
    public int value__;
    public static ResultsCacheResponseType NotSatisfied;
    public static ResultsCacheResponseType Satisfied;
}
internal class Microsoft.Build.BackEnd.SchedulableRequest : object {
    private SchedulingData _schedulingData;
    private SchedulableRequestState _state;
    private int _assignedNodeId;
    private BuildRequest _request;
    private SchedulableRequest _parent;
    private String[] _activeTargetsWhenBlocked;
    private Dictionary`2<BlockingRequestKey, SchedulableRequest> _requestsWeAreBlockedBy;
    private HashSet`1<SchedulableRequest> _requestsWeAreBlocking;
    private DateTime _creationTime;
    private DateTime _startTime;
    private DateTime _endTime;
    private Dictionary`2<SchedulableRequestState, ScheduleTimeRecord> _timeRecords;
    [CompilerGeneratedAttribute]
private string <BlockingTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GrantedCores>k__BackingField;
    public SchedulableRequestState State { get; }
    public BuildRequest BuildRequest { get; }
    public SchedulableRequest Parent { get; }
    public int AssignedNode { get; }
    public IEnumerable`1<string> ActiveTargets { get; }
    public string BlockingTarget { get; private set; }
    public int RequestsWeAreBlockedByCount { get; }
    public IEnumerable`1<SchedulableRequest> RequestsWeAreBlockedBy { get; }
    public int RequestsWeAreBlockingCount { get; }
    public IEnumerable`1<SchedulableRequest> RequestsWeAreBlocking { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public int GrantedCores { get; public set; }
    public SchedulableRequest(SchedulingData collection, BuildRequest request, SchedulableRequest parent);
    public SchedulableRequestState get_State();
    public BuildRequest get_BuildRequest();
    public SchedulableRequest get_Parent();
    public int get_AssignedNode();
    public IEnumerable`1<string> get_ActiveTargets();
    [CompilerGeneratedAttribute]
public string get_BlockingTarget();
    [CompilerGeneratedAttribute]
private void set_BlockingTarget(string value);
    public int get_RequestsWeAreBlockedByCount();
    public IEnumerable`1<SchedulableRequest> get_RequestsWeAreBlockedBy();
    public int get_RequestsWeAreBlockingCount();
    public IEnumerable`1<SchedulableRequest> get_RequestsWeAreBlocking();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_StartTime();
    public void set_StartTime(DateTime value);
    public DateTime get_EndTime();
    public void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public int get_GrantedCores();
    [CompilerGeneratedAttribute]
public void set_GrantedCores(int value);
    public TimeSpan GetTimeSpentInState(SchedulableRequestState desiredState);
    public void Yield(String[] activeTargets);
    public void Reacquire();
    public void BlockByRequest(SchedulableRequest blockingRequest, String[] activeTargets, string blockingTarget);
    public void UnblockWithPartialResultForBlockingTarget(BuildResult result);
    public void UnblockWithResult(BuildResult result);
    public void ResumeExecution(int nodeId);
    public void Complete(BuildResult result);
    public void Delete();
    public void VerifyState(SchedulableRequestState requiredState);
    public void VerifyOneOfStates(SchedulableRequestState[] requiredStates);
    public bool IsProxyBuildRequest();
    private void ChangeToState(SchedulableRequestState newState);
    private void DetectCircularDependency(SchedulableRequest blockingRequest);
    private void DetectIndirectCircularDependency(SchedulableRequest blockingRequest);
    private void ThrowIndirectCircularDependency(SchedulableRequest blockingRequest, SchedulableRequest requestToEvaluate);
    private void DetectDirectCircularDependency(SchedulableRequest blockingRequest);
    private void CleanupForCircularDependencyAndThrow(SchedulableRequest requestCausingFailure, List`1<SchedulableRequest> ancestors);
    internal void DisconnectRequestWeAreBlockedBy(BlockingRequestKey blockingRequestKey);
}
internal enum Microsoft.Build.BackEnd.SchedulableRequestState : Enum {
    public int value__;
    public static SchedulableRequestState Unscheduled;
    public static SchedulableRequestState Ready;
    public static SchedulableRequestState Executing;
    public static SchedulableRequestState Blocked;
    public static SchedulableRequestState Yielding;
    public static SchedulableRequestState Completed;
}
internal enum Microsoft.Build.BackEnd.ScheduleActionType : Enum {
    public int value__;
    public static ScheduleActionType NoAction;
    public static ScheduleActionType Schedule;
    public static ScheduleActionType ScheduleWithConfiguration;
    public static ScheduleActionType ReportResults;
    public static ScheduleActionType ResumeExecution;
    public static ScheduleActionType CreateNode;
    public static ScheduleActionType SubmissionComplete;
    public static ScheduleActionType CircularDependency;
}
internal class Microsoft.Build.BackEnd.Scheduler : object {
    internal static int InvalidNodeId;
    internal static int ResultsTransferredId;
    internal static int InProcNodeId;
    internal static int VirtualNode;
    private static double DefaultCustomSchedulerForSQLConfigurationLimitMultiplier;
    private string _schedulingUnlimitedVariable;
    private bool _schedulingUnlimited;
    private int _nodeLimitOffset;
    private int _coreLimit;
    private int _nodeCoreAllocationWeight;
    private Dictionary`2<int, NodeInfo> _availableNodes;
    private int _currentInProcNodeCount;
    private int _currentOutOfProcNodeCount;
    private SchedulingData _schedulingData;
    private Queue`1<TaskCompletionSource`1<int>> _pendingRequestCoresCallbacks;
    private IBuildComponentHost _componentHost;
    private IConfigCache _configCache;
    private IResultsCache _resultsCache;
    private int _nextGlobalRequestId;
    private bool _debugDumpState;
    private string _debugDumpPath;
    private double _customSchedulerForSQLConfigurationLimitMultiplier;
    private SchedulingPlan _schedulingPlan;
    private AssignUnscheduledRequestsDelegate _customRequestSchedulingAlgorithm;
    private NodeLoggingContext _inprocNodeContext;
    private int _loggedWarningsForProxyBuildsOnOutOfProcNodes;
    internal bool ForceAffinityOutOfProc { get; }
    public int MinimumAssignableConfigurationId { get; }
    internal bool get_ForceAffinityOutOfProc();
    public sealed virtual int get_MinimumAssignableConfigurationId();
    public sealed virtual bool IsCurrentlyBuildingConfiguration(int configurationId);
    public sealed virtual int GetConfigurationIdFromPlan(string configPath);
    public sealed virtual BuildRequest GetExecutingRequestByNode(int nodeId);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportRequestBlocked(int nodeId, BuildRequestBlocker blocker);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportResult(int nodeId, BuildResult result);
    public sealed virtual IEnumerable`1<ScheduleResponse> ReportNodesCreated(IEnumerable`1<NodeInfo> nodeInfos);
    public sealed virtual void ReportBuildAborted(int nodeId);
    public sealed virtual void Reset();
    public sealed virtual void WriteDetailedSummary(int submissionId);
    public sealed virtual Task`1<int> RequestCores(int requestId, int requestedCores, bool waitForCores);
    public sealed virtual List`1<ScheduleResponse> ReleaseCores(int requestId, int coresToRelease);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType componentType);
    private void HandleYieldAction(SchedulableRequest parentRequest, BuildRequestBlocker blocker);
    private void ScheduleUnassignedRequests(List`1<ScheduleResponse> responses);
    private void AssignUnscheduledRequestsToNodes(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private bool GetSchedulingPlanAndAlgorithm();
    private void AssignUnscheduledRequestsWithPlanByMostImmediateReferences(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithPlanByGreatestPlanTime(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithPlan(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes, Func`3<PlanConfigData, PlanConfigData, bool> comparisonFunction);
    private void AssignUnscheduledRequestsByTraversalsFirst(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledProxyBuildRequestsToInProcNode(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsToInProcNode(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes, Func`2<SchedulableRequest, bool> shouldBeScheduled);
    private bool IsTraversalRequest(BuildRequest request);
    private void AssignUnscheduledRequestsWithConfigurationCountLevelling(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithSmallestFileSize(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithLargestFileSize(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithMaxWaitingRequests(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsWithMaxWaitingRequests2(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsFIFO(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestsUsingCustomSchedulerForSQL(List`1<ScheduleResponse> responses, HashSet`1<int> idleNodes);
    private void AssignUnscheduledRequestToNode(SchedulableRequest request, int nodeId, List`1<ScheduleResponse> responses);
    private int GetAvailableCoresForExplicitRequests();
    private bool AtSchedulingLimit();
    private bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId);
    private bool CreateNewNodeIfPossible(List`1<ScheduleResponse> responses, IEnumerable`1<SchedulableRequest> requests);
    private void MarkRequestAborted(SchedulableRequest request);
    private void HandleRequestBlockedOnInProgressTarget(SchedulableRequest blockedRequest, BuildRequestBlocker blocker);
    private void HandleRequestBlockedOnResultsTransfer(SchedulableRequest parentRequest, List`1<ScheduleResponse> responses);
    private void HandleRequestBlockedByNewRequests(SchedulableRequest parentRequest, BuildRequestBlocker blocker, List`1<ScheduleResponse> responses);
    private void ResumeReadyRequestIfAny(int nodeId, List`1<ScheduleResponse> responses);
    private void ResolveRequestFromCacheAndResumeIfPossible(SchedulableRequest request, List`1<ScheduleResponse> responses);
    private void HandlePendingResourceRequests();
    private void ResumeRequiredWork(List`1<ScheduleResponse> responses);
    private ScheduleResponse TrySatisfyRequestFromCache(int nodeForResults, BuildRequest request, bool skippedResultsDoNotCauseCacheMiss);
    private bool CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot(int nodeForResults, BuildRequest request, List`1<ScheduleResponse> responses, Action`1& emitNonErrorLogs);
    internal void RecordResultToCurrentCacheIfConfigNotInOverrideCache(BuildResult result);
    private ScheduleResponse GetResponseForResult(int parentRequestNode, BuildRequest requestWhichGeneratedResult, BuildResult result);
    private void LogRequestHandledFromCache(BuildRequest request, BuildResult result);
    private int ComputeClosureOfWaitingRequests(SchedulableRequest request);
    private NodeAffinity GetNodeAffinityForRequest(BuildRequest request);
    private bool RequestOrAnyItIsBlockedByCanBeServiced(SchedulableRequest request);
    private void AssignGlobalRequestId(BuildRequest request);
    private void WriteNodeUtilizationGraph(ILoggingService loggingService, BuildEventContext context, bool useConfigurations);
    private void WriteNodeUtilizationGraphLine(ILoggingService loggingService, BuildEventContext context, Int32[] currentWork, Int32[] previousWork, DateTime currentEventTime, DateTime previousEventTime, int invalidWorkId, Double& accumulatedDuration);
    private void WriteRecursiveSummary(ILoggingService loggingService, BuildEventContext context, int submissionId, SchedulableRequest request, int level, bool useConfigurations, bool isLastChild);
    private void TraceScheduler(string format, Object[] stuff);
    private void DumpSchedulerState();
    private void DumpConfigurations();
    private void DumpRequests();
    private void DumpRequestHierarchy(StreamWriter file, SchedulableRequest root, int indent);
    private void DumpRequestState(StreamWriter file, SchedulableRequest request, int indent);
    private void DumpRequestSpec(StreamWriter file, SchedulableRequest request, int indent, string prefix);
    private void WriteSchedulingPlan(int submissionId);
    private void ReadSchedulingPlan(int submissionId);
    [CompilerGeneratedAttribute]
private bool <AssignUnscheduledRequestsByTraversalsFirst>b__53_0(SchedulableRequest request);
    [CompilerGeneratedAttribute]
private int <AssignUnscheduledRequestsWithConfigurationCountLevelling>b__57_0(int left, int right);
    [CompilerGeneratedAttribute]
private void <AssignUnscheduledRequestToNode>g__WarnWhenProxyBuildsGetScheduledOnOutOfProcNode|64_0(<>c__DisplayClass64_0& );
    [CompilerGeneratedAttribute]
internal static string <CheckIfCacheMissOnReferencedProjectIsAllowedAndErrorIfNot>g__ConcatenateGlobalProperties|78_3(BuildRequestConfiguration configuration);
}
internal class Microsoft.Build.BackEnd.SchedulerCircularDependencyException : BuildExceptionBase {
    private IList`1<SchedulableRequest> _ancestors;
    private BuildRequest _request;
    public IEnumerable`1<SchedulableRequest> Ancestors { get; }
    public BuildRequest Request { get; }
    public SchedulerCircularDependencyException(BuildRequest request, IList`1<SchedulableRequest> ancestors);
    internal SchedulerCircularDependencyException(string message, Exception inner);
    public IEnumerable`1<SchedulableRequest> get_Ancestors();
    public BuildRequest get_Request();
}
internal class Microsoft.Build.BackEnd.ScheduleResponse : object {
    internal ScheduleActionType Action;
    internal int NodeId;
    internal BuildResult BuildResult;
    internal BuildRequest BuildRequest;
    internal BuildRequestUnblocker Unblocker;
    internal NodeAffinity RequiredNodeType;
    internal int NumberOfNodesToCreate;
    internal ScheduleResponse(ScheduleActionType type);
    private ScheduleResponse(NodeAffinity affinity, int count);
    private ScheduleResponse(BuildResult result);
    private ScheduleResponse(int nodeId, BuildRequest parentRequest, BuildRequest requestCausingCircularDependency);
    private ScheduleResponse(int node, BuildRequest request, bool sendConfiguration);
    private ScheduleResponse(int node, BuildRequestUnblocker unblocker);
    public static ScheduleResponse CreateScheduleResponse(int node, BuildRequest requestToSchedule, bool sendConfiguration);
    public static ScheduleResponse CreateReportResultResponse(int node, BuildResult resultToReport);
    public static ScheduleResponse CreateResumeExecutionResponse(int node, int globalRequestIdToResume);
    public static ScheduleResponse CreateCircularDependencyResponse(int node, BuildRequest parentRequest, BuildRequest requestCausingCircularDependency);
    public static ScheduleResponse CreateSubmissionCompleteResponse(BuildResult rootRequestResult);
    public static ScheduleResponse CreateNewNodeResponse(NodeAffinity typeOfNodeToCreate, int count);
    public virtual string ToString();
}
internal class Microsoft.Build.BackEnd.ScheduleTimeRecord : object {
    private DateTime _startTimeForCurrentState;
    private TimeSpan _accumulatedTime;
    public TimeSpan AccumulatedTime { get; }
    public TimeSpan get_AccumulatedTime();
    public void StartState(DateTime currentTime);
    public void EndState(DateTime currentTime);
}
internal class Microsoft.Build.BackEnd.SchedulingData : object {
    private Dictionary`2<int, SchedulableRequest> _executingRequests;
    private Dictionary`2<int, SchedulableRequest> _blockedRequests;
    private Dictionary`2<int, SchedulableRequest> _yieldingRequests;
    private Dictionary`2<int, SchedulableRequest> _readyRequests;
    private LinkedList`1<SchedulableRequest> _unscheduledRequests;
    private Dictionary`2<SchedulableRequest, LinkedListNode`1<SchedulableRequest>> _unscheduledRequestNodesByRequest;
    private Dictionary`2<int, HashSet`1<SchedulableRequest>> _scheduledRequestsByNode;
    private Dictionary`2<int, SchedulableRequest> _executingRequestByNode;
    private Dictionary`2<int, HashSet`1<SchedulableRequest>> _readyRequestsByNode;
    private Dictionary`2<int, HashSet`1<int>> _configurationsByNode;
    private Dictionary`2<int, int> _configurationToNode;
    private Dictionary`2<int, HashSet`1<SchedulableRequest>> _configurationToRequests;
    private int _grantedCores;
    private Dictionary`2<SchedulableRequest, List`1<SchedulableRequest>> _buildHierarchy;
    private List`1<SchedulingEvent> _buildEvents;
    private DateTime _currentEventTime;
    public IEnumerable`1<SchedulingEvent> BuildEvents { get; }
    public IEnumerable`1<SchedulableRequest> ExecutingRequests { get; }
    public int ExecutingRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> ReadyRequests { get; }
    public int ReadyRequestsCount { get; }
    public int ExplicitlyGrantedCores { get; }
    public IEnumerable`1<SchedulableRequest> BlockedRequests { get; }
    public int BlockedRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> YieldingRequests { get; }
    public int YieldingRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> UnscheduledRequests { get; }
    public int UnscheduledRequestsCount { get; }
    public IEnumerable`1<SchedulableRequest> UnscheduledRequestsWhichCanBeScheduled { get; }
    public IEnumerable`1<int> Configurations { get; }
    public DateTime EventTime { get; public set; }
    public IEnumerable`1<SchedulingEvent> get_BuildEvents();
    public IEnumerable`1<SchedulableRequest> get_ExecutingRequests();
    public int get_ExecutingRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_ReadyRequests();
    public int get_ReadyRequestsCount();
    public int get_ExplicitlyGrantedCores();
    public IEnumerable`1<SchedulableRequest> get_BlockedRequests();
    public int get_BlockedRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_YieldingRequests();
    public int get_YieldingRequestsCount();
    public IEnumerable`1<SchedulableRequest> get_UnscheduledRequests();
    public int get_UnscheduledRequestsCount();
    [IteratorStateMachineAttribute("Microsoft.Build.BackEnd.SchedulingData/<get_UnscheduledRequestsWhichCanBeScheduled>d__42")]
public IEnumerable`1<SchedulableRequest> get_UnscheduledRequestsWhichCanBeScheduled();
    public IEnumerable`1<int> get_Configurations();
    public DateTime get_EventTime();
    public void set_EventTime(DateTime value);
    public SchedulableRequest CreateRequest(BuildRequest buildRequest, SchedulableRequest parent);
    public void UpdateFromState(SchedulableRequest request, SchedulableRequestState previousState);
    public IEnumerable`1<SchedulableRequest> GetRequestsAssignedToConfiguration(int configurationId);
    public int GetRequestsAssignedToConfigurationCount(int configurationId);
    public SchedulableRequest GetExecutingRequest(int globalRequestId);
    public SchedulableRequest GetBlockedRequest(int globalRequestId);
    public SchedulableRequest GetBlockedRequestIfAny(int globalRequestId);
    public SchedulableRequest GetYieldingRequest(int globalRequestId);
    public SchedulableRequest GetReadyRequest(int globalRequestId);
    public SchedulableRequest GetScheduledRequest(int globalRequestId);
    public bool IsNodeWorking(int nodeId);
    public int GetConfigurationsCountByNode(int nodeId, bool excludeTraversals, IConfigCache configCache);
    public SchedulableRequest GetExecutingRequestByNode(int nodeId);
    public bool IsRequestScheduled(SchedulableRequest request);
    public int GetScheduledRequestsCountByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetScheduledRequestsByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetReadyRequestsByNode(int nodeId);
    public IEnumerable`1<SchedulableRequest> GetRequestsByHierarchy(SchedulableRequest root);
    public int GetAssignedNodeForRequestConfiguration(int configurationId);
    public bool CanScheduleRequestToNode(SchedulableRequest request, int nodeId);
    public bool CanScheduleConfigurationToNode(int configurationId, int nodeId);
    public void GrantCoresToRequest(int globalRequestId, int coresToGrant);
    public void RemoveCoresFromRequest(int globalRequestId, int coresToRemove);
    internal void UnassignNodeForRequestConfiguration(int configurationId);
    private SchedulableRequest InternalGetScheduledRequestByGlobalRequestId(int globalRequestId);
    private void ExpectScheduledRequestState(int globalRequestId, SchedulableRequestState state);
}
internal class Microsoft.Build.BackEnd.SchedulingPlan : object {
    private IConfigCache _configCache;
    private SchedulingData _schedulingData;
    private Dictionary`2<string, PlanConfigData> _configPathToData;
    private Dictionary`2<int, PlanConfigData> _configIdToData;
    private Dictionary`2<int, List`1<Stack`1<PlanConfigData>>> _configIdToPaths;
    [CompilerGeneratedAttribute]
private bool <IsPlanValid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumConfigurationId>k__BackingField;
    public bool IsPlanValid { get; private set; }
    public int MaximumConfigurationId { get; private set; }
    public SchedulingPlan(IConfigCache configCache, SchedulingData schedulingData);
    public PlanConfigData GetConfiguration(int configId);
    [CompilerGeneratedAttribute]
public bool get_IsPlanValid();
    [CompilerGeneratedAttribute]
private void set_IsPlanValid(bool value);
    [CompilerGeneratedAttribute]
public int get_MaximumConfigurationId();
    [CompilerGeneratedAttribute]
private void set_MaximumConfigurationId(int value);
    public void WritePlan(int submissionId, ILoggingService loggingService, BuildEventContext buildEventContext);
    public void ReadPlan(int submissionId, ILoggingService loggingService, BuildEventContext buildEventContext);
    public int GetConfigIdForPath(string configPath);
    private string GetPlanName(SchedulableRequest rootRequest);
    private void AnalyzeData();
    private void DetermineConfigsWithGreatestPlanTime();
    private void DetermineConfigsWithTheMostImmediateReferences();
    private void DetermineConfigsByNumberOfOccurrences();
    private void DoRecursiveAnalysis();
    private void RecursiveVisitNodes(PlanConfigData root, Stack`1<PlanConfigData> currentPath);
    private void DetermineExpensiveConfigs();
    private void ReadHierarchy(StreamReader file);
    private void ReadTimes(StreamReader file);
    private SchedulableRequest GetRootRequest(int submissionId);
    private void RecursiveWriteDependencies(StreamWriter file, SchedulableRequest request);
    private void RecursiveAccumulateConfigurationTimes(SchedulableRequest request, Dictionary`2<int, double> accumulatedTimeByConfiguration);
    [CompilerGeneratedAttribute]
private int <DetermineConfigsByNumberOfOccurrences>b__22_0(int left, int right);
}
internal class Microsoft.Build.BackEnd.SdkResolution.CachingSdkResolverService : SdkResolverService {
    private ConcurrentDictionary`2<int, ConcurrentDictionary`2<string, Lazy`1<SdkResult>>> _cache;
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private SdkResult <>n__0(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
}
internal class Microsoft.Build.BackEnd.SdkResolution.DefaultSdkResolver : SdkResolver {
    public string Name { get; }
    public int Priority { get; }
    public virtual string get_Name();
    public virtual int get_Priority();
    public virtual SdkResult Resolve(SdkReference sdk, SdkResolverContext context, SdkResultFactory factory);
}
internal abstract class Microsoft.Build.BackEnd.SdkResolution.HostedSdkResolverServiceBase : object {
    protected AutoResetEvent ShutdownEvent;
    protected IBuildComponentHost Host;
    [CompilerGeneratedAttribute]
private Action`1<INodePacket> <SendPacket>k__BackingField;
    public Action`1<INodePacket> SendPacket { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<INodePacket> get_SendPacket();
    [CompilerGeneratedAttribute]
public void set_SendPacket(Action`1<INodePacket> value);
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual void InitializeComponent(IBuildComponentHost host);
    public abstract virtual void PacketReceived(int node, INodePacket packet);
    public abstract virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
    public virtual void ShutdownComponent();
}
internal interface Microsoft.Build.BackEnd.SdkResolution.ISdkResolverService {
    public Action`1<INodePacket> SendPacket { get; }
    public abstract virtual Action`1<INodePacket> get_SendPacket();
    public abstract virtual void ClearCache(int submissionId);
    public abstract virtual void ClearCaches();
    public abstract virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
}
internal class Microsoft.Build.BackEnd.SdkResolution.MainNodeSdkResolverService : HostedSdkResolverServiceBase {
    private ISdkResolverService _cachedSdkResolver;
    public static IBuildComponent CreateComponent(BuildComponentType type);
    internal void InitializeForTests(SdkResolverLoader resolverLoader, IList`1<SdkResolver> resolvers);
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual void PacketReceived(int node, INodePacket packet);
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
}
internal class Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverService : HostedSdkResolverServiceBase {
    private ConcurrentDictionary`2<string, Lazy`1<SdkResult>> _responseCache;
    private AutoResetEvent _responseReceivedEvent;
    private SdkResult modreq(System.Runtime.CompilerServices.IsVolatile) _lastResponse;
    public OutOfProcNodeSdkResolverService(Action`1<INodePacket> sendPacket);
    public virtual void PacketReceived(int node, INodePacket packet);
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
    public virtual void ShutdownComponent();
    private void HandleResponse(SdkResult response);
    private SdkResult RequestSdkPathFromMainNode(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
}
internal class Microsoft.Build.BackEnd.SdkResolution.OutOfProcNodeSdkResolverServiceFactory : object {
    private Action`1<INodePacket> _sendPacket;
    public OutOfProcNodeSdkResolverServiceFactory(Action`1<INodePacket> sendPacket);
    public IBuildComponent CreateInstance(BuildComponentType type);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkLogger : SdkLogger {
    private LoggingContext _loggingContext;
    public SdkLogger(LoggingContext loggingContext);
    public virtual void LogMessage(string message, MessageImportance messageImportance);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverContext : SdkResolverContext {
    public SdkResolverContext(SdkLogger logger, string projectFilePath, string solutionPath, Version msBuildVersion, bool interactive, bool isRunningInVisualStudio);
}
public class Microsoft.Build.BackEnd.SdkResolution.SdkResolverException : BuildExceptionBase {
    [CompilerGeneratedAttribute]
private SdkResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SdkReference <Sdk>k__BackingField;
    public SdkResolver Resolver { get; private set; }
    public SdkReference Sdk { get; private set; }
    public SdkResolverException(string resourceName, SdkResolver resolver, SdkReference sdk, Exception innerException, String[] args);
    internal SdkResolverException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public SdkResolver get_Resolver();
    [CompilerGeneratedAttribute]
private void set_Resolver(SdkResolver value);
    [CompilerGeneratedAttribute]
public SdkReference get_Sdk();
    [CompilerGeneratedAttribute]
private void set_Sdk(SdkReference value);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverLoader : object {
    private string IncludeDefaultResolver;
    private string AdditionalResolversFolder;
    internal virtual IList`1<SdkResolver> GetDefaultResolvers(LoggingContext loggingContext, ElementLocation location);
    internal virtual IList`1<SdkResolver> LoadAllResolvers(LoggingContext loggingContext, ElementLocation location);
    internal virtual IList`1<SdkResolverManifest> GetResolversManifests(LoggingContext loggingContext, ElementLocation location);
    internal virtual IList`1<string> FindPotentialSdkResolvers(string rootFolder, ElementLocation location);
    internal virtual IList`1<SdkResolverManifest> FindPotentialSdkResolversManifests(string rootFolder, ElementLocation location);
    private DirectoryInfo[] GetSubfolders(string rootFolder, string additionalResolversFolder);
    private bool TryAddAssemblyManifestFromXml(string pathToManifest, string manifestFolder, List`1<SdkResolverManifest> manifestsList, ElementLocation location);
    private bool TryAddAssemblyManifestFromDll(string assemblyPath, List`1<SdkResolverManifest> manifestsList);
    protected virtual IEnumerable`1<Type> GetResolverTypes(Assembly assembly);
    protected virtual Assembly LoadResolverAssembly(string resolverPath, LoggingContext loggingContext, ElementLocation location);
    protected internal virtual IList`1<SdkResolver> LoadResolversFromManifest(SdkResolverManifest manifest, LoggingContext loggingContext, ElementLocation location);
    protected virtual void LoadResolvers(string resolverPath, LoggingContext loggingContext, ElementLocation location, List`1<SdkResolver> resolvers);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverManifest : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Regex <ResolvableSdkRegex>k__BackingField;
    private static int SdkResolverPatternRegexTimeoutMsc;
    public string DisplayName { get; public set; }
    public string Path { get; public set; }
    public Regex ResolvableSdkRegex { get; public set; }
    public SdkResolverManifest(string DisplayName, string Path, Regex ResolvableSdkRegex);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public Regex get_ResolvableSdkRegex();
    [CompilerGeneratedAttribute]
public void set_ResolvableSdkRegex(Regex value);
    internal static SdkResolverManifest Load(string filePath);
    private static SdkResolverManifest ParseSdkResolverElement(XmlReader reader, string filePath);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverRequest : object {
    private BuildEventContext _buildEventContext;
    private ElementLocation _elementLocation;
    private string _minimumVersion;
    private string _name;
    private string _projectPath;
    private string _solutionPath;
    private int _submissionId;
    private string _version;
    private bool _interactive;
    private bool _isRunningInVisualStudio;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    public BuildEventContext BuildEventContext { get; }
    public ElementLocation ElementLocation { get; }
    public bool Interactive { get; }
    public bool IsRunningInVisualStudio { get; }
    public string MinimumVersion { get; }
    public string Name { get; }
    public int NodeId { get; public set; }
    public string ProjectPath { get; }
    public string SolutionPath { get; }
    public int SubmissionId { get; }
    public NodePacketType Type { get; }
    public string Version { get; }
    public SdkResolverRequest(ITranslator translator);
    private SdkResolverRequest(int submissionId, string name, string version, string minimumVersion, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
    public BuildEventContext get_BuildEventContext();
    public ElementLocation get_ElementLocation();
    public bool get_Interactive();
    public bool get_IsRunningInVisualStudio();
    public string get_MinimumVersion();
    public string get_Name();
    [CompilerGeneratedAttribute]
public int get_NodeId();
    [CompilerGeneratedAttribute]
public void set_NodeId(int value);
    public string get_ProjectPath();
    public string get_SolutionPath();
    public int get_SubmissionId();
    public sealed virtual NodePacketType get_Type();
    public string get_Version();
    public static SdkResolverRequest Create(int submissionId, SdkReference sdkReference, BuildEventContext buildEventContext, ElementLocation elementLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio);
    public static INodePacket FactoryForDeserialization(ITranslator translator);
    public sealed virtual void Translate(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResolverService : object {
    private static Lazy`1<SdkResolverService> InstanceLazy;
    private object _lockObject;
    private ConcurrentDictionary`2<int, ConcurrentDictionary`2<SdkResolver, object>> _resolverStateBySubmission;
    private IList`1<SdkResolver> _resolversList;
    private Dictionary`2<SdkResolverManifest, IList`1<SdkResolver>> _manifestToResolvers;
    private IList`1<SdkResolverManifest> _specificResolversManifestsRegistry;
    private IList`1<SdkResolverManifest> _generalResolversManifestsRegistry;
    private SdkResolverLoader _sdkResolverLoader;
    [CompilerGeneratedAttribute]
private Action`1<INodePacket> <SendPacket>k__BackingField;
    public static SdkResolverService Instance { get; }
    public Action`1<INodePacket> SendPacket { get; }
    private static SdkResolverService();
    public static SdkResolverService get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual Action`1<INodePacket> get_SendPacket();
    public static bool IsReferenceSameVersion(SdkReference sdk, string version);
    public virtual void ClearCache(int submissionId);
    public virtual void ClearCaches();
    public virtual SdkResult ResolveSdk(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
    private SdkResult ResolveSdkUsingResolversWithPatternsFirst(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, bool failOnUnresolvedSdk);
    private List`1<SdkResolver> GetResolvers(IList`1<SdkResolverManifest> resolversManifests, LoggingContext loggingContext, ElementLocation sdkReferenceLocation);
    private SdkResult ResolveSdkUsingAllResolvers(int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, IEnumerable`1& errors, IEnumerable`1& warnings);
    private bool TryResolveSdkUsingSpecifiedResolvers(IList`1<SdkResolver> resolvers, int submissionId, SdkReference sdk, LoggingContext loggingContext, ElementLocation sdkReferenceLocation, string solutionPath, string projectPath, bool interactive, bool isRunningInVisualStudio, SdkResult& sdkResult, IEnumerable`1& errors, IEnumerable`1& warnings);
    internal void InitializeForTests(SdkResolverLoader resolverLoader, IList`1<SdkResolver> resolvers);
    private static void LogWarnings(LoggingContext loggingContext, ElementLocation location, IEnumerable`1<string> warnings);
    private object GetResolverState(int submissionId, SdkResolver resolver);
    private void Initialize(LoggingContext loggingContext, ElementLocation location);
    private void RegisterResolversManifests(LoggingContext loggingContext, ElementLocation location);
    private void SetResolverState(int submissionId, SdkResolver resolver, object state);
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResult : SdkResult {
    [CompilerGeneratedAttribute]
private ElementLocation <ElementLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Warnings>k__BackingField;
    public ElementLocation ElementLocation { get; public set; }
    public IEnumerable`1<string> Errors { get; }
    public IEnumerable`1<string> Warnings { get; }
    public NodePacketType Type { get; }
    public SdkResult(ITranslator translator);
    public SdkResult(SdkReference sdkReference, IEnumerable`1<string> errors, IEnumerable`1<string> warnings);
    public SdkResult(SdkReference sdkReference, string path, string version, IEnumerable`1<string> warnings, IDictionary`2<string, string> propertiesToAdd, IDictionary`2<string, SdkResultItem> itemsToAdd);
    public SdkResult(SdkReference sdkReference, IEnumerable`1<string> paths, string version, IDictionary`2<string, string> propertiesToAdd, IDictionary`2<string, SdkResultItem> itemsToAdd, IEnumerable`1<string> warnings);
    [CompilerGeneratedAttribute]
public ElementLocation get_ElementLocation();
    [CompilerGeneratedAttribute]
public void set_ElementLocation(ElementLocation value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Warnings();
    public sealed virtual void Translate(ITranslator translator);
    public sealed virtual NodePacketType get_Type();
    public static INodePacket FactoryForDeserialization(ITranslator translator);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.Build.BackEnd.SdkResolution.SdkResultFactory : SdkResultFactory {
    private SdkReference _sdkReference;
    internal SdkResultFactory(SdkReference sdkReference);
    public virtual SdkResult IndicateFailure(IEnumerable`1<string> errors, IEnumerable`1<string> warnings);
    public virtual SdkResult IndicateSuccess(string path, string version, IEnumerable`1<string> warnings);
    public virtual SdkResult IndicateSuccess(string path, string version, IDictionary`2<string, string> propertiesToAdd, IDictionary`2<string, SdkResultItem> itemsToAdd, IEnumerable`1<string> warnings);
    public virtual SdkResult IndicateSuccess(IEnumerable`1<string> paths, string version, IDictionary`2<string, string> propertiesToAdd, IDictionary`2<string, SdkResultItem> itemsToAdd, IEnumerable`1<string> warnings);
}
[ExtensionAttribute]
internal static class Microsoft.Build.BackEnd.SdkResolution.SdkResultTranslationHelpers : object {
    [ExtensionAttribute]
public static void Translate(ITranslator t, SdkReference& sdkReference);
    [ExtensionAttribute]
public static void Translate(ITranslator t, SdkResultItem& item);
}
internal static class Microsoft.Build.BackEnd.SerializationContractInitializer : object {
    public static void Initialize();
    private static void RegisterExceptions();
}
internal class Microsoft.Build.BackEnd.ServerNodeBuildCancel : object {
    public NodePacketType Type { get; }
    public sealed virtual NodePacketType get_Type();
    [NullableContextAttribute("1")]
public sealed virtual void Translate(ITranslator translator);
    [NullableContextAttribute("1")]
internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.ServerNodeBuildCommand : object {
    private string _commandLine;
    private string _startupDirectory;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    private CultureInfo _culture;
    private CultureInfo _uiCulture;
    private TargetConsoleConfiguration _consoleConfiguration;
    [NullableAttribute("2")]
private PartialBuildTelemetry _partialBuildTelemetry;
    public NodePacketType Type { get; }
    public string CommandLine { get; }
    public string StartupDirectory { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; }
    public CultureInfo UICulture { get; }
    public TargetConsoleConfiguration ConsoleConfiguration { get; }
    [NullableAttribute("2")]
public PartialBuildTelemetry PartialBuildTelemetry { get; }
    public ServerNodeBuildCommand(string commandLine, string startupDirectory, Dictionary`2<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture, TargetConsoleConfiguration consoleConfiguration, PartialBuildTelemetry partialBuildTelemetry);
    public sealed virtual NodePacketType get_Type();
    public string get_CommandLine();
    public string get_StartupDirectory();
    public Dictionary`2<string, string> get_BuildProcessEnvironment();
    public CultureInfo get_Culture();
    public CultureInfo get_UICulture();
    public TargetConsoleConfiguration get_ConsoleConfiguration();
    [NullableContextAttribute("2")]
public PartialBuildTelemetry get_PartialBuildTelemetry();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.ServerNodeBuildResult : object {
    private int _exitCode;
    private string _exitType;
    public NodePacketType Type { get; }
    public int ExitCode { get; }
    public string ExitType { get; }
    public ServerNodeBuildResult(int exitCode, string exitType);
    public sealed virtual NodePacketType get_Type();
    public int get_ExitCode();
    public string get_ExitType();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.ServerNodeConsoleWrite : object {
    private string _text;
    private ConsoleOutput _outputType;
    public NodePacketType Type { get; }
    public string Text { get; }
    public ConsoleOutput OutputType { get; }
    public ServerNodeConsoleWrite(string text, ConsoleOutput outputType);
    public sealed virtual NodePacketType get_Type();
    public string get_Text();
    public ConsoleOutput get_OutputType();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.BackEnd.ServerNodeEndpointOutOfProc : NodeEndpointOutOfProcBase {
    private Handshake _handshake;
    internal ServerNodeEndpointOutOfProc(string pipeName, Handshake handshake);
    protected virtual Handshake GetHandshake();
}
internal class Microsoft.Build.BackEnd.TargetBuilder : object {
    private CancellationToken _cancellationToken;
    private ConcurrentStack`1<TargetEntry> _targetsToBuild;
    private IBuildComponentHost _componentHost;
    private BuildRequestEntry _requestEntry;
    private Lookup _baseLookup;
    private IRequestBuilderCallback _requestBuilderCallback;
    private ProjectLoggingContext _projectLoggingContext;
    private BuildResult _buildResult;
    private ProjectInstance _projectInstance;
    private bool _legacyCallTargetContinueOnError;
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<BuildTargets>d__10")]
public sealed virtual Task`1<BuildResult> BuildTargets(ProjectLoggingContext loggingContext, BuildRequestEntry entry, IRequestBuilderCallback callback, String[] targetNames, Lookup baseLookup, CancellationToken cancellationToken);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<Microsoft-Build-BackEnd-ITargetBuilderCallback-LegacyCallTarget>d__13")]
private sealed virtual override Task`1<ITargetResult[]> Microsoft.Build.BackEnd.ITargetBuilderCallback.LegacyCallTarget(String[] targets, bool continueOnError, ElementLocation taskLocation);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<Microsoft-Build-BackEnd-IRequestBuilderCallback-BuildProjects>d__14")]
private sealed virtual override Task`1<BuildResult[]> Microsoft.Build.BackEnd.IRequestBuilderCallback.BuildProjects(String[] projectFiles, PropertyDictionary`1[] properties, String[] toolsVersions, String[] targets, bool waitForResults, bool skipNonexistentTargets);
    private sealed virtual override Task Microsoft.Build.BackEnd.IRequestBuilderCallback.BlockOnTargetInProgress(int blockingGlobalBuildRequestId, string blockingTarget, BuildResult partialBuildResult);
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.Yield();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.Reacquire();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.EnterMSBuildCallbackState();
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.ExitMSBuildCallbackState();
    private sealed virtual override int Microsoft.Build.BackEnd.IRequestBuilderCallback.RequestCores(object monitorLockObject, int requestedCores, bool waitForCores);
    private sealed virtual override void Microsoft.Build.BackEnd.IRequestBuilderCallback.ReleaseCores(int coresToRelease);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<ProcessTargetStack>d__23")]
private Task ProcessTargetStack(ITaskBuilder taskBuilder);
    private bool CheckSkipTarget(Boolean& stopProcessingStack, TargetEntry currentTargetEntry);
    private void PopDependencyTargetsOnTargetFailure(TargetEntry topEntry, TargetResult targetResult, Boolean& stopProcessingStack);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<PushTargets>d__26")]
private Task`1<bool> PushTargets(IList`1<TargetSpecification> targets, TargetEntry parentTargetEntry, Lookup baseLookup, bool addAsErrorTarget, bool stopProcessingOnCompletion, TargetBuiltReason buildReason);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetBuilder/<CompleteOutstandingActiveRequests>d__27")]
private Task`1<bool> CompleteOutstandingActiveRequests(string targetName);
    private void ComputeAfterTargetFailures(String[] targetNames);
    private bool HasCircularDependenceInTargets(TargetEntry parentTargetEntry, TargetSpecification targetSpecification, List`1& circularDependenceChain);
}
[DebuggerDisplayAttribute("Name={_targetSpecification.TargetName} State={_state} Result={_targetResult.ResultCode}")]
internal class Microsoft.Build.BackEnd.TargetEntry : object {
    private BuildRequestEntry _requestEntry;
    private TargetSpecification _targetSpecification;
    private ProjectTargetInstance _target;
    private TargetEntryState _state;
    private TargetResult _targetResult;
    private TargetEntry _parentTarget;
    private TargetBuiltReason _buildReason;
    private Expander`2<ProjectPropertyInstance, ProjectItemInstance> _expander;
    private Lookup _baseLookup;
    private IBuildComponentHost _host;
    private ITargetBuilderCallback _targetBuilderCallback;
    private Stack`1<Scope> _legacyCallTargetScopes;
    private CancellationToken _cancellationToken;
    private bool _isExecuting;
    private ITaskBuilder _currentTaskBuilder;
    [CompilerGeneratedAttribute]
private bool <ErrorTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopProcessingOnCompletion>k__BackingField;
    internal bool ErrorTarget { get; internal set; }
    internal ElementLocation ReferenceLocation { get; }
    internal bool StopProcessingOnCompletion { get; internal set; }
    internal string Name { get; }
    internal TargetEntryState State { get; }
    internal TargetResult Result { get; }
    internal Lookup Lookup { get; }
    internal ProjectTargetInstance Target { get; }
    internal BuildRequestEntry RequestEntry { get; }
    internal TargetEntry ParentEntry { get; }
    internal TargetBuiltReason BuildReason { get; }
    internal TargetEntry(BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, TargetSpecification targetSpecification, Lookup baseLookup, TargetEntry parentTarget, TargetBuiltReason buildReason, IBuildComponentHost host, bool stopProcessingOnCompletion);
    [CompilerGeneratedAttribute]
internal bool get_ErrorTarget();
    [CompilerGeneratedAttribute]
internal void set_ErrorTarget(bool value);
    internal ElementLocation get_ReferenceLocation();
    [CompilerGeneratedAttribute]
internal bool get_StopProcessingOnCompletion();
    [CompilerGeneratedAttribute]
internal void set_StopProcessingOnCompletion(bool value);
    internal string get_Name();
    internal TargetEntryState get_State();
    internal TargetResult get_Result();
    internal Lookup get_Lookup();
    internal ProjectTargetInstance get_Target();
    internal BuildRequestEntry get_RequestEntry();
    internal TargetEntry get_ParentEntry();
    internal TargetBuiltReason get_BuildReason();
    public sealed virtual bool Equals(TargetEntry other);
    internal List`1<TargetSpecification> GetDependencies(ProjectLoggingContext projectLoggingContext);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetEntry/<ExecuteTarget>d__44")]
internal Task ExecuteTarget(ITaskBuilder taskBuilder, BuildRequestEntry requestEntry, ProjectLoggingContext projectLoggingContext, CancellationToken cancellationToken);
    internal List`1<TargetSpecification> GetErrorTargets(ProjectLoggingContext projectLoggingContext);
    internal TargetResult GatherResults();
    internal void EnterLegacyCallTargetScope(Lookup lookup);
    internal void MarkForError();
    internal void MarkForStop();
    internal void LeaveLegacyCallTargetScopes();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TargetEntry/<ProcessBucket>d__51")]
private Task`1<WorkUnitResult> ProcessBucket(ITaskBuilder taskBuilder, TargetLoggingContext targetLoggingContext, TaskExecutionMode mode, Lookup lookupForInference, Lookup lookupForExecution);
    private TaskExecutionMode GetTaskExecutionMode(DependencyAnalysisResult analysis);
    private void VerifyState(TargetEntryState actual, TargetEntryState expected);
    private List`1<string> GetBatchableParametersForTarget();
    private void GetTargetInstance();
}
internal enum Microsoft.Build.BackEnd.TargetEntryState : Enum {
    public int value__;
    public static TargetEntryState Dependencies;
    public static TargetEntryState Execution;
    public static TargetEntryState ErrorExecution;
    public static TargetEntryState Completed;
}
[DebuggerDisplayAttribute("Name={TargetName}")]
internal class Microsoft.Build.BackEnd.TargetSpecification : object {
    private string _targetName;
    private ElementLocation _referenceLocation;
    public string TargetName { get; }
    public ElementLocation ReferenceLocation { get; }
    internal TargetSpecification(string targetName, ElementLocation referenceLocation);
    public string get_TargetName();
    public ElementLocation get_ReferenceLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static TargetSpecification FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.TargetUpToDateChecker : object {
    private ProjectInstance _project;
    private ProjectTargetInstance _targetToAnalyze;
    private string _targetInputSpecification;
    private string _targetOutputSpecification;
    private List`1<DependencyAnalysisLogDetail> _dependencyAnalysisDetail;
    private ILoggingService _loggingService;
    private BuildEventContext _buildEventContext;
    private static bool s_sortInputsOutputs;
    private IDictionary`2<string, object> _uniqueTargetInputs;
    private IDictionary`2<string, object> _uniqueTargetOutputs;
    internal ProjectTargetInstance TargetToAnalyze { get; }
    private string TargetInputSpecification { get; }
    private string TargetOutputSpecification { get; }
    internal TargetUpToDateChecker(ProjectInstance project, ProjectTargetInstance targetToAnalyze, ILoggingService loggingServices, BuildEventContext buildEventContext);
    private static TargetUpToDateChecker();
    internal ProjectTargetInstance get_TargetToAnalyze();
    private string get_TargetInputSpecification();
    private string get_TargetOutputSpecification();
    internal DependencyAnalysisResult PerformDependencyAnalysis(ItemBucket bucket, bool question, ItemDictionary`1& changedTargetInputs, ItemDictionary`1& upToDateTargetInputs);
    private void LogReasonForBuildingTarget(DependencyAnalysisResult result, bool question);
    internal static string GetFullBuildReason(DependencyAnalysisLogDetail logDetail);
    private static string GetIncrementalBuildReason(DependencyAnalysisLogDetail logDetail);
    private void LogUniqueInputsAndOutputs();
    private void ParseTargetInputOutputSpecifications(ItemBucket bucket, Dictionary`2& itemVectorsInTargetInputs, Dictionary`2& itemVectorTransformsInTargetInputs, Dictionary`2& discreteItemsInTargetInputs, Dictionary`2& itemVectorsInTargetOutputs, Dictionary`2& discreteItemsInTargetOutputs, List`1& targetOutputItemSpecs);
    private DependencyAnalysisResult PerformDependencyAnalysisIfNoInputs();
    private DependencyAnalysisResult PerformDependencyAnalysisIfNoOutputs();
    private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteInputs(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetInputs, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorTransformsInTargetInputs, Dictionary`2<string, string> discreteItemsInTargetInputs, List`1<string> itemVectorsReferencedOnlyInTargetInputs, List`1<string> targetOutputItemSpecs);
    private DependencyAnalysisResult PerformDependencyAnalysisIfCorrelatedInputsOutputs(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetInputs, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetOutputs, List`1<string> itemVectorsReferencedInBothTargetInputsAndOutputs, ItemDictionary`1& changedTargetInputs, ItemDictionary`1& upToDateTargetInputs);
    private DependencyAnalysisResult PerformDependencyAnalysisIfDiscreteOutputs(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorsInTargetInputs, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorTransformsInTargetInputs, Dictionary`2<string, string> discreteItemsInTargetInputs, List`1<string> targetOutputItemSpecs);
    private void SeparateItemVectorsFromDiscreteItems(SemiColonTokenizer items, ItemBucket bucket, Dictionary`2& itemVectors, Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectorTransforms, Dictionary`2& discreteItems, ElementLocation elementLocation);
    private static bool IsItemVectorEmpty(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectors);
    private static List`1<string> GetItemSpecsFromItemVectors(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectors);
    [IteratorStateMachineAttribute("Microsoft.Build.BackEnd.TargetUpToDateChecker/<GetItemSpecsFromItemVectors>d__21")]
private static IEnumerable`1<string> GetItemSpecsFromItemVectors(Dictionary`2<string, Dictionary`2<string, IList`1<ProjectItemInstance>>> itemVectors, string itemType, Dictionary`2<string, IList`1<ProjectItemInstance>> itemVectorPartition);
    private static void DiffHashtables(IDictionary`2<K, V> h1, IDictionary`2<K, V> h2, List`1& commonKeys, List`1& uniqueKeysInH1, List`1& uniqueKeysInH2);
    internal static bool IsAnyOutOfDate(DependencyAnalysisLogDetail& dependencyAnalysisDetailEntry, string projectDirectory, IList`1<T> inputs, IList`1<T> outputs);
    private void RecordUniqueInputsAndOutputs(IList`1<T> inputs, IList`1<T> outputs);
    private bool IsOutOfDate(string input, string output, string inputItemName, string outputItemName);
    private void RecordComparisonResults(string input, string output, string inputItemName, string outputItemName, bool inputDoesNotExist, bool outputDoesNotExist, bool outOfDate);
    private int CompareLastWriteTimes(string path1, string path2, Boolean& path1DoesNotExist, Boolean& path2DoesNotExist);
}
internal class Microsoft.Build.BackEnd.TaskBuilder : object {
    private BuildRequestEntry _buildRequestEntry;
    private CancellationToken _cancellationToken;
    private IBuildComponentHost _componentHost;
    private ProjectTargetInstanceChild _targetChildInstance;
    private ProjectTaskInstance _taskNode;
    private ITaskHost _taskHostObject;
    private ContinueOnError _continueOnError;
    private TargetLoggingContext _targetLoggingContext;
    private string _projectFullPath;
    private ITargetBuilderCallback _targetBuilderCallback;
    private ITaskExecutionHost _taskExecutionHost;
    private object _taskExecutionHostSync;
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteTask>d__13")]
public sealed virtual Task`1<WorkUnitResult> ExecuteTask(TargetLoggingContext loggingContext, BuildRequestEntry requestEntry, ITargetBuilderCallback targetBuilderCallback, ProjectTargetInstanceChild taskInstance, TaskExecutionMode mode, Lookup inferLookup, Lookup executeLookup, CancellationToken cancellationToken);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private List`1<string> CreateListOfParameterValues();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteTask>d__18")]
private Task`1<WorkUnitResult> ExecuteTask(TaskExecutionMode mode, Lookup lookup);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteBucket>d__19")]
private Task`1<WorkUnitResult> ExecuteBucket(TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask, Dictionary`2<string, string> lookupHash);
    private IDictionary`2<string, string> GatherTaskIdentityParameters(Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander);
    private WorkUnitResult ExecuteTaskInSTAThread(ItemBucket bucket, TaskLoggingContext taskLoggingContext, IDictionary`2<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask);
    private void LogSkippedTask(ItemBucket bucket, TaskExecutionMode howToExecuteTask);
    private void ExecuteIntrinsicTask(ItemBucket bucket);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<InitializeAndExecuteTask>d__24")]
private Task`1<WorkUnitResult> InitializeAndExecuteTask(TaskLoggingContext taskLoggingContext, ItemBucket bucket, IDictionary`2<string, string> taskIdentityParameters, TaskHost taskHost, TaskExecutionMode howToExecuteTask);
    private void UpdateContinueOnError(ItemBucket bucket, TaskHost taskHost);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskBuilder/<ExecuteInstantiatedTask>d__26")]
private Task`1<WorkUnitResult> ExecuteInstantiatedTask(ITaskExecutionHost taskExecutionHost, TaskLoggingContext taskLoggingContext, TaskHost taskHost, ItemBucket bucket, TaskExecutionMode howToExecuteTask);
    private List`1<string> GetUndeclaredProjects(MSBuild msbuildTask);
    private bool GatherTaskOutputs(ITaskExecutionHost taskExecutionHost, TaskExecutionMode howToExecuteTask, ItemBucket bucket);
    private void InferTaskOutputs(Lookup lookup, ProjectTaskInstanceChild taskOutputSpecification, string taskParameterName, string itemName, string propertyName, ItemBucket bucket);
}
internal enum Microsoft.Build.BackEnd.TaskCompleteType : Enum {
    public int value__;
    public static TaskCompleteType Success;
    public static TaskCompleteType Failure;
    public static TaskCompleteType CrashedDuringInitialization;
    public static TaskCompleteType CrashedDuringExecution;
    public static TaskCompleteType CrashedAfterExecution;
}
internal class Microsoft.Build.BackEnd.TaskExecutionHost : object {
    private static int CancelFirstWarningWaitInterval;
    private static int CancelWarningWaitInterval;
    private TaskEngineAssemblyResolver _resolver;
    private IBuildEngine2 _buildEngine;
    private ProjectInstance _projectInstance;
    private TargetLoggingContext _targetLoggingContext;
    private TaskLoggingContext _taskLoggingContext;
    private CancellationTokenRegistration _cancellationTokenRegistration;
    private string _taskName;
    private ElementLocation _taskLocation;
    private ITaskHost _taskHost;
    private ItemBucket _batchBucket;
    private TaskFactoryWrapper _taskFactoryWrapper;
    private bool _cancelled;
    private ManualResetEvent _taskExecutionIdle;
    private List`1<TaskItem> _remotedTaskItems;
    private IBuildComponentHost _buildComponentHost;
    private Dictionary`2<string, TaskFactoryWrapper> _intrinsicTasks;
    [CompilerGeneratedAttribute]
private bool <LogTaskInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private ITask <TaskInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private AppDomainSetup <AppDomainSetup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutOfProc>k__BackingField;
    private static string TaskParameterFormatString;
    public bool LogTaskInputs { get; }
    private ProjectInstance Microsoft.Build.BackEnd.ITaskExecutionHost.ProjectInstance { get; }
    internal ITask TaskInstance { get; private set; }
    internal TaskFactoryWrapper _UNITTESTONLY_TaskFactoryWrapper { get; internal set; }
    internal AppDomainSetup AppDomainSetup { get; internal set; }
    internal bool IsOutOfProc { get; internal set; }
    internal TaskExecutionHost(IBuildComponentHost host);
    private static TaskExecutionHost();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LogTaskInputs();
    private sealed virtual override ProjectInstance Microsoft.Build.BackEnd.ITaskExecutionHost.get_ProjectInstance();
    [CompilerGeneratedAttribute]
internal ITask get_TaskInstance();
    [CompilerGeneratedAttribute]
private void set_TaskInstance(ITask value);
    internal TaskFactoryWrapper get__UNITTESTONLY_TaskFactoryWrapper();
    internal void set__UNITTESTONLY_TaskFactoryWrapper(TaskFactoryWrapper value);
    [CompilerGeneratedAttribute]
internal AppDomainSetup get_AppDomainSetup();
    [CompilerGeneratedAttribute]
internal void set_AppDomainSetup(AppDomainSetup value);
    [CompilerGeneratedAttribute]
internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
internal void set_IsOutOfProc(bool value);
    public virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForTask(IBuildEngine2 buildEngine, TargetLoggingContext loggingContext, ProjectInstance projectInstance, string taskName, ElementLocation taskLocation, ITaskHost taskHost, bool continueOnError, AppDomainSetup appDomainSetup, bool isOutOfProc, CancellationToken cancellationToken);
    private sealed virtual override Nullable`1<TaskRequirements> Microsoft.Build.BackEnd.ITaskExecutionHost.FindTask(IDictionary`2<string, string> taskIdentityParameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.InitializeForBatch(TaskLoggingContext loggingContext, ItemBucket batchBucket, IDictionary`2<string, string> taskIdentityParameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.SetTaskParameters(IDictionary`2<string, ValueTuple`2<string, ElementLocation>> parameters);
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.GatherTaskOutputs(string parameterName, ElementLocation parameterLocation, bool outputTargetIsItem, string outputTargetName);
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForBatch();
    private sealed virtual override void Microsoft.Build.BackEnd.ITaskExecutionHost.CleanupForTask();
    private sealed virtual override bool Microsoft.Build.BackEnd.ITaskExecutionHost.Execute();
    protected virtual void Dispose(bool disposing);
    private void CleanupCancellationToken();
    private void Cancel();
    private bool SetTaskItemParameter(TaskPropertyInfo parameter, ITaskItem item);
    private bool SetValueParameter(TaskPropertyInfo parameter, Type parameterType, string expandedParameterValue);
    private bool SetParameterArray(TaskPropertyInfo parameter, Type parameterType, IList`1<TaskItem> taskItems, ElementLocation parameterLocation);
    private void RecordItemForDisconnectIfNecessary(TaskItem item);
    private ITaskItem[] GetItemOutputs(TaskPropertyInfo parameter);
    private String[] GetValueOutputs(TaskPropertyInfo parameter);
    private TaskFactoryWrapper FindTaskInRegistry(IDictionary`2<string, string> taskIdentityParameters);
    private ITask InstantiateTask(IDictionary`2<string, string> taskIdentityParameters);
    private bool SetTaskParameter(string parameterName, string parameterValue, ElementLocation parameterLocation, bool isRequired, Boolean& parameterSet);
    private bool InitializeTaskScalarParameter(TaskPropertyInfo parameter, Type parameterType, string parameterValue, ElementLocation parameterLocation, Boolean& taskParameterSet);
    private void EnsureParameterInitialized(TaskPropertyInfo parameter, Lookup lookup);
    private bool InitializeTaskVectorParameter(TaskPropertyInfo parameter, Type parameterType, string parameterValue, ElementLocation parameterLocation, bool isRequired, Boolean& taskParameterSet);
    private bool InternalSetTaskParameter(TaskPropertyInfo parameter, IList parameterValue);
    private bool InternalSetTaskParameter(TaskPropertyInfo parameter, object parameterValue);
    private void GatherTaskItemOutputs(bool outputTargetIsItem, string outputTargetName, ITaskItem[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter);
    private void GatherArrayStringAndValueOutputs(bool outputTargetIsItem, string outputTargetName, String[] outputs, ElementLocation parameterLocation, TaskPropertyInfo parameter);
    private IReadOnlyDictionary`2<string, string> GetNamesOfPropertiesWithRequiredAttribute();
    private void DisplayCancelWaitMessage();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskExecutionHost/<<Cancel>b__52_0>d")]
[CompilerGeneratedAttribute]
private Task <Cancel>b__52_0();
    [IteratorStateMachineAttribute("Microsoft.Build.BackEnd.TaskExecutionHost/<<GatherTaskItemOutputs>g__EnumerateMetadata|68_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<KeyValuePair`2<string, string>> <GatherTaskItemOutputs>g__EnumerateMetadata|68_0(IDictionary customMetadata);
}
[FlagsAttribute]
internal enum Microsoft.Build.BackEnd.TaskExecutionMode : Enum {
    public int value__;
    public static TaskExecutionMode Invalid;
    public static TaskExecutionMode ExecuteTaskAndGatherOutputs;
    public static TaskExecutionMode InferOutputsOnly;
}
internal class Microsoft.Build.BackEnd.TaskFactoryLoggingHost : MarshalByRefObject {
    private ElementLocation _elementLocation;
    private BuildLoggingContext _loggingContext;
    private bool _isRunningWithMultipleNodes;
    private ClientSponsor _sponsor;
    private bool _activeProxy;
    public bool IsRunningMultipleNodes { get; }
    public bool ContinueOnError { get; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    internal BuildLoggingContext LoggingContext { get; }
    public TaskFactoryLoggingHost(bool isRunningWithMultipleNodes, ElementLocation elementLocation, BuildLoggingContext loggingContext);
    public bool get_IsRunningMultipleNodes();
    public sealed virtual bool get_ContinueOnError();
    public sealed virtual int get_LineNumberOfTaskNode();
    public sealed virtual int get_ColumnNumberOfTaskNode();
    public sealed virtual string get_ProjectFileOfTaskNode();
    [DebuggerStepThroughAttribute]
internal BuildLoggingContext get_LoggingContext();
    public sealed virtual void LogErrorEvent(BuildErrorEventArgs e);
    public sealed virtual void LogWarningEvent(BuildWarningEventArgs e);
    public sealed virtual void LogMessageEvent(BuildMessageEventArgs e);
    public sealed virtual void LogCustomEvent(CustomBuildEventArgs e);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
    public virtual object InitializeLifetimeService();
    internal void MarkAsInactive();
    internal bool IsEventSerializable(BuildEventArgs e);
    private void VerifyActiveProxy();
}
internal class Microsoft.Build.BackEnd.TaskHost : MarshalByRefObject {
    private static bool s_breakOnLogAfterTaskReturns;
    private IBuildComponentHost _host;
    private BuildRequestEntry _requestEntry;
    private ElementLocation _taskLocation;
    private TaskLoggingContext _taskLoggingContext;
    private bool _activeProxy;
    private ITargetBuilderCallback _targetBuilderCallback;
    private object _callbackMonitor;
    private ClientSponsor _sponsor;
    private bool _continueOnError;
    private bool _convertErrorsToWarnings;
    private int _yieldThreadId;
    private bool _disableInprocNode;
    [CompilerGeneratedAttribute]
private bool <BuildRequestsSucceeded>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowFailureWithoutError>k__BackingField;
    private ICollection`1<string> _warningsAsErrors;
    private ICollection`1<string> _warningsNotAsErrors;
    private ICollection`1<string> _warningsAsMessages;
    private int _additionalAcquiredCores;
    private bool _isImplicitCoreUsed;
    [CompilerGeneratedAttribute]
private EngineServices <EngineServices>k__BackingField;
    public bool IsRunningMultipleNodes { get; }
    public bool ContinueOnError { get; internal set; }
    public int LineNumberOfTaskNode { get; }
    public int ColumnNumberOfTaskNode { get; }
    public string ProjectFileOfTaskNode { get; }
    internal bool ConvertErrorsToWarnings { get; internal set; }
    internal TaskLoggingContext LoggingContext { get; internal set; }
    internal AppDomainSetup AppDomainSetup { get; }
    internal bool IsOutOfProc { get; }
    public bool BuildRequestsSucceeded { get; private set; }
    public bool AllowFailureWithoutError { get; public set; }
    private ICollection`1<string> WarningsAsErrors { get; }
    private ICollection`1<string> WarningsNotAsErrors { get; }
    private ICollection`1<string> WarningsAsMessages { get; }
    private int TotalAcquiredCores { get; }
    public EngineServices EngineServices { get; }
    public TaskHost(IBuildComponentHost host, BuildRequestEntry requestEntry, ElementLocation taskLocation, ITargetBuilderCallback targetBuilderCallback);
    private static TaskHost();
    public sealed virtual bool get_IsRunningMultipleNodes();
    public sealed virtual bool get_ContinueOnError();
    internal void set_ContinueOnError(bool value);
    public sealed virtual int get_LineNumberOfTaskNode();
    public sealed virtual int get_ColumnNumberOfTaskNode();
    public sealed virtual string get_ProjectFileOfTaskNode();
    internal bool get_ConvertErrorsToWarnings();
    internal void set_ConvertErrorsToWarnings(bool value);
    [DebuggerStepThroughAttribute]
internal TaskLoggingContext get_LoggingContext();
    [DebuggerStepThroughAttribute]
internal void set_LoggingContext(TaskLoggingContext value);
    internal AppDomainSetup get_AppDomainSetup();
    internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
public bool get_BuildRequestsSucceeded();
    [CompilerGeneratedAttribute]
private void set_BuildRequestsSucceeded(bool value);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs, string toolsVersion);
    public sealed virtual bool BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IDictionary[] targetOutputsPerProject, String[] toolsVersion, bool useResultsCache, bool unloadProjectsOnCompletion);
    public sealed virtual BuildEngineResult BuildProjectFilesInParallel(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs);
    public sealed virtual void Yield();
    public sealed virtual void Reacquire();
    public sealed virtual void LogErrorEvent(BuildErrorEventArgs e);
    public sealed virtual void LogWarningEvent(BuildWarningEventArgs e);
    public sealed virtual void LogMessageEvent(BuildMessageEventArgs e);
    public sealed virtual void LogCustomEvent(CustomBuildEventArgs e);
    public sealed virtual bool BuildProjectFile(string projectFileName, String[] targetNames, IDictionary globalProperties, IDictionary targetOutputs);
    public sealed virtual void RegisterTaskObject(object key, object obj, RegisteredTaskObjectLifetime lifetime, bool allowEarlyCollection);
    public sealed virtual object GetRegisteredTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual object UnregisterTaskObject(object key, RegisteredTaskObjectLifetime lifetime);
    public sealed virtual void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
    public sealed virtual IReadOnlyDictionary`2<string, string> GetGlobalProperties();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_AllowFailureWithoutError();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AllowFailureWithoutError(bool value);
    private ICollection`1<string> get_WarningsAsErrors();
    private ICollection`1<string> get_WarningsNotAsErrors();
    private ICollection`1<string> get_WarningsAsMessages();
    public sealed virtual bool ShouldTreatWarningAsError(string warningCode);
    private bool WarningAsErrorNotOverriden(string warningCode);
    private int get_TotalAcquiredCores();
    public sealed virtual int RequestCores(int requestedCores);
    public sealed virtual void ReleaseCores(int coresToRelease);
    internal void ReleaseAllCores();
    [CompilerGeneratedAttribute]
public sealed virtual EngineServices get_EngineServices();
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskHost/<InternalBuildProjects>d__80")]
public Task`1<BuildEngineResult> InternalBuildProjects(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets);
    public virtual object InitializeLifetimeService();
    internal void MarkAsInactive();
    internal bool IsEventSerializable(BuildEventArgs e);
    [AsyncStateMachineAttribute("Microsoft.Build.BackEnd.TaskHost/<BuildProjectFilesInParallelAsync>d__84")]
private Task`1<BuildEngineResult> BuildProjectFilesInParallelAsync(String[] projectFileNames, String[] targetNames, IDictionary[] globalProperties, IList`1[] undefineProperties, String[] toolsVersion, bool returnTargetOutputs, bool skipNonexistentTargets);
    private void VerifyActiveProxy();
}
internal class Microsoft.Build.BackEnd.TaskHostConfiguration : object {
    private int _nodeId;
    private string _startupDirectory;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    private CultureInfo _culture;
    private CultureInfo _uiCulture;
    private AppDomainSetup _appDomainSetup;
    private int _lineNumberOfTask;
    private int _columnNumberOfTask;
    private string _projectFileOfTask;
    private bool _continueOnError;
    private string _taskName;
    private string _taskLocation;
    private bool _isTaskInputLoggingEnabled;
    private Dictionary`2<string, TaskParameter> _taskParameters;
    private Dictionary`2<string, string> _globalParameters;
    private ICollection`1<string> _warningsAsErrors;
    private ICollection`1<string> _warningsNotAsErrors;
    private ICollection`1<string> _warningsAsMessages;
    public int NodeId { get; }
    public string StartupDirectory { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; }
    public CultureInfo UICulture { get; }
    public AppDomainSetup AppDomainSetup { get; }
    public int LineNumberOfTask { get; }
    public int ColumnNumberOfTask { get; }
    public bool ContinueOnError { get; }
    public string ProjectFileOfTask { get; }
    public string TaskName { get; }
    public string TaskLocation { get; }
    public bool IsTaskInputLoggingEnabled { get; }
    public Dictionary`2<string, TaskParameter> TaskParameters { get; }
    public Dictionary`2<string, string> GlobalProperties { get; }
    public NodePacketType Type { get; }
    public ICollection`1<string> WarningsAsErrors { get; }
    public ICollection`1<string> WarningsNotAsErrors { get; }
    public ICollection`1<string> WarningsAsMessages { get; }
    public TaskHostConfiguration(int nodeId, string startupDirectory, IDictionary`2<string, string> buildProcessEnvironment, CultureInfo culture, CultureInfo uiCulture, AppDomainSetup appDomainSetup, int lineNumberOfTask, int columnNumberOfTask, string projectFileOfTask, bool continueOnError, string taskName, string taskLocation, bool isTaskInputLoggingEnabled, IDictionary`2<string, object> taskParameters, Dictionary`2<string, string> globalParameters, ICollection`1<string> warningsAsErrors, ICollection`1<string> warningsNotAsErrors, ICollection`1<string> warningsAsMessages);
    [DebuggerStepThroughAttribute]
public int get_NodeId();
    [DebuggerStepThroughAttribute]
public string get_StartupDirectory();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_BuildProcessEnvironment();
    [DebuggerStepThroughAttribute]
public CultureInfo get_Culture();
    [DebuggerStepThroughAttribute]
public CultureInfo get_UICulture();
    [DebuggerStepThroughAttribute]
public AppDomainSetup get_AppDomainSetup();
    [DebuggerStepThroughAttribute]
public int get_LineNumberOfTask();
    [DebuggerStepThroughAttribute]
public int get_ColumnNumberOfTask();
    [DebuggerStepThroughAttribute]
public bool get_ContinueOnError();
    [DebuggerStepThroughAttribute]
public string get_ProjectFileOfTask();
    [DebuggerStepThroughAttribute]
public string get_TaskName();
    [DebuggerStepThroughAttribute]
public string get_TaskLocation();
    [DebuggerStepThroughAttribute]
public bool get_IsTaskInputLoggingEnabled();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, TaskParameter> get_TaskParameters();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_GlobalProperties();
    [DebuggerStepThroughAttribute]
public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_WarningsAsErrors();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_WarningsNotAsErrors();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_WarningsAsMessages();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskHostNodeManager : object {
    private INodeProvider _outOfProcTaskHostNodeProvider;
    private IBuildComponentHost _componentHost;
    private bool _componentShutdown;
    public sealed virtual IList`1<NodeInfo> CreateNodes(NodeConfiguration configuration, NodeAffinity affinity, int numberOfNodesToCreate);
    public sealed virtual void SendData(int node, INodePacket packet);
    public sealed virtual void ShutdownConnectedNodes(bool enableReuse);
    public sealed virtual void ShutdownAllNodes();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ClearPerBuildState();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    internal static IBuildComponent CreateComponent(BuildComponentType type);
    private sealed virtual override IEnumerable`1<Process> Microsoft.Build.BackEnd.INodeManager.GetProcesses();
}
internal class Microsoft.Build.BackEnd.TaskHostTask : object {
    private IBuildEngine _buildEngine;
    private ITaskHost _hostObject;
    private TaskLoggingContext _taskLoggingContext;
    private IElementLocation _taskLocation;
    private IBuildComponentHost _buildComponentHost;
    private NodePacketFactory _packetFactory;
    private AutoResetEvent _packetReceivedEvent;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private IDictionary`2<string, string> _taskHostParameters;
    private LoadedType _taskType;
    private AppDomainSetup _appDomainSetup;
    private HandshakeOptions _requiredContext;
    private bool _connectedToTaskHost;
    private NodeProviderOutOfProcTaskHost _taskHostProvider;
    private object _taskHostLock;
    private bool _taskCancelled;
    private IDictionary`2<string, object> _setParameters;
    private bool _taskExecutionSucceeded;
    public IBuildEngine BuildEngine { get; public set; }
    public ITaskHost HostObject { get; public set; }
    public TaskHostTask(IElementLocation taskLocation, TaskLoggingContext taskLoggingContext, IBuildComponentHost buildComponentHost, IDictionary`2<string, string> taskHostParameters, LoadedType taskType, AppDomainSetup appDomainSetup);
    public sealed virtual IBuildEngine get_BuildEngine();
    public sealed virtual void set_BuildEngine(IBuildEngine value);
    public sealed virtual ITaskHost get_HostObject();
    public sealed virtual void set_HostObject(ITaskHost value);
    public sealed virtual void SetPropertyValue(TaskPropertyInfo property, object value);
    public sealed virtual object GetPropertyValue(TaskPropertyInfo property);
    public sealed virtual void Cancel();
    public sealed virtual bool Execute();
    public sealed virtual void RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    public sealed virtual void UnregisterPacketHandler(NodePacketType packetType);
    public sealed virtual void DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    public sealed virtual void RoutePacket(int nodeId, INodePacket packet);
    public sealed virtual void PacketReceived(int node, INodePacket packet);
    internal void Cleanup();
    private void HandlePacket(INodePacket packet, Boolean& taskFinished);
    private void HandleTaskHostTaskComplete(TaskHostTaskComplete taskHostTaskComplete);
    private void HandleNodeShutdown(NodeShutdown nodeShutdown);
    private void HandleLoggedMessage(LogMessagePacket logMessagePacket);
    private void LogErrorUnableToCreateTaskHost(HandshakeOptions requiredContext, string runtime, string architecture, NodeFailedToLaunchException e);
}
internal class Microsoft.Build.BackEnd.TaskHostTaskCancelled : object {
    public NodePacketType Type { get; }
    public sealed virtual NodePacketType get_Type();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskHostTaskComplete : object {
    private List`1<FileAccessData> _fileAccessData;
    private TaskCompleteType _taskResult;
    private Exception _taskException;
    private string _taskExceptionMessage;
    private String[] _taskExceptionMessageArgs;
    private Dictionary`2<string, TaskParameter> _taskOutputParameters;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    public TaskCompleteType TaskResult { get; }
    public Exception TaskException { get; }
    public string TaskExceptionMessage { get; }
    public String[] TaskExceptionMessageArgs { get; }
    public Dictionary`2<string, TaskParameter> TaskOutputParameters { get; }
    public Dictionary`2<string, string> BuildProcessEnvironment { get; }
    public NodePacketType Type { get; }
    public List`1<FileAccessData> FileAccessData { get; }
    public TaskHostTaskComplete(OutOfProcTaskHostTaskResult result, List`1<FileAccessData> fileAccessData, IDictionary`2<string, string> buildProcessEnvironment);
    [DebuggerStepThroughAttribute]
public TaskCompleteType get_TaskResult();
    [DebuggerStepThroughAttribute]
public Exception get_TaskException();
    [DebuggerStepThroughAttribute]
public string get_TaskExceptionMessage();
    [DebuggerStepThroughAttribute]
public String[] get_TaskExceptionMessageArgs();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, TaskParameter> get_TaskOutputParameters();
    [DebuggerStepThroughAttribute]
public Dictionary`2<string, string> get_BuildProcessEnvironment();
    public sealed virtual NodePacketType get_Type();
    [DebuggerStepThroughAttribute]
public List`1<FileAccessData> get_FileAccessData();
    public sealed virtual void Translate(ITranslator translator);
    internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.BackEnd.TaskLoggingHelper : MarshalByRefObject {
    private ClientSponsor _sponsor;
    private ITask _taskInstance;
    private object _locker;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    private string _taskNameUpperCase;
    private IBuildEngine _buildEngine;
    [CompilerGeneratedAttribute]
private ResourceManager <TaskResources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeywordPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLoggedErrors>k__BackingField;
    protected string TaskName { get; }
    private string TaskNameUpperCase { get; }
    protected IBuildEngine BuildEngine { get; }
    public ResourceManager TaskResources { get; public set; }
    public string HelpKeywordPrefix { get; public set; }
    public bool HasLoggedErrors { get; private set; }
    public bool IsTaskInputLoggingEnabled { get; }
    public TaskLoggingHelper(ITask taskInstance);
    public TaskLoggingHelper(IBuildEngine buildEngine, string taskName);
    [CompilerGeneratedAttribute]
protected string get_TaskName();
    private string get_TaskNameUpperCase();
    protected IBuildEngine get_BuildEngine();
    [CompilerGeneratedAttribute]
public ResourceManager get_TaskResources();
    [CompilerGeneratedAttribute]
public void set_TaskResources(ResourceManager value);
    [CompilerGeneratedAttribute]
public string get_HelpKeywordPrefix();
    [CompilerGeneratedAttribute]
public void set_HelpKeywordPrefix(string value);
    [CompilerGeneratedAttribute]
public bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
private void set_HasLoggedErrors(bool value);
    public string ExtractMessageCode(string message, String& messageWithoutCodePrefix);
    public virtual string FormatResourceString(string resourceName, Object[] args);
    public virtual string FormatString(string unformatted, Object[] args);
    public virtual string GetResourceMessage(string resourceName);
    public bool get_IsTaskInputLoggingEnabled();
    public bool LogsMessagesOfImportance(MessageImportance importance);
    public void LogMessage(string message, Object[] messageArgs);
    public void LogMessage(MessageImportance importance, string message, Object[] messageArgs);
    public void LogMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, MessageImportance importance, string message, Object[] messageArgs);
    public void LogCriticalMessage(string subcategory, string code, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogMessageFromResources(string messageResourceName, Object[] messageArgs);
    public void LogMessageFromResources(MessageImportance importance, string messageResourceName, Object[] messageArgs);
    public static string GetInnerExceptionMessageString(Exception e);
    public void LogExternalProjectStarted(string message, string helpKeyword, string projectFile, string targetNames);
    public void LogExternalProjectFinished(string message, string helpKeyword, string projectFile, bool succeeded);
    public void LogCommandLine(string commandLine);
    public void LogCommandLine(MessageImportance importance, string commandLine);
    public void LogError(string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogError(string subcategory, string errorCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogErrorFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorFromResources(string subcategoryResourceName, string errorCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogErrorWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogErrorFromException(Exception exception);
    public void LogErrorFromException(Exception exception, bool showStackTrace);
    public void LogErrorFromException(Exception exception, bool showStackTrace, bool showDetail, string file);
    public void LogWarning(string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarning(string subcategory, string warningCode, string helpKeyword, string helpLink, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, Object[] messageArgs);
    public void LogWarningFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningFromResources(string subcategoryResourceName, string warningCode, string helpKeyword, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string messageResourceName, Object[] messageArgs);
    public void LogWarningWithCodeFromResources(string subcategoryResourceName, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string messageResourceName, Object[] messageArgs);
    public void LogWarningFromException(Exception exception);
    public void LogWarningFromException(Exception exception, bool showStackTrace);
    public bool LogMessagesFromFile(string fileName);
    public bool LogMessagesFromFile(string fileName, MessageImportance messageImportance);
    public bool LogMessagesFromStream(TextReader stream, MessageImportance messageImportance);
    public bool LogMessageFromText(string lineOfText, MessageImportance messageImportance);
    public void LogTelemetry(string eventName, IDictionary`2<string, string> properties);
    public virtual object InitializeLifetimeService();
    public void MarkAsInactive();
}
internal class Microsoft.Build.BackEnd.TaskLoggingHelperExtension : TaskLoggingHelper {
    private ResourceManager _taskSharedResources;
    public ResourceManager TaskSharedResources { get; public set; }
    public TaskLoggingHelperExtension(ITask taskInstance, ResourceManager primaryResources, ResourceManager sharedResources, string helpKeywordPrefix);
    public ResourceManager get_TaskSharedResources();
    public void set_TaskSharedResources(ResourceManager value);
    public virtual string FormatResourceString(string resourceName, Object[] args);
}
internal class Microsoft.Build.BackEnd.TaskParameter : MarshalByRefObject {
    private TaskParameterType _parameterType;
    private TypeCode _parameterTypeCode;
    private object _wrappedParameter;
    public TaskParameterType ParameterType { get; }
    public TypeCode ParameterTypeCode { get; }
    public object WrappedParameter { get; }
    public TaskParameter(object wrappedParameter);
    public TaskParameterType get_ParameterType();
    public TypeCode get_ParameterTypeCode();
    public object get_WrappedParameter();
    public virtual string ToString();
    public sealed virtual void Translate(ITranslator translator);
    [SecurityCriticalAttribute]
public virtual object InitializeLifetimeService();
    internal static TaskParameter FactoryForDeserialization(ITranslator translator);
    private ITaskItem CreateNewTaskItemFrom(ITaskItem copyFrom);
    private void TranslateITaskItemArray(ITranslator translator);
    private void TranslateITaskItem(ITranslator translator);
    private void WriteITaskItem(ITranslator translator, ITaskItem wrappedItem);
    private void ReadITaskItem(ITranslator translator, ITaskItem& wrappedItem);
    private bool TranslateNullable(ITranslator translator, T value);
    private void TranslatePrimitiveType(ITranslator translator);
    private void TranslatePrimitiveTypeArray(ITranslator translator);
    private void TranslateValueType(ITranslator translator);
    private void TranslateValueTypeArray(ITranslator translator);
}
internal enum Microsoft.Build.BackEnd.TaskParameterType : Enum {
    public int value__;
    public static TaskParameterType Null;
    public static TaskParameterType PrimitiveType;
    public static TaskParameterType PrimitiveTypeArray;
    public static TaskParameterType ValueType;
    public static TaskParameterType ValueTypeArray;
    public static TaskParameterType ITaskItem;
    public static TaskParameterType ITaskItemArray;
    public static TaskParameterType Invalid;
}
internal static class Microsoft.Build.BackEnd.TaskParameterTypeVerifier : object {
    internal static bool IsValidScalarInputParameter(Type parameterType);
    internal static bool IsValidVectorInputParameter(Type parameterType);
    internal static bool IsAssignableToITask(Type parameterType);
    internal static bool IsValueTypeOutputParameter(Type parameterType);
    internal static bool IsValidInputParameter(Type parameterType);
    internal static bool IsValidOutputParameter(Type parameterType);
}
[FlagsAttribute]
internal enum Microsoft.Build.BackEnd.TaskRequirements : Enum {
    public int value__;
    public static TaskRequirements None;
    public static TaskRequirements RequireSTAThread;
    public static TaskRequirements RequireSeparateAppDomain;
}
[ExtensionAttribute]
internal static class Microsoft.Build.BackEnd.TranslatorExtensions : object {
    private static Lazy`1<ConcurrentDictionary`2<Type, ConstructorInfo>> parameterlessConstructorCache;
    private static TranslatorExtensions();
    [ExtensionAttribute]
public static void TranslateProjectPropertyInstanceDictionary(ITranslator translator, PropertyDictionary`1& value);
    [ExtensionAttribute]
public static T FactoryForDeserializingTypeWithName(ITranslator translator);
    [ExtensionAttribute]
public static void TranslateOptionalBuildEventContext(ITranslator translator, BuildEventContext& buildEventContext);
}
[ExtensionAttribute]
internal static class Microsoft.Build.BackEnd.TranslatorHelpers : object {
    [ExtensionAttribute]
public static void Translate(ITranslator translator, T& instance, NodePacketValueFactory`1<T> valueFactory);
    private static ObjectTranslator`1<T> AdaptFactory(NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, List`1& list, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, IList`1& list, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<L> collectionFactory);
    [ExtensionAttribute]
public static void TranslateArray(ITranslator translator, T[]& array, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void TranslateDictionary(ITranslator translator, Dictionary`2& dictionary, IEqualityComparer`1<string> comparer, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void TranslateDictionary(ITranslator translator, D& dictionary, NodePacketValueFactory`1<T> valueFactory);
    [ExtensionAttribute]
public static void TranslateDictionary(ITranslator translator, D& dictionary, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<D> collectionCreator);
    [ExtensionAttribute]
public static void TranslateHashSet(ITranslator translator, HashSet`1& hashSet, NodePacketValueFactory`1<T> valueFactory, NodePacketCollectionCreator`1<HashSet`1<T>> collectionFactory);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, CultureInfo& cultureInfo);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, Version& version);
    [ExtensionAttribute]
public static void Translate(ITranslator translator, AssemblyName& assemblyName);
}
internal enum Microsoft.Build.BackEnd.WorkUnitActionCode : Enum {
    public int value__;
    public static WorkUnitActionCode Continue;
    public static WorkUnitActionCode Stop;
}
internal class Microsoft.Build.BackEnd.WorkUnitResult : object {
    private WorkUnitResultCode _resultCode;
    private WorkUnitActionCode _actionCode;
    private Exception _exception;
    internal WorkUnitResultCode ResultCode { get; }
    internal WorkUnitActionCode ActionCode { get; internal set; }
    internal Exception Exception { get; }
    internal WorkUnitResult(WorkUnitResultCode resultCode, WorkUnitActionCode actionCode, Exception e);
    private WorkUnitResult(ITranslator translator);
    internal WorkUnitResultCode get_ResultCode();
    internal WorkUnitActionCode get_ActionCode();
    internal void set_ActionCode(WorkUnitActionCode value);
    internal Exception get_Exception();
    public sealed virtual void Translate(ITranslator translator);
    internal static WorkUnitResult FactoryForDeserialization(ITranslator translator);
    internal WorkUnitResult AggregateResult(WorkUnitResult result);
}
internal enum Microsoft.Build.BackEnd.WorkUnitResultCode : Enum {
    public int value__;
    public static WorkUnitResultCode Skipped;
    public static WorkUnitResultCode Success;
    public static WorkUnitResultCode Failed;
    public static WorkUnitResultCode Canceled;
}
internal enum Microsoft.Build.BackEnd.YieldAction : Enum {
    public byte value__;
    public static YieldAction Yield;
    public static YieldAction Reacquire;
    public static YieldAction None;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ArrayDictionary`2 : object {
    private TKey[] keys;
    private TValue[] values;
    private int count;
    public TValue Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public ICollection`1<TKey> Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEqualityComparer`1<TKey> KeyComparer { get; }
    private IEqualityComparer`1<TValue> ValueComparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public ArrayDictionary`2(int capacity);
    public static IDictionary`2<TKey, TValue> Create(int capacity);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private IEqualityComparer`1<TKey> get_KeyComparer();
    private IEqualityComparer`1<TValue> get_ValueComparer();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
}
internal class Microsoft.Build.Collections.BitHelper : object {
    private static byte MarkedBitFlag;
    private static byte IntSize;
    private int _length;
    [SecurityCriticalAttribute]
private Int32* _arrayPtr;
    private Int32[] _array;
    private bool _useStackAlloc;
    [SecurityCriticalAttribute]
internal BitHelper(Int32* bitArrayPtr, int length);
    [SecurityCriticalAttribute]
internal BitHelper(Int32[] bitArray, int length);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Collections.ConcurrentQueueExtensions : object {
    [ExtensionAttribute]
public static T Dequeue(ConcurrentQueue`1<T> stack);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Collections.ConcurrentStackExtensions : object {
    [ExtensionAttribute]
public static T Peek(ConcurrentStack`1<T> stack);
    [ExtensionAttribute]
public static T Pop(ConcurrentStack`1<T> stack);
}
internal class Microsoft.Build.Collections.ConvertingEnumerable`2 : object {
    private IEnumerable`1<TFrom> _backingEnumerable;
    private Func`2<TFrom, TTo> _converter;
    internal ConvertingEnumerable`2(IEnumerable`1<TFrom> backingEnumerable, Func`2<TFrom, TTo> converter);
    public sealed virtual IEnumerator`1<TTo> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Collections.CopyOnReadEnumerable`2 : object {
    private IEnumerable`1<TSource> _backingEnumerable;
    private object _syncRoot;
    private Func`2<TSource, TResult> _selector;
    public CopyOnReadEnumerable`2(IEnumerable`1<TSource> backingEnumerable, object syncRoot, Func`2<TSource, TResult> selector);
    public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.CopyOnWriteDictionary`1 : object {
    private static ImmutableDictionary`2<string, V> NameComparerDictionaryPrototype;
    private static ImmutableDictionary`2<string, V> OrdinalIgnoreCaseComparerDictionaryPrototype;
    private ImmutableDictionary`2<string, V> _backing;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<V> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal IEqualityComparer`1<string> Comparer { get; private set; }
    public V Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    internal CopyOnWriteDictionary`1(IEqualityComparer`1<string> keyComparer);
    protected CopyOnWriteDictionary`1(SerializationInfo info, StreamingContext context);
    private CopyOnWriteDictionary`1(CopyOnWriteDictionary`1<V> that);
    public CopyOnWriteDictionary`1(IDictionary`2<string, V> dictionary);
    private static CopyOnWriteDictionary`1();
    private static ImmutableDictionary`2<string, V> GetInitialDictionary(IEqualityComparer`1<string> keyComparer);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal IEqualityComparer`1<string> get_Comparer();
    private void set_Comparer(IEqualityComparer`1<string> value);
    public sealed virtual V get_Item(string key);
    public sealed virtual void set_Item(string key, V value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual void Add(string key, V value);
    public void SetItems(IEnumerable`1<KeyValuePair`2<string, V>> items);
    public IEnumerable`1<KeyValuePair`2<string, V>> Where(Func`2<KeyValuePair`2<string, V>, bool> predicate);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    [NullableContextAttribute("0")]
public sealed virtual bool TryGetValue(string key, V& value);
    public sealed virtual void Add(KeyValuePair`2<string, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("0")]
private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    internal CopyOnWriteDictionary`1<V> Clone();
    internal bool HasSameBacking(CopyOnWriteDictionary`1<V> other);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
internal class Microsoft.Build.Collections.CopyOnWritePropertyDictionary`1 : object {
    private static ImmutableDictionary`2<string, T> NameComparerDictionaryPrototype;
    private ImmutableDictionary`2<string, T> _backing;
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.Keys { get; }
    private ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.IsReadOnly { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private CopyOnWritePropertyDictionary`1(CopyOnWritePropertyDictionary`1<T> that);
    private static CopyOnWritePropertyDictionary`1();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_IsReadOnly();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(string name);
    public sealed virtual void set_Item(string name, T value);
    public bool Contains(string name);
    public sealed virtual void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(CopyOnWritePropertyDictionary`1<T> other);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.TryGetValue(string key, T& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    public sealed virtual bool Remove(string name);
    internal void Set(T projectProperty);
    internal void ImportProperties(IEnumerable`1<T> other);
    internal CopyOnWritePropertyDictionary`1<T> DeepClone();
}
internal static class Microsoft.Build.Collections.HashHelpers : object {
    internal static Int32[] primes;
    internal static int MaxPrimeArrayLength;
    private static HashHelpers();
    [ReliabilityContractAttribute("3", "2")]
internal static bool IsPrime(int candidate);
    [ReliabilityContractAttribute("3", "2")]
internal static int GetPrime(int min);
    internal static int GetMinPrime();
    internal static int ExpandPrime(int oldSize);
}
internal class Microsoft.Build.Collections.HashSetDebugView`1 : object {
    private RetrievableEntryHashSet`1<T> _set;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public HashSetDebugView`1(RetrievableEntryHashSet`1<T> set);
    public T[] get_Items();
}
internal static class Microsoft.Build.Collections.HashTableUtility : object {
    internal static int Compare(Dictionary`2<string, string> h1, Dictionary`2<string, string> h2);
}
internal interface Microsoft.Build.Collections.IConstrainedEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y, int indexY, int length);
    public abstract virtual int GetHashCode(T obj, int index, int length);
}
internal interface Microsoft.Build.Collections.IImmutable {
}
internal interface Microsoft.Build.Collections.IKeyed {
    public string Key { get; }
    public abstract virtual string get_Key();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Item types={ItemTypes.Count} #Items={Count}")]
internal class Microsoft.Build.Collections.ItemDictionary`1 : object {
    private Dictionary`2<string, LinkedList`1<T>> _itemLists;
    private Dictionary`2<T, LinkedListNode`1<T>> _nodes;
    internal int Count { get; }
    internal ICollection`1<string> ItemTypes { get; }
    internal ICollection`1<T> Item { get; }
    internal ItemDictionary`1(int initialItemTypesCapacity, int initialItemsCapacity);
    internal ItemDictionary`1(IEnumerable`1<T> items);
    internal int get_Count();
    internal ICollection`1<string> get_ItemTypes();
    internal ICollection`1<T> get_Item(string itemtype);
    public void Clear();
    public IEnumerable`1<TResult> GetCopyOnReadEnumerable(Func`2<T, TResult> selector);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void EnumerateItemsPerType(Action`2<string, IEnumerable`1<T>> itemTypeCallback);
    public sealed virtual ICollection`1<T> GetItems(string itemType);
    internal bool Contains(T projectItem);
    internal void Add(T projectItem);
    internal bool Remove(T projectItem);
    internal void Replace(T existingItem, T newItem);
    internal void ImportItems(IEnumerable`1<T> other);
    internal void ImportItemsOfType(string itemType, IEnumerable`1<T> items);
    internal void RemoveItems(IEnumerable`1<T> other);
    internal void AddEmptyMarker(string itemType);
    internal bool HasEmptyMarker(string itemType);
}
internal interface Microsoft.Build.Collections.IValued {
    public string EscapedValue { get; }
    public abstract virtual string get_EscapedValue();
}
internal class Microsoft.Build.Collections.LookasideStringInterner : object {
    private static int NullStringIndex;
    private static int EmptyStringIndex;
    private Dictionary`2<string, int> _stringToIdsMap;
    private List`1<string> _strings;
    public LookasideStringInterner(StringComparer comparer, int defaultCollectionSize);
    public LookasideStringInterner(ITranslator translator);
    public int Intern(string str);
    public string GetString(int index);
    public sealed virtual void Translate(ITranslator translator);
}
internal class Microsoft.Build.Collections.MSBuildNameIgnoreCaseComparer : object {
    private static ProcessorArchitectures s_runningProcessorArchitecture;
    [CompilerGeneratedAttribute]
private static MSBuildNameIgnoreCaseComparer <Default>k__BackingField;
    internal static MSBuildNameIgnoreCaseComparer Default { get; }
    private static MSBuildNameIgnoreCaseComparer();
    [CompilerGeneratedAttribute]
internal static MSBuildNameIgnoreCaseComparer get_Default();
    public sealed virtual bool Equals(string x, string y);
    public sealed virtual int GetHashCode(string obj);
    public sealed virtual bool Equals(string compareToString, string constrainedString, int start, int lengthToCompare);
    public sealed virtual int GetHashCode(string obj, int start, int length);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Keys={KeyCount} #Values={ValueCount}")]
internal class Microsoft.Build.Collections.MultiDictionary`2 : object {
    private Dictionary`2<K, SmallList`1<K, V, V>> _backing;
    private int _valueCount;
    internal int KeyCount { get; }
    internal int ValueCount { get; }
    internal IEnumerable`1<K> Keys { get; }
    internal IEnumerable`1<V> Item { get; }
    internal MultiDictionary`2(IEqualityComparer`1<K> keyComparer);
    internal int get_KeyCount();
    internal int get_ValueCount();
    internal IEnumerable`1<K> get_Keys();
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.MultiDictionary`2/<get_Item>d__10")]
internal IEnumerable`1<V> get_Item(K key);
    internal void Add(K key, V value);
    internal bool Remove(K key, V value);
    internal void Clear();
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("#Entries={Count}")]
internal class Microsoft.Build.Collections.PropertyDictionary`1 : object {
    [DebuggerBrowsableAttribute("3")]
private RetrievableEntryHashSet`1<T> _properties;
    [DebuggerBrowsableAttribute("0")]
private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.Keys { get; }
    [DebuggerBrowsableAttribute("0")]
private ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.Values { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Count { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.IsReadOnly { get; }
    internal int Count { get; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    internal T Item { get; internal set; }
    internal PropertyDictionary`1(int capacity);
    internal PropertyDictionary`1(IEnumerable`1<T> elements);
    internal PropertyDictionary`1(MSBuildNameIgnoreCaseComparer comparer);
    internal PropertyDictionary`1(int capacity, IEnumerable`1<T> elements);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,T>.get_Keys();
    private sealed virtual override ICollection`1<T> System.Collections.Generic.IDictionary<System.String,T>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.get_IsReadOnly();
    internal int get_Count();
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    public IEnumerable`1<TResult> GetCopyOnReadEnumerable(Func`2<T, TResult> selector);
    public bool Contains(string name);
    public void Clear();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(PropertyDictionary`1<T> other);
    public sealed virtual T GetProperty(string name);
    public sealed virtual T GetProperty(string name, int startIndex, int endIndex);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,T>.TryGetValue(string key, T& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.PropertyDictionary`1/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-String,T>>-GetEnumerator>d__39")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    internal bool Remove(string name);
    internal void Set(T projectProperty);
    internal void ImportProperties(IEnumerable`1<T> other);
    internal void RemoveProperties(IEnumerable`1<T> other);
    internal Dictionary`2<string, string> ToDictionary();
    internal void Enumerate(Action`2<string, string> keyValueCallback);
    internal IEnumerable`1<TResult> Filter(Func`2<T, bool> filter, Func`2<T, TResult> selector);
}
internal class Microsoft.Build.Collections.ReadOnlyCollection`1 : object {
    private IEnumerable`1<T> _backing;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ICollection`1<T> BackingCollection { get; }
    internal ReadOnlyCollection`1(IEnumerable`1<T> backing);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private ICollection`1<T> get_BackingCollection();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyConvertingDictionary`3 : object {
    private IDictionary`2<K, V> _backing;
    private Func`2<V, N> _converter;
    public ICollection`1<K> Keys { get; }
    public ICollection`1<N> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public N Item { get; public set; }
    internal ReadOnlyConvertingDictionary`3(IDictionary`2<K, V> backing, Func`2<V, N> converter);
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<N> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual N get_Item(K key);
    public sealed virtual void set_Item(K key, N value);
    public sealed virtual void Add(K key, N value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, N& value);
    public sealed virtual void Add(KeyValuePair`2<K, N> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, N> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, N> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, N>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private KeyValuePair`2<K, N> KeyValueConverter(KeyValuePair`2<K, V> original);
}
internal class Microsoft.Build.Collections.ReadOnlyEmptyCollection`1 : object {
    private static ReadOnlyEmptyCollection`1<T> s_instance;
    public static ReadOnlyEmptyCollection`1<T> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public static ReadOnlyEmptyCollection`1<T> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.ReadOnlyEmptyCollection`1/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ReadOnlyEmptyDictionary`2 : object {
    private static Dictionary`2<K, V> s_backing;
    private static ReadOnlyEmptyDictionary`2<K, V> s_instance;
    public static ReadOnlyEmptyDictionary`2<K, V> Instance { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<K> Keys { get; }
    public ICollection`1<V> Values { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.Keys { get; }
    private IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.Values { get; }
    public object Item { get; public set; }
    public V Item { get; public set; }
    private static ReadOnlyEmptyDictionary`2();
    public static ReadOnlyEmptyDictionary`2<K, V> get_Instance();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<K> get_Keys();
    public sealed virtual ICollection`1<V> get_Values();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<K> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Keys();
    private sealed virtual override IEnumerable`1<V> System.Collections.Generic.IReadOnlyDictionary<K,V>.get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual V get_Item(K key);
    public sealed virtual void set_Item(K key, V value);
    public sealed virtual void Add(K key, V value);
    public sealed virtual bool ContainsKey(K key);
    public sealed virtual bool Remove(K key);
    public sealed virtual bool TryGetValue(K key, V& value);
    public sealed virtual void Add(KeyValuePair`2<K, V> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<K, V> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<K, V> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(object key, object value);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual void CopyTo(Array array, int index);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Build.Collections.HashSetDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.Build.Collections.RetrievableEntryHashSet`1 : object {
    private static int Lower31BitMask;
    private static int ShrinkThreshold;
    private static string CapacityName;
    private static string ElementsName;
    private static string ComparerName;
    private static string VersionName;
    private Int32[] _buckets;
    private Slot[] _slots;
    private int _count;
    private int _lastIndex;
    private int _freeList;
    private IEqualityComparer`1<string> _comparer;
    private IConstrainedEqualityComparer`1<string> _constrainedComparer;
    private int _version;
    private bool _readOnly;
    private SerializationInfo _siInfo;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<T> Values { get; }
    internal T Item { get; internal set; }
    private T System.Collections.Generic.IDictionary<System.String,T>.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public RetrievableEntryHashSet`1(IEqualityComparer`1<string> comparer);
    public RetrievableEntryHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<string> comparer, bool readOnly);
    public RetrievableEntryHashSet`1(IEnumerable`1<KeyValuePair`2<string, T>> collection, IEqualityComparer`1<string> comparer, bool readOnly);
    public RetrievableEntryHashSet`1(int suggestedCapacity, IEqualityComparer`1<string> comparer);
    public RetrievableEntryHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<string> comparer);
    protected RetrievableEntryHashSet`1(SerializationInfo info, StreamingContext context);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<T> get_Values();
    internal T get_Item(string name);
    internal void set_Item(string name, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    internal bool Contains(string key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Contains(KeyValuePair`2<string, T> entry);
    public sealed virtual bool ContainsKey(string key);
    private sealed virtual override T System.Collections.Generic.IDictionary<System.String,T>.get_Item(string name);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.set_Item(string name, T value);
    public sealed virtual bool Contains(T item);
    public sealed virtual bool TryGetValue(string key, T& item);
    public T Get(string key);
    public T Get(string key, int index, int length);
    private T GetCore(string item, int index, int length);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Remove(KeyValuePair`2<string, T> entry);
    public sealed virtual bool Remove(string item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    internal void MakeReadOnly();
    public Enumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.RetrievableEntryHashSet`1/<System-Collections-Generic-IEnumerable<System-Collections-Generic-KeyValuePair<System-String,T>>-GetEnumerator>d__52")]
private sealed virtual override IEnumerator`1<KeyValuePair`2<string, T>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,T>>.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void OnDeserialization(object sender);
    public void Add(T item);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,T>.Add(string key, T item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.Add(KeyValuePair`2<string, T> entry);
    public void UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,T>>.CopyTo(KeyValuePair`2[] array, int index);
    public void CopyTo(T[] array);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public void TrimExcess();
    private void Initialize(int capacity);
    private void IncreaseCapacity();
    private bool AddEvenIfPresent(T value);
    internal bool EntriesAreReferenceEquals(RetrievableEntryHashSet`1<T> other);
    internal T[] ToArray();
    private int InternalGetHashCode(string item, int index, int length);
    private int InternalGetHashCode(string item);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.WeakValueDictionary`2 : object {
    [DebuggerBrowsableAttribute("3")]
private Dictionary`2<K, WeakReference`1<V>> _dictionary;
    [DebuggerBrowsableAttribute("0")]
private int _capacity;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public V Item { get; public set; }
    public WeakValueDictionary`2(IEqualityComparer`1<K> keyComparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool Contains(K key);
    public bool TryGetValue(K key, V& value);
    public bool Remove(K key);
    public int Scavenge();
    public void Clear();
    [IteratorStateMachineAttribute("Microsoft.Build.Collections.WeakValueDictionary`2/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<KeyValuePair`2<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Construction.AspNetCompilerParameters : ValueType {
    internal string aspNetVirtualPath;
    internal string aspNetPhysicalPath;
    internal string aspNetTargetPath;
    internal string aspNetForce;
    internal string aspNetUpdateable;
    internal string aspNetDebug;
    internal string aspNetKeyFile;
    internal string aspNetKeyContainer;
    internal string aspNetDelaySign;
    internal string aspNetAPTCA;
    internal string aspNetFixedNames;
}
public abstract class Microsoft.Build.Construction.ElementLocation : object {
    private static ElementLocation s_emptyElementLocation;
    [DebuggerBrowsableAttribute("0")]
public string File { get; }
    [DebuggerBrowsableAttribute("0")]
public int Line { get; }
    [DebuggerBrowsableAttribute("0")]
public int Column { get; }
    public string LocationString { get; }
    internal static ElementLocation EmptyLocation { get; }
    private static ElementLocation();
    public abstract virtual string get_File();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public sealed virtual string get_LocationString();
    internal static ElementLocation get_EmptyLocation();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ElementLocation FactoryForDeserialization(ITranslator translator);
    internal static ElementLocation Create(string file);
    internal static ElementLocation Create(string file, int line, int column);
    private static string GetLocationString(string file, int line, int column);
}
public enum Microsoft.Build.Construction.ImplicitImportLocation : Enum {
    public int value__;
    public static ImplicitImportLocation None;
    public static ImplicitImportLocation Top;
    public static ImplicitImportLocation Bottom;
}
[DebuggerDisplayAttribute("ProjectChooseElement (#Children={Count} HasOtherwise={OtherwiseElement != null})")]
public class Microsoft.Build.Construction.ProjectChooseElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectWhenElement> WhenElements { get; }
    public ProjectOtherwiseElement OtherwiseElement { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectChooseElement(ProjectChooseElementLink link);
    internal ProjectChooseElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectChooseElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectWhenElement> get_WhenElements();
    public ProjectOtherwiseElement get_OtherwiseElement();
    public virtual ElementLocation get_ConditionLocation();
    internal static ProjectChooseElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
public class Microsoft.Build.Construction.ProjectConfigurationInSolution : object {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInBuild>k__BackingField;
    public string ConfigurationName { get; }
    public string PlatformName { get; }
    public string FullName { get; }
    public bool IncludeInBuild { get; }
    internal ProjectConfigurationInSolution(string configurationName, string platformName, bool includeInBuild);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public string get_PlatformName();
    [CompilerGeneratedAttribute]
public string get_FullName();
    [CompilerGeneratedAttribute]
public bool get_IncludeInBuild();
    private static string RemoveSpaceFromAnyCpuPlatform(string platformName);
}
public abstract class Microsoft.Build.Construction.ProjectElement : object {
    private ProjectElementContainer _parent;
    private string _condition;
    private bool _expressedAsAttribute;
    private ProjectElement _previousSibling;
    private ProjectElement _nextSibling;
    private ILinkedXml _xmlSource;
    internal bool ExpressedAsAttribute { get; internal set; }
    public string Condition { get; public set; }
    public string Label { get; public set; }
    public ProjectElementContainer Parent { get; internal set; }
    public string OuterElement { get; }
    public IEnumerable`1<ProjectElementContainer> AllParents { get; }
    public ProjectElement PreviousSibling { get; internal set; }
    public ProjectElement NextSibling { get; internal set; }
    public ProjectRootElement ContainingProject { get; internal set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation LabelLocation { get; }
    public ElementLocation Location { get; }
    public string ElementName { get; }
    internal ProjectElementLink Link { get; }
    private object Microsoft.Build.ObjectModelRemoting.ILinkableObject.Link { get; }
    internal XmlElementWithLocation XmlElement { get; }
    internal XmlDocumentWithLocation XmlDocument { get; }
    internal ProjectElement(ProjectElementLink link);
    internal ProjectElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    internal virtual bool get_ExpressedAsAttribute();
    internal virtual void set_ExpressedAsAttribute(bool value);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Label();
    [DebuggerStepThroughAttribute]
public void set_Label(string value);
    [DebuggerStepThroughAttribute]
public ProjectElementContainer get_Parent();
    internal void set_Parent(ProjectElementContainer value);
    public sealed virtual string get_OuterElement();
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectElement/<get_AllParents>d__23")]
public IEnumerable`1<ProjectElementContainer> get_AllParents();
    [DebuggerStepThroughAttribute]
public ProjectElement get_PreviousSibling();
    [DebuggerStepThroughAttribute]
internal void set_PreviousSibling(ProjectElement value);
    [DebuggerStepThroughAttribute]
public ProjectElement get_NextSibling();
    [DebuggerStepThroughAttribute]
internal void set_NextSibling(ProjectElement value);
    public ProjectRootElement get_ContainingProject();
    internal void set_ContainingProject(ProjectRootElement value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_LabelLocation();
    public ElementLocation get_Location();
    public sealed virtual string get_ElementName();
    internal ProjectElementLink get_Link();
    private sealed virtual override object Microsoft.Build.ObjectModelRemoting.ILinkableObject.get_Link();
    internal XmlElementWithLocation get_XmlElement();
    [DebuggerStepThroughAttribute]
internal XmlDocumentWithLocation get_XmlDocument();
    public ProjectElement Clone();
    public virtual void CopyFrom(ProjectElement element);
    protected virtual bool ShouldCloneXmlAttribute(XmlAttribute attribute);
    internal virtual bool ShouldCloneXmlAttribute(XmlAttributeLink attributeLink);
    internal void SetProjectRootElementFromParser(XmlElementWithLocation xmlElement, ProjectRootElement projectRootElement);
    internal void ClearParent();
    internal void ReplaceElement(XmlElementWithLocation newElement);
    internal abstract virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer proposedParent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void MarkDirty(string reason, string param);
    internal virtual void OnAfterParentChanged(ProjectElementContainer newParent);
    protected internal virtual ProjectElement Clone(ProjectRootElement factory);
    protected abstract virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    internal static ProjectElement CreateNewInstance(ProjectElement xml, ProjectRootElement owner);
    internal ElementLocation GetAttributeLocation(string attributeName);
    internal string GetAttributeValue(string attributeName, bool nullIfNotExists);
    internal string GetAttributeValue(string attributeName, String& cache);
    internal virtual void ClearAttributeCache();
    internal void SetOrRemoveAttributeForLink(string name, string value, bool clearAttributeCache, string reason, string param);
    internal void SetOrRemoveAttribute(string name, string value, string reason, string param);
    internal void SetOrRemoveAttribute(string name, string value, String& cache, string reason, string param);
}
public abstract class Microsoft.Build.Construction.ProjectElementContainer : ProjectElement {
    private static string DEFAULT_INDENT;
    private int _count;
    private ProjectElement _firstChild;
    private ProjectElement _lastChild;
    internal ProjectElementContainerLink ContainerLink { get; }
    public IEnumerable`1<ProjectElement> AllChildren { get; }
    public ICollection`1<ProjectElement> Children { get; }
    internal ProjectElementSiblingEnumerable ChildrenEnumerable { get; }
    public ICollection`1<ProjectElement> ChildrenReversed { get; }
    public int Count { get; private set; }
    public ProjectElement FirstChild { get; private set; }
    public ProjectElement LastChild { get; private set; }
    internal ProjectElementContainer(ProjectElementContainerLink link);
    internal ProjectElementContainer(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    internal ProjectElementContainerLink get_ContainerLink();
    public IEnumerable`1<ProjectElement> get_AllChildren();
    internal IEnumerable`1<T> GetAllChildrenOfType();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectElement> get_Children();
    internal ProjectElementSiblingEnumerable get_ChildrenEnumerable();
    internal ProjectElementSiblingSubTypeCollection`1<T> GetChildrenOfType();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectElement> get_ChildrenReversed();
    internal ProjectElementSiblingSubTypeCollection`1<T> GetChildrenReversedOfType();
    public int get_Count();
    private void set_Count(int value);
    public ProjectElement get_FirstChild();
    private void set_FirstChild(ProjectElement value);
    public ProjectElement get_LastChild();
    private void set_LastChild(ProjectElement value);
    public void InsertAfterChild(ProjectElement child, ProjectElement reference);
    public void InsertBeforeChild(ProjectElement child, ProjectElement reference);
    public void AppendChild(ProjectElement child);
    public void PrependChild(ProjectElement child);
    public void RemoveChild(ProjectElement child);
    public void RemoveAllChildren();
    public virtual void DeepCopyFrom(ProjectElementContainer element);
    internal void AppendParentedChildNoChecks(ProjectElement child);
    protected internal virtual ProjectElementContainer DeepClone(ProjectRootElement factory, ProjectElementContainer parent);
    internal static ProjectElementContainer DeepClone(ProjectElementContainer xml, ProjectRootElement factory, ProjectElementContainer parent);
    private void SetElementAsAttributeValue(ProjectElement child);
    internal void UpdateElementValue(ProjectElement child);
    internal void AddToXml(ProjectElement child);
    private static string GetElementIndentation(XmlElementWithLocation xmlElement);
    internal void RemoveFromXml(ProjectElement child);
    internal void AddInitialChild(ProjectElement child);
    private void VerifyForInsertBeforeAfterFirst(ProjectElement child, ProjectElement reference);
    private void VerifyThrowInvalidOperationNotSelfAncestor(ProjectElement element);
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectElementContainer/<GetDescendants>d__47")]
private IEnumerable`1<ProjectElement> GetDescendants();
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectElementContainer/<GetDescendantsOfType>d__48`1")]
private IEnumerable`1<T> GetDescendantsOfType();
    private static bool TrySearchLeftSiblings(ProjectElement initialElement, Predicate`1<ProjectElement> siblingIsAcceptable, ProjectElement& referenceSibling);
    private static bool TrySearchRightSiblings(ProjectElement initialElement, Predicate`1<ProjectElement> siblingIsAcceptable, ProjectElement& referenceSibling);
    private static bool TrySearchSiblings(ProjectElement initialElement, Predicate`1<ProjectElement> siblingIsAcceptable, Func`2<ProjectElement, ProjectElement> nextSibling, ProjectElement& referenceSibling);
    [CompilerGeneratedAttribute]
internal static bool <AddToXml>g__SiblingIsExplicitElement|41_0(ProjectElement _);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Construction.ProjectExtensionsElement : ProjectElement {
    internal ProjectExtensionsElementLink ExtensionLink { get; }
    public string Condition { get; public set; }
    public string Content { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public string Item { get; public set; }
    internal ProjectExtensionsElement(ProjectExtensionsElementLink link);
    internal ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement parent, ProjectRootElement project);
    private ProjectExtensionsElement(XmlElement xmlElement, ProjectRootElement project);
    internal ProjectExtensionsElementLink get_ExtensionLink();
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    [DebuggerStepThroughAttribute]
public string get_Content();
    public void set_Content(string value);
    public virtual ElementLocation get_ConditionLocation();
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectExtensionsElement CreateParented(XmlElementWithLocation element, ProjectRootElement parent, ProjectRootElement containingProject);
    internal static ProjectExtensionsElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("Project={Project} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectImportElement : ProjectElement {
    private ImplicitImportLocation _implicitImportLocation;
    private ProjectElement _originalElement;
    [CompilerGeneratedAttribute]
private SdkReference <SdkReference>k__BackingField;
    internal ProjectImportElementLink ImportLink { get; }
    public string Project { get; public set; }
    public ElementLocation ProjectLocation { get; }
    public string Sdk { get; public set; }
    public string Version { get; public set; }
    public string MinimumVersion { get; public set; }
    public ElementLocation SdkLocation { get; }
    public ImplicitImportLocation ImplicitImportLocation { get; internal set; }
    public ProjectElement OriginalElement { get; internal set; }
    internal SdkReference SdkReference { get; internal set; }
    internal ProjectImportElement(ProjectImportElementLink link);
    internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject, SdkReference sdkReference);
    internal ProjectImportElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    internal ProjectImportElementLink get_ImportLink();
    public string get_Project();
    public void set_Project(string value);
    public ElementLocation get_ProjectLocation();
    public string get_Sdk();
    public void set_Sdk(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_MinimumVersion();
    public void set_MinimumVersion(string value);
    public ElementLocation get_SdkLocation();
    public ImplicitImportLocation get_ImplicitImportLocation();
    internal void set_ImplicitImportLocation(ImplicitImportLocation value);
    public ProjectElement get_OriginalElement();
    internal void set_OriginalElement(ProjectElement value);
    [CompilerGeneratedAttribute]
internal SdkReference get_SdkReference();
    [CompilerGeneratedAttribute]
internal void set_SdkReference(SdkReference value);
    internal static ProjectImportElement CreateDisconnected(string project, ProjectRootElement containingProject);
    internal static ProjectImportElement CreateImplicit(string project, ProjectRootElement containingProject, ImplicitImportLocation implicitImportLocation, SdkReference sdkReference, ProjectElement originalElement);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private bool UpdateSdkReference(string name, string version, string minimumVersion);
}
[DebuggerDisplayAttribute("#Imports={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectImportGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectImportElement> Imports { get; }
    internal ProjectImportGroupElement(ProjectImportGroupElementLink link);
    internal ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectImportGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectImportElement> get_Imports();
    public ProjectImportElement AddImport(string project);
    internal static ProjectImportGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
public class Microsoft.Build.Construction.ProjectInSolution : object {
    private static Char[] s_charsToCleanse;
    internal static String[] projectNamesToDisambiguate;
    private static char cleanCharacter;
    private string _relativePath;
    private string _absolutePath;
    private List`1<string> _dependencies;
    private IReadOnlyList`1<string> _dependenciesAsReadonly;
    private string _uniqueProjectName;
    private string _originalProjectName;
    private Dictionary`2<string, ProjectConfigurationInSolution> _projectConfigurations;
    private IReadOnlyDictionary`2<string, ProjectConfigurationInSolution> _projectConfigurationsReadOnly;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentProjectGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private SolutionProjectType <ProjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private SolutionFile <ParentSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <AspNetConfigurations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkMoniker>k__BackingField;
    private bool _checkedIfCanBeMSBuildProjectFile;
    private bool _canBeMSBuildProjectFile;
    private string _canBeMSBuildProjectFileErrorMessage;
    internal static int DependencyLevelUnknown;
    internal static int DependencyLevelBeingDetermined;
    public string ProjectName { get; internal set; }
    public string RelativePath { get; internal set; }
    public string AbsolutePath { get; }
    public string ProjectGuid { get; internal set; }
    public string ParentProjectGuid { get; internal set; }
    public IReadOnlyList`1<string> Dependencies { get; }
    public IReadOnlyDictionary`2<string, ProjectConfigurationInSolution> ProjectConfigurations { get; }
    internal string Extension { get; }
    public SolutionProjectType ProjectType { get; public set; }
    internal List`1<string> ProjectReferences { get; }
    internal SolutionFile ParentSolution { get; internal set; }
    internal Hashtable AspNetConfigurations { get; internal set; }
    internal string TargetFrameworkMoniker { get; internal set; }
    internal ProjectInSolution(SolutionFile solution);
    private static ProjectInSolution();
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
internal void set_ProjectName(string value);
    public string get_RelativePath();
    internal void set_RelativePath(string value);
    public string get_AbsolutePath();
    [CompilerGeneratedAttribute]
public string get_ProjectGuid();
    [CompilerGeneratedAttribute]
internal void set_ProjectGuid(string value);
    [CompilerGeneratedAttribute]
public string get_ParentProjectGuid();
    [CompilerGeneratedAttribute]
internal void set_ParentProjectGuid(string value);
    public IReadOnlyList`1<string> get_Dependencies();
    public IReadOnlyDictionary`2<string, ProjectConfigurationInSolution> get_ProjectConfigurations();
    internal string get_Extension();
    [CompilerGeneratedAttribute]
public SolutionProjectType get_ProjectType();
    [CompilerGeneratedAttribute]
public void set_ProjectType(SolutionProjectType value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_ProjectReferences();
    [CompilerGeneratedAttribute]
internal SolutionFile get_ParentSolution();
    [CompilerGeneratedAttribute]
internal void set_ParentSolution(SolutionFile value);
    [CompilerGeneratedAttribute]
internal Hashtable get_AspNetConfigurations();
    [CompilerGeneratedAttribute]
internal void set_AspNetConfigurations(Hashtable value);
    [CompilerGeneratedAttribute]
internal string get_TargetFrameworkMoniker();
    [CompilerGeneratedAttribute]
internal void set_TargetFrameworkMoniker(string value);
    internal void AddDependency(string referencedProjectGuid);
    internal void SetProjectConfiguration(string configurationName, ProjectConfigurationInSolution configuration);
    internal bool CanBeMSBuildProjectFile(String& errorMessage);
    internal string GetUniqueProjectName();
    internal string GetOriginalProjectName();
    internal string GetProjectGuidWithoutCurlyBrackets();
    internal void UpdateUniqueProjectName(string newUniqueName);
    private static string CleanseProjectName(string projectName);
    internal static string DisambiguateProjectTargetName(string uniqueProjectName);
    private static bool ElementContainsInvalidNamespaceDefitions(XmlElement mainProjectElement);
}
[DebuggerDisplayAttribute("{ItemType} #Metadata={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectItemDefinitionElement : ProjectElementContainer {
    public string ItemType { get; }
    public ICollection`1<ProjectMetadataElement> Metadata { get; }
    internal ProjectItemDefinitionElement(ProjectItemDefinitionElementLink link);
    internal ProjectItemDefinitionElement(XmlElement xmlElement, ProjectItemDefinitionGroupElement parent, ProjectRootElement containingProject);
    private ProjectItemDefinitionElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public string get_ItemType();
    public ICollection`1<ProjectMetadataElement> get_Metadata();
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue);
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute);
    internal static ProjectItemDefinitionElement CreateDisconnected(string itemType, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    protected virtual bool ShouldCloneXmlAttribute(XmlAttribute attribute);
    internal virtual bool ShouldCloneXmlAttribute(XmlAttributeLink attributeLink);
}
[DebuggerDisplayAttribute("#ItemDefinitions={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectItemDefinitionGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectItemDefinitionElement> ItemDefinitions { get; }
    internal ProjectItemDefinitionGroupElement(ProjectItemDefinitionGroupElementLink link);
    internal ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectItemDefinitionGroupElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemDefinitionElement> get_ItemDefinitions();
    public ProjectItemDefinitionElement AddItemDefinition(string itemType);
    internal static ProjectItemDefinitionGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{ItemType} Include={Include} Exclude={Exclude} #Metadata={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectItemElement : ProjectElementContainer {
    private string _include;
    private string _exclude;
    private string _remove;
    private string _matchOnMetadata;
    private string _update;
    private Nullable`1<bool> _includeHasWildcards;
    internal ProjectItemElementLink ItemLink { get; }
    public string ItemType { get; public set; }
    public string Include { get; public set; }
    public string Exclude { get; public set; }
    public string Remove { get; public set; }
    public string Update { get; public set; }
    public string MatchOnMetadata { get; public set; }
    public string MatchOnMetadataOptions { get; public set; }
    public string KeepMetadata { get; public set; }
    public string RemoveMetadata { get; public set; }
    public string KeepDuplicates { get; public set; }
    public bool HasMetadata { get; }
    public ICollection`1<ProjectMetadataElement> Metadata { get; }
    public ElementLocation IncludeLocation { get; }
    public ElementLocation ExcludeLocation { get; }
    public ElementLocation RemoveLocation { get; }
    public ElementLocation UpdateLocation { get; }
    public ElementLocation MatchOnMetadataLocation { get; }
    public ElementLocation MatchOnMetadataOptionsLocation { get; }
    public ElementLocation KeepMetadataLocation { get; }
    public ElementLocation RemoveMetadataLocation { get; }
    public ElementLocation KeepDuplicatesLocation { get; }
    internal bool IncludeHasWildcards { get; }
    internal ProjectItemElement NextItem { get; }
    internal ProjectItemElement(ProjectItemElementLink link);
    internal ProjectItemElement(XmlElementWithLocation xmlElement, ProjectItemGroupElement parent, ProjectRootElement containingProject);
    private ProjectItemElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    internal ProjectItemElementLink get_ItemLink();
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_Include();
    public void set_Include(string value);
    [DebuggerStepThroughAttribute]
public string get_Exclude();
    public void set_Exclude(string value);
    [DebuggerStepThroughAttribute]
public string get_Remove();
    public void set_Remove(string value);
    [DebuggerStepThroughAttribute]
public string get_Update();
    public void set_Update(string value);
    [DebuggerStepThroughAttribute]
public string get_MatchOnMetadata();
    public void set_MatchOnMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_MatchOnMetadataOptions();
    public void set_MatchOnMetadataOptions(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepMetadata();
    public void set_KeepMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_RemoveMetadata();
    public void set_RemoveMetadata(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicates();
    public void set_KeepDuplicates(string value);
    public bool get_HasMetadata();
    public ICollection`1<ProjectMetadataElement> get_Metadata();
    public ElementLocation get_IncludeLocation();
    public ElementLocation get_ExcludeLocation();
    public ElementLocation get_RemoveLocation();
    public ElementLocation get_UpdateLocation();
    public ElementLocation get_MatchOnMetadataLocation();
    public ElementLocation get_MatchOnMetadataOptionsLocation();
    public ElementLocation get_KeepMetadataLocation();
    public ElementLocation get_RemoveMetadataLocation();
    public ElementLocation get_KeepDuplicatesLocation();
    internal bool get_IncludeHasWildcards();
    internal ProjectItemElement get_NextItem();
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue);
    public ProjectMetadataElement AddMetadata(string name, string unevaluatedValue, bool expressAsAttribute);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectItemElement CreateDisconnected(string itemType, ProjectRootElement containingProject);
    internal void ChangeItemType(string newItemType);
    internal virtual void ClearAttributeCache();
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void OnAfterParentChanged(ProjectElementContainer parent);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    protected virtual bool ShouldCloneXmlAttribute(XmlAttribute attribute);
    internal virtual bool ShouldCloneXmlAttribute(XmlAttributeLink attributeLink);
}
[DebuggerDisplayAttribute("#Items={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectItemGroupElement : ProjectElementContainer {
    private bool _definitelyAreNoChildrenWithWildcards;
    public ICollection`1<ProjectItemElement> Items { get; }
    internal bool DefinitelyAreNoChildrenWithWildcards { get; internal set; }
    internal ProjectItemGroupElement(ProjectItemGroupElementLink link);
    internal ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectItemGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectItemElement> get_Items();
    internal bool get_DefinitelyAreNoChildrenWithWildcards();
    internal void set_DefinitelyAreNoChildrenWithWildcards(bool value);
    public ProjectItemElement AddItem(string itemType, string include);
    public ProjectItemElement AddItem(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectItemGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{Name} Value={Value} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectMetadataElement : ProjectElement {
    internal ProjectMetadataElementLink MetadataLink { get; }
    public string Name { get; public set; }
    public bool ExpressedAsAttribute { get; public set; }
    public string Value { get; public set; }
    internal ProjectMetadataElement(ProjectMetadataElementLink link);
    internal ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project);
    private ProjectMetadataElement(XmlElementWithLocation xmlElement, ProjectRootElement project);
    internal ProjectMetadataElementLink get_MetadataLink();
    public string get_Name();
    public void set_Name(string value);
    public bool get_ExpressedAsAttribute();
    public void set_ExpressedAsAttribute(bool value);
    public string get_Value();
    public void set_Value(string value);
    internal static ProjectMetadataElement CreateDisconnected(string name, ProjectRootElement containingProject, ElementLocation location);
    internal void ChangeName(string newName);
    internal static void ValidateValidMetadataAsAttributeName(string name, string parentName, IElementLocation parentLocation);
    internal static bool AttributeNameIsValidMetadataName(string name);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("ExecuteTargetsAttribute={ExecuteTargetsAttribute}")]
public class Microsoft.Build.Construction.ProjectOnErrorElement : ProjectElement {
    public string ExecuteTargetsAttribute { get; public set; }
    public ElementLocation ExecuteTargetsLocation { get; }
    internal ProjectOnErrorElement(ProjectOnErrorElementLink link);
    internal ProjectOnErrorElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement project);
    private ProjectOnErrorElement(XmlElementWithLocation xmlElement, ProjectRootElement project);
    [DebuggerStepThroughAttribute]
public string get_ExecuteTargetsAttribute();
    public void set_ExecuteTargetsAttribute(string value);
    public ElementLocation get_ExecuteTargetsLocation();
    internal static ProjectOnErrorElement CreateDisconnected(string executeTargets, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#Children={Count}")]
public class Microsoft.Build.Construction.ProjectOtherwiseElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectOtherwiseElement(ProjectOtherwiseElementLink link);
    internal ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement project);
    private ProjectOtherwiseElement(XmlElementWithLocation xmlElement, ProjectRootElement project);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public virtual ElementLocation get_ConditionLocation();
    internal static ProjectOtherwiseElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("TaskParameter={TaskParameter} ItemType={ItemType} PropertyName={PropertyName} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectOutputElement : ProjectElement {
    public string TaskParameter { get; public set; }
    public bool IsOutputItem { get; }
    public bool IsOutputProperty { get; }
    public string ItemType { get; public set; }
    public string PropertyName { get; public set; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation PropertyNameLocation { get; }
    public ElementLocation ItemTypeLocation { get; }
    internal ProjectOutputElement(ProjectOutputElementLink link);
    internal ProjectOutputElement(XmlElement xmlElement, ProjectTaskElement parent, ProjectRootElement containingProject);
    private ProjectOutputElement(XmlElement xmlElement, ProjectRootElement containingProject);
    [DebuggerStepThroughAttribute]
public string get_TaskParameter();
    [DebuggerStepThroughAttribute]
public void set_TaskParameter(string value);
    public bool get_IsOutputItem();
    public bool get_IsOutputProperty();
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_PropertyName();
    public void set_PropertyName(string value);
    public ElementLocation get_TaskParameterLocation();
    public ElementLocation get_PropertyNameLocation();
    public ElementLocation get_ItemTypeLocation();
    internal static ProjectOutputElement CreateDisconnected(string taskParameter, string itemType, string propertyName, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
internal class Microsoft.Build.Construction.ProjectParser : object {
    internal static int MaximumChooseNesting;
    private static HashSet`1<string> ValidAttributesOnlyConditionAndLabel;
    private static HashSet`1<string> KnownAttributesOnItem;
    private static HashSet`1<string> KnownAttributesOnItemIgnoreCase;
    private static HashSet`1<string> ValidAttributesOnImport;
    private static HashSet`1<string> ValidAttributesOnUsingTask;
    private static HashSet`1<string> ValidAttributesOnTarget;
    private static HashSet`1<string> ValidAttributesOnOnError;
    private static HashSet`1<string> ValidAttributesOnOutput;
    private static HashSet`1<string> ValidAttributesOnUsingTaskParameter;
    private static HashSet`1<string> ValidAttributesOnUsingTaskBody;
    private ProjectRootElement _project;
    private XmlDocumentWithLocation _document;
    private bool _seenProjectExtensions;
    private ProjectParser(XmlDocumentWithLocation document, ProjectRootElement project);
    private static ProjectParser();
    internal static void Parse(XmlDocumentWithLocation document, ProjectRootElement projectRootElement);
    private void Parse();
    private ProjectPropertyGroupElement ParseProjectPropertyGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectItemGroupElement ParseProjectItemGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectItemElement ParseProjectItemElement(XmlElementWithLocation element, ProjectItemGroupElement parent);
    internal static void CheckMetadataAsAttributeName(string name, Boolean& isReservedAttributeName, Boolean& isValidMetadataNameInAttribute);
    private ProjectMetadataElement ParseProjectMetadataElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectImportGroupElement ParseProjectImportGroupElement(XmlElementWithLocation element, ProjectRootElement parent);
    private ProjectImportElement ParseProjectImportElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private UsingTaskParameterGroupElement ParseUsingTaskParameterGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectUsingTaskElement ParseProjectUsingTaskElement(XmlElementWithLocation element);
    private ProjectTargetElement ParseProjectTargetElement(XmlElementWithLocation element);
    private ProjectTaskElement ParseProjectTaskElement(XmlElementWithLocation element, ProjectTargetElement parent);
    private ProjectOutputElement ParseProjectOutputElement(XmlElementWithLocation element, ProjectTaskElement parent);
    private ProjectItemDefinitionGroupElement ParseProjectItemDefinitionGroupElement(XmlElementWithLocation element, ProjectElementContainer parent);
    private ProjectItemDefinitionElement ParseProjectItemDefinitionXml(XmlElementWithLocation element, ProjectItemDefinitionGroupElement parent);
    private ProjectChooseElement ParseProjectChooseElement(XmlElementWithLocation element, ProjectElementContainer parent, int nestingDepth);
    private ProjectWhenElement ParseProjectWhenElement(XmlElementWithLocation element, ProjectChooseElement parent, int nestingDepth);
    private ProjectOtherwiseElement ParseProjectOtherwiseElement(XmlElementWithLocation element, ProjectChooseElement parent, int nestingDepth);
    private void ParseWhenOtherwiseChildren(XmlElementWithLocation element, ProjectElementContainer parent, int nestingDepth);
    private ProjectExtensionsElement ParseProjectExtensionsElement(XmlElementWithLocation element);
    private ProjectSdkElement ParseProjectSdkElement(XmlElementWithLocation element);
}
[DebuggerDisplayAttribute("{Name} Value={Value} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectPropertyElement : ProjectElement {
    internal ProjectPropertyElementLink PropertyLink { get; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    internal ProjectPropertyElement(ProjectPropertyElementLink link);
    internal ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectPropertyGroupElement parent, ProjectRootElement containingProject);
    private ProjectPropertyElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    internal ProjectPropertyElementLink get_PropertyLink();
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
    internal static ProjectPropertyElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal void ChangeName(string newName);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#Properties={Count} Condition={Condition} Label={Label}")]
public class Microsoft.Build.Construction.ProjectPropertyGroupElement : ProjectElementContainer {
    public ICollection`1<ProjectPropertyElement> Properties { get; }
    public ICollection`1<ProjectPropertyElement> PropertiesReversed { get; }
    internal ProjectPropertyGroupElement(ProjectPropertyGroupElementLink link);
    internal ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private ProjectPropertyGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectPropertyElement> get_Properties();
    public ICollection`1<ProjectPropertyElement> get_PropertiesReversed();
    public ProjectPropertyElement AddProperty(string name, string unevaluatedValue);
    public ProjectPropertyElement SetProperty(string name, string unevaluatedValue);
    internal static ProjectPropertyGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{FullPath} #Children={Count} DefaultTargets={DefaultTargets} ToolsVersion={ToolsVersion} InitialTargets={InitialTargets} ExplicitlyLoaded={IsExplicitlyLoaded}")]
public class Microsoft.Build.Construction.ProjectRootElement : ProjectElementContainer {
    private static string EmptyProjectFileContent;
    private static string EmptyProjectFileXmlDeclaration;
    private static string EmptyProjectFileToolsVersion;
    internal static string EmptyProjectFileXmlNamespace;
    private static OpenProjectRootElement s_openLoaderDelegate;
    private static OpenProjectRootElement s_openLoaderPreserveFormattingDelegate;
    private static Lazy`1<Regex> XmlDeclarationRegEx;
    private static Encoding s_defaultEncoding;
    private static int s_globalVersionCounter;
    private int _version;
    private int _versionOnDisk;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    private ElementLocation _projectFileLocation;
    private string _escapedFullPath;
    private string _directory;
    private DateTime _timeLastChangedUtc;
    private DateTime _lastWriteTimeWhenReadUtc;
    private string _dirtyReason;
    private string _dirtyParameter;
    [CompilerGeneratedAttribute]
private RenameHandlerDelegate OnAfterProjectRename;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectXmlChangedEventArgs> OnProjectXmlChanged;
    internal Nullable`1<DateTime> StreamTimeUtc;
    [CompilerGeneratedAttribute]
private bool <IsExplicitlyLoaded>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheBase <ProjectRootElementCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsTargetsWithReturnsAttribute>k__BackingField;
    internal string XmlNamespace { get; internal set; }
    internal ProjectRootElementLink RootLink { get; }
    public string Condition { get; public set; }
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ICollection`1<ProjectItemDefinitionGroupElement> ItemDefinitionGroups { get; }
    public ICollection`1<ProjectItemDefinitionElement> ItemDefinitions { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectItemElement> Items { get; }
    public ICollection`1<ProjectImportGroupElement> ImportGroups { get; }
    public ICollection`1<ProjectImportElement> Imports { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectPropertyElement> Properties { get; }
    public ICollection`1<ProjectTargetElement> Targets { get; }
    public ICollection`1<ProjectUsingTaskElement> UsingTasks { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroupsReversed { get; }
    public ICollection`1<ProjectItemDefinitionGroupElement> ItemDefinitionGroupsReversed { get; }
    public ICollection`1<ProjectImportGroupElement> ImportGroupsReversed { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroupsReversed { get; }
    public string DirectoryPath { get; internal set; }
    public string EscapedFullPath { get; }
    public string FullPath { get; public set; }
    public Encoding Encoding { get; }
    public string DefaultTargets { get; public set; }
    public string InitialTargets { get; public set; }
    public string Sdk { get; public set; }
    public string TreatAsLocalProperty { get; public set; }
    public string ToolsVersion { get; public set; }
    public string RawXml { get; }
    public bool HasUnsavedChanges { get; }
    public bool PreserveFormatting { get; }
    public int Version { get; private set; }
    public DateTime TimeLastChanged { get; }
    public DateTime LastWriteTimeWhenRead { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ProjectFileLocation { get; }
    public ElementLocation ToolsVersionLocation { get; }
    public ElementLocation DefaultTargetsLocation { get; }
    public ElementLocation InitialTargetsLocation { get; }
    public ElementLocation SdkLocation { get; }
    public ElementLocation TreatAsLocalPropertyLocation { get; }
    internal bool IsExplicitlyLoaded { get; private set; }
    internal ProjectRootElementCacheBase ProjectRootElementCache { get; }
    internal bool IsMemberOfProjectCollection { get; }
    internal bool ContainsTargetsWithReturnsAttribute { get; internal set; }
    internal ProjectExtensionsElement ProjectExtensions { get; }
    internal string LastDirtyReason { get; }
    internal ProjectRootElement(ProjectRootElementLink link);
    internal ProjectRootElement(XmlReader xmlReader, ProjectRootElementCacheBase projectRootElementCache, bool isExplicitlyLoaded, bool preserveFormatting);
    private ProjectRootElement(ProjectRootElementCacheBase projectRootElementCache, NewProjectFileOptions projectFileOptions);
    private ProjectRootElement(string path, ProjectRootElementCacheBase projectRootElementCache, bool preserveFormatting);
    private ProjectRootElement(XmlDocumentWithLocation document, ProjectRootElementCacheBase projectRootElementCache);
    private ProjectRootElement(XmlDocumentWithLocation document);
    private static ProjectRootElement();
    [CompilerGeneratedAttribute]
internal string get_XmlNamespace();
    [CompilerGeneratedAttribute]
internal void set_XmlNamespace(string value);
    internal ProjectRootElementLink get_RootLink();
    [CompilerGeneratedAttribute]
internal void add_OnAfterProjectRename(RenameHandlerDelegate value);
    [CompilerGeneratedAttribute]
internal void remove_OnAfterProjectRename(RenameHandlerDelegate value);
    [CompilerGeneratedAttribute]
internal void add_OnProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_OnProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public ICollection`1<ProjectItemDefinitionGroupElement> get_ItemDefinitionGroups();
    public ICollection`1<ProjectItemDefinitionElement> get_ItemDefinitions();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectItemElement> get_Items();
    public ICollection`1<ProjectImportGroupElement> get_ImportGroups();
    public ICollection`1<ProjectImportElement> get_Imports();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectPropertyElement> get_Properties();
    public ICollection`1<ProjectTargetElement> get_Targets();
    public ICollection`1<ProjectUsingTaskElement> get_UsingTasks();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroupsReversed();
    public ICollection`1<ProjectItemDefinitionGroupElement> get_ItemDefinitionGroupsReversed();
    public ICollection`1<ProjectImportGroupElement> get_ImportGroupsReversed();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroupsReversed();
    public string get_DirectoryPath();
    internal void set_DirectoryPath(string value);
    public string get_EscapedFullPath();
    public string get_FullPath();
    public void set_FullPath(string value);
    public Encoding get_Encoding();
    [DebuggerStepThroughAttribute]
public string get_DefaultTargets();
    [DebuggerStepThroughAttribute]
public void set_DefaultTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_InitialTargets();
    [DebuggerStepThroughAttribute]
public void set_InitialTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_Sdk();
    [DebuggerStepThroughAttribute]
public void set_Sdk(string value);
    [DebuggerStepThroughAttribute]
public string get_TreatAsLocalProperty();
    [DebuggerStepThroughAttribute]
public void set_TreatAsLocalProperty(string value);
    [DebuggerStepThroughAttribute]
public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public void set_ToolsVersion(string value);
    public string get_RawXml();
    public bool get_HasUnsavedChanges();
    public bool get_PreserveFormatting();
    public int get_Version();
    private void set_Version(int value);
    public DateTime get_TimeLastChanged();
    public DateTime get_LastWriteTimeWhenRead();
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ProjectFileLocation();
    public ElementLocation get_ToolsVersionLocation();
    public ElementLocation get_DefaultTargetsLocation();
    public ElementLocation get_InitialTargetsLocation();
    public ElementLocation get_SdkLocation();
    public ElementLocation get_TreatAsLocalPropertyLocation();
    [CompilerGeneratedAttribute]
internal bool get_IsExplicitlyLoaded();
    [CompilerGeneratedAttribute]
private void set_IsExplicitlyLoaded(bool value);
    [CompilerGeneratedAttribute]
internal ProjectRootElementCacheBase get_ProjectRootElementCache();
    internal bool get_IsMemberOfProjectCollection();
    [CompilerGeneratedAttribute]
internal bool get_ContainsTargetsWithReturnsAttribute();
    [CompilerGeneratedAttribute]
internal void set_ContainsTargetsWithReturnsAttribute(bool value);
    internal ProjectExtensionsElement get_ProjectExtensions();
    internal string get_LastDirtyReason();
    public static ProjectRootElement Create();
    public static ProjectRootElement Create(NewProjectFileOptions projectFileOptions);
    public static ProjectRootElement Create(ProjectCollection projectCollection);
    public static ProjectRootElement Create(ProjectCollection projectCollection, NewProjectFileOptions projectFileOptions);
    public static ProjectRootElement Create(string path);
    public static ProjectRootElement Create(string path, NewProjectFileOptions newProjectFileOptions);
    public static ProjectRootElement Create(string path, ProjectCollection projectCollection);
    public static ProjectRootElement Create(string path, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions);
    public static ProjectRootElement Create(XmlReader xmlReader);
    public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection projectCollection);
    public static ProjectRootElement Create(XmlReader xmlReader, ProjectCollection projectCollection, bool preserveFormatting);
    public static ProjectRootElement Open(string path);
    public static ProjectRootElement Open(string path, ProjectCollection projectCollection);
    public static ProjectRootElement Open(string path, ProjectCollection projectCollection, Nullable`1<bool> preserveFormatting);
    public static ProjectRootElement TryOpen(string path);
    public static ProjectRootElement TryOpen(string path, ProjectCollection projectCollection);
    public static ProjectRootElement TryOpen(string path, ProjectCollection projectCollection, Nullable`1<bool> preserveFormatting);
    public ProjectImportElement AddImport(string project);
    public ProjectImportGroupElement AddImportGroup();
    public ProjectItemElement AddItem(string itemType, string include);
    public ProjectItemElement AddItem(string itemType, string include, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ProjectItemGroupElement AddItemGroup();
    public ProjectItemDefinitionElement AddItemDefinition(string itemType);
    public ProjectItemDefinitionGroupElement AddItemDefinitionGroup();
    public ProjectPropertyGroupElement AddPropertyGroup();
    public ProjectPropertyElement AddProperty(string name, string value);
    public ProjectTargetElement AddTarget(string name);
    public ProjectUsingTaskElement AddUsingTask(string name, string assemblyFile, string assemblyName);
    public ProjectChooseElement CreateChooseElement();
    public ProjectImportElement CreateImportElement(string project);
    public ProjectItemElement CreateItemElement(string itemType);
    public ProjectItemElement CreateItemElement(string itemType, string include);
    public ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType);
    public ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement();
    public ProjectItemGroupElement CreateItemGroupElement();
    public ProjectImportGroupElement CreateImportGroupElement();
    public ProjectMetadataElement CreateMetadataElement(string name);
    public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue);
    public ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue, ElementLocation location);
    public ProjectOnErrorElement CreateOnErrorElement(string executeTargets);
    public ProjectOtherwiseElement CreateOtherwiseElement();
    public ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName);
    public ProjectExtensionsElement CreateProjectExtensionsElement();
    public ProjectPropertyGroupElement CreatePropertyGroupElement();
    public ProjectPropertyElement CreatePropertyElement(string name);
    public ProjectTargetElement CreateTargetElement(string name);
    public ProjectTaskElement CreateTaskElement(string name);
    public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName);
    public ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);
    public UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement();
    public ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType);
    public ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body);
    public ProjectWhenElement CreateWhenElement(string condition);
    public ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion);
    public void Save();
    public void Save(Encoding saveEncoding);
    public void Save(string path);
    public void Save(string path, Encoding encoding);
    public void Save(TextWriter writer);
    public ProjectRootElement DeepClone();
    public void Reload(bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    public void ReloadFrom(string path, bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    public void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    private void ReloadFrom(Func`2<bool, XmlDocumentWithLocation> documentProducer, bool throwIfUnsavedChanges, Nullable`1<bool> preserveFormatting);
    private static void ThrowIfDocumentHasParsingErrors(XmlDocumentWithLocation document);
    internal static ProjectRootElement Create(ProjectRootElementCacheBase projectRootElementCache);
    internal static ProjectRootElement Create(ProjectRootElementCacheBase projectRootElementCache, NewProjectFileOptions projectFileOptions);
    internal static ProjectRootElement Open(string path, ProjectRootElementCacheBase projectRootElementCache, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    internal static ProjectRootElement Open(XmlDocumentWithLocation document);
    internal static ProjectRootElement OpenProjectOrSolution(string fullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectRootElementCacheBase projectRootElementCache, bool isExplicitlyLoaded);
    internal ProjectMetadataElement CreateMetadataElement(XmlAttributeWithLocation attribute);
    internal XmlElementWithLocation CreateElement(string name, ElementLocation location);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal sealed virtual void MarkDirty(string reason, string param);
    internal void MarkProjectDirty(Project project);
    internal void MarkAsExplicitlyLoaded();
    internal List`1<ProjectImportElement> GetImplicitImportNodes(ProjectRootElement currentProjectOrImport);
    [IteratorStateMachineAttribute("Microsoft.Build.Construction.ProjectRootElement/<ParseSdks>d__217")]
private static IEnumerable`1<SdkReference> ParseSdks(string sdks, IElementLocation sdkLocation);
    internal static bool IsEmptyXmlFile(string path);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private static ProjectRootElement OpenLoader(string path, ProjectRootElementCacheBase projectRootElementCache);
    private static ProjectRootElement OpenLoaderPreserveFormatting(string path, ProjectRootElementCacheBase projectRootElementCache);
    private static ProjectRootElement OpenLoader(string path, ProjectRootElementCacheBase projectRootElementCache, bool preserveFormatting);
    private static ProjectRootElement CreateProjectFromPath(string projectFile, ProjectRootElementCacheBase projectRootElementCache, bool preserveFormatting);
    private XmlDocumentWithLocation LoadDocument(string fullPath, bool preserveFormatting, bool loadAsReadOnly);
    private static XmlDocumentWithLocation LoadDocument(XmlReader reader, bool preserveFormatting);
    private void IncrementVersion();
    private void ThrowIfUnsavedChanges(bool throwIfUnsavedChanges);
}
public class Microsoft.Build.Construction.ProjectSdkElement : ProjectElementContainer {
    public string Name { get; public set; }
    public string Version { get; public set; }
    public string MinimumVersion { get; public set; }
    internal ProjectSdkElement(ProjectElementContainerLink link);
    internal ProjectSdkElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectSdkElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public string get_Name();
    public void set_Name(string value);
    public string get_Version();
    public void set_Version(string value);
    public string get_MinimumVersion();
    public void set_MinimumVersion(string value);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    internal static ProjectSdkElement CreateDisconnected(string sdkName, string sdkVersion, ProjectRootElement containingProject);
}
[DebuggerDisplayAttribute("#Strings={Count} #Documents={_documents.Count}")]
internal class Microsoft.Build.Construction.ProjectStringCache : object {
    private static int InitialSize;
    private RetrievableEntryHashSet`1<StringCacheEntry> _strings;
    private Dictionary`2<XmlDocument, HashSet`1<StringCacheEntry>> _documents;
    private object _locker;
    internal int Count { get; }
    internal int DocumentCount { get; }
    internal int get_Count();
    internal int get_DocumentCount();
    public string Add(string key, XmlDocument document);
    public string Get(string key);
    public void Clear(XmlDocument document);
    [ConditionalAttribute("NEVER")]
private void VerifyState();
    private void OnStrongCacheEntryRemoved(object sender, ProjectRootElement projectRootElement);
}
[DebuggerDisplayAttribute("Name={Name} #Children={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectTargetElement : ProjectElementContainer {
    private string _name;
    [CompilerGeneratedAttribute]
private ProjectTargetInstance <TargetInstance>k__BackingField;
    internal ProjectTargetElementLink TargetLink { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    public ICollection`1<ProjectTaskElement> Tasks { get; }
    public ICollection`1<ProjectOnErrorElement> OnErrors { get; }
    public string Name { get; public set; }
    public string Inputs { get; public set; }
    public string Outputs { get; public set; }
    public string KeepDuplicateOutputs { get; public set; }
    public string DependsOnTargets { get; public set; }
    public string BeforeTargets { get; public set; }
    public string AfterTargets { get; public set; }
    public string Returns { get; public set; }
    public ElementLocation NameLocation { get; }
    public ElementLocation InputsLocation { get; }
    public ElementLocation OutputsLocation { get; }
    public ElementLocation KeepDuplicateOutputsLocation { get; }
    public ElementLocation DependsOnTargetsLocation { get; }
    public ElementLocation BeforeTargetsLocation { get; }
    public ElementLocation ReturnsLocation { get; }
    public ElementLocation AfterTargetsLocation { get; }
    internal ProjectTargetInstance TargetInstance { get; internal set; }
    internal ProjectTargetElement(ProjectTargetElementLink link);
    internal ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectTargetElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    internal ProjectTargetElementLink get_TargetLink();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    public ICollection`1<ProjectTaskElement> get_Tasks();
    public ICollection`1<ProjectOnErrorElement> get_OnErrors();
    [DebuggerStepThroughAttribute]
public string get_Name();
    public void set_Name(string value);
    [DebuggerStepThroughAttribute]
public string get_Inputs();
    public void set_Inputs(string value);
    [DebuggerStepThroughAttribute]
public string get_Outputs();
    public void set_Outputs(string value);
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicateOutputs();
    public void set_KeepDuplicateOutputs(string value);
    [DebuggerStepThroughAttribute]
public string get_DependsOnTargets();
    public void set_DependsOnTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_BeforeTargets();
    public void set_BeforeTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_AfterTargets();
    public void set_AfterTargets(string value);
    [DebuggerStepThroughAttribute]
public string get_Returns();
    public void set_Returns(string value);
    public ElementLocation get_NameLocation();
    public ElementLocation get_InputsLocation();
    public ElementLocation get_OutputsLocation();
    public ElementLocation get_KeepDuplicateOutputsLocation();
    public ElementLocation get_DependsOnTargetsLocation();
    public ElementLocation get_BeforeTargetsLocation();
    public ElementLocation get_ReturnsLocation();
    public ElementLocation get_AfterTargetsLocation();
    [CompilerGeneratedAttribute]
internal ProjectTargetInstance get_TargetInstance();
    [CompilerGeneratedAttribute]
internal void set_TargetInstance(ProjectTargetInstance value);
    public ProjectItemGroupElement AddItemGroup();
    public ProjectPropertyGroupElement AddPropertyGroup();
    public ProjectTaskElement AddTask(string taskName);
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectTargetElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    internal virtual void MarkDirty(string reason, string param);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("{Name} Condition={Condition} ContinueOnError={ContinueOnError} MSBuildRuntime={MSBuildRuntime} MSBuildArchitecture={MSBuildArchitecture} #Outputs={Count}")]
public class Microsoft.Build.Construction.ProjectTaskElement : ProjectElementContainer {
    private CopyOnWriteDictionary`1<ValueTuple`2<string, ElementLocation>> _parameters;
    private object _locker;
    internal ProjectTaskElementLink TaskLink { get; }
    public string ContinueOnError { get; public set; }
    public string MSBuildRuntime { get; public set; }
    public string MSBuildArchitecture { get; public set; }
    public string Name { get; }
    public ICollection`1<ProjectOutputElement> Outputs { get; }
    public IDictionary`2<string, string> Parameters { get; }
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> ParameterLocations { get; }
    public ElementLocation ContinueOnErrorLocation { get; }
    public ElementLocation MSBuildRuntimeLocation { get; }
    public ElementLocation MSBuildArchitectureLocation { get; }
    internal CopyOnWriteDictionary`1<ValueTuple`2<string, ElementLocation>> ParametersForEvaluation { get; }
    internal ProjectTaskElement(ProjectTaskElementLink link);
    internal ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectTargetElement parent, ProjectRootElement containingProject);
    private ProjectTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    internal ProjectTaskElementLink get_TaskLink();
    [DebuggerStepThroughAttribute]
public string get_ContinueOnError();
    [DebuggerStepThroughAttribute]
public void set_ContinueOnError(string value);
    [DebuggerStepThroughAttribute]
public string get_MSBuildRuntime();
    [DebuggerStepThroughAttribute]
public void set_MSBuildRuntime(string value);
    [DebuggerStepThroughAttribute]
public string get_MSBuildArchitecture();
    [DebuggerStepThroughAttribute]
public void set_MSBuildArchitecture(string value);
    public string get_Name();
    public ICollection`1<ProjectOutputElement> get_Outputs();
    public IDictionary`2<string, string> get_Parameters();
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> get_ParameterLocations();
    public ElementLocation get_ContinueOnErrorLocation();
    public ElementLocation get_MSBuildRuntimeLocation();
    public ElementLocation get_MSBuildArchitectureLocation();
    internal CopyOnWriteDictionary`1<ValueTuple`2<string, ElementLocation>> get_ParametersForEvaluation();
    public ProjectOutputElement AddOutputItem(string taskParameter, string itemType);
    public ProjectOutputElement AddOutputItem(string taskParameter, string itemType, string condition);
    public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName);
    public ProjectOutputElement AddOutputProperty(string taskParameter, string propertyName, string condition);
    public string GetParameter(string name);
    public void SetParameter(string name, string unevaluatedValue);
    public void RemoveParameter(string name);
    public void RemoveAllParameters();
    public virtual void CopyFrom(ProjectElement element);
    internal static ProjectTaskElement CreateDisconnected(string name, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private void EnsureParametersInitialized();
}
[DebuggerDisplayAttribute("Evaluate={Evaluate} TaskBody={TaskBody}")]
public class Microsoft.Build.Construction.ProjectUsingTaskBodyElement : ProjectElement {
    internal ProjectUsingTaskBodyElementLink UsingTaskBodyLink { get; }
    public string Condition { get; public set; }
    public string TaskBody { get; public set; }
    public string Evaluate { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation EvaluateLocation { get; }
    internal ProjectUsingTaskBodyElement(ProjectUsingTaskBodyElementLink link);
    internal ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectUsingTaskElement parent, ProjectRootElement containingProject);
    private ProjectUsingTaskBodyElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    internal ProjectUsingTaskBodyElementLink get_UsingTaskBodyLink();
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public string get_TaskBody();
    public void set_TaskBody(string value);
    public string get_Evaluate();
    public void set_Evaluate(string value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_EvaluateLocation();
    internal static ProjectUsingTaskBodyElement CreateDisconnected(string evaluate, string body, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private static void VerifyCorrectParent(ProjectElementContainer parent);
}
[DebuggerDisplayAttribute("TaskName={TaskName} AssemblyName={AssemblyName} AssemblyFile={AssemblyFile} Condition={Condition} Runtime={Runtime} Architecture={Architecture}")]
public class Microsoft.Build.Construction.ProjectUsingTaskElement : ProjectElementContainer {
    public string AssemblyFile { get; public set; }
    public string AssemblyName { get; public set; }
    public string TaskName { get; public set; }
    public string TaskFactory { get; public set; }
    public string Runtime { get; public set; }
    public string Architecture { get; public set; }
    public string Override { get; public set; }
    public ProjectUsingTaskBodyElement TaskBody { get; }
    public UsingTaskParameterGroupElement ParameterGroup { get; }
    public ElementLocation TaskNameLocation { get; }
    public ElementLocation AssemblyFileLocation { get; }
    public ElementLocation AssemblyNameLocation { get; }
    public ElementLocation RuntimeLocation { get; }
    public ElementLocation ArchitectureLocation { get; }
    public ElementLocation TaskFactoryLocation { get; }
    public ElementLocation OverrideLocation { get; }
    internal ProjectUsingTaskElement(ProjectUsingTaskElementLink link);
    internal ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement parent, ProjectRootElement containingProject);
    private ProjectUsingTaskElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public string get_AssemblyFile();
    public void set_AssemblyFile(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_TaskName();
    public void set_TaskName(string value);
    public string get_TaskFactory();
    public void set_TaskFactory(string value);
    public string get_Runtime();
    public void set_Runtime(string value);
    public string get_Architecture();
    public void set_Architecture(string value);
    public string get_Override();
    public void set_Override(string value);
    public ProjectUsingTaskBodyElement get_TaskBody();
    public UsingTaskParameterGroupElement get_ParameterGroup();
    public ElementLocation get_TaskNameLocation();
    public ElementLocation get_AssemblyFileLocation();
    public ElementLocation get_AssemblyNameLocation();
    public ElementLocation get_RuntimeLocation();
    public ElementLocation get_ArchitectureLocation();
    public ElementLocation get_TaskFactoryLocation();
    public ElementLocation get_OverrideLocation();
    public UsingTaskParameterGroupElement AddParameterGroup();
    public ProjectUsingTaskBodyElement AddUsingTaskBody(string evaluate, string taskBody);
    internal static ProjectUsingTaskElement CreateDisconnected(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("Name={Name} ParameterType={ParameterType} Output={Output} Required={Required}")]
public class Microsoft.Build.Construction.ProjectUsingTaskParameterElement : ProjectElement {
    private ProjectUsingTaskParameterElementLink TaskParameterLink { get; }
    public string Condition { get; public set; }
    public string Name { get; public set; }
    public string ParameterType { get; public set; }
    public string Output { get; public set; }
    public string Required { get; public set; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ParameterTypeLocation { get; }
    public ElementLocation OutputLocation { get; }
    public ElementLocation RequiredLocation { get; }
    internal ProjectUsingTaskParameterElement(ProjectUsingTaskParameterElementLink link);
    internal ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, UsingTaskParameterGroupElement parent, ProjectRootElement containingProject);
    private ProjectUsingTaskParameterElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    private ProjectUsingTaskParameterElementLink get_TaskParameterLink();
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_ParameterType();
    public void set_ParameterType(string value);
    public string get_Output();
    public void set_Output(string value);
    public string get_Required();
    public void set_Required(string value);
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ParameterTypeLocation();
    public ElementLocation get_OutputLocation();
    public ElementLocation get_RequiredLocation();
    internal static ProjectUsingTaskParameterElement CreateDisconnected(string parameterName, string output, string required, string parameterType, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
[DebuggerDisplayAttribute("#Children={Count} Condition={Condition}")]
public class Microsoft.Build.Construction.ProjectWhenElement : ProjectElementContainer {
    public ICollection`1<ProjectChooseElement> ChooseElements { get; }
    public ICollection`1<ProjectItemGroupElement> ItemGroups { get; }
    public ICollection`1<ProjectPropertyGroupElement> PropertyGroups { get; }
    internal ProjectWhenElement(ProjectWhenElementLink link);
    internal ProjectWhenElement(XmlElement xmlElement, ProjectChooseElement parent, ProjectRootElement containingProject);
    private ProjectWhenElement(XmlElement xmlElement, ProjectRootElement containingProject);
    public ICollection`1<ProjectChooseElement> get_ChooseElements();
    public ICollection`1<ProjectItemGroupElement> get_ItemGroups();
    public ICollection`1<ProjectPropertyGroupElement> get_PropertyGroups();
    internal static ProjectWhenElement CreateDisconnected(string condition, ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
}
internal class Microsoft.Build.Construction.RegistryLocation : object {
    private string registryPath;
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public string LocationString { get; }
    internal RegistryLocation(string registryPath);
    private RegistryLocation(ITranslator translator);
    public sealed virtual string get_File();
    public sealed virtual int get_Line();
    public sealed virtual int get_Column();
    public sealed virtual string get_LocationString();
    public sealed virtual void Translate(ITranslator translator);
    internal static RegistryLocation FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.Construction.RenameHandlerDelegate : MulticastDelegate {
    public RenameHandlerDelegate(object object, IntPtr method);
    public virtual void Invoke(string oldFullPath);
    public virtual IAsyncResult BeginInvoke(string oldFullPath, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Construction.SolutionConfigurationInSolution : object {
    internal static char ConfigurationPlatformSeparator;
    internal static Char[] ConfigurationPlatformSeparatorArray;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    public string ConfigurationName { get; }
    public string PlatformName { get; }
    public string FullName { get; }
    internal SolutionConfigurationInSolution(string configurationName, string platformName);
    private static SolutionConfigurationInSolution();
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public string get_PlatformName();
    [CompilerGeneratedAttribute]
public string get_FullName();
    internal static string ComputeFullName(string configurationName, string platformName);
}
public class Microsoft.Build.Construction.SolutionFile : object {
    private static Lazy`1<Regex> s_crackProjectLine;
    private static Lazy`1<Regex> s_crackPropertyLine;
    internal static int slnFileMinUpgradableVersion;
    internal static int slnFileMinVersion;
    internal static int slnFileMaxVersion;
    private static string vbProjectGuid;
    private static string csProjectGuid;
    private static string cpsProjectGuid;
    private static string cpsCsProjectGuid;
    private static string cpsVbProjectGuid;
    private static string cpsFsProjectGuid;
    private static string vjProjectGuid;
    private static string vcProjectGuid;
    private static string fsProjectGuid;
    private static string dbProjectGuid;
    private static string wdProjectGuid;
    private static string synProjectGuid;
    private static string webProjectGuid;
    private static string solutionFolderGuid;
    private static string sharedProjectGuid;
    private static char CommentStartChar;
    private string _solutionFile;
    private string _solutionFilterFile;
    private HashSet`1<string> _solutionFilter;
    private bool _parsingForConversionOnly;
    private Dictionary`2<string, ProjectInSolution> _projects;
    private List`1<ProjectInSolution> _projectsInOrder;
    private List`1<SolutionConfigurationInSolution> _solutionConfigurations;
    private string _defaultConfigurationName;
    private string _defaultPlatformName;
    private Version _currentVisualStudioVersion;
    private int _currentLineNumber;
    private static StringComparer _pathComparer;
    [CompilerGeneratedAttribute]
private List`1<string> <SolutionParserWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SolutionParserComments>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <SolutionParserErrorCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsWebProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsWebDeploymentProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionFileDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamReader <SolutionReader>k__BackingField;
    internal List`1<string> SolutionParserWarnings { get; }
    internal List`1<string> SolutionParserComments { get; }
    internal List`1<string> SolutionParserErrorCodes { get; }
    internal int Version { get; private set; }
    internal int VisualStudioVersion { get; }
    internal bool ContainsWebProjects { get; private set; }
    internal bool ContainsWebDeploymentProjects { get; private set; }
    public IReadOnlyList`1<ProjectInSolution> ProjectsInOrder { get; }
    public IReadOnlyDictionary`2<string, ProjectInSolution> ProjectsByGuid { get; }
    internal string FullPath { get; internal set; }
    internal string SolutionFileDirectory { get; internal set; }
    internal StreamReader SolutionReader { get; internal set; }
    public IReadOnlyList`1<SolutionConfigurationInSolution> SolutionConfigurations { get; }
    private static SolutionFile();
    [CompilerGeneratedAttribute]
internal List`1<string> get_SolutionParserWarnings();
    [CompilerGeneratedAttribute]
internal List`1<string> get_SolutionParserComments();
    [CompilerGeneratedAttribute]
internal List`1<string> get_SolutionParserErrorCodes();
    [CompilerGeneratedAttribute]
internal int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    internal int get_VisualStudioVersion();
    [CompilerGeneratedAttribute]
internal bool get_ContainsWebProjects();
    [CompilerGeneratedAttribute]
private void set_ContainsWebProjects(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ContainsWebDeploymentProjects();
    [CompilerGeneratedAttribute]
private void set_ContainsWebDeploymentProjects(bool value);
    public IReadOnlyList`1<ProjectInSolution> get_ProjectsInOrder();
    public IReadOnlyDictionary`2<string, ProjectInSolution> get_ProjectsByGuid();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    [CompilerGeneratedAttribute]
internal string get_SolutionFileDirectory();
    [CompilerGeneratedAttribute]
internal void set_SolutionFileDirectory(string value);
    [CompilerGeneratedAttribute]
internal StreamReader get_SolutionReader();
    [CompilerGeneratedAttribute]
internal void set_SolutionReader(StreamReader value);
    public IReadOnlyList`1<SolutionConfigurationInSolution> get_SolutionConfigurations();
    internal bool ProjectShouldBuild(string projectFile);
    public static SolutionFile Parse(string solutionFile);
    internal static bool IsBuildableProject(ProjectInSolution project);
    internal static void GetSolutionFileAndVisualStudioMajorVersions(string solutionFile, Int32& solutionVersion, Int32& visualStudioMajorVersion);
    private void ParseSolutionFilter(string solutionFilterFile);
    internal static string ParseSolutionFromSolutionFilter(string solutionFilterFile, JsonElement& solution);
    internal void AddSolutionConfiguration(string configurationName, string platformName);
    private string ReadLine();
    internal void ParseSolutionFileForConversion();
    internal void ParseSolutionFile();
    internal void ParseSolution();
    private void ParseFileHeader();
    private static Version ParseVisualStudioVersion(string str);
    private void ValidateSolutionFileVersion(string versionString);
    private void ParseProject(string firstLine);
    internal void ParseEtpProject(ProjectInSolution etpProj);
    private void AddProjectToSolution(ProjectInSolution proj);
    private static bool IsEtpProjectFile(string projectFile);
    private void ValidateProjectRelativePath(ProjectInSolution proj);
    private static void ParseAspNetCompilerProperty(ProjectInSolution proj, string propertyName, string propertyValue);
    private static string TrimQuotes(string property);
    internal void ParseFirstProjectLine(string firstLine, ProjectInSolution proj);
    internal void ParseNestedProjects();
    internal void ParseSolutionConfigurations();
    internal static ValueTuple`2<string, string> ParseConfigurationName(string fullConfigurationName, string projectPath, int lineNumber, string containingString);
    internal Dictionary`2<string, string> ParseProjectConfigurations();
    internal void ProcessProjectConfigurationSection(Dictionary`2<string, string> rawProjectConfigurationsEntries);
    public string GetDefaultConfigurationName();
    public string GetDefaultPlatformName();
    internal string GetProjectUniqueNameByGuid(string projectGuid);
    internal string GetProjectRelativePathByGuid(string projectGuid);
}
internal class Microsoft.Build.Construction.SolutionProjectGenerator : object {
    internal static string SolutionPathPropertyName;
    private static string WebProjectOverrideFolder;
    internal static string CurrentSolutionConfigurationContents;
    private static string SolutionProperties;
    private static string SolutionConfigurationAndPlatformProperties;
    internal static string SolutionProjectReferenceAllTargets;
    internal static ImmutableHashSet`1<string> _defaultTargetNames;
    private Version _version20;
    private Version _version40;
    private Tuple`2[] _metaprojectGlobalProperties;
    private SolutionFile _solutionFile;
    private IDictionary`2<string, string> _globalProperties;
    private string _toolsVersionOverride;
    private BuildEventContext _projectBuildEventContext;
    private ILoggingService _loggingService;
    private IReadOnlyCollection`1<string> _targetNames;
    private string _selectedSolutionConfiguration;
    private ISdkResolverService _sdkResolverService;
    private int _submissionId;
    private bool _batchProjectTargets;
    private SolutionProjectGenerator(SolutionFile solution, IDictionary`2<string, string> globalProperties, string toolsVersionOverride, BuildEventContext projectBuildEventContext, ILoggingService loggingService, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    private static SolutionProjectGenerator();
    internal static ProjectInstance[] Generate(SolutionFile solution, IDictionary`2<string, string> globalProperties, string toolsVersionOverride, BuildEventContext projectBuildEventContext, ILoggingService loggingService, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    internal static void AddPropertyGroupForSolutionConfiguration(ProjectRootElement msbuildProject, SolutionFile solutionFile, SolutionConfigurationInSolution solutionConfiguration);
    internal static string GetSolutionConfiguration(SolutionFile solutionFile, SolutionConfigurationInSolution solutionConfiguration);
    internal static ProjectTaskElement AddErrorWarningMessageElement(ProjectTargetElement target, string elementType, bool treatAsLiteral, string textResourceName, Object[] args);
    internal static string PredictActiveSolutionConfigurationName(SolutionFile solutionFile, IDictionary`2<string, string> globalProperties);
    private static string GetMetaprojectName(string fullPathToProject);
    private static string DetermineWrapperProjectToolsVersion(string toolsVersionOverride, Boolean& explicitToolsVersionSpecified);
    private static void AddTasksToCopyAllDependenciesIntoBinDir(ProjectTargetInstance target, ProjectInSolution project, string referenceItemName, string conditionDescribingValidConfigurations);
    private static void AddTasksToResolveAutoRefreshFileReferences(ProjectTargetInstance target, ProjectInSolution project, string referenceItemName);
    private static ProjectTaskInstance AddMSBuildTaskInstance(ProjectTargetInstance target, string projectPath, string msbuildTargetName, string configurationName, string platformName, bool specifyProjectToolsVersion);
    private static string GenerateSafePropertyName(ProjectInSolution proj, string propertyName);
    private static string MakeIntoSafeItemName(string name);
    private static ProjectTaskInstance AddErrorWarningMessageInstance(ProjectTargetInstance target, string condition, string elementType, bool treatAsLiteral, string textResourceName, Object[] args);
    private static string GetConditionStringForConfiguration(SolutionConfigurationInSolution configuration);
    private static string DetermineLikelyActiveSolutionConfiguration(SolutionFile solutionFile, IDictionary`2<string, string> globalProperties);
    private static bool WouldProjectBuild(SolutionFile solutionFile, string selectedSolutionConfiguration, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration);
    private ProjectInstance[] Generate();
    private ProjectInstance[] CreateSolutionProject(string wrapperProjectToolsVersion, bool explicitToolsVersionSpecified);
    private void EvaluateAndAddProjects(List`1<ProjectInSolution> projectsInOrder, List`1<ProjectInstance> projectInstances, ProjectInstance traversalInstance, string selectedSolutionConfiguration);
    private void AddStandardTraversalTargets(ProjectInstance traversalInstance, List`1<ProjectInSolution> projectsInOrder);
    private ProjectInstance CreateTraversalInstance(string wrapperProjectToolsVersion, bool explicitToolsVersionSpecified, List`1<ProjectInSolution> projectsInOrder);
    private void EmitMetaproject(ProjectRootElement metaproject, string path);
    private void AddProjectReference(ProjectInstance traversalProject, ProjectInstance projectInstance, ProjectInSolution projectToAdd, ProjectConfigurationInSolution projectConfiguration, bool direct);
    private static string GetToolsVersionMetadataForDirectMSBuildTask(ProjectInstance traversalProject);
    private static string GetToolsVersionAttributeForDirectMSBuildTask();
    private static string GetPropertiesMetadataForProjectReference(ProjectInstance traversalProject, string configurationAndPlatformProperties);
    private static string GetConfigurationAndPlatformPropertiesString(ProjectConfigurationInSolution projectConfiguration);
    private static string GetPropertiesAttributeForDirectMSBuildTask(ProjectConfigurationInSolution projectConfiguration);
    private bool CanBuildDirectly(ProjectInstance traversalProject, ProjectInSolution projectToAdd, ProjectConfigurationInSolution projectConfiguration);
    private ProjectInstance CreateMetaproject(ProjectInstance traversalProject, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration);
    private string GetMetaprojectName(ProjectInSolution project);
    private void AddMetaprojectReferenceItems(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project);
    private static void AddMetaprojectTargetForManagedProject(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, string targetName, string outputItem);
    private static void AddProjectBuildTask(ProjectInstance traversalProject, ProjectConfigurationInSolution projectConfiguration, ProjectTargetInstance target, string targetToBuild, string sourceItems, string condition, string outputItem);
    private void AddMetaprojectBuildTask(ProjectInSolution project, ProjectTargetInstance target, string targetToBuild, string outputItem);
    private void AddMetaprojectTargetForWebProject(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, string targetName);
    private void AddTaskForAspNetCompiler(ProjectTargetInstance target, ProjectInSolution project, string conditionDescribingValidConfigurations);
    private void ValidateTargetFrameworkForWebProject(ProjectInSolution project);
    private void SetToolPathForAspNetCompilerTask(ProjectInSolution project, ProjectTaskInstance task);
    private void AddResolveProjectReferenceTasks(ProjectInstance traversalProject, ProjectTargetInstance target, ProjectInSolution project, SolutionConfigurationInSolution solutionConfiguration, string outputReferenceItemName, String& addedReferenceGuids);
    private static void AddPropertyGroupForAspNetConfiguration(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, string configurationName, AspNetCompilerParameters aspNetCompilerParameters, string solutionFile);
    private string ComputeTargetConditionForWebProject(ProjectInSolution project);
    private static void AddTargetForGetFrameworkPathAndRedistList(ProjectInstance metaprojectInstance);
    private void AddMetaprojectTargetForUnknownProjectType(ProjectInstance traversalProject, ProjectInstance metaprojectInstance, ProjectInSolution project, string targetName, string unknownProjectTypeErrorMessage);
    private void AddValidateProjectsTarget(ProjectInstance traversalProject, List`1<ProjectInSolution> projects);
    private static void AddTraversalReferencesTarget(ProjectInstance traversalProject, string targetName, string outputItem, bool batchBuildTargets);
    private static void AddReferencesBuildTask(ProjectTargetInstance target, string targetToBuild, string outputItem);
    private void AddTraversalTargetForProject(ProjectInstance traversalProject, ProjectInSolution project, ProjectConfigurationInSolution projectConfiguration, string targetToBuild, string outputItem, bool canBuildDirectly);
    private IDictionary`2<string, string> GetMetaprojectGlobalProperties(ProjectInstance traversalProject);
    private string DetermineChildProjectToolsVersion(string wrapperProjectToolsVersion);
    private string PredictActiveSolutionConfigurationName();
    private void ScanProjectDependencies(string childProjectToolsVersion, string fullSolutionConfigurationName);
    private void AddDependencyByGuid(ProjectInSolution project, string dependencyGuid);
    private void AddConfigurationPlatformDefaults(ProjectRootElement traversalProject);
    private void AddPropertyGroupForSolutionConfiguration(ProjectRootElement traversalProject, SolutionConfigurationInSolution solutionConfiguration);
    private static void AddVenusConfigurationDefaults(ProjectRootElement traversalProject);
    private void AddGlobalProperties(ProjectRootElement traversalProject);
    private void AddFakeReleaseSolutionConfigurationIfNecessary();
    private void AddInitialTargets(ProjectInstance traversalProject, List`1<ProjectInSolution> projects);
    private void AddValidateSolutionConfigurationTarget(ProjectInstance traversalProject);
    private static void AddValidateToolsVersionsTarget(ProjectInstance traversalProject);
    private static void AddGetSolutionConfigurationContentsTarget(ProjectInstance traversalProject);
}
public enum Microsoft.Build.Construction.SolutionProjectType : Enum {
    public int value__;
    public static SolutionProjectType Unknown;
    public static SolutionProjectType KnownToBeMSBuildFormat;
    public static SolutionProjectType SolutionFolder;
    public static SolutionProjectType WebProject;
    public static SolutionProjectType WebDeploymentProject;
    public static SolutionProjectType EtpSubProject;
    public static SolutionProjectType SharedProject;
}
[DebuggerDisplayAttribute("#Parameters={Count}")]
public class Microsoft.Build.Construction.UsingTaskParameterGroupElement : ProjectElementContainer {
    public string Condition { get; public set; }
    public ICollection`1<ProjectUsingTaskParameterElement> Parameters { get; }
    public ElementLocation ConditionLocation { get; }
    internal UsingTaskParameterGroupElement(UsingTaskParameterGroupElementLink link);
    internal UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, ProjectElementContainer parent, ProjectRootElement containingProject);
    private UsingTaskParameterGroupElement(XmlElementWithLocation xmlElement, ProjectRootElement containingProject);
    public virtual string get_Condition();
    public virtual void set_Condition(string value);
    public ICollection`1<ProjectUsingTaskParameterElement> get_Parameters();
    public virtual ElementLocation get_ConditionLocation();
    public ProjectUsingTaskParameterElement AddParameter(string name, string output, string required, string parameterType);
    public ProjectUsingTaskParameterElement AddParameter(string name);
    internal static UsingTaskParameterGroupElement CreateDisconnected(ProjectRootElement containingProject);
    internal virtual void VerifyThrowInvalidOperationAcceptableLocation(ProjectElementContainer parent, ProjectElement previousSibling, ProjectElement nextSibling);
    protected virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    private static void VerifyCorrectParent(ProjectElementContainer parent);
}
internal class Microsoft.Build.Construction.XmlAttributeWithLocation : XmlAttribute {
    private ElementLocation _elementLocation;
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal ElementLocation Location { get; }
    public XmlAttributeWithLocation(string prefix, string localName, string namespaceURI, XmlDocument document);
    public XmlAttributeWithLocation(string prefix, string localName, string namespaceURI, XmlDocument document, int lineNumber, int columnNumber);
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LineNumber();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LinePosition();
    internal ElementLocation get_Location();
    public sealed virtual bool HasLineInfo();
}
internal class Microsoft.Build.Construction.XmlDocumentWithLocation : XmlDocument {
    private static ProjectStringCache s_globalStringCache;
    private static NameTable s_nameTable;
    private static ReadOnlyLoadFlags s_readOnlyFlags;
    private IXmlLineInfo _reader;
    private string _fullPath;
    private ProjectStringCache _stringCache;
    private Nullable`1<bool> _loadAsReadOnly;
    private AsyncLocal`1<ElementLocation> _elementLocation;
    internal string FullPath { get; internal set; }
    internal ProjectStringCache StringCache { get; internal set; }
    public bool IsReadOnly { get; }
    internal XmlDocumentWithLocation(Nullable`1<bool> loadAsReadOnly);
    private static XmlDocumentWithLocation();
    internal string get_FullPath();
    internal void set_FullPath(string value);
    internal ProjectStringCache get_StringCache();
    internal void set_StringCache(ProjectStringCache value);
    public virtual void Load(XmlReader reader);
    public virtual void Load(string fullPath);
    internal XmlElement CreateElement(string localName, string namespaceURI, ElementLocation location);
    public virtual XmlElement CreateElement(string prefix, string localName, string namespaceURI);
    public virtual XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI);
    public virtual XmlWhitespace CreateWhitespace(string text);
    public virtual XmlSignificantWhitespace CreateSignificantWhitespace(string text);
    public virtual XmlText CreateTextNode(string text);
    public virtual XmlComment CreateComment(string data);
    public virtual void Save(Stream outStream);
    public virtual void Save(string filename);
    public virtual void Save(TextWriter writer);
    public virtual void Save(XmlWriter writer);
    public virtual bool get_IsReadOnly();
    internal static void ClearReadOnlyFlags_UnitTestsOnly();
    internal void ClearAnyCachedStrings();
    private void DetermineWhetherToLoadReadOnly(string fullPath);
    private void DetermineWhetherToLoadReadOnlyIfPossible();
    private void VerifyThrowNotReadOnly();
}
internal class Microsoft.Build.Construction.XmlElementWithLocation : XmlElement {
    private ElementLocation _elementLocation;
    private ProjectElementLink Microsoft.Build.ObjectModelRemoting.ILinkedXml.Link { get; }
    private XmlElementWithLocation Microsoft.Build.ObjectModelRemoting.ILinkedXml.Xml { get; }
    public int LineNumber { get; }
    public int LinePosition { get; }
    internal ElementLocation Location { get; }
    public XmlElementWithLocation(string prefix, string localName, string namespaceURI, XmlDocumentWithLocation document);
    public XmlElementWithLocation(string prefix, string localName, string namespaceURI, XmlDocumentWithLocation document, int lineNumber, int columnNumber);
    private sealed virtual override ProjectElementLink Microsoft.Build.ObjectModelRemoting.ILinkedXml.get_Link();
    private sealed virtual override XmlElementWithLocation Microsoft.Build.ObjectModelRemoting.ILinkedXml.get_Xml();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LineNumber();
    [DebuggerStepThroughAttribute]
public sealed virtual int get_LinePosition();
    internal ElementLocation get_Location();
    public sealed virtual bool HasLineInfo();
    public XmlAttributeWithLocation GetAttributeWithLocation(string name);
    public virtual XmlNode RemoveChild(XmlNode oldChild);
    internal ElementLocation GetAttributeLocation(string name);
}
internal class Microsoft.Build.Construction.XmlNameTableThreadSafe : NameTable {
    private object _locker;
    public virtual string Add(string key);
    public virtual string Add(Char[] key, int start, int len);
    public virtual string Get(string value);
    public virtual string Get(Char[] key, int start, int len);
}
public class Microsoft.Build.Definition.ProjectOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <GlobalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubToolsetVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCollection <ProjectCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectLoadSettings <LoadSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationContext <EvaluationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectoryCacheFactory <DirectoryCacheFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Interactive>k__BackingField;
    public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public string ToolsVersion { get; public set; }
    public string SubToolsetVersion { get; public set; }
    public ProjectCollection ProjectCollection { get; public set; }
    public ProjectLoadSettings LoadSettings { get; public set; }
    public EvaluationContext EvaluationContext { get; public set; }
    public IDirectoryCacheFactory DirectoryCacheFactory { get; public set; }
    public bool Interactive { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public void set_GlobalProperties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ToolsVersion();
    [CompilerGeneratedAttribute]
public void set_ToolsVersion(string value);
    [CompilerGeneratedAttribute]
public string get_SubToolsetVersion();
    [CompilerGeneratedAttribute]
public void set_SubToolsetVersion(string value);
    [CompilerGeneratedAttribute]
public ProjectCollection get_ProjectCollection();
    [CompilerGeneratedAttribute]
public void set_ProjectCollection(ProjectCollection value);
    [CompilerGeneratedAttribute]
public ProjectLoadSettings get_LoadSettings();
    [CompilerGeneratedAttribute]
public void set_LoadSettings(ProjectLoadSettings value);
    [CompilerGeneratedAttribute]
public EvaluationContext get_EvaluationContext();
    [CompilerGeneratedAttribute]
public void set_EvaluationContext(EvaluationContext value);
    [CompilerGeneratedAttribute]
public IDirectoryCacheFactory get_DirectoryCacheFactory();
    [CompilerGeneratedAttribute]
public void set_DirectoryCacheFactory(IDirectoryCacheFactory value);
    [CompilerGeneratedAttribute]
public bool get_Interactive();
    [CompilerGeneratedAttribute]
public void set_Interactive(bool value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.AndExpressionNode : OperatorExpressionNode {
    private bool _possibleAndCollision;
    internal string DebuggerDisplay { get; }
    internal bool PossibleAndCollision { get; internal set; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string get_DebuggerDisplay();
    internal virtual void set_PossibleAndCollision(bool value);
    internal virtual bool get_PossibleAndCollision();
}
internal static class Microsoft.Build.Evaluation.BuiltInMetadata : object {
    internal static int MetadataCount { get; }
    internal static ICollection`1<string> MetadataNames { get; }
    [DebuggerStepThroughAttribute]
internal static int get_MetadataCount();
    [DebuggerStepThroughAttribute]
internal static ICollection`1<string> get_MetadataNames();
    internal static string GetMetadataValue(string currentDirectory, string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped, string definingProjectEscaped, string name, String& fullPath);
    internal static string GetMetadataValueEscaped(string currentDirectory, string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped, string definingProjectEscaped, string name, String& fullPath);
    private static string GetRecursiveDirValue(string evaluatedIncludeBeforeWildcardExpansionEscaped, string evaluatedIncludeEscaped);
}
internal static class Microsoft.Build.Evaluation.CharacterUtilities : object {
    internal static bool IsNumberStart(char candidate);
    internal static bool IsSimpleStringStart(char candidate);
    internal static bool IsSimpleStringChar(char candidate);
    internal static bool IsHexAlphabetic(char candidate);
    internal static bool IsHexDigit(char candidate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Evaluation.ConditionEvaluator : object {
    private static ConcurrentDictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedExpressionTrees;
    private static bool s_disableExpressionCaching;
    private static ConditionEvaluator();
    internal static void UpdateConditionedPropertiesTable(Dictionary`2<string, List`1<string>> conditionedPropertiesTable, string leftValue, string rightValueExpanded);
    [NullableContextAttribute("0")]
internal static bool TryGetSingleProperty(ReadOnlySpan`1<char> input, int beginning, int length, ReadOnlySpan`1& propertyName);
    internal static bool EvaluateCondition(string condition, ParserOptions options, Expander`2<P, I> expander, ExpanderOptions expanderOptions, string evaluationDirectory, ElementLocation elementLocation, ILoggingService loggingServices, BuildEventContext buildEventContext, IFileSystem fileSystem, ProjectRootElementCacheBase projectRootElementCache, LoggingContext loggingContext);
    internal static bool EvaluateConditionCollectingConditionedProperties(string condition, ParserOptions options, Expander`2<P, I> expander, ExpanderOptions expanderOptions, Dictionary`2<string, List`1<string>> conditionedPropertiesTable, string evaluationDirectory, ElementLocation elementLocation, ILoggingService loggingServices, BuildEventContext buildEventContext, IFileSystem fileSystem, ProjectRootElementCacheBase projectRootElementCache, LoggingContext loggingContext);
    private static ExpressionTreeForCurrentOptionsWithSize FlushCacheIfLargerThanThreshold(ParserOptions options, ExpressionTreeForCurrentOptionsWithSize cachedExpressionTreesForCurrentOptions);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <TryGetSingleProperty>g__ContainsInvalidCharacter|1_0(ReadOnlySpan`1<char> span);
}
public class Microsoft.Build.Evaluation.Context.EvaluationContext : object {
    [CompilerGeneratedAttribute]
private static Action`1<EvaluationContext> <TestOnlyHookOnCreate>k__BackingField;
    private int _used;
    [CompilerGeneratedAttribute]
private SharingPolicy <Policy>k__BackingField;
    [CompilerGeneratedAttribute]
private ISdkResolverService <SdkResolverService>k__BackingField;
    [CompilerGeneratedAttribute]
private IFileSystem <FileSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private FileMatcher <FileMatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, IReadOnlyList`1<string>> <FileEntryExpansionCache>k__BackingField;
    internal static Action`1<EvaluationContext> TestOnlyHookOnCreate { get; internal set; }
    internal SharingPolicy Policy { get; }
    internal ISdkResolverService SdkResolverService { get; }
    internal IFileSystem FileSystem { get; }
    internal FileMatcher FileMatcher { get; }
    private ConcurrentDictionary`2<string, IReadOnlyList`1<string>> FileEntryExpansionCache { get; }
    private EvaluationContext(SharingPolicy policy, IFileSystem fileSystem, ISdkResolverService sdkResolverService, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> fileEntryExpansionCache);
    [CompilerGeneratedAttribute]
internal static Action`1<EvaluationContext> get_TestOnlyHookOnCreate();
    [CompilerGeneratedAttribute]
internal static void set_TestOnlyHookOnCreate(Action`1<EvaluationContext> value);
    [CompilerGeneratedAttribute]
internal SharingPolicy get_Policy();
    [CompilerGeneratedAttribute]
internal ISdkResolverService get_SdkResolverService();
    [CompilerGeneratedAttribute]
internal IFileSystem get_FileSystem();
    [CompilerGeneratedAttribute]
internal FileMatcher get_FileMatcher();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, IReadOnlyList`1<string>> get_FileEntryExpansionCache();
    public static EvaluationContext Create(SharingPolicy policy);
    public static EvaluationContext Create(SharingPolicy policy, MSBuildFileSystemBase fileSystem);
    private EvaluationContext CreateUsedIsolatedContext();
    internal EvaluationContext ContextForNewProject();
    internal EvaluationContext ContextWithFileSystem(IFileSystem fileSystem);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.EqualExpressionNode : MultipleComparisonNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(bool left, bool right);
    protected virtual bool Compare(string left, string right);
    internal virtual string get_DebuggerDisplay();
}
internal class Microsoft.Build.Evaluation.EvaluationLocationMarkdownPrettyPrinter : EvaluationLocationPrettyPrinterBase {
    private static string Separator;
    internal virtual void AppendHeader(StringBuilder stringBuilder);
    internal virtual void AppendLocation(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation);
    protected virtual string NormalizeExpression(string description, EvaluationLocationKind kind);
}
internal abstract class Microsoft.Build.Evaluation.EvaluationLocationPrettyPrinterBase : object {
    internal abstract virtual void AppendHeader(StringBuilder stringBuilder);
    internal abstract virtual void AppendLocation(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation);
    protected abstract virtual string NormalizeExpression(string description, EvaluationLocationKind kind);
    protected static double GetMilliseconds(TimeSpan timeSpan);
    protected static double GetPercentage(TimeSpan total, TimeSpan time);
    protected static string GetElementOrConditionText(string description, EvaluationLocationKind kind);
    protected void AppendDefaultHeaderWithSeparator(StringBuilder stringBuilder, string separator);
    protected void AppendDefaultLocationWithSeparator(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation, string separator);
}
internal class Microsoft.Build.Evaluation.EvaluationLocationTabSeparatedPrettyPrinter : EvaluationLocationPrettyPrinterBase {
    private static string Separator;
    internal virtual void AppendHeader(StringBuilder stringBuilder);
    internal virtual void AppendLocation(StringBuilder stringBuilder, TimeSpan totalTime, EvaluationLocation evaluationLocation, ProfiledLocation profiledLocation);
    protected virtual string NormalizeExpression(string description, EvaluationLocationKind kind);
}
internal class Microsoft.Build.Evaluation.EvaluationProfiler : object {
    private bool _shouldTrackElements;
    private Stack`1<EvaluationFrame> _evaluationStack;
    private Dictionary`2<EvaluationLocation, ProfiledLocation> _timeSpent;
    private EvaluationLocation CurrentLocation { get; }
    public Nullable`1<ProfilerResult> ProfiledResult { get; }
    internal EvaluationProfiler(bool shouldTrackElements);
    private EvaluationLocation get_CurrentLocation();
    public Nullable`1<ProfilerResult> get_ProfiledResult();
    public IDisposable TrackPass(EvaluationPass evaluationPass, string passDescription);
    public IDisposable TrackFile(string file);
    public IDisposable TrackGlob(string rootDirectory, string glob, ISet`1<string> excludePatterns);
    public IDisposable TrackElement(ProjectElement element);
    public IDisposable TrackCondition(IElementLocation location, string condition);
    internal bool IsEmpty();
}
internal class Microsoft.Build.Evaluation.Evaluator`4 : object {
    private static Char[] s_splitter;
    private Expander`2<P, I> _expander;
    private IEvaluatorData`4<P, I, M, D> _data;
    private List`1<ProjectItemGroupElement> _itemGroupElements;
    private List`1<ProjectItemDefinitionGroupElement> _itemDefinitionGroupElements;
    private List`1<Pair`2<string, ProjectUsingTaskElement>> _usingTaskElements;
    private List`1<ProjectTargetElement> _targetElements;
    private Dictionary`2<string, ProjectImportElement> _importsSeen;
    private List`1<string> _initialTargetsList;
    private Dictionary`2<ProjectRootElement, NGen`1<bool>> _projectSupportsReturnsAttribute;
    private ProjectRootElement _projectRootElement;
    private IItemFactory`2<I, I> _itemFactory;
    private ProjectLoadSettings _loadSettings;
    private int _maxNodeCount;
    private ISdkResolverService _sdkResolverService;
    private int _submissionId;
    private EvaluationContext _evaluationContext;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private ProjectRootElementCacheBase _projectRootElementCache;
    private EvaluationLoggingContext _evaluationLoggingContext;
    private bool _logProjectImportedEvents;
    private static IOCache _fallbackSearchPathsCache;
    private EvaluationProfiler _evaluationProfiler;
    private ProjectRootElement _lastModifiedProject;
    private List`1<string> _streamImports;
    private bool _interactive;
    private bool _isRunningInVisualStudio;
    private static string CachedFileVersion;
    private static string CouldNotResolveSdk;
    private static string ProjectImported;
    private static string ProjectImportSkippedEmptyFile;
    private static string ProjectImportSkippedExpressionEvaluatedToEmpty;
    private static string ProjectImportSkippedFalseCondition;
    private static string ProjectImportSkippedInvalidFile;
    private static string ProjectImportSkippedMissingFile;
    private static string ProjectImportSkippedNoMatches;
    private Evaluator`4(IEvaluatorData`4<P, I, M, D> data, Project project, ProjectRootElement projectRootElement, ProjectLoadSettings loadSettings, int maxNodeCount, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, IItemFactory`2<I, I> itemFactory, IToolsetProvider toolsetProvider, IDirectoryCacheFactory directoryCacheFactory, ProjectRootElementCacheBase projectRootElementCache, ISdkResolverService sdkResolverService, int submissionId, EvaluationContext evaluationContext, bool profileEvaluation, bool interactive, ILoggingService loggingService, BuildEventContext buildEventContext);
    private static Evaluator`4();
    internal static void Evaluate(IEvaluatorData`4<P, I, M, D> data, Project project, ProjectRootElement root, ProjectLoadSettings loadSettings, int maxNodeCount, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, ILoggingService loggingService, IItemFactory`2<I, I> itemFactory, IToolsetProvider toolsetProvider, IDirectoryCacheFactory directoryCacheFactory, ProjectRootElementCacheBase projectRootElementCache, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, EvaluationContext evaluationContext, bool interactive);
    internal static List`1<I> CreateItemsFromInclude(string rootDirectory, ProjectItemElement itemElement, IItemFactory`2<I, I> itemFactory, string unevaluatedIncludeEscaped, Expander`2<P, I> expander, ILoggingService loggingService, string buildEventFileInfoFullPath, BuildEventContext buildEventContext);
    private static ProjectTaskInstance ReadTaskElement(ProjectTaskElement taskElement);
    private static ProjectPropertyGroupTaskInstance ReadPropertyGroupUnderTargetElement(ProjectPropertyGroupElement propertyGroupElement);
    private static ProjectOnErrorInstance ReadOnErrorElement(ProjectOnErrorElement projectOnErrorElement);
    private static ProjectItemGroupTaskInstance ReadItemGroupUnderTargetElement(ProjectItemGroupElement itemGroupElement);
    private static ProjectTargetInstance ReadNewTargetElement(ProjectTargetElement targetElement, bool parentProjectSupportsReturnsAttribute, EvaluationProfiler evaluationProfiler);
    private void Evaluate();
    private IEnumerable FilterOutEnvironmentDerivedProperties(PropertyDictionary`1<P> dictionary);
    private void CollectProjectCachePlugins();
    private void PerformDepthFirstPass(ProjectRootElement currentProjectOrImport);
    private void UpdateDefaultTargets(ProjectRootElement currentProjectOrImport);
    private void EvaluatePropertyGroupElement(ProjectPropertyGroupElement propertyGroupElement);
    private void EvaluateItemDefinitionGroupElement(ProjectItemDefinitionGroupElement itemDefinitionGroupElement);
    private void EvaluateItemGroupElement(ProjectItemGroupElement itemGroupElement, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private void ReadTargetElement(ProjectTargetElement targetElement, LinkedList`1<ProjectTargetElement> activeTargetsByEvaluationOrder, Dictionary`2<string, LinkedListNode`1<ProjectTargetElement>> activeTargets);
    private void AddBeforeAndAfterTargetMappings(ProjectTargetElement targetElement, Dictionary`2<string, LinkedListNode`1<ProjectTargetElement>> activeTargets, Dictionary`2<string, List`1<TargetSpecification>> targetsWhichRunBeforeByTarget, Dictionary`2<string, List`1<TargetSpecification>> targetsWhichRunAfterByTarget);
    private void ValidateChangeWaveState();
    private void AddBuiltInProperties();
    private void AddEnvironmentProperties();
    private void AddToolsetProperties();
    private int AddGlobalProperties();
    private P SetBuiltInProperty(string name, string evaluatedValueEscaped);
    private void EvaluatePropertyElement(ProjectPropertyElement propertyElement);
    private void LogPropertyReassignment(P predecessor, P property, string location);
    private void EvaluateItemElement(bool itemGroupConditionResult, ProjectItemElement itemElement, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private void EvaluateItemDefinitionElement(ProjectItemDefinitionElement itemDefinitionElement);
    private void EvaluateImportElement(string directoryOfImportingFile, ProjectImportElement importElement);
    private void EvaluateImportGroupElement(string directoryOfImportingFile, ProjectImportGroupElement importGroupElement);
    private void EvaluateChooseElement(ProjectChooseElement chooseElement);
    private bool EvaluateWhenOrOtherwiseChildren(ProjectElementSiblingEnumerable children);
    private List`1<ProjectRootElement> ExpandAndLoadImports(string directoryOfImportingFile, ProjectImportElement importElement, SdkResult& sdkResult);
    private void ExpandAndLoadImportsFromUnescapedImportExpressionConditioned(string directoryOfImportingFile, ProjectImportElement importElement, List`1& projects, SdkResult& sdkResult);
    private ProjectRootElement CreateProjectForSdkResult(SdkResult sdkResult);
    private LoadImportsResult ExpandAndLoadImportsFromUnescapedImportExpression(string directoryOfImportingFile, ProjectImportElement importElement, string unescapedExpression, bool throwOnFileNotExistsError, List`1& imports);
    private bool IntroducesCircularity(string importFileUnescaped, ProjectImportElement importElement);
    private bool EvaluateCondition(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions);
    private bool EvaluateCondition(ProjectElement element, string condition, ExpanderOptions expanderOptions, ParserOptions parserOptions);
    private bool EvaluateConditionCollectingConditionedProperties(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions, ProjectRootElementCacheBase projectRootElementCache);
    private bool EvaluateConditionCollectingConditionedProperties(ProjectElement element, string condition, ExpanderOptions expanderOptions, ParserOptions parserOptions, ProjectRootElementCacheBase projectRootElementCache);
    private string GetCurrentDirectoryForConditionEvaluation(ProjectElement element);
    private void RecordEvaluatedItemElement(ProjectItemElement itemElement);
    private void ThrowForImportedProjectWithSearchPathsNotFound(ProjectImportPathMatch searchPathMatch, ProjectImportElement importElement);
    private static string StringifyList(IList`1<string> strings);
    private void SetAllProjectsProperty();
    [CompilerGeneratedAttribute]
internal static bool <ExpandAndLoadImportsFromUnescapedImportExpressionConditioned>g__HasProperty|71_0(string value, CompareInfo compareInfo);
    [CompilerGeneratedAttribute]
internal static string <ExpandAndLoadImportsFromUnescapedImportExpressionConditioned>g__EvaluateProperty|71_1(string value, IElementLocation location, Expander`2<P, I> expander, SdkReferencePropertyExpansionMode mode);
    [CompilerGeneratedAttribute]
private string <ThrowForImportedProjectWithSearchPathsNotFound>b__81_0(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Evaluation.EvaluatorMetadataTable : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, EvaluatorMetadata> _metadata;
    private string _implicitItemType;
    private int _capacity;
    internal IEnumerable`1<EvaluatorMetadata> Entries { get; }
    public EvaluatorMetadataTable(string implicitItemType, int capacity);
    internal IEnumerable`1<EvaluatorMetadata> get_Entries();
    public sealed virtual string GetEscapedValue(string name);
    public sealed virtual string GetEscapedValue(string itemType, string name);
    [NullableContextAttribute("2")]
public sealed virtual string GetEscapedValueIfPresent(string itemType, string name);
    internal void SetValue(ProjectMetadataElement xml, string evaluatedValueEscaped);
}
internal class Microsoft.Build.Evaluation.Expander`2 : object {
    private static int CharacterLimitPerExpansion;
    private static int ItemLimitPerExpansion;
    private static Char[] s_singleQuoteChar;
    private static Char[] s_backtickChar;
    private static Char[] s_doubleQuoteChar;
    private static Char[] s_expandableChars;
    private static CompareInfo s_invariantCompareInfo;
    private IPropertyProvider`1<P> _properties;
    private IItemProvider`1<I> _items;
    private IMetadataTable _metadata;
    private UsedUninitializedProperties _usedUninitializedProperties;
    private IFileSystem _fileSystem;
    [CompilerGeneratedAttribute]
private EvaluationContext <EvaluationContext>k__BackingField;
    internal EvaluationContext EvaluationContext { get; }
    internal bool WarnForUninitializedProperties { get; internal set; }
    internal IMetadataTable Metadata { get; internal set; }
    internal UsedUninitializedProperties UsedUninitializedProperties { get; internal set; }
    internal Expander`2(IPropertyProvider`1<P> properties, IFileSystem fileSystem);
    internal Expander`2(IPropertyProvider`1<P> properties, EvaluationContext evaluationContext);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items, IFileSystem fileSystem);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items, EvaluationContext evaluationContext);
    internal Expander`2(IPropertyProvider`1<P> properties, IItemProvider`1<I> items, IMetadataTable metadata, IFileSystem fileSystem);
    private static Expander`2();
    [CompilerGeneratedAttribute]
internal EvaluationContext get_EvaluationContext();
    internal bool get_WarnForUninitializedProperties();
    internal void set_WarnForUninitializedProperties(bool value);
    internal IMetadataTable get_Metadata();
    internal void set_Metadata(IMetadataTable value);
    internal UsedUninitializedProperties get_UsedUninitializedProperties();
    internal void set_UsedUninitializedProperties(UsedUninitializedProperties value);
    internal static bool ExpressionMayContainExpandableExpressions(string expression);
    internal static bool ExpressionContainsItemVector(string expression);
    internal string ExpandIntoStringAndUnescape(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext);
    internal string ExpandIntoStringLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext);
    internal object ExpandPropertiesLeaveTypedAndEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal SemiColonTokenizer ExpandIntoStringListLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation, LoggingContext loggingContext);
    internal IList`1<TaskItem> ExpandIntoTaskItemsLeaveEscaped(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandIntoItemsLeaveEscaped(string expression, IItemFactory`2<I, T> itemFactory, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandSingleItemVectorExpressionIntoItems(string expression, IItemFactory`2<I, T> itemFactory, ExpanderOptions options, bool includeNullItems, Boolean& isTransformExpression, IElementLocation elementLocation);
    internal static ItemExpressionCapture ExpandSingleItemVectorExpressionIntoExpressionCapture(string expression, ExpanderOptions options, IElementLocation elementLocation);
    internal IList`1<T> ExpandExpressionCaptureIntoItems(ItemExpressionCapture expressionCapture, IItemProvider`1<S> items, IItemFactory`2<S, T> itemFactory, ExpanderOptions options, bool includeNullEntries, Boolean& isTransformExpression, IElementLocation elementLocation);
    internal bool ExpandExpressionCapture(ItemExpressionCapture expressionCapture, IElementLocation elementLocation, ExpanderOptions options, bool includeNullEntries, Boolean& isTransformExpression, List`1& itemsFromCapture);
    private static bool IsValidPropertyName(string propertyName);
    private static bool IsTruncationEnabled(ExpanderOptions options);
    private static int ScanForClosingParenthesis(string expression, int index, Boolean& potentialPropertyFunction, Boolean& potentialRegistryFunction);
    private static int ScanForClosingQuote(char quoteChar, string expression, int index);
    private static void AddArgument(List`1<string> arguments, SpanBasedStringBuilder argumentBuilder);
    private static String[] ExtractFunctionArguments(IElementLocation elementLocation, string expressionFunction, string argumentsString);
    [CompilerGeneratedAttribute]
internal static void <ExtractFunctionArguments>g__FlushCurrentArgumentToArgumentBuilder|47_0(int argumentEndIndex, <>c__DisplayClass47_0& );
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ExpanderOptions : Enum {
    public int value__;
    public static ExpanderOptions Invalid;
    public static ExpanderOptions ExpandCustomMetadata;
    public static ExpanderOptions ExpandBuiltInMetadata;
    public static ExpanderOptions ExpandMetadata;
    public static ExpanderOptions ExpandProperties;
    public static ExpanderOptions ExpandItems;
    public static ExpanderOptions BreakOnNotEmpty;
    public static ExpanderOptions LeavePropertiesUnexpandedOnError;
    public static ExpanderOptions Truncate;
    public static ExpanderOptions LogOnItemMetadataSelfReference;
    public static ExpanderOptions ExpandPropertiesAndItems;
    public static ExpanderOptions ExpandPropertiesAndMetadata;
    public static ExpanderOptions ExpandPropertiesAndCustomMetadata;
    public static ExpanderOptions ExpandAll;
}
internal static class Microsoft.Build.Evaluation.ExpressionShredder : object {
    internal static SemiColonTokenizer SplitSemiColonSeparatedList(string expression);
    internal static ItemsAndMetadataPair GetReferencedItemNamesAndMetadata(IEnumerable`1<string> expressions);
    internal static bool ContainsMetadataExpressionOutsideTransform(string expression);
    internal static List`1<ItemExpressionCapture> GetReferencedItemExpressions(string expression);
    internal static List`1<ItemExpressionCapture> GetReferencedItemExpressions(string expression, int start, int end);
    private static void GetReferencedItemNamesAndMetadata(string expression, int start, int end, ItemsAndMetadataPair& pair, ShredderOptions whatToShredFor);
    private static bool SinkSingleQuotedExpression(string expression, Int32& i, int end);
    private static bool SinkArgumentsInParentheses(string expression, Int32& i, int end);
    private static bool SinkUntilClosingQuote(char quoteChar, string expression, Int32& i, int end);
    private static ItemExpressionCapture SinkItemFunctionExpression(string expression, int startTransform, Int32& i, int end);
    private static bool SinkValidName(string expression, Int32& i, int end);
    private static bool Sink(string expression, Int32& i, char c);
    private static bool Sink(string expression, Int32& i, int end, char c1, char c2);
    private static void SinkWhitespace(string expression, Int32& i);
}
internal class Microsoft.Build.Evaluation.FunctionCallExpressionNode : OperatorExpressionNode {
    private List`1<GenericExpressionNode> _arguments;
    private string _functionName;
    internal FunctionCallExpressionNode(string functionName, List`1<GenericExpressionNode> arguments);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    private static string ExpandArgumentForScalarParameter(string function, GenericExpressionNode argumentNode, IConditionEvaluationState state, bool isFilePath);
    private List`1<string> ExpandArgumentAsFileList(GenericExpressionNode argumentNode, IConditionEvaluationState state, bool isFilePath);
    private void VerifyArgumentCount(int expected, IConditionEvaluationState state);
}
internal abstract class Microsoft.Build.Evaluation.GenericExpressionNode : object {
    [CompilerGeneratedAttribute]
private string <DebuggerDisplay>k__BackingField;
    internal string DebuggerDisplay { get; }
    internal bool PossibleAndCollision { get; internal set; }
    internal bool PossibleOrCollision { get; internal set; }
    internal abstract virtual bool TryBoolEvaluate(IConditionEvaluationState state, Boolean& result, LoggingContext loggingContext);
    internal abstract virtual bool TryNumericEvaluate(IConditionEvaluationState state, Double& result, LoggingContext loggingContext);
    internal abstract virtual bool TryVersionEvaluate(IConditionEvaluationState state, Version& result, LoggingContext loggingContext);
    internal virtual bool EvaluatesToEmpty(IConditionEvaluationState state, LoggingContext loggingContext);
    internal abstract virtual string GetExpandedValue(IConditionEvaluationState state, LoggingContext loggingContext);
    internal abstract virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal abstract virtual void ResetState();
    internal bool Evaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    [CompilerGeneratedAttribute]
internal virtual string get_DebuggerDisplay();
    internal virtual void set_PossibleAndCollision(bool value);
    internal virtual bool get_PossibleAndCollision();
    internal virtual void set_PossibleOrCollision(bool value);
    internal virtual bool get_PossibleOrCollision();
    internal bool PotentialAndOrConflict();
    internal abstract virtual bool DetectOr();
    internal abstract virtual bool DetectAnd();
}
internal class Microsoft.Build.Evaluation.GlobFragment : ItemSpecFragment {
    public bool IsFullFileSystemScan { get; }
    public GlobFragment(string textFragment, string projectDirectory);
    public virtual IEnumerable`1<string> GetReferencedItems();
    public bool get_IsFullFileSystemScan();
}
public class Microsoft.Build.Evaluation.GlobResult : object {
    [CompilerGeneratedAttribute]
private ProjectItemElement <ItemElement>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <IncludeGlobs>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildGlob <MsBuildGlob>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Excludes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Removes>k__BackingField;
    public ProjectItemElement ItemElement { get; }
    public IEnumerable`1<string> IncludeGlobs { get; }
    public IMSBuildGlob MsBuildGlob { get; public set; }
    public IEnumerable`1<string> Excludes { get; }
    public IEnumerable`1<string> Removes { get; public set; }
    public GlobResult(ProjectItemElement itemElement, IEnumerable`1<string> includeGlobStrings, IMSBuildGlob globWithGaps, IEnumerable`1<string> excludeFragmentStrings, IEnumerable`1<string> removeFragmentStrings);
    [CompilerGeneratedAttribute]
public ProjectItemElement get_ItemElement();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_IncludeGlobs();
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_MsBuildGlob();
    [CompilerGeneratedAttribute]
public void set_MsBuildGlob(IMSBuildGlob value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Excludes();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Removes();
    [CompilerGeneratedAttribute]
public void set_Removes(IEnumerable`1<string> value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.GreaterThanExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.GreaterThanOrEqualExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
internal interface Microsoft.Build.Evaluation.IEvaluatorData`4 {
    public int EvaluationId { get; public set; }
    public string Directory { get; }
    public TaskRegistry TaskRegistry { get; public set; }
    public Toolset Toolset { get; }
    public string SubToolsetVersion { get; }
    public string ExplicitToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    public ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    public List`1<string> InitialTargets { get; public set; }
    public List`1<string> DefaultTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> BeforeTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> AfterTargets { get; public set; }
    public Dictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public bool ShouldEvaluateForDesignTime { get; }
    public bool CanEvaluateElementsWithFalseConditions { get; }
    public PropertyDictionary`1<P> Properties { get; }
    public IEnumerable`1<D> ItemDefinitionsEnumerable { get; }
    public ItemDictionary`1<I> Items { get; }
    public List`1<ProjectItemElement> EvaluatedItemElements { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary { get; }
    public abstract virtual int get_EvaluationId();
    public abstract virtual void set_EvaluationId(int value);
    public abstract virtual string get_Directory();
    public abstract virtual TaskRegistry get_TaskRegistry();
    public abstract virtual void set_TaskRegistry(TaskRegistry value);
    public abstract virtual Toolset get_Toolset();
    public abstract virtual string get_SubToolsetVersion();
    public abstract virtual string get_ExplicitToolsVersion();
    public abstract virtual PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    public abstract virtual ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    public abstract virtual List`1<string> get_InitialTargets();
    public abstract virtual void set_InitialTargets(List`1<string> value);
    public abstract virtual List`1<string> get_DefaultTargets();
    public abstract virtual void set_DefaultTargets(List`1<string> value);
    public abstract virtual IDictionary`2<string, List`1<TargetSpecification>> get_BeforeTargets();
    public abstract virtual void set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public abstract virtual IDictionary`2<string, List`1<TargetSpecification>> get_AfterTargets();
    public abstract virtual void set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public abstract virtual Dictionary`2<string, List`1<string>> get_ConditionedProperties();
    public abstract virtual bool get_ShouldEvaluateForDesignTime();
    public abstract virtual bool get_CanEvaluateElementsWithFalseConditions();
    public abstract virtual PropertyDictionary`1<P> get_Properties();
    public abstract virtual IEnumerable`1<D> get_ItemDefinitionsEnumerable();
    public abstract virtual ItemDictionary`1<I> get_Items();
    public abstract virtual List`1<ProjectItemElement> get_EvaluatedItemElements();
    public abstract virtual PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentVariablePropertiesDictionary();
    public abstract virtual void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
    public abstract virtual void FinishEvaluation();
    public abstract virtual void AddItem(I item);
    public abstract virtual void AddItemIgnoringCondition(I item);
    public abstract virtual IItemDefinition`1<M> AddItemDefinition(string itemType);
    public abstract virtual void AddToAllEvaluatedPropertiesList(P property);
    public abstract virtual void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum);
    public abstract virtual void AddToAllEvaluatedItemsList(I item);
    public abstract virtual IItemDefinition`1<M> GetItemDefinition(string itemType);
    public abstract virtual P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext);
    public abstract virtual P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped);
    public abstract virtual ProjectTargetInstance GetTarget(string targetName);
    public abstract virtual void AddTarget(ProjectTargetInstance target);
    public abstract virtual void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult);
    public abstract virtual void RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    public abstract virtual string ExpandString(string unexpandedValue);
    public abstract virtual bool EvaluateCondition(string condition);
}
internal interface Microsoft.Build.Evaluation.IItem {
    public string EvaluatedInclude { get; }
    public string EvaluatedIncludeEscaped { get; }
    public string ProjectDirectory { get; }
    public abstract virtual string get_EvaluatedInclude();
    public abstract virtual string get_EvaluatedIncludeEscaped();
    public abstract virtual string get_ProjectDirectory();
    public abstract virtual string GetMetadataValue(string name);
    public abstract virtual string GetMetadataValueEscaped(string name);
}
internal interface Microsoft.Build.Evaluation.IItem`1 {
    public IEnumerable`1<M> Metadata { get; }
    public abstract virtual M GetMetadata(string name);
    public abstract virtual M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue);
    public abstract virtual IEnumerable`1<M> get_Metadata();
}
internal interface Microsoft.Build.Evaluation.IItemDefinition`1 {
    public abstract virtual M GetMetadata(string name);
    public abstract virtual M SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, M predecessor);
}
internal interface Microsoft.Build.Evaluation.IItemFactory`2 {
    public string ItemType { get; public set; }
    unknown ProjectItemElement ItemElement {public set; }
    public abstract virtual string get_ItemType();
    public abstract virtual void set_ItemType(string value);
    public abstract virtual void set_ItemElement(ProjectItemElement value);
    public abstract virtual T CreateItem(string include, string definingProject);
    public abstract virtual T CreateItem(S source, string definingProject);
    public abstract virtual T CreateItem(string include, S baseItem, string definingProject);
    public abstract virtual T CreateItem(string include, string includeBeforeWildcardExpansion, string definingProject);
    public abstract virtual void SetMetadata(IEnumerable`1<Pair`2<ProjectMetadataElement, string>> metadata, IEnumerable`1<T> destinationItems);
}
internal interface Microsoft.Build.Evaluation.IItemProvider`1 {
    public abstract virtual ICollection`1<T> GetItems(string itemType);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.Evaluation.IItemTypeDefinition {
    public string ItemType { get; }
    public abstract virtual string get_ItemType();
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.Evaluation.IMetadataTable {
    public abstract virtual string GetEscapedValue(string name);
    public abstract virtual string GetEscapedValue(string itemType, string name);
    [NullableContextAttribute("2")]
public abstract virtual string GetEscapedValueIfPresent(string itemType, string name);
}
internal interface Microsoft.Build.Evaluation.IMetadatum {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Evaluation.IntrinsicFunctionOverload : object {
    private static String[] s_knownOverloadName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IComparer`1<MemberInfo> s_comparerLongBeforeDouble;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static IComparer`1<MemberInfo> s_comparerDoubleBeforeLong;
    internal static IComparer`1<MemberInfo> IntrinsicFunctionOverloadMethodComparer { get; }
    private static IComparer`1<MemberInfo> LongBeforeDoubleComparer { get; }
    private static IComparer`1<MemberInfo> DoubleBeforeLongComparer { get; }
    private static IntrinsicFunctionOverload();
    internal static IComparer`1<MemberInfo> get_IntrinsicFunctionOverloadMethodComparer();
    private static IComparer`1<MemberInfo> get_LongBeforeDoubleComparer();
    private static IComparer`1<MemberInfo> get_DoubleBeforeLongComparer();
    internal static bool IsIntrinsicFunctionOverloadsEnabled();
    internal static bool IsKnownOverloadMethodName(string methodName);
    private static TypeCode SelectTypeOfFirstParameter(MemberInfo member);
}
internal static class Microsoft.Build.Evaluation.IntrinsicFunctions : object {
    private static Object[] DefaultRegistryViews;
    private static Lazy`1<Regex> RegistrySdkRegex;
    private static Lazy`1<NuGetFrameworkWrapper> NuGetFramework;
    private static IntrinsicFunctions();
    internal static double Add(double a, double b);
    internal static long Add(long a, long b);
    internal static double Subtract(double a, double b);
    internal static long Subtract(long a, long b);
    internal static double Multiply(double a, double b);
    internal static long Multiply(long a, long b);
    internal static double Divide(double a, double b);
    internal static long Divide(long a, long b);
    internal static double Modulo(double a, double b);
    internal static long Modulo(long a, long b);
    internal static string Escape(string unescaped);
    internal static string Unescape(string escaped);
    internal static int BitwiseOr(int first, int second);
    internal static int BitwiseAnd(int first, int second);
    internal static int BitwiseXor(int first, int second);
    internal static int BitwiseNot(int first);
    internal static int LeftShift(int operand, int count);
    internal static int RightShift(int operand, int count);
    internal static int RightShiftUnsigned(int operand, int count);
    internal static object GetRegistryValue(string keyName, string valueName);
    internal static object GetRegistryValue(string keyName, string valueName, object defaultValue);
    internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, Object[] views);
    internal static object GetRegistryValueFromView(string keyName, string valueName, object defaultValue, ArraySegment`1<object> views);
    internal static string MakeRelative(string basePath, string path);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem);
    internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem);
    internal static string ValueOrDefault(string conditionValue, string defaultValue);
    internal static string ConvertToBase64(string toEncode);
    internal static string ConvertFromBase64(string toDecode);
    internal static int StableStringHash(string toHash);
    internal static bool DoesTaskHostExist(string runtime, string architecture);
    internal static string EnsureTrailingSlash(string path);
    internal static string NormalizeDirectory(String[] path);
    internal static string NormalizePath(String[] path);
    internal static bool IsOSPlatform(string platformString);
    internal static bool IsOsUnixLike();
    internal static bool IsOsBsdLike();
    internal static bool VersionEquals(string a, string b);
    internal static bool VersionNotEquals(string a, string b);
    internal static bool VersionGreaterThan(string a, string b);
    internal static bool VersionGreaterThanOrEquals(string a, string b);
    internal static bool VersionLessThan(string a, string b);
    internal static bool VersionLessThanOrEquals(string a, string b);
    internal static string GetTargetFrameworkIdentifier(string tfm);
    internal static string GetTargetFrameworkVersion(string tfm, int versionPartCount);
    internal static bool IsTargetFrameworkCompatible(string target, string candidate);
    internal static string GetTargetPlatformIdentifier(string tfm);
    internal static string GetTargetPlatformVersion(string tfm, int versionPartCount);
    internal static string FilterTargetFrameworks(string incoming, string filter);
    internal static bool AreFeaturesEnabled(Version wave);
    public static string GetCurrentToolsDirectory();
    public static string GetToolsDirectory32();
    public static string GetToolsDirectory64();
    public static string GetMSBuildSDKsPath();
    public static string GetVsInstallRoot();
    public static string GetProgramFiles32();
    public static string GetMSBuildExtensionsPath();
    public static bool IsRunningFromVisualStudio();
    internal static List`1<string> __GetListTest();
    [SupportedOSPlatform("windows")]
private static RegistryKey GetBaseKeyFromKeyName(string keyName, RegistryView view, String& subKeyName);
}
internal interface Microsoft.Build.Evaluation.IProjectMetadataParent {
    public Project Project { get; }
    public string ItemType { get; }
    public abstract virtual Project get_Project();
    public abstract virtual string get_ItemType();
}
internal interface Microsoft.Build.Evaluation.IProperty {
    public string Name { get; }
    public string EvaluatedValue { get; }
    public string EvaluatedValueEscaped { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_EvaluatedValue();
    public abstract virtual string get_EvaluatedValueEscaped();
}
internal interface Microsoft.Build.Evaluation.IPropertyProvider`1 {
    public abstract virtual T GetProperty(string name);
    public abstract virtual T GetProperty(string name, int startIndex, int endIndex);
}
internal class Microsoft.Build.Evaluation.ItemDataCollectionValue`1 : ValueType {
    private object _value;
    public bool IsEmpty { get; }
    public ItemDataCollectionValue`1(I item);
    public bool get_IsEmpty();
    public void Add(I item);
    public void Delete(I item);
    public void Replace(I oldItem, I newItem);
    public Enumerator<I> GetEnumerator();
}
internal class Microsoft.Build.Evaluation.ItemsAndMetadataPair : ValueType {
    private HashSet`1<string> _items;
    private Dictionary`2<string, MetadataReference> _metadata;
    internal HashSet`1<string> Items { get; internal set; }
    internal Dictionary`2<string, MetadataReference> Metadata { get; internal set; }
    internal ItemsAndMetadataPair(HashSet`1<string> items, Dictionary`2<string, MetadataReference> metadata);
    [IsReadOnlyAttribute]
internal HashSet`1<string> get_Items();
    internal void set_Items(HashSet`1<string> value);
    [IsReadOnlyAttribute]
internal Dictionary`2<string, MetadataReference> get_Metadata();
    internal void set_Metadata(Dictionary`2<string, MetadataReference> value);
}
internal class Microsoft.Build.Evaluation.ItemSpec`2 : object {
    [CompilerGeneratedAttribute]
private string <ItemSpecString>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ItemSpecFragment> <Fragments>k__BackingField;
    [CompilerGeneratedAttribute]
private Expander`2<P, I> <Expander>k__BackingField;
    [CompilerGeneratedAttribute]
private IElementLocation <ItemSpecLocation>k__BackingField;
    public string ItemSpecString { get; }
    public List`1<ItemSpecFragment> Fragments { get; }
    public Expander`2<P, I> Expander { get; public set; }
    public IElementLocation ItemSpecLocation { get; }
    public ItemSpec`2(string itemSpec, Expander`2<P, I> expander, IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext);
    [CompilerGeneratedAttribute]
public string get_ItemSpecString();
    [CompilerGeneratedAttribute]
public List`1<ItemSpecFragment> get_Fragments();
    [CompilerGeneratedAttribute]
public Expander`2<P, I> get_Expander();
    [CompilerGeneratedAttribute]
public void set_Expander(Expander`2<P, I> value);
    [CompilerGeneratedAttribute]
public IElementLocation get_ItemSpecLocation();
    private List`1<ItemSpecFragment> BuildItemFragments(IElementLocation itemSpecLocation, string projectDirectory, bool expandProperties, LoggingContext loggingContext);
    private ItemExpressionFragment<P, I> ProcessItemExpression(string expression, IElementLocation elementLocation, string projectDirectory, Boolean& isItemListExpression);
    public bool MatchesItem(I item);
    public IEnumerable`1<ItemSpecFragment> FragmentsMatchingItem(string itemToMatch, Int32& matches);
    public IList`1<string> IntersectsWith(IReadOnlyDictionary`2<string, ItemDataCollectionValue`1<I>> itemsByNormalizedValue);
    public IMSBuildGlob ToMSBuildGlob();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ItemSpec`2/<FlattenFragmentsAsStrings>d__22")]
public IEnumerable`1<string> FlattenFragmentsAsStrings();
    public virtual string ToString();
}
internal abstract class Microsoft.Build.Evaluation.ItemSpecFragment : object {
    private FileSpecMatcherTester _fileMatcher;
    private bool _fileMatcherInitialized;
    private IMSBuildGlob _msbuildGlob;
    [CompilerGeneratedAttribute]
private string <TextFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    public string TextFragment { get; }
    internal string ProjectDirectory { get; }
    private FileSpecMatcherTester& FileMatcher { get; }
    protected IMSBuildGlob MsBuildGlob { get; }
    protected ItemSpecFragment(string textFragment, string projectDirectory);
    [CompilerGeneratedAttribute]
public string get_TextFragment();
    [CompilerGeneratedAttribute]
internal string get_ProjectDirectory();
    private FileSpecMatcherTester& get_FileMatcher();
    protected virtual IMSBuildGlob get_MsBuildGlob();
    public virtual int MatchCount(string itemToMatch);
    public virtual bool IsMatch(string itemToMatch);
    public virtual bool IsMatchNormalized(string normalizedItemToMatch);
    public virtual IEnumerable`1<string> GetReferencedItems();
    public virtual IMSBuildGlob ToMSBuildGlob();
    protected virtual IMSBuildGlob CreateMsBuildGlob();
    private FileSpecMatcherTester CreateFileSpecMatcher();
}
internal interface Microsoft.Build.Evaluation.IToolsetProvider {
    public ICollection`1<Toolset> Toolsets { get; }
    public abstract virtual ICollection`1<Toolset> get_Toolsets();
    public abstract virtual Toolset GetToolset(string toolsVersion);
}
internal class Microsoft.Build.Evaluation.LazyItemEvaluator`4 : object {
    private IEvaluatorData`4<P, I, M, D> _outerEvaluatorData;
    private Expander`2<P, I> _outerExpander;
    private IEvaluatorData`4<P, I, M, D> _evaluatorData;
    private Expander`2<P, I> _expander;
    private IItemFactory`2<I, I> _itemFactory;
    private LoggingContext _loggingContext;
    private EvaluationProfiler _evaluationProfiler;
    private int _nextElementOrder;
    private Dictionary`2<string, LazyItemList<P, I, M, D>> _itemLists;
    [CompilerGeneratedAttribute]
private EvaluationContext <EvaluationContext>k__BackingField;
    protected EvaluationContext EvaluationContext { get; }
    protected IFileSystem FileSystem { get; }
    protected FileMatcher FileMatcher { get; }
    public LazyItemEvaluator`4(IEvaluatorData`4<P, I, M, D> data, IItemFactory`2<I, I> itemFactory, LoggingContext loggingContext, EvaluationProfiler evaluationProfiler, EvaluationContext evaluationContext);
    [CompilerGeneratedAttribute]
protected EvaluationContext get_EvaluationContext();
    protected IFileSystem get_FileSystem();
    protected FileMatcher get_FileMatcher();
    public bool EvaluateConditionWithCurrentState(ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions);
    private static bool EvaluateCondition(string condition, ProjectElement element, ExpanderOptions expanderOptions, ParserOptions parserOptions, Expander`2<P, I> expander, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private static string GetCurrentDirectoryForConditionEvaluation(ProjectElement element, LazyItemEvaluator`4<P, I, M, D> lazyEvaluator);
    private void AddReferencedItemList(string itemType, IDictionary`2<string, LazyItemList<P, I, M, D>> referencedItemLists);
    public IEnumerable`1<ItemData<P, I, M, D>> GetAllItemsDeferred();
    public void ProcessItemElement(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private UpdateOperation<P, I, M, D> BuildUpdateOperation(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private IncludeOperation<P, I, M, D> BuildIncludeOperation(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private RemoveOperation<P, I, M, D> BuildRemoveOperation(string rootDirectory, ProjectItemElement itemElement, bool conditionResult);
    private void ProcessItemSpec(string rootDirectory, string itemSpec, IElementLocation itemSpecLocation, OperationBuilder<P, I, M, D> builder);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.LazyItemEvaluator`4/<GetExpandedMetadataValuesAndConditions>d__32")]
private static IEnumerable`1<string> GetExpandedMetadataValuesAndConditions(ICollection`1<ProjectMetadataElement> metadata, Expander`2<P, I> expander, LoggingContext loggingContext);
    private void ProcessMetadataElements(ProjectItemElement itemElement, OperationBuilderWithMetadata<P, I, M, D> operationBuilder);
    private void AddItemReferences(string expression, OperationBuilder<P, I, M, D> operationBuilder, IElementLocation elementLocation);
    private void AddReferencedItemLists(OperationBuilder<P, I, M, D> operationBuilder, ItemExpressionCapture match);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.LessThanExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.LessThanOrEqualExpressionNode : NumericComparisonExpressionNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(Version left, Version right);
    protected virtual bool Compare(Version left, double right);
    protected virtual bool Compare(double left, Version right);
    internal virtual string get_DebuggerDisplay();
}
internal enum Microsoft.Build.Evaluation.LoadImportsResult : Enum {
    public int value__;
    public static LoadImportsResult ProjectsImported;
    public static LoadImportsResult FoundFilesToImportButIgnored;
    public static LoadImportsResult TriedToImportButFileNotFound;
    public static LoadImportsResult ImportExpressionResolvedToNothing;
    public static LoadImportsResult ConditionWasFalse;
}
internal class Microsoft.Build.Evaluation.LoadXmlFromPath : MulticastDelegate {
    public LoadXmlFromPath(object object, IntPtr method);
    public virtual XmlDocumentWithLocation Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual XmlDocumentWithLocation EndInvoke(IAsyncResult result);
}
public static class Microsoft.Build.Evaluation.MatchOnMetadataConstants : object {
    public static MatchOnMetadataOptions MatchOnMetadataOptionsDefaultValue;
}
public enum Microsoft.Build.Evaluation.MatchOnMetadataOptions : Enum {
    public int value__;
    public static MatchOnMetadataOptions CaseSensitive;
    public static MatchOnMetadataOptions CaseInsensitive;
    public static MatchOnMetadataOptions PathLike;
}
internal class Microsoft.Build.Evaluation.MetadataReference : ValueType {
    internal string ItemName;
    internal string MetadataName;
    internal MetadataReference(string itemName, string metadataName);
}
internal class Microsoft.Build.Evaluation.MetadataTrie`2 : object {
    private Dictionary`2<string, MetadataTrie`2<P, I>> _children;
    private Func`2<string, string> _normalize;
    internal MetadataTrie`2(MatchOnMetadataOptions options, IEnumerable`1<string> metadata, ItemSpec`2<P, I> itemSpec);
    private MetadataTrie`2(StringComparer comparer);
    private void Add(IEnumerable`1<string> metadata, StringComparer comparer);
    internal bool Contains(IEnumerable`1<string> metadata);
}
internal class Microsoft.Build.Evaluation.MSBuildExtensionsPathReferenceKind : ValueType {
    public static MSBuildExtensionsPathReferenceKind Default;
    public static MSBuildExtensionsPathReferenceKind Path32;
    public static MSBuildExtensionsPathReferenceKind Path64;
    public static MSBuildExtensionsPathReferenceKind None;
    [CompilerGeneratedAttribute]
private string <StringRepresentation>k__BackingField;
    public string StringRepresentation { get; private set; }
    public string MSBuildPropertyName { get; }
    private MSBuildExtensionsPathReferenceKind(string value);
    private static MSBuildExtensionsPathReferenceKind();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_StringRepresentation();
    [CompilerGeneratedAttribute]
private void set_StringRepresentation(string value);
    [IsReadOnlyAttribute]
public string get_MSBuildPropertyName();
    public static MSBuildExtensionsPathReferenceKind FindIn(string expression);
}
internal abstract class Microsoft.Build.Evaluation.MultipleComparisonNode : OperatorExpressionNode {
    private bool _conditionedPropertiesUpdated;
    protected abstract virtual bool Compare(double left, double right);
    protected abstract virtual bool Compare(bool left, bool right);
    protected abstract virtual bool Compare(string left, string right);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual void ResetState();
    private void UpdateConditionedProperties(IConditionEvaluationState state);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.NewProjectFileOptions : Enum {
    public int value__;
    public static NewProjectFileOptions None;
    public static NewProjectFileOptions IncludeXmlDeclaration;
    public static NewProjectFileOptions IncludeToolsVersion;
    public static NewProjectFileOptions IncludeXmlNamespace;
    public static NewProjectFileOptions IncludeAllOptions;
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.NotEqualExpressionNode : MultipleComparisonNode {
    internal string DebuggerDisplay { get; }
    protected virtual bool Compare(double left, double right);
    protected virtual bool Compare(bool left, bool right);
    protected virtual bool Compare(string left, string right);
    internal virtual string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.NotExpressionNode : OperatorExpressionNode {
    internal string DebuggerDisplay { get; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string get_DebuggerDisplay();
}
internal class Microsoft.Build.Evaluation.NuGetFrameworkWrapper : object {
    private static MethodInfo ParseMethod;
    private static MethodInfo IsCompatibleMethod;
    private static object DefaultCompatibilityProvider;
    private static PropertyInfo FrameworkProperty;
    private static PropertyInfo VersionProperty;
    private static PropertyInfo PlatformProperty;
    private static PropertyInfo PlatformVersionProperty;
    private static PropertyInfo AllFrameworkVersionsProperty;
    private object Parse(string tfm);
    public string GetTargetFrameworkIdentifier(string tfm);
    public string GetTargetFrameworkVersion(string tfm, int minVersionPartCount);
    public string GetTargetPlatformIdentifier(string tfm);
    public string GetTargetPlatformVersion(string tfm, int minVersionPartCount);
    public bool IsCompatible(string target, string candidate);
    private string GetNonZeroVersionParts(Version version, int minVersionPartCount);
    public string FilterTargetFrameworks(string incoming, string filter);
    [CompilerGeneratedAttribute]
private IEnumerable`1<ValueTuple`2<string, object>> <FilterTargetFrameworks>g__ParseTfms|16_0(string desiredTargetFrameworks);
    [CompilerGeneratedAttribute]
private ValueTuple`2<string, object> <FilterTargetFrameworks>b__16_2(string tfm);
}
internal abstract class Microsoft.Build.Evaluation.NumericComparisonExpressionNode : OperatorExpressionNode {
    protected abstract virtual bool Compare(double left, double right);
    protected abstract virtual bool Compare(Version left, Version right);
    protected abstract virtual bool Compare(Version left, double right);
    protected abstract virtual bool Compare(double left, Version right);
    internal virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.NumericExpressionNode : OperandExpressionNode {
    private string _value;
    internal string DebuggerDisplay { get; }
    internal NumericExpressionNode(string value);
    internal virtual bool TryBoolEvaluate(IConditionEvaluationState state, Boolean& result, LoggingContext loggingContext);
    internal virtual bool TryNumericEvaluate(IConditionEvaluationState state, Double& result, LoggingContext loggingContext);
    internal virtual bool TryVersionEvaluate(IConditionEvaluationState state, Version& result, LoggingContext loggingContext);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual void ResetState();
    internal virtual string get_DebuggerDisplay();
}
internal abstract class Microsoft.Build.Evaluation.OperandExpressionNode : GenericExpressionNode {
    internal virtual bool DetectAnd();
    internal virtual bool DetectOr();
}
public enum Microsoft.Build.Evaluation.Operation : Enum {
    public int value__;
    public static Operation Include;
    public static Operation Exclude;
    public static Operation Update;
    public static Operation Remove;
}
internal abstract class Microsoft.Build.Evaluation.OperatorExpressionNode : GenericExpressionNode {
    [CompilerGeneratedAttribute]
private GenericExpressionNode <LeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericExpressionNode <RightChild>k__BackingField;
    internal GenericExpressionNode LeftChild { get; internal set; }
    internal GenericExpressionNode RightChild { get; internal set; }
    internal virtual bool TryBoolEvaluate(IConditionEvaluationState state, Boolean& result, LoggingContext loggingContext);
    internal abstract virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual bool TryNumericEvaluate(IConditionEvaluationState state, Double& result, LoggingContext loggingContext);
    internal virtual bool TryVersionEvaluate(IConditionEvaluationState state, Version& result, LoggingContext loggingContext);
    internal virtual string GetExpandedValue(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual void ResetState();
    [CompilerGeneratedAttribute]
internal void set_LeftChild(GenericExpressionNode value);
    [CompilerGeneratedAttribute]
internal GenericExpressionNode get_LeftChild();
    [CompilerGeneratedAttribute]
internal void set_RightChild(GenericExpressionNode value);
    [CompilerGeneratedAttribute]
internal GenericExpressionNode get_RightChild();
    internal virtual bool DetectAnd();
    internal virtual bool DetectOr();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.OrExpressionNode : OperatorExpressionNode {
    private bool _possibleOrCollision;
    internal string DebuggerDisplay { get; }
    internal bool PossibleOrCollision { get; internal set; }
    internal virtual bool BoolEvaluate(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string get_DebuggerDisplay();
    internal virtual void set_PossibleOrCollision(bool value);
    internal virtual bool get_PossibleOrCollision();
}
internal class Microsoft.Build.Evaluation.Parser : object {
    private Scanner _lexer;
    private ParserOptions _options;
    private ElementLocation _elementLocation;
    internal int errorPosition;
    private bool _warnedForExpression;
    private BuildEventContext _logBuildEventContext;
    private ILoggingService _loggingServices;
    internal BuildEventContext LogBuildEventContext { get; internal set; }
    internal ILoggingService LoggingServices { get; internal set; }
    internal BuildEventContext get_LogBuildEventContext();
    internal void set_LogBuildEventContext(BuildEventContext value);
    internal void set_LoggingServices(ILoggingService value);
    internal ILoggingService get_LoggingServices();
    internal GenericExpressionNode Parse(string expression, ParserOptions optionSettings, ElementLocation elementLocation);
    private GenericExpressionNode Expr(string expression);
    private GenericExpressionNode ExprPrime(string expression, GenericExpressionNode lhs);
    private GenericExpressionNode BooleanTerm(string expression);
    private GenericExpressionNode BooleanTermPrime(string expression, GenericExpressionNode lhs);
    private GenericExpressionNode RelationalExpr(string expression);
    private OperatorExpressionNode RelationalOperation(string expression);
    private GenericExpressionNode Factor(string expression);
    private void Arglist(string expression, List`1<GenericExpressionNode> arglist);
    private void Args(string expression, List`1<GenericExpressionNode> arglist);
    private GenericExpressionNode Arg(string expression);
    private bool Same(string expression, TokenType token);
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ParserOptions : Enum {
    public int value__;
    public static ParserOptions None;
    public static ParserOptions AllowProperties;
    public static ParserOptions AllowItemLists;
    public static ParserOptions AllowPropertiesAndItemLists;
    public static ParserOptions AllowBuiltInMetadata;
    public static ParserOptions AllowCustomMetadata;
    public static ParserOptions AllowItemMetadata;
    public static ParserOptions AllowPropertiesAndItemMetadata;
    public static ParserOptions AllowPropertiesAndCustomMetadata;
    public static ParserOptions AllowAll;
}
internal class Microsoft.Build.Evaluation.Preprocessor : object {
    private Project _project;
    private Dictionary`2<XmlElement, IList`1<ProjectRootElement>> _importTable;
    private Stack`1<string> _filePaths;
    private List`1<XmlNode> _addedNodes;
    private Dictionary`2<XmlDocument, List`1<ResolvedImport>> _implicitImportsByProject;
    private Preprocessor(Project project);
    internal static XmlDocument GetPreprocessedDocument(Project project);
    private XmlDocument Preprocess();
    private void AddToImportTable(XmlElement element, ProjectRootElement importedProject);
    private void CreateImplicitImportTable();
    private void AddImplicitImportNodes(XmlElement documentElement);
    private void CloneChildrenResolvingImports(XmlNode source, XmlNode destination);
}
internal class Microsoft.Build.Evaluation.ProfilerResultPrettyPrinter : object {
    public static string GetMarkdownContent(ProfilerResult result);
    public static string GetTsvContent(ProfilerResult result);
    private static string GetContent(ProfilerResult result, EvaluationLocationPrettyPrinterBase evaluationLocationPrinter);
}
[DebuggerDisplayAttribute("{FullPath} EffectiveToolsVersion={ToolsVersion} #GlobalProperties={implementation._data.GlobalPropertiesDictionary.Count} #Properties={implementation._data.Properties.Count} #ItemTypes={implementation._data.ItemTypes.Count} #ItemDefinitions={implementation._data.ItemDefinitions.Count} #Items={implementation._data.Items.Count} #Targets={implementation._data.Targets.Count}")]
public class Microsoft.Build.Evaluation.Project : object {
    private static bool s_debugEvaluation;
    private static Char[] s_invalidGlobChars;
    private static BuildEventContext s_buildEventContext;
    private ProjectLink implementation;
    private IProjectLinkInternal implementationInternal;
    private IDirectoryCacheFactory _directoryCacheFactory;
    internal static NewProjectFileOptions DefaultNewProjectTemplateOptions;
    [CompilerGeneratedAttribute]
private ProjectCollection <ProjectCollection>k__BackingField;
    internal bool IsLinked { get; }
    internal ProjectLink Link { get; }
    private object Microsoft.Build.ObjectModelRemoting.ILinkableObject.Link { get; }
    public bool ThrowInsteadOfSplittingItemElement { get; public set; }
    internal Data TestOnlyGetPrivateData { get; }
    public ProjectCollection ProjectCollection { get; }
    public ProjectRootElement Xml { get; }
    public bool IsDirty { get; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    internal int GlobalPropertiesCount { get; }
    internal IEnumerable`1<KeyValuePair`2<string, string>> GlobalPropertiesEnumerable { get; }
    public ICollection`1<string> ItemTypes { get; }
    public ICollection`1<ProjectProperty> Properties { get; }
    public IDictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public IDictionary`2<string, ProjectItemDefinition> ItemDefinitions { get; }
    public ICollection`1<ProjectItem> Items { get; }
    public ICollection`1<ProjectItem> ItemsIgnoringCondition { get; }
    public IList`1<ResolvedImport> Imports { get; }
    public IList`1<ResolvedImport> ImportsIncludingDuplicates { get; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public ICollection`1<ProjectProperty> AllEvaluatedProperties { get; }
    public ICollection`1<ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get; }
    public ICollection`1<ProjectItem> AllEvaluatedItems { get; }
    public string ToolsVersion { get; }
    public string SubToolsetVersion { get; }
    public string DirectoryPath { get; }
    public string FullPath { get; public set; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    public bool IsBuildEnabled { get; public set; }
    public ElementLocation ProjectFileLocation { get; }
    public int EvaluationCounter { get; }
    public int LastEvaluationId { get; }
    internal ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    internal ILoggingService LoggingService { get; }
    internal Project(ProjectCollection projectCollection, ProjectLink link);
    public Project(NewProjectFileOptions newProjectFileOptions);
    public Project(ProjectCollection projectCollection);
    public Project(ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions);
    public Project(IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, NewProjectFileOptions newProjectFileOptions);
    public Project(ProjectRootElement xml);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private Project(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive);
    public Project(XmlReader xmlReader);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private Project(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive);
    public Project(string projectFile);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    public Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings);
    private Project(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, ProjectLoadSettings loadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive);
    private static Project();
    internal bool get_IsLinked();
    internal ProjectLink get_Link();
    private sealed virtual override object Microsoft.Build.ObjectModelRemoting.ILinkableObject.get_Link();
    [DebuggerStepThroughAttribute]
public bool get_ThrowInsteadOfSplittingItemElement();
    [DebuggerStepThroughAttribute]
public void set_ThrowInsteadOfSplittingItemElement(bool value);
    public static Project FromFile(string file, ProjectOptions options);
    public static Project FromProjectRootElement(ProjectRootElement rootElement, ProjectOptions options);
    public static Project FromXmlReader(XmlReader reader, ProjectOptions options);
    internal Data get_TestOnlyGetPrivateData();
    [CompilerGeneratedAttribute]
public ProjectCollection get_ProjectCollection();
    public ProjectRootElement get_Xml();
    public bool get_IsDirty();
    public IDictionary`2<string, string> get_GlobalProperties();
    internal bool GlobalPropertiesContains(string key);
    internal int get_GlobalPropertiesCount();
    internal IEnumerable`1<KeyValuePair`2<string, string>> get_GlobalPropertiesEnumerable();
    public ICollection`1<string> get_ItemTypes();
    public ICollection`1<ProjectProperty> get_Properties();
    public IDictionary`2<string, List`1<string>> get_ConditionedProperties();
    public IDictionary`2<string, ProjectItemDefinition> get_ItemDefinitions();
    public ICollection`1<ProjectItem> get_Items();
    public ICollection`1<ProjectItem> get_ItemsIgnoringCondition();
    public IList`1<ResolvedImport> get_Imports();
    public IList`1<ResolvedImport> get_ImportsIncludingDuplicates();
    public IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public ICollection`1<ProjectProperty> get_AllEvaluatedProperties();
    public ICollection`1<ProjectMetadata> get_AllEvaluatedItemDefinitionMetadata();
    public ICollection`1<ProjectItem> get_AllEvaluatedItems();
    public string get_ToolsVersion();
    public string get_SubToolsetVersion();
    public string get_DirectoryPath();
    [DebuggerStepThroughAttribute]
public string get_FullPath();
    [DebuggerStepThroughAttribute]
public void set_FullPath(string value);
    [DebuggerStepThroughAttribute]
public bool get_SkipEvaluation();
    [DebuggerStepThroughAttribute]
public void set_SkipEvaluation(bool value);
    [DebuggerStepThroughAttribute]
public bool get_DisableMarkDirty();
    [DebuggerStepThroughAttribute]
public void set_DisableMarkDirty(bool value);
    [DebuggerStepThroughAttribute]
public bool get_IsBuildEnabled();
    [DebuggerStepThroughAttribute]
public void set_IsBuildEnabled(bool value);
    public ElementLocation get_ProjectFileLocation();
    public int get_EvaluationCounter();
    public int get_LastEvaluationId();
    internal ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    internal ILoggingService get_LoggingService();
    public static string GetEvaluatedItemIncludeEscaped(ProjectItem item);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinition item);
    public List`1<GlobResult> GetAllGlobs();
    public List`1<GlobResult> GetAllGlobs(EvaluationContext evaluationContext);
    public List`1<GlobResult> GetAllGlobs(string itemType);
    public List`1<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType);
    public List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext);
    public List`1<ProvenanceResult> GetItemProvenance(ProjectItem item);
    public List`1<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext);
    public static string GetMetadataValueEscaped(ProjectMetadata metadatum);
    public static string GetMetadataValueEscaped(ProjectItem item, string name);
    public static string GetMetadataValueEscaped(ProjectItemDefinition item, string name);
    public static string GetPropertyValueEscaped(ProjectProperty property);
    public IEnumerable`1<ProjectElement> GetLogicalProject();
    [DebuggerStepThroughAttribute]
public ProjectProperty GetProperty(string name);
    public string GetPropertyValue(string name);
    public ProjectProperty SetProperty(string name, string unevaluatedValue);
    public bool SetGlobalProperty(string name, string escapedValue);
    public IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude);
    public IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude);
    public IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ICollection`1<ProjectItem> GetItems(string itemType);
    public ICollection`1<ProjectItem> GetItemsIgnoringCondition(string itemType);
    public ICollection`1<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude);
    public bool RemoveProperty(ProjectProperty property);
    public bool RemoveGlobalProperty(string name);
    public bool RemoveItem(ProjectItem item);
    public void RemoveItems(IEnumerable`1<ProjectItem> items);
    public string ExpandString(string unexpandedValue);
    public ProjectInstance CreateProjectInstance();
    public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings);
    public ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext);
    public void MarkDirty();
    public void ReevaluateIfNecessary();
    public void ReevaluateIfNecessary(EvaluationContext evaluationContext);
    public void Save();
    public void Save(Encoding encoding);
    public void Save(string path);
    public void Save(string path, Encoding encoding);
    public void Save(TextWriter writer);
    public void SaveLogicalProject(TextWriter writer);
    public bool Build();
    public bool Build(ILogger logger);
    public bool Build(IEnumerable`1<ILogger> loggers);
    public bool Build(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(string target);
    public bool Build(string target, IEnumerable`1<ILogger> loggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext);
    internal bool UsesProjectRootElement(ProjectRootElement xmlRootElement);
    internal bool SplitItemElementIfNecessary(ProjectItemElement itemElement);
    internal bool ItemElementRequiresSplitting(ProjectItemElement itemElement);
    internal bool IsSuitableExistingItemXml(ProjectItemElement candidateExistingItemXml, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    internal void RemoveItemBeforeItemTypeChange(ProjectItem item);
    internal void ReAddExistingItemAfterItemTypeChange(ProjectItem item);
    internal string ExpandPropertyValueBestEffortLeaveEscaped(string unevaluatedValue, ElementLocation propertyLocation);
    internal string ExpandItemIncludeBestEffortLeaveEscaped(ProjectItemElement renamedItemElement);
    internal string ExpandMetadataValueBestEffortLeaveEscaped(IMetadataTable metadataTable, string unevaluatedValue, ElementLocation metadataLocation);
    internal void Zombify();
    internal void VerifyThrowInvalidOperationNotZombie();
    internal void VerifyThrowInvalidOperationNotImported(ProjectRootElement otherXml);
}
public class Microsoft.Build.Evaluation.ProjectChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    public Project Project { get; private set; }
    internal ProjectChangedEventArgs(Project project);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(Project value);
}
public class Microsoft.Build.Evaluation.ProjectCollection : object {
    private ReaderWriterLockSlim _locker;
    private static ProjectCollection s_globalProjectCollection;
    private static Version s_engineVersion;
    private static string s_assemblyDisplayVersion;
    private static ProjectRootElementCacheBase s_projectRootElementCache;
    private LoadedProjectCollection _loadedProjects;
    private ExternalProjectsProvider _link;
    private ILoggingService _loggingService;
    private HostServices _hostServices;
    private Dictionary`2<string, Toolset> _toolsets;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private string _defaultToolsVersion;
    private int _toolsetsVersion;
    private bool _isBuildEnabled;
    private bool _onlyLogCriticalEvents;
    private bool _skipEvaluation;
    private bool _disableMarkDirty;
    private int _maxNodeCount;
    private LoggerMode _loggerMode;
    [CompilerGeneratedAttribute]
private ProjectAddedEventHandler ProjectAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectCollectionChangedEventArgs> ProjectCollectionChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectXmlChangedEventArgs> ProjectXmlChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectChangedEventArgs> ProjectChanged;
    [CompilerGeneratedAttribute]
private ToolsetDefinitionLocations <ToolsetLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CollectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheBase <ProjectRootElementCache>k__BackingField;
    public static ProjectCollection GlobalProjectCollection { get; }
    public static Version Version { get; }
    public static string DisplayVersion { get; }
    public string DefaultToolsVersion { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ICollection`1<Project> LoadedProjects { get; }
    public int Count { get; }
    public ICollection`1<ILogger> Loggers { get; }
    public ICollection`1<Toolset> Toolsets { get; }
    public ToolsetDefinitionLocations ToolsetLocations { get; }
    public bool IsBuildEnabled { get; public set; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public HostServices HostServices { get; public set; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    internal Guid CollectionId { get; }
    internal ExternalProjectsProvider Link { get; internal set; }
    internal ILoggingService LoggingService { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesCollection { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> EnvironmentProperties { get; }
    internal int ToolsetsVersion { get; }
    internal int MaxNodeCount { get; internal set; }
    internal ProjectRootElementCacheBase ProjectRootElementCache { get; }
    public ProjectCollection(ToolsetDefinitionLocations toolsetLocations);
    public ProjectCollection(IDictionary`2<string, string> globalProperties);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, ToolsetDefinitionLocations toolsetDefinitionLocations);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly);
    public ProjectCollection(IDictionary`2<string, string> globalProperties, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ToolsetDefinitionLocations toolsetDefinitionLocations, int maxNodeCount, bool onlyLogCriticalEvents, bool loadProjectsReadOnly, bool useAsynchronousLogging, bool reuseProjectRootElementCache);
    [CompilerGeneratedAttribute]
public void add_ProjectAdded(ProjectAddedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ProjectAdded(ProjectAddedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ProjectCollectionChanged(EventHandler`1<ProjectCollectionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProjectCollectionChanged(EventHandler`1<ProjectCollectionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProjectXmlChanged(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ProjectChanged(EventHandler`1<ProjectChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ProjectChanged(EventHandler`1<ProjectChangedEventArgs> value);
    public static ProjectCollection get_GlobalProjectCollection();
    public static Version get_Version();
    public static string get_DisplayVersion();
    public string get_DefaultToolsVersion();
    public void set_DefaultToolsVersion(string value);
    public IDictionary`2<string, string> get_GlobalProperties();
    public ICollection`1<Project> get_LoadedProjects();
    public int get_Count();
    [DebuggerStepThroughAttribute]
public ICollection`1<ILogger> get_Loggers();
    public sealed virtual ICollection`1<Toolset> get_Toolsets();
    [CompilerGeneratedAttribute]
public ToolsetDefinitionLocations get_ToolsetLocations();
    [DebuggerStepThroughAttribute]
public bool get_IsBuildEnabled();
    [DebuggerStepThroughAttribute]
public void set_IsBuildEnabled(bool value);
    public bool get_OnlyLogCriticalEvents();
    public void set_OnlyLogCriticalEvents(bool value);
    public HostServices get_HostServices();
    public void set_HostServices(HostServices value);
    public bool get_SkipEvaluation();
    public void set_SkipEvaluation(bool value);
    public bool get_DisableMarkDirty();
    public void set_DisableMarkDirty(bool value);
    [CompilerGeneratedAttribute]
internal Guid get_CollectionId();
    internal ExternalProjectsProvider get_Link();
    internal void set_Link(ExternalProjectsProvider value);
    [DebuggerStepThroughAttribute]
internal ILoggingService get_LoggingService();
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesCollection();
    internal PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentProperties();
    [DebuggerStepThroughAttribute]
internal int get_ToolsetsVersion();
    internal int get_MaxNodeCount();
    internal void set_MaxNodeCount(int value);
    [CompilerGeneratedAttribute]
internal ProjectRootElementCacheBase get_ProjectRootElementCache();
    public static string Escape(string unescapedString);
    public static string Unescape(string escapedString);
    public bool ContainsToolset(string toolsVersion);
    public void AddToolset(Toolset toolset);
    public bool RemoveToolset(string toolsVersion);
    public void RemoveAllToolsets();
    public sealed virtual Toolset GetToolset(string toolsVersion);
    public string GetEffectiveToolsVersion(string explicitToolsVersion, string toolsVersionFromProject);
    public ICollection`1<Project> GetLoadedProjects(string fullPath);
    internal ICollection`1<Project> GetLoadedProjects(bool includeExternal, string fullPath);
    public Project LoadProject(string fileName);
    public Project LoadProject(string fileName, string toolsVersion);
    public Project LoadProject(string fileName, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public Project LoadProject(XmlReader xmlReader);
    public Project LoadProject(XmlReader xmlReader, string toolsVersion);
    public Project LoadProject(XmlReader xmlReader, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public void RegisterLogger(ILogger logger);
    public void RegisterLoggers(IEnumerable`1<ILogger> loggers);
    public void RegisterForwardingLoggers(IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public void UnregisterAllLoggers();
    public void UnloadProject(Project project);
    public void UnloadProject(ProjectRootElement projectRootElement);
    public void UnloadAllProjects();
    public ProjectPropertyInstance GetGlobalProperty(string name);
    public void SetGlobalProperty(string name, string value);
    public bool RemoveGlobalProperty(string name);
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponent.InitializeComponent(IBuildComponentHost host);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponent.ShutdownComponent();
    public bool TryUnloadProject(ProjectRootElement projectRootElement);
    public void LogBuildFinishedEvent(bool success);
    internal void OnAfterRenameLoadedProject(string oldFullPathIfAny, Project project);
    internal void AfterUpdateLoadedProjectGlobalProperties(Project project);
    protected virtual void Dispose(bool disposing);
    private bool RemoveToolsetInternal(string toolsVersion);
    private void RegisterLoggerInternal(ILogger logger);
    private void ProjectRootElementCache_ProjectRootElementAddedHandler(object sender, ProjectRootElementCacheAddEntryEventArgs e);
    private void ProjectRootElementCache_ProjectRootElementDirtiedHandler(object sender, ProjectXmlChangedEventArgs e);
    private void ProjectRootElementCache_ProjectDirtiedHandler(object sender, ProjectChangedEventArgs e);
    private void OnProjectXmlChanged(ProjectXmlChangedEventArgs e);
    private void OnProjectChanged(ProjectChangedEventArgs e);
    private void OnProjectCollectionChanged(ProjectCollectionChangedEventArgs e);
    private void ShutDownLoggingService();
    private void CreateLoggingService(int maxCPUCount, bool onlyLogCriticalEvents);
    internal void ResetToolsetsForTests(ToolsetConfigurationReader configurationReaderForTestsOnly);
    internal void ResetToolsetsForTests(ToolsetRegistryReader registryReaderForTestsOnly);
    private void InitializeToolsetCollection(ToolsetRegistryReader registryReader, ToolsetConfigurationReader configReader);
}
public class Microsoft.Build.Evaluation.ProjectCollectionChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ProjectCollectionChangedState <Changed>k__BackingField;
    public ProjectCollectionChangedState Changed { get; private set; }
    internal ProjectCollectionChangedEventArgs(ProjectCollectionChangedState changedState);
    [CompilerGeneratedAttribute]
public ProjectCollectionChangedState get_Changed();
    [CompilerGeneratedAttribute]
private void set_Changed(ProjectCollectionChangedState value);
}
public enum Microsoft.Build.Evaluation.ProjectCollectionChangedState : Enum {
    public int value__;
    public static ProjectCollectionChangedState DefaultToolsVersion;
    public static ProjectCollectionChangedState Toolsets;
    public static ProjectCollectionChangedState Loggers;
    public static ProjectCollectionChangedState GlobalProperties;
    public static ProjectCollectionChangedState IsBuildEnabled;
    public static ProjectCollectionChangedState OnlyLogCriticalEvents;
    public static ProjectCollectionChangedState HostServices;
    public static ProjectCollectionChangedState DisableMarkDirty;
    public static ProjectCollectionChangedState SkipEvaluation;
}
internal class Microsoft.Build.Evaluation.ProjectImportPathMatch : object {
    public static ProjectImportPathMatch None;
    private string _propertyName;
    private string _msBuildPropertyFormat;
    private List`1<string> _searchPaths;
    public string PropertyName { get; }
    public string MsBuildPropertyFormat { get; }
    public List`1<string> SearchPaths { get; }
    internal ProjectImportPathMatch(string propertyName, List`1<string> searchPaths);
    public ProjectImportPathMatch(ITranslator translator);
    private static ProjectImportPathMatch();
    public string get_PropertyName();
    public string get_MsBuildPropertyFormat();
    public List`1<string> get_SearchPaths();
    public sealed virtual void Translate(ITranslator translator);
    internal static ProjectImportPathMatch FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("{ItemType}={EvaluatedInclude} [{UnevaluatedInclude}] #DirectMetadata={DirectMetadataCount}")]
public class Microsoft.Build.Evaluation.ProjectItem : object {
    private Project _project;
    private string _evaluatedIncludeBeforeWildcardExpansionEscaped;
    private List`1<ProjectItemDefinition> _inheritedItemDefinitions;
    private ProjectItemElement _xml;
    private string _evaluatedIncludeEscaped;
    private PropertyDictionary`1<ProjectMetadata> _directMetadata;
    private string _fullPath;
    internal ProjectItemLink Link { get; }
    [DebuggerBrowsableAttribute("0")]
public ProjectItemElement Xml { get; }
    public string ItemType { get; public set; }
    public string UnevaluatedInclude { get; public set; }
    public string EvaluatedInclude { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped { get; }
    private string Microsoft.Build.Evaluation.IItem.ProjectDirectory { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    public bool IsImported { get; }
    public IEnumerable`1<ProjectMetadata> DirectMetadata { get; }
    public int DirectMetadataCount { get; }
    public ICollection`1<ProjectMetadata> Metadata { get; }
    private IEnumerable`1<ProjectMetadata> Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.Metadata { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ICollection`1<ProjectMetadata> MetadataCollection { get; }
    internal string EvaluatedIncludeBeforeWildcardExpansion { get; }
    internal string EvaluatedIncludeBeforeWildcardExpansionEscaped { get; }
    internal List`1<ProjectItemDefinition> InheritedItemDefinitions { get; }
    internal ProjectItem(ProjectItemElement xml, Project project);
    internal ProjectItem(Project project, ProjectItemElement xml, string evaluatedIncludeEscaped, string evaluatedIncludeBeforeWildcardExpansionEscaped, PropertyDictionary`1<ProjectMetadata> directMetadataCloned, List`1<ProjectItemDefinition> inheritedItemDefinitionsCloned);
    internal virtual ProjectItemLink get_Link();
    [DebuggerStepThroughAttribute]
public ProjectItemElement get_Xml();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    public void set_ItemType(string value);
    [DebuggerStepThroughAttribute]
public string get_UnevaluatedInclude();
    public void set_UnevaluatedInclude(string value);
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedInclude();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_EvaluatedIncludeEscaped();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_ProjectDirectory();
    [DebuggerStepThroughAttribute]
public sealed virtual Project get_Project();
    public bool get_IsImported();
    public IEnumerable`1<ProjectMetadata> get_DirectMetadata();
    [DebuggerStepThroughAttribute]
public int get_DirectMetadataCount();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectMetadata> get_Metadata();
    private sealed virtual override IEnumerable`1<ProjectMetadata> Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.get_Metadata();
    [DebuggerStepThroughAttribute]
public int get_MetadataCount();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    internal ICollection`1<ProjectMetadata> get_MetadataCollection();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedIncludeBeforeWildcardExpansion();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedIncludeBeforeWildcardExpansionEscaped();
    [DebuggerStepThroughAttribute]
internal List`1<ProjectItemDefinition> get_InheritedItemDefinitions();
    public ProjectMetadata GetMetadata(string name);
    public sealed virtual string GetMetadataValue(string name);
    public bool HasMetadata(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(string name);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.GetMetadata(string name);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItem<Microsoft.Build.Evaluation.ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
    private ProjectMetadata SetMetadataOperation(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
    public bool RemoveMetadata(string name);
    public void Rename(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string itemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string itemType, string name);
    internal void ChangeItemType(string newItemType);
    internal void SplitOwnItemElement();
    private string GetBuiltInMetadataEscaped(string name);
    private ProjectMetadata GetItemDefinitionMetadata(string name);
    [CompilerGeneratedAttribute]
private bool <SetMetadataOperation>b__57_0(ProjectItem i);
}
[DebuggerDisplayAttribute("{_itemType} #Metadata={MetadataCount}")]
public class Microsoft.Build.Evaluation.ProjectItemDefinition : object {
    private Project _project;
    private string _itemType;
    private PropertyDictionary`1<ProjectMetadata> _metadata;
    internal ProjectItemDefinitionLink Link { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public IEnumerable`1<ProjectMetadata> Metadata { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal ProjectItemDefinition(Project project, string itemType);
    internal virtual ProjectItemDefinitionLink get_Link();
    [DebuggerStepThroughAttribute]
public sealed virtual Project get_Project();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    public IEnumerable`1<ProjectMetadata> get_Metadata();
    public int get_MetadataCount();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectMetadata GetMetadata(string name);
    public string GetMetadataValue(string name);
    public ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
    private sealed virtual override ProjectMetadata Microsoft.Build.Evaluation.IItemDefinition<Microsoft.Build.Evaluation.ProjectMetadata>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedValue, ProjectMetadata predecessor);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string specifiedItemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string name);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.ProjectLoadSettings : Enum {
    public int value__;
    public static ProjectLoadSettings Default;
    public static ProjectLoadSettings IgnoreMissingImports;
    public static ProjectLoadSettings RecordDuplicateButNotCircularImports;
    public static ProjectLoadSettings RejectCircularImports;
    public static ProjectLoadSettings RecordEvaluatedItemElements;
    public static ProjectLoadSettings IgnoreEmptyImports;
    public static ProjectLoadSettings DoNotEvaluateElementsWithFalseCondition;
    public static ProjectLoadSettings IgnoreInvalidImports;
    public static ProjectLoadSettings ProfileEvaluation;
    public static ProjectLoadSettings FailOnUnresolvedSdk;
}
[DebuggerDisplayAttribute("{Name}={EvaluatedValue} [{_xml.Value}]")]
public class Microsoft.Build.Evaluation.ProjectMetadata : object {
    private IProjectMetadataParent _parent;
    private ProjectMetadataElement _xml;
    private string _evaluatedValueEscaped;
    private ProjectMetadata _predecessor;
    internal ProjectMetadataLink Link { get; }
    public string Name { get; }
    public string EvaluatedValue { get; }
    public string UnevaluatedValue { get; public set; }
    internal IProjectMetadataParent Parent { get; }
    [DebuggerBrowsableAttribute("0")]
public ProjectMetadataElement Xml { get; }
    public Project Project { get; }
    public string ItemType { get; }
    public ProjectMetadata Predecessor { get; }
    public bool IsImported { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal string EvaluatedValueEscaped { get; }
    internal ProjectMetadata(object parent, ProjectMetadataElement xml);
    internal ProjectMetadata(IProjectMetadataParent parent, ProjectMetadataElement xml, string evaluatedValueEscaped, ProjectMetadata predecessor);
    internal virtual ProjectMetadataLink get_Link();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
public string get_UnevaluatedValue();
    [DebuggerStepThroughAttribute]
public void set_UnevaluatedValue(string value);
    internal IProjectMetadataParent get_Parent();
    [DebuggerStepThroughAttribute]
public ProjectMetadataElement get_Xml();
    [DebuggerStepThroughAttribute]
public Project get_Project();
    public string get_ItemType();
    [DebuggerStepThroughAttribute]
public ProjectMetadata get_Predecessor();
    public bool get_IsImported();
    public ElementLocation get_Location();
    public ElementLocation get_ConditionLocation();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedValueEscaped();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Evaluation.ProjectMetadata>.Equals(ProjectMetadata other);
    internal ProjectMetadata DeepClone();
}
[DebuggerDisplayAttribute("{Name}={EvaluatedValue} [{UnevaluatedValue}]")]
public abstract class Microsoft.Build.Evaluation.ProjectProperty : object {
    private Project _project;
    private string _evaluatedValueEscaped;
    internal string EvaluatedValueEscapedInternal { get; }
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped { get; }
    public string UnevaluatedValue { get; public set; }
    public bool IsEnvironmentProperty { get; }
    public bool IsGlobalProperty { get; }
    public bool IsReservedProperty { get; }
    [DebuggerBrowsableAttribute("0")]
public ProjectPropertyElement Xml { get; }
    [DebuggerBrowsableAttribute("0")]
public Project Project { get; }
    public ProjectProperty Predecessor { get; }
    public bool IsImported { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    internal ProjectProperty(Project project);
    internal ProjectProperty(Project project, string evaluatedValueEscaped);
    internal virtual string get_EvaluatedValueEscapedInternal();
    [DebuggerStepThroughAttribute]
public abstract virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IProperty.get_EvaluatedValueEscaped();
    [DebuggerStepThroughAttribute]
public abstract virtual string get_UnevaluatedValue();
    public abstract virtual void set_UnevaluatedValue(string value);
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsEnvironmentProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsGlobalProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual bool get_IsReservedProperty();
    [DebuggerStepThroughAttribute]
public abstract virtual ProjectPropertyElement get_Xml();
    [DebuggerStepThroughAttribute]
public Project get_Project();
    [DebuggerStepThroughAttribute]
public abstract virtual ProjectProperty get_Predecessor();
    public abstract virtual bool get_IsImported();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Evaluation.ProjectProperty>.Equals(ProjectProperty other);
    internal static ProjectProperty Create(Project project, string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, LoggingContext loggingContext);
    internal static ProjectProperty Create(Project project, ProjectPropertyElement xml, string evaluatedValueEscaped, ProjectProperty predecessor);
    internal void UpdateEvaluatedValue(string evaluatedValueEscaped);
    private static bool ProjectHasMatchingGlobalProperty(Project project, string propertyName);
}
internal class Microsoft.Build.Evaluation.ProjectRootElementCache : ProjectRootElementCacheBase {
    private static int s_maximumStrongCacheSize;
    private static bool s_debugLogCacheActivity;
    private static bool s_сheckFileContent;
    private WeakValueDictionary`2<string, ProjectRootElement> _weakCache;
    private ConcurrentDictionary`2<string, object> _fileLoadLocks;
    private LinkedList`1<ProjectRootElement> _strongCache;
    private bool _autoReloadFromDisk;
    private object _locker;
    internal ProjectRootElementCache(bool autoReloadFromDisk, bool loadProjectsReadOnly);
    private static ProjectRootElementCache();
    private bool IsInvalidEntry(string projectFile, ProjectRootElement projectRootElement);
    internal virtual ProjectRootElement Get(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    private ProjectRootElement GetOrLoad(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    internal virtual void AddEntry(ProjectRootElement projectRootElement);
    internal virtual void RenameEntry(string oldFullPath, ProjectRootElement projectRootElement);
    internal virtual ProjectRootElement TryGet(string projectFile);
    internal virtual ProjectRootElement TryGet(string projectFile, Nullable`1<bool> preserveFormatting);
    internal virtual void DiscardStrongReferences();
    internal virtual void Clear();
    internal virtual void DiscardImplicitReferences();
    internal virtual void DiscardAnyWeakReference(ProjectRootElement projectRootElement);
    private void RenameEntryInternal(string oldFullPathIfAny, ProjectRootElement projectRootElement);
    private void BoostEntryInStrongCache(ProjectRootElement projectRootElement);
    private void ForgetEntry(ProjectRootElement projectRootElement);
    private void ForgetEntryIfExists(ProjectRootElement projectRootElement);
    private void DebugTraceCache(string message, bool param1);
    private void DebugTraceCache(string message, int param1);
    private void DebugTraceCache(string message, string param1);
}
internal class Microsoft.Build.Evaluation.ProjectRootElementCacheAddEntryEventArgs : EventArgs {
    internal ProjectRootElement RootElement;
    internal ProjectRootElementCacheAddEntryEventArgs(ProjectRootElement element);
}
internal abstract class Microsoft.Build.Evaluation.ProjectRootElementCacheBase : object {
    [CompilerGeneratedAttribute]
private bool <LoadProjectsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private static StrongCacheEntryRemovedDelegate StrongCacheEntryRemoved;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheAddEntryHandler ProjectRootElementAddedHandler;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectXmlChangedEventArgs> ProjectRootElementDirtied;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProjectChangedEventArgs> ProjectDirtied;
    public bool LoadProjectsReadOnly { get; protected set; }
    [CompilerGeneratedAttribute]
public bool get_LoadProjectsReadOnly();
    [CompilerGeneratedAttribute]
protected void set_LoadProjectsReadOnly(bool value);
    [CompilerGeneratedAttribute]
internal static void add_StrongCacheEntryRemoved(StrongCacheEntryRemovedDelegate value);
    [CompilerGeneratedAttribute]
internal static void remove_StrongCacheEntryRemoved(StrongCacheEntryRemovedDelegate value);
    [CompilerGeneratedAttribute]
internal void add_ProjectRootElementAddedHandler(ProjectRootElementCacheAddEntryHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ProjectRootElementAddedHandler(ProjectRootElementCacheAddEntryHandler value);
    [CompilerGeneratedAttribute]
internal void add_ProjectRootElementDirtied(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ProjectRootElementDirtied(EventHandler`1<ProjectXmlChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ProjectDirtied(EventHandler`1<ProjectChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ProjectDirtied(EventHandler`1<ProjectChangedEventArgs> value);
    internal abstract virtual ProjectRootElement Get(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    internal abstract virtual void AddEntry(ProjectRootElement projectRootElement);
    internal abstract virtual void RenameEntry(string oldFullPath, ProjectRootElement projectRootElement);
    internal abstract virtual ProjectRootElement TryGet(string projectFile);
    internal abstract virtual ProjectRootElement TryGet(string projectFile, Nullable`1<bool> preserveFormatting);
    internal abstract virtual void DiscardStrongReferences();
    internal abstract virtual void Clear();
    internal abstract virtual void DiscardImplicitReferences();
    internal abstract virtual void DiscardAnyWeakReference(ProjectRootElement projectRootElement);
    internal virtual void OnProjectRootElementDirtied(ProjectRootElement sender, ProjectXmlChangedEventArgs e);
    internal virtual void OnProjectDirtied(Project sender, ProjectChangedEventArgs e);
    protected void RaiseProjectRootElementAddedToCacheEvent(ProjectRootElement rootElement);
    protected virtual void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement);
}
public class Microsoft.Build.Evaluation.ProjectXmlChangedEventArgs : EventArgs {
    private string _unformattedReason;
    private string _formattingParameter;
    [CompilerGeneratedAttribute]
private ProjectRootElement <ProjectXml>k__BackingField;
    public ProjectRootElement ProjectXml { get; private set; }
    public string Reason { get; }
    internal ProjectXmlChangedEventArgs(ProjectRootElement projectXml, string unformattedReason, string formattingParameter);
    [CompilerGeneratedAttribute]
public ProjectRootElement get_ProjectXml();
    [CompilerGeneratedAttribute]
private void set_ProjectXml(ProjectRootElement value);
    public string get_Reason();
}
internal class Microsoft.Build.Evaluation.PropertyTrackingEvaluatorDataWrapper`4 : object {
    private IEvaluatorData`4<P, I, M, D> _wrapped;
    private HashSet`1<string> _overwrittenEnvironmentVariables;
    private EvaluationLoggingContext _evaluationLoggingContext;
    private PropertyTrackingSetting<P, I, M, D> _settings;
    public int EvaluationId { get; public set; }
    public string Directory { get; }
    public TaskRegistry TaskRegistry { get; public set; }
    public Toolset Toolset { get; }
    public string SubToolsetVersion { get; }
    public string ExplicitToolsVersion { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    public ISet`1<string> GlobalPropertiesToTreatAsLocal { get; }
    public List`1<string> InitialTargets { get; public set; }
    public List`1<string> DefaultTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> BeforeTargets { get; public set; }
    public IDictionary`2<string, List`1<TargetSpecification>> AfterTargets { get; public set; }
    public Dictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public bool ShouldEvaluateForDesignTime { get; }
    public bool CanEvaluateElementsWithFalseConditions { get; }
    public PropertyDictionary`1<P> Properties { get; }
    public IEnumerable`1<D> ItemDefinitionsEnumerable { get; }
    public ItemDictionary`1<I> Items { get; }
    public List`1<ProjectItemElement> EvaluatedItemElements { get; }
    public PropertyDictionary`1<ProjectPropertyInstance> EnvironmentVariablePropertiesDictionary { get; }
    public PropertyTrackingEvaluatorDataWrapper`4(IEvaluatorData`4<P, I, M, D> dataToWrap, EvaluationLoggingContext evaluationLoggingContext, int settingValue);
    public sealed virtual P GetProperty(string name);
    public sealed virtual P GetProperty(string name, int startIndex, int endIndex);
    public sealed virtual P SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext);
    public sealed virtual P SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped);
    public sealed virtual ICollection`1<I> GetItems(string itemType);
    public sealed virtual int get_EvaluationId();
    public sealed virtual void set_EvaluationId(int value);
    public sealed virtual string get_Directory();
    public sealed virtual TaskRegistry get_TaskRegistry();
    public sealed virtual void set_TaskRegistry(TaskRegistry value);
    public sealed virtual Toolset get_Toolset();
    public sealed virtual string get_SubToolsetVersion();
    public sealed virtual string get_ExplicitToolsVersion();
    public sealed virtual PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    public sealed virtual ISet`1<string> get_GlobalPropertiesToTreatAsLocal();
    public sealed virtual List`1<string> get_InitialTargets();
    public sealed virtual void set_InitialTargets(List`1<string> value);
    public sealed virtual List`1<string> get_DefaultTargets();
    public sealed virtual void set_DefaultTargets(List`1<string> value);
    public sealed virtual IDictionary`2<string, List`1<TargetSpecification>> get_BeforeTargets();
    public sealed virtual void set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public sealed virtual IDictionary`2<string, List`1<TargetSpecification>> get_AfterTargets();
    public sealed virtual void set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    public sealed virtual Dictionary`2<string, List`1<string>> get_ConditionedProperties();
    public sealed virtual bool get_ShouldEvaluateForDesignTime();
    public sealed virtual bool get_CanEvaluateElementsWithFalseConditions();
    public sealed virtual PropertyDictionary`1<P> get_Properties();
    public sealed virtual IEnumerable`1<D> get_ItemDefinitionsEnumerable();
    public sealed virtual ItemDictionary`1<I> get_Items();
    public sealed virtual List`1<ProjectItemElement> get_EvaluatedItemElements();
    public sealed virtual PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentVariablePropertiesDictionary();
    public sealed virtual void InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
    public sealed virtual void FinishEvaluation();
    public sealed virtual void AddItem(I item);
    public sealed virtual void AddItemIgnoringCondition(I item);
    public sealed virtual IItemDefinition`1<M> AddItemDefinition(string itemType);
    public sealed virtual void AddToAllEvaluatedPropertiesList(P property);
    public sealed virtual void AddToAllEvaluatedItemDefinitionMetadataList(M itemDefinitionMetadatum);
    public sealed virtual void AddToAllEvaluatedItemsList(I item);
    public sealed virtual IItemDefinition`1<M> GetItemDefinition(string itemType);
    public sealed virtual ProjectTargetInstance GetTarget(string targetName);
    public sealed virtual void AddTarget(ProjectTargetInstance target);
    public sealed virtual void RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult);
    public sealed virtual void RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    public sealed virtual string ExpandString(string unexpandedValue);
    public sealed virtual bool EvaluateCondition(string condition);
    private void TrackPropertyRead(string name, P property);
    private void TrackEnvironmentVariableRead(string name);
    private void TrackUninitializedPropertyRead(string name);
    private void TrackPropertyWrite(P predecessor, P property, string location, PropertySource<P, I, M, D> source);
    private void TrackPropertyInitialValueSet(P property, PropertySource<P, I, M, D> source);
    private void TrackPropertyReassignment(P predecessor, P property, string location);
    private PropertySource<P, I, M, D> DeterminePropertySource(bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.Provenance : Enum {
    public int value__;
    public static Provenance Undefined;
    public static Provenance StringLiteral;
    public static Provenance Glob;
    public static Provenance Inconclusive;
}
public class Microsoft.Build.Evaluation.ProvenanceResult : object {
    [CompilerGeneratedAttribute]
private Operation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectItemElement <ItemElement>k__BackingField;
    [CompilerGeneratedAttribute]
private Provenance <Provenance>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Occurrences>k__BackingField;
    public Operation Operation { get; }
    public ProjectItemElement ItemElement { get; }
    public Provenance Provenance { get; }
    public int Occurrences { get; }
    public ProvenanceResult(ProjectItemElement itemElement, Operation operation, Provenance provenance, int occurrences);
    [CompilerGeneratedAttribute]
public Operation get_Operation();
    [CompilerGeneratedAttribute]
public ProjectItemElement get_ItemElement();
    [CompilerGeneratedAttribute]
public Provenance get_Provenance();
    [CompilerGeneratedAttribute]
public int get_Occurrences();
}
public class Microsoft.Build.Evaluation.ResolvedImport : ValueType {
    [CompilerGeneratedAttribute]
private ProjectImportElement <ImportingElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElement <ImportedProject>k__BackingField;
    [CompilerGeneratedAttribute]
private SdkResult <SdkResult>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VersionEvaluated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImported>k__BackingField;
    public ProjectImportElement ImportingElement { get; }
    public ProjectRootElement ImportedProject { get; }
    public SdkResult SdkResult { get; }
    internal int VersionEvaluated { get; }
    public bool IsImported { get; }
    internal ResolvedImport(ProjectImportElement importingElement, ProjectRootElement importedProject, int versionEvaluated, SdkResult sdkResult, bool isImported);
    internal ResolvedImport(Project project, ProjectImportElement importingElement, ProjectRootElement importedProject, int versionEvaluated, SdkResult sdkResult);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ProjectImportElement get_ImportingElement();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ProjectRootElement get_ImportedProject();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SdkResult get_SdkResult();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal int get_VersionEvaluated();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsImported();
}
internal class Microsoft.Build.Evaluation.Scanner : object {
    private string _expression;
    private int _parsePoint;
    private Token _lookahead;
    internal bool _errorState;
    private int _errorPosition;
    private string _unexpectedlyFound;
    private ParserOptions _options;
    private string _errorResource;
    private static string s_endOfInput;
    private string EndOfInput { get; }
    internal Token CurrentToken { get; }
    internal string UnexpectedlyFound { get; }
    internal Scanner(string expressionToParse, ParserOptions options);
    private string get_EndOfInput();
    internal string GetErrorResource();
    internal bool IsNext(TokenType type);
    internal string IsNextString();
    internal Token get_CurrentToken();
    internal int GetErrorPosition();
    internal string get_UnexpectedlyFound();
    internal bool Advance();
    private string ParsePropertyOrItemMetadata();
    private static bool ScanForPropertyExpressionEnd(string expression, int index, Int32& indexResult);
    private bool ParseProperty();
    private bool ParseItemMetadata();
    private bool CheckForUnexpectedMetadata(string expression);
    private bool ParseInternalItemList();
    private bool ParseItemList();
    private bool ParseQuotedString();
    private bool ParseRemaining();
    private bool ParseSimpleStringOrFunction(int start);
    private bool ParseNumeric(int start);
    private void SkipWhiteSpace();
    private void SkipDigits();
    private void SkipHexDigits();
    private void SkipSimpleStringChars();
}
internal class Microsoft.Build.Evaluation.SemiColonTokenizer : ValueType {
    private string _expression;
    public SemiColonTokenizer(string expression);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[FlagsAttribute]
internal enum Microsoft.Build.Evaluation.ShredderOptions : Enum {
    public int value__;
    public static ShredderOptions Invalid;
    public static ShredderOptions ItemTypes;
    public static ShredderOptions MetadataOutsideTransforms;
    public static ShredderOptions All;
}
internal class Microsoft.Build.Evaluation.SimpleProjectRootElementCache : ProjectRootElementCacheBase {
    private ConcurrentDictionary`2<string, ProjectRootElement> _cache;
    internal virtual ProjectRootElement Get(string projectFile, OpenProjectRootElement loadProjectRootElement, bool isExplicitlyLoaded, Nullable`1<bool> preserveFormatting);
    private ProjectRootElement GetFromCache(string projectFile);
    private ProjectRootElement GetFromOrAddToCache(string projectFile, OpenProjectRootElement loadFunc);
    internal virtual void AddEntry(ProjectRootElement projectRootElement);
    internal virtual void RenameEntry(string oldFullPath, ProjectRootElement projectRootElement);
    internal virtual ProjectRootElement TryGet(string projectFile);
    internal virtual ProjectRootElement TryGet(string projectFile, Nullable`1<bool> preserveFormatting);
    internal virtual void DiscardStrongReferences();
    internal virtual void Clear();
    internal virtual void DiscardImplicitReferences();
    internal virtual void DiscardAnyWeakReference(ProjectRootElement projectRootElement);
    internal virtual void OnProjectRootElementDirtied(ProjectRootElement sender, ProjectXmlChangedEventArgs e);
    internal virtual void OnProjectDirtied(Project sender, ProjectChangedEventArgs e);
    protected virtual void RaiseProjectRootElementRemovedFromStrongCache(ProjectRootElement projectRootElement);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Build.Evaluation.StringExpressionNode : OperandExpressionNode {
    private string _value;
    private string _cachedExpandedValue;
    private bool _expandable;
    private Nullable`1<bool> _shouldBeTreatedAsVisualStudioVersion;
    internal string DebuggerDisplay { get; }
    internal StringExpressionNode(string value, bool expandable);
    internal virtual bool TryBoolEvaluate(IConditionEvaluationState state, Boolean& result, LoggingContext loggingContext);
    internal virtual bool TryNumericEvaluate(IConditionEvaluationState state, Double& result, LoggingContext loggingContext);
    internal virtual bool TryVersionEvaluate(IConditionEvaluationState state, Version& result, LoggingContext loggingContext);
    internal virtual bool EvaluatesToEmpty(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string GetUnexpandedValue(IConditionEvaluationState state);
    internal virtual string GetExpandedValue(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual void ResetState();
    private bool ShouldBeTreatedAsVisualStudioVersion(IConditionEvaluationState state, LoggingContext loggingContext);
    internal virtual string get_DebuggerDisplay();
}
internal class Microsoft.Build.Evaluation.StringMetadataTable : object {
    private Dictionary`2<string, string> _metadata;
    internal StringMetadataTable(Dictionary`2<string, string> metadata);
    public sealed virtual string GetEscapedValue(string name);
    public sealed virtual string GetEscapedValue(string itemType, string name);
    public sealed virtual string GetEscapedValueIfPresent(string itemType, string name);
}
[DebuggerDisplayAttribute("SubToolsetVersion={SubToolsetVersion} #Properties={_properties.Count}")]
public class Microsoft.Build.Evaluation.SubToolset : object {
    private string _subToolsetVersion;
    private PropertyDictionary`1<ProjectPropertyInstance> _properties;
    public string SubToolsetVersion { get; }
    public IDictionary`2<string, ProjectPropertyInstance> Properties { get; }
    internal SubToolset(string subToolsetVersion, PropertyDictionary`1<ProjectPropertyInstance> properties);
    private SubToolset(ITranslator translator);
    public string get_SubToolsetVersion();
    public IDictionary`2<string, ProjectPropertyInstance> get_Properties();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static SubToolset FactoryForDeserialization(ITranslator translator);
}
internal class Microsoft.Build.Evaluation.Token : object {
    internal static Token Comma;
    internal static Token LeftParenthesis;
    internal static Token RightParenthesis;
    internal static Token LessThan;
    internal static Token GreaterThan;
    internal static Token LessThanOrEqualTo;
    internal static Token GreaterThanOrEqualTo;
    internal static Token And;
    internal static Token Or;
    internal static Token EqualTo;
    internal static Token NotEqualTo;
    internal static Token Not;
    internal static Token EndOfInput;
    private TokenType _tokenType;
    private string _tokenString;
    [CompilerGeneratedAttribute]
private bool <Expandable>k__BackingField;
    internal bool Expandable { get; internal set; }
    internal string String { get; }
    private Token(TokenType tokenType);
    internal Token(TokenType type, string tokenString);
    internal Token(TokenType type, string tokenString, bool expandable);
    private static Token();
    [CompilerGeneratedAttribute]
internal bool get_Expandable();
    [CompilerGeneratedAttribute]
internal void set_Expandable(bool value);
    internal bool IsToken(TokenType type);
    internal string get_String();
}
[DebuggerDisplayAttribute("ToolsVersion={ToolsVersion} ToolsPath={ToolsPath} #Properties={_properties.Count}")]
public class Microsoft.Build.Evaluation.Toolset : object {
    private static string DefaultTasksFilePattern;
    private static string OverrideTasksFilePattern;
    private static string Dev10OverallInstallKeyRegistryPath;
    private static string Dev10UltimateInstallKeyRegistryPath;
    private static string Dev10PremiumInstallKeyRegistryPath;
    private static string Dev10ProfessionalInstallKeyRegistryPath;
    private static string Dev10VCSExpressInstallKeyRegistryPath;
    private static string Dev10VBExpressInstallKeyRegistryPath;
    private static string Dev10VCExpressInstallKeyRegistryPath;
    private static string Dev10VWDExpressInstallKeyRegistryPath;
    private static string Dev10LightSwitchInstallKeyRegistryPath;
    private static Nullable`1<bool> s_dev10IsInstalled;
    private string _toolsVersion;
    private string _toolsPath;
    private PropertyDictionary`1<ProjectPropertyInstance> _properties;
    private string _overrideTasksPath;
    private string _defaultOverrideToolsVersion;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private bool _defaultTasksRegistrationAttempted;
    private bool _overrideTasksRegistrationAttempted;
    private TaskRegistry _defaultTaskRegistry;
    private TaskRegistry _overrideTaskRegistry;
    private DirectoryGetFiles _getFiles;
    private DirectoryExists _directoryExists;
    private LoadXmlFromPath _loadXmlFromPath;
    private Expander`2<ProjectPropertyInstance, ProjectItemInstance> _expander;
    private Dictionary`2<string, SubToolset> _subToolsets;
    private string _defaultSubToolsetVersion;
    private Dictionary`2<string, ProjectImportPathMatch> _propertySearchPathsTable;
    [CompilerGeneratedAttribute]
private Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> <MSBuildExtensionsPathSearchPathsTable>k__BackingField;
    public string ToolsVersion { get; }
    public string ToolsPath { get; private set; }
    public IDictionary`2<string, ProjectPropertyInstance> Properties { get; }
    public IDictionary`2<string, SubToolset> SubToolsets { get; }
    public string DefaultSubToolsetVersion { get; }
    internal static bool Dev10IsInstalled { get; }
    internal string OverrideTasksPath { get; }
    internal string DefaultOverrideToolsVersion { get; }
    internal Dictionary`2<string, ProjectImportPathMatch> ImportPropertySearchPathsTable { get; }
    internal Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> MSBuildExtensionsPathSearchPathsTable { get; internal set; }
    public Toolset(string toolsVersion, string toolsPath, ProjectCollection projectCollection, string msbuildOverrideTasksPath);
    public Toolset(string toolsVersion, string toolsPath, IDictionary`2<string, string> buildProperties, ProjectCollection projectCollection, string msbuildOverrideTasksPath);
    public Toolset(string toolsVersion, string toolsPath, IDictionary`2<string, string> buildProperties, ProjectCollection projectCollection, IDictionary`2<string, SubToolset> subToolsets, string msbuildOverrideTasksPath);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> buildProperties, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, IDictionary`2<string, SubToolset> subToolsets, string msbuildOverrideTasksPath, string defaultOverrideToolsVersion, Dictionary`2<string, ProjectImportPathMatch> importSearchPathsTable);
    internal Toolset(string toolsVersion, string toolsPath, PropertyDictionary`1<ProjectPropertyInstance> buildProperties, ProjectCollection projectCollection, DirectoryGetFiles getFiles, LoadXmlFromPath loadXmlFromPath, string msbuildOverrideTasksPath, DirectoryExists directoryExists);
    private Toolset(ITranslator translator);
    internal ProjectImportPathMatch GetProjectImportSearchPaths(string expression);
    public string get_ToolsVersion();
    public string get_ToolsPath();
    private void set_ToolsPath(string value);
    public IDictionary`2<string, ProjectPropertyInstance> get_Properties();
    public IDictionary`2<string, SubToolset> get_SubToolsets();
    public string get_DefaultSubToolsetVersion();
    internal static bool get_Dev10IsInstalled();
    internal string get_OverrideTasksPath();
    internal string get_DefaultOverrideToolsVersion();
    internal Dictionary`2<string, ProjectImportPathMatch> get_ImportPropertySearchPathsTable();
    [CompilerGeneratedAttribute]
internal Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> get_MSBuildExtensionsPathSearchPathsTable();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPathSearchPathsTable(Dictionary`2<MSBuildExtensionsPathReferenceKind, IList`1<string>> value);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    public string GenerateSubToolsetVersion();
    public string GenerateSubToolsetVersion(IDictionary`2<string, string> overrideGlobalProperties, int solutionVersion);
    public ProjectPropertyInstance GetProperty(string propertyName, string subToolsetVersion);
    internal static Toolset FactoryForDeserialization(ITranslator translator);
    internal static String[] GetTaskFiles(DirectoryGetFiles getFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskPattern, string searchPath, string taskFileWarning);
    internal string GenerateSubToolsetVersion(PropertyDictionary`1<ProjectPropertyInstance> overrideGlobalProperties);
    internal string GenerateSubToolsetVersion(int visualStudioVersionFromSolution);
    internal TaskRegistry GetTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache);
    internal string GenerateSubToolsetVersionUsingVisualStudioVersion(IDictionary`2<string, string> overrideGlobalProperties, int visualStudioVersionFromSolution);
    internal TaskRegistry GetOverrideTaskRegistry(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache);
    private void RegisterDefaultTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache);
    private void InitializeProperties(ILoggingService loggingServices, BuildEventContext buildEventContext);
    private void RegisterOverrideTasks(ILoggingService loggingServices, BuildEventContext buildEventContext, ProjectRootElementCacheBase projectRootElementCache);
    private void LoadAndRegisterFromTasksFile(String[] defaultTaskFiles, ILoggingService loggingServices, BuildEventContext buildEventContext, string taskFileError, ProjectRootElementCacheBase projectRootElementCache, TaskRegistry registry);
}
internal class Microsoft.Build.Evaluation.ToolsetConfigurationReader : ToolsetReader {
    private ToolsetConfigurationSection _configurationSection;
    private Func`1<Configuration> _readApplicationConfiguration;
    private bool _configurationReadAttempted;
    private static Char[] s_separatorForExtensionsPathSearchPaths;
    private static Lazy`1<Configuration> s_configurationCache;
    private Dictionary`2<string, Dictionary`2<string, ProjectImportPathMatch>> _projectImportSearchPathsCache;
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected string DefaultOverrideToolsVersion { get; }
    private ToolsetConfigurationSection ConfigurationSection { get; }
    internal ToolsetConfigurationReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    internal ToolsetConfigurationReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, Func`1<Configuration> readApplicationConfiguration);
    private static ToolsetConfigurationReader();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetConfigurationReader/<get_ToolsVersions>d__9")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected virtual string get_DefaultToolsVersion();
    protected virtual string get_MSBuildOverrideTasksPath();
    protected virtual string get_DefaultOverrideToolsVersion();
    private ToolsetConfigurationSection get_ConfigurationSection();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetConfigurationReader/<GetPropertyDefinitions>d__18")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetConfigurationReader/<GetSubToolsetVersions>d__19")]
protected virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetConfigurationReader/<GetSubToolsetPropertyDefinitions>d__20")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
    protected virtual Dictionary`2<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os);
    private Dictionary`2<string, ProjectImportPathMatch> ComputeDistinctListOfSearchPaths(PropertyElementCollection propertyCollection);
    private static Configuration ReadApplicationConfiguration();
    private static Configuration ReadOpenMappedExeConfiguration();
}
internal static class Microsoft.Build.Evaluation.ToolsetConfigurationReaderHelpers : object {
    private static object s_syncLock;
    private static ToolsetConfigurationSection s_toolsetConfigurationSectionCache;
    private static Configuration s_configurationOfCachedSection;
    private static ToolsetConfigurationReaderHelpers();
    internal static ToolsetConfigurationSection ReadToolsetConfigurationSection(Configuration configuration);
    private static ToolsetConfigurationSection GetToolsetConfigurationSection(Configuration configuration);
}
internal class Microsoft.Build.Evaluation.ToolsetConfigurationSection : ConfigurationSection {
    [ConfigurationPropertyAttribute("")]
public ToolsetElementCollection Toolsets { get; }
    [ConfigurationPropertyAttribute("default")]
public string Default { get; public set; }
    [ConfigurationPropertyAttribute("msbuildOverrideTasksPath")]
public string MSBuildOverrideTasksPath { get; public set; }
    [ConfigurationPropertyAttribute("DefaultOverrideToolsVersion")]
public string DefaultOverrideToolsVersion { get; public set; }
    public ToolsetElementCollection get_Toolsets();
    public string get_Default();
    public void set_Default(string value);
    public string get_MSBuildOverrideTasksPath();
    public void set_MSBuildOverrideTasksPath(string value);
    public string get_DefaultOverrideToolsVersion();
    public void set_DefaultOverrideToolsVersion(string value);
}
[FlagsAttribute]
public enum Microsoft.Build.Evaluation.ToolsetDefinitionLocations : Enum {
    public int value__;
    public static ToolsetDefinitionLocations None;
    public static ToolsetDefinitionLocations ConfigurationFile;
    public static ToolsetDefinitionLocations Registry;
    public static ToolsetDefinitionLocations Local;
    public static ToolsetDefinitionLocations Default;
}
internal class Microsoft.Build.Evaluation.ToolsetElement : ConfigurationElement {
    [ConfigurationPropertyAttribute("toolsVersion")]
public string toolsVersion { get; public set; }
    [ConfigurationPropertyAttribute("")]
public PropertyElementCollection PropertyElements { get; }
    [ConfigurationPropertyAttribute("projectImportSearchPaths")]
public ExtensionsPathsElementCollection AllProjectImportSearchPaths { get; }
    public string get_toolsVersion();
    public void set_toolsVersion(string value);
    public PropertyElementCollection get_PropertyElements();
    public ExtensionsPathsElementCollection get_AllProjectImportSearchPaths();
}
internal class Microsoft.Build.Evaluation.ToolsetElementCollection : ConfigurationElementCollection {
    private Dictionary`2<string, string> _previouslySeenToolsVersions;
    public ConfigurationElementCollectionType CollectionType { get; }
    protected bool ThrowOnDuplicate { get; }
    protected string ElementName { get; }
    public virtual ConfigurationElementCollectionType get_CollectionType();
    protected virtual bool get_ThrowOnDuplicate();
    protected virtual string get_ElementName();
    public ToolsetElement GetElement(string toolsVersion);
    public ToolsetElement GetElement(int index);
    protected virtual object GetElementKey(ConfigurationElement element);
    protected virtual ConfigurationElement CreateNewElement();
    protected virtual void BaseAdd(int index, ConfigurationElement element);
    protected virtual void BaseAdd(ConfigurationElement element);
    private void UpdateToolsVersionMap(ConfigurationElement element);
}
internal class Microsoft.Build.Evaluation.ToolsetLocalReader : ToolsetReader {
    private IElementLocation _sourceLocation;
    protected string DefaultOverrideToolsVersion { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    internal ToolsetLocalReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    protected virtual string get_DefaultOverrideToolsVersion();
    protected virtual string get_DefaultToolsVersion();
    protected virtual string get_MSBuildOverrideTasksPath();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetLocalReader/<get_ToolsVersions>d__9")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetLocalReader/<GetPropertyDefinitions>d__10")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
    protected virtual Dictionary`2<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os);
    protected virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
}
[DebuggerDisplayAttribute("Name={Name} Value={Value}")]
internal class Microsoft.Build.Evaluation.ToolsetPropertyDefinition : object {
    private string _name;
    private string _value;
    private IElementLocation _source;
    public string Name { get; }
    public string Value { get; public set; }
    public IElementLocation Source { get; }
    public ToolsetPropertyDefinition(string name, string value, IElementLocation source);
    public string get_Name();
    public string get_Value();
    public void set_Value(string value);
    public IElementLocation get_Source();
}
internal class Microsoft.Build.Evaluation.ToolsetProvider : object {
    private Dictionary`2<string, Toolset> _toolsets;
    public ICollection`1<Toolset> Toolsets { get; }
    public ToolsetProvider(string defaultToolsVersion, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations);
    public ToolsetProvider(IEnumerable`1<Toolset> toolsets);
    private ToolsetProvider(ITranslator translator);
    public sealed virtual ICollection`1<Toolset> get_Toolsets();
    public sealed virtual Toolset GetToolset(string toolsVersion);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ToolsetProvider FactoryForDeserialization(ITranslator translator);
    private void InitializeToolsetCollection(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations toolsetDefinitionLocations);
}
internal abstract class Microsoft.Build.Evaluation.ToolsetReader : object {
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected string DefaultOverrideToolsVersion { get; }
    protected ToolsetReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected abstract virtual string get_DefaultToolsVersion();
    protected abstract virtual string get_MSBuildOverrideTasksPath();
    protected abstract virtual string get_DefaultOverrideToolsVersion();
    internal static string ReadAllToolsets(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations locations);
    internal static string ReadAllToolsets(Dictionary`2<string, Toolset> toolsets, ToolsetRegistryReader registryReader, ToolsetConfigurationReader configurationReader, PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, ToolsetDefinitionLocations locations);
    internal string ReadToolsets(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties, String& msBuildOverrideTasksPath, String& defaultOverrideToolsVersion);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected abstract virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    protected abstract virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
    protected abstract virtual Dictionary`2<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os);
    private void ReadEachToolset(Dictionary`2<string, Toolset> toolsets, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties);
    private Toolset ReadToolset(ToolsetPropertyDefinition toolsVersion, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties);
    private static PropertyDictionary`1<ProjectPropertyInstance> CreateStandardProperties(PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string version, string root, string toolsPath);
    private static void AppendStandardProperties(PropertyDictionary`1<ProjectPropertyInstance> properties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, string version, string root, string toolsPath);
    private void EvaluateAndSetProperty(ToolsetPropertyDefinition property, PropertyDictionary`1<ProjectPropertyInstance> properties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, PropertyDictionary`1<ProjectPropertyInstance> initialProperties, bool accumulateProperties, String& toolsPath, String& binPath, Expander`2& expander);
    private string ExpandPropertyUnescaped(ToolsetPropertyDefinition property, Expander`2<ProjectPropertyInstance, ProjectItemInstance> expander);
    private void SetProperty(ToolsetPropertyDefinition property, PropertyDictionary`1<ProjectPropertyInstance> propertyGroup, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    private string ExpandRelativePathsRelativeToExeLocation(string path);
    [CompilerGeneratedAttribute]
internal static void <ReadAllToolsets>g__ReadConfigToolset|12_0(<>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
internal static string <ReadEachToolset>g__existingRootOrNull|18_0(string path);
}
internal class Microsoft.Build.Evaluation.ToolsetRegistryReader : ToolsetReader {
    private static string MSBuildRegistryPath;
    private RegistryKeyWrapper _msbuildRegistryWrapper;
    protected IEnumerable`1<ToolsetPropertyDefinition> ToolsVersions { get; }
    protected string DefaultToolsVersion { get; }
    protected string MSBuildOverrideTasksPath { get; }
    protected string DefaultOverrideToolsVersion { get; }
    internal ToolsetRegistryReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties);
    internal ToolsetRegistryReader(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, PropertyDictionary`1<ProjectPropertyInstance> globalProperties, RegistryKeyWrapper msbuildRegistryWrapper);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetRegistryReader/<get_ToolsVersions>d__5")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> get_ToolsVersions();
    protected virtual string get_DefaultToolsVersion();
    protected virtual string get_MSBuildOverrideTasksPath();
    protected virtual string get_DefaultOverrideToolsVersion();
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetRegistryReader/<GetPropertyDefinitions>d__12")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetPropertyDefinitions(string toolsVersion);
    protected virtual IEnumerable`1<string> GetSubToolsetVersions(string toolsVersion);
    [IteratorStateMachineAttribute("Microsoft.Build.Evaluation.ToolsetRegistryReader/<GetSubToolsetPropertyDefinitions>d__14")]
protected virtual IEnumerable`1<ToolsetPropertyDefinition> GetSubToolsetPropertyDefinitions(string toolsVersion, string subToolsetVersion);
    protected virtual Dictionary`2<string, ProjectImportPathMatch> GetProjectImportSearchPathsTable(string toolsVersion, string os);
    private static ToolsetPropertyDefinition CreatePropertyFromRegistry(RegistryKeyWrapper toolsetWrapper, string propertyName);
    private static string GetValue(RegistryKeyWrapper wrapper, string valueName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Build.Evaluation.UsedUninitializedProperties : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, IElementLocation> _properties;
    [CompilerGeneratedAttribute]
private bool <Warn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentlyEvaluatingPropertyElementName>k__BackingField;
    internal bool Warn { get; internal set; }
    internal string CurrentlyEvaluatingPropertyElementName { get; internal set; }
    [NullableContextAttribute("1")]
internal void TryAdd(string propertyName, IElementLocation elementLocation);
    [NullableContextAttribute("1")]
internal bool TryGetPropertyElementLocation(string propertyName, IElementLocation& elementLocation);
    [NullableContextAttribute("1")]
internal void RemoveProperty(string propertyName);
    [CompilerGeneratedAttribute]
internal bool get_Warn();
    [CompilerGeneratedAttribute]
internal void set_Warn(bool value);
    [CompilerGeneratedAttribute]
internal string get_CurrentlyEvaluatingPropertyElementName();
    [CompilerGeneratedAttribute]
internal void set_CurrentlyEvaluatingPropertyElementName(string value);
}
internal class Microsoft.Build.Evaluation.ValueFragment : ItemSpecFragment {
    public ValueFragment(string textFragment, string projectDirectory);
}
public class Microsoft.Build.Exceptions.BuildAbortedException : BuildExceptionBase {
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    public string ErrorCode { get; private set; }
    public BuildAbortedException(string message);
    public BuildAbortedException(string message, Exception innerException);
    private BuildAbortedException(string message, Exception innerException, bool calledFromDeserialization);
    protected BuildAbortedException(SerializationInfo info, StreamingContext context);
    internal static BuildAbortedException CreateFromRemote(string message, Exception innerException);
    protected virtual IDictionary`2<string, string> FlushCustomState();
    protected virtual void InitializeCustomState(IDictionary`2<string, string> state);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Build.Exceptions.CircularDependencyException : BuildExceptionBase {
    internal CircularDependencyException(string message);
    internal CircularDependencyException(string message, Exception inner);
    protected CircularDependencyException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.Build.Exceptions.InternalLoggerException : BuildExceptionBase {
    private BuildEventArgs e;
    private string errorCode;
    private string helpKeyword;
    [OptionalFieldAttribute]
private bool initializationException;
    public BuildEventArgs BuildEventArgs { get; }
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public bool InitializationException { get; }
    public InternalLoggerException(string message);
    public InternalLoggerException(string message, Exception innerException);
    internal InternalLoggerException(string message, Exception innerException, BuildEventArgs e, string errorCode, string helpKeyword, bool initializationException);
    private InternalLoggerException(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual IDictionary`2<string, string> FlushCustomState();
    protected virtual void InitializeCustomState(IDictionary`2<string, string> state);
    [OnDeserializingAttribute]
private void SetDefaultsBeforeSerialization(StreamingContext sc);
    [OnDeserializedAttribute]
private void SetValueAfterDeserialization(StreamingContext sx);
    public BuildEventArgs get_BuildEventArgs();
    public string get_ErrorCode();
    public string get_HelpKeyword();
    public bool get_InitializationException();
    internal static void Throw(Exception innerException, BuildEventArgs e, string messageResourceName, bool initializationException, String[] messageArgs);
}
public class Microsoft.Build.Exceptions.InvalidProjectFileException : BuildExceptionBase {
    private string file;
    private int lineNumber;
    private int columnNumber;
    private int endLineNumber;
    private int endColumnNumber;
    private string errorSubcategory;
    private string errorCode;
    private string helpKeyword;
    private bool hasBeenLogged;
    public string Message { get; }
    public string BaseMessage { get; }
    public string ProjectFile { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string ErrorSubcategory { get; }
    public string ErrorCode { get; }
    public string HelpKeyword { get; }
    public bool HasBeenLogged { get; internal set; }
    public InvalidProjectFileException(string message);
    public InvalidProjectFileException(string message, Exception innerException);
    internal InvalidProjectFileException(string message, InvalidProjectFileException innerException);
    private InvalidProjectFileException(SerializationInfo info, StreamingContext context);
    public InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword);
    internal InvalidProjectFileException(string projectFile, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string errorSubcategory, string errorCode, string helpKeyword, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual IDictionary`2<string, string> FlushCustomState();
    protected virtual void InitializeCustomState(IDictionary`2<string, string> state);
    public virtual string get_Message();
    public string get_BaseMessage();
    public string get_ProjectFile();
    public int get_LineNumber();
    public int get_ColumnNumber();
    public int get_EndLineNumber();
    public int get_EndColumnNumber();
    public string get_ErrorSubcategory();
    public string get_ErrorCode();
    public string get_HelpKeyword();
    public bool get_HasBeenLogged();
    internal void set_HasBeenLogged(bool value);
}
public class Microsoft.Build.Exceptions.InvalidToolsetDefinitionException : BuildExceptionBase {
    private string errorCode;
    public string ErrorCode { get; }
    public InvalidToolsetDefinitionException(string message);
    public InvalidToolsetDefinitionException(string message, Exception innerException);
    protected InvalidToolsetDefinitionException(SerializationInfo info, StreamingContext context);
    public InvalidToolsetDefinitionException(string message, string errorCode);
    public InvalidToolsetDefinitionException(string message, string errorCode, Exception innerException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual IDictionary`2<string, string> FlushCustomState();
    protected virtual void InitializeCustomState(IDictionary`2<string, string> state);
    public string get_ErrorCode();
    internal static void Throw(string resourceName, String[] args);
    internal static void Throw(Exception innerException, string resourceName, String[] args);
}
internal class Microsoft.Build.Exceptions.RegistryException : BuildExceptionBase {
    public RegistryException(string message);
    public RegistryException(string message, Exception innerException);
    public RegistryException(string message, string source);
    protected RegistryException(SerializationInfo info, StreamingContext context);
    public RegistryException(string message, string source, Exception innerException);
}
public class Microsoft.Build.Execution.BuildManager : object {
    [CompilerGeneratedAttribute]
private static ConcurrentDictionary`2<ProjectCacheDescriptor, ProjectCacheDescriptor> <ProjectCacheDescriptors>k__BackingField;
    private static object s_staticSyncLock;
    private object _syncLock;
    private static BuildManager s_singletonInstance;
    private static int s_nextBuildId;
    private static int s_nextBuildRequestConfigurationId;
    private IConfigCache _configCache;
    private IResultsCache _resultsCache;
    private INodeManager _nodeManager;
    private INodeManager _taskHostNodeManager;
    private IScheduler _scheduler;
    private NodeConfiguration _nodeConfiguration;
    private ExceptionDispatchInfo _threadException;
    private HashSet`1<NGen`1<int>> _activeNodes;
    private AutoResetEvent _noNodesActiveEvent;
    private Dictionary`2<NGen`1<int>, HashSet`1<NGen`1<int>>> _nodeIdToKnownConfigurations;
    private bool _shuttingDown;
    private CancellationTokenSource _executionCancellationTokenSource;
    private BuildManagerState _buildManagerState;
    private string _hostName;
    private BuildParameters _buildParameters;
    private Dictionary`2<int, BuildSubmission> _buildSubmissions;
    private Dictionary`2<int, GraphBuildSubmission> _graphBuildSubmissions;
    private AutoResetEvent _noActiveSubmissionsEvent;
    private bool _overallBuildSuccess;
    private int _nextBuildSubmissionId;
    private Nullable`1<bool> _previousLowPriority;
    private Dictionary`2<ProjectInstance, string> _unnamedProjectInstanceToNames;
    private int _nextUnnamedProjectId;
    private BuildComponentFactoryCollection _componentFactories;
    private Dictionary`2<int, BuildEventArgs> _projectStartedEvents;
    private bool _acquiredProjectRootElementCacheFromProjectInstance;
    private ProjectStartedEventHandler _projectStartedEventHandler;
    private ProjectFinishedEventHandler _projectFinishedEventHandler;
    private LoggingExceptionDelegate _loggingThreadExceptionEventHandler;
    private LegacyThreadingData _legacyThreadingData;
    private ActionBlock`1<Action> _workQueue;
    private bool _disposed;
    private DateTime _instantiationTimeUtc;
    private IEnumerable`1<DeferredBuildMessage> _deferredBuildMessages;
    private BuildTelemetry _buildTelemetry;
    private ProjectCacheService _projectCacheService;
    private bool _hasProjectCacheServiceInitializedVsScenario;
    internal static ConcurrentDictionary`2<ProjectCacheDescriptor, ProjectCacheDescriptor> ProjectCacheDescriptors { get; }
    public static BuildManager DefaultBuildManager { get; }
    private ISdkResolverService SdkResolverService { get; }
    private ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService { get; }
    private string Microsoft.Build.BackEnd.IBuildComponentHost.Name { get; }
    private BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters { get; }
    private LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData { get; }
    public BuildManager(string hostName);
    private static BuildManager();
    [CompilerGeneratedAttribute]
internal static ConcurrentDictionary`2<ProjectCacheDescriptor, ProjectCacheDescriptor> get_ProjectCacheDescriptors();
    protected virtual override void Finalize();
    public static BuildManager get_DefaultBuildManager();
    private ISdkResolverService get_SdkResolverService();
    private sealed virtual override ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.get_LoggingService();
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildComponentHost.get_Name();
    private sealed virtual override BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.get_BuildParameters();
    private sealed virtual override LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.get_LegacyThreadingData();
    public void BeginBuild(BuildParameters parameters, IEnumerable`1<DeferredBuildMessage> deferredBuildMessages);
    private void UpdatePriority(Process p, ProcessPriorityClass priority);
    public void BeginBuild(BuildParameters parameters);
    private void EnableDetouredNodeLauncher();
    private static void AttachDebugger();
    public void CancelAllSubmissions();
    private void CancelAllSubmissions(bool async);
    public void ResetCaches();
    public ProjectInstance GetProjectInstanceForBuild(Project project);
    public BuildSubmission PendBuildRequest(BuildRequestData requestData);
    public GraphBuildSubmission PendBuildRequest(GraphBuildRequestData requestData);
    public BuildResult BuildRequest(BuildRequestData requestData);
    public GraphBuildResult BuildRequest(GraphBuildRequestData requestData);
    public void EndBuild();
    public BuildResult Build(BuildParameters parameters, BuildRequestData requestData);
    public GraphBuildResult Build(BuildParameters parameters, GraphBuildRequestData requestData);
    public void ShutdownAllNodes();
    public sealed virtual void Dispose();
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(BuildComponentType componentType, BuildComponentFactoryDelegate factory);
    private sealed virtual override IBuildComponent Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(BuildComponentType type);
    internal void ExecuteSubmission(BuildSubmission submission, bool allowMainThreadBuild);
    private void IssueCacheRequestForBuildSubmission(CacheRequest cacheRequest);
    internal void ExecuteSubmission(GraphBuildSubmission submission);
    private void LoadSolutionIntoConfiguration(BuildRequestConfiguration config, BuildRequest request);
    private static int GetNextBuildId();
    private BuildRequestConfiguration CreateConfiguration(Project project, BuildRequestConfiguration existingConfiguration);
    private void ProcessWorkQueue(Action action);
    private void ProcessPacket(int node, INodePacket packet);
    private void CompleteSubmissionWithException(BuildSubmission submission, BuildRequestConfiguration configuration, Exception exception);
    private void HandleSubmissionException(BuildSubmission submission, Exception ex);
    private void WaitForAllLoggingServiceEventsToBeProcessed();
    private void HandleSubmissionException(GraphBuildSubmission submission, Exception ex);
    private static void AddBuildRequestToSubmission(BuildSubmission submission, int configurationId, int projectContextId);
    private static void AddProxyBuildRequestToSubmission(BuildSubmission submission, int configurationId, ProxyTargets proxyTargets, int projectContextId);
    private void IssueBuildRequestForBuildSubmission(BuildSubmission submission, BuildRequestConfiguration configuration, bool allowMainThreadBuild);
    private bool IsInvalidProjectOrIORelatedException(Exception e);
    private void ExecuteGraphBuildScheduler(GraphBuildSubmission submission);
    private Dictionary`2<ProjectGraphNode, BuildResult> BuildGraph(ProjectGraph projectGraph, IReadOnlyDictionary`2<ProjectGraphNode, ImmutableList`1<string>> targetsPerNode, GraphBuildRequestData graphBuildRequestData);
    private void ShutdownConnectedNodes(bool abort);
    private int GetNextSubmissionId();
    private void ErrorIfState(BuildManagerState disallowedState, string exceptionResouorce);
    private void RequireState(BuildManagerState requiredState, string exceptionResouorce);
    private void VerifyStateInternal(BuildManagerState requiredState);
    private void Reset();
    private int GetNewConfigurationId();
    private BuildRequestConfiguration ResolveConfiguration(BuildRequestConfiguration unresolvedConfiguration, BuildRequestConfiguration matchingConfigurationFromCache, bool replaceProjectInstance);
    private void ReplaceExistingProjectInstance(BuildRequestConfiguration newConfiguration, BuildRequestConfiguration existingConfiguration);
    private BuildRequestConfiguration AddNewConfiguration(BuildRequestConfiguration unresolvedConfiguration);
    internal void PostCacheResult(CacheRequest cacheRequest, CacheResult cacheResult, int projectContextId);
    private void HandleNewRequest(int node, BuildRequestBlocker blocker);
    private void HandleResourceRequest(int node, ResourceRequest request);
    private void HandleConfigurationRequest(int node, BuildRequestConfiguration unresolvedConfiguration);
    private void HandleResult(int node, BuildResult result);
    private void HandleNodeShutdown(int node, NodeShutdown shutdownPacket);
    private void HandleFileAccessReport(int nodeId, FileAccessReport fileAccessReport);
    private void HandleProcessReport(int nodeId, ProcessReport processReport);
    private void CheckForActiveNodesAndCleanUpSubmissions();
    private void PerformSchedulingActions(IEnumerable`1<ScheduleResponse> responses);
    private void ReportResultsToSubmission(BuildResult result);
    private void ReportResultsToSubmission(GraphBuildResult result);
    private void CheckSubmissionCompletenessAndRemove(BuildSubmission submission);
    private void CheckSubmissionCompletenessAndRemove(GraphBuildSubmission submission);
    private void CheckAllSubmissionsComplete(Nullable`1<BuildRequestDataFlags> flags);
    private NodeConfiguration GetNodeConfiguration();
    private void OnThreadException(Exception e);
    private void OnLoggingThreadException(Exception e);
    private void OnProjectFinished(object sender, ProjectFinishedEventArgs e);
    private void OnProjectStarted(object sender, ProjectStartedEventArgs e);
    private ILoggingService CreateLoggingService(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> forwardingLoggers, ISet`1<string> warningsAsErrors, ISet`1<string> warningsNotAsErrors, ISet`1<string> warningsAsMessages);
    private static void LogDeferredMessages(ILoggingService loggingService, IEnumerable`1<DeferredBuildMessage> deferredBuildMessages);
    private static I ExpectPacketType(INodePacket packet, NodePacketType expectedType);
    private void ShutdownLoggingService(ILoggingService loggingService);
    private void Dispose(bool disposing);
    private bool ReuseOldCaches(String[] inputCacheFiles);
    private void LogMessage(string message);
    private void LogErrorAndShutdown(string message);
    private void CancelAndMarkAsFailure();
    [CompilerGeneratedAttribute]
private void <BeginBuild>b__64_3(Action action);
    [CompilerGeneratedAttribute]
private ILoggingService <BeginBuild>g__InitializeLoggingService|64_0();
    [CompilerGeneratedAttribute]
private IEnumerable`1<ILogger> <BeginBuild>g__AppendDebuggingLoggers|64_1(IEnumerable`1<ILogger> loggers);
    [CompilerGeneratedAttribute]
private void <BeginBuild>g__InitializeCaches|64_2();
    [CompilerGeneratedAttribute]
private void <CancelAllSubmissions>g__Callback|68_0(object state);
    [CompilerGeneratedAttribute]
private void <EndBuild>g__SerializeCaches|75_0();
    [CompilerGeneratedAttribute]
private void <HandleSubmissionException>g__LogInvalidProjectFileError|94_0(InvalidProjectFileException projectException, <>c__DisplayClass94_0& );
    [CompilerGeneratedAttribute]
internal static void <ExecuteGraphBuildScheduler>g__DumpGraph|99_1(ProjectGraph graph, IReadOnlyDictionary`2<ProjectGraphNode, ImmutableList`1<string>> targetList);
    [CompilerGeneratedAttribute]
private int <ReuseOldCaches>b__136_2();
}
public class Microsoft.Build.Execution.BuildParameters : object {
    private static int DefaultThreadStackSize;
    private static int DefaultEndpointShutdownTimeout;
    private static int DefaultEngineShutdownTimeout;
    private static int DefaultLoggingThreadShutdownTimeout;
    private static int DefaultRequestBuilderShutdownTimeout;
    private static int DefaultIdleRequestBuilderLimit;
    private static string s_startupDirectory;
    private static Nullable`1<bool> s_warnOnUninitializedProperty;
    private static Nullable`1<bool> s_dumpStringInterningStats;
    private static Nullable`1<bool> s_debugExpansion;
    private static Nullable`1<bool> s_keepDuplicateOutputs;
    private static Nullable`1<bool> s_enableBuildPlan;
    private static Nullable`1<int> s_idleRequestBuilderLimit;
    private static string s_msbuildExeKnownToExistAt;
    private int _buildId;
    private CultureInfo _culture;
    private string _defaultToolsVersion;
    private bool _enableNodeReuse;
    private Dictionary`2<string, string> _buildProcessEnvironment;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentProperties;
    private IEnumerable`1<ForwardingLoggerRecord> _forwardingLoggers;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private IEnumerable`1<ILogger> _loggers;
    private int _maxNodeCount;
    private int _memoryUseLimit;
    private string _nodeExeLocation;
    private bool _onlyLogCriticalEvents;
    private CultureInfo _uiCulture;
    private ToolsetProvider _toolsetProvider;
    private bool _useSynchronousLogging;
    private bool _shutdownInProcNodeOnBuildFinish;
    private bool _disableInProcNode;
    private bool _logTaskInputs;
    private bool _logInitialPropertiesAndItems;
    private bool _question;
    private ProjectLoadSettings _projectLoadSettings;
    private bool _interactive;
    private ProjectIsolationMode _projectIsolationMode;
    private String[] _inputResultsCacheFiles;
    private string _outputResultsCacheFile;
    private bool _reportFileAccesses;
    [CompilerGeneratedAttribute]
private ThreadPriority <BuildThreadPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowFailureWithoutError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetailedSummary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResetCaches>k__BackingField;
    [CompilerGeneratedAttribute]
private HostServices <HostServices>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyThreadingSemantics>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsNotAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <WarningsAsMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private ToolsetDefinitionLocations <ToolsetDefinitionLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SaveOperatingEnvironment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheBase <ProjectRootElementCache>k__BackingField;
    [CompilerGeneratedAttribute]
private AppDomainSetup <AppDomainSetup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutOfProc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardBuildResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LowPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCacheDescriptor <ProjectCacheDescriptor>k__BackingField;
    public ThreadPriority BuildThreadPriority { get; public set; }
    public bool UseSynchronousLogging { get; public set; }
    public bool AllowFailureWithoutError { get; public set; }
    public IDictionary`2<string, string> BuildProcessEnvironment { get; }
    public CultureInfo Culture { get; public set; }
    public string DefaultToolsVersion { get; public set; }
    public bool DetailedSummary { get; public set; }
    public bool DisableInProcNode { get; public set; }
    public bool LogTaskInputs { get; public set; }
    public bool LogInitialPropertiesAndItems { get; public set; }
    public bool ResetCaches { get; public set; }
    public bool EnableNodeReuse { get; public set; }
    public IDictionary`2<string, string> EnvironmentProperties { get; }
    public IEnumerable`1<ForwardingLoggerRecord> ForwardingLoggers { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public HostServices HostServices { get; public set; }
    public bool LegacyThreadingSemantics { get; public set; }
    public IEnumerable`1<ILogger> Loggers { get; public set; }
    public int MaxNodeCount { get; public set; }
    public int MemoryUseLimit { get; public set; }
    public string NodeExeLocation { get; public set; }
    public bool OnlyLogCriticalEvents { get; public set; }
    public ISet`1<string> WarningsAsErrors { get; public set; }
    public ISet`1<string> WarningsNotAsErrors { get; public set; }
    public ISet`1<string> WarningsAsMessages { get; public set; }
    public ToolsetDefinitionLocations ToolsetDefinitionLocations { get; public set; }
    public ICollection`1<Toolset> Toolsets { get; }
    public CultureInfo UICulture { get; public set; }
    public bool SaveOperatingEnvironment { get; public set; }
    public bool ShutdownInProcNodeOnBuildFinish { get; public set; }
    internal static int ThreadStackSize { get; }
    internal static int EndpointShutdownTimeout { get; }
    internal static int EngineShutdownTimeout { get; }
    internal static int IdleRequestBuilderLimit { get; }
    internal static int LoggingThreadShutdownTimeout { get; }
    internal static int RequestBuilderShutdownTimeout { get; }
    internal static string StartupDirectory { get; internal set; }
    internal static bool EnableBuildPlan { get; }
    internal static bool WarnOnUninitializedProperty { get; internal set; }
    internal static bool DumpOpportunisticInternStats { get; }
    internal static bool DebugExpansion { get; }
    internal static bool KeepDuplicateOutputs { get; }
    internal int BuildId { get; internal set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> EnvironmentPropertiesInternal { get; internal set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesInternal { get; }
    internal int NodeId { get; internal set; }
    internal IToolsetProvider ToolsetProvider { get; }
    internal ProjectRootElementCacheBase ProjectRootElementCache { get; internal set; }
    internal AppDomainSetup AppDomainSetup { get; internal set; }
    internal bool IsOutOfProc { get; internal set; }
    public ProjectLoadSettings ProjectLoadSettings { get; public set; }
    public bool Interactive { get; public set; }
    public bool IsolateProjects { get; public set; }
    public ProjectIsolationMode ProjectIsolationMode { get; public set; }
    public String[] InputResultsCacheFiles { get; public set; }
    public string OutputResultsCacheFile { get; public set; }
    public bool ReportFileAccesses { get; public set; }
    public bool DiscardBuildResults { get; public set; }
    public bool LowPriority { get; public set; }
    public bool Question { get; public set; }
    public ProjectCacheDescriptor ProjectCacheDescriptor { get; public set; }
    public BuildParameters(ProjectCollection projectCollection);
    private BuildParameters(ITranslator translator);
    internal BuildParameters(BuildParameters other, bool resetEnvironment);
    private static BuildParameters();
    [CompilerGeneratedAttribute]
public ThreadPriority get_BuildThreadPriority();
    [CompilerGeneratedAttribute]
public void set_BuildThreadPriority(ThreadPriority value);
    public bool get_UseSynchronousLogging();
    public void set_UseSynchronousLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowFailureWithoutError();
    [CompilerGeneratedAttribute]
public void set_AllowFailureWithoutError(bool value);
    public IDictionary`2<string, string> get_BuildProcessEnvironment();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public string get_DefaultToolsVersion();
    public void set_DefaultToolsVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_DetailedSummary();
    [CompilerGeneratedAttribute]
public void set_DetailedSummary(bool value);
    public bool get_DisableInProcNode();
    public void set_DisableInProcNode(bool value);
    public bool get_LogTaskInputs();
    public void set_LogTaskInputs(bool value);
    public bool get_LogInitialPropertiesAndItems();
    public void set_LogInitialPropertiesAndItems(bool value);
    [CompilerGeneratedAttribute]
public bool get_ResetCaches();
    [CompilerGeneratedAttribute]
public void set_ResetCaches(bool value);
    public bool get_EnableNodeReuse();
    public void set_EnableNodeReuse(bool value);
    public IDictionary`2<string, string> get_EnvironmentProperties();
    public IEnumerable`1<ForwardingLoggerRecord> get_ForwardingLoggers();
    public void set_ForwardingLoggers(IEnumerable`1<ForwardingLoggerRecord> value);
    public IDictionary`2<string, string> get_GlobalProperties();
    public void set_GlobalProperties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HostServices get_HostServices();
    [CompilerGeneratedAttribute]
public void set_HostServices(HostServices value);
    [CompilerGeneratedAttribute]
public bool get_LegacyThreadingSemantics();
    [CompilerGeneratedAttribute]
public void set_LegacyThreadingSemantics(bool value);
    public IEnumerable`1<ILogger> get_Loggers();
    public void set_Loggers(IEnumerable`1<ILogger> value);
    public int get_MaxNodeCount();
    public void set_MaxNodeCount(int value);
    public int get_MemoryUseLimit();
    public void set_MemoryUseLimit(int value);
    public string get_NodeExeLocation();
    public void set_NodeExeLocation(string value);
    public bool get_OnlyLogCriticalEvents();
    public void set_OnlyLogCriticalEvents(bool value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsNotAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsNotAsErrors(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_WarningsAsMessages();
    [CompilerGeneratedAttribute]
public void set_WarningsAsMessages(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public ToolsetDefinitionLocations get_ToolsetDefinitionLocations();
    [CompilerGeneratedAttribute]
public void set_ToolsetDefinitionLocations(ToolsetDefinitionLocations value);
    public ICollection`1<Toolset> get_Toolsets();
    public CultureInfo get_UICulture();
    public void set_UICulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public bool get_SaveOperatingEnvironment();
    [CompilerGeneratedAttribute]
public void set_SaveOperatingEnvironment(bool value);
    public bool get_ShutdownInProcNodeOnBuildFinish();
    public void set_ShutdownInProcNodeOnBuildFinish(bool value);
    internal static int get_ThreadStackSize();
    internal static int get_EndpointShutdownTimeout();
    internal static int get_EngineShutdownTimeout();
    internal static int get_IdleRequestBuilderLimit();
    internal static int get_LoggingThreadShutdownTimeout();
    internal static int get_RequestBuilderShutdownTimeout();
    internal static string get_StartupDirectory();
    internal static void set_StartupDirectory(string value);
    internal static bool get_EnableBuildPlan();
    internal static bool get_WarnOnUninitializedProperty();
    internal static void set_WarnOnUninitializedProperty(bool value);
    internal static bool get_DumpOpportunisticInternStats();
    internal static bool get_DebugExpansion();
    internal static bool get_KeepDuplicateOutputs();
    internal int get_BuildId();
    internal void set_BuildId(int value);
    internal PropertyDictionary`1<ProjectPropertyInstance> get_EnvironmentPropertiesInternal();
    internal void set_EnvironmentPropertiesInternal(PropertyDictionary`1<ProjectPropertyInstance> value);
    internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesInternal();
    [CompilerGeneratedAttribute]
internal int get_NodeId();
    [CompilerGeneratedAttribute]
internal void set_NodeId(int value);
    internal IToolsetProvider get_ToolsetProvider();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCacheBase get_ProjectRootElementCache();
    [CompilerGeneratedAttribute]
internal void set_ProjectRootElementCache(ProjectRootElementCacheBase value);
    [CompilerGeneratedAttribute]
internal AppDomainSetup get_AppDomainSetup();
    [CompilerGeneratedAttribute]
internal void set_AppDomainSetup(AppDomainSetup value);
    [CompilerGeneratedAttribute]
internal bool get_IsOutOfProc();
    [CompilerGeneratedAttribute]
internal void set_IsOutOfProc(bool value);
    public ProjectLoadSettings get_ProjectLoadSettings();
    public void set_ProjectLoadSettings(ProjectLoadSettings value);
    public bool get_Interactive();
    public void set_Interactive(bool value);
    public bool get_IsolateProjects();
    public void set_IsolateProjects(bool value);
    public ProjectIsolationMode get_ProjectIsolationMode();
    public void set_ProjectIsolationMode(ProjectIsolationMode value);
    public String[] get_InputResultsCacheFiles();
    public void set_InputResultsCacheFiles(String[] value);
    public string get_OutputResultsCacheFile();
    public void set_OutputResultsCacheFile(string value);
    public bool get_ReportFileAccesses();
    public void set_ReportFileAccesses(bool value);
    [CompilerGeneratedAttribute]
public bool get_DiscardBuildResults();
    [CompilerGeneratedAttribute]
public void set_DiscardBuildResults(bool value);
    [CompilerGeneratedAttribute]
public bool get_LowPriority();
    [CompilerGeneratedAttribute]
public void set_LowPriority(bool value);
    public bool get_Question();
    public void set_Question(bool value);
    [CompilerGeneratedAttribute]
public ProjectCacheDescriptor get_ProjectCacheDescriptor();
    [CompilerGeneratedAttribute]
public void set_ProjectCacheDescriptor(ProjectCacheDescriptor value);
    public Toolset GetToolset(string toolsVersion);
    public BuildParameters Clone();
    internal bool UsesCachedResults();
    internal bool UsesOutputCache();
    internal bool UsesInputCaches();
    internal bool SkippedResultsDoNotCauseCacheMiss();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static BuildParameters FactoryForDeserialization(ITranslator translator);
    private static bool GetStaticBoolVariableOrDefault(string environmentVariable, Nullable`1& backing, bool default);
    private static int GetStaticIntVariableOrDefault(string environmentVariable, Nullable`1& backingValue, int defaultValue);
    private void Initialize(PropertyDictionary`1<ProjectPropertyInstance> environmentProperties, ProjectRootElementCacheBase projectRootElementCache, ToolsetProvider toolsetProvider);
    private void EnsureToolsets();
    private string FindMSBuildExe();
    private static bool CheckMSBuildExeExistsAt(string path);
}
public class Microsoft.Build.Execution.BuildRequestData : object {
    [CompilerGeneratedAttribute]
private ProjectInstance <ProjectInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <TargetNames>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestDataFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExplicitlySpecifiedToolsVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private HostServices <HostServices>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <PropertiesToTransfer>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestedProjectState <RequestedProjectState>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyDictionary`1<ProjectPropertyInstance> <GlobalPropertiesDictionary>k__BackingField;
    public ProjectInstance ProjectInstance { get; }
    public string ProjectFullPath { get; internal set; }
    public ICollection`1<string> TargetNames { get; }
    public BuildRequestDataFlags Flags { get; }
    public ICollection`1<ProjectPropertyInstance> GlobalProperties { get; }
    public string ExplicitlySpecifiedToolsVersion { get; }
    public HostServices HostServices { get; }
    public IEnumerable`1<string> PropertiesToTransfer { get; }
    public RequestedProjectState RequestedProjectState { get; }
    internal bool ExplicitToolsVersionSpecified { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable`1<string> propertiesToTransfer);
    public BuildRequestData(ProjectInstance projectInstance, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, IEnumerable`1<string> propertiesToTransfer, RequestedProjectState requestedProjectState);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, RequestedProjectState requestedProjectState);
    public BuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, string toolsVersion, String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    private BuildRequestData(String[] targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    [CompilerGeneratedAttribute]
public ProjectInstance get_ProjectInstance();
    [CompilerGeneratedAttribute]
public string get_ProjectFullPath();
    [CompilerGeneratedAttribute]
internal void set_ProjectFullPath(string value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_TargetNames();
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_Flags();
    public ICollection`1<ProjectPropertyInstance> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public string get_ExplicitlySpecifiedToolsVersion();
    [CompilerGeneratedAttribute]
public HostServices get_HostServices();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_PropertiesToTransfer();
    [CompilerGeneratedAttribute]
public RequestedProjectState get_RequestedProjectState();
    internal bool get_ExplicitToolsVersionSpecified();
    [CompilerGeneratedAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
}
[FlagsAttribute]
public enum Microsoft.Build.Execution.BuildRequestDataFlags : Enum {
    public int value__;
    public static BuildRequestDataFlags None;
    public static BuildRequestDataFlags ReplaceExistingProjectInstance;
    public static BuildRequestDataFlags ProvideProjectStateAfterBuild;
    public static BuildRequestDataFlags IgnoreExistingProjectState;
    public static BuildRequestDataFlags ClearCachesAfterBuild;
    public static BuildRequestDataFlags SkipNonexistentTargets;
    public static BuildRequestDataFlags ProvideSubsetOfStateAfterBuild;
    public static BuildRequestDataFlags IgnoreMissingEmptyAndInvalidImports;
    public static BuildRequestDataFlags FailOnUnresolvedSdk;
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Execution.BuildResult : object {
    private int _submissionId;
    private int _configurationId;
    private int _globalRequestId;
    private int _parentGlobalRequestId;
    private int _nodeRequestId;
    private List`1<string> _initialTargets;
    private List`1<string> _defaultTargets;
    private ConcurrentDictionary`2<string, TargetResult> _resultsByTarget;
    private bool _circularDependency;
    private Exception _requestException;
    private bool _baseOverallResult;
    private Dictionary`2<string, string> _savedEnvironmentVariables;
    private string _savedCurrentDirectory;
    private ProjectInstance _projectStateAfterBuild;
    private string _schedulerInducedError;
    private HashSet`1<string> _projectTargets;
    public int SubmissionId { get; }
    public int ConfigurationId { get; }
    public int GlobalRequestId { get; }
    public int ParentGlobalRequestId { get; }
    public int NodeRequestId { get; }
    public Exception Exception { get; internal set; }
    public bool CircularDependency { get; }
    public BuildResultCode OverallResult { get; }
    public IDictionary`2<string, TargetResult> ResultsByTarget { get; }
    public ProjectInstance ProjectStateAfterBuild { get; public set; }
    private NodePacketType Microsoft.Build.BackEnd.INodePacket.Type { get; }
    private Dictionary`2<string, string> Microsoft.Build.BackEnd.IBuildResults.SavedEnvironmentVariables { get; private set; }
    private string Microsoft.Build.BackEnd.IBuildResults.SavedCurrentDirectory { get; private set; }
    internal List`1<string> InitialTargets { get; internal set; }
    internal List`1<string> DefaultTargets { get; internal set; }
    internal HashSet`1<string> ProjectTargets { get; internal set; }
    internal string SchedulerInducedError { get; internal set; }
    public ITargetResult Item { get; }
    internal BuildResult(BuildRequest request);
    internal BuildResult(BuildRequest request, Exception exception);
    internal BuildResult(BuildRequest request, bool circularDependency);
    internal BuildResult(BuildResult existingResults, String[] targetNames);
    internal BuildResult(BuildRequest request, BuildResult existingResults, Exception exception);
    internal BuildResult(BuildRequest request, BuildResult existingResults, String[] targetNames, Exception exception);
    internal BuildResult(BuildResult result, int nodeRequestId);
    internal BuildResult(BuildResult result, int submissionId, int configurationId, int requestId, int parentRequestId, int nodeRequestId);
    private BuildResult(ITranslator translator);
    [DebuggerStepThroughAttribute]
public int get_SubmissionId();
    [DebuggerStepThroughAttribute]
public int get_ConfigurationId();
    [DebuggerStepThroughAttribute]
public int get_GlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_ParentGlobalRequestId();
    [DebuggerStepThroughAttribute]
public int get_NodeRequestId();
    [DebuggerStepThroughAttribute]
public sealed virtual Exception get_Exception();
    [DebuggerStepThroughAttribute]
internal void set_Exception(Exception value);
    [DebuggerStepThroughAttribute]
public bool get_CircularDependency();
    public sealed virtual BuildResultCode get_OverallResult();
    [DebuggerStepThroughAttribute]
public sealed virtual IDictionary`2<string, TargetResult> get_ResultsByTarget();
    public ProjectInstance get_ProjectStateAfterBuild();
    public void set_ProjectStateAfterBuild(ProjectInstance value);
    [DebuggerStepThroughAttribute]
private sealed virtual override NodePacketType Microsoft.Build.BackEnd.INodePacket.get_Type();
    private sealed virtual override Dictionary`2<string, string> Microsoft.Build.BackEnd.IBuildResults.get_SavedEnvironmentVariables();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildResults.set_SavedEnvironmentVariables(Dictionary`2<string, string> value);
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildResults.get_SavedCurrentDirectory();
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildResults.set_SavedCurrentDirectory(string value);
    [DebuggerStepThroughAttribute]
internal List`1<string> get_InitialTargets();
    [DebuggerStepThroughAttribute]
internal void set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal List`1<string> get_DefaultTargets();
    [DebuggerStepThroughAttribute]
internal void set_DefaultTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
internal HashSet`1<string> get_ProjectTargets();
    [DebuggerStepThroughAttribute]
internal void set_ProjectTargets(HashSet`1<string> value);
    internal string get_SchedulerInducedError();
    internal void set_SchedulerInducedError(string value);
    [DebuggerStepThroughAttribute]
public sealed virtual ITargetResult get_Item(string target);
    public void AddResultsForTarget(string target, TargetResult result);
    internal void KeepSpecificTargetResults(IReadOnlyCollection`1<string> targetsToKeep);
    public void MergeResults(BuildResult results);
    public sealed virtual bool HasResultsForTarget(string target);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static BuildResult FactoryForDeserialization(ITranslator translator);
    internal void CacheIfPossible();
    internal void ClearCachedFiles();
    internal BuildResult Clone();
    internal void SetOverallResult(bool overallResult);
    private static ConcurrentDictionary`2<string, TargetResult> CreateTargetResultDictionary(int capacity);
    private static ConcurrentDictionary`2<string, TargetResult> CreateTargetResultDictionaryWithContents(BuildResult existingResults, String[] targetNames);
}
public enum Microsoft.Build.Execution.BuildResultCode : Enum {
    public int value__;
    public static BuildResultCode Success;
    public static BuildResultCode Failure;
}
public class Microsoft.Build.Execution.BuildSubmission : object {
    private BuildSubmissionCompleteCallback _completionCallback;
    private ManualResetEvent _completionEvent;
    [CompilerGeneratedAttribute]
private bool <LoggingCompleted>k__BackingField;
    private int _completionInvoked;
    private bool _legacyThreadingSemantics;
    [CompilerGeneratedAttribute]
private BuildManager <BuildManager>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubmissionId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AsyncContext>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <BuildResult>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestData <BuildRequestData>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequest <BuildRequest>k__BackingField;
    internal bool LoggingCompleted { get; private set; }
    public BuildManager BuildManager { get; }
    public int SubmissionId { get; }
    public object AsyncContext { get; private set; }
    public WaitHandle WaitHandle { get; }
    public bool IsCompleted { get; }
    public BuildResult BuildResult { get; public set; }
    internal BuildRequestData BuildRequestData { get; }
    internal BuildRequest BuildRequest { get; internal set; }
    internal BuildSubmission(BuildManager buildManager, int submissionId, BuildRequestData requestData, bool legacyThreadingSemantics);
    [CompilerGeneratedAttribute]
internal bool get_LoggingCompleted();
    [CompilerGeneratedAttribute]
private void set_LoggingCompleted(bool value);
    [CompilerGeneratedAttribute]
public BuildManager get_BuildManager();
    [CompilerGeneratedAttribute]
public int get_SubmissionId();
    [CompilerGeneratedAttribute]
public object get_AsyncContext();
    [CompilerGeneratedAttribute]
private void set_AsyncContext(object value);
    public WaitHandle get_WaitHandle();
    public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
public BuildResult get_BuildResult();
    [CompilerGeneratedAttribute]
public void set_BuildResult(BuildResult value);
    [CompilerGeneratedAttribute]
internal BuildRequestData get_BuildRequestData();
    [CompilerGeneratedAttribute]
internal BuildRequest get_BuildRequest();
    [CompilerGeneratedAttribute]
internal void set_BuildRequest(BuildRequest value);
    public BuildResult Execute();
    public void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context);
    internal void CompleteResults(BuildResult result);
    internal void CompleteLogging();
    private void ExecuteAsync(BuildSubmissionCompleteCallback callback, object context, bool allowMainThreadBuild);
    private void CheckForCompletion();
    [CompilerGeneratedAttribute]
private void <CheckForCompletion>g__Callback|39_0(object state);
}
public class Microsoft.Build.Execution.BuildSubmissionCompleteCallback : MulticastDelegate {
    public BuildSubmissionCompleteCallback(object object, IntPtr method);
    public virtual void Invoke(BuildSubmission submission);
    public virtual IAsyncResult BeginInvoke(BuildSubmission submission, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Execution.CacheAggregation : object {
    [CompilerGeneratedAttribute]
private IConfigCache <ConfigCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IResultsCache <ResultsCache>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastConfigurationId>k__BackingField;
    public IConfigCache ConfigCache { get; }
    public IResultsCache ResultsCache { get; }
    public int LastConfigurationId { get; }
    public CacheAggregation(IConfigCache configCache, IResultsCache resultsCache, int lastConfigurationId);
    [CompilerGeneratedAttribute]
public IConfigCache get_ConfigCache();
    [CompilerGeneratedAttribute]
public IResultsCache get_ResultsCache();
    [CompilerGeneratedAttribute]
public int get_LastConfigurationId();
}
internal class Microsoft.Build.Execution.CacheAggregator : object {
    private Func`1<int> _nextConfigurationId;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<IConfigCache, IResultsCache>> _inputCaches;
    private int _lastConfigurationId;
    private bool _aggregated;
    private ConfigCache _aggregatedConfigCache;
    private ResultsCache _aggregatedResultsCache;
    public CacheAggregator(Func`1<int> nextConfigurationId);
    public void Add(IConfigCache configCache, IResultsCache resultsCache);
    public CacheAggregation Aggregate();
    private void InsertCaches(IConfigCache configCache, IResultsCache resultsCache);
}
internal static class Microsoft.Build.Execution.CacheSerialization : object {
    public static string SerializeCaches(IConfigCache configCache, IResultsCache resultsCache, string outputCacheFile, ProjectIsolationMode projectIsolationMode);
    public static ValueTuple`3<IConfigCache, IResultsCache, Exception> DeserializeCaches(string inputCacheFile);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Execution.ConfigCacheWithOverride : object {
    private IConfigCache _override;
    [CompilerGeneratedAttribute]
private ConfigCache <CurrentCache>k__BackingField;
    public ConfigCache CurrentCache { get; }
    public BuildRequestConfiguration Item { get; }
    public ConfigCacheWithOverride(IConfigCache override);
    [CompilerGeneratedAttribute]
public ConfigCache get_CurrentCache();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual IEnumerator`1<BuildRequestConfiguration> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Translate(ITranslator translator);
    public sealed virtual BuildRequestConfiguration get_Item(int configId);
    public sealed virtual void AddConfiguration(BuildRequestConfiguration config);
    public sealed virtual void RemoveConfiguration(int configId);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(BuildRequestConfiguration config);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata);
    public sealed virtual BuildRequestConfiguration GetMatchingConfiguration(ConfigurationMetadata configMetadata, ConfigCreateCallback callback, bool loadProject);
    public sealed virtual bool HasConfiguration(int configId);
    public bool HasConfigurationInOverrideCache(int configId);
    public sealed virtual void ClearConfigurations();
    public sealed virtual List`1<int> ClearNonExplicitlyLoadedConfigurations();
    public sealed virtual bool IsConfigCacheSizeLargerThanThreshold();
    public sealed virtual bool WriteConfigurationsToDisk();
}
internal class Microsoft.Build.Execution.HostObjectException : BuildExceptionBase {
    private static string ErrorMessagePrefix;
    private static string ErrorMessageProjectTargetTask;
    internal HostObjectException(string message);
    internal HostObjectException(string projectFile, string targetName, string taskName, Exception innerException);
    internal HostObjectException(string projectFile, string targetName, string taskName, string message);
    internal HostObjectException(string message, Exception innerException);
}
[DebuggerDisplayAttribute("#Entries={_hostObjectMap.Count}")]
public class Microsoft.Build.Execution.HostServices : object {
    private Dictionary`2<string, HostObjects> _hostObjectMap;
    private Dictionary`2<string, NodeAffinity> _projectAffinities;
    private Lazy`1<IRunningObjectTableWrapper> _runningObjectTable;
    public ITaskHost GetHostObject(string projectFile, string targetName, string taskName);
    public void RegisterHostObject(string projectFile, string targetName, string taskName, ITaskHost hostObject);
    [SupportedOSPlatform("windows")]
public void RegisterHostObject(string projectFile, string targetName, string taskName, string monikerName);
    public void UnregisterProject(string projectFullPath);
    public NodeAffinity GetNodeAffinity(string projectFile);
    public void SetNodeAffinity(string projectFile, NodeAffinity nodeAffinity);
    public void OnRenameProject(string oldFullPath, string newFullPath);
    internal bool HasInProcessHostObject(string projectFile);
    private NodeAffinity GetNodeAffinity(string projectFile, Boolean& isExplicit);
    private HostObjects GetHostObjectsFromMapByKeyOrCreateNew(string projectFile);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    [SupportedOSPlatform("windows")]
internal void SetTestRunningObjectTable(IRunningObjectTableWrapper runningObjectTable);
}
internal interface Microsoft.Build.Execution.IRunningObjectTableWrapper {
    public abstract virtual object GetObject(string itemName);
}
public interface Microsoft.Build.Execution.ITargetResult {
    public Exception Exception { get; }
    public ITaskItem[] Items { get; }
    public TargetResultCode ResultCode { get; }
    public abstract virtual Exception get_Exception();
    public abstract virtual ITaskItem[] get_Items();
    public abstract virtual TargetResultCode get_ResultCode();
}
internal class Microsoft.Build.Execution.LegacyThreadingData : object {
    private IDictionary`2<int, Tuple`2<AutoResetEvent, ManualResetEvent>> _legacyThreadingEventsById;
    private int _mainThreadSubmissionId;
    private RequestBuilder _instanceForMainThread;
    private object _legacyThreadingEventsLock;
    internal RequestBuilder InstanceForMainThread { get; internal set; }
    internal int MainThreadSubmissionId { get; internal set; }
    internal RequestBuilder get_InstanceForMainThread();
    internal void set_InstanceForMainThread(RequestBuilder value);
    internal int get_MainThreadSubmissionId();
    internal void set_MainThreadSubmissionId(int value);
    internal void RegisterSubmissionForLegacyThread(int submissionId);
    internal void UnregisterSubmissionForLegacyThread(int submissionId);
    internal WaitHandle GetStartRequestBuilderMainThreadEventForSubmission(int submissionId);
    internal Task GetLegacyThreadInactiveTask(int submissionId);
    internal void SignalLegacyThreadStart(RequestBuilder instance);
    internal void SignalLegacyThreadEnd(int submissionId);
}
public enum Microsoft.Build.Execution.NodeAffinity : Enum {
    public int value__;
    public static NodeAffinity InProc;
    public static NodeAffinity OutOfProc;
    public static NodeAffinity Any;
}
public enum Microsoft.Build.Execution.NodeEngineShutdownReason : Enum {
    public int value__;
    public static NodeEngineShutdownReason BuildComplete;
    public static NodeEngineShutdownReason BuildCompleteReuse;
    public static NodeEngineShutdownReason ConnectionFailed;
    public static NodeEngineShutdownReason Error;
}
public class Microsoft.Build.Execution.OutOfProcNode : object {
    private static bool s_isOutOfProcNode;
    private static ProjectRootElementCacheBase s_projectRootElementCacheBase;
    private NodeEndpointOutOfProc _nodeEndpoint;
    private IDictionary`2<string, string> _savedEnvironment;
    private BuildComponentFactoryCollection _componentFactories;
    private BuildParameters _buildParameters;
    private ILoggingService _loggingService;
    private NodeLoggingContext _loggingContext;
    private IConfigCache _globalConfigCache;
    private INodeManager _taskHostNodeManager;
    private IBuildRequestEngine _buildRequestEngine;
    private NodePacketFactory _packetFactory;
    private NodeConfiguration _currentConfiguration;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private AutoResetEvent _packetReceivedEvent;
    private ManualResetEvent _shutdownEvent;
    private NodeEngineShutdownReason _shutdownReason;
    private Exception _shutdownException;
    private LegacyThreadingData _legacyThreadingData;
    private ISdkResolverService _sdkResolverService;
    private ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.LoggingService { get; }
    private LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.LegacyThreadingData { get; }
    private string Microsoft.Build.BackEnd.IBuildComponentHost.Name { get; }
    private BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.BuildParameters { get; }
    internal static bool IsOutOfProcNode { get; }
    private sealed virtual override ILoggingService Microsoft.Build.BackEnd.IBuildComponentHost.get_LoggingService();
    private sealed virtual override LegacyThreadingData Microsoft.Build.BackEnd.IBuildComponentHost.get_LegacyThreadingData();
    private sealed virtual override string Microsoft.Build.BackEnd.IBuildComponentHost.get_Name();
    private sealed virtual override BuildParameters Microsoft.Build.BackEnd.IBuildComponentHost.get_BuildParameters();
    internal static bool get_IsOutOfProcNode();
    public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    public NodeEngineShutdownReason Run(bool enableReuse, Exception& shutdownException);
    public NodeEngineShutdownReason Run(bool enableReuse, bool lowPriority, Exception& shutdownException);
    private sealed virtual override void Microsoft.Build.BackEnd.IBuildComponentHost.RegisterFactory(BuildComponentType factoryType, BuildComponentFactoryDelegate factory);
    private sealed virtual override IBuildComponent Microsoft.Build.BackEnd.IBuildComponentHost.GetComponent(BuildComponentType type);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RoutePacket(int nodeId, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
    private void OnRequestComplete(BuildRequest request, BuildResult result);
    private void OnNewRequest(BuildRequestBlocker blocker);
    private void OnNewConfigurationRequest(BuildRequestConfiguration config);
    private void OnResourceRequest(ResourceRequest request);
    private void OnLoggingThreadException(Exception e);
    private void OnEngineException(Exception e);
    private NodeEngineShutdownReason HandleShutdown(Exception& exception);
    private void CleanupCaches();
    private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void SendPacket(INodePacket packet);
    private void HandlePacket(INodePacket packet);
    private void HandleBuildRequest(BuildRequest request);
    private void HandleBuildRequestConfiguration(BuildRequestConfiguration configuration);
    private void HandleBuildRequestConfigurationResponse(BuildRequestConfigurationResponse response);
    private void HandleBuildRequestUnblocker(BuildRequestUnblocker unblocker);
    private void HandleResourceResponse(ResourceResponse response);
    private void HandleNodeConfiguration(NodeConfiguration configuration);
    private void HandleNodeBuildComplete(NodeBuildComplete buildComplete);
    [CompilerGeneratedAttribute]
private IBuildComponent <.ctor>b__20_0(BuildComponentType componentType);
}
[DebuggerDisplayAttribute("{FullPath} #Targets={TargetsCount} DefaultTargets={(DefaultTargets == null) ? System.String.Empty : System.String.Join(";", DefaultTargets.ToArray())} ToolsVersion={Toolset.ToolsVersion} InitialTargets={(InitialTargets == null) ? System.String.Empty : System.String.Join(";", InitialTargets.ToArray())} #GlobalProperties={GlobalProperties.Count} #Properties={Properties.Count} #ItemTypes={ItemTypes.Count} #Items={Items.Count}")]
public class Microsoft.Build.Execution.ProjectInstance : object {
    private RetrievableEntryHashSet`1<ProjectTargetInstance> _actualTargets;
    private IDictionary`2<string, ProjectTargetInstance> _targets;
    private List`1<string> _defaultTargets;
    private List`1<string> _initialTargets;
    private List`1<string> _importPaths;
    private List`1<string> _importPathsIncludingDuplicates;
    private PropertyDictionary`1<ProjectPropertyInstance> _globalProperties;
    private ISet`1<string> _globalPropertiesToTreatAsLocal;
    private bool _explicitToolsVersionSpecified;
    private PropertyDictionary`1<ProjectPropertyInstance> _properties;
    private PropertyDictionary`1<ProjectPropertyInstance> _environmentVariableProperties;
    private ItemDictionary`1<ProjectItemInstance> _items;
    private MultiDictionary`2<string, ProjectItemInstance> _itemsByEvaluatedInclude;
    private string _directory;
    private ElementLocation _projectFileLocation;
    private RetrievableEntryHashSet`1<ProjectItemDefinitionInstance> _itemDefinitions;
    private HostServices _hostServices;
    private bool _usingDifferentToolsVersionFromProjectFile;
    private string _originalProjectToolsVersion;
    private bool _isImmutable;
    private IDictionary`2<string, List`1<TargetSpecification>> _beforeTargets;
    private IDictionary`2<string, List`1<TargetSpecification>> _afterTargets;
    private Toolset _toolset;
    private string _subToolsetVersion;
    private TaskRegistry _taskRegistry;
    private bool _translateEntireState;
    private int _evaluationId;
    [CompilerGeneratedAttribute]
private List`1<ProjectItemElement> <EvaluatedItemElements>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ImportPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ImportPathsIncludingDuplicates>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheBase <ProjectRootElementCache>k__BackingField;
    public IDictionary`2<string, string> GlobalProperties { get; }
    public string ToolsVersion { get; }
    public ICollection`1<string> ItemTypes { get; }
    private bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.CanEvaluateElementsWithFalseConditions { get; }
    public ICollection`1<ProjectPropertyInstance> Properties { get; }
    public ICollection`1<ProjectItemInstance> Items { get; }
    public List`1<ProjectItemElement> EvaluatedItemElements { get; private set; }
    public bool TranslateEntireState { get; public set; }
    public int EvaluationId { get; public set; }
    public string Directory { get; }
    public string FullPath { get; }
    public IDictionary`2<string, ProjectItemDefinitionInstance> ItemDefinitions { get; }
    public IReadOnlyList`1<string> ImportPaths { get; private set; }
    public IReadOnlyList`1<string> ImportPathsIncludingDuplicates { get; private set; }
    public List`1<string> DefaultTargets { get; private set; }
    public List`1<string> InitialTargets { get; private set; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public bool IsImmutable { get; }
    private TaskRegistry Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.TaskRegistry { get; private set; }
    private Toolset Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Toolset { get; }
    private string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SubToolsetVersion { get; }
    private string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ExplicitToolsVersion { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GlobalPropertiesDictionary { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.EnvironmentVariablePropertiesDictionary { get; }
    private ISet`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GlobalPropertiesToTreatAsLocal { get; }
    private PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Properties { get; }
    private IEnumerable`1<ProjectItemDefinitionInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ItemDefinitionsEnumerable { get; }
    private ItemDictionary`1<ProjectItemInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.Items { get; }
    private List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.InitialTargets { get; private set; }
    private List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.DefaultTargets { get; private set; }
    private IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.BeforeTargets { get; private set; }
    private IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AfterTargets { get; private set; }
    private Dictionary`2<string, List`1<string>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ConditionedProperties { get; }
    private bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.ShouldEvaluateForDesignTime { get; }
    public ElementLocation ProjectFileLocation { get; }
    internal PropertyDictionary`1<ProjectPropertyInstance> GlobalPropertiesDictionary { get; }
    internal Toolset Toolset { get; private set; }
    internal bool UsingDifferentToolsVersionFromProjectFile { get; }
    internal string OriginalProjectToolsVersion { get; }
    internal string ExplicitToolsVersion { get; }
    internal bool ExplicitToolsVersionSpecified { get; }
    internal string SubToolsetVersion { get; private set; }
    internal PropertyDictionary`1<ProjectPropertyInstance> PropertiesToBuildWith { get; }
    internal ICollection`1<ProjectPropertyInstance> TestEnvironmentalProperties { get; }
    internal ItemDictionary`1<ProjectItemInstance> ItemsToBuildWith { get; }
    internal TaskRegistry TaskRegistry { get; private set; }
    internal int TargetsCount { get; }
    internal ProjectRootElementCacheBase ProjectRootElementCache { get; private set; }
    internal bool IsLoaded { get; }
    public ProjectInstance(string projectFile);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection);
    private ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, Nullable`1<ProjectLoadSettings> projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive);
    public ProjectInstance(ProjectRootElement xml);
    public ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectCollection projectCollection);
    public ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection);
    public ProjectInstance(Project project, ProjectInstanceSettings settings);
    private ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, string subToolsetVersion, ProjectCollection projectCollection, Nullable`1<ProjectLoadSettings> projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory, bool interactive);
    internal ProjectInstance(string projectFile, ProjectInstance projectToInheritFrom, IDictionary`2<string, string> globalProperties);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, int visualStudioVersionFromSolution, ProjectCollection projectCollection, ISdkResolverService sdkResolverService, int submissionId);
    internal ProjectInstance(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, Nullable`1<ProjectLoadSettings> projectLoadSettings);
    internal ProjectInstance(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId);
    internal ProjectInstance(Data data, string directory, string fullPath, HostServices hostServices, PropertyDictionary`1<ProjectPropertyInstance> environmentVariableProperties, ProjectInstanceSettings settings);
    private ProjectInstance(ITranslator translator);
    private ProjectInstance(ProjectInstance that, bool isImmutable, RequestedProjectState filter);
    public static ProjectInstance FromFile(string file, ProjectOptions options);
    public static ProjectInstance FromProjectRootElement(ProjectRootElement rootElement, ProjectOptions options);
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    public string get_ToolsVersion();
    [DebuggerStepThroughAttribute]
public ICollection`1<string> get_ItemTypes();
    private sealed virtual override bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_CanEvaluateElementsWithFalseConditions();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectPropertyInstance> get_Properties();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemInstance> get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual List`1<ProjectItemElement> get_EvaluatedItemElements();
    [CompilerGeneratedAttribute]
private void set_EvaluatedItemElements(List`1<ProjectItemElement> value);
    public bool get_TranslateEntireState();
    public void set_TranslateEntireState(bool value);
    public sealed virtual int get_EvaluationId();
    public sealed virtual void set_EvaluationId(int value);
    [DebuggerStepThroughAttribute]
public sealed virtual string get_Directory();
    [DebuggerStepThroughAttribute]
public string get_FullPath();
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectItemDefinitionInstance> get_ItemDefinitions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ImportPaths();
    [CompilerGeneratedAttribute]
private void set_ImportPaths(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ImportPathsIncludingDuplicates();
    [CompilerGeneratedAttribute]
private void set_ImportPathsIncludingDuplicates(IReadOnlyList`1<string> value);
    public List`1<string> get_DefaultTargets();
    private void set_DefaultTargets(List`1<string> value);
    public List`1<string> get_InitialTargets();
    private void set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
public IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public bool get_IsImmutable();
    [DebuggerStepThroughAttribute]
private sealed virtual override TaskRegistry Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_TaskRegistry();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_TaskRegistry(TaskRegistry value);
    [DebuggerStepThroughAttribute]
private sealed virtual override Toolset Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Toolset();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_SubToolsetVersion();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ExplicitToolsVersion();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_GlobalPropertiesDictionary();
    private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_EnvironmentVariablePropertiesDictionary();
    private sealed virtual override ISet`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_GlobalPropertiesToTreatAsLocal();
    [DebuggerStepThroughAttribute]
private sealed virtual override PropertyDictionary`1<ProjectPropertyInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Properties();
    [DebuggerStepThroughAttribute]
private sealed virtual override IEnumerable`1<ProjectItemDefinitionInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ItemDefinitionsEnumerable();
    [DebuggerStepThroughAttribute]
private sealed virtual override ItemDictionary`1<ProjectItemInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_Items();
    [DebuggerStepThroughAttribute]
private sealed virtual override List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_InitialTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_InitialTargets(List`1<string> value);
    [DebuggerStepThroughAttribute]
private sealed virtual override List`1<string> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_DefaultTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_DefaultTargets(List`1<string> value);
    private sealed virtual override IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_BeforeTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_BeforeTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    private sealed virtual override IDictionary`2<string, List`1<TargetSpecification>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_AfterTargets();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.set_AfterTargets(IDictionary`2<string, List`1<TargetSpecification>> value);
    private sealed virtual override Dictionary`2<string, List`1<string>> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ConditionedProperties();
    private sealed virtual override bool Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.get_ShouldEvaluateForDesignTime();
    public ElementLocation get_ProjectFileLocation();
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_GlobalPropertiesDictionary();
    internal Toolset get_Toolset();
    private void set_Toolset(Toolset value);
    internal bool get_UsingDifferentToolsVersionFromProjectFile();
    internal string get_OriginalProjectToolsVersion();
    internal string get_ExplicitToolsVersion();
    internal bool get_ExplicitToolsVersionSpecified();
    internal string get_SubToolsetVersion();
    private void set_SubToolsetVersion(string value);
    [DebuggerStepThroughAttribute]
internal PropertyDictionary`1<ProjectPropertyInstance> get_PropertiesToBuildWith();
    internal ICollection`1<ProjectPropertyInstance> get_TestEnvironmentalProperties();
    [DebuggerStepThroughAttribute]
internal ItemDictionary`1<ProjectItemInstance> get_ItemsToBuildWith();
    internal TaskRegistry get_TaskRegistry();
    private void set_TaskRegistry(TaskRegistry value);
    internal int get_TargetsCount();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCacheBase get_ProjectRootElementCache();
    [CompilerGeneratedAttribute]
private void set_ProjectRootElementCache(ProjectRootElementCacheBase value);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemInstance item);
    public static string GetEvaluatedItemIncludeEscaped(ProjectItemDefinitionInstance item);
    public static string GetMetadataValueEscaped(ProjectMetadataInstance metadatum);
    public static string GetMetadataValueEscaped(ProjectItemInstance item, string name);
    public static string GetMetadataValueEscaped(ProjectItemDefinitionInstance item, string name);
    public static string GetPropertyValueEscaped(ProjectPropertyInstance property);
    private sealed virtual override ICollection`1<ProjectItemInstance> Microsoft.Build.Evaluation.IItemProvider<Microsoft.Build.Execution.ProjectItemInstance>.GetItems(string itemType);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.InitializeForEvaluation(IToolsetProvider toolsetProvider, EvaluationContext evaluationContext);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.FinishEvaluation();
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItem(ProjectItemInstance item);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItemIgnoringCondition(ProjectItemInstance item);
    private sealed virtual override IItemDefinition`1<ProjectMetadataInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddItemDefinition(string itemType);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedPropertiesList(ProjectPropertyInstance property);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedItemDefinitionMetadataList(ProjectMetadataInstance itemDefinitionMetadatum);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddToAllEvaluatedItemsList(ProjectItemInstance item);
    private sealed virtual override IItemDefinition`1<ProjectMetadataInstance> Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GetItemDefinition(string itemType);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SetProperty(string name, string evaluatedValueEscaped, bool isGlobalProperty, bool mayBeReserved, bool isEnvironmentVariable, LoggingContext loggingContext);
    private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.SetProperty(ProjectPropertyElement propertyElement, string evaluatedValueEscaped);
    private sealed virtual override ProjectTargetInstance Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.GetTarget(string targetName);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.AddTarget(ProjectTargetInstance target);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.RecordImport(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated, SdkResult sdkResult);
    private sealed virtual override void Microsoft.Build.Evaluation.IEvaluatorData<Microsoft.Build.Execution.ProjectPropertyInstance,Microsoft.Build.Execution.ProjectItemInstance,Microsoft.Build.Execution.ProjectMetadataInstance,Microsoft.Build.Execution.ProjectItemDefinitionInstance>.RecordImportWithDuplicates(ProjectImportElement importElement, ProjectRootElement import, int versionEvaluated);
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectPropertyInstance GetProperty(string name);
    [DebuggerStepThroughAttribute]
private sealed virtual override ProjectPropertyInstance Microsoft.Build.Evaluation.IPropertyProvider<Microsoft.Build.Execution.ProjectPropertyInstance>.GetProperty(string name, int startIndex, int endIndex);
    public string GetPropertyValue(string name);
    public ProjectPropertyInstance SetProperty(string name, string evaluatedValue);
    public ProjectItemInstance AddItem(string itemType, string evaluatedInclude);
    public ProjectItemInstance AddItem(string itemType, string evaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public ICollection`1<ProjectItemInstance> GetItems(string itemType);
    [IteratorStateMachineAttribute("Microsoft.Build.Execution.ProjectInstance/<GetItemsByItemTypeAndEvaluatedInclude>d__192")]
public IEnumerable`1<ProjectItemInstance> GetItemsByItemTypeAndEvaluatedInclude(string itemType, string evaluatedInclude);
    public bool RemoveItem(ProjectItemInstance item);
    public bool RemoveProperty(string name);
    public ProjectInstance DeepCopy();
    public ProjectInstance FilteredCopy(RequestedProjectState filter);
    public ProjectInstance DeepCopy(bool isImmutable);
    public bool Build();
    public bool Build(IEnumerable`1<ILogger> loggers);
    public bool Build(IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers);
    public bool Build(string target, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IDictionary`2& targetOutputs);
    public bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, IDictionary`2& targetOutputs);
    public sealed virtual string ExpandString(string unexpandedValue);
    public sealed virtual bool EvaluateCondition(string condition);
    public ProjectRootElement ToProjectRootElement();
    public void UpdateStateFrom(ProjectInstance projectState);
    internal bool get_IsLoaded();
    internal void LateInitialize(ProjectRootElementCacheBase projectRootElementCache, HostServices hostServices);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    private void MaybeForceTranslateEntireStateMode();
    internal void TranslateMinimalState(ITranslator translator);
    private void TranslateAllState(ITranslator translator);
    private void TranslateToolsetSpecificState(ITranslator translator);
    private void TranslateProperties(ITranslator translator);
    private void TranslateTargets(ITranslator translator);
    private static void TranslatorForTargetSpecificDictionaryKey(ITranslator translator, String& key);
    private static void TranslatorForTargetSpecificDictionaryValue(ITranslator translator, List`1& value);
    private void TranslateItems(ITranslator translator);
    internal static ProjectInstance[] LoadSolutionForBuild(string projectFile, PropertyDictionary`1<ProjectPropertyInstance> globalPropertiesInstances, string toolsVersion, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    internal static ProjectInstance FactoryForDeserialization(ITranslator translator);
    internal static void VerifyThrowNotImmutable(bool isImmutable);
    internal bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ILoggingService loggingService, int maxNodeCount, IDictionary`2& targetOutputs);
    internal bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, ILoggingService loggingService, IDictionary`2& targetOutputs);
    internal IList`1<TargetSpecification> GetTargetsWhichRunBefore(string target);
    internal IList`1<TargetSpecification> GetTargetsWhichRunAfter(string target);
    internal void Cache(ITranslator translator);
    internal void RetrieveFromCache(ITranslator translator);
    internal ProjectTargetInstance AddTarget(string targetName, string condition, string inputs, string outputs, string returns, string keepDuplicateOutputs, string dependsOnTargets, string beforeTargets, string afterTargets, bool parentProjectSupportsReturnsAttribute);
    internal void RemoveTarget(string targetName);
    internal void VerifyThrowNotImmutable();
    private static ProjectInstance[] GenerateSolutionWrapper(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ILoggingService loggingService, BuildEventContext projectBuildEventContext, IReadOnlyCollection`1<string> targetNames, ISdkResolverService sdkResolverService, int submissionId);
    private static ProjectInstance[] GenerateSolutionWrapperUsingOldOM(string projectFile, IDictionary`2<string, string> globalProperties, string toolsVersion, ProjectRootElementCacheBase projectRootElementCache, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext projectBuildEventContext, bool isExplicitlyLoaded, ISdkResolverService sdkResolverService, int submissionId);
    private static ReadOnlyDictionary`2<string, TValue> CreateCloneDictionary(IDictionary`2<string, TValue> dictionary, StringComparer strComparer);
    private static IDictionary`2<string, TValue> CreateCloneDictionary(IDictionary`2<string, TValue> dictionary);
    private void Initialize(ProjectRootElement xml, IDictionary`2<string, string> globalProperties, string explicitToolsVersion, string explicitSubToolsetVersion, int visualStudioVersionFromSolution, BuildParameters buildParameters, ILoggingService loggingService, BuildEventContext buildEventContext, ISdkResolverService sdkResolverService, int submissionId, Nullable`1<ProjectLoadSettings> projectLoadSettings, EvaluationContext evaluationContext, IDirectoryCacheFactory directoryCacheFactory);
    private IEnumerable`1<ProjectItemInstance> GetItemsByEvaluatedInclude(string evaluatedInclude);
    private void CreateTargetsSnapshot(IDictionary`2<string, ProjectTargetInstance> targets, List`1<string> defaultTargets, List`1<string> initialTargets, IDictionary`2<string, List`1<TargetSpecification>> beforeTargets, IDictionary`2<string, List`1<TargetSpecification>> afterTargets);
    private void CreateImportsSnapshot(IList`1<ResolvedImport> importClosure, IList`1<ResolvedImport> importClosureWithDuplicates);
    private void CreateEnvironmentVariablePropertiesSnapshot(PropertyDictionary`1<ProjectPropertyInstance> environmentVariableProperties);
    private void CreateGlobalPropertiesSnapshot(PropertyDictionary`1<ProjectPropertyInstance> globalPropertiesDictionary);
    private void CreateEvaluatedIncludeSnapshotIfRequested(bool keepEvaluationCache, ICollection`1<ProjectItem> items, Dictionary`2<ProjectItem, ProjectItemInstance> projectItemToInstanceMap);
    private Dictionary`2<ProjectItem, ProjectItemInstance> CreateItemsSnapshot(ICollection`1<ProjectItem> items, int itemTypeCount, bool keepEvaluationCache);
    private void CreateItemDefinitionsSnapshot(IDictionary`2<string, ProjectItemDefinition> itemDefinitions);
    private void CreatePropertiesSnapshot(ICollection`1<ProjectProperty> properties, bool isImmutable);
}
[FlagsAttribute]
public enum Microsoft.Build.Execution.ProjectInstanceSettings : Enum {
    public int value__;
    public static ProjectInstanceSettings None;
    public static ProjectInstanceSettings Immutable;
    public static ProjectInstanceSettings ImmutableWithFastItemLookup;
}
public enum Microsoft.Build.Execution.ProjectIsolationMode : Enum {
    public int value__;
    public static ProjectIsolationMode False;
    public static ProjectIsolationMode MessageUponIsolationViolation;
    public static ProjectIsolationMode True;
}
[DebuggerDisplayAttribute("{_itemType} #Metadata={MetadataCount}")]
public class Microsoft.Build.Execution.ProjectItemDefinitionInstance : object {
    private string _itemType;
    private CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> _metadata;
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public ICollection`1<ProjectMetadataInstance> Metadata { get; }
    public int MetadataCount { get; }
    public IEnumerable`1<string> MetadataNames { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    private string Microsoft.Build.Evaluation.IItemTypeDefinition.ItemType { get; }
    internal ProjectItemDefinitionInstance(string itemType);
    internal ProjectItemDefinitionInstance(ProjectItemDefinition itemDefinition);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    public ICollection`1<ProjectMetadataInstance> get_Metadata();
    public int get_MetadataCount();
    [IteratorStateMachineAttribute("Microsoft.Build.Execution.ProjectItemDefinitionInstance/<get_MetadataNames>d__12")]
public IEnumerable`1<string> get_MetadataNames();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
public sealed virtual ProjectMetadataInstance GetMetadata(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string specifiedItemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string specifiedItemType, string name);
    private sealed virtual override ProjectMetadataInstance Microsoft.Build.Evaluation.IItemDefinition<Microsoft.Build.Execution.ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement xml, string evaluatedValue, ProjectMetadataInstance predecessor);
    internal ProjectItemDefinitionElement ToProjectItemDefinitionElement(ProjectElementContainer parent);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectItemDefinitionInstance FactoryForDeserialization(ITranslator translator);
    private sealed virtual override string Microsoft.Build.Evaluation.IItemTypeDefinition.get_ItemType();
}
[DebuggerDisplayAttribute("Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskInstance : ProjectTargetInstanceChild {
    private string _condition;
    private List`1<ProjectItemGroupTaskItemInstance> _items;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Condition { get; }
    public ICollection`1<ProjectItemGroupTaskItemInstance> Items { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskInstance(string condition, ElementLocation location, ElementLocation conditionLocation, List`1<ProjectItemGroupTaskItemInstance> items);
    private ProjectItemGroupTaskInstance(ProjectItemGroupTaskInstance that);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemGroupTaskItemInstance> get_Items();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
[DebuggerDisplayAttribute("{_itemType} Include={_include} Exclude={_exclude} Remove={_remove} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskItemInstance : object {
    private string _itemType;
    private string _include;
    private string _exclude;
    private string _remove;
    private string _matchOnMetadata;
    private string _matchOnMetadataOptions;
    private string _keepMetadata;
    private string _removeMetadata;
    private string _keepDuplicates;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _includeLocation;
    private ElementLocation _excludeLocation;
    private ElementLocation _removeLocation;
    private ElementLocation _matchOnMetadataLocation;
    private ElementLocation _matchOnMetadataOptionsLocation;
    private ElementLocation _keepMetadataLocation;
    private ElementLocation _removeMetadataLocation;
    private ElementLocation _keepDuplicatesLocation;
    private ElementLocation _conditionLocation;
    private List`1<ProjectItemGroupTaskMetadataInstance> _metadata;
    public string ItemType { get; }
    public string Include { get; }
    public string Exclude { get; }
    public string Remove { get; }
    public string MatchOnMetadata { get; }
    public string MatchOnMetadataOptions { get; }
    public string KeepMetadata { get; }
    public string RemoveMetadata { get; }
    public string KeepDuplicates { get; }
    public string Condition { get; }
    public ICollection`1<ProjectItemGroupTaskMetadataInstance> Metadata { get; }
    public ElementLocation Location { get; }
    public ElementLocation IncludeLocation { get; }
    public ElementLocation ExcludeLocation { get; }
    public ElementLocation RemoveLocation { get; }
    public ElementLocation MatchOnMetadataLocation { get; }
    public ElementLocation MatchOnMetadataOptionsLocation { get; }
    public ElementLocation KeepMetadataLocation { get; }
    public ElementLocation RemoveMetadataLocation { get; }
    public ElementLocation KeepDuplicatesLocation { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskItemInstance(string itemType, string include, string exclude, string remove, string matchOnMetadata, string matchOnMetadataOptions, string keepMetadata, string removeMetadata, string keepDuplicates, string condition, ElementLocation location, ElementLocation includeLocation, ElementLocation excludeLocation, ElementLocation removeLocation, ElementLocation matchOnMetadataLocation, ElementLocation matchOnMetadataOptionsLocation, ElementLocation keepMetadataLocation, ElementLocation removeMetadataLocation, ElementLocation keepDuplicatesLocation, ElementLocation conditionLocation, List`1<ProjectItemGroupTaskMetadataInstance> metadata);
    private ProjectItemGroupTaskItemInstance(ProjectItemGroupTaskItemInstance that);
    [DebuggerStepThroughAttribute]
public string get_ItemType();
    [DebuggerStepThroughAttribute]
public string get_Include();
    [DebuggerStepThroughAttribute]
public string get_Exclude();
    [DebuggerStepThroughAttribute]
public string get_Remove();
    [DebuggerStepThroughAttribute]
public string get_MatchOnMetadata();
    [DebuggerStepThroughAttribute]
public string get_MatchOnMetadataOptions();
    [DebuggerStepThroughAttribute]
public string get_KeepMetadata();
    [DebuggerStepThroughAttribute]
public string get_RemoveMetadata();
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicates();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectItemGroupTaskMetadataInstance> get_Metadata();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_IncludeLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ExcludeLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_RemoveLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_MatchOnMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_MatchOnMetadataOptionsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_RemoveMetadataLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepDuplicatesLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskItemInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectItemGroupTaskItemInstance FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("{_name} Value={_value} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectItemGroupTaskMetadataInstance : object {
    private string _name;
    private string _value;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Name { get; }
    public string Value { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectItemGroupTaskMetadataInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation);
    private ProjectItemGroupTaskMetadataInstance(ProjectItemGroupTaskMetadataInstance that);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Value();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    internal ProjectItemGroupTaskMetadataInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectItemGroupTaskMetadataInstance FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("{ItemType}={EvaluatedInclude} #DirectMetadata={DirectMetadataCount})")]
public class Microsoft.Build.Execution.ProjectItemInstance : object {
    private ProjectInstance _project;
    private string _itemType;
    private TaskItem _taskItem;
    [DebuggerBrowsableAttribute("0")]
public ProjectInstance Project { get; }
    [DebuggerBrowsableAttribute("0")]
public string ItemType { get; }
    public string EvaluatedInclude { get; public set; }
    private string Microsoft.Build.Evaluation.IItem.EvaluatedIncludeEscaped { get; }
    private string Microsoft.Build.Framework.ITaskItem2.EvaluatedIncludeEscaped { get; private set; }
    public IEnumerable`1<ProjectMetadataInstance> Metadata { get; }
    public int DirectMetadataCount { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    public ICollection`1<string> MetadataNames { get; }
    private string Microsoft.Build.Framework.ITaskItem.ItemSpec { get; private set; }
    private ICollection Microsoft.Build.Framework.ITaskItem.MetadataNames { get; }
    public int MetadataCount { get; }
    private string Microsoft.Build.Evaluation.IItem.ProjectDirectory { get; }
    internal static IEqualityComparer`1<ProjectItemInstance> EqualityComparer { get; }
    internal string ProjectFullPath { get; }
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string definingFileEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, string definingFileEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> directMetadata, List`1<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped);
    internal ProjectItemInstance(ProjectInstance project, string itemType, string includeEscaped, IEnumerable`1<KeyValuePair`2<string, string>> directMetadata, string definingFileEscaped);
    private ProjectItemInstance(ProjectItemInstance that);
    private ProjectItemInstance(ProjectItemInstance that, ProjectInstance newProject);
    private ProjectItemInstance(ProjectInstance projectInstance);
    public ProjectInstance get_Project();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_ItemType();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedInclude();
    [DebuggerStepThroughAttribute]
public void set_EvaluatedInclude(string value);
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_EvaluatedIncludeEscaped();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.get_EvaluatedIncludeEscaped();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.set_EvaluatedIncludeEscaped(string value);
    public sealed virtual IEnumerable`1<ProjectMetadataInstance> get_Metadata();
    public int get_DirectMetadataCount();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    public ICollection`1<string> get_MetadataNames();
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem.get_ItemSpec();
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.set_ItemSpec(string value);
    private sealed virtual override ICollection Microsoft.Build.Framework.ITaskItem.get_MetadataNames();
    public sealed virtual int get_MetadataCount();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.get_ProjectDirectory();
    internal static IEqualityComparer`1<ProjectItemInstance> get_EqualityComparer();
    internal string get_ProjectFullPath();
    public sealed virtual ProjectMetadataInstance GetMetadata(string name);
    public sealed virtual string GetMetadataValue(string name);
    public bool HasMetadata(string name);
    public ProjectMetadataInstance SetMetadata(string name, string evaluatedValue);
    public void SetMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadataDictionary);
    public sealed virtual void RemoveMetadata(string metadataName);
    public virtual string ToString();
    private sealed virtual override string Microsoft.Build.Evaluation.IItem.GetMetadataValueEscaped(string name);
    private sealed virtual override ProjectMetadataInstance Microsoft.Build.Evaluation.IItem<Microsoft.Build.Execution.ProjectMetadataInstance>.SetMetadata(ProjectMetadataElement metadataElement, string evaluatedInclude);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem.GetMetadata(string metadataName);
    private sealed virtual override string Microsoft.Build.Framework.ITaskItem2.GetMetadataValueEscaped(string name);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.SetMetadata(string metadataName, string metadataValue);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem2.SetMetadataValueLiteral(string metadataName, string metadataValue);
    private sealed virtual override void Microsoft.Build.Framework.ITaskItem.CopyMetadataTo(ITaskItem destinationItem);
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem.CloneCustomMetadata();
    private sealed virtual override IDictionary Microsoft.Build.Framework.ITaskItem2.CloneCustomMetadataEscaped();
    private sealed virtual override IEnumerable`1<KeyValuePair`2<string, string>> Microsoft.Build.Framework.IMetadataContainer.EnumerateMetadata();
    private sealed virtual override void Microsoft.Build.Framework.IMetadataContainer.ImportMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValue(string itemType, string name);
    private sealed virtual override string Microsoft.Build.Evaluation.IMetadataTable.GetEscapedValueIfPresent(string itemType, string name);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static void SetMetadata(IEnumerable`1<KeyValuePair`2<string, string>> metadataList, IEnumerable`1<ProjectItemInstance> items);
    internal static ProjectItemInstance FactoryForDeserialization(ITranslator translator, ProjectInstance projectInstance);
    internal void SetMetadata(CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> metadataDictionary);
    internal void SetMetadataOnTaskOutput(IEnumerable`1<KeyValuePair`2<string, string>> items);
    internal ProjectItemInstance DeepClone();
    internal ProjectItemInstance DeepClone(ProjectInstance newProject);
    internal ProjectItemElement ToProjectItemElement(ProjectElementContainer parent);
    private void CommonConstructor(ProjectInstance projectToUse, string itemTypeToUse, string includeEscaped, string includeBeforeWildcardExpansionEscaped, CopyOnWritePropertyDictionary`1<ProjectMetadataInstance> directMetadata, List`1<ProjectItemDefinitionInstance> itemDefinitions, string definingFileEscaped);
}
[DebuggerDisplayAttribute("{_name}={EvaluatedValue}")]
public class Microsoft.Build.Execution.ProjectMetadataInstance : object {
    private string _name;
    private string _escapedValue;
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    [DebuggerBrowsableAttribute("0")]
internal string EvaluatedValueEscaped { get; }
    internal ProjectMetadataInstance(string name, string escapedValue);
    internal ProjectMetadataInstance(string name, string escapedValue, bool allowItemSpecModifiers);
    internal ProjectMetadataInstance(ProjectMetadata metadatum);
    private ProjectMetadataInstance(ITranslator translator);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    [DebuggerStepThroughAttribute]
internal string get_EvaluatedValueEscaped();
    public virtual string ToString();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Execution.ProjectMetadataInstance>.Equals(ProjectMetadataInstance other);
    public ProjectMetadataInstance DeepClone();
    internal static ProjectMetadataInstance FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("ExecuteTargets={_executeTargets} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectOnErrorInstance : ProjectTargetInstanceChild {
    private string _executeTargets;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    private ElementLocation _executeTargetsLocation;
    public string Condition { get; }
    public string ExecuteTargets { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation ExecuteTargetsLocation { get; }
    internal ProjectOnErrorInstance(string executeTargets, string condition, ElementLocation location, ElementLocation executeTargetsLocation, ElementLocation conditionLocation);
    public virtual string get_Condition();
    public string get_ExecuteTargets();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public ElementLocation get_ExecuteTargetsLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectOnErrorInstance FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectPropertyGroupTaskInstance : ProjectTargetInstanceChild {
    private string _condition;
    private List`1<ProjectPropertyGroupTaskPropertyInstance> _properties;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Condition { get; }
    public ICollection`1<ProjectPropertyGroupTaskPropertyInstance> Properties { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectPropertyGroupTaskInstance(string condition, ElementLocation location, ElementLocation conditionLocation, List`1<ProjectPropertyGroupTaskPropertyInstance> properties);
    private ProjectPropertyGroupTaskInstance(ProjectPropertyGroupTaskInstance that);
    [DebuggerStepThroughAttribute]
public virtual string get_Condition();
    [DebuggerStepThroughAttribute]
public ICollection`1<ProjectPropertyGroupTaskPropertyInstance> get_Properties();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal ProjectPropertyGroupTaskInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
[DebuggerDisplayAttribute("{_name}={Value} Condition={_condition}")]
public class Microsoft.Build.Execution.ProjectPropertyGroupTaskPropertyInstance : object {
    private string _name;
    private string _value;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    public string Name { get; }
    public string Value { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal ProjectPropertyGroupTaskPropertyInstance(string name, string value, string condition, ElementLocation location, ElementLocation conditionLocation);
    private ProjectPropertyGroupTaskPropertyInstance(ProjectPropertyGroupTaskPropertyInstance that);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Value();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    public ElementLocation get_Location();
    public ElementLocation get_ConditionLocation();
    internal ProjectPropertyGroupTaskPropertyInstance DeepClone();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectPropertyGroupTaskPropertyInstance FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("{_name}={_escapedValue}")]
public class Microsoft.Build.Execution.ProjectPropertyInstance : object {
    private string _name;
    private string _escapedValue;
    [DebuggerBrowsableAttribute("0")]
public string Name { get; }
    public string EvaluatedValue { get; public set; }
    public bool IsImmutable { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Evaluation.IProperty.EvaluatedValueEscaped { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IValued.EscapedValue { get; }
    private ProjectPropertyInstance(string name, string escapedValue);
    public sealed virtual string get_Name();
    [DebuggerStepThroughAttribute]
public sealed virtual string get_EvaluatedValue();
    [DebuggerStepThroughAttribute]
public void set_EvaluatedValue(string value);
    public virtual bool get_IsImmutable();
    private sealed virtual override string Microsoft.Build.Evaluation.IProperty.get_EvaluatedValueEscaped();
    private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    private sealed virtual override string Microsoft.Build.Collections.IValued.get_EscapedValue();
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Execution.ProjectPropertyInstance>.Equals(ProjectPropertyInstance other);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    public virtual string ToString();
    internal static ProjectPropertyInstance Create(string name, string escapedValue);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, bool isImmutable, bool isEnvironmentProperty, LoggingContext loggingContext);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, ElementLocation location);
    internal static ProjectPropertyInstance Create(string name, string escapedValue, ElementLocation location, bool isImmutable);
    internal static ProjectPropertyInstance Create(ProjectPropertyInstance that);
    internal static ProjectPropertyInstance Create(ProjectPropertyInstance that, bool isImmutable);
    internal static ProjectPropertyInstance FactoryForDeserialization(ITranslator translator);
    internal ProjectPropertyInstance DeepClone();
    internal ProjectPropertyInstance DeepClone(bool isImmutable);
    internal ProjectPropertyElement ToProjectPropertyElement(ProjectElementContainer parent);
    private static ProjectPropertyInstance Create(string name, string escapedValue, bool mayBeReserved, ElementLocation location, bool isImmutable, bool isEnvironmentProperty, LoggingContext loggingContext);
}
[DebuggerDisplayAttribute("Name={_name} Count={_children.Count} Condition={_condition} Inputs={_inputs} Outputs={_outputs} DependsOnTargets={_dependsOnTargets} BeforeTargets={_beforeTargets} AfterTargets={_afterTargets}")]
public class Microsoft.Build.Execution.ProjectTargetInstance : object {
    private string _name;
    private string _condition;
    private string _inputs;
    private string _outputs;
    private string _returns;
    private string _dependsOnTargets;
    private string _beforeTargets;
    private string _afterTargets;
    private string _keepDuplicateOutputs;
    private ReadOnlyCollection`1<ProjectOnErrorInstance> _onErrorChildren;
    private bool _parentProjectSupportsReturnsAttribute;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    private ElementLocation _inputsLocation;
    private ElementLocation _outputsLocation;
    private ElementLocation _returnsLocation;
    private ElementLocation _keepDuplicateOutputsLocation;
    private ElementLocation _dependsOnTargetsLocation;
    private ElementLocation _beforeTargetsLocation;
    private ElementLocation _afterTargetsLocation;
    private IList`1<ProjectTargetInstanceChild> _children;
    public string Name { get; }
    public string Condition { get; }
    public string Inputs { get; }
    public string Outputs { get; }
    public string Returns { get; }
    public string KeepDuplicateOutputs { get; }
    public string DependsOnTargets { get; }
    public string BeforeTargets { get; }
    public string AfterTargets { get; }
    public IList`1<ProjectTargetInstanceChild> Children { get; }
    public IList`1<ProjectOnErrorInstance> OnErrorChildren { get; }
    public ICollection`1<ProjectTaskInstance> Tasks { get; }
    public string FullPath { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation InputsLocation { get; }
    public ElementLocation OutputsLocation { get; }
    public ElementLocation ReturnsLocation { get; }
    public ElementLocation KeepDuplicateOutputsLocation { get; }
    public ElementLocation DependsOnTargetsLocation { get; }
    public ElementLocation BeforeTargetsLocation { get; }
    public ElementLocation AfterTargetsLocation { get; }
    [DebuggerBrowsableAttribute("0")]
private string Microsoft.Build.Collections.IKeyed.Key { get; }
    internal bool ParentProjectSupportsReturnsAttribute { get; }
    internal ProjectTargetInstance(string name, string condition, string inputs, string outputs, string returns, string keepDuplicateOutputs, string dependsOnTargets, string beforeTargets, string afterTargets, ElementLocation location, ElementLocation conditionLocation, ElementLocation inputsLocation, ElementLocation outputsLocation, ElementLocation returnsLocation, ElementLocation keepDuplicateOutputsLocation, ElementLocation dependsOnTargetsLocation, ElementLocation beforeTargetsLocation, ElementLocation afterTargetsLocation, ReadOnlyCollection`1<ProjectTargetInstanceChild> children, ReadOnlyCollection`1<ProjectOnErrorInstance> onErrorChildren, bool parentProjectSupportsReturnsAttribute);
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public string get_Condition();
    [DebuggerStepThroughAttribute]
public string get_Inputs();
    [DebuggerStepThroughAttribute]
public string get_Outputs();
    [DebuggerStepThroughAttribute]
public string get_Returns();
    [DebuggerStepThroughAttribute]
public string get_KeepDuplicateOutputs();
    [DebuggerStepThroughAttribute]
public string get_DependsOnTargets();
    [DebuggerStepThroughAttribute]
public string get_BeforeTargets();
    [DebuggerStepThroughAttribute]
public string get_AfterTargets();
    [DebuggerStepThroughAttribute]
public IList`1<ProjectTargetInstanceChild> get_Children();
    [DebuggerStepThroughAttribute]
public IList`1<ProjectOnErrorInstance> get_OnErrorChildren();
    public ICollection`1<ProjectTaskInstance> get_Tasks();
    public string get_FullPath();
    [DebuggerStepThroughAttribute]
public ElementLocation get_Location();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ConditionLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_InputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_OutputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_ReturnsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_KeepDuplicateOutputsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_DependsOnTargetsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_BeforeTargetsLocation();
    [DebuggerStepThroughAttribute]
public ElementLocation get_AfterTargetsLocation();
    [DebuggerStepThroughAttribute]
private sealed virtual override string Microsoft.Build.Collections.IKeyed.get_Key();
    [DebuggerStepThroughAttribute]
internal bool get_ParentProjectSupportsReturnsAttribute();
    internal ProjectTargetElement ToProjectTargetElement(ProjectRootElement rootElement);
    internal void AddProjectTargetInstanceChild(ProjectTargetInstanceChild projectTargetInstanceChild);
    internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError);
    internal ProjectTaskInstance AddTask(string taskName, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectTargetInstance FactoryForDeserialization(ITranslator translator);
}
public abstract class Microsoft.Build.Execution.ProjectTargetInstanceChild : object {
    public string Condition { get; }
    public string FullPath { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public abstract virtual string get_Condition();
    public string get_FullPath();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual ElementLocation get_ConditionLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectTargetInstanceChild FactoryForDeserialization(ITranslator translator);
}
[DebuggerDisplayAttribute("Name={_name} Condition={_condition} ContinueOnError={_continueOnError} MSBuildRuntime={MSBuildRuntime} MSBuildArchitecture={MSBuildArchitecture} #Parameters={_parameters.Count} #Outputs={_outputs.Count}")]
public class Microsoft.Build.Execution.ProjectTaskInstance : ProjectTargetInstanceChild {
    private string _name;
    private string _condition;
    private string _continueOnError;
    private string _msbuildRuntime;
    private string _msbuildArchitecture;
    private CopyOnWriteDictionary`1<ValueTuple`2<string, ElementLocation>> _parameters;
    private List`1<ProjectTaskInstanceChild> _outputs;
    private ElementLocation _location;
    private ElementLocation _conditionLocation;
    private ElementLocation _continueOnErrorLocation;
    private ElementLocation _msbuildRuntimeLocation;
    private ElementLocation _msbuildArchitectureLocation;
    public string Name { get; }
    public string Condition { get; }
    public string ContinueOnError { get; }
    public string MSBuildRuntime { get; }
    public string MSBuildArchitecture { get; }
    public IDictionary`2<string, string> Parameters { get; }
    internal IDictionary`2<string, ValueTuple`2<string, ElementLocation>> TestGetParameters { get; }
    public IList`1<ProjectTaskInstanceChild> Outputs { get; }
    public ElementLocation ContinueOnErrorLocation { get; }
    public ElementLocation MSBuildRuntimeLocation { get; }
    public ElementLocation MSBuildArchitectureLocation { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    internal IDictionary`2<string, ValueTuple`2<string, ElementLocation>> ParametersForBuild { get; }
    internal ProjectTaskInstance(ProjectTaskElement element, IList`1<ProjectTaskInstanceChild> outputs);
    internal ProjectTaskInstance(string name, ElementLocation location, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture);
    internal ProjectTaskInstance(string name, string condition, string continueOnError, string msbuildRuntime, string msbuildArchitecture, CopyOnWriteDictionary`1<ValueTuple`2<string, ElementLocation>> parameters, List`1<ProjectTaskInstanceChild> outputs, ElementLocation location, ElementLocation conditionLocation, ElementLocation continueOnErrorElementLocation, ElementLocation msbuildRuntimeLocation, ElementLocation msbuildArchitectureLocation);
    public string get_Name();
    public virtual string get_Condition();
    public string get_ContinueOnError();
    public string get_MSBuildRuntime();
    public string get_MSBuildArchitecture();
    public IDictionary`2<string, string> get_Parameters();
    internal IDictionary`2<string, ValueTuple`2<string, ElementLocation>> get_TestGetParameters();
    public IList`1<ProjectTaskInstanceChild> get_Outputs();
    public ElementLocation get_ContinueOnErrorLocation();
    public ElementLocation get_MSBuildRuntimeLocation();
    public ElementLocation get_MSBuildArchitectureLocation();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    internal IDictionary`2<string, ValueTuple`2<string, ElementLocation>> get_ParametersForBuild();
    internal string GetParameter(string parameterName);
    internal void SetParameter(string parameterName, string unevaluatedValue);
    internal void AddOutputItem(string taskOutputParameterName, string itemName, string condition);
    internal void AddOutputProperty(string taskOutputParameterName, string propertyName, string condition);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    private static void ParametersKeyTranslator(ITranslator translator, String& key);
    private static void ParametersValueTranslator(ITranslator translator, ValueTuple`2& value);
    internal static ProjectTaskInstance FactoryForDeserialization(ITranslator translator);
}
public abstract class Microsoft.Build.Execution.ProjectTaskInstanceChild : object {
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation ConditionLocation { get; }
    public abstract virtual string get_Condition();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual ElementLocation get_TaskParameterLocation();
    public abstract virtual ElementLocation get_ConditionLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProjectTaskInstanceChild FactoryForDeserialization(ITranslator translator);
}
public class Microsoft.Build.Execution.ProjectTaskOutputItemInstance : ProjectTaskInstanceChild {
    private string _itemType;
    private string _taskParameter;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _itemTypeLocation;
    private ElementLocation _taskParameterLocation;
    private ElementLocation _conditionLocation;
    public string ItemType { get; }
    public string TaskParameter { get; }
    public string Condition { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation TaskParameterLocation { get; }
    public ElementLocation ItemTypeLocation { get; }
    internal ProjectTaskOutputItemInstance(string itemType, string taskParameter, string condition, ElementLocation location, ElementLocation itemTypeLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation);
    public string get_ItemType();
    public string get_TaskParameter();
    public virtual string get_Condition();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public virtual ElementLocation get_TaskParameterLocation();
    public ElementLocation get_ItemTypeLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
public class Microsoft.Build.Execution.ProjectTaskOutputPropertyInstance : ProjectTaskInstanceChild {
    private string _propertyName;
    private string _taskParameter;
    private string _condition;
    private ElementLocation _location;
    private ElementLocation _propertyNameLocation;
    private ElementLocation _taskParameterLocation;
    private ElementLocation _conditionLocation;
    public string PropertyName { get; }
    public string TaskParameter { get; }
    public string Condition { get; }
    public ElementLocation PropertyNameLocation { get; }
    public ElementLocation Location { get; }
    public ElementLocation ConditionLocation { get; }
    public ElementLocation TaskParameterLocation { get; }
    internal ProjectTaskOutputPropertyInstance(string propertyName, string taskParameter, string condition, ElementLocation location, ElementLocation propertyNameLocation, ElementLocation taskParameterLocation, ElementLocation conditionLocation);
    public string get_PropertyName();
    public string get_TaskParameter();
    public virtual string get_Condition();
    public ElementLocation get_PropertyNameLocation();
    public virtual ElementLocation get_Location();
    public virtual ElementLocation get_ConditionLocation();
    public virtual ElementLocation get_TaskParameterLocation();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
internal class Microsoft.Build.Execution.ReflectableTaskPropertyInfo : TaskPropertyInfo {
    private PropertyInfo _propertyInfo;
    private Type _taskType;
    internal PropertyInfo Reflection { get; }
    internal ReflectableTaskPropertyInfo(TaskPropertyInfo taskPropertyInfo, Type taskType);
    internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo);
    internal ReflectableTaskPropertyInfo(PropertyInfo propertyInfo, bool output, bool required, bool isAssignableToITaskItemType);
    internal PropertyInfo get_Reflection();
}
public class Microsoft.Build.Execution.RequestedProjectState : object {
    private List`1<string> _propertyFilters;
    private IDictionary`2<string, List`1<string>> _itemFilters;
    public List`1<string> PropertyFilters { get; public set; }
    public IDictionary`2<string, List`1<string>> ItemFilters { get; public set; }
    public List`1<string> get_PropertyFilters();
    public void set_PropertyFilters(List`1<string> value);
    public IDictionary`2<string, List`1<string>> get_ItemFilters();
    public void set_ItemFilters(IDictionary`2<string, List`1<string>> value);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    private static IDictionary`2<string, List`1<string>> CreateItemMetadataDictionary(int capacity);
    private static void TranslateMetadataForItem(ITranslator translator, List`1& list);
    private static void TranslateString(ITranslator translator, String& s);
}
internal class Microsoft.Build.Execution.ResultsCacheWithOverride : object {
    private IResultsCache _override;
    [CompilerGeneratedAttribute]
private ResultsCache <CurrentCache>k__BackingField;
    public ResultsCache CurrentCache { get; }
    public ResultsCacheWithOverride(IResultsCache override);
    [CompilerGeneratedAttribute]
public ResultsCache get_CurrentCache();
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void Translate(ITranslator translator);
    public sealed virtual void AddResult(BuildResult result);
    public sealed virtual void ClearResults();
    public sealed virtual BuildResult GetResultForRequest(BuildRequest request);
    public sealed virtual BuildResult GetResultsForConfiguration(int configurationId);
    public sealed virtual ResultsCacheResponse SatisfyRequest(BuildRequest request, List`1<string> configInitialTargets, List`1<string> configDefaultTargets, bool skippedResultsDoNotCauseCacheMiss);
    public sealed virtual void ClearResultsForConfiguration(int configurationId);
    public sealed virtual void WriteResultsToDisk();
    public sealed virtual IEnumerator`1<BuildResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Build.Execution.RunningObjectTable : object {
    private Task`1<IRunningObjectTable> _rotTask;
    [SupportedOSPlatform("windows")]
public sealed virtual object GetObject(string itemName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Execution.ServerNamedMutex : object {
    private Mutex _serverMutex;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLocked>k__BackingField;
    public bool IsDisposed { get; private set; }
    public bool IsLocked { get; private set; }
    public ServerNamedMutex(string mutexName, Boolean& createdNew);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsLocked();
    [CompilerGeneratedAttribute]
private void set_IsLocked(bool value);
    internal static ServerNamedMutex OpenOrCreateMutex(string name, Boolean& createdNew);
    public static bool WasOpen(string mutexName);
    public sealed virtual void Dispose();
}
public class Microsoft.Build.Execution.TargetResult : object {
    private WorkUnitResult _result;
    private bool _targetFailureDoesntCauseBuildFailure;
    private bool _afterTargetsHaveFailed;
    private TaskItem[] _items;
    private CacheInfo _cacheInfo;
    private BuildEventContext _originalBuildEventContext;
    public Exception Exception { get; }
    public ITaskItem[] Items { get; }
    public TargetResultCode ResultCode { get; }
    internal WorkUnitResult WorkUnitResult { get; }
    internal BuildEventContext OriginalBuildEventContext { get; }
    internal bool TargetFailureDoesntCauseBuildFailure { get; internal set; }
    internal bool AfterTargetsHaveFailed { get; internal set; }
    internal TargetResult(TaskItem[] items, WorkUnitResult result, BuildEventContext originalBuildEventContext);
    private TargetResult(ITranslator translator);
    [DebuggerStepThroughAttribute]
public sealed virtual Exception get_Exception();
    [DebuggerStepThroughAttribute]
public sealed virtual ITaskItem[] get_Items();
    [DebuggerStepThroughAttribute]
public sealed virtual TargetResultCode get_ResultCode();
    [DebuggerStepThroughAttribute]
internal WorkUnitResult get_WorkUnitResult();
    internal BuildEventContext get_OriginalBuildEventContext();
    [DebuggerStepThroughAttribute]
internal bool get_TargetFailureDoesntCauseBuildFailure();
    [DebuggerStepThroughAttribute]
internal void set_TargetFailureDoesntCauseBuildFailure(bool value);
    [DebuggerStepThroughAttribute]
internal bool get_AfterTargetsHaveFailed();
    [DebuggerStepThroughAttribute]
internal void set_AfterTargetsHaveFailed(bool value);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static TargetResult FactoryForDeserialization(ITranslator translator);
    internal static string GetCacheFile(int configId, string targetToCache);
    internal static string GetCacheDirectory(int configId, string targetToCache);
    internal void CacheItems(int configId, string targetName);
    private void InternalTranslate(ITranslator translator);
    private void RetrieveItemsFromCache();
    private void TranslateItems(ITranslator translator);
    private static ITranslator GetResultsCacheTranslator(int configId, string targetToCache, TranslationDirection direction);
}
public enum Microsoft.Build.Execution.TargetResultCode : Enum {
    public byte value__;
    public static TargetResultCode Skipped;
    public static TargetResultCode Success;
    public static TargetResultCode Failure;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Execution.TaskFactoryWrapper : object {
    private ITaskFactory _taskFactory;
    private Lazy`1<PropertyData> _propertyData;
    private string _taskName;
    private IDictionary`2<string, string> _factoryIdentityParameters;
    [CompilerGeneratedAttribute]
private LoadedType <TaskFactoryLoadedType>k__BackingField;
    public LoadedType TaskFactoryLoadedType { get; private set; }
    public ITaskFactory TaskFactory { get; }
    public IReadOnlyDictionary`2<string, string> GetNamesOfPropertiesWithRequiredAttribute { get; }
    public IReadOnlyDictionary`2<string, string> GetNamesOfPropertiesWithOutputAttribute { get; }
    public string Name { get; }
    public IDictionary`2<string, string> FactoryIdentityParameters { get; }
    internal TaskFactoryWrapper(ITaskFactory taskFactory, LoadedType taskFactoryLoadInfo, string taskName, IDictionary`2<string, string> factoryIdentityParameters);
    [CompilerGeneratedAttribute]
public LoadedType get_TaskFactoryLoadedType();
    [CompilerGeneratedAttribute]
private void set_TaskFactoryLoadedType(LoadedType value);
    public ITaskFactory get_TaskFactory();
    public IReadOnlyDictionary`2<string, string> get_GetNamesOfPropertiesWithRequiredAttribute();
    public IReadOnlyDictionary`2<string, string> get_GetNamesOfPropertiesWithOutputAttribute();
    public string get_Name();
    public IDictionary`2<string, string> get_FactoryIdentityParameters();
    public TaskPropertyInfo GetProperty(string propertyName);
    internal void SetPropertyValue(ITask task, TaskPropertyInfo property, object value);
    internal object GetPropertyValue(ITask task, TaskPropertyInfo property);
    internal bool IsCreatableByFactory(string taskName);
    private PropertyData PopulatePropertyInfo();
}
internal class Microsoft.Build.Execution.TaskRegistry : object {
    private Toolset _toolset;
    private static bool s_forceTaskHostLaunch;
    private static string s_tasksV4SimpleName;
    private static string s_tasksV4Filename;
    private static string s_potentialTasksV4Location;
    private static string s_tasksV12SimpleName;
    private static string s_tasksV12Filename;
    private static string s_potentialTasksV12Location;
    private static string s_tasksCoreSimpleName;
    private static string s_tasksCoreFilename;
    private static string s_potentialTasksCoreLocation;
    private int _nextRegistrationOrderId;
    private ConcurrentDictionary`2<RegisteredTaskIdentity, RegisteredTaskRecord> _cachedTaskRecordsWithExactMatch;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<RegisteredTaskIdentity, RegisteredTaskRecord>> _cachedTaskRecordsWithFuzzyMatch;
    private Dictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> _taskRegistrations;
    private Dictionary`2<string, List`1<RegisteredTaskRecord>> _overriddenTasks;
    [CompilerGeneratedAttribute]
private ProjectRootElementCacheBase <RootElementCache>k__BackingField;
    internal ProjectRootElementCacheBase RootElementCache { get; internal set; }
    internal Toolset Toolset { get; }
    internal int NextRegistrationOrderId { get; }
    internal IDictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> TaskRegistrations { get; }
    internal bool IsLoaded { get; }
    internal TaskRegistry(ProjectRootElementCacheBase projectRootElementCache);
    internal TaskRegistry(Toolset toolset, ProjectRootElementCacheBase projectRootElementCache);
    private static TaskRegistry();
    [CompilerGeneratedAttribute]
internal ProjectRootElementCacheBase get_RootElementCache();
    [CompilerGeneratedAttribute]
internal void set_RootElementCache(ProjectRootElementCacheBase value);
    [DebuggerStepThroughAttribute]
internal Toolset get_Toolset();
    internal int get_NextRegistrationOrderId();
    internal IDictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> get_TaskRegistrations();
    internal bool get_IsLoaded();
    internal static void InitializeTaskRegistryFromUsingTaskElements(ILoggingService loggingService, BuildEventContext buildEventContext, IEnumerable`1<ValueTuple`2<ProjectUsingTaskElement, string>> registrations, TaskRegistry taskRegistry, Expander`2<P, I> expander, ExpanderOptions expanderOptions, IFileSystem fileSystem);
    private static void RegisterTasksFromUsingTaskElement(ILoggingService loggingService, BuildEventContext buildEventContext, string directoryOfImportingFile, ProjectUsingTaskElement projectUsingTaskXml, TaskRegistry taskRegistry, Expander`2<P, I> expander, ExpanderOptions expanderOptions, IFileSystem fileSystem);
    private static Dictionary`2<string, string> CreateTaskFactoryParametersDictionary(Nullable`1<int> initialCount);
    internal TaskFactoryWrapper GetRegisteredTask(string taskName, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, bool exactMatchRequired, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    internal RegisteredTaskRecord GetTaskRegistrationRecord(string taskName, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, bool exactMatchRequired, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation, Boolean& retrievedFromCache);
    private static bool IsTaskFactoryClass(Type type, object unused);
    private IEnumerable`1<RegisteredTaskRecord> GetRelevantOrderedRegistrations(RegisteredTaskIdentity taskIdentity, bool exactMatchRequired);
    private void RegisterTask(string taskName, AssemblyLoadInfo assemblyLoadInfo, string taskFactory, Dictionary`2<string, string> taskFactoryParameters, ParameterGroupAndTaskElementRecord inlineTaskRecord, ILoggingService loggingService, BuildEventContext context, ProjectUsingTaskElement projectUsingTaskInXml, bool overrideTask);
    private static Dictionary`2<RegisteredTaskIdentity, List`1<RegisteredTaskRecord>> CreateRegisteredTaskDictionary(Nullable`1<int> capacity);
    private RegisteredTaskRecord GetMatchingRegistration(string taskName, IEnumerable`1<RegisteredTaskRecord> taskRecords, string taskProjectFile, IDictionary`2<string, string> taskIdentityParameters, TargetLoggingContext targetLoggingContext, ElementLocation elementLocation);
    public sealed virtual void Translate(ITranslator translator);
    private void TranslateTaskRegistrationKey(ITranslator translator, RegisteredTaskIdentity& taskIdentity);
    private void TranslateTaskRegistrationValue(ITranslator translator, List`1& taskRecords);
    public static TaskRegistry FactoryForDeserialization(ITranslator translator);
}
[FlagsAttribute]
[CLSCompliantAttribute("False")]
public enum Microsoft.Build.Experimental.FileAccess.DesiredAccess : Enum {
    public UInt32 value__;
    public static DesiredAccess FILE_LIST_DIRECTORY;
    public static DesiredAccess FILE_ADD_FILE;
    public static DesiredAccess FILE_ADD_SUBDIRECTORY;
    public static DesiredAccess FILE_READ_EA;
    public static DesiredAccess DELETE;
    public static DesiredAccess SYNCHRONIZE;
    public static DesiredAccess FILE_APPEND_DATA;
    public static DesiredAccess FILE_WRITE_EA;
    public static DesiredAccess FILE_EXECUTE;
    public static DesiredAccess FILE_DELETE_CHILD;
    public static DesiredAccess FILE_READ_ATTRIBUTES;
    public static DesiredAccess FILE_WRITE_ATTRIBUTES;
    public static DesiredAccess FILE_WRITE_DATA;
    public static DesiredAccess GENERIC_ALL;
    public static DesiredAccess GENERIC_EXECUTE;
    public static DesiredAccess GENERIC_WRITE;
    public static DesiredAccess GENERIC_READ;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class Microsoft.Build.Experimental.FileAccess.FileAccessData : ValueType {
    private ReportedFileOperation _operation;
    private RequestedAccess _requestedAccess;
    private UInt32 _processId;
    private UInt32 _error;
    private DesiredAccess _desiredAccess;
    private FlagsAndAttributes _flagsAndAttributes;
    private string _path;
    [NullableAttribute("2")]
private string _processArgs;
    private bool _isAnAugmentedFileAccess;
    public ReportedFileOperation Operation { get; private set; }
    public RequestedAccess RequestedAccess { get; private set; }
    public UInt32 ProcessId { get; private set; }
    public UInt32 Error { get; private set; }
    public DesiredAccess DesiredAccess { get; private set; }
    public FlagsAndAttributes FlagsAndAttributes { get; private set; }
    public string Path { get; private set; }
    [NullableAttribute("2")]
public string ProcessArgs { get; private set; }
    public bool IsAnAugmentedFileAccess { get; private set; }
    public FileAccessData(ReportedFileOperation operation, RequestedAccess requestedAccess, UInt32 processId, UInt32 error, DesiredAccess desiredAccess, FlagsAndAttributes flagsAndAttributes, string path, string processArgs, bool isAnAugmentedFileAccess);
    [IsReadOnlyAttribute]
public ReportedFileOperation get_Operation();
    private void set_Operation(ReportedFileOperation value);
    public RequestedAccess get_RequestedAccess();
    private void set_RequestedAccess(RequestedAccess value);
    [IsReadOnlyAttribute]
public UInt32 get_ProcessId();
    private void set_ProcessId(UInt32 value);
    [IsReadOnlyAttribute]
public UInt32 get_Error();
    private void set_Error(UInt32 value);
    [IsReadOnlyAttribute]
public DesiredAccess get_DesiredAccess();
    private void set_DesiredAccess(DesiredAccess value);
    [IsReadOnlyAttribute]
public FlagsAndAttributes get_FlagsAndAttributes();
    private void set_FlagsAndAttributes(FlagsAndAttributes value);
    [IsReadOnlyAttribute]
public string get_Path();
    private void set_Path(string value);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public string get_ProcessArgs();
    [NullableContextAttribute("2")]
private void set_ProcessArgs(string value);
    [IsReadOnlyAttribute]
public bool get_IsAnAugmentedFileAccess();
    private void set_IsAnAugmentedFileAccess(bool value);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
[FlagsAttribute]
[CLSCompliantAttribute("False")]
public enum Microsoft.Build.Experimental.FileAccess.FlagsAndAttributes : Enum {
    public UInt32 value__;
    public static FlagsAndAttributes FILE_ATTRIBUTE_READONLY;
    public static FlagsAndAttributes FILE_ATTRIBUTE_HIDDEN;
    public static FlagsAndAttributes FILE_ATTRIBUTE_SYSTEM;
    public static FlagsAndAttributes FILE_ATTRIBUTE_DIRECTORY;
    public static FlagsAndAttributes FILE_ATTRIBUTE_ARCHIVE;
    public static FlagsAndAttributes FILE_ATTRIBUTE_NORMAL;
    public static FlagsAndAttributes FILE_ATTRIBUTE_TEMPORARY;
    public static FlagsAndAttributes FILE_ATTRIBUTE_OFFLINE;
    public static FlagsAndAttributes FILE_ATTRIBUTE_ENCRYPED;
    public static FlagsAndAttributes FILE_FLAG_OPEN_NO_RECALL;
    public static FlagsAndAttributes FILE_FLAG_OPEN_REPARSE_POINT;
    public static FlagsAndAttributes FILE_FLAG_SESSION_AWARE;
    public static FlagsAndAttributes FILE_FLAG_POSIX_SEMANTICS;
    public static FlagsAndAttributes FILE_FLAG_BACKUP_SEMANTICS;
    public static FlagsAndAttributes FILE_FLAG_DELETE_ON_CLOSE;
    public static FlagsAndAttributes FILE_FLAG_SEQUENTIAL_SCAN;
    public static FlagsAndAttributes FILE_FLAG_RANDOM_ACCESS;
    public static FlagsAndAttributes FILE_FLAG_NO_BUFFERING;
    public static FlagsAndAttributes FILE_FLAG_OVERLAPPED;
    public static FlagsAndAttributes FILE_FLAG_WRITE_THROUGH;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CLSCompliantAttribute("False")]
public class Microsoft.Build.Experimental.FileAccess.ProcessData : ValueType {
    private string _processName;
    private UInt32 _processId;
    private UInt32 _parentProcessId;
    private DateTime _creationDateTime;
    private DateTime _exitDateTime;
    private UInt32 _exitCode;
    public string ProcessName { get; private set; }
    public UInt32 ProcessId { get; private set; }
    public UInt32 ParentProcessId { get; private set; }
    public DateTime CreationDateTime { get; private set; }
    public DateTime ExitDateTime { get; private set; }
    public UInt32 ExitCode { get; private set; }
    public ProcessData(string processName, UInt32 processId, UInt32 parentProcessId, DateTime creationDateTime, DateTime exitDateTime, UInt32 exitCode);
    public string get_ProcessName();
    private void set_ProcessName(string value);
    public UInt32 get_ProcessId();
    private void set_ProcessId(UInt32 value);
    public UInt32 get_ParentProcessId();
    private void set_ParentProcessId(UInt32 value);
    public DateTime get_CreationDateTime();
    private void set_CreationDateTime(DateTime value);
    public DateTime get_ExitDateTime();
    private void set_ExitDateTime(DateTime value);
    public UInt32 get_ExitCode();
    private void set_ExitCode(UInt32 value);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
}
public enum Microsoft.Build.Experimental.FileAccess.ReportedFileOperation : Enum {
    public byte value__;
    public static ReportedFileOperation Unknown;
    public static ReportedFileOperation CreateFile;
    public static ReportedFileOperation CreateProcess;
    public static ReportedFileOperation GetFileAttributes;
    public static ReportedFileOperation GetFileAttributesEx;
    public static ReportedFileOperation Process;
    public static ReportedFileOperation FindFirstFileEx;
    public static ReportedFileOperation FindNextFile;
    public static ReportedFileOperation CreateDirectory;
    public static ReportedFileOperation DeleteFile;
    public static ReportedFileOperation MoveFileSource;
    public static ReportedFileOperation MoveFileDestination;
    public static ReportedFileOperation SetFileInformationByHandleSource;
    public static ReportedFileOperation SetFileInformationByHandleDest;
    public static ReportedFileOperation ZwSetRenameInformationFileSource;
    public static ReportedFileOperation ZwSetRenameInformationFileDest;
    public static ReportedFileOperation ZwSetLinkInformationFile;
    public static ReportedFileOperation ZwSetDispositionInformationFile;
    public static ReportedFileOperation ZwSetModeInformationFile;
    public static ReportedFileOperation ZwSetFileNameInformationFileSource;
    public static ReportedFileOperation ZwSetFileNameInformationFileDest;
    public static ReportedFileOperation CopyFileSource;
    public static ReportedFileOperation CopyFileDestination;
    public static ReportedFileOperation CreateHardLinkSource;
    public static ReportedFileOperation CreateHardLinkDestination;
    public static ReportedFileOperation RemoveDirectory;
    public static ReportedFileOperation RemoveDirectorySource;
    public static ReportedFileOperation NtQueryDirectoryFile;
    public static ReportedFileOperation ZwQueryDirectoryFile;
    public static ReportedFileOperation NtCreateFile;
    public static ReportedFileOperation ZwCreateFile;
    public static ReportedFileOperation ZwOpenFile;
    public static ReportedFileOperation ChangedReadWriteToReadAccess;
    public static ReportedFileOperation FirstAllowWriteCheckInProcess;
    public static ReportedFileOperation StaticallyLinkedProcess;
    public static ReportedFileOperation ReparsePointTarget;
    public static ReportedFileOperation ReparsePointTargetCached;
    public static ReportedFileOperation CreateSymbolicLinkSource;
    public static ReportedFileOperation MoveFileWithProgressSource;
    public static ReportedFileOperation MoveFileWithProgressDest;
    public static ReportedFileOperation MultipleOperations;
    public static ReportedFileOperation ProcessExit;
    public static ReportedFileOperation MacLookup;
    public static ReportedFileOperation MacReadlink;
    public static ReportedFileOperation MacVNodeCreate;
    public static ReportedFileOperation KAuthMoveSource;
    public static ReportedFileOperation KAuthMoveDest;
    public static ReportedFileOperation KAuthCreateHardlinkSource;
    public static ReportedFileOperation KAuthCreateHardlinkDest;
    public static ReportedFileOperation KAuthCopySource;
    public static ReportedFileOperation KAuthCopyDest;
    public static ReportedFileOperation KAuthDeleteDir;
    public static ReportedFileOperation KAuthDeleteFile;
    public static ReportedFileOperation KAuthOpenDir;
    public static ReportedFileOperation KAuthReadFile;
    public static ReportedFileOperation KAuthCreateDir;
    public static ReportedFileOperation KAuthWriteFile;
    public static ReportedFileOperation KAuthClose;
    public static ReportedFileOperation KAuthCloseModified;
    public static ReportedFileOperation KAuthGetAttributes;
    public static ReportedFileOperation KAuthVNodeExecute;
    public static ReportedFileOperation KAuthVNodeWrite;
    public static ReportedFileOperation KAuthVNodeRead;
    public static ReportedFileOperation KAuthVNodeProbe;
    public static ReportedFileOperation MacVNodeWrite;
    public static ReportedFileOperation MacVNodeCloneSource;
    public static ReportedFileOperation MacVNodeCloneDest;
}
[FlagsAttribute]
public enum Microsoft.Build.Experimental.FileAccess.RequestedAccess : Enum {
    public byte value__;
    public static RequestedAccess None;
    public static RequestedAccess Read;
    public static RequestedAccess Write;
    public static RequestedAccess Probe;
    public static RequestedAccess Enumerate;
    public static RequestedAccess EnumerationProbe;
    public static RequestedAccess ReadWrite;
    public static RequestedAccess All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.MSBuildClient : object {
    private Dictionary`2<string, string> _serverEnvironmentVariables;
    private Nullable`1<UInt32> _originalConsoleMode;
    private string _msbuildLocation;
    private string _commandLine;
    private MSBuildClientExitResult _exitResult;
    private bool _buildFinished;
    private ServerNodeHandshake _handshake;
    private string _pipeName;
    private NamedPipeClientStream _nodeStream;
    private MemoryStream _packetMemoryStream;
    private BinaryWriter _binaryWriter;
    private int _numConsoleWritePackets;
    private long _sizeOfConsoleWritePackets;
    [NullableAttribute("2")]
private TargetConsoleConfiguration _consoleConfiguration;
    private MSBuildClientPacketPump _packetPump;
    public MSBuildClient(string commandLine, string msbuildLocation);
    private void CreateNodePipeStream();
    public MSBuildClientExitResult Execute(CancellationToken cancellationToken);
    public static bool ShutdownServer(CancellationToken cancellationToken);
    private bool TryShutdownServer(CancellationToken cancellationToken);
    private bool ServerIsBusyWithWaitAndRetry(int milliseconds);
    internal bool ServerIsRunning();
    private bool ServerWasBusy();
    private void ReadPacketsLoop(CancellationToken cancellationToken);
    private void ConfigureAndQueryConsoleProperties();
    private int QueryConsoleBufferWidth();
    private ConsoleColor QueryConsoleBackgroundColor();
    private bool TrySendPacket(Func`1<INodePacket> packetResolver);
    private bool TryLaunchServer();
    private bool TrySendBuildCommand();
    private bool TrySendCancelCommand();
    private bool TrySendShutdownCommand();
    private ServerNodeBuildCommand GetServerNodeBuildCommand();
    private ServerNodeHandshake GetHandshake();
    private void HandleCancellation();
    private void HandlePacketPumpCompleted(MSBuildClientPacketPump packetPump);
    private void HandlePacket(INodePacket packet);
    private void HandleServerNodeConsoleWrite(ServerNodeConsoleWrite consoleWrite);
    private void HandleServerNodeBuildResult(ServerNodeBuildResult response);
    private bool TryConnectToServer(int timeoutMilliseconds);
    private void WritePacket(Stream nodeStream, INodePacket packet);
    [CompilerGeneratedAttribute]
private INodePacket <TrySendBuildCommand>b__29_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.MSBuildClientExitResult : object {
    [CompilerGeneratedAttribute]
private MSBuildClientExitType <MSBuildClientExitType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildAppExitTypeString>k__BackingField;
    public MSBuildClientExitType MSBuildClientExitType { get; public set; }
    public string MSBuildAppExitTypeString { get; public set; }
    [CompilerGeneratedAttribute]
public MSBuildClientExitType get_MSBuildClientExitType();
    [CompilerGeneratedAttribute]
public void set_MSBuildClientExitType(MSBuildClientExitType value);
    [CompilerGeneratedAttribute]
public string get_MSBuildAppExitTypeString();
    [CompilerGeneratedAttribute]
public void set_MSBuildAppExitTypeString(string value);
}
public enum Microsoft.Build.Experimental.MSBuildClientExitType : Enum {
    public int value__;
    public static MSBuildClientExitType Success;
    public static MSBuildClientExitType ServerBusy;
    public static MSBuildClientExitType UnableToConnect;
    public static MSBuildClientExitType LaunchError;
    public static MSBuildClientExitType Unexpected;
    public static MSBuildClientExitType UnknownServerState;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.OutOfProcServerNode : object {
    private BuildCallback _buildFunction;
    private INodeEndpoint _nodeEndpoint;
    private NodePacketFactory _packetFactory;
    private ConcurrentQueue`1<INodePacket> _receivedPackets;
    private AutoResetEvent _packetReceivedEvent;
    private ManualResetEvent _shutdownEvent;
    private NodeEngineShutdownReason _shutdownReason;
    [NullableAttribute("2")]
private Exception _shutdownException;
    private bool _cancelRequested;
    private string _serverBusyMutexName;
    public OutOfProcServerNode(BuildCallback buildFunction);
    [NullableContextAttribute("2")]
public sealed virtual NodeEngineShutdownReason Run(Exception& shutdownException);
    private NodeEngineShutdownReason RunInternal(Exception& shutdownException, ServerNodeHandshake handshake);
    internal static string GetPipeName(ServerNodeHandshake handshake);
    internal static string GetRunningServerMutexName(ServerNodeHandshake handshake);
    internal static string GetBusyServerMutexName(ServerNodeHandshake handshake);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RegisterPacketHandler(NodePacketType packetType, NodePacketFactoryMethod factory, INodePacketHandler handler);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.UnregisterPacketHandler(NodePacketType packetType);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.DeserializeAndRoutePacket(int nodeId, NodePacketType packetType, ITranslator translator);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketFactory.RoutePacket(int nodeId, INodePacket packet);
    private sealed virtual override void Microsoft.Build.BackEnd.INodePacketHandler.PacketReceived(int node, INodePacket packet);
    [NullableContextAttribute("2")]
private NodeEngineShutdownReason HandleShutdown(Exception& exception);
    private void OnLinkStatusChanged(INodeEndpoint endpoint, LinkStatus status);
    private void SendPacket(INodePacket packet);
    private void HandlePacket(INodePacket packet);
    private void HandleServerShutdownCommand(NodeBuildComplete buildComplete);
    private void HandleBuildCancel();
    private void HandleServerNodeBuildCommandAsync(ServerNodeBuildCommand command);
    private void HandleServerNodeBuildCommand(ServerNodeBuildCommand command);
    [CompilerGeneratedAttribute]
private void <HandleServerNodeBuildCommand>b__29_0(string text);
    [CompilerGeneratedAttribute]
private void <HandleServerNodeBuildCommand>b__29_1(string text);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.ProjectCache.CacheContext : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <PluginSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectGraph <Graph>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphEntryPoint> <GraphEntryPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExePath>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private MSBuildFileSystemBase <FileSystem>k__BackingField;
    [NullableAttribute("1")]
public IReadOnlyDictionary`2<string, string> PluginSettings { get; }
    public ProjectGraph Graph { get; }
    public IReadOnlyCollection`1<ProjectGraphEntryPoint> GraphEntryPoints { get; }
    public string MSBuildExePath { get; }
    [NullableAttribute("1")]
public MSBuildFileSystemBase FileSystem { get; }
    [NullableContextAttribute("1")]
public CacheContext(IReadOnlyDictionary`2<string, string> pluginSettings, MSBuildFileSystemBase fileSystem, ProjectGraph graph, IReadOnlyCollection`1<ProjectGraphEntryPoint> graphEntryPoints);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_PluginSettings();
    [CompilerGeneratedAttribute]
public ProjectGraph get_Graph();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphEntryPoint> get_GraphEntryPoints();
    [CompilerGeneratedAttribute]
public string get_MSBuildExePath();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public MSBuildFileSystemBase get_FileSystem();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Experimental.ProjectCache.CacheRequest : object {
    [CompilerGeneratedAttribute]
private BuildSubmission <Submission>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public BuildSubmission Submission { get; public set; }
    public BuildRequestConfiguration Configuration { get; public set; }
    public CacheRequest(BuildSubmission Submission, BuildRequestConfiguration Configuration);
    [CompilerGeneratedAttribute]
protected CacheRequest(CacheRequest original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public BuildSubmission get_Submission();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Submission(BuildSubmission value);
    [CompilerGeneratedAttribute]
public BuildRequestConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Configuration(BuildRequestConfiguration value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CacheRequest left, CacheRequest right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CacheRequest left, CacheRequest right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(CacheRequest other);
    [CompilerGeneratedAttribute]
public virtual CacheRequest <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(BuildSubmission& Submission, BuildRequestConfiguration& Configuration);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.ProjectCache.CacheResult : object {
    [CompilerGeneratedAttribute]
private CacheResultType <ResultType>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResult <BuildResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyTargets <ProxyTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public CacheResultType ResultType { get; }
    public BuildResult BuildResult { get; }
    public ProxyTargets ProxyTargets { get; }
    internal Exception Exception { get; }
    private CacheResult(CacheResultType resultType, BuildResult buildResult, ProxyTargets proxyTargets);
    [NullableContextAttribute("1")]
private CacheResult(Exception exception);
    [CompilerGeneratedAttribute]
public CacheResultType get_ResultType();
    [CompilerGeneratedAttribute]
public BuildResult get_BuildResult();
    [CompilerGeneratedAttribute]
public ProxyTargets get_ProxyTargets();
    [CompilerGeneratedAttribute]
internal Exception get_Exception();
    [NullableContextAttribute("1")]
public static CacheResult IndicateCacheHit(BuildResult buildResult);
    [NullableContextAttribute("1")]
public static CacheResult IndicateCacheHit(ProxyTargets proxyTargets);
    [NullableContextAttribute("1")]
public static CacheResult IndicateCacheHit(IReadOnlyCollection`1<PluginTargetResult> targetResults);
    [NullableContextAttribute("1")]
public static CacheResult IndicateNonCacheHit(CacheResultType resultType);
    [NullableContextAttribute("1")]
internal static CacheResult IndicateException(Exception e);
    [NullableContextAttribute("1")]
private static BuildResult ConstructBuildResult(IReadOnlyCollection`1<PluginTargetResult> targetResults);
    [NullableContextAttribute("1")]
private static WorkUnitResult CreateWorkUnitResult(BuildResultCode resultCode);
    [NullableContextAttribute("1")]
private static TaskItem CreateTaskItem(ITaskItem2 taskItemInterface);
}
public enum Microsoft.Build.Experimental.ProjectCache.CacheResultType : Enum {
    public int value__;
    public static CacheResultType None;
    public static CacheResultType CacheHit;
    public static CacheResultType CacheMiss;
    public static CacheResultType CacheNotApplicable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Build.Experimental.ProjectCache.FileAccessContext : ValueType {
    [CompilerGeneratedAttribute]
private string <ProjectFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <GlobalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Targets>k__BackingField;
    public string ProjectFullPath { get; }
    public IReadOnlyDictionary`2<string, string> GlobalProperties { get; }
    public IReadOnlyList`1<string> Targets { get; }
    public FileAccessContext(string projectFullPath, IReadOnlyDictionary`2<string, string> globalProperties, IReadOnlyList`1<string> targets);
    [CompilerGeneratedAttribute]
public string get_ProjectFullPath();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Targets();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Build.Experimental.ProjectCache.PluginLoggerBase : object {
    public bool HasLoggedErrors { get; protected set; }
    public abstract virtual bool get_HasLoggedErrors();
    protected abstract virtual void set_HasLoggedErrors(bool value);
    public abstract virtual void LogMessage(string message, Nullable`1<MessageImportance> messageImportance);
    public abstract virtual void LogWarning(string warning);
    public abstract virtual void LogError(string error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.Build.Experimental.ProjectCache.PluginTargetResult : ValueType {
    [CompilerGeneratedAttribute]
private string <TargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ITaskItem2> <TaskItems>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildResultCode <ResultCode>k__BackingField;
    public string TargetName { get; }
    public IReadOnlyCollection`1<ITaskItem2> TaskItems { get; }
    public BuildResultCode ResultCode { get; }
    public PluginTargetResult(string targetName, IReadOnlyCollection`1<ITaskItem2> taskItems, BuildResultCode resultCode);
    [CompilerGeneratedAttribute]
public string get_TargetName();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ITaskItem2> get_TaskItems();
    [CompilerGeneratedAttribute]
public BuildResultCode get_ResultCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptor : object {
    [CompilerGeneratedAttribute]
private string <PluginAssemblyPath>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <PluginSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCachePluginBase <PluginInstance>k__BackingField;
    public string PluginAssemblyPath { get; }
    [NullableAttribute("1")]
public IReadOnlyDictionary`2<string, string> PluginSettings { get; }
    public ProjectCachePluginBase PluginInstance { get; }
    private ProjectCacheDescriptor(string pluginAssemblyPath, IReadOnlyDictionary`2<string, string> pluginSettings, ProjectCachePluginBase pluginInstance);
    [CompilerGeneratedAttribute]
public string get_PluginAssemblyPath();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_PluginSettings();
    [CompilerGeneratedAttribute]
public ProjectCachePluginBase get_PluginInstance();
    [NullableContextAttribute("1")]
public static ProjectCacheDescriptor FromAssemblyPath(string pluginAssemblyPath, IReadOnlyDictionary`2<string, string> pluginSettings);
    [NullableContextAttribute("1")]
public static ProjectCacheDescriptor FromInstance(ProjectCachePluginBase pluginInstance, IReadOnlyDictionary`2<string, string> pluginSettings);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Experimental.ProjectCache.ProjectCacheDescriptorEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static ProjectCacheDescriptorEqualityComparer <Instance>k__BackingField;
    public static ProjectCacheDescriptorEqualityComparer Instance { get; }
    private static ProjectCacheDescriptorEqualityComparer();
    [CompilerGeneratedAttribute]
public static ProjectCacheDescriptorEqualityComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ProjectCacheDescriptor x, ProjectCacheDescriptor y);
    public sealed virtual int GetHashCode(ProjectCacheDescriptor obj);
}
public class Microsoft.Build.Experimental.ProjectCache.ProjectCacheException : BuildExceptionBase {
    [CompilerGeneratedAttribute]
private bool <HasBeenLoggedByProjectCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    public bool HasBeenLoggedByProjectCache { get; }
    public string ErrorCode { get; }
    private ProjectCacheException(string message, Exception innerException, bool hasBeenLoggedByProjectCache, string errorCode);
    internal ProjectCacheException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public bool get_HasBeenLoggedByProjectCache();
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    internal static void ThrowAsUnhandledException(Exception innerException, string messageResourceName, String[] messageArgs);
    internal static void ThrowForErrorLoggedInsideTheProjectCache(string messageResourceName, String[] messageArgs);
    internal static void ThrowForMSBuildIssueWithTheProjectCache(string messageResourceName, String[] messageArgs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.Build.Experimental.ProjectCache.ProjectCachePluginBase : object {
    public abstract virtual Task BeginBuildAsync(CacheContext context, PluginLoggerBase logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, PluginLoggerBase logger, CancellationToken cancellationToken);
    public abstract virtual Task EndBuildAsync(PluginLoggerBase logger, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual void HandleFileAccess(FileAccessContext fileAccessContext, FileAccessData fileAccessData);
    [CLSCompliantAttribute("False")]
public virtual void HandleProcess(FileAccessContext fileAccessContext, ProcessData processData);
    public virtual Task HandleProjectFinishedAsync(FileAccessContext fileAccessContext, BuildResult buildResult, PluginLoggerBase logger, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Experimental.ProjectCache.ProjectCacheService : object {
    private static ParallelOptions s_parallelOptions;
    private static HashSet`1<string> s_projectSpecificPropertyNames;
    private BuildManager _buildManager;
    private IBuildComponentHost _componentHost;
    private ILoggingService _loggingService;
    private IFileAccessManager _fileAccessManager;
    private IConfigCache _configCache;
    [NullableAttribute("2")]
private ProjectCacheDescriptor _globalProjectCacheDescriptor;
    private ConcurrentDictionary`2<ProjectCacheDescriptor, Lazy`1<Task`1<ProjectCachePlugin>>> _projectCachePlugins;
    private ConcurrentDictionary`2<BuildRequestConfiguration, IReadOnlyDictionary`2<string, string>> _globalPropertiesPerConfiguration;
    private bool _isVsScenario;
    private bool _isDisposed;
    public ProjectCacheService(BuildManager buildManager, ILoggingService loggingService, IFileAccessManager fileAccessManager, IConfigCache configCache, ProjectCacheDescriptor globalProjectCacheDescriptor);
    private static ProjectCacheService();
    public void InitializePluginsForGraph(ProjectGraph projectGraph, CancellationToken cancellationToken);
    public void InitializePluginsForVsScenario(IEnumerable`1<ProjectCacheDescriptor> projectCacheDescriptors, BuildRequestConfiguration buildRequestConfiguration, CancellationToken cancellationToken);
    private Task`1<ProjectCachePlugin> GetProjectCachePluginAsync(ProjectCacheDescriptor projectCacheDescriptor, ProjectGraph projectGraph, BuildRequestConfiguration buildRequestConfiguration, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.Build.Experimental.ProjectCache.ProjectCacheService/<GetProjectCacheDescriptors>d__18")]
private IEnumerable`1<ProjectCacheDescriptor> GetProjectCacheDescriptors(ProjectInstance projectInstance);
    [AsyncStateMachineAttribute("Microsoft.Build.Experimental.ProjectCache.ProjectCacheService/<CreateAndInitializePluginAsync>d__19")]
private Task`1<ProjectCachePlugin> CreateAndInitializePluginAsync(ProjectCacheDescriptor projectCacheDescriptor, ProjectGraph projectGraph, BuildRequestConfiguration buildRequestConfiguration, CancellationToken cancellationToken);
    private FileAccessContext GetFileAccessContext(BuildRequest buildRequest);
    private IReadOnlyDictionary`2<string, string> GetGlobalProperties(BuildRequestConfiguration configuration);
    private static ProjectCachePluginBase GetPluginInstanceFromType(Type pluginType);
    private static Type GetTypeFromAssemblyPath(string pluginAssemblyPath);
    public bool ShouldUseCache(BuildRequestConfiguration buildRequestConfiguration);
    private bool IsDesignTimeBuild(BuildRequestConfiguration buildRequestConfiguration);
    public void PostCacheRequest(CacheRequest cacheRequest, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Build.Experimental.ProjectCache.ProjectCacheService/<GetCacheResultAsync>d__27")]
private Task`1<CacheResult> GetCacheResultAsync(BuildRequestData buildRequest, BuildRequestConfiguration buildRequestConfiguration, BuildEventContext buildEventContext, CancellationToken cancellationToken);
    private IReadOnlyCollection`1<ProjectGraphEntryPoint> GetGraphEntryPoints(BuildRequestConfiguration configuration);
    [AsyncStateMachineAttribute("Microsoft.Build.Experimental.ProjectCache.ProjectCacheService/<HandleBuildResultAsync>d__29")]
public Task HandleBuildResultAsync(BuildRequestConfiguration requestConfiguration, BuildResult buildResult, BuildEventContext buildEventContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Build.Experimental.ProjectCache.ProjectCacheService/<DisposeAsync>d__30")]
public sealed virtual ValueTask DisposeAsync();
    private void EnsureNotDisposed();
    private static void HandlePluginException(Exception e, string apiExceptionWasThrownFrom);
    [CompilerGeneratedAttribute]
internal static Assembly <GetTypeFromAssemblyPath>g__LoadAssembly|23_0(string resolverPath);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<Type> <GetTypeFromAssemblyPath>g__GetTypes|23_1(Assembly assembly);
    [CompilerGeneratedAttribute]
internal static IReadOnlyCollection`1<ProjectGraphEntryPoint> <GetGraphEntryPoints>g__GenerateGraphEntryPointsFromSolutionConfigurationXml|28_0(string solutionConfigurationXml, string definingProjectPath, Dictionary`2<string, string> templateGlobalProperties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Experimental.ProjectCache.ProxyTargets : object {
    private Dictionary`2<string, string> _proxyTargetToRealTargetMap;
    public IReadOnlyDictionary`2<string, string> ProxyTargetToRealTargetMap { get; }
    public ProxyTargets(IReadOnlyDictionary`2<string, string> proxyTargetToRealTargetMap);
    public IReadOnlyDictionary`2<string, string> get_ProxyTargetToRealTargetMap();
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static ProxyTargets FactoryForDeserialization(ITranslator translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.FileAccesses.FileAccessManager : object {
    private static string FileAccessCompletionPrefix;
    [NullableAttribute("2")]
private IScheduler _scheduler;
    [NullableAttribute("2")]
private IConfigCache _configCache;
    private object _handlersWriteLock;
    private Handlers[] _handlers;
    [NullableAttribute("2")]
private string _tempDirectory;
    private ConcurrentDictionary`2<int, ManualResetEventSlim> _fileAccessCompletionWaitHandles;
    private static FileAccessManager();
    public static IBuildComponent CreateComponent(BuildComponentType type);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
    public sealed virtual void ReportProcess(ProcessData processData, int nodeId);
    public sealed virtual HandlerRegistration RegisterHandlers(Action`2<BuildRequest, FileAccessData> fileAccessHandler, Action`2<BuildRequest, ProcessData> processHandler);
    private void UnregisterHandlers(Handlers handlersToRemove);
    [SupportedOSPlatform("windows")]
public static void NotifyFileAccessCompletion(int globalRequestId);
    public sealed virtual void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private BuildRequest GetBuildRequest(int nodeId);
}
internal class Microsoft.Build.FileAccesses.FileAccessReport : object {
    private FileAccessData _fileAccessData;
    public NodePacketType Type { get; }
    internal FileAccessData FileAccessData { get; }
    internal FileAccessReport(FileAccessData fileAccessData);
    [NullableContextAttribute("1")]
private FileAccessReport(ITranslator translator);
    public sealed virtual NodePacketType get_Type();
    [NullableContextAttribute("1")]
public sealed virtual void Translate(ITranslator translator);
    internal FileAccessData get_FileAccessData();
    [NullableContextAttribute("1")]
internal static INodePacket FactoryForDeserialization(ITranslator translator);
}
[NullableContextAttribute("1")]
internal interface Microsoft.Build.FileAccesses.IFileAccessManager {
    public abstract virtual void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
    public abstract virtual void ReportProcess(ProcessData processData, int nodeId);
    public abstract virtual HandlerRegistration RegisterHandlers(Action`2<BuildRequest, FileAccessData> fileAccessHandler, Action`2<BuildRequest, ProcessData> processHandler);
    public abstract virtual void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.FileAccesses.OutOfProcNodeFileAccessManager : object {
    private Action`1<INodePacket> _sendPacket;
    private OutOfProcNodeFileAccessManager(Action`1<INodePacket> sendPacket);
    public static IBuildComponent CreateComponent(BuildComponentType type, Action`1<INodePacket> sendPacket);
    public sealed virtual void InitializeComponent(IBuildComponentHost host);
    public sealed virtual void ShutdownComponent();
    public sealed virtual void ReportFileAccess(FileAccessData fileAccessData, int nodeId);
    public sealed virtual void ReportProcess(ProcessData processData, int nodeId);
    public sealed virtual HandlerRegistration RegisterHandlers(Action`2<BuildRequest, FileAccessData> fileAccessHandler, Action`2<BuildRequest, ProcessData> processHandler);
    public sealed virtual void WaitForFileAccessReportCompletion(int globalRequestId, CancellationToken cancellationToken);
}
internal class Microsoft.Build.FileAccesses.ProcessReport : object {
    private ProcessData _processData;
    public NodePacketType Type { get; }
    internal ProcessData ProcessData { get; }
    internal ProcessReport(ProcessData processData);
    [NullableContextAttribute("1")]
private ProcessReport(ITranslator translator);
    public sealed virtual NodePacketType get_Type();
    internal ProcessData get_ProcessData();
    [NullableContextAttribute("1")]
internal static INodePacket FactoryForDeserialization(ITranslator translator);
    [NullableContextAttribute("1")]
public sealed virtual void Translate(ITranslator translator);
}
internal class Microsoft.Build.FileSystem.DirectoryCacheFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private IDirectoryCache _directoryCache;
    public DirectoryCacheFileSystemWrapper(IFileSystem fileSystem, IDirectoryCache directoryCache);
    public sealed virtual bool FileOrDirectoryExists(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private IEnumerable`1<string> EnumerateFullFileSystemPaths(string path, string searchPattern, bool includeFiles, bool includeDirectories);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
}
public class Microsoft.Build.FileSystem.FindPredicate : MulticastDelegate {
    public FindPredicate(object object, IntPtr method);
    public virtual bool Invoke(ReadOnlySpan`1& fileName);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1& fileName, AsyncCallback callback, object object);
    public virtual bool EndInvoke(ReadOnlySpan`1& fileName, IAsyncResult result);
}
public class Microsoft.Build.FileSystem.FindTransform`1 : MulticastDelegate {
    public FindTransform`1(object object, IntPtr method);
    public virtual TResult Invoke(ReadOnlySpan`1& fileName);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1& fileName, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(ReadOnlySpan`1& fileName, IAsyncResult result);
}
public interface Microsoft.Build.FileSystem.IDirectoryCache {
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual IEnumerable`1<TResult> EnumerateFiles(string path, string pattern, FindPredicate predicate, FindTransform`1<TResult> transform);
    public abstract virtual IEnumerable`1<TResult> EnumerateDirectories(string path, string pattern, FindPredicate predicate, FindTransform`1<TResult> transform);
}
public interface Microsoft.Build.FileSystem.IDirectoryCacheFactory {
    public abstract virtual IDirectoryCache GetDirectoryCacheForEvaluation(int evaluationId);
}
public abstract class Microsoft.Build.FileSystem.MSBuildFileSystemBase : object {
    public virtual TextReader ReadFile(string path);
    public virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public virtual string ReadFileAllText(string path);
    public virtual Byte[] ReadFileAllBytes(string path);
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public virtual FileAttributes GetAttributes(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
}
public class Microsoft.Build.Globbing.CompositeGlob : object {
    private ImmutableArray`1<IMSBuildGlob> _globs;
    public IEnumerable`1<IMSBuildGlob> Globs { get; }
    public CompositeGlob(IEnumerable`1<IMSBuildGlob> globs);
    public CompositeGlob(IMSBuildGlob[] globs);
    internal CompositeGlob(IMSBuildGlob glob1, IMSBuildGlob glob2);
    private CompositeGlob(ImmutableArray`1<IMSBuildGlob> globs);
    public IEnumerable`1<IMSBuildGlob> get_Globs();
    public sealed virtual bool IsMatch(string stringToMatch);
    public static IMSBuildGlob Create(IEnumerable`1<IMSBuildGlob> globs);
}
[ExtensionAttribute]
public static class Microsoft.Build.Globbing.Extensions.MSBuildGlobExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<MSBuildGlob> GetParsedGlobs(IMSBuildGlob glob);
}
public interface Microsoft.Build.Globbing.IMSBuildGlob {
    public abstract virtual bool IsMatch(string stringToMatch);
}
public class Microsoft.Build.Globbing.MSBuildGlob : object {
    private static WeakValueDictionary`2<string, Regex> s_regexCache;
    private Lazy`1<GlobState> _state;
    internal string TestOnlyGlobRoot { get; }
    internal string TestOnlyFileSpec { get; }
    internal bool TestOnlyNeedsRecursion { get; }
    internal Regex TestOnlyRegex { get; }
    public string FixedDirectoryPart { get; }
    public string WildcardDirectoryPart { get; }
    public string FilenamePart { get; }
    public bool IsLegal { get; }
    private MSBuildGlob(Lazy`1<GlobState> state);
    private static MSBuildGlob();
    internal string get_TestOnlyGlobRoot();
    internal string get_TestOnlyFileSpec();
    internal bool get_TestOnlyNeedsRecursion();
    internal Regex get_TestOnlyRegex();
    public string get_FixedDirectoryPart();
    public string get_WildcardDirectoryPart();
    public string get_FilenamePart();
    public bool get_IsLegal();
    public sealed virtual bool IsMatch(string stringToMatch);
    public MatchInfoResult MatchInfo(string stringToMatch);
    private string NormalizeMatchInput(string stringToMatch);
    public static MSBuildGlob Parse(string globRoot, string fileSpec);
    private static string NormalizeTheFixedDirectoryPartAgainstTheGlobRoot(string fixedDirPart, string globRoot);
    public static MSBuildGlob Parse(string fileSpec);
}
public class Microsoft.Build.Globbing.MSBuildGlobWithGaps : object {
    [CompilerGeneratedAttribute]
private IMSBuildGlob <MainGlob>k__BackingField;
    [CompilerGeneratedAttribute]
private IMSBuildGlob <Gaps>k__BackingField;
    public IMSBuildGlob MainGlob { get; }
    public IMSBuildGlob Gaps { get; }
    internal MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IMSBuildGlob gaps);
    public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IEnumerable`1<IMSBuildGlob> gaps);
    public MSBuildGlobWithGaps(IMSBuildGlob mainGlob, IMSBuildGlob[] gaps);
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_MainGlob();
    [CompilerGeneratedAttribute]
public IMSBuildGlob get_Gaps();
    public sealed virtual bool IsMatch(string stringToMatch);
}
internal abstract class Microsoft.Build.Globbing.Visitor.GlobVisitor : object {
    public void Visit(IMSBuildGlob glob);
    protected virtual void VisitGlobWithGaps(MSBuildGlobWithGaps globWithGaps);
    protected virtual void VisitCompositeGlob(CompositeGlob compositeGlob);
    protected virtual void VisitMSBuildGlob(MSBuildGlob msbuildGlob);
}
internal class Microsoft.Build.Globbing.Visitor.ParsedGlobCollector : GlobVisitor {
    private Builder<MSBuildGlob> _collectedGlobs;
    public ImmutableList`1<MSBuildGlob> CollectedGlobs { get; }
    public ImmutableList`1<MSBuildGlob> get_CollectedGlobs();
    protected virtual void VisitMSBuildGlob(MSBuildGlob msbuildGlob);
}
internal class Microsoft.Build.Graph.GraphBuilder : object {
    internal static string SolutionItemReference;
    private static int ImplicitWorkerCount;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphNode> <ProjectNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphNode> <RootNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphNode> <EntryPointNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphEdges <Edges>k__BackingField;
    private List`1<ConfigurationMetadata> _entryPointConfigurationMetadata;
    private ParallelWorkSet`2<ConfigurationMetadata, ParsedProject> _graphWorkSet;
    private ProjectCollection _projectCollection;
    private ProjectInterpretation _projectInterpretation;
    private ProjectInstanceFactoryFunc _projectInstanceFactory;
    private IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> _solutionDependencies;
    public IReadOnlyCollection`1<ProjectGraphNode> ProjectNodes { get; private set; }
    public IReadOnlyCollection`1<ProjectGraphNode> RootNodes { get; private set; }
    public IReadOnlyCollection`1<ProjectGraphNode> EntryPointNodes { get; private set; }
    public GraphEdges Edges { get; private set; }
    public GraphBuilder(IEnumerable`1<ProjectGraphEntryPoint> entryPoints, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory, ProjectInterpretation projectInterpretation, int degreeOfParallelism, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphNode> get_ProjectNodes();
    [CompilerGeneratedAttribute]
private void set_ProjectNodes(IReadOnlyCollection`1<ProjectGraphNode> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphNode> get_RootNodes();
    [CompilerGeneratedAttribute]
private void set_RootNodes(IReadOnlyCollection`1<ProjectGraphNode> value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphNode> get_EntryPointNodes();
    [CompilerGeneratedAttribute]
private void set_EntryPointNodes(IReadOnlyCollection`1<ProjectGraphNode> value);
    [CompilerGeneratedAttribute]
public GraphEdges get_Edges();
    [CompilerGeneratedAttribute]
private void set_Edges(GraphEdges value);
    public void BuildGraph();
    private static IReadOnlyCollection`1<ProjectGraphNode> GetGraphRoots(IReadOnlyCollection`1<ProjectGraphNode> entryPointNodes);
    private void AddEdges(Dictionary`2<ConfigurationMetadata, ParsedProject> allParsedProjects);
    private void AddEdgesFromProjectReferenceItems(Dictionary`2<ConfigurationMetadata, ParsedProject> allParsedProjects, GraphEdges edges);
    private static void AddEdgesFromSolution(IReadOnlyDictionary`2<ConfigurationMetadata, ParsedProject> allParsedProjects, IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> solutionDependencies, GraphEdges edges);
    private ValueTuple`2<IReadOnlyCollection`1<ProjectGraphEntryPoint>, IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>>> ExpandSolutionIfPresent(IReadOnlyCollection`1<ProjectGraphEntryPoint> entryPoints);
    private static List`1<ConfigurationMetadata> AddGraphBuildPropertyToEntryPoints(IEnumerable`1<ProjectGraphEntryPoint> entryPoints);
    private void DetectCycles(IReadOnlyCollection`1<ProjectGraphNode> entryPointNodes, ProjectInterpretation projectInterpretation, Dictionary`2<ConfigurationMetadata, ParsedProject> allParsedProjects);
    private ParsedProject ParseProject(ConfigurationMetadata configurationMetadata);
    private Dictionary`2<ConfigurationMetadata, ParsedProject> FindGraphNodes();
    private void SubmitProjectForParsing(ConfigurationMetadata projectToEvaluate);
    private List`1<ReferenceInfo> ParseReferences(ProjectGraphNode parsedProject);
    internal static string FormatCircularDependencyError(List`1<string> projectsInCycle);
    private static PropertyDictionary`1<ProjectPropertyInstance> CreatePropertyDictionary(IDictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
internal static HashSet`1<ProjectGraphNode> <AddEdgesFromProjectReferenceItems>g__GetTransitiveProjectReferencesExcludingSelf|28_0(ParsedProject parsedProject, <>c__DisplayClass28_0& );
    [CompilerGeneratedAttribute]
internal static IReadOnlyCollection`1<ProjectInSolution> <ExpandSolutionIfPresent>g__GetBuildableProjects|30_2(SolutionFile solutionFile);
    [CompilerGeneratedAttribute]
internal static SolutionConfigurationInSolution <ExpandSolutionIfPresent>g__SelectSolutionConfiguration|30_3(SolutionFile solutionFile, IDictionary`2<string, string> globalProperties);
    [CompilerGeneratedAttribute]
internal static ProjectConfigurationInSolution <ExpandSolutionIfPresent>g__SelectProjectConfiguration|30_4(SolutionConfigurationInSolution solutionConfig, IReadOnlyDictionary`2<string, ProjectConfigurationInSolution> projectConfigs);
    [CompilerGeneratedAttribute]
internal static IReadOnlyDictionary`2<string, IReadOnlyCollection`1<string>> <ExpandSolutionIfPresent>g__GetSolutionDependencies|30_5(SolutionFile solutionFile);
    [CompilerGeneratedAttribute]
internal static void <AddGraphBuildPropertyToEntryPoints>g__AddGraphBuildGlobalVariable|31_0(PropertyDictionary`1<ProjectPropertyInstance> globalPropertyDictionary);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<bool, List`1<string>> <DetectCycles>g__VisitNode|32_0(ProjectGraphNode node, IDictionary`2<ProjectGraphNode, NodeVisitationState> nodeState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Graph.GraphBuildOptions : object {
    [CompilerGeneratedAttribute]
private bool <Build>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public bool Build { get; public set; }
    [CompilerGeneratedAttribute]
protected GraphBuildOptions(GraphBuildOptions original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_Build();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Build(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(GraphBuildOptions left, GraphBuildOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(GraphBuildOptions left, GraphBuildOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(GraphBuildOptions other);
    [CompilerGeneratedAttribute]
public virtual GraphBuildOptions <Clone>$();
}
public class Microsoft.Build.Graph.GraphBuildRequestData : object {
    [CompilerGeneratedAttribute]
private ProjectGraph <ProjectGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ProjectGraphEntryPoint> <ProjectGraphEntryPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <TargetNames>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestDataFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphBuildOptions <GraphBuildOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private HostServices <HostServices>k__BackingField;
    public ProjectGraph ProjectGraph { get; }
    public IEnumerable`1<ProjectGraphEntryPoint> ProjectGraphEntryPoints { get; }
    public ICollection`1<string> TargetNames { get; }
    public BuildRequestDataFlags Flags { get; }
    public GraphBuildOptions GraphBuildOptions { get; }
    public HostServices HostServices { get; }
    public GraphBuildRequestData(ProjectGraph projectGraph, ICollection`1<string> targetsToBuild);
    public GraphBuildRequestData(ProjectGraph projectGraph, ICollection`1<string> targetsToBuild, HostServices hostServices);
    public GraphBuildRequestData(ProjectGraph projectGraph, ICollection`1<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public GraphBuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, ICollection`1<string> targetsToBuild, HostServices hostServices);
    public GraphBuildRequestData(string projectFullPath, IDictionary`2<string, string> globalProperties, ICollection`1<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection`1<string> targetsToBuild);
    public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection`1<string> targetsToBuild, HostServices hostServices);
    public GraphBuildRequestData(ProjectGraphEntryPoint projectGraphEntryPoint, ICollection`1<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public GraphBuildRequestData(IEnumerable`1<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection`1<string> targetsToBuild);
    public GraphBuildRequestData(IEnumerable`1<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection`1<string> targetsToBuild, HostServices hostServices);
    public GraphBuildRequestData(IEnumerable`1<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection`1<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags);
    public GraphBuildRequestData(IEnumerable`1<ProjectGraphEntryPoint> projectGraphEntryPoints, ICollection`1<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions);
    private GraphBuildRequestData(ICollection`1<string> targetsToBuild, HostServices hostServices, BuildRequestDataFlags flags, GraphBuildOptions graphBuildOptions);
    [CompilerGeneratedAttribute]
public ProjectGraph get_ProjectGraph();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ProjectGraphEntryPoint> get_ProjectGraphEntryPoints();
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_TargetNames();
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_Flags();
    [CompilerGeneratedAttribute]
public GraphBuildOptions get_GraphBuildOptions();
    [CompilerGeneratedAttribute]
public HostServices get_HostServices();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Graph.GraphBuildResult : object {
    [CompilerGeneratedAttribute]
private int <SubmissionId>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<ProjectGraphNode, BuildResult> <ResultsByNode>k__BackingField;
    public int SubmissionId { get; }
    public bool CircularDependency { get; }
    public Exception Exception { get; internal set; }
    public BuildResultCode OverallResult { get; }
    public IReadOnlyDictionary`2<ProjectGraphNode, BuildResult> ResultsByNode { get; }
    public BuildResult Item { get; }
    internal GraphBuildResult(int submissionId, IReadOnlyDictionary`2<ProjectGraphNode, BuildResult> resultsByNode);
    internal GraphBuildResult(int submissionId, Exception exception);
    [CompilerGeneratedAttribute]
public int get_SubmissionId();
    public bool get_CircularDependency();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
internal void set_Exception(Exception value);
    public BuildResultCode get_OverallResult();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<ProjectGraphNode, BuildResult> get_ResultsByNode();
    public BuildResult get_Item(ProjectGraphNode node);
}
public class Microsoft.Build.Graph.GraphBuildSubmission : object {
    private GraphBuildSubmissionCompleteCallback _completionCallback;
    private ManualResetEvent _completionEvent;
    private int _completionInvoked;
    [CompilerGeneratedAttribute]
private BuildManager <BuildManager>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubmissionId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AsyncContext>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphBuildResult <BuildResult>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphBuildRequestData <BuildRequestData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStarted>k__BackingField;
    public BuildManager BuildManager { get; }
    public int SubmissionId { get; }
    public object AsyncContext { get; private set; }
    public WaitHandle WaitHandle { get; }
    public bool IsCompleted { get; }
    public GraphBuildResult BuildResult { get; internal set; }
    internal GraphBuildRequestData BuildRequestData { get; }
    internal bool IsStarted { get; internal set; }
    internal GraphBuildSubmission(BuildManager buildManager, int submissionId, GraphBuildRequestData requestData);
    [CompilerGeneratedAttribute]
public BuildManager get_BuildManager();
    [CompilerGeneratedAttribute]
public int get_SubmissionId();
    [CompilerGeneratedAttribute]
public object get_AsyncContext();
    [CompilerGeneratedAttribute]
private void set_AsyncContext(object value);
    public WaitHandle get_WaitHandle();
    public bool get_IsCompleted();
    [CompilerGeneratedAttribute]
public GraphBuildResult get_BuildResult();
    [CompilerGeneratedAttribute]
internal void set_BuildResult(GraphBuildResult value);
    [CompilerGeneratedAttribute]
internal GraphBuildRequestData get_BuildRequestData();
    [CompilerGeneratedAttribute]
internal bool get_IsStarted();
    [CompilerGeneratedAttribute]
internal void set_IsStarted(bool value);
    public GraphBuildResult Execute();
    public void ExecuteAsync(GraphBuildSubmissionCompleteCallback callback, object context);
    internal void CompleteResults(GraphBuildResult result);
    [CompilerGeneratedAttribute]
private void <CompleteResults>g__Callback|31_0(object state);
}
public class Microsoft.Build.Graph.GraphBuildSubmissionCompleteCallback : MulticastDelegate {
    public GraphBuildSubmissionCompleteCallback(object object, IntPtr method);
    public virtual void Invoke(GraphBuildSubmission submission);
    public virtual IAsyncResult BeginInvoke(GraphBuildSubmission submission, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Graph.ParallelWorkSet`2 : object {
    private CancellationToken _cancellationToken;
    private int _degreeOfParallelism;
    private ConcurrentDictionary`2<TKey, Lazy`1<TResult>> _inProgressOrCompletedWork;
    private bool _isSchedulingCompleted;
    private long _pendingCount;
    private ConcurrentQueue`1<Lazy`1<TResult>> _queue;
    private SemaphoreSlim _semaphore;
    private List`1<Task> _tasks;
    private List`1<Exception> _exceptions;
    internal Dictionary`2<TKey, TResult> CompletedWork { get; }
    internal bool IsCompleted { get; private set; }
    internal ParallelWorkSet`2(int degreeOfParallelism, IEqualityComparer`1<TKey> comparer, CancellationToken cancellationToken);
    internal Dictionary`2<TKey, TResult> get_CompletedWork();
    internal bool get_IsCompleted();
    private void set_IsCompleted(bool value);
    internal void AddWork(TKey key, Func`1<TResult> workFunc);
    internal void WaitForAllWorkAndComplete();
    private Task CreateProcessorItemTask();
    private void ExecuteWorkItem();
    [AsyncStateMachineAttribute("Microsoft.Build.Graph.ParallelWorkSet`2/<<CreateProcessorItemTask>b__17_0>d")]
[CompilerGeneratedAttribute]
private Task <CreateProcessorItemTask>b__17_0();
}
[IsReadOnlyAttribute]
internal class Microsoft.Build.Graph.ParsedProject : ValueType {
    [CompilerGeneratedAttribute]
private ConfigurationMetadata <ConfigurationMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectGraphNode <GraphNode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ReferenceInfo> <ReferenceInfos>k__BackingField;
    public ConfigurationMetadata ConfigurationMetadata { get; }
    public ProjectGraphNode GraphNode { get; }
    public List`1<ReferenceInfo> ReferenceInfos { get; }
    public ParsedProject(ConfigurationMetadata configurationMetadata, ProjectGraphNode graphNode, List`1<ReferenceInfo> referenceInfos);
    [CompilerGeneratedAttribute]
public ConfigurationMetadata get_ConfigurationMetadata();
    [CompilerGeneratedAttribute]
public ProjectGraphNode get_GraphNode();
    [CompilerGeneratedAttribute]
public List`1<ReferenceInfo> get_ReferenceInfos();
}
[DebuggerDisplayAttribute("{DebuggerDisplayString()}")]
public class Microsoft.Build.Graph.ProjectGraph : object {
    private Lazy`1<IReadOnlyCollection`1<ProjectGraphNode>> _projectNodesTopologicallySorted;
    [CompilerGeneratedAttribute]
private GraphEdges <Edges>k__BackingField;
    [CompilerGeneratedAttribute]
private GraphConstructionMetrics <ConstructionMetrics>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphNode> <EntryPointNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphNode> <ProjectNodes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<ProjectGraphNode> <GraphRoots>k__BackingField;
    private GraphEdges Edges { get; }
    internal GraphEdges TestOnly_Edges { get; }
    public GraphConstructionMetrics ConstructionMetrics { get; private set; }
    public IReadOnlyCollection`1<ProjectGraphNode> EntryPointNodes { get; }
    public IReadOnlyCollection`1<ProjectGraphNode> ProjectNodes { get; }
    public IReadOnlyCollection`1<ProjectGraphNode> ProjectNodesTopologicallySorted { get; }
    public IReadOnlyCollection`1<ProjectGraphNode> GraphRoots { get; }
    public ProjectGraph(string entryProjectFile);
    public ProjectGraph(IEnumerable`1<string> entryProjectFiles);
    public ProjectGraph(string entryProjectFile, ProjectCollection projectCollection);
    public ProjectGraph(IEnumerable`1<string> entryProjectFiles, ProjectCollection projectCollection);
    public ProjectGraph(string entryProjectFile, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory);
    public ProjectGraph(string entryProjectFile, IDictionary`2<string, string> globalProperties);
    public ProjectGraph(IEnumerable`1<string> entryProjectFiles, IDictionary`2<string, string> globalProperties);
    public ProjectGraph(string entryProjectFile, IDictionary`2<string, string> globalProperties, ProjectCollection projectCollection);
    public ProjectGraph(IEnumerable`1<string> entryProjectFiles, IDictionary`2<string, string> globalProperties, ProjectCollection projectCollection);
    public ProjectGraph(ProjectGraphEntryPoint entryPoint);
    public ProjectGraph(IEnumerable`1<ProjectGraphEntryPoint> entryPoints);
    public ProjectGraph(ProjectGraphEntryPoint entryPoint, ProjectCollection projectCollection);
    public ProjectGraph(IEnumerable`1<ProjectGraphEntryPoint> entryPoints, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory);
    public ProjectGraph(IEnumerable`1<ProjectGraphEntryPoint> entryPoints, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory, CancellationToken cancellationToken);
    public ProjectGraph(IEnumerable`1<ProjectGraphEntryPoint> entryPoints, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory, int degreeOfParallelism, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private GraphEdges get_Edges();
    internal GraphEdges get_TestOnly_Edges();
    [CompilerGeneratedAttribute]
public GraphConstructionMetrics get_ConstructionMetrics();
    [CompilerGeneratedAttribute]
private void set_ConstructionMetrics(GraphConstructionMetrics value);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphNode> get_EntryPointNodes();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphNode> get_ProjectNodes();
    public IReadOnlyCollection`1<ProjectGraphNode> get_ProjectNodesTopologicallySorted();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<ProjectGraphNode> get_GraphRoots();
    internal string ToDot(IReadOnlyDictionary`2<ProjectGraphNode, ImmutableList`1<string>> targetsPerNode);
    internal string ToDot(Func`2<ProjectGraphNode, string> nodeIdProvider, IReadOnlyDictionary`2<ProjectGraphNode, ImmutableList`1<string>> targetsPerNode);
    private string DebuggerDisplayString();
    private static IReadOnlyCollection`1<ProjectGraphNode> TopologicalSort(IReadOnlyCollection`1<ProjectGraphNode> graphRoots, IReadOnlyCollection`1<ProjectGraphNode> graphNodes);
    public IReadOnlyDictionary`2<ProjectGraphNode, ImmutableList`1<string>> GetTargetLists(ICollection`1<string> entryProjectTargets);
    private static ImmutableList`1<string> ExpandDefaultTargets(ImmutableList`1<string> targets, List`1<string> defaultTargets, ProjectItemInstance graphEdge);
    internal static ProjectInstance DefaultProjectInstanceFactory(string projectPath, Dictionary`2<string, string> globalProperties, ProjectCollection projectCollection);
    [CompilerGeneratedAttribute]
internal static string <ToDot>g__GetNodeId|39_0(ProjectGraphNode node, <>c__DisplayClass39_0& );
    [CompilerGeneratedAttribute]
internal static string <ToDot>g__GetTargetListString|39_1(ProjectGraphNode node, <>c__DisplayClass39_0& );
    [CompilerGeneratedAttribute]
internal static void <GetTargetLists>g__ThrowOnEmptyTargetNames|42_2(ICollection`1<string> targetNames);
}
public class Microsoft.Build.Graph.ProjectGraphEntryPoint : ValueType {
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <GlobalProperties>k__BackingField;
    public string ProjectFile { get; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ProjectGraphEntryPoint(string projectFile);
    public ProjectGraphEntryPoint(string projectFile, IDictionary`2<string, string> globalProperties);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_ProjectFile();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    [IteratorStateMachineAttribute("Microsoft.Build.Graph.ProjectGraphEntryPoint/<CreateEnumerable>d__8")]
internal static IEnumerable`1<ProjectGraphEntryPoint> CreateEnumerable(IEnumerable`1<string> entryProjectFiles);
    [IteratorStateMachineAttribute("Microsoft.Build.Graph.ProjectGraphEntryPoint/<CreateEnumerable>d__9")]
internal static IEnumerable`1<ProjectGraphEntryPoint> CreateEnumerable(IEnumerable`1<string> entryProjectFiles, IDictionary`2<string, string> globalProperties);
    [IsReadOnlyAttribute]
[IteratorStateMachineAttribute("Microsoft.Build.Graph.ProjectGraphEntryPoint/<AsEnumerable>d__10")]
internal IEnumerable`1<ProjectGraphEntryPoint> AsEnumerable();
}
[DebuggerDisplayAttribute("{DebugString()}")]
public class Microsoft.Build.Graph.ProjectGraphNode : object {
    private HashSet`1<ProjectGraphNode> _projectReferences;
    private HashSet`1<ProjectGraphNode> _referencingProjects;
    [CompilerGeneratedAttribute]
private ProjectInstance <ProjectInstance>k__BackingField;
    public IReadOnlyCollection`1<ProjectGraphNode> ProjectReferences { get; }
    public IReadOnlyCollection`1<ProjectGraphNode> ReferencingProjects { get; }
    public ProjectInstance ProjectInstance { get; }
    internal ProjectGraphNode(ProjectInstance projectInstance);
    public IReadOnlyCollection`1<ProjectGraphNode> get_ProjectReferences();
    public IReadOnlyCollection`1<ProjectGraphNode> get_ReferencingProjects();
    [CompilerGeneratedAttribute]
public ProjectInstance get_ProjectInstance();
    private string DebugString();
    internal void AddProjectReference(ProjectGraphNode reference, ProjectItemInstance projectReferenceItem, GraphEdges edges);
    internal void RemoveReference(ProjectGraphNode reference, GraphEdges edges);
    internal void RemoveReferences(GraphEdges edges);
    internal ConfigurationMetadata ToConfigurationMetadata();
}
internal class Microsoft.Build.Graph.ProjectInterpretation : object {
    private static string FullPathMetadataName;
    private static string ToolsVersionMetadataName;
    private static string SetConfigurationMetadataName;
    private static string SetPlatformMetadataName;
    private static string SetTargetFrameworkMetadataName;
    private static string GlobalPropertiesToRemoveMetadataName;
    private static string ProjectReferenceTargetIsOuterBuildMetadataName;
    private static string InnerBuildReferenceItemName;
    internal static string TransitiveReferenceItemName;
    internal static string AddTransitiveProjectReferencesInStaticGraphPropertyName;
    private static string PlatformLookupTableMetadataName;
    private static string PlatformMetadataName;
    private static string PlatformsMetadataName;
    private static string EnableDynamicPlatformResolutionPropertyName;
    private static string OverridePlatformNegotiationValue;
    private static string ShouldUnsetParentConfigurationAndPlatformPropertyName;
    private static string ProjectMetadataName;
    private static string ConfigurationMetadataName;
    private static Char[] PropertySeparator;
    public static ProjectInterpretation Instance;
    private static ImmutableList`1<GlobalPropertiesModifier> ModifierForNonMultitargetingNodes;
    private static ProjectInterpretation();
    [IteratorStateMachineAttribute("Microsoft.Build.Graph.ProjectInterpretation/<GetReferences>d__25")]
public IEnumerable`1<ReferenceInfo> GetReferences(ProjectInstance requesterInstance, ProjectCollection projectCollection, ProjectInstanceFactoryFunc projectInstanceFactory);
    internal static string GetInnerBuildPropertyValue(ProjectInstance project);
    internal static string GetInnerBuildPropertyName(ProjectInstance project);
    internal static string GetInnerBuildPropertyValues(ProjectInstance project);
    internal static ProjectType GetProjectType(ProjectInstance project);
    public void AddInnerBuildEdges(Dictionary`2<ConfigurationMetadata, ParsedProject> allNodes, GraphBuilder graphBuilder);
    [IteratorStateMachineAttribute("Microsoft.Build.Graph.ProjectInterpretation/<ConstructInnerBuildReferences>d__31")]
private static IEnumerable`1<ProjectItemInstance> ConstructInnerBuildReferences(ProjectInstance outerBuild);
    private static GlobalPropertyPartsForMSBuildTask ProjectReferenceGlobalPropertiesModifier(GlobalPropertyPartsForMSBuildTask defaultParts, ProjectItemInstance projectReference);
    private static PropertyDictionary`1<ProjectPropertyInstance> GetGlobalPropertiesForItem(ProjectItemInstance projectReference, PropertyDictionary`1<ProjectPropertyInstance> requesterGlobalProperties, bool allowCollectionReuse, IEnumerable`1<GlobalPropertiesModifier> globalPropertyModifiers);
    private static void MergeIntoPropertyDictionary(PropertyDictionary`1<ProjectPropertyInstance> destination, IReadOnlyDictionary`2<string, string> source);
    private static IReadOnlyDictionary`2<string, string> SplitPropertyNameValuePairs(string syntaxName, string propertyNameAndValuesString);
    private static IReadOnlyCollection`1<string> SplitPropertyNames(string propertyNamesString);
    private static void RemoveFromPropertyDictionary(PropertyDictionary`1<ProjectPropertyInstance> properties, IReadOnlyCollection`1<string> propertyNamesToRemove);
    public bool RequiresTransitiveProjectReferences(ProjectInstance projectInstance);
    private static bool MSBuildStringIsTrue(string msbuildString);
    private static bool MSBuildStringIsFalse(string msbuildString);
    [CompilerGeneratedAttribute]
internal static void <GetReferences>g__SetProperty|25_1(PropertyDictionary`1<ProjectPropertyInstance> properties, string propertyName, string propertyValue);
}
internal static class Microsoft.Build.Internal.AvailableStaticMethods : object {
    private static ConcurrentDictionary`2<string, Tuple`2<string, Type>> s_availableStaticMethods;
    private static object s_locker;
    private static AvailableStaticMethods();
    internal static bool ContainsKey(string key);
    internal static bool TryAdd(string key, Tuple`2<string, Type> value);
    public static bool TryAdd(string typeFullName, string simpleMethodName, Tuple`2<string, Type> typeInformation);
    internal static bool TryGetValue(string key, Tuple`2& value);
    internal static Tuple`2<string, Type> GetValue(string key);
    internal static Tuple`2<string, Type> GetTypeInformationFromTypeCache(string typeFullName, string simpleMethodName);
    private static string CreateQualifiedMethodName(string typeFullName, string simpleMethodName);
    internal static void Reset_ForUnitTestsOnly();
    private static void InitializeAvailableMethods();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.CommunicationsUtilities : object {
    private static int EndOfHandshakeSignal;
    internal static byte handshakeVersion;
    private static int DefaultNodeConnectionTimeout;
    private static bool s_trace;
    private static object s_traceLock;
    private static string s_debugDumpPath;
    private static long s_lastLoggedTicks;
    internal static int NodeConnectionTimeout { get; }
    private static CommunicationsUtilities();
    internal static int get_NodeConnectionTimeout();
    internal static Char* GetEnvironmentStrings();
    internal static bool FreeEnvironmentStrings(Char* pStrings);
    internal static Dictionary`2<string, string> GetEnvironmentVariables();
    internal static void SetEnvironment(IDictionary`2<string, string> newEnvironment);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void WriteEndOfHandshakeSignal(PipeStream stream);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void WriteIntForHandshake(PipeStream stream, int value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static void ReadEndOfHandshakeSignal(PipeStream stream, bool isProvider);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static int ReadIntForHandshake(PipeStream stream, Nullable`1<byte> byteToAccept);
    internal static HandshakeOptions GetHandshakeOptions(bool taskHost, string architectureFlagToSet, bool nodeReuse, bool lowPriority, IDictionary`2<string, string> taskHostParameters);
    internal static int GetIntegerVariableOrDefault(string environmentVariable, int defaultValue);
    internal static void Trace(string format, T arg0);
    internal static void Trace(int nodeId, string format, T arg0);
    internal static void Trace(string format, T0 arg0, T1 arg1);
    internal static void Trace(int nodeId, string format, T0 arg0, T1 arg1);
    internal static void Trace(string format, T0 arg0, T1 arg1, T2 arg2);
    internal static void Trace(int nodeId, string format, T0 arg0, T1 arg1, T2 arg2);
    internal static void Trace(string format, Object[] args);
    internal static void Trace(int nodeId, string format, Object[] args);
    internal static void Trace(int nodeId, string message);
    private static void TraceCore(int nodeId, string message);
    internal static int GetHashCode(string fileVersion);
    internal static int AvoidEndOfHandshakeSignal(int x);
}
internal static class Microsoft.Build.Internal.Constants : object {
    internal static string defaultToolsVersion;
    internal static string defaultFallbackToolsVersion;
    internal static string defaultSolutionWrapperProjectToolsVersion;
    internal static string VisualStudioVersionPropertyName;
    internal static string SubToolsetVersionPropertyName;
    internal static string Dev10SubToolsetValue;
    internal static string programFilesx86;
    internal static string MSBuildAllProjectsPropertyName;
    internal static string AssemblyVersion { get; }
    private static Constants();
    internal static string get_AssemblyVersion();
}
internal static class Microsoft.Build.Internal.EngineFileUtilities : object {
    private static string DriveEnumeratingWildcardMessageResourceName;
    private static List`1<Regex> s_lazyWildCardExpansionRegexes;
    private static Lazy`1<ConcurrentDictionary`2<string, bool>> _regexMatchCache;
    private static EngineFileUtilities();
    internal static void CaptureLazyWildcardRegexes();
    internal static String[] GetFileListUnescaped(string directoryEscaped, string filespecEscaped, object loggingMechanism, IElementLocation excludeLocation);
    internal static String[] GetFileListEscaped(string directoryEscaped, string filespecEscaped, IEnumerable`1<string> excludeSpecsEscaped, bool forceEvaluate, FileMatcher fileMatcher, object loggingMechanism, IElementLocation includeLocation, IElementLocation excludeLocation, IElementLocation importLocation, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, bool disableExcludeDriveEnumerationWarning);
    internal static bool FilespecHasWildcards(string filespecEscaped);
    private static String[] GetFileList(string directoryEscaped, string filespecEscaped, bool returnEscaped, bool forceEvaluateWildCards, IEnumerable`1<string> excludeSpecsEscaped, FileMatcher fileMatcher, object loggingMechanism, IElementLocation includeLocation, IElementLocation excludeLocation, IElementLocation importLocation, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, bool disableExcludeDriveEnumerationWarning);
    private static void LogDriveEnumerationWarningWithTargetLoggingContext(TargetLoggingContext targetLoggingContext, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, bool disableExcludeDriveEnumerationWarning, string fileSpec);
    private static void LogDriveEnumerationWarningWithLoggingService(ILoggingService loggingService, IElementLocation includeLocation, BuildEventContext buildEventContext, string buildEventFileInfoFullPath, string filespecUnescaped);
    private static void LogDriveEnumerationWarningWithEvaluationLoggingContext(EvaluationLoggingContext evaluationLoggingContext, IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec);
    private static void ThrowDriveEnumerationExceptionWithTargetLoggingContext(IElementLocation includeLocation, IElementLocation excludeLocation, bool excludeFileSpecIsEmpty, string filespecUnescaped, string fileSpec);
    private static void ThrowDriveEnumerationExceptionWithLoggingService(IElementLocation includeLocation, string filespecUnescaped);
    private static void ThrowDriveEnumerationExceptionWithEvaluationLoggingContext(IElementLocation importLocation, IElementLocation includeLocation, IElementLocation excludeLocation, string filespecUnescaped, string fileSpec, bool excludeFileSpecIsEmpty);
    private static bool FilespecMatchesLazyWildcard(string filespecEscaped, bool forceEvaluateWildCards);
    private static bool IsValidExclude(string exclude);
    private static List`1<Regex> PopulateRegexFromEnvironment();
    private static bool MatchesLazyWildcard(string fileSpec);
    internal static Func`2<string, bool> GetFileSpecMatchTester(IList`1<string> filespecsEscaped, string currentDirectory);
}
[IsReadOnlyAttribute]
internal class Microsoft.Build.Internal.FileSpecMatcherTester : ValueType {
    private string _currentDirectory;
    private string _unescapedFileSpec;
    private string _filenamePattern;
    private Regex _regex;
    private FileSpecMatcherTester(string currentDirectory, string unescapedFileSpec, string filenamePattern, Regex regex);
    public static FileSpecMatcherTester Parse(string currentDirectory, string fileSpec);
    public bool IsMatch(string fileToMatch);
    public bool IsMatchNormalized(string normalizedFileToMatch);
    private static void CreateRegexOrFilenamePattern(string unescapedFileSpec, string currentDirectory, String& filenamePattern, Regex& regex);
}
internal class Microsoft.Build.Internal.Handshake : object {
    protected int options;
    protected int salt;
    protected int fileVersionMajor;
    protected int fileVersionMinor;
    protected int fileVersionBuild;
    protected int fileVersionPrivate;
    private int sessionId;
    public Nullable`1<byte> ExpectedVersionInFirstByte { get; }
    protected internal Handshake(HandshakeOptions nodeType);
    public virtual string ToString();
    public virtual Int32[] RetrieveHandshakeComponents();
    public virtual string GetKey();
    public virtual Nullable`1<byte> get_ExpectedVersionInFirstByte();
}
[FlagsAttribute]
internal enum Microsoft.Build.Internal.HandshakeOptions : Enum {
    public int value__;
    public static HandshakeOptions None;
    public static HandshakeOptions TaskHost;
    public static HandshakeOptions CLR2;
    public static HandshakeOptions X64;
    public static HandshakeOptions NodeReuse;
    public static HandshakeOptions LowPriority;
    public static HandshakeOptions Administrator;
    public static HandshakeOptions NET;
    public static HandshakeOptions Arm64;
}
internal class Microsoft.Build.Internal.MSBuildAssemblyFileVersion : object {
    private static Lazy`1<MSBuildAssemblyFileVersion> MSBuildAssemblyFileVersionLazy;
    [CompilerGeneratedAttribute]
private string <MajorMinorBuild>k__BackingField;
    public static MSBuildAssemblyFileVersion Instance { get; }
    public string MajorMinorBuild { get; public set; }
    private MSBuildAssemblyFileVersion(string majorMinorBuild);
    private static MSBuildAssemblyFileVersion();
    public static MSBuildAssemblyFileVersion get_Instance();
    [CompilerGeneratedAttribute]
public string get_MajorMinorBuild();
    [CompilerGeneratedAttribute]
public void set_MajorMinorBuild(string value);
    private static MSBuildAssemblyFileVersion GetMSBuildAssemblyFileVersion();
}
internal static class Microsoft.Build.Internal.ProjectXmlUtilities : object {
    internal static XmlElementChildIterator GetVerifyThrowProjectChildElements(XmlElementWithLocation element);
    private static XmlElementChildIterator GetChildElements(XmlElementWithLocation element, bool throwForInvalidNodeTypes);
    internal static void VerifyThrowProjectNoChildElements(XmlElementWithLocation element);
    internal static void ThrowProjectInvalidChildElementDueToDuplicate(XmlElementWithLocation child);
    internal static void ThrowProjectInvalidChildElement(string name, string parentName, ElementLocation location);
    internal static bool VerifyValidProjectNamespace(XmlElementWithLocation element);
    internal static void VerifyThrowProjectAttributeEitherMissingOrNotEmpty(XmlElementWithLocation xmlElement, string attributeName);
    internal static void VerifyThrowProjectAttributeEitherMissingOrNotEmpty(XmlElementWithLocation xmlElement, XmlAttributeWithLocation attribute, string attributeName);
    internal static void VerifyThrowProjectNoAttributes(XmlElementWithLocation element);
    internal static void VerifyThrowProjectInvalidAttribute(bool condition, XmlAttributeWithLocation attribute);
    internal static void VerifyThrowProjectRequiredAttribute(XmlElementWithLocation element, string attributeName);
    internal static void VerifyThrowProjectAttributes(XmlElementWithLocation element, HashSet`1<string> validAttributes);
    internal static void ThrowProjectInvalidAttribute(XmlAttributeWithLocation attribute);
    internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLocation element, string name, string value);
    internal static XmlAttributeWithLocation SetOrRemoveAttribute(XmlElementWithLocation element, string name, string value, bool allowSettingEmptyAttributes);
    internal static string GetAttributeValue(XmlAttributeWithLocation attribute, bool returnNullForNonexistentAttributes);
    internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName);
    internal static string GetAttributeValue(XmlElementWithLocation element, string attributeName, bool nullIfNotExists);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.ReaderWriterLockSlimExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DisposableReadLock EnterDisposableReadLock(ReaderWriterLockSlim rwLock);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static DisposableWriteLock EnterDisposableWriteLock(ReaderWriterLockSlim rwLock);
}
internal class Microsoft.Build.Internal.RegistryKeyWrapper : object {
    private string _registryKeyPath;
    private RegistryKey _wrappedKey;
    private RegistryKey _registryHive;
    private bool _attemptedToOpenRegistryKey;
    private bool _disposed;
    public string Name { get; }
    private RegistryKey WrappedKey { get; }
    protected RegistryKeyWrapper(RegistryKey wrappedKey, RegistryKey registryHive);
    internal RegistryKeyWrapper(string registryKeyPath);
    internal RegistryKeyWrapper(string registryKeyPath, RegistryHive registryHive, RegistryView registryView);
    internal RegistryKeyWrapper(string registryKeyPath, RegistryKey registryHive);
    public virtual string get_Name();
    public static bool KeyExists(string registryKeyPath, RegistryHive registryHive, RegistryView registryView);
    public virtual object GetValue(string name);
    public virtual String[] GetValueNames();
    public virtual String[] GetSubKeyNames();
    public virtual RegistryKeyWrapper OpenSubKey(string name);
    public virtual bool Exists();
    private RegistryKey get_WrappedKey();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal static class Microsoft.Build.Internal.ReservedPropertyNames : object {
    internal static string projectDirectory;
    internal static string projectDirectoryNoRoot;
    internal static string projectFile;
    internal static string projectExtension;
    internal static string projectFullPath;
    internal static string projectName;
    internal static string thisFileDirectory;
    internal static string thisFileDirectoryNoRoot;
    internal static string thisFile;
    internal static string thisFileExtension;
    internal static string thisFileFullPath;
    internal static string thisFileName;
    internal static string binPath;
    internal static string projectDefaultTargets;
    internal static string extensionsPath;
    internal static string extensionsPath32;
    internal static string extensionsPath64;
    internal static string userExtensionsPath;
    internal static string toolsPath;
    internal static string toolsVersion;
    internal static string msbuildRuntimeType;
    internal static string overrideTasksPath;
    internal static string defaultOverrideToolsVersion;
    internal static string startupDirectory;
    internal static string buildNodeCount;
    internal static string lastTaskResult;
    internal static string extensionsPathSuffix;
    internal static string userExtensionsPathSuffix;
    internal static string programFiles32;
    internal static string localAppData;
    internal static string assemblyVersion;
    internal static string fileVersion;
    internal static string semanticVersion;
    internal static string version;
    internal static string osName;
    internal static string frameworkToolsRoot;
    internal static string interactive;
    internal static string msbuilddisablefeaturesfromversion;
    private static HashSet`1<string> ReservedProperties;
    private static ReservedPropertyNames();
    internal static bool IsReservedProperty(string property);
}
internal class Microsoft.Build.Internal.ServerNodeHandshake : Handshake {
    private string _computedHash;
    public Nullable`1<byte> ExpectedVersionInFirstByte { get; }
    internal ServerNodeHandshake(HandshakeOptions nodeType);
    public virtual Nullable`1<byte> get_ExpectedVersionInFirstByte();
    public virtual Int32[] RetrieveHandshakeComponents();
    public virtual string GetKey();
    public string ComputeHash();
}
internal static class Microsoft.Build.Internal.Tracing : object {
    private static Dictionary`2<string, int> s_counts;
    private static DateTime s_last;
    private static TimeSpan s_interval;
    private static string s_slot;
    private static string s_currentAssemblyName;
    private static Tracing();
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, string value);
    [ConditionalAttribute("DEBUG")]
internal static void Slot(string tag, KeyValuePair`2<K, V> value);
    [ConditionalAttribute("DEBUG")]
internal static void Record(string counter);
    [ConditionalAttribute("DEBUG")]
internal static void List(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
internal static void Dump();
}
internal class Microsoft.Build.Internal.UnbuildableProjectTypeException : BuildExceptionBase {
    internal UnbuildableProjectTypeException(string file);
    internal UnbuildableProjectTypeException(string message, Exception inner);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.Utilities : object {
    private static bool s_shouldTreatHigherToolsVersionsAsCurrent;
    private static bool s_shouldTreatOtherToolsVersionsAsCurrent;
    private static bool s_uselegacyDefaultToolsVersionBehavior;
    private static string s_defaultToolsVersionFromEnvironment;
    private static Regex s_xmlnsPattern;
    private static Utilities();
    internal static void RefreshInternalEnvironmentValues();
    internal static void SetXmlNodeInnerContents(XmlElementWithLocation node, string s);
    internal static string GetXmlNodeInnerContents(XmlElementWithLocation node);
    private static bool ContainsNoTagsOtherThanComments(string innerXml, int firstLessThan);
    internal static string RemoveXmlNamespace(string xml);
    internal static string CreateToolsVersionListString(IEnumerable`1<Toolset> toolsets);
    internal static string GenerateToolsVersionToUse(string explicitToolsVersion, string toolsVersionFromProject, GetToolset getToolset, string defaultToolsVersion, Boolean& usingDifferentToolsVersionFromProjectFile);
    private static bool UsingDifferentToolsVersionFromProjectFile(string toolsVersionFromProject, string toolsVersionToUse, bool explicitToolsVersionSpecified);
    internal static PropertyDictionary`1<ProjectPropertyInstance> GetEnvironmentProperties();
    [ExtensionAttribute]
public static int FastCountOrZero(IEnumerable enumerable);
    [IteratorStateMachineAttribute("Microsoft.Build.Internal.Utilities/<Values>d__16`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Values(IEnumerable`1<KeyValuePair`2<string, T>> source);
    [IteratorStateMachineAttribute("Microsoft.Build.Internal.Utilities/<ToEnumerable>d__17`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ToEnumerable(IEnumerator`1<T> enumerator);
    [ExtensionAttribute]
public static T[] ToArray(IEnumerator`1<T> enumerator);
    public static void EnumerateProperties(IEnumerable properties, TArg arg, Action`2<TArg, KeyValuePair`2<string, string>> callback);
    public static void EnumerateItems(IEnumerable items, Action`1<DictionaryEntry> callback);
}
internal class Microsoft.Build.Internal.XmlReaderExtension : object {
    private static Encoding s_utf8NoBom;
    private Stream _stream;
    private StreamReader _streamReader;
    [CompilerGeneratedAttribute]
private XmlReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    internal XmlReader Reader { get; }
    internal Encoding Encoding { get; }
    private XmlReaderExtension(string file, bool loadAsReadOnly);
    private static XmlReaderExtension();
    internal static XmlReaderExtension Create(string filePath, bool loadAsReadOnly);
    [CompilerGeneratedAttribute]
internal XmlReader get_Reader();
    [CompilerGeneratedAttribute]
internal Encoding get_Encoding();
    public sealed virtual void Dispose();
    private static XmlReader GetXmlReader(string file, StreamReader input, bool loadAsReadOnly, Encoding& encoding);
    private static Encoding GetEncodingFromAttribute(XmlReader reader);
}
internal class Microsoft.Build.InterningBinaryReader : BinaryReader {
    private static int MaxCharsBuffer;
    private static Buffer s_bufferPool;
    private Buffer _buffer;
    private bool _isPrivateBuffer;
    private Decoder _decoder;
    internal static BinaryReaderFactory PoolingBuffer { get; }
    private InterningBinaryReader(Stream input, Buffer buffer, bool isPrivateBuffer);
    public virtual string ReadString();
    internal static BinaryReaderFactory CreateSharedBuffer();
    internal static BinaryReaderFactory get_PoolingBuffer();
    private static Buffer GetPooledBuffer();
    protected virtual void Dispose(bool disposing);
    private static BinaryReader Create(Stream stream, BinaryReaderFactory sharedBuffer);
}
public class Microsoft.Build.Logging.BinaryLogger : object {
    internal static int FileFormatVersion;
    private Stream stream;
    private BinaryWriter binaryWriter;
    private BuildEventArgsWriter eventArgsWriter;
    private ProjectImportsCollector projectImportsCollector;
    private string _initialTargetOutputLogging;
    private bool _initialLogImports;
    private string _initialIsBinaryLoggerEnabled;
    [CompilerGeneratedAttribute]
private ProjectImportsCollectionMode <CollectProjectImports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public ProjectImportsCollectionMode CollectProjectImports { get; public set; }
    private string FilePath { get; private set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public ProjectImportsCollectionMode get_CollectProjectImports();
    [CompilerGeneratedAttribute]
public void set_CollectProjectImports(ProjectImportsCollectionMode value);
    [CompilerGeneratedAttribute]
private string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource);
    private void EventArgsWriter_EmbedFile(string filePath);
    private void LogInitialInfo();
    private void LogMessage(string text);
    public sealed virtual void Shutdown();
    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e);
    private void Write(BuildEventArgs e);
    private void CollectImports(BuildEventArgs e);
    private void ProcessParameters();
}
internal enum Microsoft.Build.Logging.BinaryLogRecordKind : Enum {
    public int value__;
    public static BinaryLogRecordKind EndOfFile;
    public static BinaryLogRecordKind BuildStarted;
    public static BinaryLogRecordKind BuildFinished;
    public static BinaryLogRecordKind ProjectStarted;
    public static BinaryLogRecordKind ProjectFinished;
    public static BinaryLogRecordKind TargetStarted;
    public static BinaryLogRecordKind TargetFinished;
    public static BinaryLogRecordKind TaskStarted;
    public static BinaryLogRecordKind TaskFinished;
    public static BinaryLogRecordKind Error;
    public static BinaryLogRecordKind Warning;
    public static BinaryLogRecordKind Message;
    public static BinaryLogRecordKind TaskCommandLine;
    public static BinaryLogRecordKind CriticalBuildMessage;
    public static BinaryLogRecordKind ProjectEvaluationStarted;
    public static BinaryLogRecordKind ProjectEvaluationFinished;
    public static BinaryLogRecordKind ProjectImported;
    public static BinaryLogRecordKind ProjectImportArchive;
    public static BinaryLogRecordKind TargetSkipped;
    public static BinaryLogRecordKind PropertyReassignment;
    public static BinaryLogRecordKind UninitializedPropertyRead;
    public static BinaryLogRecordKind EnvironmentVariableRead;
    public static BinaryLogRecordKind PropertyInitialValueSet;
    public static BinaryLogRecordKind NameValueList;
    public static BinaryLogRecordKind String;
    public static BinaryLogRecordKind TaskParameter;
    public static BinaryLogRecordKind ResponseFileUsed;
    public static BinaryLogRecordKind AssemblyLoad;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Logging.BinaryLogReplayEventSource : EventArgsDispatcher {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<IBuildEventArgsReaderNotifications> NotificationsSourceCreated;
    private static BinaryLogReplayEventSource();
    [CompilerGeneratedAttribute]
public void add_NotificationsSourceCreated(Action`1<IBuildEventArgsReaderNotifications> value);
    [CompilerGeneratedAttribute]
public void remove_NotificationsSourceCreated(Action`1<IBuildEventArgsReaderNotifications> value);
    public void Replay(string sourceFilePath);
    public static BinaryReader OpenReader(string sourceFilePath);
    public void Replay(string sourceFilePath, CancellationToken cancellationToken);
    public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken);
}
[FlagsAttribute]
internal enum Microsoft.Build.Logging.BuildEventArgsFieldFlags : Enum {
    public int value__;
    public static BuildEventArgsFieldFlags None;
    public static BuildEventArgsFieldFlags BuildEventContext;
    public static BuildEventArgsFieldFlags HelpKeyword;
    public static BuildEventArgsFieldFlags Message;
    public static BuildEventArgsFieldFlags SenderName;
    public static BuildEventArgsFieldFlags ThreadId;
    public static BuildEventArgsFieldFlags Timestamp;
    public static BuildEventArgsFieldFlags Subcategory;
    public static BuildEventArgsFieldFlags Code;
    public static BuildEventArgsFieldFlags File;
    public static BuildEventArgsFieldFlags ProjectFile;
    public static BuildEventArgsFieldFlags LineNumber;
    public static BuildEventArgsFieldFlags ColumnNumber;
    public static BuildEventArgsFieldFlags EndLineNumber;
    public static BuildEventArgsFieldFlags EndColumnNumber;
    public static BuildEventArgsFieldFlags Arguments;
    public static BuildEventArgsFieldFlags Importance;
}
internal class Microsoft.Build.Logging.BuildEventArgsFields : object {
    [CompilerGeneratedAttribute]
private BuildEventArgsFieldFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildEventContext <BuildEventContext>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SenderName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageImportance <Importance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    public BuildEventArgsFieldFlags Flags { get; public set; }
    public string Message { get; public set; }
    public Object[] Arguments { get; public set; }
    public BuildEventContext BuildEventContext { get; public set; }
    public int ThreadId { get; public set; }
    public string HelpKeyword { get; public set; }
    public string SenderName { get; public set; }
    public DateTime Timestamp { get; public set; }
    public MessageImportance Importance { get; public set; }
    public string Subcategory { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string ProjectFile { get; public set; }
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    [CompilerGeneratedAttribute]
public BuildEventArgsFieldFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(BuildEventArgsFieldFlags value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(Object[] value);
    [CompilerGeneratedAttribute]
public BuildEventContext get_BuildEventContext();
    [CompilerGeneratedAttribute]
public void set_BuildEventContext(BuildEventContext value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_SenderName();
    [CompilerGeneratedAttribute]
public void set_SenderName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public MessageImportance get_Importance();
    [CompilerGeneratedAttribute]
public void set_Importance(MessageImportance value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Logging.BuildEventArgsReader : object {
    private BinaryReader binaryReader;
    private int fileFormatVersion;
    private long recordNumber;
    private List`1<object> stringRecords;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2[]> nameValueListRecords;
    private StringStorage stringStorage;
    [NullableAttribute("2")]
private static FieldInfo buildEventArgsFieldThreadId;
    [NullableAttribute("2")]
private static FieldInfo buildEventArgsFieldSenderName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<StringReadEventArgs> StringReadDone;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Action StringEncountered;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`2<BinaryLogRecordKind, Byte[]> OnBlobRead;
    private StringReadEventArgs stringReadEventArgs;
    public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion);
    private static BuildEventArgsReader();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual void add_StringReadDone(Action`1<StringReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StringReadDone(Action`1<StringReadEventArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_StringEncountered(Action value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_StringEncountered(Action value);
    [CompilerGeneratedAttribute]
internal void add_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    [CompilerGeneratedAttribute]
internal void remove_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    [NullableContextAttribute("2")]
public BuildEventArgs Read();
    private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind);
    private void ReadBlob(BinaryLogRecordKind kind);
    private void ReadNameValueList();
    private IDictionary`2<string, string> GetNameValueList(int id);
    private void ReadStringRecord();
    private BuildEventArgs ReadProjectImportedEventArgs();
    private BuildEventArgs ReadTargetSkippedEventArgs();
    private BuildEventArgs ReadBuildStartedEventArgs();
    private BuildEventArgs ReadBuildFinishedEventArgs();
    private BuildEventArgs ReadProjectEvaluationStartedEventArgs();
    private BuildEventArgs ReadProjectEvaluationFinishedEventArgs();
    private BuildEventArgs ReadProjectStartedEventArgs();
    private BuildEventArgs ReadProjectFinishedEventArgs();
    private BuildEventArgs ReadTargetStartedEventArgs();
    private BuildEventArgs ReadTargetFinishedEventArgs();
    private BuildEventArgs ReadTaskStartedEventArgs();
    private BuildEventArgs ReadTaskFinishedEventArgs();
    private BuildEventArgs ReadBuildErrorEventArgs();
    private BuildEventArgs ReadBuildWarningEventArgs();
    private BuildEventArgs ReadBuildMessageEventArgs();
    private BuildEventArgs ReadTaskCommandLineEventArgs();
    private BuildEventArgs ReadTaskParameterEventArgs();
    private BuildEventArgs ReadCriticalBuildMessageEventArgs();
    private BuildEventArgs ReadEnvironmentVariableReadEventArgs();
    private BuildEventArgs ReadResponseFileUsedEventArgs();
    private BuildEventArgs ReadPropertyReassignmentEventArgs();
    private BuildEventArgs ReadUninitializedPropertyReadEventArgs();
    private BuildEventArgs ReadPropertyInitialValueSetEventArgs();
    private AssemblyLoadBuildEventArgs ReadAssemblyLoadEventArgs();
    private void ReadDiagnosticFields(BuildEventArgsFields fields);
    private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance);
    private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields fields);
    [NullableContextAttribute("2")]
private IEnumerable ReadPropertyList();
    private BuildEventContext ReadBuildEventContext();
    private IDictionary`2<string, string> ReadStringDictionary();
    private IDictionary`2<string, string> ReadLegacyStringDictionary();
    private ITaskItem ReadTaskItem();
    [NullableContextAttribute("2")]
private IEnumerable ReadProjectItems();
    [NullableContextAttribute("2")]
private IEnumerable ReadTaskItemList();
    private string ReadString();
    [NullableContextAttribute("2")]
private string ReadOptionalString();
    [NullableContextAttribute("2")]
private string ReadDeduplicatedString();
    [NullableContextAttribute("2")]
private string GetStringFromRecord(int index);
    private int ReadInt32();
    private long ReadInt64();
    private bool ReadBoolean();
    private Guid ReadGuid();
    private DateTime ReadDateTime();
    private TimeSpan ReadTimeSpan();
    private ProfiledLocation ReadProfiledLocation();
    private EvaluationLocation ReadEvaluationLocation();
}
internal class Microsoft.Build.Logging.BuildEventArgsWriter : object {
    private Stream originalStream;
    private MemoryStream currentRecordStream;
    private BinaryWriter originalBinaryWriter;
    private BinaryWriter currentRecordWriter;
    private BinaryWriter binaryWriter;
    private Dictionary`2<HashKey, int> stringHashes;
    private Dictionary`2<HashKey, int> nameValueListHashes;
    internal static int StringStartIndex;
    internal static int NameValueRecordStartIndex;
    private int stringRecordId;
    private int nameValueRecordId;
    private List`1<KeyValuePair`2<string, string>> nameValueListBuffer;
    private List`1<KeyValuePair`2<int, int>> nameValueIndexListBuffer;
    [CompilerGeneratedAttribute]
private Action`1<string> EmbedFile;
    private List`1<object> reusableItemsList;
    private List`1<object> reusableProjectItemList;
    public BuildEventArgsWriter(BinaryWriter binaryWriter);
    [CompilerGeneratedAttribute]
public void add_EmbedFile(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_EmbedFile(Action`1<string> value);
    public void Write(BuildEventArgs e);
    private void WriteCore(BuildEventArgs e);
    public void WriteBlob(BinaryLogRecordKind kind, Byte[] bytes);
    public void WriteBlob(BinaryLogRecordKind kind, Stream stream);
    private IDisposable RedirectWritesToOriginalWriter();
    private void Write(BuildStartedEventArgs e);
    private void Write(BuildFinishedEventArgs e);
    private void Write(ProjectEvaluationStartedEventArgs e);
    private void Write(ProjectEvaluationFinishedEventArgs e);
    private void Write(ProjectStartedEventArgs e);
    private void Write(ProjectFinishedEventArgs e);
    private void Write(TargetStartedEventArgs e);
    private void Write(TargetFinishedEventArgs e);
    private void Write(TaskStartedEventArgs e);
    private void Write(TaskFinishedEventArgs e);
    private void Write(BuildErrorEventArgs e);
    private void Write(BuildWarningEventArgs e);
    private void Write(BuildMessageEventArgs e);
    private void Write(ProjectImportedEventArgs e);
    private void Write(TargetSkippedEventArgs e);
    private void Write(AssemblyLoadBuildEventArgs e);
    private void Write(CriticalBuildMessageEventArgs e);
    private void Write(PropertyReassignmentEventArgs e);
    private void Write(UninitializedPropertyReadEventArgs e);
    private void Write(PropertyInitialValueSetEventArgs e);
    private void Write(EnvironmentVariableReadEventArgs e);
    private void Write(ResponseFileUsedEventArgs e);
    private void Write(TaskCommandLineEventArgs e);
    private void Write(TaskParameterEventArgs e);
    private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage, bool writeLineAndColumn);
    private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags);
    private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage, bool writeImportance);
    private void WriteArguments(Object[] arguments);
    private static BuildEventArgsFieldFlags GetMessageFlags(BuildMessageEventArgs e, BuildEventArgsFieldFlags flags, bool writeImportance);
    private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e, bool writeMessage);
    private void WriteTaskItemList(IEnumerable items, bool writeMetadata);
    private void WriteProjectItems(IEnumerable items);
    private void CheckForFilesToEmbed(string itemType, object itemList);
    private void Write(ITaskItem item, bool writeMetadata);
    private void WriteProperties(IEnumerable properties);
    private void Write(BuildEventContext buildEventContext);
    private void Write(IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    private void WriteNameValueList();
    private void WriteNameValueListRecord();
    private HashKey HashAllStrings(List`1<KeyValuePair`2<string, string>> nameValueList);
    private void Write(BinaryLogRecordKind kind);
    private void Write(int value);
    private void Write(long value);
    private void Write(Byte[] bytes);
    private void Write(Stream stream);
    private void Write(byte b);
    private void Write(bool boolean);
    private void Write(Guid guid);
    private void WriteDeduplicatedString(string text);
    private ValueTuple`2<int, HashKey> HashString(string text);
    private void WriteStringRecord(string text);
    private void Write(DateTime timestamp);
    private void Write(TimeSpan timeSpan);
    private void Write(EvaluationLocation item);
    private void Write(ProfiledLocation e);
    [CompilerGeneratedAttribute]
private void <WriteProjectItems>b__56_0(string itemType, IEnumerable`1<ProjectItemInstance> itemList);
    [CompilerGeneratedAttribute]
private void <WriteProjectItems>b__56_1(string itemType, IEnumerable`1<ProjectItem> itemList);
}
public class Microsoft.Build.Logging.ColorResetter : MulticastDelegate {
    public ColorResetter(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.ColorSetter : MulticastDelegate {
    public ColorSetter(object object, IntPtr method);
    public virtual void Invoke(ConsoleColor color);
    public virtual IAsyncResult BeginInvoke(ConsoleColor color, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.ConfigurableForwardingLogger : object {
    private LoggerVerbosity _verbosity;
    private string _loggerParameters;
    private static Char[] s_parameterDelimiters;
    private static string BuildStartedEventDescription;
    private static string BuildFinishedEventDescription;
    private static string ProjectStartedEventDescription;
    private static string ProjectFinishedEventDescription;
    private static string ProjectEvaluationEventDescription;
    private static string ProjectEvaluationStartedEventDescription;
    private static string ProjectEvaluationFinishedEventDescription;
    private static string TargetStartedEventDescription;
    private static string TargetFinishedEventDescription;
    private static string TaskStartedEventDescription;
    private static string TaskFinishedEventDescription;
    private static string ErrorEventDescription;
    private static string WarningEventDescription;
    private static string HighMessageEventDescription;
    private static string NormalMessageEventDescription;
    private static string LowMessageEventDescription;
    private static string CustomEventDescription;
    private static string CommandLineDescription;
    private static string PerformanceSummaryDescription;
    private static string NoSummaryDescription;
    private static string ShowCommandLineDescription;
    private static string ForwardProjectContextDescription;
    private Dictionary`2<string, int> _forwardingTable;
    private IEventRedirector _buildEventRedirector;
    private bool _forwardingSetFromParameters;
    private bool _forwardProjectContext;
    private bool _showSummary;
    private bool _showPerfSummary;
    private bool _showCommandLine;
    private int _nodeId;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    private static ConfigurableForwardingLogger();
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual IEventRedirector get_BuildEventRedirector();
    public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    public sealed virtual int get_NodeId();
    public sealed virtual void set_NodeId(int value);
    private void InitializeForwardingTable();
    private void ParseParameters();
    private void ApplyParameter(string parameterName);
    public virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void SetForwardingBasedOnVerbosity();
    internal MessageImportance GetMinimumMessageImportance();
    private void ResetLoggerState();
    public virtual void Shutdown();
    private void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    private void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    private void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    private void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    private void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    private void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    private void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    private void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    private void ErrorHandler(object sender, BuildErrorEventArgs e);
    private void WarningHandler(object sender, BuildWarningEventArgs e);
    private void MessageHandler(object sender, BuildMessageEventArgs e);
    private void CustomEventHandler(object sender, CustomBuildEventArgs e);
    private void BuildStatusHandler(object sender, BuildStatusEventArgs e);
    protected virtual void ForwardToCentralLogger(BuildEventArgs e);
    private bool IsVerbosityAtLeast(LoggerVerbosity checkVerbosity);
}
public class Microsoft.Build.Logging.ConsoleLogger : object {
    private BaseConsoleLogger _consoleLogger;
    private int _numberOfProcessors;
    private LoggerVerbosity _verbosity;
    private WriteHandler _write;
    private ColorSetter _colorSet;
    private ColorResetter _colorReset;
    private string _parameters;
    private bool _skipProjectStartedText;
    private Nullable`1<bool> _showSummary;
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public bool SkipProjectStartedText { get; public set; }
    public bool ShowSummary { get; public set; }
    protected WriteHandler WriteHandler { get; protected set; }
    public ConsoleLogger(LoggerVerbosity verbosity);
    public ConsoleLogger(LoggerVerbosity verbosity, WriteHandler write, ColorSetter colorSet, ColorResetter colorReset);
    private void InitializeBaseConsoleLogger();
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public bool get_SkipProjectStartedText();
    public void set_SkipProjectStartedText(bool value);
    public bool get_ShowSummary();
    public void set_ShowSummary(bool value);
    protected WriteHandler get_WriteHandler();
    protected void set_WriteHandler(WriteHandler value);
    public void ApplyParameter(string parameterName, string parameterValue);
    public virtual void Initialize(IEventSource eventSource);
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    public virtual void Shutdown();
    public void BuildStartedHandler(object sender, BuildStartedEventArgs e);
    public void BuildFinishedHandler(object sender, BuildFinishedEventArgs e);
    public void ProjectStartedHandler(object sender, ProjectStartedEventArgs e);
    public void ProjectFinishedHandler(object sender, ProjectFinishedEventArgs e);
    public void TargetStartedHandler(object sender, TargetStartedEventArgs e);
    public void TargetFinishedHandler(object sender, TargetFinishedEventArgs e);
    public void TaskStartedHandler(object sender, TaskStartedEventArgs e);
    public void TaskFinishedHandler(object sender, TaskFinishedEventArgs e);
    public void ErrorHandler(object sender, BuildErrorEventArgs e);
    public void WarningHandler(object sender, BuildWarningEventArgs e);
    public void MessageHandler(object sender, BuildMessageEventArgs e);
    public void CustomEventHandler(object sender, CustomBuildEventArgs e);
    internal MessageImportance GetMinimumMessageImportance();
}
public class Microsoft.Build.Logging.DistributedFileLogger : object {
    private FileLogger _nodeFileLogger;
    private IEventRedirector _buildEventRedirector;
    private int _nodeId;
    private string _logFile;
    private string _parameters;
    private static Char[] s_fileLoggerParameterDelimiters;
    private static Char[] s_fileLoggerParameterValueSplitCharacter;
    internal FileLogger InternalFilelogger { get; }
    public IEventRedirector BuildEventRedirector { get; public set; }
    public int NodeId { get; public set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    private static DistributedFileLogger();
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void ParseFileLoggerParameters();
    private void ApplyFileLoggerParameter(string parameterName, string parameterValue);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    internal FileLogger get_InternalFilelogger();
    public sealed virtual IEventRedirector get_BuildEventRedirector();
    public sealed virtual void set_BuildEventRedirector(IEventRedirector value);
    public sealed virtual int get_NodeId();
    public sealed virtual void set_NodeId(int value);
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
}
internal class Microsoft.Build.Logging.EvaluationLocationIdAgnosticComparer : object {
    public static EvaluationLocationIdAgnosticComparer Singleton;
    private static EvaluationLocationIdAgnosticComparer();
    public sealed virtual bool Equals(EvaluationLocation x, EvaluationLocation y);
    public sealed virtual int GetHashCode(EvaluationLocation obj);
}
public class Microsoft.Build.Logging.EventArgsDispatcher : object {
    [CompilerGeneratedAttribute]
private AnyEventHandler AnyEventRaised;
    [CompilerGeneratedAttribute]
private BuildStatusEventHandler StatusEventRaised;
    [CompilerGeneratedAttribute]
private CustomBuildEventHandler CustomEventRaised;
    [CompilerGeneratedAttribute]
private BuildStartedEventHandler BuildStarted;
    [CompilerGeneratedAttribute]
private BuildFinishedEventHandler BuildFinished;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler ProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler ProjectFinished;
    [CompilerGeneratedAttribute]
private TargetStartedEventHandler TargetStarted;
    [CompilerGeneratedAttribute]
private TargetFinishedEventHandler TargetFinished;
    [CompilerGeneratedAttribute]
private TaskStartedEventHandler TaskStarted;
    [CompilerGeneratedAttribute]
private TaskFinishedEventHandler TaskFinished;
    [CompilerGeneratedAttribute]
private BuildErrorEventHandler ErrorRaised;
    [CompilerGeneratedAttribute]
private BuildWarningEventHandler WarningRaised;
    [CompilerGeneratedAttribute]
private BuildMessageEventHandler MessageRaised;
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    public void Dispatch(BuildEventArgs buildEvent);
}
public class Microsoft.Build.Logging.FileLogger : ConsoleLogger {
    private string _logFileName;
    private StreamWriter _fileWriter;
    private bool _append;
    private bool _autoFlush;
    private Encoding _encoding;
    private static Char[] s_fileLoggerParameterDelimiters;
    private static Char[] s_fileLoggerParameterValueSplitCharacter;
    private static FileLogger();
    public virtual void Initialize(IEventSource eventSource);
    private void FileLoggerBuildFinished(object sender, BuildFinishedEventArgs e);
    private void InitializeFileLogger(IEventSource eventSource, int nodeCount);
    public virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void Write(string text);
    public virtual void Shutdown();
    private void ParseFileLoggerParameters();
    private void ApplyFileLoggerParameter(string parameterName, string parameterValue);
    [CompilerGeneratedAttribute]
private void <InitializeFileLogger>b__3_0(object obj, BuildStartedEventArgs args);
}
public class Microsoft.Build.Logging.ForwardingLoggerRecord : object {
    [CompilerGeneratedAttribute]
private ILogger <CentralLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerDescription <ForwardingLoggerDescription>k__BackingField;
    public ILogger CentralLogger { get; private set; }
    public LoggerDescription ForwardingLoggerDescription { get; private set; }
    public ForwardingLoggerRecord(ILogger centralLogger, LoggerDescription forwardingLoggerDescription);
    [CompilerGeneratedAttribute]
public ILogger get_CentralLogger();
    [CompilerGeneratedAttribute]
private void set_CentralLogger(ILogger value);
    [CompilerGeneratedAttribute]
public LoggerDescription get_ForwardingLoggerDescription();
    [CompilerGeneratedAttribute]
private void set_ForwardingLoggerDescription(LoggerDescription value);
}
public interface Microsoft.Build.Logging.IBuildEventArgsReaderNotifications {
}
[NullableContextAttribute("2")]
public interface Microsoft.Build.Logging.IBuildEventStringsReader {
    [CompilerGeneratedAttribute]
public abstract virtual void add_StringReadDone(Action`1<StringReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StringReadDone(Action`1<StringReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StringEncountered(Action value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StringEncountered(Action value);
}
public class Microsoft.Build.Logging.LoggerDescription : object {
    private static Func`3<Type, object, bool> s_forwardingLoggerClassFilter;
    private static Func`3<Type, object, bool> s_loggerClassFilter;
    private string _loggerClassName;
    private string _loggerSwitchParameters;
    private AssemblyLoadInfo _loggerAssembly;
    private LoggerVerbosity _verbosity;
    private int _loggerId;
    private bool _isOptional;
    internal int LoggerId { get; internal set; }
    internal string Name { get; }
    public string LoggerSwitchParameters { get; }
    public bool IsOptional { get; }
    public LoggerVerbosity Verbosity { get; }
    public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, LoggerVerbosity verbosity);
    public LoggerDescription(string loggerClassName, string loggerAssemblyName, string loggerAssemblyFile, string loggerSwitchParameters, LoggerVerbosity verbosity, bool isOptional);
    private static LoggerDescription();
    internal int get_LoggerId();
    internal void set_LoggerId(int value);
    internal string get_Name();
    public string get_LoggerSwitchParameters();
    public bool get_IsOptional();
    public LoggerVerbosity get_Verbosity();
    internal IForwardingLogger CreateForwardingLogger();
    public ILogger CreateLogger();
    private ILogger CreateLogger(bool forwardingLogger);
    private static bool IsForwardingLoggerClass(Type type, object unused);
    private static bool IsLoggerClass(Type type, object unused);
    internal void ConvertPathsToFullPaths();
    internal void WriteToStream(BinaryWriter writer);
    internal void CreateFromStream(BinaryReader reader);
    private sealed virtual override void Microsoft.Build.BackEnd.ITranslatable.Translate(ITranslator translator);
    internal static LoggerDescription FactoryForTranslation(ITranslator translator);
}
public class Microsoft.Build.Logging.ProfilerLogger : object {
    private ConcurrentQueue`1<ProfilerResult> _profiledResults;
    private Dictionary`2<EvaluationLocation, ProfiledLocation> _aggregatedLocations;
    [CompilerGeneratedAttribute]
private string <FileToLog>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public string FileToLog { get; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    public ProfilerLogger(string fileToLog);
    [CompilerGeneratedAttribute]
public string get_FileToLog();
    internal static ProfilerLogger CreateForTesting();
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
    private void ProjectEvaluationFinishedRaised(object sender, BuildEventArgs e);
    internal ProfilerResult GetAggregatedResult(bool pruneSmallItems);
    private static void MergeItem(IDictionary`2<EvaluationLocation, EvaluationLocation> originalLocations, IDictionary`2<long, long> mergeMap, IDictionary`2<EvaluationLocation, ProfiledLocation> aggregatedLocations, KeyValuePair`2<EvaluationLocation, ProfiledLocation> pairToMerge);
    private static Dictionary`2<EvaluationLocation, ProfiledLocation> PruneSmallItems(IDictionary`2<EvaluationLocation, ProfiledLocation> aggregatedLocations);
    private static Nullable`1<long> FindBigEnoughParentId(IDictionary`2<long, Pair`2<EvaluationLocation, ProfiledLocation>> idTable, Nullable`1<long> parentId);
    private static bool IsTooSmall(ProfiledLocation profiledData);
    private static ProfiledLocation AggregateProfiledLocation(ProfiledLocation location, ProfiledLocation otherLocation);
    private void GenerateProfilerReport();
    [CompilerGeneratedAttribute]
private ProfiledLocation <GetAggregatedResult>b__18_1(ProfiledLocation profiledLocation, EvaluationLocation evaluationLocation);
}
internal class Microsoft.Build.Logging.ProjectImportsCollector : object {
    private Stream _fileStream;
    private ZipArchive _zipArchive;
    [CompilerGeneratedAttribute]
private string <ArchiveFilePath>k__BackingField;
    private HashSet`1<string> _processedFiles;
    private Task _currentTask;
    public string ArchiveFilePath { get; }
    public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension);
    [CompilerGeneratedAttribute]
public string get_ArchiveFilePath();
    public void AddFile(string filePath);
    public void AddFileFromMemory(string filePath, string data);
    private void AddFileCore(string filePath);
    private void AddFileFromMemoryCore(string filePath, string data);
    private Stream OpenArchiveEntry(string filePath);
    private static string CalculateArchivePath(string filePath);
    public void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Logging.SimpleErrorLogger.SimpleErrorLogger : object {
    private bool acceptAnsiColorCodes;
    private Nullable`1<UInt32> originalConsoleMode;
    [CompilerGeneratedAttribute]
private bool <HasLoggedErrors>k__BackingField;
    public bool HasLoggedErrors { get; private set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HasLoggedErrors();
    [CompilerGeneratedAttribute]
private void set_HasLoggedErrors(bool value);
    public sealed virtual LoggerVerbosity get_Verbosity();
    public sealed virtual void set_Verbosity(LoggerVerbosity value);
    public sealed virtual string get_Parameters();
    public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource, int nodeCount);
    private void HandleErrorEvent(object sender, BuildErrorEventArgs e);
    private void HandleWarningEvent(object sender, BuildWarningEventArgs e);
    private void LogWithColor(string message, TerminalColor color);
    public sealed virtual void Initialize(IEventSource eventSource);
    public sealed virtual void Shutdown();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.Build.Logging.StringReadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <OriginalString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StringToBeUsed>k__BackingField;
    public string OriginalString { get; private set; }
    public string StringToBeUsed { get; public set; }
    public StringReadEventArgs(string str);
    [CompilerGeneratedAttribute]
public string get_OriginalString();
    [CompilerGeneratedAttribute]
private void set_OriginalString(string value);
    [CompilerGeneratedAttribute]
public string get_StringToBeUsed();
    [CompilerGeneratedAttribute]
public void set_StringToBeUsed(string value);
    internal void Reuse(string newValue);
}
public class Microsoft.Build.Logging.WriteHandler : MulticastDelegate {
    public WriteHandler(object object, IntPtr method);
    public virtual void Invoke(string message);
    public virtual IAsyncResult BeginInvoke(string message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ExternalProjectsProvider : object {
    public abstract virtual ICollection`1<Project> GetLoadedProjects(string filePath);
    public virtual void Disconnected(ProjectCollection collection);
    public static void SetExternalProjectsProvider(ProjectCollection collection, ExternalProjectsProvider link);
}
internal interface Microsoft.Build.ObjectModelRemoting.ILinkableObject {
    public object Link { get; }
    public abstract virtual object get_Link();
}
internal interface Microsoft.Build.ObjectModelRemoting.ILinkedXml {
    public ProjectElementLink Link { get; }
    public XmlElementWithLocation Xml { get; }
    public abstract virtual ProjectElementLink get_Link();
    public abstract virtual XmlElementWithLocation get_Xml();
}
public class Microsoft.Build.ObjectModelRemoting.LinkedObjectsFactory : object {
    [CompilerGeneratedAttribute]
private ProjectCollection <Collection>k__BackingField;
    public ProjectCollection Collection { get; }
    private LinkedObjectsFactory(ProjectCollection collection);
    public static LinkedObjectsFactory Get(ProjectCollection collection);
    public static object GetLink(object obj);
    public static bool IsLocal(object obj);
    [CompilerGeneratedAttribute]
public ProjectCollection get_Collection();
    public static IReadOnlyCollection`1<Project> GetLocalProjects(ProjectCollection collection, string projectFile);
    public ProjectItem Create(ProjectItemLink link, Project project, ProjectItemElement xml);
    public ProjectItemDefinition Create(ProjectItemDefinitionLink link, Project project);
    public Project Create(ProjectLink link);
    public ProjectMetadata Create(ProjectMetadataLink link, object parent);
    public ProjectProperty Create(ProjectPropertyLink link, Project project);
    public ResolvedImport Create(ProjectImportElement importingElement, ProjectRootElement importedProject, int versionEvaluated, SdkResult sdkResult, bool isImported);
    public ProjectRootElement Create(ProjectRootElementLink link);
    public ProjectChooseElement Create(ProjectChooseElementLink link);
    public ProjectExtensionsElement Create(ProjectExtensionsElementLink link);
    public ProjectImportElement Create(ProjectImportElementLink link);
    public ProjectImportGroupElement Create(ProjectImportGroupElementLink link);
    public ProjectItemDefinitionElement Create(ProjectItemDefinitionElementLink link);
    public ProjectItemDefinitionGroupElement Create(ProjectItemDefinitionGroupElementLink link);
    public ProjectItemElement Create(ProjectItemElementLink link);
    public ProjectItemGroupElement Create(ProjectItemGroupElementLink link);
    public ProjectMetadataElement Create(ProjectMetadataElementLink link);
    public ProjectOnErrorElement Create(ProjectOnErrorElementLink link);
    public ProjectOtherwiseElement Create(ProjectOtherwiseElementLink link);
    public ProjectOutputElement Create(ProjectOutputElementLink link);
    public ProjectPropertyElement Create(ProjectPropertyElementLink link);
    public ProjectPropertyGroupElement Create(ProjectPropertyGroupElementLink link);
    public ProjectSdkElement Create(ProjectSdkElementLink link);
    public ProjectTargetElement Create(ProjectTargetElementLink link);
    public ProjectTaskElement Create(ProjectTaskElementLink link);
    public ProjectUsingTaskBodyElement Create(ProjectUsingTaskBodyElementLink link);
    public ProjectUsingTaskElement Create(ProjectUsingTaskElementLink link);
    public ProjectUsingTaskParameterElement Create(ProjectUsingTaskParameterElementLink link);
    public ProjectWhenElement Create(ProjectWhenElementLink link);
    public UsingTaskParameterGroupElement Create(UsingTaskParameterGroupElementLink link);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectChooseElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectElementContainerLink : ProjectElementLink {
    public int Count { get; }
    public ProjectElement FirstChild { get; }
    public ProjectElement LastChild { get; }
    public abstract virtual int get_Count();
    public abstract virtual ProjectElement get_FirstChild();
    public abstract virtual ProjectElement get_LastChild();
    public abstract virtual void InsertAfterChild(ProjectElement child, ProjectElement reference);
    public abstract virtual void InsertBeforeChild(ProjectElement child, ProjectElement reference);
    public abstract virtual void AddInitialChild(ProjectElement child);
    public abstract virtual ProjectElementContainer DeepClone(ProjectRootElement factory, ProjectElementContainer parent);
    public abstract virtual void RemoveChild(ProjectElement child);
    public static void AddInitialChild(ProjectElementContainer xml, ProjectElement child);
    public static ProjectElementContainer DeepClone(ProjectElementContainer xml, ProjectRootElement factory, ProjectElementContainer parent);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectElementLink : object {
    private ProjectElementLink Microsoft.Build.ObjectModelRemoting.ILinkedXml.Link { get; }
    private XmlElementWithLocation Microsoft.Build.ObjectModelRemoting.ILinkedXml.Xml { get; }
    public ProjectElementContainer Parent { get; }
    public ProjectRootElement ContainingProject { get; }
    public string ElementName { get; }
    public string OuterElement { get; }
    public bool ExpressedAsAttribute { get; public set; }
    public ProjectElement PreviousSibling { get; }
    public ProjectElement NextSibling { get; }
    public ElementLocation Location { get; }
    public IReadOnlyCollection`1<XmlAttributeLink> Attributes { get; }
    public string PureText { get; }
    private sealed virtual override ProjectElementLink Microsoft.Build.ObjectModelRemoting.ILinkedXml.get_Link();
    private sealed virtual override XmlElementWithLocation Microsoft.Build.ObjectModelRemoting.ILinkedXml.get_Xml();
    public abstract virtual ProjectElementContainer get_Parent();
    public abstract virtual ProjectRootElement get_ContainingProject();
    public abstract virtual string get_ElementName();
    public abstract virtual string get_OuterElement();
    public abstract virtual bool get_ExpressedAsAttribute();
    public abstract virtual void set_ExpressedAsAttribute(bool value);
    public abstract virtual ProjectElement get_PreviousSibling();
    public abstract virtual ProjectElement get_NextSibling();
    public abstract virtual ElementLocation get_Location();
    public abstract virtual IReadOnlyCollection`1<XmlAttributeLink> get_Attributes();
    public abstract virtual string get_PureText();
    public abstract virtual ElementLocation GetAttributeLocation(string attributeName);
    public abstract virtual string GetAttributeValue(string attributeName, bool nullIfNotExists);
    public abstract virtual void SetOrRemoveAttribute(string name, string value, bool clearAttributeCache, string reason, string param);
    public abstract virtual void CopyFrom(ProjectElement element);
    public abstract virtual ProjectElement CreateNewInstance(ProjectRootElement owner);
    public static bool GetExpressedAsAttribute(ProjectElement xml);
    public static void SetExpressedAsAttribute(ProjectElement xml, bool value);
    public static ElementLocation GetAttributeLocation(ProjectElement xml, string attributeName);
    public static string GetAttributeValue(ProjectElement xml, string attributeName, bool nullIfNotExists);
    public static void SetOrRemoveAttribute(ProjectElement xml, string name, string value, bool clearAttributeCache, string reason, string param);
    public static void MarkDirty(ProjectElement xml, string reason, string param);
    public static ProjectElement CreateNewInstance(ProjectElement xml, ProjectRootElement owner);
    public static string GetPureText(ProjectElement xml);
    public static IReadOnlyCollection`1<XmlAttributeLink> GetAttributes(ProjectElement xml);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectExtensionsElementLink : ProjectElementLink {
    public string Content { get; public set; }
    public abstract virtual string get_Content();
    public abstract virtual void set_Content(string value);
    public abstract virtual string GetSubElement(string name);
    public abstract virtual void SetSubElement(string name, string value);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectImportElementLink : ProjectElementLink {
    public ImplicitImportLocation ImplicitImportLocation { get; }
    public ProjectElement OriginalElement { get; }
    public abstract virtual ImplicitImportLocation get_ImplicitImportLocation();
    public abstract virtual ProjectElement get_OriginalElement();
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectImportGroupElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionGroupElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectItemDefinitionLink : object {
    public Project Project { get; }
    public string ItemType { get; }
    public ICollection`1<ProjectMetadata> Metadata { get; }
    public abstract virtual Project get_Project();
    public abstract virtual string get_ItemType();
    public abstract virtual ICollection`1<ProjectMetadata> get_Metadata();
    public abstract virtual ProjectMetadata GetMetadata(string name);
    public abstract virtual string GetMetadataValue(string name);
    public abstract virtual ProjectMetadata SetMetadataValue(string name, string unevaluatedValue);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectItemElementLink : ProjectElementContainerLink {
    public abstract virtual void ChangeItemType(string newType);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectItemGroupElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectItemLink : object {
    public Project Project { get; }
    public ProjectItemElement Xml { get; }
    public string EvaluatedInclude { get; }
    public ICollection`1<ProjectMetadata> MetadataCollection { get; }
    public ICollection`1<ProjectMetadata> DirectMetadata { get; }
    public abstract virtual Project get_Project();
    public abstract virtual ProjectItemElement get_Xml();
    public abstract virtual string get_EvaluatedInclude();
    public abstract virtual ICollection`1<ProjectMetadata> get_MetadataCollection();
    public abstract virtual ICollection`1<ProjectMetadata> get_DirectMetadata();
    public abstract virtual bool HasMetadata(string name);
    public abstract virtual ProjectMetadata GetMetadata(string name);
    public abstract virtual string GetMetadataValue(string name);
    public abstract virtual ProjectMetadata SetMetadataValue(string name, string unevaluatedValue, bool propagateMetadataToSiblingItems);
    public abstract virtual bool RemoveMetadata(string name);
    public abstract virtual void Rename(string name);
    public abstract virtual void ChangeItemType(string newItemType);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectLink : object {
    public ProjectRootElement Xml { get; }
    public bool ThrowInsteadOfSplittingItemElement { get; public set; }
    public bool IsDirty { get; }
    public IDictionary`2<string, string> GlobalProperties { get; }
    public ICollection`1<string> ItemTypes { get; }
    public ICollection`1<ProjectProperty> Properties { get; }
    public IDictionary`2<string, List`1<string>> ConditionedProperties { get; }
    public IDictionary`2<string, ProjectItemDefinition> ItemDefinitions { get; }
    public ICollection`1<ProjectItem> Items { get; }
    public ICollection`1<ProjectItem> ItemsIgnoringCondition { get; }
    public IList`1<ResolvedImport> Imports { get; }
    public IList`1<ResolvedImport> ImportsIncludingDuplicates { get; }
    public IDictionary`2<string, ProjectTargetInstance> Targets { get; }
    public ICollection`1<ProjectProperty> AllEvaluatedProperties { get; }
    public ICollection`1<ProjectMetadata> AllEvaluatedItemDefinitionMetadata { get; }
    public ICollection`1<ProjectItem> AllEvaluatedItems { get; }
    public string ToolsVersion { get; }
    public string SubToolsetVersion { get; }
    public bool SkipEvaluation { get; public set; }
    public bool DisableMarkDirty { get; public set; }
    public bool IsBuildEnabled { get; public set; }
    public int LastEvaluationId { get; }
    public abstract virtual ProjectRootElement get_Xml();
    public abstract virtual bool get_ThrowInsteadOfSplittingItemElement();
    public abstract virtual void set_ThrowInsteadOfSplittingItemElement(bool value);
    public abstract virtual bool get_IsDirty();
    public abstract virtual IDictionary`2<string, string> get_GlobalProperties();
    public abstract virtual ICollection`1<string> get_ItemTypes();
    public abstract virtual ICollection`1<ProjectProperty> get_Properties();
    public abstract virtual IDictionary`2<string, List`1<string>> get_ConditionedProperties();
    public abstract virtual IDictionary`2<string, ProjectItemDefinition> get_ItemDefinitions();
    public abstract virtual ICollection`1<ProjectItem> get_Items();
    public abstract virtual ICollection`1<ProjectItem> get_ItemsIgnoringCondition();
    public abstract virtual IList`1<ResolvedImport> get_Imports();
    public abstract virtual IList`1<ResolvedImport> get_ImportsIncludingDuplicates();
    public abstract virtual IDictionary`2<string, ProjectTargetInstance> get_Targets();
    public abstract virtual ICollection`1<ProjectProperty> get_AllEvaluatedProperties();
    public abstract virtual ICollection`1<ProjectMetadata> get_AllEvaluatedItemDefinitionMetadata();
    public abstract virtual ICollection`1<ProjectItem> get_AllEvaluatedItems();
    public abstract virtual string get_ToolsVersion();
    public abstract virtual string get_SubToolsetVersion();
    public abstract virtual bool get_SkipEvaluation();
    public abstract virtual void set_SkipEvaluation(bool value);
    public abstract virtual bool get_DisableMarkDirty();
    public abstract virtual void set_DisableMarkDirty(bool value);
    public abstract virtual bool get_IsBuildEnabled();
    public abstract virtual void set_IsBuildEnabled(bool value);
    public abstract virtual int get_LastEvaluationId();
    public abstract virtual List`1<GlobResult> GetAllGlobs(EvaluationContext evaluationContext);
    public abstract virtual List`1<GlobResult> GetAllGlobs(string itemType, EvaluationContext evaluationContext);
    public abstract virtual List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, EvaluationContext evaluationContext);
    public abstract virtual List`1<ProvenanceResult> GetItemProvenance(string itemToMatch, string itemType, EvaluationContext evaluationContext);
    public abstract virtual List`1<ProvenanceResult> GetItemProvenance(ProjectItem item, EvaluationContext evaluationContext);
    public abstract virtual IEnumerable`1<ProjectElement> GetLogicalProject();
    public abstract virtual ProjectProperty GetProperty(string name);
    public abstract virtual string GetPropertyValue(string name);
    public abstract virtual ProjectProperty SetProperty(string name, string unevaluatedValue);
    public abstract virtual bool SetGlobalProperty(string name, string escapedValue);
    public abstract virtual IList`1<ProjectItem> AddItem(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public abstract virtual IList`1<ProjectItem> AddItemFast(string itemType, string unevaluatedInclude, IEnumerable`1<KeyValuePair`2<string, string>> metadata);
    public abstract virtual ICollection`1<ProjectItem> GetItems(string itemType);
    public abstract virtual ICollection`1<ProjectItem> GetItemsIgnoringCondition(string itemType);
    public abstract virtual ICollection`1<ProjectItem> GetItemsByEvaluatedInclude(string evaluatedInclude);
    public abstract virtual bool RemoveProperty(ProjectProperty property);
    public abstract virtual bool RemoveGlobalProperty(string name);
    public abstract virtual bool RemoveItem(ProjectItem item);
    public abstract virtual void RemoveItems(IEnumerable`1<ProjectItem> items);
    public abstract virtual string ExpandString(string unexpandedValue);
    public abstract virtual ProjectInstance CreateProjectInstance(ProjectInstanceSettings settings, EvaluationContext evaluationContext);
    public abstract virtual void MarkDirty();
    public abstract virtual void ReevaluateIfNecessary(EvaluationContext evaluationContext);
    public abstract virtual void SaveLogicalProject(TextWriter writer);
    public abstract virtual bool Build(String[] targets, IEnumerable`1<ILogger> loggers, IEnumerable`1<ForwardingLoggerRecord> remoteLoggers, EvaluationContext evaluationContext);
    public abstract virtual void Unload();
    public virtual bool GlobalPropertiesContains(string key);
    public virtual int GlobalPropertiesCount();
    public virtual IEnumerable`1<KeyValuePair`2<string, string>> GlobalPropertiesEnumerable();
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectMetadataElementLink : ProjectElementLink {
    public string Value { get; public set; }
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual void ChangeName(string newName);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectMetadataLink : object {
    public object Parent { get; }
    public ProjectMetadataElement Xml { get; }
    public string EvaluatedValueEscaped { get; }
    public ProjectMetadata Predecessor { get; }
    public abstract virtual object get_Parent();
    public abstract virtual ProjectMetadataElement get_Xml();
    public abstract virtual string get_EvaluatedValueEscaped();
    public abstract virtual ProjectMetadata get_Predecessor();
    public static object GetParent(ProjectMetadata metadata);
    public static string GetEvaluatedValueEscaped(ProjectMetadata metadata);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectOnErrorElementLink : ProjectElementLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectOtherwiseElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectOutputElementLink : ProjectElementLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectPropertyElementLink : ProjectElementLink {
    public string Value { get; public set; }
    public abstract virtual string get_Value();
    public abstract virtual void set_Value(string value);
    public abstract virtual void ChangeName(string newName);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectPropertyGroupElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectPropertyLink : object {
    public Project Project { get; }
    public ProjectPropertyElement Xml { get; }
    public string Name { get; }
    public string EvaluatedIncludeEscaped { get; }
    public string UnevaluatedValue { get; public set; }
    public bool IsEnvironmentProperty { get; }
    public bool IsGlobalProperty { get; }
    public bool IsReservedProperty { get; }
    public ProjectProperty Predecessor { get; }
    public bool IsImported { get; }
    public abstract virtual Project get_Project();
    public abstract virtual ProjectPropertyElement get_Xml();
    public abstract virtual string get_Name();
    public abstract virtual string get_EvaluatedIncludeEscaped();
    public abstract virtual string get_UnevaluatedValue();
    public abstract virtual void set_UnevaluatedValue(string value);
    public abstract virtual bool get_IsEnvironmentProperty();
    public abstract virtual bool get_IsGlobalProperty();
    public abstract virtual bool get_IsReservedProperty();
    public abstract virtual ProjectProperty get_Predecessor();
    public abstract virtual bool get_IsImported();
    public static string GetEvaluatedValueEscaped(ProjectProperty property);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectRootElementLink : ProjectElementContainerLink {
    public int Version { get; }
    public bool HasUnsavedChanges { get; }
    public DateTime TimeLastChanged { get; }
    public DateTime LastWriteTimeWhenRead { get; }
    public string DirectoryPath { get; }
    public string FullPath { get; public set; }
    public ElementLocation ProjectFileLocation { get; }
    public Encoding Encoding { get; }
    public string RawXml { get; }
    public bool PreserveFormatting { get; }
    public abstract virtual int get_Version();
    public abstract virtual bool get_HasUnsavedChanges();
    public abstract virtual DateTime get_TimeLastChanged();
    public abstract virtual DateTime get_LastWriteTimeWhenRead();
    public abstract virtual string get_DirectoryPath();
    public abstract virtual string get_FullPath();
    public abstract virtual void set_FullPath(string value);
    public abstract virtual ElementLocation get_ProjectFileLocation();
    public abstract virtual Encoding get_Encoding();
    public abstract virtual string get_RawXml();
    public abstract virtual bool get_PreserveFormatting();
    public abstract virtual ProjectChooseElement CreateChooseElement();
    public abstract virtual ProjectImportElement CreateImportElement(string project);
    public abstract virtual ProjectItemElement CreateItemElement(string itemType);
    public abstract virtual ProjectItemElement CreateItemElement(string itemType, string include);
    public abstract virtual ProjectItemDefinitionElement CreateItemDefinitionElement(string itemType);
    public abstract virtual ProjectItemDefinitionGroupElement CreateItemDefinitionGroupElement();
    public abstract virtual ProjectItemGroupElement CreateItemGroupElement();
    public abstract virtual ProjectImportGroupElement CreateImportGroupElement();
    public abstract virtual ProjectMetadataElement CreateMetadataElement(string name);
    public abstract virtual ProjectMetadataElement CreateMetadataElement(string name, string unevaluatedValue);
    public abstract virtual ProjectOnErrorElement CreateOnErrorElement(string executeTargets);
    public abstract virtual ProjectOtherwiseElement CreateOtherwiseElement();
    public abstract virtual ProjectOutputElement CreateOutputElement(string taskParameter, string itemType, string propertyName);
    public abstract virtual ProjectExtensionsElement CreateProjectExtensionsElement();
    public abstract virtual ProjectPropertyGroupElement CreatePropertyGroupElement();
    public abstract virtual ProjectPropertyElement CreatePropertyElement(string name);
    public abstract virtual ProjectTargetElement CreateTargetElement(string name);
    public abstract virtual ProjectTaskElement CreateTaskElement(string name);
    public abstract virtual ProjectUsingTaskElement CreateUsingTaskElement(string taskName, string assemblyFile, string assemblyName, string runtime, string architecture);
    public abstract virtual UsingTaskParameterGroupElement CreateUsingTaskParameterGroupElement();
    public abstract virtual ProjectUsingTaskParameterElement CreateUsingTaskParameterElement(string name, string output, string required, string parameterType);
    public abstract virtual ProjectUsingTaskBodyElement CreateUsingTaskBodyElement(string evaluate, string body);
    public abstract virtual ProjectWhenElement CreateWhenElement(string condition);
    public abstract virtual ProjectSdkElement CreateProjectSdkElement(string sdkName, string sdkVersion);
    public abstract virtual void Save(Encoding saveEncoding);
    public abstract virtual void Save(TextWriter writer);
    public abstract virtual void ReloadFrom(string path, bool throwIfUnsavedChanges, bool preserveFormatting);
    public abstract virtual void ReloadFrom(XmlReader reader, bool throwIfUnsavedChanges, bool preserveFormatting);
    public abstract virtual void MarkDirty(string reason, string param);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectSdkElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectTargetElementLink : ProjectElementContainerLink {
    public string Name { get; public set; }
    unknown string Returns {public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual void set_Returns(string value);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectTaskElementLink : ProjectElementContainerLink {
    public IDictionary`2<string, string> Parameters { get; }
    public IEnumerable`1<KeyValuePair`2<string, ElementLocation>> ParameterLocations { get; }
    public abstract virtual IDictionary`2<string, string> get_Parameters();
    public abstract virtual IEnumerable`1<KeyValuePair`2<string, ElementLocation>> get_ParameterLocations();
    public abstract virtual string GetParameter(string name);
    public abstract virtual void SetParameter(string name, string unevaluatedValue);
    public abstract virtual void RemoveParameter(string name);
    public abstract virtual void RemoveAllParameters();
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskBodyElementLink : ProjectElementLink {
    public string TaskBody { get; public set; }
    public abstract virtual string get_TaskBody();
    public abstract virtual void set_TaskBody(string value);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectUsingTaskParameterElementLink : ProjectElementLink {
    public string Name { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
public abstract class Microsoft.Build.ObjectModelRemoting.ProjectWhenElementLink : ProjectElementContainerLink {
}
public abstract class Microsoft.Build.ObjectModelRemoting.UsingTaskParameterGroupElementLink : ProjectElementContainerLink {
}
public class Microsoft.Build.ObjectModelRemoting.XmlAttributeLink : ValueType {
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamespaceURI>k__BackingField;
    public string LocalName { get; }
    public string Value { get; }
    public string NamespaceURI { get; }
    public XmlAttributeLink(string localName, string value, string namespaceUri);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_LocalName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_NamespaceURI();
}
internal abstract class Microsoft.Build.Shared.AssemblyLoadInfo : object {
    public string AssemblyName { get; }
    public string AssemblyFile { get; }
    internal string AssemblyLocation { get; }
    internal static AssemblyLoadInfo Create(string assemblyName, string assemblyFile);
    public abstract virtual string get_AssemblyName();
    public abstract virtual string get_AssemblyFile();
    internal abstract virtual string get_AssemblyLocation();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(AssemblyLoadInfo other);
    public virtual bool Equals(object obj);
    public sealed virtual void Translate(ITranslator translator);
    public static AssemblyLoadInfo FactoryForTranslation(ITranslator translator);
}
internal class Microsoft.Build.Shared.AssemblyNameComparer : object {
    internal static IComparer Comparer;
    internal static IComparer ComparerConsiderRetargetable;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparer;
    internal static IEqualityComparer`1<AssemblyNameExtension> GenericComparerConsiderRetargetable;
    private bool considerRetargetableFlag;
    private AssemblyNameComparer(bool considerRetargetableFlag);
    private static AssemblyNameComparer();
    public sealed virtual int Compare(object o1, object o2);
    public sealed virtual bool Equals(object o1, object o2);
    public sealed virtual int GetHashCode(object o);
    public sealed virtual bool Equals(AssemblyNameExtension x, AssemblyNameExtension y);
    public sealed virtual int GetHashCode(AssemblyNameExtension obj);
}
internal class Microsoft.Build.Shared.AssemblyNameExtension : object {
    private AssemblyName asAssemblyName;
    private string asString;
    private bool isSimpleName;
    private bool hasProcessorArchitectureInFusionName;
    private bool immutable;
    private HashSet`1<AssemblyNameExtension> remappedFrom;
    private static AssemblyNameExtension s_unnamedAssembly;
    internal string Name { get; }
    internal ProcessorArchitecture ProcessorArchitecture { get; }
    internal Version Version { get; }
    internal bool IsSimpleName { get; }
    internal bool HasProcessorArchitectureInFusionName { get; }
    internal CultureInfo CultureInfo { get; }
    internal bool Retargetable { get; }
    internal IEnumerable`1<AssemblyNameExtension> RemappedFromEnumerator { get; }
    internal AssemblyName AssemblyName { get; }
    internal string FullName { get; }
    internal static AssemblyNameExtension UnnamedAssembly { get; }
    public bool Immutable { get; }
    internal bool IsUnnamedAssembly { get; }
    internal AssemblyNameExtension(AssemblyName assemblyName);
    internal AssemblyNameExtension(string assemblyName);
    internal AssemblyNameExtension(string assemblyName, bool validate);
    private AssemblyNameExtension(SerializationInfo info, StreamingContext context);
    internal AssemblyNameExtension(ITranslator translator);
    private static AssemblyNameExtension();
    internal static AssemblyNameExtension GetAssemblyNameEx(string path);
    [OnDeserializedAttribute]
private void SetRemappedFromDefaultAfterSerialization(StreamingContext sc);
    private void InitializeRemappedFrom();
    private static HashSet`1<AssemblyNameExtension> CreateRemappedFrom();
    private void CreateAssemblyName();
    private void CreateFullName();
    internal string get_Name();
    internal ProcessorArchitecture get_ProcessorArchitecture();
    internal Version get_Version();
    internal bool get_IsSimpleName();
    internal bool get_HasProcessorArchitectureInFusionName();
    internal void ReplaceVersion(Version version);
    internal CultureInfo get_CultureInfo();
    internal bool get_Retargetable();
    internal IEnumerable`1<AssemblyNameExtension> get_RemappedFromEnumerator();
    internal void AddRemappedAssemblyName(AssemblyNameExtension extensionToAdd);
    internal AssemblyName get_AssemblyName();
    internal string get_FullName();
    internal Byte[] GetPublicKeyToken();
    internal static AssemblyNameExtension get_UnnamedAssembly();
    internal int CompareTo(AssemblyNameExtension that);
    internal int CompareTo(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal int GetHashCode();
    internal int CompareBaseNameTo(AssemblyNameExtension that);
    private int CompareBaseNameToImpl(AssemblyNameExtension that);
    private static int CompareBaseNamesStringWise(string asString1, string asString2);
    internal AssemblyNameExtension Clone();
    internal AssemblyNameExtension CloneImmutable();
    public bool get_Immutable();
    internal void MarkImmutable();
    internal bool Equals(AssemblyNameExtension that);
    private sealed virtual override bool System.IEquatable<Microsoft.Build.Shared.AssemblyNameExtension>.Equals(AssemblyNameExtension other);
    internal bool EqualsIgnoreVersion(AssemblyNameExtension that);
    internal bool Equals(AssemblyNameExtension that, bool considerRetargetableFlag);
    private bool EqualsImpl(AssemblyNameExtension that, bool ignoreVersion, bool considerRetargetableFlag);
    internal static bool CompareCultures(AssemblyName a, AssemblyName b);
    internal bool ComparePublicKeyToken(AssemblyNameExtension that);
    internal static bool ComparePublicKeyTokens(Byte[] aPKT, Byte[] bPKT);
    internal bool get_IsUnnamedAssembly();
    private static AssemblyName GetAssemblyNameFromDisplayName(string displayName);
    internal static string EscapeDisplayNameCharacters(string displayName);
    public virtual string ToString();
    internal bool PartialNameCompare(AssemblyNameExtension that);
    internal bool PartialNameCompare(AssemblyNameExtension that, bool considerRetargetableFlag);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags);
    internal bool PartialNameCompare(AssemblyNameExtension that, PartialComparisonFlags comparisonFlags, bool considerRetargetableFlag);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void Translate(ITranslator translator);
}
internal class Microsoft.Build.Shared.AssemblyNameReverseVersionComparer : object {
    internal static IComparer`1<AssemblyNameExtension> GenericComparer;
    private static AssemblyNameReverseVersionComparer();
    public sealed virtual int Compare(AssemblyNameExtension x, AssemblyNameExtension y);
}
internal static class Microsoft.Build.Shared.AssemblyResources : object {
    private static ResourceManager s_msbuildExeResourceManager;
    private static ResourceManager s_resources;
    private static ResourceManager s_sharedResources;
    internal static ResourceManager PrimaryResources { get; }
    internal static ResourceManager SharedResources { get; }
    private static AssemblyResources();
    internal static void RegisterMSBuildExeResources(ResourceManager manager);
    internal static string GetString(string name);
    internal static string GetStringLookingInMSBuildExeResourcesFirst(string name);
    private static string GetStringFromEngineResources(string name);
    private static string GetStringFromMSBuildExeResources(string name);
    internal static ResourceManager get_PrimaryResources();
    internal static ResourceManager get_SharedResources();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.AwaitExtensions : object {
    private static object s_staSchedulerSync;
    private static TaskScheduler s_staScheduler;
    internal static TaskScheduler OneSTAThreadPerTaskSchedulerInstance { get; }
    private static AwaitExtensions();
    internal static TaskScheduler get_OneSTAThreadPerTaskSchedulerInstance();
    [ExtensionAttribute]
internal static TaskAwaiter GetAwaiter(WaitHandle handle);
    [ExtensionAttribute]
internal static TaskAwaiter`1<int> GetAwaiter(WaitHandle[] handles);
    [ExtensionAttribute]
internal static Task ToTask(WaitHandle handle, int timeout);
    [ExtensionAttribute]
internal static Task`1<int> ToTask(WaitHandle[] handles, int timeout);
}
internal class Microsoft.Build.Shared.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private BuildEnvironmentMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningTests>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningInVisualStudio>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectoryRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectory64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildToolsDirectoryArm64>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildConfigurationFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildExePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CurrentMSBuildToolsDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioInstallRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildExtensionsPath>k__BackingField;
    internal BuildEnvironmentMode Mode { get; }
    internal bool RunningTests { get; }
    internal bool RunningInVisualStudio { get; }
    internal string MSBuildToolsDirectoryRoot { get; }
    internal string MSBuildToolsDirectory32 { get; }
    internal string MSBuildToolsDirectory64 { get; }
    internal string MSBuildToolsDirectoryArm64 { get; }
    internal string MSBuildSDKsPath { get; }
    internal string CurrentMSBuildConfigurationFile { get; }
    internal string CurrentMSBuildExePath { get; private set; }
    internal string CurrentMSBuildToolsDirectory { get; }
    internal string VisualStudioInstallRootDirectory { get; }
    internal string MSBuildExtensionsPath { get; internal set; }
    public BuildEnvironment(BuildEnvironmentMode mode, string currentMSBuildExePath, bool runningTests, bool runningInVisualStudio, string visualStudioPath);
    [CompilerGeneratedAttribute]
internal BuildEnvironmentMode get_Mode();
    [CompilerGeneratedAttribute]
internal bool get_RunningTests();
    [CompilerGeneratedAttribute]
internal bool get_RunningInVisualStudio();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectoryRoot();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory32();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectory64();
    [CompilerGeneratedAttribute]
internal string get_MSBuildToolsDirectoryArm64();
    internal string get_MSBuildSDKsPath();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildConfigurationFile();
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildExePath();
    [CompilerGeneratedAttribute]
private void set_CurrentMSBuildExePath(string value);
    [CompilerGeneratedAttribute]
internal string get_CurrentMSBuildToolsDirectory();
    [CompilerGeneratedAttribute]
internal string get_VisualStudioInstallRootDirectory();
    [CompilerGeneratedAttribute]
internal string get_MSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
internal void set_MSBuildExtensionsPath(string value);
}
internal class Microsoft.Build.Shared.BuildEnvironmentHelper : object {
    private static string CurrentVisualStudioVersion;
    private static string CurrentToolsVersion;
    private static String[] s_visualStudioProcess;
    private static String[] s_msBuildProcess;
    private static String[] s_msBuildExeNames;
    private static Nullable`1<bool> _runningTests;
    private static object _runningTestsLock;
    private static Func`1<string> s_getProcessFromRunningProcess;
    private static Func`1<string> s_getExecutingAssemblyPath;
    private static Func`1<string> s_getAppContextBaseDirectory;
    private static Func`1<IEnumerable`1<VisualStudioInstance>> s_getVisualStudioInstances;
    private static Func`2<string, string> s_getEnvironmentVariable;
    private static Func`1<bool> s_runningTests;
    public static BuildEnvironment Instance { get; }
    private static BuildEnvironmentHelper();
    public static BuildEnvironment get_Instance();
    private static BuildEnvironment Initialize();
    private static BuildEnvironment TryFromEnvironmentVariable();
    private static BuildEnvironment TryFromVisualStudioProcess();
    private static BuildEnvironment TryFromMSBuildProcess();
    private static BuildEnvironment TryFromMSBuildAssembly();
    private static BuildEnvironment TryFromMSBuildExeUnderVisualStudio(string msbuildExe, bool allowLegacyToolsVersion);
    private static BuildEnvironment TryFromDevConsole();
    private static BuildEnvironment TryFromSetupApi();
    private static BuildEnvironment TryFromAppContextBaseDirectory();
    private static BuildEnvironment TryFromStandaloneMSBuildExe(string msBuildExePath);
    private static string GetVsRootFromMSBuildAssembly(string msBuildAssembly);
    private static string GetMSBuildExeFromVsRoot(string visualStudioRoot);
    private static bool CheckIfRunningTests();
    private static bool IsProcessInList(string processName, String[] processList);
    private static string GetProcessFromRunningProcess();
    private static string GetExecutingAssemblyPath();
    private static string GetAppContextBaseDirectory();
    private static string GetEnvironmentVariable(string variable);
    internal static void ResetInstance_ForUnitTestsOnly(Func`1<string> getProcessFromRunningProcess, Func`1<string> getExecutingAssemblyPath, Func`1<string> getAppContextBaseDirectory, Func`1<IEnumerable`1<VisualStudioInstance>> getVisualStudioInstances, Func`2<string, string> getEnvironmentVariable, Func`1<bool> runningTests);
    internal static void ResetInstance_ForUnitTestsOnly(BuildEnvironment buildEnvironment);
}
internal enum Microsoft.Build.Shared.BuildEnvironmentMode : Enum {
    public int value__;
    public static BuildEnvironmentMode VisualStudio;
    public static BuildEnvironmentMode Standalone;
    public static BuildEnvironmentMode None;
}
internal class Microsoft.Build.Shared.BuildEventFileInfo : object {
    internal static BuildEventFileInfo Empty;
    private string _file;
    private int _line;
    private int _column;
    private int _endLine;
    private int _endColumn;
    internal string File { get; }
    internal int Line { get; }
    internal int Column { get; }
    internal int EndLine { get; }
    internal int EndColumn { get; }
    internal BuildEventFileInfo(string file);
    internal BuildEventFileInfo(IElementLocation location);
    internal BuildEventFileInfo(string file, int line, int column);
    internal BuildEventFileInfo(string file, int line, int column, int endLine, int endColumn);
    internal BuildEventFileInfo(XmlException e);
    internal BuildEventFileInfo(string file, XmlException e);
    private static BuildEventFileInfo();
    internal string get_File();
    internal int get_Line();
    internal int get_Column();
    internal int get_EndLine();
    internal int get_EndColumn();
}
internal static class Microsoft.Build.Shared.CanonicalError : object {
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression;
    private static Lazy`1<Regex> s_originCategoryCodeTextExpression2;
    private static Lazy`1<Regex> s_filenameLocationFromOrigin;
    private static Lazy`1<Regex> s_lineFromLocation;
    private static Lazy`1<Regex> s_lineLineFromLocation;
    private static Lazy`1<Regex> s_lineColFromLocation;
    private static Lazy`1<Regex> s_lineColColFromLocation;
    private static Lazy`1<Regex> s_lineColLineColFromLocation;
    private static CanonicalError();
    private static int ConvertToIntWithDefault(string value);
    internal static Parts Parse(string message);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.CollectionHelpers : object {
    internal static List`1<T> RemoveNulls(List`1<T> inputs);
    [ExtensionAttribute]
internal static bool ContainsValueAndIsEqual(Dictionary`2<string, string> dictionary, string key, string value, StringComparison comparer);
    internal static bool SetEquivalent(IEnumerable`1<T> a, IEnumerable`1<T> b);
    internal static bool DictionaryEquals(IReadOnlyDictionary`2<K, V> a, IReadOnlyDictionary`2<K, V> b);
}
internal static class Microsoft.Build.Shared.ConversionUtilities : object {
    internal static bool ConvertStringToBool(string parameterValue);
    internal static bool ConvertStringToBool(string parameterValue, bool nullOrWhitespaceIsFalse);
    internal static string ConvertByteArrayToHex(Byte[] bytes);
    internal static bool TryConvertStringToBool(string parameterValue, Boolean& boolValue);
    internal static bool CanConvertStringToBool(string parameterValue);
    internal static bool ValidBooleanTrue(string parameterValue);
    internal static bool ValidBooleanFalse(string parameterValue);
    internal static double ConvertDecimalToDouble(string number);
    internal static double ConvertHexToDouble(string number);
    internal static double ConvertDecimalOrHexToDouble(string number);
    internal static bool TryConvertDecimalOrHexToDouble(string number, Double& doubleValue);
    private static bool ValidHexNumber(string number, Int32& value);
    private static bool ValidDecimalNumber(string number, Double& value);
    internal static bool ValidDecimalOrHexNumber(string number);
}
internal static class Microsoft.Build.Shared.Debugging.DebugUtils : object {
    private static Lazy`1<NodeMode> ProcessNodeMode;
    public static string ProcessInfoString;
    public static bool ShouldDebugCurrentProcess;
    [CompilerGeneratedAttribute]
private static string <DebugPath>k__BackingField;
    public static string DebugPath { get; }
    private static DebugUtils();
    private static bool CurrentProcessMatchesDebugName();
    [CompilerGeneratedAttribute]
public static string get_DebugPath();
    public static string FindNextAvailableDebugFilePath(string fileName);
    [CompilerGeneratedAttribute]
internal static NodeMode <.cctor>g__ScanNodeMode|1_1(string input);
}
internal class Microsoft.Build.Shared.Debugging.PrintLineDebugger : object {
    private static Lazy`1<PropertyInfo> CommonWriterProperty;
    public static Lazy`1<PrintLineDebugger> Default;
    public static Lazy`1<PrintLineDebugger> DefaultWithProcessInfo;
    private string _id;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`3<string, string, IEnumerable`1<string>> _writerSetByThisInstance;
    public PrintLineDebugger(string id, Action`3<string, string, IEnumerable`1<string>> writer);
    private static PrintLineDebugger();
    public sealed virtual void Dispose();
    public static Action`3<string, string, IEnumerable`1<string>> GetStaticWriter();
    public static void SetWriter(Action`3<string, string, IEnumerable`1<string>> writer);
    public static void UnsetWriter();
    public static PrintLineDebugger Create(Action`3<string, string, IEnumerable`1<string>> writer, string id, bool prependProcessInfo);
    public Action`3<string, string, IEnumerable`1<string>> GetWriter();
    public void Log(string message, string memberName, string sourceFilePath, int sourceLineNumber);
    public void Log(IEnumerable`1<string> args, string memberName, string sourceFilePath, int sourceLineNumber);
    private static string CallsiteString(string sourceFilePath, string memberName, int sourceLineNumber);
    private void ReleaseUnmanagedResources();
    protected virtual override void Finalize();
}
internal static class Microsoft.Build.Shared.Debugging.PrintLineDebuggerWriters : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Action`3<string, string, IEnumerable`1<string>> StdOutWriter;
    private static Lazy`1<string> _artifactsLogs;
    public static string ArtifactsLogDirectory { get; }
    private static PrintLineDebuggerWriters();
    public static string get_ArtifactsLogDirectory();
    public static string SimpleFormat(string id, string callsite, IEnumerable`1<string> args);
    public static string CsvFormat(string id, string callsite, IEnumerable`1<string> args);
    [CompilerGeneratedAttribute]
internal static string <CsvFormat>g__EscapeCommas|7_1(string s);
}
internal class Microsoft.Build.Shared.DirectoryExists : MulticastDelegate {
    public DirectoryExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.DirectoryGetFiles : MulticastDelegate {
    public DirectoryGetFiles(object object, IntPtr method);
    public virtual String[] Invoke(string path, string searchPattern);
    public virtual IAsyncResult BeginInvoke(string path, string searchPattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal enum Microsoft.Build.Shared.DotNetFrameworkArchitecture : Enum {
    public int value__;
    public static DotNetFrameworkArchitecture Current;
    public static DotNetFrameworkArchitecture Bitness32;
    public static DotNetFrameworkArchitecture Bitness64;
}
internal class Microsoft.Build.Shared.EncodingStringWriter : StringWriter {
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public EncodingStringWriter(Encoding encoding);
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
}
internal static class Microsoft.Build.Shared.EnvironmentUtilities : object {
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    [NullableContextAttribute("1")]
public static bool IsWellKnownEnvironmentDerivedProperty(string propertyName);
}
internal static class Microsoft.Build.Shared.ErrorUtilities : object {
    private static bool s_enableMSBuildDebugTracing;
    private static ErrorUtilities();
    public static void DebugTraceMessage(string category, string formatstring, Object[] parameters);
    internal static void VerifyThrowInternalError(bool condition, string message, Object[] args);
    internal static void ThrowInternalError(string message, Object[] args);
    internal static void ThrowInternalError(string message, Exception innerException, Object[] args);
    internal static void ThrowInternalErrorUnreachable();
    internal static void VerifyThrowInternalErrorUnreachable(bool condition);
    internal static void ThrowIfTypeDoesNotImplementToString(object param);
    internal static void VerifyThrowInternalNull(object parameter, string parameterName);
    internal static void VerifyThrowInternalLockHeld(object locker);
    internal static void VerifyThrowInternalLength(string parameterValue, string parameterName);
    public static void VerifyThrowInternalLength(T[] parameterValue, string parameterName);
    internal static void VerifyThrowInternalRooted(string value);
    internal static void VerifyThrow(bool condition, string unformattedMessage);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2);
    internal static void VerifyThrow(bool condition, string unformattedMessage, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowInvalidOperation(string resourceName, Object[] args);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowInvalidOperation(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgument(string resourceName, Object[] args);
    internal static void ThrowArgument(Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowArgument(bool condition, string resourceName);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2);
    internal static void VerifyThrowArgument(bool condition, Exception innerException, string resourceName, object arg0, object arg1, object arg2, object arg3);
    internal static void ThrowArgumentOutOfRange(string parameterName);
    internal static void VerifyThrowArgumentOutOfRange(bool condition, string parameterName);
    internal static void VerifyThrowArgumentLength(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLength(IReadOnlyCollection`1<T> parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(IReadOnlyCollection`1<T> parameter, string parameterName);
    private static void ThrowArgumentLength(string parameterName);
    internal static void VerifyThrowArgumentInvalidPath(string parameter, string parameterName);
    internal static void VerifyThrowArgumentLengthIfNotNull(string parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName);
    internal static void VerifyThrowArgumentNull(object parameter, string parameterName, string resourceName);
    internal static void ThrowArgumentNull(string parameterName, string resourceName);
    internal static void VerifyThrowArgumentArraysSameLength(Array parameter1, Array parameter2, string parameter1Name, string parameter2Name);
    internal static void VerifyThrowObjectDisposed(bool condition, string objectName);
    internal static void ThrowObjectDisposed(string objectName);
}
internal static class Microsoft.Build.Shared.EscapingUtilities : object {
    private static Dictionary`2<string, string> s_unescapedToEscapedStrings;
    private static Char[] s_charsToEscape;
    private static EscapingUtilities();
    private static bool TryDecodeHexDigit(char character, Int32& value);
    internal static string UnescapeAll(string escapedString, bool trim);
    internal static string EscapeWithCaching(string unescapedString);
    internal static string Escape(string unescapedString);
    private static string EscapeWithOptionalCaching(string unescapedString, bool cache);
    private static bool ContainsReservedCharacters(string unescapedString);
    internal static bool ContainsEscapedWildcards(string escapedString);
    private static char HexDigitChar(int x);
    private static void AppendEscapedChar(StringBuilder sb, char ch);
    private static void AppendEscapedString(StringBuilder sb, string unescapedString);
}
internal static class Microsoft.Build.Shared.EventArgsFormatting : object {
    private static String[] s_newLines;
    private static EventArgsFormatting();
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile, string projectConfigurationDescription);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile, string projectConfigurationDescription);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string projectConfigurationDescription, string nonNullMessage);
    internal static string FormatEventMessage(BuildErrorEventArgs e);
    internal static string FormatEventMessage(BuildErrorEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildWarningEventArgs e);
    internal static string FormatEventMessage(BuildWarningEventArgs e, bool showProjectFile);
    internal static string FormatEventMessage(BuildMessageEventArgs e);
    internal static string FormatEventMessage(BuildMessageEventArgs e, bool showProjectFile, string nonNullMessage);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId);
    internal static string FormatEventMessage(string category, string subcategory, string message, string code, string file, string projectFile, int lineNumber, int endLineNumber, int columnNumber, int endColumnNumber, int threadId, string logOutputProperties);
    private static String[] SplitStringOnNewLines(string s);
}
internal static class Microsoft.Build.Shared.ExceptionHandling : object {
    private static string s_debugDumpPath;
    private static string s_dumpFileName;
    internal static string DebugDumpPath { get; }
    private static ExceptionHandling();
    private static string GetDebugDumpPath();
    internal static string get_DebugDumpPath();
    internal static bool IsCriticalException(Exception e);
    internal static bool NotExpectedException(Exception e);
    internal static bool IsIoRelatedException(Exception e);
    internal static bool IsXmlException(Exception e);
    internal static LineAndColumn GetXmlLineAndColumn(Exception e);
    internal static bool NotExpectedIoOrXmlException(Exception e);
    internal static bool NotExpectedReflectionException(Exception e);
    internal static bool NotExpectedSerializationException(Exception e);
    internal static bool NotExpectedRegistryException(Exception e);
    internal static bool NotExpectedFunctionException(Exception e);
    internal static void UnhandledExceptionHandler(object sender, UnhandledExceptionEventArgs e);
    internal static void DumpExceptionToFile(Exception ex);
    internal static string ReadAnyExceptionFromFile(DateTime fromTimeUtc);
}
internal class Microsoft.Build.Shared.FileCopy : MulticastDelegate {
    public FileCopy(object object, IntPtr method);
    public virtual void Invoke(string source, string destination);
    public virtual IAsyncResult BeginInvoke(string source, string destination, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileCreate : MulticastDelegate {
    public FileCreate(object object, IntPtr method);
    public virtual FileStream Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual FileStream EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileDelete : MulticastDelegate {
    public FileDelete(object object, IntPtr method);
    public virtual void Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileExists : MulticastDelegate {
    public FileExists(object object, IntPtr method);
    public virtual bool Invoke(string path);
    public virtual IAsyncResult BeginInvoke(string path, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.Build.Shared.FileMatcher : object {
    private IFileSystem _fileSystem;
    private static string recursiveDirectoryMatch;
    private static string s_directorySeparator;
    private static string s_thisDirectory;
    private static Char[] s_wildcardCharacters;
    private static Char[] s_wildcardAndSemicolonCharacters;
    private static String[] s_propertyAndItemReferences;
    internal static Char[] directorySeparatorCharacters;
    private static Lazy`1<ConcurrentDictionary`2<string, IReadOnlyList`1<string>>> s_cachedGlobExpansions;
    private static Lazy`1<ConcurrentDictionary`2<string, object>> s_cachedGlobExpansionsLock;
    private ConcurrentDictionary`2<string, IReadOnlyList`1<string>> _cachedGlobExpansions;
    private Lazy`1<ConcurrentDictionary`2<string, object>> _cachedGlobExpansionsLock;
    private static Char[] s_invalidPathChars;
    public static RegexOptions DefaultRegexOptions;
    private GetFileSystemEntries _getFileSystemEntries;
    private static int FileSpecRegexMinLength;
    public static FileMatcher Default;
    public FileMatcher(IFileSystem fileSystem, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> fileEntryExpansionCache);
    internal FileMatcher(IFileSystem fileSystem, GetFileSystemEntries getFileSystemEntries, ConcurrentDictionary`2<string, IReadOnlyList`1<string>> getFileSystemDirectoryEntriesCache);
    private static FileMatcher();
    internal static void ClearFileEnumerationsCache();
    internal static bool HasWildcards(string filespec);
    internal static bool HasWildcardsSemicolonItemOrPropertyReferences(string filespec);
    internal static bool HasPropertyOrItemReferences(string filespec);
    private static IReadOnlyList`1<string> GetAccessibleFileSystemEntries(IFileSystem fileSystem, FileSystemEntity entityType, string path, string pattern, string projectDirectory, bool stripProjectDirectory);
    private static IReadOnlyList`1<string> GetAccessibleFilesAndDirectories(IFileSystem fileSystem, string path, string pattern);
    private static bool ShouldEnforceMatching(string searchPattern);
    private static IReadOnlyList`1<string> GetAccessibleFiles(IFileSystem fileSystem, string path, string filespec, string projectDirectory, bool stripProjectDirectory);
    private static IReadOnlyList`1<string> GetAccessibleDirectories(IFileSystem fileSystem, string path, string pattern);
    internal string GetLongPathName(string path);
    internal static string GetLongPathName(string path, GetFileSystemEntries getFileSystemEntries);
    internal void SplitFileSpec(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    private static void PreprocessFileSpecForSplitting(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveInitialDotSlash>d__35")]
private static IEnumerable`1<string> RemoveInitialDotSlash(IEnumerable`1<string> paths);
    internal static bool IsDirectorySeparator(char c);
    [IteratorStateMachineAttribute("Microsoft.Build.Shared.FileMatcher/<RemoveProjectDirectory>d__37")]
internal static IEnumerable`1<string> RemoveProjectDirectory(IEnumerable`1<string> paths, string projectDirectory);
    private void GetFilesRecursive(ConcurrentStack`1<List`1<string>> listOfFiles, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory, IList`1<RecursionState> searchesToExclude, Dictionary`2<string, List`1<RecursionState>> searchesToExcludeInSubdirs, TaskOptions taskOptions);
    private IEnumerable`1<string> GetFilesForStep(RecursiveStepResult stepResult, RecursionState recursionState, string projectDirectory, bool stripProjectDirectory);
    private static bool MatchFileRecursionStep(RecursionState recursionState, string file);
    private static RecursiveStepResult GetFilesRecursiveStep(RecursionState recursionState);
    internal static string RegularExpressionFromFileSpec(string fixedDirectoryPart, string wildcardDirectoryPart, string filenamePart);
    private static bool IsLegalFileSpec(string wildcardDirectoryPart, string filenamePart);
    private static bool HasDotDot(string str);
    private static bool HasMisplacedRecursiveOperator(string str);
    private static void AppendRegularExpressionFromFixedDirectory(ReuseableStringBuilder regex, string fixedDir);
    private static void AppendRegularExpressionFromWildcardDirectory(ReuseableStringBuilder regex, string wildcardDir);
    private static void AppendRegularExpressionFromFilename(ReuseableStringBuilder regex, string filename);
    private static void AppendRegularExpressionFromChar(ReuseableStringBuilder regex, char ch);
    private static bool IsSpecialRegexCharacter(char ch);
    private static int LastIndexOfDirectorySequence(string str, int startIndex);
    private static int LastIndexOfDirectoryOrRecursiveSequence(string str, int startIndex);
    internal void GetFileSpecInfoWithRegexObject(string filespec, Regex& regexFileMatch, Boolean& needsRecursion, Boolean& isLegalFileSpec);
    internal void GetFileSpecInfo(string filespec, String& fixedDirectoryPart, String& wildcardDirectoryPart, String& filenamePart, Boolean& needsRecursion, Boolean& isLegalFileSpec, FixupParts fixupParts);
    internal static bool RawFileSpecIsValid(string filespec);
    internal static bool IsFileNameMatch(string path, string pattern);
    internal static bool IsMatch(string input, string pattern);
    internal static bool IsMatch(ReadOnlySpan`1<char> input, string pattern);
    internal Result FileMatch(string filespec, string fileToMatch);
    internal static void GetRegexMatchInfo(string fileToMatch, Regex fileSpecRegex, Boolean& isMatch, String& wildcardDirectoryPart, String& filenamePart);
    internal ValueTuple`3<String[], SearchAction, string> GetFiles(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private static string ComputeFileEnumerationCacheKey(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludes);
    private SearchAction GetFileSearchData(string projectDirectoryUnescaped, string filespecUnescaped, Boolean& stripProjectDirectory, RecursionState& result);
    internal static string Normalize(string aString);
    internal static bool IsDriveEnumeratingWildcardPattern(string directoryPart, string wildcardPart);
    private static bool IsDrivePatternWithoutSlash(char firstValue, char secondValue);
    private static bool IsFullFileSystemScan(int directoryPartIndex, int directoryPartLength, string directoryPart, string wildcardPart);
    private static bool IsValidDriveChar(char value);
    private static int SkipSlashes(string aString, int startingIndex);
    private static String[] CreateArrayWithSingleItemIfNotExcluded(string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private ValueTuple`3<String[], SearchAction, string> GetFilesImplementation(string projectDirectoryUnescaped, string filespecUnescaped, List`1<string> excludeSpecsUnescaped);
    private bool InnerExceptionsAreAllIoRelated(AggregateException ex);
    private static bool IsSubdirectoryOf(string possibleChild, string possibleParent);
    private static bool DirectoryEndsWithPattern(string directoryPath, string pattern);
    internal static bool IsAllFilesWildcard(string pattern);
    internal static bool IsRecursiveDirectoryMatch(string path);
    [CompilerGeneratedAttribute]
internal static bool <IsMatch>g__CompareIgnoreCase|63_0(ReadOnlySpan`1& input, int iIndex, int pIndex, <>c__DisplayClass63_0& );
}
internal class Microsoft.Build.Shared.FileSystem.CachingFileSystemWrapper : object {
    private IFileSystem _fileSystem;
    private ConcurrentDictionary`2<string, bool> _existenceCache;
    private ConcurrentDictionary`2<string, DateTime> _lastWriteTimeCache;
    public CachingFileSystemWrapper(IFileSystem fileSystem);
    public sealed virtual bool FileOrDirectoryExists(string path);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    private bool CachedExistenceCheck(string path, Func`2<string, bool> existenceCheck);
    [CompilerGeneratedAttribute]
private bool <FileOrDirectoryExists>b__4_0(string p);
    [CompilerGeneratedAttribute]
private DateTime <GetLastWriteTimeUtc>b__6_0(string p);
    [CompilerGeneratedAttribute]
private bool <DirectoryExists>b__7_0(string p);
    [CompilerGeneratedAttribute]
private bool <FileExists>b__8_0(string p);
}
internal enum Microsoft.Build.Shared.FileSystem.FileArtifactType : Enum {
    public byte value__;
    public static FileArtifactType File;
    public static FileArtifactType Directory;
    public static FileArtifactType FileOrDirectory;
}
internal static class Microsoft.Build.Shared.FileSystem.FileSystems : object {
    public static IFileSystem Default;
    private static FileSystems();
    private static IFileSystem GetFileSystem();
}
internal interface Microsoft.Build.Shared.FileSystem.IFileSystem {
    public abstract virtual TextReader ReadFile(string path);
    public abstract virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public abstract virtual string ReadFileAllText(string path);
    public abstract virtual Byte[] ReadFileAllBytes(string path);
    public abstract virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public abstract virtual FileAttributes GetAttributes(string path);
    public abstract virtual DateTime GetLastWriteTimeUtc(string path);
    public abstract virtual bool DirectoryExists(string path);
    public abstract virtual bool FileExists(string path);
    public abstract virtual bool FileOrDirectoryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.ManagedFileSystem : object {
    private static ManagedFileSystem Instance;
    private static bool ShouldUseMicrosoftIO { get; }
    private static ManagedFileSystem();
    public static ManagedFileSystem Singleton();
    private static bool get_ShouldUseMicrosoftIO();
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    private static IEnumerable`1<string> HandleFileLoadException(Func`4<string, string, SearchOption, IEnumerable`1<string>> enumerateFunctionDelegate, string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual FileAttributes GetAttributes(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Shared.FileSystem.MSBuildOnWindowsFileSystem : object {
    private static MSBuildOnWindowsFileSystem Instance;
    private static MSBuildOnWindowsFileSystem();
    public static MSBuildOnWindowsFileSystem Singleton();
    public sealed virtual TextReader ReadFile(string path);
    public sealed virtual Stream GetFileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public sealed virtual string ReadFileAllText(string path);
    public sealed virtual Byte[] ReadFileAllBytes(string path);
    public sealed virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public sealed virtual FileAttributes GetAttributes(string path);
    public sealed virtual DateTime GetLastWriteTimeUtc(string path);
    public sealed virtual bool DirectoryExists(string path);
    public sealed virtual bool FileExists(string path);
    public sealed virtual bool FileOrDirectoryExists(string path);
}
internal class Microsoft.Build.Shared.FileSystem.NativeWin32Exception : Win32Exception {
    public NativeWin32Exception(int nativeErrorCode, string messagePrefix);
    public NativeWin32Exception(int nativeErrorCode);
    public static string GetFormattedMessageForNativeErrorCode(int nativeErrorCode, string messagePrefix);
    public static int HResultFromWin32(int nativeErrorCode);
}
internal class Microsoft.Build.Shared.FileSystem.SafeFindFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
[SupportedOSPlatform("windows")]
internal class Microsoft.Build.Shared.FileSystem.WindowsFileSystem : ManagedFileSystem {
    private static WindowsFileSystem Instance;
    private static WindowsFileSystem();
    public static WindowsFileSystem Singleton();
    public virtual IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public virtual IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public virtual bool DirectoryExists(string path);
    public virtual bool FileExists(string path);
    public virtual bool FileOrDirectoryExists(string path);
    public virtual DateTime GetLastWriteTimeUtc(string path);
    private static IEnumerable`1<string> EnumerateFileOrDirectories(string directoryPath, FileArtifactType fileArtifactType, string searchPattern, SearchOption searchOption);
    private static EnumerateDirectoryResult CustomEnumerateDirectoryEntries(string directoryPath, FileArtifactType fileArtifactType, string pattern, SearchOption searchOption, ICollection`1<string> result);
}
internal static class Microsoft.Build.Shared.FileSystem.WindowsNative : object {
    public static int MaxPath;
    public static int ErrorSuccess;
    public static int ErrorFileNotFound;
    public static int ErrorPathNotFound;
    public static int ErrorDirectory;
    public static int ErrorAccessDenied;
    public static UInt32 ErrorNoMoreFiles;
    public static SafeFindFileHandle FindFirstFileW(string lpFileName, Win32FindData& lpFindFileData);
    public static bool FindNextFileW(SafeHandle hFindFile, Win32FindData& lpFindFileData);
    public static int PathMatchSpecExW(string pszFileParam, string pszSpec, int flags);
    internal static bool FindClose(IntPtr findFileHandle);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.FileUtilities : object {
    internal static string cacheDirectory;
    internal static StringComparison PathComparison;
    internal static StringComparer PathComparer;
    internal static Char[] InvalidPathChars;
    internal static Char[] InvalidFileNameChars;
    internal static Char[] Slashes;
    internal static string DirectorySeparatorString;
    private static ConcurrentDictionary`2<string, bool> FileExistenceCache;
    private static IFileSystem DefaultFileSystem;
    internal static string FileTimeFormat;
    private static int userRWX;
    private static string tempFileDirectory;
    internal static string ExecutingAssemblyPath { get; }
    internal static string TempFileDirectory { get; }
    private static FileUtilities();
    internal static void ClearCacheDirectoryPath();
    public static bool GetIsFileSystemCaseSensitive();
    internal static string GetCacheDirectory();
    internal static string GetHexHash(string stringToHash);
    internal static int GetPathsHash(IEnumerable`1<string> assemblyPaths);
    internal static bool CanWriteToDirectory(string directory);
    internal static void ClearCacheDirectory();
    internal static string EnsureTrailingSlash(string fileSpec);
    internal static string EnsureNoLeadingOrTrailingSlash(string path, int start);
    internal static string EnsureTrailingNoLeadingSlash(string path, int start);
    internal static string EnsureNoTrailingSlash(string path);
    internal static string EnsureSingleQuotes(string path);
    internal static string EnsureDoubleQuotes(string path);
    internal static string EnsureQuotes(string path, bool isSingleQuote);
    internal static bool EndsWithSlash(string fileSpec);
    internal static bool IsSlash(char c);
    internal static string TrimAndStripAnyQuotes(string path);
    internal static string GetDirectoryNameOfFullPath(string fullPath);
    internal static string TruncatePathToTrailingSegments(string path, int trailingSegmentsToKeep);
    internal static bool ContainsRelativePathSegments(string path);
    private static bool RelativePathBoundsAreValid(string path, int leftIndex, int rightIndex);
    private static bool IsValidRelativePathBound(Nullable`1<char> c);
    internal static string NormalizePath(string path);
    internal static string NormalizePath(string directory, string file);
    internal static string NormalizePath(String[] paths);
    private static string GetFullPath(string path);
    private static bool IsUNCPath(string path);
    internal static string FixFilePath(string path);
    internal static string MaybeAdjustFilePath(string value, string baseDirectory);
    internal static ReadOnlyMemory`1<char> MaybeAdjustFilePath(ReadOnlyMemory`1<char> value, string baseDirectory);
    private static Span`1<char> ConvertToUnixSlashes(Span`1<char> path);
    private static Span`1<char> CollapseSlashes(Span`1<char> str);
    private static Span`1<char> RemoveQuotes(Span`1<char> path);
    internal static bool IsAnySlash(char c);
    internal static bool LooksLikeUnixFilePath(string value, string baseDirectory);
    internal static bool LooksLikeUnixFilePath(ReadOnlySpan`1<char> value, string baseDirectory);
    internal static string GetDirectory(string fileSpec);
    internal static bool HasExtension(string fileName, String[] allowedExtensions);
    internal static string get_ExecutingAssemblyPath();
    internal static string GetFullPath(string fileSpec, string currentDirectory);
    internal static string GetFullPathNoThrow(string path);
    internal static bool ComparePathsNoThrow(string first, string second, string currentDirectory, bool alwaysIgnoreCase);
    internal static string NormalizePathForComparisonNoThrow(string path, string currentDirectory);
    internal static bool PathIsInvalid(string path);
    internal static void DeleteNoThrow(string path);
    internal static void DeleteDirectoryNoThrow(string path, bool recursive, int retryCount, int retryTimeOut);
    internal static void DeleteWithoutTrailingBackslash(string path, bool recursive);
    internal static FileInfo GetFileInfoNoThrow(string filePath);
    internal static bool DirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool FileOrDirectoryExistsNoThrow(string fullPath, IFileSystem fileSystem);
    internal static bool IsSolutionFilename(string filename);
    internal static bool IsSolutionFilterFilename(string filename);
    internal static bool IsVCProjFilename(string filename);
    internal static bool IsDspFilename(string filename);
    internal static bool IsMetaprojectFilename(string filename);
    internal static bool IsBinaryLogFilename(string filename);
    private static bool HasExtension(string filename, string extension);
    internal static string MakeRelative(string basePath, string path);
    internal static string AttemptToShortenPath(string path);
    private static bool IsPathTooLong(string path);
    private static bool IsPathTooLongIfRooted(string path);
    private static bool IsRootedNoThrow(string path);
    internal static string GetFolderAbove(string path, int count);
    internal static string CombinePaths(string root, String[] paths);
    [ExtensionAttribute]
internal static string TrimTrailingSlashes(string s);
    [ExtensionAttribute]
internal static string ToSlash(string s);
    [ExtensionAttribute]
internal static string ToBackslash(string s);
    [ExtensionAttribute]
internal static string ToPlatformSlash(string s);
    [ExtensionAttribute]
internal static string WithTrailingSlash(string s);
    [ExtensionAttribute]
internal static string NormalizeForPathComparison(string s);
    internal static bool PathsEqual(string path1, string path2);
    internal static StreamWriter OpenWrite(string path, bool append, Encoding encoding);
    internal static StreamReader OpenRead(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    internal static string GetDirectoryNameOfFileAbove(string startingDirectory, string fileName, IFileSystem fileSystem);
    internal static string GetPathOfFileAbove(string file, string startingDirectory, IFileSystem fileSystem);
    internal static void EnsureDirectoryExists(string directoryPath);
    private static bool PathsEqualNonAscii(string strA, string strB, int i, int length);
    internal static void ClearFileExistenceCache();
    internal static string get_TempFileDirectory();
    internal static void ClearTempFileDirectory();
    private static string CreateFolderUnderTemp();
    internal static string GetTemporaryDirectory(bool createDirectory, string subfolder);
    internal static string GetTemporaryFileName();
    internal static string GetTemporaryFileName(string extension);
    internal static string GetTemporaryFile();
    internal static string GetTemporaryFile(string fileName, string extension, bool createFile);
    internal static string GetTemporaryFile(string extension);
    internal static string GetTemporaryFile(string directory, string fileName, string extension, bool createFile);
    internal static void CopyDirectory(string source, string dest);
}
internal static class Microsoft.Build.Shared.FileUtilitiesRegex : object {
    private static char _backSlash;
    private static char _forwardSlash;
    internal static bool IsDrivePattern(string pattern);
    internal static bool IsDrivePatternWithSlash(string pattern);
    internal static bool StartsWithDrivePattern(string pattern);
    internal static bool StartsWithDrivePatternWithSlash(string pattern);
    internal static bool IsUncPattern(string pattern);
    internal static bool StartsWithUncPattern(string pattern);
    internal static int StartsWithUncPatternMatchLength(string pattern);
    internal static bool MeetsUncPatternMinimumRequirements(string pattern);
}
internal static class Microsoft.Build.Shared.FrameworkLocationHelper : object {
    internal static string dotNetFrameworkIdentifier;
    internal static Version dotNetFrameworkVersion11;
    internal static Version dotNetFrameworkVersion20;
    internal static Version dotNetFrameworkVersion30;
    internal static Version dotNetFrameworkVersion35;
    internal static Version dotNetFrameworkVersion40;
    internal static Version dotNetFrameworkVersion45;
    internal static Version dotNetFrameworkVersion451;
    internal static Version dotNetFrameworkVersion452;
    internal static Version dotNetFrameworkVersion46;
    internal static Version dotNetFrameworkVersion461;
    internal static Version dotNetFrameworkVersion462;
    internal static Version dotNetFrameworkVersion47;
    internal static Version dotNetFrameworkVersion471;
    internal static Version dotNetFrameworkVersion472;
    internal static Version dotNetFrameworkVersion48;
    internal static Version dotNetFrameworkVersion481;
    internal static Version visualStudioVersion100;
    internal static Version visualStudioVersion110;
    internal static Version visualStudioVersion120;
    internal static Version visualStudioVersion140;
    internal static Version visualStudioVersion150;
    internal static Version visualStudioVersion160;
    internal static Version visualStudioVersion170;
    internal static Version visualStudioVersionLatest;
    private static string dotNetFrameworkRegistryPath;
    private static string dotNetFrameworkSetupRegistryPath;
    private static string dotNetFrameworkSetupRegistryInstalledName;
    internal static string fullDotNetFrameworkRegistryKey;
    private static string dotNetFrameworkAssemblyFoldersRegistryPath;
    private static string referenceAssembliesRegistryValueName;
    internal static string dotNetFrameworkSdkInstallKeyValueV11;
    internal static string dotNetFrameworkVersionFolderPrefixV11;
    private static string dotNetFrameworkVersionV11;
    private static string dotNetFrameworkRegistryKeyV11;
    internal static string dotNetFrameworkSdkInstallKeyValueV20;
    internal static string dotNetFrameworkVersionFolderPrefixV20;
    private static string dotNetFrameworkVersionV20;
    private static string dotNetFrameworkRegistryKeyV20;
    internal static string dotNetFrameworkVersionFolderPrefixV30;
    private static string s_dotNetFrameworkRegistryKeyV30;
    private static string fallbackDotNetFrameworkSdkRegistryInstallPath;
    internal static string fallbackDotNetFrameworkSdkInstallKeyValue;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnWinSDK70A;
    private static string dotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    private static string fullDotNetFrameworkSdkRegistryPathForV35ToolsOnManagedToolsSDK80A;
    internal static string dotNetFrameworkVersionFolderPrefixV35;
    private static string s_dotNetFrameworkRegistryKeyV35;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS10;
    internal static string fullDotNetFrameworkSdkRegistryKeyV35OnVS11;
    internal static string dotNetFrameworkVersionFolderPrefixV40;
    internal static string dotNetFrameworkVersionFolderPrefixV45;
    private static string ToolsVersionsRegistryPath;
    internal static string programFiles;
    internal static string programFiles32;
    internal static string programFiles64;
    internal static string programFilesReferenceAssemblyLocation;
    private static string s_fallbackDotNetFrameworkSdkInstallPath;
    private static string s_pathToV35ToolsInFallbackDotNetFrameworkSdk;
    private static string s_pathToV4ToolsInFallbackDotNetFrameworkSdk;
    private static Lazy`1<VisualStudioSpec[]> VisualStudioSpecs;
    private static ValueTuple`2[0...,0...] s_explicitFallbackRulesForPathToDotNetFrameworkSdkTools;
    private static Lazy`1<IReadOnlyDictionary`2<Version, DotNetFrameworkSpec>> DotNetFrameworkSpecDict;
    private static Lazy`1<IReadOnlyDictionary`2<Version, VisualStudioSpec>> VisualStudioSpecDict;
    internal static string PathToDotNetFrameworkV11 { get; }
    internal static string PathToDotNetFrameworkV20 { get; }
    internal static string PathToDotNetFrameworkV30 { get; }
    internal static string PathToDotNetFrameworkV35 { get; }
    internal static string PathToDotNetFrameworkV40 { get; }
    internal static string PathToDotNetFrameworkV45 { get; }
    internal static string PathToDotNetFrameworkSdkV11 { get; }
    internal static string PathToDotNetFrameworkSdkV20 { get; }
    private static string FallbackDotNetFrameworkSdkInstallPath { get; }
    private static string PathToV35ToolsInFallbackDotNetFrameworkSdk { get; }
    private static string PathToV4ToolsInFallbackDotNetFrameworkSdk { get; }
    private static FrameworkLocationHelper();
    private static DotNetFrameworkSpec[] DotNetFrameworkSpecs();
    internal static string get_PathToDotNetFrameworkV11();
    internal static string get_PathToDotNetFrameworkV20();
    internal static string get_PathToDotNetFrameworkV30();
    internal static string get_PathToDotNetFrameworkV35();
    internal static string get_PathToDotNetFrameworkV40();
    internal static string get_PathToDotNetFrameworkV45();
    internal static string get_PathToDotNetFrameworkSdkV11();
    internal static string get_PathToDotNetFrameworkSdkV20();
    private static string get_FallbackDotNetFrameworkSdkInstallPath();
    private static string get_PathToV35ToolsInFallbackDotNetFrameworkSdk();
    private static string get_PathToV4ToolsInFallbackDotNetFrameworkSdk();
    internal static string GetDotNetFrameworkSdkRootRegistryKey(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkSdkInstallKeyValue(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetDotNetFrameworkVersionFolderPrefix(Version dotNetFrameworkVersion);
    internal static string GetPathToWindowsSdk(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkReferenceAssemblies(Version dotNetFrameworkVersion);
    internal static string GetPathToDotNetFrameworkSdkTools(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkSdk(Version dotNetFrameworkVersion, Version visualStudioVersion);
    internal static string GetPathToDotNetFrameworkV11(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV20(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV30(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV35(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV40(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFrameworkV45(DotNetFrameworkArchitecture architecture);
    internal static string GetPathToDotNetFramework(Version version);
    internal static string GetPathToDotNetFramework(Version version, DotNetFrameworkArchitecture architecture);
    private static bool CheckForFrameworkInstallation(string registryEntryToCheckInstall, string registryValueToCheckInstall);
    internal static string FindDotNetFrameworkPath(string currentRuntimePath, string prefix, DirectoryExists directoryExists, GetDirectories getDirectories, DotNetFrameworkArchitecture architecture);
    internal static string GenerateProgramFiles32();
    internal static string GenerateProgramFiles64();
    internal static string GenerateProgramFilesReferenceAssemblyRoot();
    internal static string GeneratePathToBuildToolsForToolsVersion(string toolsVersion, DotNetFrameworkArchitecture architecture);
    internal static string GenerateReferenceAssemblyPath(string targetFrameworkRootPath, FrameworkName frameworkName);
    internal static string RemoveDirectories(string path, int numberOfLevelsToRemove);
    private static string GetPathToBuildToolsFromEnvironment(DotNetFrameworkArchitecture architecture);
    private static string GetPathToBuildToolsFromRegistry(string toolsVersion, DotNetFrameworkArchitecture architecture);
    private static string GenerateReferenceAssemblyDirectory(string versionPrefix);
    private static string FindRegistryValueUnderKey(string registryBaseKeyName, string registryKeyName, RegistryView registryView);
    private static VisualStudioSpec GetVisualStudioSpec(Version version);
    private static DotNetFrameworkSpec GetDotNetFrameworkSpec(Version version);
    private static DotNetFrameworkSpec CreateDotNetFrameworkSpecForV4(Version version, Version visualStudioVersion);
    private static void RedirectVersionsIfNecessary(Version& dotNetFrameworkVersion, Version& visualStudioVersion);
}
internal class Microsoft.Build.Shared.GetDirectories : MulticastDelegate {
    public GetDirectories(object object, IntPtr method);
    public virtual String[] Invoke(string path, string pattern);
    public virtual IAsyncResult BeginInvoke(string path, string pattern, AsyncCallback callback, object object);
    public virtual String[] EndInvoke(IAsyncResult result);
}
internal interface Microsoft.Build.Shared.IElementLocation {
    public string File { get; }
    public int Line { get; }
    public int Column { get; }
    public string LocationString { get; }
    public abstract virtual string get_File();
    public abstract virtual int get_Line();
    public abstract virtual int get_Column();
    public abstract virtual string get_LocationString();
}
internal static class Microsoft.Build.Shared.InprocTrackingNativeMethods : object {
    internal static void StartTrackingContext(string intermediateDirectory, string taskName);
    internal static void StartTrackingContextWithRoot(string intermediateDirectory, string taskName, string rootMarker);
    internal static void EndTrackingContext();
    internal static void StopTrackingAndCleanup();
    internal static void SuspendTracking();
    internal static void ResumeTracking();
    internal static void WriteAllTLogs(string intermediateDirectory, string tlogRootName);
    internal static void WriteContextTLogs(string intermediateDirectory, string tlogRootName);
    internal static void SetThreadCount(int threadCount);
}
internal class Microsoft.Build.Shared.LoadedType : object {
    [CompilerGeneratedAttribute]
private bool <HasLoadInSeparateAppDomainAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSTAThreadAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarshalByRef>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <LoadedAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ReflectableTaskPropertyInfo[] <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <PropertyAssemblyQualifiedNames>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyLoadInfo <Assembly>k__BackingField;
    public bool HasLoadInSeparateAppDomainAttribute { get; }
    public bool HasSTAThreadAttribute { get; }
    public bool IsMarshalByRef { get; }
    internal Type Type { get; private set; }
    internal AssemblyName LoadedAssemblyName { get; private set; }
    internal string Path { get; private set; }
    internal Assembly LoadedAssembly { get; private set; }
    internal ReflectableTaskPropertyInfo[] Properties { get; private set; }
    internal String[] PropertyAssemblyQualifiedNames { get; private set; }
    internal AssemblyLoadInfo Assembly { get; private set; }
    internal LoadedType(Type type, AssemblyLoadInfo assemblyLoadInfo, Assembly loadedAssembly, Type iTaskItemType, bool loadedViaMetadataLoadContext);
    [CompilerGeneratedAttribute]
public bool get_HasLoadInSeparateAppDomainAttribute();
    [CompilerGeneratedAttribute]
public bool get_HasSTAThreadAttribute();
    [CompilerGeneratedAttribute]
public bool get_IsMarshalByRef();
    private bool CheckForHardcodedSTARequirement();
    [CompilerGeneratedAttribute]
internal Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
internal AssemblyName get_LoadedAssemblyName();
    [CompilerGeneratedAttribute]
private void set_LoadedAssemblyName(AssemblyName value);
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
internal Assembly get_LoadedAssembly();
    [CompilerGeneratedAttribute]
private void set_LoadedAssembly(Assembly value);
    [CompilerGeneratedAttribute]
internal ReflectableTaskPropertyInfo[] get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(ReflectableTaskPropertyInfo[] value);
    [CompilerGeneratedAttribute]
internal String[] get_PropertyAssemblyQualifiedNames();
    [CompilerGeneratedAttribute]
private void set_PropertyAssemblyQualifiedNames(String[] value);
    [CompilerGeneratedAttribute]
internal AssemblyLoadInfo get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(AssemblyLoadInfo value);
}
internal enum Microsoft.Build.Shared.LoggingEventType : Enum {
    public int value__;
    public static LoggingEventType Invalid;
    public static LoggingEventType CustomEvent;
    public static LoggingEventType BuildErrorEvent;
    public static LoggingEventType BuildFinishedEvent;
    public static LoggingEventType BuildMessageEvent;
    public static LoggingEventType BuildStartedEvent;
    public static LoggingEventType BuildWarningEvent;
    public static LoggingEventType ProjectFinishedEvent;
    public static LoggingEventType ProjectStartedEvent;
    public static LoggingEventType TargetStartedEvent;
    public static LoggingEventType TargetFinishedEvent;
    public static LoggingEventType TaskStartedEvent;
    public static LoggingEventType TaskFinishedEvent;
    public static LoggingEventType TaskCommandLineEvent;
    public static LoggingEventType TaskParameterEvent;
    public static LoggingEventType ProjectEvaluationStartedEvent;
    public static LoggingEventType ProjectEvaluationFinishedEvent;
    public static LoggingEventType ProjectImportedEvent;
    public static LoggingEventType TargetSkipped;
    public static LoggingEventType Telemetry;
    public static LoggingEventType EnvironmentVariableReadEvent;
    public static LoggingEventType ResponseFileUsedEvent;
    public static LoggingEventType AssemblyLoadEvent;
    public static LoggingEventType ExternalProjectStartedEvent;
    public static LoggingEventType ExternalProjectFinishedEvent;
    public static LoggingEventType ExtendedCustomEvent;
    public static LoggingEventType ExtendedBuildErrorEvent;
    public static LoggingEventType ExtendedBuildWarningEvent;
    public static LoggingEventType ExtendedBuildMessageEvent;
    public static LoggingEventType CriticalBuildMessage;
    public static LoggingEventType MetaprojectGenerated;
    public static LoggingEventType PropertyInitialValueSet;
    public static LoggingEventType PropertyReassignment;
    public static LoggingEventType UninitializedPropertyRead;
}
internal abstract class Microsoft.Build.Shared.LogMessagePacketBase : object {
    private static int s_defaultPacketVersion;
    private static Dictionary`2<LoggingEventType, MethodInfo> s_readMethodCache;
    private static Dictionary`2<LoggingEventType, MethodInfo> s_writeMethodCache;
    private static HashSet`1<string> s_customEventsLoaded;
    private static TaskEngineAssemblyResolver s_resolver;
    private static object s_lockObject;
    private TargetFinishedTranslator _targetFinishedTranslator;
    private LoggingEventType _eventType;
    private BuildEventArgs _buildEvent;
    private int _sinkId;
    [ThreadStaticAttribute]
private static List`1<KeyValuePair`2<string, string>> reusablePropertyList;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ThreadStaticAttribute]
private static List`1<ValueTuple`2<string, object>> reusableItemList;
    public NodePacketType Type { get; }
    internal Nullable`1<KeyValuePair`2<int, BuildEventArgs>> NodeBuildEvent { get; }
    internal LoggingEventType EventType { get; }
    internal LogMessagePacketBase(Nullable`1<KeyValuePair`2<int, BuildEventArgs>> nodeBuildEvent, TargetFinishedTranslator targetFinishedTranslator);
    protected LogMessagePacketBase(ITranslator translator, TargetFinishedTranslator targetFinishedTranslator);
    private static LogMessagePacketBase();
    public sealed virtual NodePacketType get_Type();
    internal Nullable`1<KeyValuePair`2<int, BuildEventArgs>> get_NodeBuildEvent();
    internal LoggingEventType get_EventType();
    public sealed virtual void Translate(ITranslator translator);
    internal void WriteToStream(ITranslator translator);
    internal void ReadFromStream(ITranslator translator);
    private static Delegate CreateDelegateRobust(Type type, object firstArgument, MethodInfo methodInfo);
    private BuildEventArgs GetBuildEventArgFromId();
    private LoggingEventType GetLoggingEventId(BuildEventArgs eventArg);
    private void WriteEventToStream(BuildEventArgs buildEvent, LoggingEventType eventType, ITranslator translator);
    private void WriteEnvironmentVariableReadEventArgs(EnvironmentVariableReadEventArgs environmentVariableReadEventArgs, ITranslator translator);
    private void WriteBuildWarningEventToStream(BuildWarningEventArgs buildWarningEventArgs, ITranslator translator);
    private void WriteBuildErrorEventToStream(BuildErrorEventArgs buildErrorEventArgs, ITranslator translator);
    private void WriteTaskCommandLineEventToStream(TaskCommandLineEventArgs taskCommandLineEventArgs, ITranslator translator);
    private void WriteBuildMessageEventToStream(BuildMessageEventArgs buildMessageEventArgs, ITranslator translator);
    private void WriteResponseFileUsedEventToStream(ResponseFileUsedEventArgs responseFileUsedEventArgs, ITranslator translator);
    private void WriteProjectEvaluationStartedEventToStream(ProjectEvaluationStartedEventArgs args, ITranslator translator);
    private void WriteProjectEvaluationFinishedEventToStream(ProjectEvaluationFinishedEventArgs args, ITranslator translator);
    private static void WriteEvaluationEvent(BuildStatusEventArgs args, string projectFile, DateTime timestamp, ITranslator translator);
    private void WriteProfileResult(Nullable`1<ProfilerResult> result, ITranslator translator);
    private void WriteEvaluationLocation(ITranslator translator, EvaluationLocation evaluationLocation);
    private void WriteProfiledLocation(ITranslator translator, ProfiledLocation profiledLocation);
    private void WriteProperties(IEnumerable properties, ITranslator translator);
    private void WriteItems(IEnumerable items, ITranslator translator);
    private void WriteMetadata(object metadataContainer, BinaryWriter writer);
    private BuildEventArgs ReadEventFromStream(LoggingEventType eventType, ITranslator translator);
    private EnvironmentVariableReadEventArgs ReadEnvironmentVariableReadEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName);
    private BuildWarningEventArgs ReadBuildWarningEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName);
    private BuildErrorEventArgs ReadTaskBuildErrorEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName);
    private TaskCommandLineEventArgs ReadTaskCommandLineEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName);
    private BuildMessageEventArgs ReadBuildMessageEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName);
    private ResponseFileUsedEventArgs ReadResponseFileUsedEventFromStream(ITranslator translator, string message, string helpKeyword, string senderName);
    private ProjectEvaluationStartedEventArgs ReadProjectEvaluationStartedEventFromStream(ITranslator translator);
    private ProjectEvaluationFinishedEventArgs ReadProjectEvaluationFinishedEventFromStream(ITranslator translator);
    private ValueTuple`3<BuildEventContext, DateTime, string> ReadEvaluationEvent(ITranslator translator);
    private IEnumerable ReadProperties(ITranslator translator);
    private IEnumerable ReadItems(ITranslator translator);
    private IDictionary`2<string, string> ReadMetadata(BinaryReader reader);
    private Nullable`1<ProfilerResult> ReadProfileResult(ITranslator translator);
    private EvaluationLocation ReadEvaluationLocation(ITranslator translator);
    private ProfiledLocation ReadProfiledLocation(ITranslator translator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Shared.NamedPipeUtil : object {
    internal static string GetPlatformSpecificPipeName(Nullable`1<int> processId);
    internal static string GetPlatformSpecificPipeName(string pipeName);
}
internal class Microsoft.Build.Shared.NGen`1 : ValueType {
    private T _value;
    public NGen`1(T value);
    public static T op_Implicit(NGen`1<T> value);
    public static NGen`1<T> op_Implicit(T value);
}
internal class Microsoft.Build.Shared.OutOfProcTaskHostTaskResult : object {
    [CompilerGeneratedAttribute]
private TaskCompleteType <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <FinalParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <TaskException>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExceptionMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExceptionMessageArgs>k__BackingField;
    public TaskCompleteType Result { get; private set; }
    public IDictionary`2<string, object> FinalParameterValues { get; private set; }
    public Exception TaskException { get; private set; }
    public string ExceptionMessage { get; private set; }
    public String[] ExceptionMessageArgs { get; private set; }
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary`2<string, object> finalParams);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskException);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, Exception taskException, string exceptionMessage, String[] exceptionMessageArgs);
    internal OutOfProcTaskHostTaskResult(TaskCompleteType result, IDictionary`2<string, object> finalParams, Exception taskException, string exceptionMessage, String[] exceptionMessageArgs);
    [CompilerGeneratedAttribute]
public TaskCompleteType get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(TaskCompleteType value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_FinalParameterValues();
    [CompilerGeneratedAttribute]
private void set_FinalParameterValues(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Exception get_TaskException();
    [CompilerGeneratedAttribute]
private void set_TaskException(Exception value);
    [CompilerGeneratedAttribute]
public string get_ExceptionMessage();
    [CompilerGeneratedAttribute]
private void set_ExceptionMessage(string value);
    [CompilerGeneratedAttribute]
public String[] get_ExceptionMessageArgs();
    [CompilerGeneratedAttribute]
private void set_ExceptionMessageArgs(String[] value);
}
internal class Microsoft.Build.Shared.Pair`2 : ValueType {
    private TKey _key;
    private TValue _value;
    internal TKey Key { get; }
    internal TValue Value { get; }
    public Pair`2(TKey key, TValue value);
    [IsReadOnlyAttribute]
internal TKey get_Key();
    [IsReadOnlyAttribute]
internal TValue get_Value();
}
[FlagsAttribute]
internal enum Microsoft.Build.Shared.PartialComparisonFlags : Enum {
    public int value__;
    public static PartialComparisonFlags SimpleName;
    public static PartialComparisonFlags Version;
    public static PartialComparisonFlags Culture;
    public static PartialComparisonFlags PublicKeyToken;
    public static PartialComparisonFlags Default;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.Build.Shared.PlatformNegotiation : object {
    internal static string GetNearestPlatform(string overridePlatformValue, string referencedProjectPlatform, string projectReferencePlatformsMetadata, string projectReferenceLookupTableMetadata, string platformLookupTable, string projectPath, string currentProjectPlatform, TaskLoggingHelper log);
    internal static Dictionary`2<string, string> ExtractLookupTable(string stringTable, TaskLoggingHelper log);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.ProcessExtensions : object {
    [ExtensionAttribute]
public static void KillTree(Process process, int timeoutMilliseconds);
}
internal static class Microsoft.Build.Shared.ProjectErrorUtilities : object {
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3);
    internal static void ThrowInvalidProject(IElementLocation elementLocation, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2);
    internal static void VerifyThrowInvalidProject(bool condition, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2);
    internal static void VerifyThrowInvalidProject(bool condition, string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, T1 arg0, T2 arg1, T3 arg2, T4 arg3);
    private static void ThrowInvalidProject(string errorSubCategoryResourceName, IElementLocation elementLocation, string resourceName, Object[] args);
}
internal static class Microsoft.Build.Shared.ProjectFileErrorUtilities : object {
    internal static void ThrowInvalidProjectFile(BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void ThrowInvalidProjectFile(BuildEventFileInfo projectFile, Exception innerException, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void ThrowInvalidProjectFile(string errorSubCategoryResourceName, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, string errorSubCategoryResourceName, BuildEventFileInfo projectFile, string resourceName, Object[] args);
    internal static void VerifyThrowInvalidProjectFile(bool condition, string errorSubCategoryResourceName, BuildEventFileInfo projectFile, Exception innerException, string resourceName, Object[] args);
}
internal class Microsoft.Build.Shared.ProjectWriter : XmlTextWriter {
    internal static string itemTypeOrMetadataNameSpecification;
    internal static string itemFunctionNameSpecification;
    private static string itemVectorTransformSpecification;
    internal static Lazy`1<Regex> itemVectorTransformPattern;
    private static string itemVectorTransformRawSpecification;
    internal static Lazy`1<Regex> itemVectorTransformRawPattern;
    private bool _writeXmlDeclaration;
    private Encoding _documentEncoding;
    internal ProjectWriter(TextWriter w);
    internal ProjectWriter(string filename, Encoding encoding);
    private static ProjectWriter();
    internal void Initialize(XmlDocument project);
    internal void Initialize(XmlDocument project, XmlDeclaration projectRootElementDeclaration);
    public virtual void WriteString(string text);
    public virtual void WriteStartDocument();
}
internal static class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string ExtractMessageCode(bool msbuildCodeOnly, string message, String& code);
    private static string GetHelpKeyword(string resourceName);
    internal static string GetResourceString(string resourceName);
    internal static string FormatResourceStringStripCodeAndKeyword(String& code, String& helpKeyword, string resourceName, Object[] args);
    [ObsoleteAttribute("Use GetResourceString instead.", "True")]
[EditorBrowsableAttribute("1")]
internal static string FormatResourceString(string resourceName);
    internal static string FormatResourceStringStripCodeAndKeyword(string resourceName, Object[] args);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resourceName, Object[] args);
    internal static string FormatString(string unformatted, Object[] args);
    [ConditionalAttribute("DEBUG")]
internal static void VerifyResourceStringExists(string resourceName);
}
internal class Microsoft.Build.Shared.ReverseStringGenericComparer : object {
    internal static ReverseStringGenericComparer Comparer;
    private static ReverseStringGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.String>.Compare(string x, string y);
}
internal class Microsoft.Build.Shared.ReverseVersionGenericComparer : object {
    internal static ReverseVersionGenericComparer Comparer;
    private static ReverseVersionGenericComparer();
    private sealed virtual override int System.Collections.Generic.IComparer<System.Version>.Compare(Version x, Version y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.Build.Shared.SolutionConfiguration : object {
    public static string ProjectAttribute;
    public static string AbsolutePathAttribute;
    public static string BuildProjectInSolutionAttribute;
    public static Char[] ConfigPlatformSeparator;
    private Dictionary`2<string, XmlElement> _cachedProjectElements;
    private Dictionary`2<string, XmlElement> _cachedProjectElementsByAbsolutePath;
    private Dictionary`2<string, string> _cachedProjectAbsolutePathsByGuid;
    private Dictionary`2<string, string> _cachedProjectGuidsByAbsolutePath;
    private Dictionary`2<string, List`1<string>> _cachedDependencyProjectGuidsByDependingProjectGuid;
    [CompilerGeneratedAttribute]
private static SolutionConfiguration <Empty>k__BackingField;
    public static SolutionConfiguration Empty { get; }
    public ICollection`1<XmlElement> ProjectConfigurations { get; }
    public SolutionConfiguration(string xmlString);
    private static SolutionConfiguration();
    [CompilerGeneratedAttribute]
public static SolutionConfiguration get_Empty();
    public ICollection`1<XmlElement> get_ProjectConfigurations();
    public static XmlNodeList GetProjectConfigurations(string xmlString);
    public bool TryGetProjectByGuid(string projectGuid, XmlElement& projectElement);
    public bool TryGetProjectByAbsolutePath(string projectFullPath, XmlElement& projectElement);
    public bool TryGetProjectGuidByAbsolutePath(string projectFullPath, String& projectGuid);
    public bool TryGetProjectDependencies(string projectGuid, List`1& dependencyProjectGuids);
    public bool TryGetProjectPathByGuid(string projectGuid, String& projectPath);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.StringExtensions : object {
    [ExtensionAttribute]
public static string Replace(string aString, string oldValue, string newValue, StringComparison stringComparison);
    [ExtensionAttribute]
public static int CommonPrefixLength(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other);
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder sb, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static void Write(TextWriter writer, ReadOnlySpan`1<char> buffer);
    [ExtensionAttribute]
public static void WriteLine(TextWriter writer, ReadOnlySpan`1<char> buffer);
}
internal static class Microsoft.Build.Shared.TaskLoader : object {
    private static LoadedType s_resolverLoadedType;
    internal static bool IsTaskClass(Type type, object unused);
    internal static ITask CreateTask(LoadedType loadedType, string taskName, string taskLocation, int taskLine, int taskColumn, LogError logError, AppDomainSetup appDomainSetup, Action`1<AppDomain> appDomainCreated, bool isOutOfProc, AppDomain& taskAppDomain);
    internal static Assembly AssemblyResolver(object sender, ResolveEventArgs args);
    internal static void RemoveAssemblyResolver();
}
internal static class Microsoft.Build.Shared.ThreadPoolExtensions : object {
    internal static bool QueueThreadPoolWorkItemWithCulture(WaitCallback callback, CultureInfo culture, CultureInfo uiCulture);
}
internal class Microsoft.Build.Shared.TypeLoader : object {
    private static ConcurrentDictionary`2<Func`3<Type, object, bool>, ConcurrentDictionary`2<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfLoadedTypesByFilter;
    private static ConcurrentDictionary`2<Func`3<Type, object, bool>, ConcurrentDictionary`2<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> s_cacheOfReflectionOnlyLoadedTypesByFilter;
    private Func`3<Type, object, bool> _isDesiredType;
    private static MetadataLoadContext _context;
    private static String[] runtimeAssemblies;
    private static string microsoftBuildFrameworkPath;
    internal TypeLoader(Func`3<Type, object, bool> isDesiredType);
    private static TypeLoader();
    private static String[] findRuntimeAssembliesWithMicrosoftBuildFramework();
    internal static bool IsPartialTypeNameMatch(string typeName1, string typeName2);
    private static Assembly LoadAssembly(AssemblyLoadInfo assemblyLoadInfo);
    private static Assembly LoadAssemblyUsingMetadataLoadContext(AssemblyLoadInfo assemblyLoadInfo);
    internal LoadedType Load(string typeName, AssemblyLoadInfo assembly, bool useTaskHost);
    internal LoadedType ReflectionOnlyLoad(string typeName, AssemblyLoadInfo assembly);
    private LoadedType GetLoadedType(ConcurrentDictionary`2<Func`3<Type, object, bool>, ConcurrentDictionary`2<AssemblyLoadInfo, AssemblyInfoToLoadedTypes>> cache, string typeName, AssemblyLoadInfo assembly, bool useTaskHost);
    [CompilerGeneratedAttribute]
private AssemblyInfoToLoadedTypes <GetLoadedType>b__13_1(AssemblyLoadInfo _);
}
internal static class Microsoft.Build.Shared.VersionUtilities : object {
    internal static Version ConvertToVersion(string version);
    internal static SortedDictionary`2<Version, List`1<string>> GatherVersionStrings(Version targetPlatformVersion, IEnumerable versions);
    internal static Version ConvertToVersion(string version, bool throwException);
}
internal static class Microsoft.Build.Shared.VisualStudioConstants : object {
    internal static int CurrentVisualStudioSolutionFileVersion;
    internal static string CurrentVisualStudioVersion;
}
internal static class Microsoft.Build.Shared.XMakeAttributes : object {
    internal static string condition;
    internal static string executeTargets;
    internal static string name;
    internal static string msbuildVersion;
    internal static string xmlns;
    internal static string defaultTargets;
    internal static string initialTargets;
    internal static string treatAsLocalProperty;
    internal static string dependsOnTargets;
    internal static string beforeTargets;
    internal static string afterTargets;
    internal static string include;
    internal static string exclude;
    internal static string remove;
    internal static string update;
    internal static string matchOnMetadata;
    internal static string matchOnMetadataOptions;
    internal static string overrideUsingTask;
    internal static string keepMetadata;
    internal static string removeMetadata;
    internal static string keepDuplicates;
    internal static string inputs;
    internal static string outputs;
    internal static string keepDuplicateOutputs;
    internal static string assemblyName;
    internal static string assemblyFile;
    internal static string taskName;
    internal static string continueOnError;
    internal static string project;
    internal static string taskParameter;
    internal static string itemName;
    internal static string propertyName;
    internal static string sdk;
    internal static string sdkName;
    internal static string sdkVersion;
    internal static string sdkMinimumVersion;
    internal static string toolsVersion;
    internal static string runtime;
    internal static string msbuildRuntime;
    internal static string architecture;
    internal static string msbuildArchitecture;
    internal static string taskFactory;
    internal static string parameterType;
    internal static string required;
    internal static string output;
    internal static string defaultValue;
    internal static string evaluate;
    internal static string label;
    internal static string returns;
    internal static string requiredRuntime;
    internal static string requiredPlatform;
    internal static string defaultXmlNamespace;
    private static HashSet`1<string> KnownSpecialTaskAttributes;
    private static HashSet`1<string> KnownSpecialTaskAttributesIgnoreCase;
    private static HashSet`1<string> KnownBatchingTargetAttributes;
    private static HashSet`1<string> ValidMSBuildRuntimeValues;
    private static HashSet`1<string> ValidMSBuildArchitectureValues;
    private static XMakeAttributes();
    internal static bool IsSpecialTaskAttribute(string attribute);
    internal static bool IsBadlyCasedSpecialTaskAttribute(string attribute);
    internal static bool IsNonBatchingTargetAttribute(string attribute);
    internal static bool IsValidMSBuildRuntimeValue(string runtime);
    internal static bool IsValidMSBuildArchitectureValue(string architecture);
    internal static bool RuntimeValuesMatch(string runtimeA, string runtimeB);
    internal static bool TryMergeRuntimeValues(string runtimeA, string runtimeB, String& mergedRuntime);
    internal static bool ArchitectureValuesMatch(string architectureA, string architectureB);
    internal static string GetExplicitMSBuildRuntime(string runtime);
    internal static bool TryMergeArchitectureValues(string architectureA, string architectureB, String& mergedArchitecture);
    internal static string GetCurrentMSBuildArchitecture();
    internal static string GetCurrentMSBuildRuntime();
    internal static string GetExplicitMSBuildArchitecture(string architecture);
}
internal static class Microsoft.Build.Shared.XMakeElements : object {
    internal static string project;
    internal static string visualStudioProject;
    internal static string target;
    internal static string propertyGroup;
    internal static string output;
    internal static string itemGroup;
    internal static string itemDefinitionGroup;
    internal static string usingTask;
    internal static string projectExtensions;
    internal static string onError;
    internal static string error;
    internal static string warning;
    internal static string message;
    internal static string import;
    internal static string importGroup;
    internal static string choose;
    internal static string when;
    internal static string otherwise;
    internal static string usingTaskParameterGroup;
    internal static string usingTaskParameter;
    internal static string usingTaskBody;
    internal static string sdk;
    internal static Char[] InvalidTargetNameCharacters;
    internal static HashSet`1<string> ReservedItemNames;
    private static XMakeElements();
}
internal static class Microsoft.Build.Shared.XmlUtilities : object {
    internal static XmlElementWithLocation RenameXmlElement(XmlElementWithLocation oldElement, string newElementName, string xmlNamespace);
    internal static void VerifyThrowArgumentValidElementName(string name);
    internal static void VerifyThrowProjectValidElementName(string name, IElementLocation location);
    internal static void VerifyThrowProjectValidElementName(XmlElementWithLocation element);
    internal static bool IsValidElementName(string name);
    internal static int LocateFirstInvalidElementNameCharacter(string name);
    internal static bool IsValidInitialElementNameCharacter(char c);
    internal static bool IsValidSubsequentElementNameCharacter(char c);
}
[IsReadOnlyAttribute]
internal class Microsoft.Build.Utilities.SimpleVersion : ValueType {
    public int Major;
    public int Minor;
    public int Build;
    public int Revision;
    private static Char[] s_semverSeparators;
    public SimpleVersion(int major, int minor, int build, int revision);
    private static SimpleVersion();
    public sealed virtual bool Equals(SimpleVersion other);
    public sealed virtual int CompareTo(SimpleVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(SimpleVersion a, SimpleVersion b);
    public static bool op_Inequality(SimpleVersion a, SimpleVersion b);
    public static bool op_LessThan(SimpleVersion a, SimpleVersion b);
    public static bool op_LessThanOrEqual(SimpleVersion a, SimpleVersion b);
    public static bool op_GreaterThan(SimpleVersion a, SimpleVersion b);
    public static bool op_GreaterThanOrEqual(SimpleVersion a, SimpleVersion b);
    public static SimpleVersion Parse(string input);
    private static ReadOnlySpan`1<char> RemoveTrivia(string input);
    private static bool ParseComponent(ReadOnlySpan`1& span, Int32& value);
    private static int ParseComponent(ReadOnlySpan`1<char> span);
    private static Exception InvalidVersionFormat();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.Linq.ImmutableCollectionsExtensions : object {
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<TElement> immutableArray, Func`3<TElement, TArg, bool> predicate, TArg arg);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
