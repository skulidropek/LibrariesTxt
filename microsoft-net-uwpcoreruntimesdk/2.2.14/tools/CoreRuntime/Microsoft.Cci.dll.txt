public static class MetadataExpressionHelper : object {
    public static bool IsFiniteNumeric(IMetadataConstant constExpression);
    public static bool IsIntegralMinusOne(IMetadataConstant constExpression);
    public static bool IsIntegralNonzero(IMetadataConstant constExpression);
    public static bool IsIntegralOne(IMetadataConstant constExpression);
    public static bool IsIntegralZero(IMetadataConstant constExpression);
}
public class Microsoft.Cci.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    public virtual void Invoke(P p, R r);
    public virtual IAsyncResult BeginInvoke(P p, R r, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.Cci.AggregatingLocalScopeProvider : object {
    private Dictionary`2<IUnit, ILocalScopeProvider> unit2Provider;
    private IMethodDefinition lastUsedMethod;
    private ILocalScopeProvider lastUsedProvider;
    public AggregatingLocalScopeProvider(IDictionary`2<IUnit, ILocalScopeProvider> unit2ProviderMap);
    public AggregatingLocalScopeProvider(Dictionary`2<IUnit, ILocalScopeProvider> unit2ProviderMap);
    public sealed virtual IEnumerable`1<ILocalScope> GetIteratorScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<ILocalScope> GetLocalScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<INamespaceScope> GetNamespaceScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<ILocalDefinition> GetConstantsInScope(ILocalScope scope);
    public sealed virtual IEnumerable`1<ILocalDefinition> GetVariablesInScope(ILocalScope scope);
    public sealed virtual bool IsIterator(IMethodBody methodBody);
    public sealed virtual ISynchronizationInformation GetSynchronizationInformation(IMethodBody methodBody);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Close();
    private ILocalScopeProvider GetProvider(IMethodDefinition methodDefinition);
    private ILocalScopeProvider GetProvider(IILLocation mbLocation);
    private ILocalScopeProvider GetProvider(ILocalDefinition localDefinition);
}
public class Microsoft.Cci.AggregatingSourceLocationProvider : object {
    private Dictionary`2<IUnit, ISourceLocationProvider> unit2Provider;
    private IMethodDefinition lastUsedMethod;
    private ISourceLocationProvider lastUsedProvider;
    public AggregatingSourceLocationProvider(IDictionary`2<IUnit, ISourceLocationProvider> unit2ProviderMap);
    public AggregatingSourceLocationProvider(Dictionary`2<IUnit, ISourceLocationProvider> unit2ProviderMap);
    [IteratorStateMachineAttribute("Microsoft.Cci.AggregatingSourceLocationProvider/<GetPrimarySourceLocationsFor>d__3")]
public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IEnumerable`1<ILocation> locations);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(ILocation location);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsForDefinitionOf(ILocalDefinition localDefinition);
    public sealed virtual string GetSourceNameFor(ILocalDefinition localDefinition, Boolean& isCompilerGenerated);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Close();
    private ISourceLocationProvider GetProvider(IMethodDefinition methodDefinition);
    private ISourceLocationProvider GetProvider(IILLocation mbLocation);
    private ISourceLocationProvider GetProvider(ILocalDefinition localDefinition);
    private IEnumerable`1<IPrimarySourceLocation> MapLocationToSourceLocations(ILocation location);
}
internal static class Microsoft.Cci.ArrayT`1 : object {
    private static T[] s_empty;
    internal static T[] Empty { get; }
    private static ArrayT`1();
    internal static T[] get_Empty();
    internal static T[] Create(int count);
}
public class Microsoft.Cci.AssemblyIdentity : ModuleIdentity {
    private string culture;
    private bool containsForeignTypes;
    private IEnumerable`1<byte> publicKeyToken;
    private Byte[] publicKeyTokenArray;
    private Version version;
    public AssemblyIdentity ContainingAssembly { get; }
    public string Culture { get; }
    public bool ContainsForeignTypes { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public Version Version { get; }
    public AssemblyIdentity(IName name, string culture, Version version, IEnumerable`1<byte> publicKeyToken, string location, bool containsForeignTypes);
    public AssemblyIdentity(IName name, string culture, Version version, IEnumerable`1<byte> publicKeyToken, string location);
    public AssemblyIdentity(AssemblyIdentity template, string location);
    private void ObjectInvariant();
    public virtual AssemblyIdentity get_ContainingAssembly();
    public string get_Culture();
    public bool get_ContainsForeignTypes();
    public sealed virtual bool Equals(object obj);
    internal sealed virtual int ComputeHashCode();
    public sealed virtual int GetHashCode();
    public IEnumerable`1<byte> get_PublicKeyToken();
    public sealed virtual string ToString();
    public Version get_Version();
}
public static class Microsoft.Cci.AttributeHelper : object {
    public static bool IsAttributeType(ITypeDefinition typeDefinition);
    public static bool Contains(IEnumerable`1<ICustomAttribute> attributes, ITypeReference attributeType);
    public static bool AllowMultiple(ITypeDefinition attributeType, INameTable nameTable);
    public static bool Inherited(ITypeDefinition attributeType, INameTable nameTable);
    public static AttributeTargets ValidOn(ITypeDefinition attributeType);
}
[ObsoleteAttribute("Please use CodeTraverser")]
public class Microsoft.Cci.BaseCodeTraverser : BaseMetadataTraverser {
    public virtual void Visit(IAddition addition);
    public virtual void Visit(IAddressableExpression addressableExpression);
    public virtual void Visit(IAddressDereference addressDereference);
    public virtual void Visit(IAddressOf addressOf);
    public virtual void Visit(IAnonymousDelegate anonymousDelegate);
    public virtual void Visit(IAssertStatement assertStatement);
    public virtual void Visit(IEnumerable`1<IAssignment> assignments);
    public virtual void Visit(IAssignment assignment);
    public virtual void Visit(IAssumeStatement assumeStatement);
    public virtual void Visit(IBitwiseAnd bitwiseAnd);
    public virtual void Visit(IBitwiseOr bitwiseOr);
    public virtual void Visit(IBlockExpression blockExpression);
    public virtual void Visit(IBlockStatement block);
    public virtual void Visit(ICastIfPossible castIfPossible);
    public virtual void Visit(IEnumerable`1<ICatchClause> catchClauses);
    public virtual void Visit(ICatchClause catchClause);
    public virtual void Visit(ICheckIfInstance checkIfInstance);
    public virtual void Visit(ICompileTimeConstant constant);
    public virtual void Visit(IConversion conversion);
    public virtual void Visit(IConditional conditional);
    public virtual void Visit(IConditionalStatement conditionalStatement);
    public virtual void Visit(IContinueStatement continueStatement);
    public virtual void Visit(ICopyMemoryStatement copyMemoryStatement);
    public virtual void Visit(ICreateArray createArray);
    public virtual void Visit(ICreateObjectInstance createObjectInstance);
    public virtual void Visit(ICreateDelegateInstance createDelegateInstance);
    public virtual void Visit(IArrayIndexer arrayIndexer);
    public virtual void Visit(IBoundExpression boundExpression);
    public virtual void Visit(ICustomAttribute customAttribute);
    public virtual void Visit(IDefaultValue defaultValue);
    public virtual void Visit(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual void Visit(IDivision division);
    public virtual void Visit(IDoUntilStatement doUntilStatement);
    public virtual void Visit(IDupValue popValue);
    public virtual void Visit(IEmptyStatement emptyStatement);
    public virtual void Visit(IEquality equality);
    public virtual void Visit(IExclusiveOr exclusiveOr);
    public virtual void Visit(IEnumerable`1<IExpression> expressions);
    public virtual void Visit(IExpression expression);
    public virtual void Visit(IExpressionStatement expressionStatement);
    public virtual void Visit(IFillMemoryStatement fillMemoryStatement);
    public virtual void Visit(IForEachStatement forEachStatement);
    public virtual void Visit(IForStatement forStatement);
    public virtual void Visit(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void Visit(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual void Visit(IGotoStatement gotoStatement);
    public virtual void Visit(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void Visit(IGreaterThan greaterThan);
    public virtual void Visit(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual void Visit(ILabeledStatement labeledStatement);
    public virtual void Visit(ILeftShift leftShift);
    public virtual void Visit(ILessThan lessThan);
    public virtual void Visit(ILessThanOrEqual lessThanOrEqual);
    public virtual void Visit(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void Visit(ILockStatement lockStatement);
    public virtual void Visit(ILogicalNot logicalNot);
    public virtual void Visit(IBreakStatement breakStatement);
    public virtual void Visit(IMakeTypedReference makeTypedReference);
    public virtual void Visit(ISourceMethodBody methodBody);
    public virtual void Visit(IMethodDefinition method);
    public virtual void Visit(IMethodBody methodBody);
    public virtual void Visit(IMethodCall methodCall);
    public virtual void Visit(IModulus modulus);
    public virtual void Visit(IMultiplication multiplication);
    public virtual void Visit(IEnumerable`1<INamedArgument> namedArguments);
    public virtual void Visit(INamedArgument namedArgument);
    public virtual void Visit(INotEquality notEquality);
    public virtual void Visit(IOldValue oldValue);
    public virtual void Visit(IOnesComplement onesComplement);
    public virtual void Visit(IOutArgument outArgument);
    public virtual void Visit(IPointerCall pointerCall);
    public virtual void Visit(IPopValue popValue);
    public virtual void Visit(IPushStatement pushStatement);
    public virtual void Visit(IRefArgument refArgument);
    public virtual void Visit(IResourceUseStatement resourceUseStatement);
    public virtual void Visit(IRethrowStatement rethrowStatement);
    public virtual void Visit(IReturnStatement returnStatement);
    public virtual void Visit(IReturnValue returnValue);
    public virtual void Visit(IRightShift rightShift);
    public virtual void Visit(IStackArrayCreate stackArrayCreate);
    public virtual void Visit(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void Visit(ISizeOf sizeOf);
    public virtual void Visit(IEnumerable`1<IStatement> statements);
    public virtual void Visit(IStatement statement);
    public virtual void Visit(ISubtraction subtraction);
    public virtual void Visit(IEnumerable`1<ISwitchCase> switchCases);
    public virtual void Visit(ISwitchCase switchCase);
    public virtual void Visit(ISwitchStatement switchStatement);
    public virtual void Visit(ITargetExpression targetExpression);
    public virtual void Visit(IThisReference thisReference);
    public virtual void Visit(IThrowStatement throwStatement);
    public virtual void Visit(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual void Visit(ITokenOf tokenOf);
    public virtual void Visit(ITypeOf typeOf);
    public virtual void Visit(IUnaryNegation unaryNegation);
    public virtual void Visit(IUnaryPlus unaryPlus);
    public virtual void Visit(IVectorLength vectorLength);
    public virtual void Visit(IWhileDoStatement whileDoStatement);
    public virtual void Visit(IYieldBreakStatement yieldBreakStatement);
    public virtual void Visit(IYieldReturnStatement yieldReturnStatement);
    public virtual void VisitReference(IPropertyDefinition property);
}
[ObsoleteAttribute("Please use CodeVisitor")]
public class Microsoft.Cci.BaseCodeVisitor : BaseMetadataVisitor {
    public virtual void Visit(IAddition addition);
    public virtual void Visit(IAddressableExpression addressableExpression);
    public virtual void Visit(IAddressDereference addressDereference);
    public virtual void Visit(IAddressOf addressOf);
    public virtual void Visit(IAnonymousDelegate anonymousDelegate);
    public virtual void Visit(IArrayIndexer arrayIndexer);
    public virtual void Visit(IAssertStatement assertStatement);
    public virtual void Visit(IEnumerable`1<IAssignment> assignments);
    public virtual void Visit(IAssignment assignment);
    public virtual void Visit(IAssumeStatement assumeStatement);
    public virtual void Visit(IBitwiseAnd bitwiseAnd);
    public virtual void Visit(IBitwiseOr bitwiseOr);
    public virtual void Visit(IBlockExpression blockExpression);
    public virtual void Visit(IBlockStatement block);
    public virtual void Visit(IBreakStatement breakStatement);
    public virtual void Visit(ICastIfPossible castIfPossible);
    public virtual void Visit(IEnumerable`1<ICatchClause> catchClauses);
    public virtual void Visit(ICatchClause catchClause);
    public virtual void Visit(ICheckIfInstance checkIfInstance);
    public virtual void Visit(ICompileTimeConstant constant);
    public virtual void Visit(IConversion conversion);
    public virtual void Visit(IConditional conditional);
    public virtual void Visit(IConditionalStatement conditionalStatement);
    public virtual void Visit(IContinueStatement continueStatement);
    public virtual void Visit(ICopyMemoryStatement copyMemoryStatement);
    public virtual void Visit(ICreateArray createArray);
    public virtual void Visit(ICreateObjectInstance createObjectInstance);
    public virtual void Visit(ICreateDelegateInstance createDelegateInstance);
    public virtual void Visit(IDefaultValue defaultValue);
    public virtual void Visit(IDivision division);
    public virtual void Visit(IDoUntilStatement doUntilStatement);
    public virtual void Visit(IDupValue dupValue);
    public virtual void Visit(IEmptyStatement emptyStatement);
    public virtual void Visit(IEquality equality);
    public virtual void Visit(IExclusiveOr exclusiveOr);
    public virtual void Visit(IBoundExpression boundExpression);
    public virtual void Visit(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual void Visit(IExpression expression);
    public virtual void Visit(IExpressionStatement expressionStatement);
    public virtual void Visit(IFillMemoryStatement fillMemoryStatement);
    public virtual void Visit(IForEachStatement forEachStatement);
    public virtual void Visit(IForStatement forStatement);
    public virtual void Visit(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void Visit(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual void Visit(IGotoStatement gotoStatement);
    public virtual void Visit(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void Visit(IGreaterThan greaterThan);
    public virtual void Visit(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual void Visit(ILabeledStatement labeledStatement);
    public virtual void Visit(ILeftShift leftShift);
    public virtual void Visit(ILessThan lessThan);
    public virtual void Visit(ILessThanOrEqual lessThanOrEqual);
    public virtual void Visit(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void Visit(ILockStatement lockStatement);
    public virtual void Visit(ILogicalNot logicalNot);
    public virtual void Visit(IMakeTypedReference makeTypedReference);
    public virtual void Visit(IMethodCall methodCall);
    public virtual void Visit(IModulus modulus);
    public virtual void Visit(IMultiplication multiplication);
    public virtual void Visit(IEnumerable`1<INamedArgument> namedArguments);
    public virtual void Visit(INamedArgument namedArgument);
    public virtual void Visit(INotEquality notEquality);
    public virtual void Visit(IOldValue oldValue);
    public virtual void Visit(IOnesComplement onesComplement);
    public virtual void Visit(IOutArgument outArgument);
    public virtual void Visit(IPointerCall pointerCall);
    public virtual void Visit(IPopValue popValue);
    public virtual void Visit(IPushStatement pushStatement);
    public virtual void Visit(IRefArgument refArgument);
    public virtual void Visit(IResourceUseStatement resourceUseStatement);
    public virtual void Visit(IRethrowStatement rethrowStatement);
    public virtual void Visit(IReturnStatement returnStatement);
    public virtual void Visit(IReturnValue returnValue);
    public virtual void Visit(IRightShift rightShift);
    public virtual void Visit(IStackArrayCreate stackArrayCreate);
    public virtual void Visit(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void Visit(ISizeOf sizeOf);
    public virtual void Visit(IEnumerable`1<IStatement> statements);
    public virtual void Visit(IStatement statement);
    public virtual void Visit(ISubtraction subtraction);
    public virtual void Visit(IEnumerable`1<ISwitchCase> switchCases);
    public virtual void Visit(ISwitchCase switchCase);
    public virtual void Visit(ISwitchStatement switchStatement);
    public virtual void Visit(ITargetExpression targetExpression);
    public virtual void Visit(IThisReference thisReference);
    public virtual void Visit(IThrowStatement throwStatement);
    public virtual void Visit(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual void Visit(ITokenOf tokenOf);
    public virtual void Visit(ITypeOf typeOf);
    public virtual void Visit(IUnaryNegation unaryNegation);
    public virtual void Visit(IUnaryPlus unaryPlus);
    public virtual void Visit(IVectorLength vectorLength);
    public virtual void Visit(IWhileDoStatement whileDoStatement);
    public virtual void Visit(IYieldBreakStatement yieldBreakStatement);
    public virtual void Visit(IYieldReturnStatement yieldReturnStatement);
}
[ObsoleteAttribute("Please use MetadataTraverser")]
public class Microsoft.Cci.BaseMetadataTraverser : object {
    protected Stack path;
    protected bool stopTraversal;
    public virtual void Visit(IEnumerable`1<IAliasForType> aliasesForTypes);
    public virtual void Visit(IAliasForType aliasForType);
    public virtual void VisitReference(IAliasForType aliasForType);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public virtual void Visit(IAssembly assembly);
    public virtual void Visit(IEnumerable`1<IAssemblyReference> assemblyReferences);
    public virtual void Visit(IAssemblyReference assemblyReference);
    public virtual void Visit(IEnumerable`1<ICustomAttribute> customAttributes);
    public virtual void Visit(ICustomAttribute customAttribute);
    public virtual void Visit(IEnumerable`1<ICustomModifier> customModifiers);
    public virtual void Visit(ICustomModifier customModifier);
    public virtual void Visit(IEnumerable`1<IEventDefinition> events);
    public virtual void Visit(IEventDefinition eventDefinition);
    public virtual void Visit(IEnumerable`1<IFieldDefinition> fields);
    public virtual void Visit(IFieldDefinition fieldDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    public virtual void Visit(IEnumerable`1<IFileReference> fileReferences);
    public virtual void Visit(IFileReference fileReference);
    public virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void Visit(IEnumerable`1<IGenericMethodParameter> genericParameters);
    public virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual void Visit(IGenericParameter genericParameter);
    public virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void Visit(IEnumerable`1<IGenericTypeParameter> genericParameters);
    public virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual void Visit(IEnumerable`1<ILocalDefinition> localDefinitions);
    public virtual void Visit(ILocalDefinition localDefinition);
    public virtual void VisitReference(ILocalDefinition localDefinition);
    public virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(IMetadataConstant constant);
    public virtual void Visit(IMetadataCreateArray createArray);
    public virtual void Visit(IEnumerable`1<IMetadataExpression> expressions);
    public virtual void Visit(IMetadataExpression expression);
    public virtual void Visit(IEnumerable`1<IMetadataNamedArgument> namedArguments);
    public virtual void Visit(IMetadataNamedArgument namedArgument);
    public virtual void Visit(IMetadataTypeOf typeOf);
    public virtual void Visit(IMethodBody methodBody);
    public virtual void Visit(IEnumerable`1<IMethodDefinition> methods);
    public virtual void Visit(IMethodDefinition method);
    public virtual void Visit(IEnumerable`1<IMethodImplementation> methodImplementations);
    public virtual void Visit(IMethodImplementation methodImplementation);
    public virtual void Visit(IEnumerable`1<IMethodReference> methodReferences);
    public virtual void Visit(IMethodReference methodReference);
    public virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public virtual void Visit(IModule module);
    public virtual void Visit(IEnumerable`1<IModule> modules);
    public virtual void Visit(IEnumerable`1<IModuleReference> moduleReferences);
    public virtual void Visit(IModuleReference moduleReference);
    public virtual void Visit(IEnumerable`1<INamedTypeDefinition> types);
    public virtual void Visit(IEnumerable`1<INamespaceMember> namespaceMembers);
    public virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public virtual void VisitReference(INamespaceAliasForType namespaceAliasForType);
    public virtual void Visit(INamespaceMember namespaceMember);
    public virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public virtual void Visit(INestedAliasForType nestedAliasForType);
    public virtual void VisitReference(INestedAliasForType nestedAliasForType);
    public virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual void Visit(IEnumerable`1<INestedTypeDefinition> nestedTypes);
    public virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public virtual void Visit(IEnumerable`1<IOperation> operations);
    public virtual void Visit(IOperation operation);
    public virtual void Visit(IEnumerable`1<IOperationExceptionInformation> operationExceptionInformations);
    public virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public virtual void Visit(IEnumerable`1<IParameterDefinition> parameters);
    public virtual void Visit(IParameterDefinition parameterDefinition);
    public virtual void VisitReference(IParameterDefinition parameterDefinition);
    public virtual void Visit(IEnumerable`1<IParameterTypeInformation> parameterTypeInformations);
    public virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public virtual void Visit(IEnumerable`1<IPESection> peSections);
    public virtual void Visit(IPESection peSection);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public virtual void Visit(IEnumerable`1<IPropertyDefinition> properties);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public virtual void Visit(IEnumerable`1<IResourceReference> resourceReferences);
    public virtual void Visit(IResourceReference resourceReference);
    public virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public virtual void Visit(ISecurityAttribute securityAttribute);
    public virtual void Visit(IEnumerable`1<ISecurityAttribute> securityAttributes);
    public virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual void Visit(IEnumerable`1<ITypeDefinitionMember> typeMembers);
    public virtual void Visit(IEnumerable`1<ITypeDefinition> types);
    public virtual void Visit(ITypeDefinition typeDefinition);
    public virtual void Visit(ITypeDefinitionMember typeMember);
    public virtual void Visit(ITypeMemberReference typeMemberReference);
    public virtual void Visit(IEnumerable`1<ITypeReference> typeReferences);
    public virtual void Visit(ITypeReference typeReference);
    protected void DispatchAsReference(ITypeReference typeReference);
    public virtual void Visit(IUnit unit);
    public virtual void Visit(IEnumerable`1<IUnitReference> unitReferences);
    public virtual void Visit(IUnitReference unitReference);
    private void DispatchAsReference(IUnitReference unitReference);
    public virtual void Visit(INamespaceDefinition namespaceDefinition);
    public virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual void Visit(IUnitNamespaceReference unitNamespaceReference);
    public virtual void Visit(IUnitSet unitSet);
    public virtual void Visit(IUnitSetNamespace unitSetNamespace);
    public virtual void Visit(IWin32Resource win32Resource);
    public virtual void VisitMethodReturnAttributes(IEnumerable`1<ICustomAttribute> customAttributes);
}
[ObsoleteAttribute("Please use MetadataVisitor")]
public class Microsoft.Cci.BaseMetadataVisitor : object {
    public virtual void Visit(IAliasForType aliasForType);
    public virtual void VisitReference(IAliasForType aliasForType);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public virtual void Visit(IAssembly assembly);
    public virtual void Visit(IAssemblyReference assemblyReference);
    public virtual void Visit(ICustomAttribute customAttribute);
    public virtual void Visit(ICustomModifier customModifier);
    public virtual void Visit(IEventDefinition eventDefinition);
    public virtual void Visit(IFieldDefinition fieldDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    public virtual void Visit(IFileReference fileReference);
    public virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual void Visit(ILocalDefinition localDefinition);
    public virtual void VisitReference(ILocalDefinition localDefinition);
    public virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(IMetadataConstant constant);
    public virtual void Visit(IMetadataCreateArray createArray);
    public virtual void Visit(IMetadataExpression expression);
    public virtual void Visit(IMetadataNamedArgument namedArgument);
    public virtual void Visit(IMetadataTypeOf typeOf);
    public virtual void Visit(IMethodBody methodBody);
    public virtual void Visit(IMethodDefinition method);
    public virtual void Visit(IMethodImplementation methodImplementation);
    public virtual void Visit(IMethodReference methodReference);
    public virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public virtual void Visit(IModule module);
    public virtual void Visit(IModuleReference moduleReference);
    public virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public virtual void Visit(INamespaceDefinition namespaceDefinition);
    public virtual void Visit(INamespaceMember namespaceMember);
    public virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public virtual void Visit(INestedAliasForType nestedAliasForType);
    public virtual void VisitReference(INestedAliasForType nestedAliasForType);
    public virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public virtual void Visit(IOperation operation);
    public virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public virtual void Visit(IParameterDefinition parameterDefinition);
    public virtual void VisitReference(IParameterDefinition parameterDefinition);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public virtual void Visit(IPESection peSection);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public virtual void Visit(IResourceReference resourceReference);
    public virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public virtual void Visit(ISecurityAttribute securityAttribute);
    public virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual void Visit(ITypeDefinitionMember typeMember);
    public virtual void Visit(ITypeReference typeReference);
    public virtual void Visit(IUnit unit);
    public virtual void Visit(IUnitReference unitReference);
    public virtual void Visit(IUnitNamespaceReference unitNamespaceReference);
    public virtual void Visit(IUnitSet unitSet);
    public virtual void Visit(IUnitSetNamespace unitSetNamespace);
    public virtual void Visit(IWin32Resource win32Resource);
}
public class Microsoft.Cci.BinaryDocument : object {
    private UInt32 length;
    private string location;
    private IName name;
    private UInt32 Microsoft.Cci.IBinaryDocument.Length { get; }
    private string Microsoft.Cci.IDocument.Location { get; }
    private IName Microsoft.Cci.IDocument.Name { get; }
    public BinaryDocument(string location, IName name, UInt32 length);
    private sealed virtual override UInt32 Microsoft.Cci.IBinaryDocument.get_Length();
    private sealed virtual override string Microsoft.Cci.IDocument.get_Location();
    private sealed virtual override IName Microsoft.Cci.IDocument.get_Name();
    public static BinaryDocument GetBinaryDocumentForFile(string fullFilePath, IMetadataHost compilationHost);
}
public class Microsoft.Cci.BinaryLocation : object {
    private IBinaryDocument binaryDocument;
    private UInt32 offset;
    private IBinaryDocument Microsoft.Cci.IBinaryLocation.BinaryDocument { get; }
    private UInt32 Microsoft.Cci.IBinaryLocation.Offset { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    public BinaryLocation(IBinaryDocument binaryDocument, UInt32 offset);
    private sealed virtual override IBinaryDocument Microsoft.Cci.IBinaryLocation.get_BinaryDocument();
    private sealed virtual override UInt32 Microsoft.Cci.IBinaryLocation.get_Offset();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Microsoft.Cci.CachingInternFactory : object {
    private IInternFactory m_factory;
    private Dictionary`2<UInt32, object> m_objects;
    public sealed virtual UInt32 GetAssemblyInternedKey(AssemblyIdentity assemblyIdentity);
    public sealed virtual UInt32 GetFieldInternedKey(IFieldReference fieldReference);
    public sealed virtual UInt32 GetFunctionPointerTypeReferenceInternedKey(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    public sealed virtual UInt32 GetGenericMethodParameterReferenceInternedKey(IMethodReference defininingMethodReference, int index);
    public sealed virtual UInt32 GetGenericTypeInstanceReferenceInternedKey(ITypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    public sealed virtual UInt32 GetGenericTypeParameterReferenceInternedKey(ITypeReference definingTypeReference, int index);
    public sealed virtual UInt32 GetManagedPointerTypeReferenceInternedKey(ITypeReference targetTypeReferece);
    public sealed virtual UInt32 GetMatrixTypeReferenceInternedKey(ITypeReference elementTypeReference, int rank, IEnumerable`1<ulong> sizes, IEnumerable`1<int> lowerBounds);
    public sealed virtual UInt32 GetMethodInternedKey(IMethodReference methodReference);
    public sealed virtual UInt32 GetModifiedTypeReferenceInternedKey(ITypeReference typeReference, IEnumerable`1<ICustomModifier> customModifiers);
    public sealed virtual UInt32 GetModuleInternedKey(ModuleIdentity moduleIdentity);
    public sealed virtual UInt32 GetNamespaceTypeReferenceInternedKey(IUnitNamespaceReference containingUnitNamespace, IName typeName, UInt32 genericParameterCount);
    public sealed virtual UInt32 GetNestedTypeReferenceInternedKey(ITypeReference containingTypeReference, IName typeName, UInt32 genericParameterCount);
    public sealed virtual UInt32 GetPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    public sealed virtual UInt32 GetTypeReferenceInternedKey(ITypeReference typeReference);
    public sealed virtual UInt32 GetVectorTypeReferenceInternedKey(ITypeReference elementTypeReference);
    public sealed virtual IGenericTypeInstanceReference GetOrMakeGenericTypeInstanceReference(INamedTypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    public sealed virtual void FlushCache();
    public void Cleanup();
}
[FlagsAttribute]
public enum Microsoft.Cci.CallingConvention : Enum {
    public int value__;
    public static CallingConvention C;
    public static CallingConvention Default;
    public static CallingConvention ExtraArguments;
    public static CallingConvention FastCall;
    public static CallingConvention Standard;
    public static CallingConvention ThisCall;
    public static CallingConvention Generic;
    public static CallingConvention HasThis;
    public static CallingConvention ExplicitThis;
}
public static class Microsoft.Cci.ClrHelper : object {
    public static ClrOperandStackType[0...,0...] AddResult;
    public static ClrOperandStackType[0...,0...] DivMulRemResult;
    public static ClrOperandStackType[0...,0...] SubResult;
    public static ClrOperandStackType[] UnaryResult;
    public static ClrOperandStackType[0...,0...] CompResult;
    public static ClrOperandStackType[0...,0...] EqCompResult;
    public static ClrOperandStackType[0...,0...] IntOperationResult;
    public static ClrOperandStackType[0...,0...] ShiftOperationResult;
    public static Boolean[0...,0...] ImplicitConversionPossibleArr;
    private static ClrHelper();
    public static ClrOperandStackType ClrOperandStackTypeFor(ITypeReference typeReference);
    public static ClrOperandStackType ClrOperandStackTypeFor(PrimitiveTypeCode typeCode);
    public static PrimitiveTypeCode PrimitiveTypeCodeFor(ClrOperandStackType numericType);
    public static bool ConversionPossible(ClrOperandStackType fromType, PrimitiveTypeCode toType);
}
public enum Microsoft.Cci.ClrOperandStackType : Enum {
    public int value__;
    public static ClrOperandStackType Int32;
    public static ClrOperandStackType Int64;
    public static ClrOperandStackType NativeInt;
    public static ClrOperandStackType Float;
    public static ClrOperandStackType Reference;
    public static ClrOperandStackType Object;
    public static ClrOperandStackType Pointer;
    public static ClrOperandStackType Invalid;
}
public static class Microsoft.Cci.CodeDummy : object {
    private static IAddressableExpression addressableExpression;
    private static IAssignment assignment;
    private static IBlockStatement block;
    private static ICompileTimeConstant constant;
    private static ICreateArray createArray;
    private static IExpression expression;
    private static IGotoStatement gotoStatement;
    private static ILabeledStatement labeledStatement;
    private static IMethodCall methodCall;
    private static ISwitchCase switchCase;
    private static ISwitchStatement switchStatement;
    private static ITargetExpression targetExpression;
    public static IAddressableExpression AddressableExpression { get; }
    public static IAssignment Assignment { get; }
    public static IBlockStatement Block { get; }
    public static ICompileTimeConstant Constant { get; }
    public static ICreateArray CreateArray { get; }
    public static IExpression Expression { get; }
    public static IGotoStatement GotoStatement { get; }
    public static ILabeledStatement LabeledStatement { get; }
    public static IMethodCall MethodCall { get; }
    public static ISwitchCase SwitchCase { get; }
    public static ISwitchStatement SwitchStatement { get; }
    public static ITargetExpression TargetExpression { get; }
    public static IAddressableExpression get_AddressableExpression();
    public static IAssignment get_Assignment();
    public static IBlockStatement get_Block();
    public static ICompileTimeConstant get_Constant();
    public static ICreateArray get_CreateArray();
    public static IExpression get_Expression();
    public static IGotoStatement get_GotoStatement();
    public static ILabeledStatement get_LabeledStatement();
    public static IMethodCall get_MethodCall();
    public static ISwitchCase get_SwitchCase();
    public static ISwitchStatement get_SwitchStatement();
    public static ITargetExpression get_TargetExpression();
}
internal class Microsoft.Cci.CodeModelToIL.ExpressionSourceLocation : object {
    private IPrimarySourceLocation primarySourceLocation;
    public IPrimarySourceLocation PrimarySourceLocation { get; }
    public IDocument Document { get; }
    internal ExpressionSourceLocation(IPrimarySourceLocation primarySourceLocation);
    private void ObjectInvariant();
    public sealed virtual IPrimarySourceLocation get_PrimarySourceLocation();
    public sealed virtual IDocument get_Document();
}
internal class Microsoft.Cci.CodeModelToIL.LabelAndTryBlockAssociater : CodeTraverser {
    private Dictionary`2<object, IStatement> mostNestedTryCatchFor;
    private ITryCatchFinallyStatement currentTryCatch;
    internal LabelAndTryBlockAssociater(Dictionary`2<object, IStatement> mostNestedTryCatchFor);
    public virtual void TraverseChildren(ILabeledStatement labeledStatement);
    public virtual void TraverseChildren(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
}
internal class Microsoft.Cci.CodeModelToIL.TemporaryVariable : object {
    private IMethodDefinition methodDefinition;
    private ITypeReference type;
    public IMetadataConstant CompileTimeValue { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IName Name { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    internal TemporaryVariable(ITypeReference type, IMethodDefinition containingMethod);
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
}
public class Microsoft.Cci.CodeModelToILConverter : CodeTraverser {
    private ILGeneratorLabel currentBreakTarget;
    private ILGeneratorLabel currentContinueTarget;
    private bool currentExpressionIsStatement;
    private ILGeneratorLabel currentTryCatchFinallyEnd;
    private IStatement currentTryCatch;
    private ILGeneratorLabel endOfMethod;
    private ILGenerator generator;
    protected IMetadataHost host;
    private Dictionary`2<int, ILGeneratorLabel> labelFor;
    private bool lastStatementWasUnconditionalTransfer;
    private Dictionary`2<ILocalDefinition, ushort> localIndex;
    private IMethodDefinition method;
    private bool minizeCodeSize;
    private Dictionary`2<object, IStatement> mostNestedTryCatchFor;
    private ILocalDefinition returnLocal;
    protected ISourceLocationProvider sourceLocationProvider;
    private bool trackExpressionSourceLocations;
    private List`1<ILocalDefinition> localVariables;
    private IDictionary`2<IBlockStatement, UInt32> iteratorLocalCount;
    private ushort maximumStackSizeNeeded;
    private ushort _stackSize;
    private MethodReference decimalConstructor;
    private IMethodReference getTypeFromHandle;
    public ushort MaximumStackSizeNeeded { get; }
    public bool MinimizeCodeSize { get; public set; }
    private ushort StackSize { get; private set; }
    public bool TrackExpressionSourceLocations { get; public set; }
    private MethodReference DecimalConstructor { get; }
    private IMethodReference GetTypeFromHandle { get; }
    public CodeModelToILConverter(IMetadataHost host, IMethodDefinition method, ISourceLocationProvider sourceLocationProvider);
    public CodeModelToILConverter(IMetadataHost host, IMethodDefinition method, ISourceLocationProvider sourceLocationProvider, IMethodDefinition asyncMethod, IDictionary`2<IBlockStatement, UInt32> iteratorLocalCount);
    private void EmitSourceLocation(IExpression expression);
    private static ushort GetParameterIndex(IParameterDefinition parameterDefinition);
    private void LoadAddressOf(object container, IExpression instance);
    private void LoadAddressOf(object container, IExpression instance, bool emitReadonlyPrefix);
    private void LoadField(byte alignment, bool isVolatile, IExpression instance, IFieldReference field, bool fieldIsStatic);
    private void LoadLocal(ILocalDefinition local);
    private void LoadParameter(IParameterDefinition parameter);
    public sealed virtual ushort get_MaximumStackSizeNeeded();
    public bool get_MinimizeCodeSize();
    public void set_MinimizeCodeSize(bool value);
    private ushort get_StackSize();
    private void set_StackSize(ushort value);
    public bool get_TrackExpressionSourceLocations();
    public void set_TrackExpressionSourceLocations(bool value);
    public virtual void TraverseChildren(IAddition addition);
    private void TraverseAdditionRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IAddressableExpression addressableExpression);
    public virtual void TraverseChildren(IAddressDereference addressDereference);
    private void LoadIndirect(ITypeReference targetType);
    public virtual void TraverseChildren(IAddressOf addressOf);
    public virtual void TraverseChildren(IAnonymousDelegate anonymousDelegate);
    public virtual void TraverseChildren(IArrayIndexer arrayIndexer);
    private void LoadVectorElement(ITypeReference typeReference);
    public virtual void TraverseChildren(IAssertStatement assertStatement);
    public virtual void TraverseChildren(IAssignment assignment);
    public virtual void VisitAssignment(IAssignment assignment, bool treatAsStatement);
    private void VisitAssignment(ITargetExpression target, IExpression source, SourceTraverser sourceTraverser, bool treatAsStatement, bool pushTargetRValue, bool resultIsInitialTargetRValue);
    private void StoreVectorElement(ITypeReference elementTypeReference);
    private void VisitAssignmentTo(IAddressDereference addressDereference);
    private void StoreIndirect(ITypeReference targetType);
    private void VisitAssignmentTo(ILocalDefinition local);
    public virtual void TraverseChildren(IAssumeStatement assumeStatement);
    public virtual void TraverseChildren(IBitwiseAnd bitwiseAnd);
    private void TraverseBitwiseAndRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IBitwiseOr bitwiseOr);
    private void TraverseBitwiseOrRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IBlockExpression blockExpression);
    public virtual void TraverseChildren(IBlockStatement block);
    public virtual void TraverseChildren(IBoundExpression boundExpression);
    public virtual void TraverseChildren(IBreakStatement breakStatement);
    public virtual void TraverseChildren(ICastIfPossible castIfPossible);
    public virtual void TraverseChildren(ICatchClause catchClause);
    public virtual void TraverseChildren(ICheckIfInstance checkIfInstance);
    public virtual void TraverseChildren(ICompileTimeConstant constant);
    public virtual void TraverseChildren(IConditional conditional);
    public virtual void TraverseChildren(IConditionalStatement conditionalStatement);
    internal bool LabelIsOutsideCurrentExceptionBlock(ILGeneratorLabel label);
    public virtual void TraverseChildren(IContinueStatement continueStatement);
    public virtual void TraverseChildren(ICopyMemoryStatement copyMemoryStatement);
    public virtual void TraverseChildren(IConversion conversion);
    public virtual void TraverseChildren(ICreateArray createArray);
    private void StoreInitializers(ICreateArray createArray, IArrayTypeReference arrayType);
    public virtual void TraverseChildren(ICreateDelegateInstance createDelegateInstance);
    public virtual void TraverseChildren(ICreateObjectInstance createObjectInstance);
    public virtual void TraverseChildren(IDefaultValue defaultValue);
    public virtual void TraverseChildren(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual void TraverseChildren(IDivision division);
    private void TraverseDivisionRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IDoUntilStatement doUntilStatement);
    public virtual void TraverseChildren(IDupValue dupValue);
    public virtual void TraverseChildren(IEmptyStatement emptyStatement);
    public virtual void TraverseChildren(IEquality equality);
    public virtual void TraverseChildren(IExclusiveOr exclusiveOr);
    private void TraverseExclusiveOrRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IExpressionStatement expressionStatement);
    public virtual void TraverseChildren(IFillMemoryStatement fillMemoryStatement);
    public virtual void TraverseChildren(IForEachStatement forEachStatement);
    public virtual void VisitForeachArrayElement(IForEachStatement forEachStatement, IArrayTypeReference arrayType);
    public virtual void TraverseChildren(IForStatement forStatement);
    public virtual void TraverseChildren(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void TraverseChildren(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual void TraverseChildren(IGotoStatement gotoStatement);
    public virtual void TraverseChildren(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void TraverseChildren(IGreaterThan greaterThan);
    public virtual void TraverseChildren(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual void TraverseChildren(ILabeledStatement labeledStatement);
    public virtual void TraverseChildren(ILeftShift leftShift);
    private void TraverseLeftShiftRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(ILessThan lessThan);
    public virtual void TraverseChildren(ILessThanOrEqual lessThanOrEqual);
    public virtual void TraverseChildren(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void TraverseChildren(ILockStatement lockStatement);
    private void GenerateDownLevelLockStatement(ILockStatement lockStatement);
    public virtual void TraverseChildren(ILogicalNot logicalNot);
    public virtual void TraverseChildren(IMakeTypedReference makeTypedReference);
    public virtual void TraverseChildren(IMethodCall methodCall);
    public virtual void TraverseChildren(IModulus modulus);
    private void TraverseModulusRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IMultiplication multiplication);
    private void TraverseMultiplicationRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(INotEquality notEquality);
    public virtual void TraverseChildren(IOldValue oldValue);
    public virtual void TraverseChildren(IOnesComplement onesComplement);
    public virtual void TraverseChildren(IOutArgument outArgument);
    public virtual void TraverseChildren(IPointerCall pointerCall);
    public virtual void TraverseChildren(IPopValue popValue);
    public virtual void TraverseChildren(IPushStatement pushStatement);
    public virtual void TraverseChildren(IRefArgument refArgument);
    public virtual void TraverseChildren(IResourceUseStatement resourceUseStatement);
    public virtual void TraverseChildren(IRethrowStatement rethrowStatement);
    public virtual void TraverseChildren(IReturnStatement returnStatement);
    public virtual void TraverseChildren(IReturnValue returnValue);
    public virtual void TraverseChildren(IRightShift rightShift);
    private void TraverseRightShiftRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void TraverseChildren(ISizeOf sizeOf);
    public virtual void TraverseChildren(ISourceMethodBody methodBody);
    public virtual void TraverseChildren(IStackArrayCreate stackArrayCreate);
    public virtual void TraverseChildren(ISubtraction subtraction);
    private void TraverseSubtractionRightOperandAndDoOperation(IExpression expression);
    public virtual void TraverseChildren(ISwitchCase switchCase);
    public virtual void TraverseChildren(ISwitchStatement switchStatement);
    private void GenerateSwitchInstruction(IEnumerable`1<ISwitchCase> switchCases, UInt32 maxValue);
    private static UInt32 GetMaxCaseExpressionValueAsUInt(IEnumerable`1<ISwitchCase> switchCases, UInt32& numberOfCases);
    public virtual void TraverseChildren(ITargetExpression targetExpression);
    public virtual void TraverseChildren(IThisReference thisReference);
    public virtual void TraverseChildren(IThrowStatement throwStatement);
    public virtual void TraverseChildren(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual void TraverseChildren(ITokenOf tokenOf);
    public virtual void TraverseChildren(ITypeOf typeOf);
    public virtual void TraverseChildren(IUnaryNegation unaryNegation);
    public virtual void TraverseChildren(IUnaryPlus unaryPlus);
    public virtual void TraverseChildren(IVectorLength vectorLength);
    public virtual void TraverseChildren(IWhileDoStatement whileDoStatement);
    public virtual void TraverseChildren(IYieldBreakStatement yieldBreakStatement);
    public virtual void TraverseChildren(IYieldReturnStatement yieldReturnStatement);
    private void VisitCheckedConversion(ITypeReference sourceType, ITypeReference targetType);
    private void VisitUncheckedConversion(ITypeReference sourceType, ITypeReference targetType);
    private void VisitBranchIfFalse(IExpression expression, ILGeneratorLabel targetLabel);
    private static bool KeepUnsignedButInvertUnordered(bool usignedOrUnordered, IBinaryOperation binOp);
    private void VisitBranchIfTrue(IExpression expression, ILGeneratorLabel targetLabel);
    private MethodReference get_DecimalConstructor();
    private void EmitConstant(IConvertible ic);
    private void EmitSequencePoint(IEnumerable`1<ILocation> locations);
    private ushort GetLocalIndex(ILocalDefinition local);
    public UInt32 GetBodySize();
    public IEnumerable`1<ILocalScope> GetIteratorScopes();
    public IEnumerable`1<ILocalScope> GetLocalScopes();
    public sealed virtual IEnumerable`1<ILocalDefinition> GetLocalVariables();
    public IEnumerable`1<INamespaceScope> GetNamespaceScopes();
    public sealed virtual IEnumerable`1<IOperation> GetOperations();
    public ISynchronizationInformation GetSynchronizationInformation();
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> GetOperationExceptionInformation();
    public virtual IEnumerable`1<ITypeDefinition> GetPrivateHelperTypes();
    private IMethodReference get_GetTypeFromHandle();
    public virtual void ConvertToIL(IBlockStatement body);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__41_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <VisitAssignment>b__52_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__60_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__62_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__84_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__90_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__104_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__114_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__116_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__130_0(IExpression e);
    [CompilerGeneratedAttribute]
private void <TraverseChildren>b__136_0(IExpression e);
}
public class Microsoft.Cci.CodeTraverser : MetadataTraverser {
    private ICodeVisitor preorderVisitor;
    private ICodeVisitor postorderVisitor;
    private Dispatcher dispatchingVisitor;
    public ICodeVisitor PreorderVisitor { get; public set; }
    public ICodeVisitor PostorderVisitor { get; public set; }
    public ICodeVisitor get_PreorderVisitor();
    public void set_PreorderVisitor(ICodeVisitor value);
    public ICodeVisitor get_PostorderVisitor();
    public void set_PostorderVisitor(ICodeVisitor value);
    public void Traverse(IAddition addition);
    public void Traverse(IAddressableExpression addressableExpression);
    public void Traverse(IAddressDereference addressDereference);
    public void Traverse(IAddressOf addressOf);
    public void Traverse(IAnonymousDelegate anonymousDelegate);
    public void Traverse(IArrayIndexer arrayIndexer);
    public void Traverse(IAssertStatement assertStatement);
    public void Traverse(IAssignment assignment);
    public void Traverse(IAssumeStatement assumeStatement);
    public void Traverse(IBinaryOperation binaryOperation);
    public void Traverse(IBitwiseAnd bitwiseAnd);
    public void Traverse(IBitwiseOr bitwiseOr);
    public void Traverse(IBlockExpression blockExpression);
    public void Traverse(IBlockStatement block);
    public void Traverse(IBoundExpression boundExpression);
    public void Traverse(IBreakStatement breakStatement);
    public void Traverse(ICastIfPossible castIfPossible);
    public void Traverse(ICatchClause catchClause);
    public void Traverse(ICheckIfInstance checkIfInstance);
    public void Traverse(ICompileTimeConstant constant);
    public void Traverse(IConditional conditional);
    public void Traverse(IConditionalStatement conditionalStatement);
    public void Traverse(IContinueStatement continueStatement);
    public void Traverse(IConversion conversion);
    public void Traverse(ICopyMemoryStatement copyMemoryStatement);
    public void Traverse(ICreateArray createArray);
    public void Traverse(ICreateDelegateInstance createDelegateInstance);
    public void Traverse(ICreateObjectInstance createObjectInstance);
    public void Traverse(IDebuggerBreakStatement debuggerBreakStatement);
    public void Traverse(IDefaultValue defaultValue);
    public void Traverse(IDivision division);
    public void Traverse(IDoUntilStatement doUntilStatement);
    public void Traverse(IDupValue dupValue);
    public void Traverse(IEmptyStatement emptyStatement);
    public void Traverse(IEquality equality);
    public void Traverse(IExclusiveOr exclusiveOr);
    public void Traverse(IExpression expression);
    public void Traverse(IExpressionStatement expressionStatement);
    public void Traverse(IFillMemoryStatement fillMemoryStatement);
    public void Traverse(IForEachStatement forEachStatement);
    public void Traverse(IForStatement forStatement);
    public void Traverse(IGetTypeOfTypedReference getTypeOfTypedReference);
    public void Traverse(IGetValueOfTypedReference getValueOfTypedReference);
    public void Traverse(IGotoStatement gotoStatement);
    public void Traverse(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public void Traverse(IGreaterThan greaterThan);
    public void Traverse(IGreaterThanOrEqual greaterThanOrEqual);
    public void Traverse(ILabeledStatement labeledStatement);
    public void Traverse(ILeftShift leftShift);
    public void Traverse(ILessThan lessThan);
    public void Traverse(ILessThanOrEqual lessThanOrEqual);
    public void Traverse(ILocalDeclarationStatement localDeclarationStatement);
    public void Traverse(ILockStatement lockStatement);
    public void Traverse(ILogicalNot logicalNot);
    public void Traverse(IMakeTypedReference makeTypedReference);
    public virtual void Traverse(IMethodBody methodBody);
    public void Traverse(IMethodCall methodCall);
    public void Traverse(IModulus modulus);
    public void Traverse(IMultiplication multiplication);
    public void Traverse(INamedArgument namedArgument);
    public void Traverse(INotEquality notEquality);
    public void Traverse(IOldValue oldValue);
    public void Traverse(IOnesComplement onesComplement);
    public void Traverse(IOutArgument outArgument);
    public void Traverse(IPointerCall pointerCall);
    public void Traverse(IPopValue popValue);
    public void Traverse(IPushStatement pushStatement);
    public void Traverse(IRefArgument refArgument);
    public void Traverse(IResourceUseStatement resourceUseStatement);
    public void Traverse(IRethrowStatement rethrowStatement);
    public void Traverse(IReturnStatement returnStatement);
    public void Traverse(IReturnValue returnValue);
    public void Traverse(IRightShift rightShift);
    public void Traverse(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public void Traverse(ISizeOf sizeOf);
    public void Traverse(ISourceMethodBody sourceMethodBody);
    public void Traverse(IStackArrayCreate stackArrayCreate);
    public void Traverse(IStatement statement);
    public void Traverse(ISubtraction subtraction);
    public void Traverse(ISwitchCase switchCase);
    public void Traverse(ISwitchStatement switchStatement);
    public void Traverse(ITargetExpression targetExpression);
    public void Traverse(IThisReference thisReference);
    public void Traverse(IThrowStatement throwStatement);
    public void Traverse(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public void Traverse(ITokenOf tokenOf);
    public void Traverse(ITypeOf typeOf);
    public void Traverse(IUnaryNegation unaryNegation);
    public void Traverse(IUnaryOperation unaryOperation);
    public void Traverse(IUnaryPlus unaryPlus);
    public void Traverse(IVectorLength vectorLength);
    public void Traverse(IWhileDoStatement whileDoStatement);
    public void Traverse(IYieldBreakStatement yieldBreakStatement);
    public void Traverse(IYieldReturnStatement yieldReturnStatement);
    public void Traverse(IEnumerable`1<ICatchClause> catchClauses);
    public void Traverse(IEnumerable`1<IExpression> expressions);
    public void Traverse(IEnumerable`1<ISwitchCase> switchCases);
    public void Traverse(IEnumerable`1<IStatement> statements);
    public virtual void TraverseChildren(IAddition addition);
    public virtual void TraverseChildren(IAddressableExpression addressableExpression);
    public virtual void TraverseChildren(IAddressDereference addressDereference);
    public virtual void TraverseChildren(IAddressOf addressOf);
    public virtual void TraverseChildren(IAnonymousDelegate anonymousDelegate);
    public virtual void TraverseChildren(IArrayIndexer arrayIndexer);
    public virtual void TraverseChildren(IAssertStatement assertStatement);
    public virtual void TraverseChildren(IAssignment assignment);
    public virtual void TraverseChildren(IAssumeStatement assumeStatement);
    public virtual void TraverseChildren(IBinaryOperation binaryOperation);
    public virtual void TraverseChildren(IBitwiseAnd bitwiseAnd);
    public virtual void TraverseChildren(IBitwiseOr bitwiseOr);
    public virtual void TraverseChildren(IBlockExpression blockExpression);
    public virtual void TraverseChildren(IBlockStatement block);
    public virtual void TraverseChildren(IBoundExpression boundExpression);
    public virtual void TraverseChildren(IBreakStatement breakStatement);
    public virtual void TraverseChildren(ICastIfPossible castIfPossible);
    public virtual void TraverseChildren(ICatchClause catchClause);
    public virtual void TraverseChildren(ICheckIfInstance checkIfInstance);
    public virtual void TraverseChildren(ICompileTimeConstant constant);
    public virtual void TraverseChildren(IConditional conditional);
    public virtual void TraverseChildren(IConditionalStatement conditionalStatement);
    public virtual void TraverseChildren(IContinueStatement continueStatement);
    public virtual void TraverseChildren(ICopyMemoryStatement copyMemoryStatement);
    public virtual void TraverseChildren(IConversion conversion);
    public virtual void TraverseChildren(ICreateArray createArray);
    public virtual void TraverseChildren(ICreateDelegateInstance createDelegateInstance);
    public virtual void TraverseChildren(ICreateObjectInstance createObjectInstance);
    public virtual void TraverseChildren(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual void TraverseChildren(IDefaultValue defaultValue);
    public virtual void TraverseChildren(IDivision division);
    public virtual void TraverseChildren(IDoUntilStatement doUntilStatement);
    public virtual void TraverseChildren(IDupValue dupValue);
    public virtual void TraverseChildren(IEmptyStatement emptyStatement);
    public virtual void TraverseChildren(IEquality equality);
    public virtual void TraverseChildren(IExclusiveOr exclusiveOr);
    public virtual void TraverseChildren(IExpression expression);
    public virtual void TraverseChildren(IExpressionStatement expressionStatement);
    public virtual void TraverseChildren(IFillMemoryStatement fillMemoryStatement);
    public virtual void TraverseChildren(IForEachStatement forEachStatement);
    public virtual void TraverseChildren(IForStatement forStatement);
    public virtual void TraverseChildren(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void TraverseChildren(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual void TraverseChildren(IGotoStatement gotoStatement);
    public virtual void TraverseChildren(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void TraverseChildren(IGreaterThan greaterThan);
    public virtual void TraverseChildren(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual void TraverseChildren(ILabeledStatement labeledStatement);
    public virtual void TraverseChildren(ILeftShift leftShift);
    public virtual void TraverseChildren(ILessThan lessThan);
    public virtual void TraverseChildren(ILessThanOrEqual lessThanOrEqual);
    public virtual void TraverseChildren(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void TraverseChildren(ILockStatement lockStatement);
    public virtual void TraverseChildren(ILogicalNot logicalNot);
    public virtual void TraverseChildren(IMakeTypedReference makeTypedReference);
    public virtual void TraverseChildren(IMethodCall methodCall);
    public virtual void TraverseChildren(IModulus modulus);
    public virtual void TraverseChildren(IMultiplication multiplication);
    public virtual void TraverseChildren(INamedArgument namedArgument);
    public virtual void TraverseChildren(INotEquality notEquality);
    public virtual void TraverseChildren(IOldValue oldValue);
    public virtual void TraverseChildren(IOnesComplement onesComplement);
    public virtual void TraverseChildren(IOutArgument outArgument);
    public virtual void TraverseChildren(IPointerCall pointerCall);
    public virtual void TraverseChildren(IPopValue popValue);
    public virtual void TraverseChildren(IPushStatement pushStatement);
    public virtual void TraverseChildren(IRefArgument refArgument);
    public virtual void TraverseChildren(IResourceUseStatement resourceUseStatement);
    public virtual void TraverseChildren(IRethrowStatement rethrowStatement);
    public virtual void TraverseChildren(IReturnStatement returnStatement);
    public virtual void TraverseChildren(IReturnValue returnValue);
    public virtual void TraverseChildren(IRightShift rightShift);
    public virtual void TraverseChildren(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void TraverseChildren(ISizeOf sizeOf);
    public virtual void TraverseChildren(ISourceMethodBody sourceMethodBody);
    public virtual void TraverseChildren(IStackArrayCreate stackArrayCreate);
    public virtual void TraverseChildren(IStatement statement);
    public virtual void TraverseChildren(ISubtraction subtraction);
    public virtual void TraverseChildren(ISwitchCase switchCase);
    public virtual void TraverseChildren(ISwitchStatement switchStatement);
    public virtual void TraverseChildren(ITargetExpression targetExpression);
    public virtual void TraverseChildren(IThisReference thisReference);
    public virtual void TraverseChildren(IThrowStatement throwStatement);
    public virtual void TraverseChildren(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual void TraverseChildren(ITokenOf tokenOf);
    public virtual void TraverseChildren(ITypeOf typeOf);
    public virtual void TraverseChildren(IUnaryNegation unaryNegation);
    public virtual void TraverseChildren(IUnaryOperation unaryOperation);
    public virtual void TraverseChildren(IUnaryPlus unaryPlus);
    public virtual void TraverseChildren(IVectorLength vectorLength);
    public virtual void TraverseChildren(IWhileDoStatement whileDoStatement);
    public virtual void TraverseChildren(IYieldBreakStatement yieldBreakStatement);
    public virtual void TraverseChildren(IYieldReturnStatement yieldReturnStatement);
}
public class Microsoft.Cci.CodeVisitor : MetadataVisitor {
    public virtual void Visit(IAddition addition);
    public virtual void Visit(IAddressableExpression addressableExpression);
    public virtual void Visit(IAddressDereference addressDereference);
    public virtual void Visit(IAddressOf addressOf);
    public virtual void Visit(IAnonymousDelegate anonymousDelegate);
    public virtual void Visit(IArrayIndexer arrayIndexer);
    public virtual void Visit(IAssertStatement assertStatement);
    public virtual void Visit(IAssignment assignment);
    public virtual void Visit(IAssumeStatement assumeStatement);
    public virtual void Visit(IBitwiseAnd bitwiseAnd);
    public virtual void Visit(IBinaryOperation binaryOperation);
    public virtual void Visit(IBitwiseOr bitwiseOr);
    public virtual void Visit(IBlockExpression blockExpression);
    public virtual void Visit(IBlockStatement block);
    public virtual void Visit(IBreakStatement breakStatement);
    public virtual void Visit(ICastIfPossible castIfPossible);
    public virtual void Visit(ICatchClause catchClause);
    public virtual void Visit(ICheckIfInstance checkIfInstance);
    public virtual void Visit(ICompileTimeConstant constant);
    public virtual void Visit(IConversion conversion);
    public virtual void Visit(IConditional conditional);
    public virtual void Visit(IConditionalStatement conditionalStatement);
    public virtual void Visit(IContinueStatement continueStatement);
    public virtual void Visit(ICopyMemoryStatement copyMemoryStatement);
    public virtual void Visit(ICreateArray createArray);
    public virtual void Visit(ICreateObjectInstance createObjectInstance);
    public virtual void Visit(ICreateDelegateInstance createDelegateInstance);
    public virtual void Visit(IDefaultValue defaultValue);
    public virtual void Visit(IDivision division);
    public virtual void Visit(IDoUntilStatement doUntilStatement);
    public virtual void Visit(IDupValue dupValue);
    public virtual void Visit(IEmptyStatement emptyStatement);
    public virtual void Visit(IEquality equality);
    public virtual void Visit(IExclusiveOr exclusiveOr);
    public virtual void Visit(IBoundExpression boundExpression);
    public virtual void Visit(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual void Visit(IExpression expression);
    public virtual void Visit(IExpressionStatement expressionStatement);
    public virtual void Visit(IFillMemoryStatement fillMemoryStatement);
    public virtual void Visit(IForEachStatement forEachStatement);
    public virtual void Visit(IForStatement forStatement);
    public virtual void Visit(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void Visit(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual void Visit(IGotoStatement gotoStatement);
    public virtual void Visit(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void Visit(IGreaterThan greaterThan);
    public virtual void Visit(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual void Visit(ILabeledStatement labeledStatement);
    public virtual void Visit(ILeftShift leftShift);
    public virtual void Visit(ILessThan lessThan);
    public virtual void Visit(ILessThanOrEqual lessThanOrEqual);
    public virtual void Visit(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void Visit(ILockStatement lockStatement);
    public virtual void Visit(ILogicalNot logicalNot);
    public virtual void Visit(IMakeTypedReference makeTypedReference);
    public virtual void Visit(IMethodCall methodCall);
    public virtual void Visit(IModulus modulus);
    public virtual void Visit(IMultiplication multiplication);
    public virtual void Visit(INamedArgument namedArgument);
    public virtual void Visit(INotEquality notEquality);
    public virtual void Visit(IOldValue oldValue);
    public virtual void Visit(IOnesComplement onesComplement);
    public virtual void Visit(IOutArgument outArgument);
    public virtual void Visit(IPointerCall pointerCall);
    public virtual void Visit(IPopValue popValue);
    public virtual void Visit(IPushStatement pushStatement);
    public virtual void Visit(IRefArgument refArgument);
    public virtual void Visit(IResourceUseStatement resourceUseStatement);
    public virtual void Visit(IRethrowStatement rethrowStatement);
    public virtual void Visit(IReturnStatement returnStatement);
    public virtual void Visit(IReturnValue returnValue);
    public virtual void Visit(IRightShift rightShift);
    public virtual void Visit(IStackArrayCreate stackArrayCreate);
    public virtual void Visit(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void Visit(ISizeOf sizeOf);
    public virtual void Visit(IStatement statement);
    public virtual void Visit(ISubtraction subtraction);
    public virtual void Visit(ISwitchCase switchCase);
    public virtual void Visit(ISwitchStatement switchStatement);
    public virtual void Visit(ITargetExpression targetExpression);
    public virtual void Visit(IThisReference thisReference);
    public virtual void Visit(IThrowStatement throwStatement);
    public virtual void Visit(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual void Visit(ITokenOf tokenOf);
    public virtual void Visit(ITypeOf typeOf);
    public virtual void Visit(IUnaryNegation unaryNegation);
    public virtual void Visit(IUnaryOperation unaryOperation);
    public virtual void Visit(IUnaryPlus unaryPlus);
    public virtual void Visit(IVectorLength vectorLength);
    public virtual void Visit(IWhileDoStatement whileDoStatement);
    public virtual void Visit(IYieldBreakStatement yieldBreakStatement);
    public virtual void Visit(IYieldReturnStatement yieldReturnStatement);
}
public abstract class Microsoft.Cci.CompositeSourceDocument : SourceDocument {
    private int currentFragmentOffset;
    private bool enumeratorIsValid;
    private IEnumerator`1<ISourceLocation> fragmentEnumerator;
    private Nullable`1<int> length;
    private SourceLocationSpanningEntireDerivedSourceDocument sourceLocation;
    private int lineCounter;
    private int columnCounter;
    private int lastPosition;
    public int Length { get; }
    public string Location { get; }
    public SourceLocation SourceLocation { get; }
    private IDerivedSourceLocation Microsoft.Cci.IDerivedSourceDocument.DerivedSourceLocation { get; }
    protected CompositeSourceDocument(IName name);
    protected CompositeSourceDocument(SourceDocument previousVersion, int position, int oldLength, int newLength);
    private void ObjectInvariant();
    public virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public sealed virtual IDerivedSourceLocation GetDerivedSourceLocation(int position, int length);
    protected virtual IEnumerable`1<ISourceLocation> GetFragments();
    [IteratorStateMachineAttribute("Microsoft.Cci.CompositeSourceDocument/<GetFragmentLocationsFor>d__9")]
public IEnumerable`1<ISourceLocation> GetFragmentLocationsFor(ISourceLocation sourceLocation);
    [IteratorStateMachineAttribute("Microsoft.Cci.CompositeSourceDocument/<GetPrimarySourceLocationsFor>d__10")]
public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IDerivedSourceLocation derivedSourceLocation);
    public virtual ISourceLocation GetSourceLocation(int position, int length);
    public virtual string GetText();
    public virtual int get_Length();
    public virtual string get_Location();
    public virtual SourceLocation get_SourceLocation();
    public void ToLineColumn(int position, Int32& line, Int32& column);
    private void ToLineColumn(int position, Int32& line, Int32& column, string text);
    private sealed virtual override IDerivedSourceLocation Microsoft.Cci.IDerivedSourceDocument.get_DerivedSourceLocation();
}
internal static class Microsoft.Cci.ContainerCache : object {
    [ThreadStaticAttribute]
private static Containers ts_CachedContainers;
    internal static T Acquire(T& field);
    internal static T Acquire(T& field1, T& field2);
    internal static void Release(T& field1, T& field2, T container);
    internal static Containers GetContainers();
    public static Dictionary`2<object, object> AcquireObjectDictionary();
    public static void Release(Dictionary`2<object, object> dic);
    public static SetOfObjects AcquireSetOfObjects(UInt32 capacity);
    public static void ReleaseSetOfObjects(SetOfObjects& setOfObjects);
    public static Hashtable`2<object, object> AcquireHashtable(UInt32 capacity);
    public static void ReleaseHashtable(Hashtable`2& hashTable);
    public static Hashtable`2<IReference, object> AcquireRefHashtable(UInt32 capacity);
    public static void ReleaseRefHashtable(Hashtable`2& hashTable);
}
public class Microsoft.Cci.ContinuationLocation : object {
    private SynchronizationPointLocation synchronizationPointLocation;
    public SynchronizationPointLocation SynchronizationPointLocation { get; }
    public IDocument Document { get; }
    public ContinuationLocation(SynchronizationPointLocation synchronizationPointLocation);
    private void ObjectInvariant();
    public SynchronizationPointLocation get_SynchronizationPointLocation();
    public sealed virtual IDocument get_Document();
}
[ObsoleteAttribute("Please use CodeAndContractVisitor")]
public class Microsoft.Cci.Contracts.BaseCodeAndContractTraverser : BaseCodeTraverser {
    protected IContractProvider contractProvider;
    public BaseCodeAndContractTraverser(IContractProvider contractProvider);
    public virtual void Visit(IEnumerable`1<IAddressableExpression> addressableExpressions);
    public virtual void Visit(IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    public virtual void Visit(IExpression expression);
    public virtual void Visit(ILoopContract loopContract);
    public virtual void Visit(IEnumerable`1<ILoopInvariant> loopInvariants);
    public virtual void Visit(ILoopInvariant loopInvariant);
    public virtual void Visit(IMethodContract methodContract);
    public virtual void Visit(IEnumerable`1<IPostcondition> postConditions);
    public virtual void Visit(IPostcondition postCondition);
    public virtual void Visit(IEnumerable`1<IPrecondition> preconditions);
    public virtual void Visit(IPrecondition precondition);
    public virtual void Visit(IStatement statement);
    public virtual void Visit(IEnumerable`1<IThrownException> thrownExceptions);
    public virtual void Visit(IThrownException thrownException);
    public virtual void Visit(ITypeContract typeContract);
    public virtual void Visit(IEnumerable`1<ITypeInvariant> typeInvariants);
    public virtual void Visit(ITypeInvariant typeInvariant);
    public virtual void Visit(IMethodDefinition method);
    public virtual void Visit(ITypeDefinition typeDefinition);
}
[ObsoleteAttribute("Please use CodeAndContractVisitor")]
public class Microsoft.Cci.Contracts.BaseCodeAndContractVisitor : BaseCodeVisitor {
    protected IContractProvider contractProvider;
    public BaseCodeAndContractVisitor(IContractProvider contractProvider);
    public virtual void Visit(ILoopContract loopContract);
    public virtual void Visit(ILoopInvariant loopInvariant);
    public virtual void Visit(IMethodContract methodContract);
    public virtual void Visit(IPostcondition postCondition);
    public virtual void Visit(IPrecondition precondition);
    public virtual void Visit(IThrownException thrownException);
    public virtual void Visit(ITypeContract typeContract);
    public virtual void Visit(ITypeInvariant typeInvariant);
}
public class Microsoft.Cci.Contracts.CodeAndContractTraverser : CodeTraverser {
    protected IContractProvider contractProvider;
    private ICodeAndContractVisitor preorderVisitor;
    private ICodeAndContractVisitor postorderVisitor;
    private ContractElementDispatcher dispatchingVisitor;
    public ICodeAndContractVisitor PreorderVisitor { get; public set; }
    public ICodeAndContractVisitor PostorderVisitor { get; public set; }
    public CodeAndContractTraverser(IContractProvider contractProvider);
    public ICodeAndContractVisitor get_PreorderVisitor();
    public void set_PreorderVisitor(ICodeAndContractVisitor value);
    public ICodeAndContractVisitor get_PostorderVisitor();
    public void set_PostorderVisitor(ICodeAndContractVisitor value);
    public void Traverse(IContractElement contractElement);
    public virtual void Traverse(IEnumerable`1<IAddressableExpression> addressableExpressions);
    public virtual void Traverse(IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    public virtual void Traverse(IEnumerable`1<ILoopInvariant> loopInvariants);
    public virtual void Traverse(IEnumerable`1<IPostcondition> postConditions);
    public virtual void Traverse(IEnumerable`1<IPrecondition> preconditions);
    public virtual void Traverse(IEnumerable`1<IThrownException> thrownExceptions);
    public virtual void Traverse(IEnumerable`1<ITypeInvariant> typeInvariants);
    public void Traverse(ILoopContract loopContract);
    public void Traverse(ILoopInvariant loopInvariant);
    public void Traverse(IMethodContract methodContract);
    public void Traverse(IPostcondition postCondition);
    public void Traverse(IPrecondition precondition);
    public void Traverse(IThrownException thrownException);
    public void Traverse(ITypeContract typeContract);
    public void Traverse(ITypeInvariant typeInvariant);
    public virtual void TraverseChildren(IContractElement contractElement);
    public virtual void TraverseChildren(ILoopContract loopContract);
    public virtual void TraverseChildren(ILoopInvariant loopInvariant);
    public virtual void TraverseChildren(IMethodCall methodCall);
    public virtual void TraverseChildren(IMethodContract methodContract);
    public virtual void TraverseChildren(IMethodDefinition method);
    public virtual void TraverseChildren(IPostcondition postCondition);
    public virtual void TraverseChildren(IPrecondition precondition);
    public virtual void TraverseChildren(IStatement statement);
    public virtual void TraverseChildren(IThrownException thrownException);
    public virtual void TraverseChildren(ITypeContract typeContract);
    public virtual void TraverseChildren(ITypeDefinition typeDefinition);
    public virtual void TraverseChildren(ITypeInvariant typeInvariant);
}
public class Microsoft.Cci.Contracts.CodeAndContractVisitor : CodeVisitor {
    protected IContractProvider contractProvider;
    public CodeAndContractVisitor(IContractProvider contractProvider);
    public virtual void Visit(IContractElement contractElement);
    public virtual void Visit(ILoopContract loopContract);
    public virtual void Visit(ILoopInvariant loopInvariant);
    public virtual void Visit(IMethodContract methodContract);
    public virtual void Visit(IPostcondition postCondition);
    public virtual void Visit(IPrecondition precondition);
    public virtual void Visit(IThrownException thrownException);
    public virtual void Visit(ITypeContract typeContract);
    public virtual void Visit(ITypeInvariant typeInvariant);
}
public static class Microsoft.Cci.Contracts.ContractDummy : object {
    private static IMethodContract methodContract;
    private static ITypeContract typeContract;
    private static IPostcondition postcondition;
    public static IMethodContract MethodContract { get; }
    public static ITypeContract TypeContract { get; }
    public static IPostcondition Postcondition { get; }
    public static IMethodContract get_MethodContract();
    public static ITypeContract get_TypeContract();
    public static IPostcondition get_Postcondition();
}
public class Microsoft.Cci.Contracts.ContractMethods : object {
    private IMethodReference assertRef;
    private IMethodReference assumeRef;
    private IMethodReference endContract;
    private IMethodReference ensuresRef;
    private IMethodReference existsRef;
    private IMethodReference forallRef;
    private INamedTypeReference predicateType;
    private IMethodReference invariantRef;
    private IMethodReference oldRef;
    private IMethodReference requiresRef;
    private IMethodReference result;
    private IMethodReference startContract;
    private IMetadataHost host;
    public IMethodReference Assert { get; }
    public IMethodReference Assume { get; }
    public IMethodReference EndContract { get; }
    public IMethodReference Ensures { get; }
    public IMethodReference Exists { get; }
    public IMethodReference Forall { get; }
    private INamedTypeReference PredicateType { get; }
    public IMethodReference Invariant { get; }
    public IMethodReference Old { get; }
    public IMethodReference Requires { get; }
    public IMethodReference Result { get; }
    public IMethodReference StartContract { get; }
    public ContractMethods(IMetadataHost host);
    public sealed virtual IMethodReference get_Assert();
    public sealed virtual IMethodReference get_Assume();
    public sealed virtual IMethodReference get_EndContract();
    public sealed virtual IMethodReference get_Ensures();
    public sealed virtual IMethodReference get_Exists();
    public sealed virtual IMethodReference get_Forall();
    private INamedTypeReference get_PredicateType();
    public sealed virtual IMethodReference get_Invariant();
    public sealed virtual IMethodReference get_Old();
    public sealed virtual IMethodReference get_Requires();
    public sealed virtual IMethodReference get_Result();
    public sealed virtual IMethodReference get_StartContract();
}
internal class Microsoft.Cci.Contracts.DummyMethodContract : object {
    public IEnumerable`1<IExpression> Allocates { get; }
    public IEnumerable`1<IExpression> Frees { get; }
    public IEnumerable`1<IAddressableExpression> ModifiedVariables { get; }
    public bool MustInline { get; }
    public IEnumerable`1<IPostcondition> Postconditions { get; }
    public IEnumerable`1<IPrecondition> Preconditions { get; }
    public IEnumerable`1<IExpression> Reads { get; }
    public IEnumerable`1<IThrownException> ThrownExceptions { get; }
    public IEnumerable`1<IExpression> Writes { get; }
    public IEnumerable`1<IExpression> Variants { get; }
    public bool IsPure { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IExpression> get_Allocates();
    public sealed virtual IEnumerable`1<IExpression> get_Frees();
    public sealed virtual IEnumerable`1<IAddressableExpression> get_ModifiedVariables();
    public sealed virtual bool get_MustInline();
    public sealed virtual IEnumerable`1<IPostcondition> get_Postconditions();
    public sealed virtual IEnumerable`1<IPrecondition> get_Preconditions();
    public sealed virtual IEnumerable`1<IExpression> get_Reads();
    public sealed virtual IEnumerable`1<IThrownException> get_ThrownExceptions();
    public sealed virtual IEnumerable`1<IExpression> get_Writes();
    public sealed virtual IEnumerable`1<IExpression> get_Variants();
    public sealed virtual bool get_IsPure();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.Contracts.DummyPostcondition : object {
    public IExpression Condition { get; }
    public IExpression Description { get; }
    public string OriginalSource { get; }
    public bool IsModel { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Condition();
    public sealed virtual IExpression get_Description();
    public sealed virtual void Dispatch(ICodeAndContractVisitor visitor);
    public sealed virtual string get_OriginalSource();
    public sealed virtual bool get_IsModel();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.Contracts.DummyTypeContract : object {
    public IEnumerable`1<IFieldDefinition> ContractFields { get; }
    public IEnumerable`1<IMethodDefinition> ContractMethods { get; }
    public IEnumerable`1<ITypeInvariant> Invariants { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IFieldDefinition> get_ContractFields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_ContractMethods();
    public sealed virtual IEnumerable`1<ITypeInvariant> get_Invariants();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.Contracts.ICodeAndContractVisitor {
    public abstract virtual void Visit(ILoopContract loopContract);
    public abstract virtual void Visit(ILoopInvariant loopInvariant);
    public abstract virtual void Visit(IMethodContract methodContract);
    public abstract virtual void Visit(IPostcondition postCondition);
    public abstract virtual void Visit(IPrecondition precondition);
    public abstract virtual void Visit(IThrownException thrownException);
    public abstract virtual void Visit(ITypeContract typeContract);
    public abstract virtual void Visit(ITypeInvariant typeInvariant);
}
internal abstract class Microsoft.Cci.Contracts.ICodeAndContractVisitorContract : object {
    public sealed virtual void Visit(ILoopContract loopContract);
    public sealed virtual void Visit(ILoopInvariant loopInvariant);
    public sealed virtual void Visit(IMethodContract methodContract);
    public sealed virtual void Visit(IPostcondition postCondition);
    public sealed virtual void Visit(IPrecondition precondition);
    public sealed virtual void Visit(IThrownException thrownException);
    public sealed virtual void Visit(ITypeContract typeContract);
    public sealed virtual void Visit(ITypeInvariant typeInvariant);
    public sealed virtual void Visit(IAddition addition);
    public sealed virtual void Visit(IAddressableExpression addressableExpression);
    public sealed virtual void Visit(IAddressDereference addressDereference);
    public sealed virtual void Visit(IAddressOf addressOf);
    public sealed virtual void Visit(IAnonymousDelegate anonymousDelegate);
    public sealed virtual void Visit(IArrayIndexer arrayIndexer);
    public sealed virtual void Visit(IAssertStatement assertStatement);
    public sealed virtual void Visit(IAssignment assignment);
    public sealed virtual void Visit(IAssumeStatement assumeStatement);
    public sealed virtual void Visit(IBitwiseAnd bitwiseAnd);
    public sealed virtual void Visit(IBitwiseOr bitwiseOr);
    public sealed virtual void Visit(IBlockExpression blockExpression);
    public sealed virtual void Visit(IBlockStatement block);
    public sealed virtual void Visit(IBreakStatement breakStatement);
    public sealed virtual void Visit(IBoundExpression boundExpression);
    public sealed virtual void Visit(ICastIfPossible castIfPossible);
    public sealed virtual void Visit(ICatchClause catchClause);
    public sealed virtual void Visit(ICheckIfInstance checkIfInstance);
    public sealed virtual void Visit(ICompileTimeConstant constant);
    public sealed virtual void Visit(IConversion conversion);
    public sealed virtual void Visit(IConditional conditional);
    public sealed virtual void Visit(IConditionalStatement conditionalStatement);
    public sealed virtual void Visit(IContinueStatement continueStatement);
    public sealed virtual void Visit(ICopyMemoryStatement copyMemoryBlock);
    public sealed virtual void Visit(ICreateArray createArray);
    public sealed virtual void Visit(ICreateDelegateInstance createDelegateInstance);
    public sealed virtual void Visit(ICreateObjectInstance createObjectInstance);
    public sealed virtual void Visit(IDebuggerBreakStatement debuggerBreakStatement);
    public sealed virtual void Visit(IDefaultValue defaultValue);
    public sealed virtual void Visit(IDivision division);
    public sealed virtual void Visit(IDoUntilStatement doUntilStatement);
    public sealed virtual void Visit(IDupValue dupValue);
    public sealed virtual void Visit(IEmptyStatement emptyStatement);
    public sealed virtual void Visit(IEquality equality);
    public sealed virtual void Visit(IExclusiveOr exclusiveOr);
    public sealed virtual void Visit(IExpressionStatement expressionStatement);
    public sealed virtual void Visit(IFillMemoryStatement fillMemoryStatement);
    public sealed virtual void Visit(IForEachStatement forEachStatement);
    public sealed virtual void Visit(IForStatement forStatement);
    public sealed virtual void Visit(IGotoStatement gotoStatement);
    public sealed virtual void Visit(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public sealed virtual void Visit(IGetTypeOfTypedReference getTypeOfTypedReference);
    public sealed virtual void Visit(IGetValueOfTypedReference getValueOfTypedReference);
    public sealed virtual void Visit(IGreaterThan greaterThan);
    public sealed virtual void Visit(IGreaterThanOrEqual greaterThanOrEqual);
    public sealed virtual void Visit(ILabeledStatement labeledStatement);
    public sealed virtual void Visit(ILeftShift leftShift);
    public sealed virtual void Visit(ILessThan lessThan);
    public sealed virtual void Visit(ILessThanOrEqual lessThanOrEqual);
    public sealed virtual void Visit(ILocalDeclarationStatement localDeclarationStatement);
    public sealed virtual void Visit(ILockStatement lockStatement);
    public sealed virtual void Visit(ILogicalNot logicalNot);
    public sealed virtual void Visit(IMakeTypedReference makeTypedReference);
    public sealed virtual void Visit(IMethodCall methodCall);
    public sealed virtual void Visit(IModulus modulus);
    public sealed virtual void Visit(IMultiplication multiplication);
    public sealed virtual void Visit(INamedArgument namedArgument);
    public sealed virtual void Visit(INotEquality notEquality);
    public sealed virtual void Visit(IOldValue oldValue);
    public sealed virtual void Visit(IOnesComplement onesComplement);
    public sealed virtual void Visit(IOutArgument outArgument);
    public sealed virtual void Visit(IPointerCall pointerCall);
    public sealed virtual void Visit(IPopValue popValue);
    public sealed virtual void Visit(IPushStatement pushStatement);
    public sealed virtual void Visit(IRefArgument refArgument);
    public sealed virtual void Visit(IResourceUseStatement resourceUseStatement);
    public sealed virtual void Visit(IReturnValue returnValue);
    public sealed virtual void Visit(IRethrowStatement rethrowStatement);
    public sealed virtual void Visit(IReturnStatement returnStatement);
    public sealed virtual void Visit(IRightShift rightShift);
    public sealed virtual void Visit(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public sealed virtual void Visit(ISizeOf sizeOf);
    public sealed virtual void Visit(IStackArrayCreate stackArrayCreate);
    public sealed virtual void Visit(ISubtraction subtraction);
    public sealed virtual void Visit(ISwitchCase switchCase);
    public sealed virtual void Visit(ISwitchStatement switchStatement);
    public sealed virtual void Visit(ITargetExpression targetExpression);
    public sealed virtual void Visit(IThisReference thisReference);
    public sealed virtual void Visit(IThrowStatement throwStatement);
    public sealed virtual void Visit(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public sealed virtual void Visit(ITokenOf tokenOf);
    public sealed virtual void Visit(ITypeOf typeOf);
    public sealed virtual void Visit(IUnaryNegation unaryNegation);
    public sealed virtual void Visit(IUnaryPlus unaryPlus);
    public sealed virtual void Visit(IVectorLength vectorLength);
    public sealed virtual void Visit(IWhileDoStatement whileDoStatement);
    public sealed virtual void Visit(IYieldBreakStatement yieldBreakStatement);
    public sealed virtual void Visit(IYieldReturnStatement yieldReturnStatement);
    public sealed virtual void Visit(IArrayTypeReference arrayTypeReference);
    public sealed virtual void Visit(IAssembly assembly);
    public sealed virtual void Visit(IAssemblyReference assemblyReference);
    public sealed virtual void Visit(ICustomAttribute customAttribute);
    public sealed virtual void Visit(ICustomModifier customModifier);
    public sealed virtual void Visit(IEventDefinition eventDefinition);
    public sealed virtual void Visit(IFieldDefinition fieldDefinition);
    public sealed virtual void Visit(IFieldReference fieldReference);
    public sealed virtual void Visit(IFileReference fileReference);
    public sealed virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public sealed virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public sealed virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public sealed virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public sealed virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public sealed virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public sealed virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public sealed virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public sealed virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public sealed virtual void Visit(ILocalDefinition localDefinition);
    public sealed virtual void VisitReference(ILocalDefinition localDefinition);
    public sealed virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public sealed virtual void Visit(IMarshallingInformation marshallingInformation);
    public sealed virtual void Visit(IMetadataConstant constant);
    public sealed virtual void Visit(IMetadataCreateArray createArray);
    public sealed virtual void Visit(IMetadataExpression expression);
    public sealed virtual void Visit(IMetadataNamedArgument namedArgument);
    public sealed virtual void Visit(IMetadataTypeOf typeOf);
    public sealed virtual void Visit(IMethodBody methodBody);
    public sealed virtual void Visit(IMethodDefinition method);
    public sealed virtual void Visit(IMethodImplementation methodImplementation);
    public sealed virtual void Visit(IMethodReference methodReference);
    public sealed virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public sealed virtual void Visit(IModule module);
    public sealed virtual void Visit(IModuleReference moduleReference);
    public sealed virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public sealed virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public sealed virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public sealed virtual void Visit(INestedAliasForType nestedAliasForType);
    public sealed virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public sealed virtual void Visit(INestedTypeReference nestedTypeReference);
    public sealed virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public sealed virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public sealed virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public sealed virtual void Visit(IOperation operation);
    public sealed virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public sealed virtual void Visit(IParameterDefinition parameterDefinition);
    public sealed virtual void VisitReference(IParameterDefinition parameterDefinition);
    public sealed virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public sealed virtual void Visit(IPESection peSection);
    public sealed virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public sealed virtual void Visit(IPointerTypeReference pointerTypeReference);
    public sealed virtual void Visit(IPropertyDefinition propertyDefinition);
    public sealed virtual void Visit(IResourceReference resourceReference);
    public sealed virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public sealed virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public sealed virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public sealed virtual void Visit(ISecurityAttribute securityAttribute);
    public sealed virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public sealed virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public sealed virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public sealed virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public sealed virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public sealed virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public sealed virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public sealed virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public sealed virtual void Visit(IUnitSet unitSet);
    public sealed virtual void Visit(IWin32Resource win32Resource);
}
public interface Microsoft.Cci.Contracts.IContractAwareHost {
    public abstract virtual IContractExtractor GetContractExtractor(UnitIdentity unitIdentity);
}
public interface Microsoft.Cci.Contracts.IContractElement {
    public IExpression Condition { get; }
    public IExpression Description { get; }
    public string OriginalSource { get; }
    public bool IsModel { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IExpression get_Description();
    public abstract virtual void Dispatch(ICodeAndContractVisitor visitor);
    public abstract virtual string get_OriginalSource();
    public abstract virtual bool get_IsModel();
}
public interface Microsoft.Cci.Contracts.IContractExtractor {
    public abstract virtual void RegisterContractProviderCallback(IContractProviderCallback contractProviderCallback);
    public abstract virtual MethodContractAndMethodBody SplitMethodBodyIntoContractAndCode(ISourceMethodBody sourceMethodBody);
}
public interface Microsoft.Cci.Contracts.IContractMethods {
    public IMethodReference Assert { get; }
    public IMethodReference Assume { get; }
    public IMethodReference EndContract { get; }
    public IMethodReference Exists { get; }
    public IMethodReference Ensures { get; }
    public IMethodReference Forall { get; }
    public IMethodReference Invariant { get; }
    public IMethodReference Old { get; }
    public IMethodReference Requires { get; }
    public IMethodReference Result { get; }
    public IMethodReference StartContract { get; }
    public abstract virtual IMethodReference get_Assert();
    public abstract virtual IMethodReference get_Assume();
    public abstract virtual IMethodReference get_EndContract();
    public abstract virtual IMethodReference get_Exists();
    public abstract virtual IMethodReference get_Ensures();
    public abstract virtual IMethodReference get_Forall();
    public abstract virtual IMethodReference get_Invariant();
    public abstract virtual IMethodReference get_Old();
    public abstract virtual IMethodReference get_Requires();
    public abstract virtual IMethodReference get_Result();
    public abstract virtual IMethodReference get_StartContract();
}
public interface Microsoft.Cci.Contracts.IContractProvider {
    public IContractMethods ContractMethods { get; }
    public IUnit Unit { get; }
    public abstract virtual ILoopContract GetLoopContractFor(object loop);
    public abstract virtual IMethodContract GetMethodContractFor(object method);
    public abstract virtual IEnumerable`1<IEnumerable`1<IExpression>> GetTriggersFor(object quantifier);
    public abstract virtual ITypeContract GetTypeContractFor(object type);
    public abstract virtual IContractMethods get_ContractMethods();
    public abstract virtual IUnit get_Unit();
}
public interface Microsoft.Cci.Contracts.IContractProviderCallback {
    public abstract virtual void ProvideResidualMethodBody(IMethodDefinition methodDefinition, IBlockStatement blockStatement);
}
public interface Microsoft.Cci.Contracts.ILoopContract {
    public IEnumerable`1<ILoopInvariant> Invariants { get; }
    public IEnumerable`1<IExpression> Writes { get; }
    public IEnumerable`1<IExpression> Variants { get; }
    public abstract virtual IEnumerable`1<ILoopInvariant> get_Invariants();
    public abstract virtual IEnumerable`1<IExpression> get_Writes();
    public abstract virtual IEnumerable`1<IExpression> get_Variants();
}
public interface Microsoft.Cci.Contracts.ILoopInvariant {
}
public interface Microsoft.Cci.Contracts.IMethodContract {
    public IEnumerable`1<IExpression> Allocates { get; }
    public IEnumerable`1<IExpression> Frees { get; }
    public IEnumerable`1<IAddressableExpression> ModifiedVariables { get; }
    public bool MustInline { get; }
    public IEnumerable`1<IPostcondition> Postconditions { get; }
    public IEnumerable`1<IPrecondition> Preconditions { get; }
    public IEnumerable`1<IExpression> Reads { get; }
    public IEnumerable`1<IThrownException> ThrownExceptions { get; }
    public IEnumerable`1<IExpression> Writes { get; }
    public IEnumerable`1<IExpression> Variants { get; }
    public bool IsPure { get; }
    public abstract virtual IEnumerable`1<IExpression> get_Allocates();
    public abstract virtual IEnumerable`1<IExpression> get_Frees();
    public abstract virtual IEnumerable`1<IAddressableExpression> get_ModifiedVariables();
    public abstract virtual bool get_MustInline();
    public abstract virtual IEnumerable`1<IPostcondition> get_Postconditions();
    public abstract virtual IEnumerable`1<IPrecondition> get_Preconditions();
    public abstract virtual IEnumerable`1<IExpression> get_Reads();
    public abstract virtual IEnumerable`1<IThrownException> get_ThrownExceptions();
    public abstract virtual IEnumerable`1<IExpression> get_Writes();
    public abstract virtual IEnumerable`1<IExpression> get_Variants();
    public abstract virtual bool get_IsPure();
}
public interface Microsoft.Cci.Contracts.IPostcondition {
}
public interface Microsoft.Cci.Contracts.IPrecondition {
    public bool AlwaysCheckedAtRuntime { get; }
    public IExpression ExceptionToThrow { get; }
    public abstract virtual bool get_AlwaysCheckedAtRuntime();
    public abstract virtual IExpression get_ExceptionToThrow();
}
public interface Microsoft.Cci.Contracts.IThrownException {
    public ITypeReference ExceptionType { get; }
    public IPostcondition Postcondition { get; }
    public abstract virtual ITypeReference get_ExceptionType();
    public abstract virtual IPostcondition get_Postcondition();
}
public interface Microsoft.Cci.Contracts.ITypeContract {
    public IEnumerable`1<IFieldDefinition> ContractFields { get; }
    public IEnumerable`1<IMethodDefinition> ContractMethods { get; }
    public IEnumerable`1<ITypeInvariant> Invariants { get; }
    public abstract virtual IEnumerable`1<IFieldDefinition> get_ContractFields();
    public abstract virtual IEnumerable`1<IMethodDefinition> get_ContractMethods();
    public abstract virtual IEnumerable`1<ITypeInvariant> get_Invariants();
}
public interface Microsoft.Cci.Contracts.ITypeInvariant {
    public bool IsAxiom { get; }
    public IName Name { get; }
    public abstract virtual bool get_IsAxiom();
    public abstract virtual IName get_Name();
}
public class Microsoft.Cci.Contracts.MethodContractAndMethodBody : ValueType {
    private IMethodContract methodContract;
    private IBlockStatement blockStatement;
    public IMethodContract MethodContract { get; public set; }
    public IBlockStatement BlockStatement { get; public set; }
    public MethodContractAndMethodBody(IMethodContract methodContract, IBlockStatement blockStatement);
    public IMethodContract get_MethodContract();
    public void set_MethodContract(IMethodContract value);
    public IBlockStatement get_BlockStatement();
    public void set_BlockStatement(IBlockStatement value);
}
[ExtensionAttribute]
internal static class Microsoft.Cci.ConvertExtensions : object {
    [ExtensionAttribute]
public static TypeCode ConvertGetTypeCode(object value);
}
internal class Microsoft.Cci.CopiedLocalScope : object {
    private IMethodBody copiedMethodBody;
    private ILocalScope originalScope;
    private UInt32 Microsoft.Cci.ILocalScope.Length { get; }
    private IMethodDefinition Microsoft.Cci.ILocalScope.MethodDefinition { get; }
    private UInt32 Microsoft.Cci.ILocalScope.Offset { get; }
    internal ILocalScope OriginalScope { get; }
    internal CopiedLocalScope(ILocalScope originalScope, IMethodBody copiedMethodBody);
    private void ObjectInvariant();
    private sealed virtual override UInt32 Microsoft.Cci.ILocalScope.get_Length();
    private sealed virtual override IMethodDefinition Microsoft.Cci.ILocalScope.get_MethodDefinition();
    private sealed virtual override UInt32 Microsoft.Cci.ILocalScope.get_Offset();
    internal ILocalScope get_OriginalScope();
}
public class Microsoft.Cci.CopiedLocalScopeProvider : object {
    private Hashtable`2<object, object> mapFromCopyToOriginal;
    private Hashtable`2<object, object> mapFromOriginalToCopy;
    private ILocalScopeProvider providerForOriginal;
    public CopiedLocalScopeProvider(Hashtable`2<object, object> mapFromCopyToOriginal, Hashtable`2<object, object> mapFromOriginalToCopy, ILocalScopeProvider providerForOriginal);
    private void ObjectInvariant();
    [IteratorStateMachineAttribute("Microsoft.Cci.CopiedLocalScopeProvider/<Microsoft-Cci-ILocalScopeProvider-GetIteratorScopes>d__5")]
private sealed virtual override IEnumerable`1<ILocalScope> Microsoft.Cci.ILocalScopeProvider.GetIteratorScopes(IMethodBody methodBody);
    [IteratorStateMachineAttribute("Microsoft.Cci.CopiedLocalScopeProvider/<Microsoft-Cci-ILocalScopeProvider-GetLocalScopes>d__6")]
private sealed virtual override IEnumerable`1<ILocalScope> Microsoft.Cci.ILocalScopeProvider.GetLocalScopes(IMethodBody methodBody);
    private sealed virtual override IEnumerable`1<INamespaceScope> Microsoft.Cci.ILocalScopeProvider.GetNamespaceScopes(IMethodBody methodBody);
    [IteratorStateMachineAttribute("Microsoft.Cci.CopiedLocalScopeProvider/<Microsoft-Cci-ILocalScopeProvider-GetConstantsInScope>d__8")]
private sealed virtual override IEnumerable`1<ILocalDefinition> Microsoft.Cci.ILocalScopeProvider.GetConstantsInScope(ILocalScope scope);
    [IteratorStateMachineAttribute("Microsoft.Cci.CopiedLocalScopeProvider/<Microsoft-Cci-ILocalScopeProvider-GetVariablesInScope>d__9")]
private sealed virtual override IEnumerable`1<ILocalDefinition> Microsoft.Cci.ILocalScopeProvider.GetVariablesInScope(ILocalScope scope);
    private ILocalDefinition GetCorrespondingLocal(ILocalDefinition originalLocalDef);
    private sealed virtual override bool Microsoft.Cci.ILocalScopeProvider.IsIterator(IMethodBody methodBody);
    private sealed virtual override ISynchronizationInformation Microsoft.Cci.ILocalScopeProvider.GetSynchronizationInformation(IMethodBody methodBody);
}
internal class Microsoft.Cci.CopiedSynchronizationInformation : object {
    private Hashtable`2<object, object> mapFromOriginaltoCopy;
    private ISynchronizationInformation originalSyncrhonizationInformation;
    private IMethodDefinition Microsoft.Cci.ISynchronizationInformation.AsyncMethod { get; }
    private IMethodDefinition Microsoft.Cci.ISynchronizationInformation.MoveNextMethod { get; }
    private UInt32 Microsoft.Cci.ISynchronizationInformation.GeneratedCatchHandlerOffset { get; }
    private IEnumerable`1<ISynchronizationPoint> Microsoft.Cci.ISynchronizationInformation.SynchronizationPoints { get; }
    internal CopiedSynchronizationInformation(ISynchronizationInformation originalSyncrhonizationInformation, Hashtable`2<object, object> mapFromOriginaltoCopy);
    private void ObjectInvariant();
    private sealed virtual override IMethodDefinition Microsoft.Cci.ISynchronizationInformation.get_AsyncMethod();
    private sealed virtual override IMethodDefinition Microsoft.Cci.ISynchronizationInformation.get_MoveNextMethod();
    private sealed virtual override UInt32 Microsoft.Cci.ISynchronizationInformation.get_GeneratedCatchHandlerOffset();
    [IteratorStateMachineAttribute("Microsoft.Cci.CopiedSynchronizationInformation/<Microsoft-Cci-ISynchronizationInformation-get_SynchronizationPoints>d__11")]
private sealed virtual override IEnumerable`1<ISynchronizationPoint> Microsoft.Cci.ISynchronizationInformation.get_SynchronizationPoints();
}
internal class Microsoft.Cci.CopiedSynchronizationPoint : object {
    private Hashtable`2<object, object> mapFromOriginaltoCopy;
    private ISynchronizationPoint original;
    private UInt32 Microsoft.Cci.ISynchronizationPoint.SynchronizeOffset { get; }
    private IMethodDefinition Microsoft.Cci.ISynchronizationPoint.ContinuationMethod { get; }
    private UInt32 Microsoft.Cci.ISynchronizationPoint.ContinuationOffset { get; }
    internal CopiedSynchronizationPoint(ISynchronizationPoint original, Hashtable`2<object, object> mapFromOriginaltoCopy);
    private void ObjectInvariant();
    private sealed virtual override UInt32 Microsoft.Cci.ISynchronizationPoint.get_SynchronizeOffset();
    private sealed virtual override IMethodDefinition Microsoft.Cci.ISynchronizationPoint.get_ContinuationMethod();
    private sealed virtual override UInt32 Microsoft.Cci.ISynchronizationPoint.get_ContinuationOffset();
}
public class Microsoft.Cci.CustomSectionProvider : MulticastDelegate {
    public CustomSectionProvider(object object, IntPtr method);
    public virtual IPESection Invoke(PEFileData peFileData, ITokenProvider tokenProvider);
    public virtual IAsyncResult BeginInvoke(PEFileData peFileData, ITokenProvider tokenProvider, AsyncCallback callback, object object);
    public virtual IPESection EndInvoke(IAsyncResult result);
}
public class Microsoft.Cci.DerivedSourceLocation : SourceLocation {
    private IDerivedSourceDocument derivedSourceDocument;
    public IDerivedSourceDocument DerivedSourceDocument { get; }
    public ISourceDocument SourceDocument { get; }
    private IEnumerable`1<IPrimarySourceLocation> Microsoft.Cci.IDerivedSourceLocation.PrimarySourceLocations { get; }
    public DerivedSourceLocation(IDerivedSourceDocument derivedSourceDocument, int startIndex, int length);
    private void ObjectInvariant();
    public sealed virtual IDerivedSourceDocument get_DerivedSourceDocument();
    public virtual ISourceDocument get_SourceDocument();
    private sealed virtual override IEnumerable`1<IPrimarySourceLocation> Microsoft.Cci.IDerivedSourceLocation.get_PrimarySourceLocations();
}
public abstract class Microsoft.Cci.Dummy : object {
    private static IAliasForType aliasForType;
    private static IAssembly assembly;
    private static AssemblyIdentity assemblyIdentity;
    private static IMetadataHost compilationHostEnvironment;
    private static IMetadataConstant constant;
    private static ICustomModifier customModifier;
    private static IEventDefinition eventDefinition;
    private static IFieldDefinition field;
    private static IMetadataExpression expression;
    private static IFunctionPointer functionPointer;
    private static DummyGenericMethodParameter genericMethodParameter;
    private static DummyGenericTypeInstance genericTypeInstance;
    private static IGenericTypeInstanceReference genericTypeInstanceReference;
    private static IGenericTypeParameter genericTypeParameter;
    private static IMethodDefinition methodDefinition;
    private static IMethodBody methodBody;
    private static IName name;
    private static IMetadataNamedArgument namedArgument;
    private static INamedTypeReference namedTypeReference;
    private static INameTable nameTable;
    private static INestedTypeDefinition nestedTypeDefinition;
    private static INestedTypeDefinition nestedTypeReference;
    private static INestedUnitNamespace nestedUnitNamespace;
    private static IPlatformType platformType;
    private static IPropertyDefinition propertyDefinition;
    private static IRootUnitNamespace rootUnitNamespace;
    private static ITypeDefinition type;
    private static ITypeReference typeReference;
    private static IUnit unit;
    private static UnitIdentity unitIdentity;
    private static IUnitNamespace unitNamespace;
    private static IUnitNamespaceReference unitNamespaceReference;
    private static IUnitReference unitReference;
    private static IUnitSet unitSet;
    private static IUnitSetNamespace unitSetNamespace;
    private static IRootUnitSetNamespace rootUnitSetNamespace;
    private static IModule module;
    private static ModuleIdentity moduleIdentity;
    private static IMethodReference methodReference;
    private static Version version;
    private static ICustomAttribute customAttribute;
    private static IFileReference fileReference;
    private static IResource resource;
    private static IModuleReference moduleReference;
    private static IAssemblyReference assemblyReference;
    private static IMarshallingInformation marshallingInformation;
    private static IParameterTypeInformation parameterTypeInformation;
    private static INamedTypeDefinition namedTypeDefinition;
    private static INamespaceDefinition namespaceDefinition;
    private static INamespaceRootOwner namespaceRootOwner;
    private static INamespaceTypeDefinition namespaceTypeDefinition;
    private static INamespaceTypeReference namespaceTypeReference;
    private static ISectionBlock sectionBlock;
    private static ISecurityAttribute securityAttribute;
    private static ISignature signature;
    private static ISpecializedNestedTypeDefinition specializedNestedTypeDefinition;
    private static ISpecializedFieldDefinition specializedFieldDefinition;
    private static ISpecializedMethodDefinition specializedMethodDefinition;
    private static ISpecializedPropertyDefinition specializedPropertyDefinition;
    private static ILocalDefinition localVariable;
    private static IFieldReference fieldReference;
    private static IParameterDefinition parameterDefinition;
    private static IPlatformInvokeInformation platformInvokeInformation;
    private static IGlobalMethodDefinition globalMethodDefinition;
    private static IGlobalFieldDefinition globalFieldDefinition;
    private static IOperation operation;
    private static ILocation location;
    private static IDocument document;
    private static IOperationExceptionInformation operationExceptionInformation;
    private static IInternFactory internFactory;
    private static IArrayType arrayType;
    private static ITypeDefinitionMember typeDefinitionMember;
    public static IAliasForType AliasForType { get; }
    public static IAssembly Assembly { get; }
    public static AssemblyIdentity AssemblyIdentity { get; }
    public static IMetadataHost CompilationHostEnvironment { get; }
    public static IMetadataConstant Constant { get; }
    public static ICustomModifier CustomModifier { get; }
    public static IEventDefinition Event { get; }
    public static IEventDefinition EventDefinition { get; }
    public static IFieldDefinition Field { get; }
    public static IFieldDefinition FieldDefinition { get; }
    public static IMetadataExpression Expression { get; }
    public static IFunctionPointer FunctionPointer { get; }
    public static IGenericMethodParameter GenericMethodParameter { get; }
    public static IGenericTypeInstance GenericTypeInstance { get; }
    public static IGenericTypeInstanceReference GenericTypeInstanceReference { get; }
    public static IGenericTypeParameter GenericTypeParameter { get; }
    public static IMethodDefinition Method { get; }
    public static IMethodDefinition MethodDefinition { get; }
    public static IMethodBody MethodBody { get; }
    public static IName Name { get; }
    public static IMetadataNamedArgument NamedArgument { get; }
    public static INamedTypeReference NamedTypeReference { get; }
    public static INameTable NameTable { get; }
    public static INestedTypeDefinition NestedType { get; }
    public static INestedTypeDefinition NestedTypeDefinition { get; }
    public static INestedTypeReference NestedTypeReference { get; }
    public static INestedUnitNamespace NestedUnitNamespace { get; }
    public static IPlatformType PlatformType { get; }
    public static IPropertyDefinition Property { get; }
    public static IPropertyDefinition PropertyDefinition { get; }
    public static IRootUnitNamespace RootUnitNamespace { get; }
    public static ITypeDefinition Type { get; }
    public static ITypeDefinition TypeDefinition { get; }
    public static ITypeReference TypeReference { get; }
    public static IUnit Unit { get; }
    public static UnitIdentity UnitIdentity { get; }
    public static IUnitNamespace UnitNamespace { get; }
    public static IUnitNamespaceReference UnitNamespaceReference { get; }
    public static IUnitReference UnitReference { get; }
    public static IUnitSet UnitSet { get; }
    public static IUnitSetNamespace UnitSetNamespace { get; }
    public static IRootUnitSetNamespace RootUnitSetNamespace { get; }
    public static IModule Module { get; }
    public static ModuleIdentity ModuleIdentity { get; }
    public static IMethodReference MethodReference { get; }
    public static Version Version { get; }
    public static ICustomAttribute CustomAttribute { get; }
    public static IFileReference FileReference { get; }
    public static IResource Resource { get; }
    public static IModuleReference ModuleReference { get; }
    public static IAssemblyReference AssemblyReference { get; }
    public static IMarshallingInformation MarshallingInformation { get; }
    public static IParameterTypeInformation ParameterTypeInformation { get; }
    public static INamedTypeDefinition NamedTypeDefinition { get; }
    public static INamespaceDefinition NamespaceDefinition { get; }
    public static INamespaceRootOwner NamespaceRootOwner { get; }
    public static INamespaceTypeDefinition NamespaceTypeDefinition { get; }
    public static INamespaceTypeReference NamespaceTypeReference { get; }
    public static ISectionBlock SectionBlock { get; }
    public static ISecurityAttribute SecurityAttribute { get; }
    public static ISignature Signature { get; }
    public static ISpecializedNestedTypeDefinition SpecializedNestedTypeDefinition { get; }
    public static ISpecializedFieldDefinition SpecializedFieldDefinition { get; }
    public static ISpecializedMethodDefinition SpecializedMethodDefinition { get; }
    public static ISpecializedPropertyDefinition SpecializedPropertyDefinition { get; }
    public static ILocalDefinition LocalVariable { get; }
    public static IFieldReference FieldReference { get; }
    public static IParameterDefinition ParameterDefinition { get; }
    public static IPlatformInvokeInformation PlatformInvokeInformation { get; }
    public static IGlobalMethodDefinition GlobalMethod { get; }
    public static IGlobalFieldDefinition GlobalField { get; }
    public static IOperation Operation { get; }
    public static ILocation Location { get; }
    public static IDocument Document { get; }
    public static IOperationExceptionInformation OperationExceptionInformation { get; }
    public static IInternFactory InternFactory { get; }
    public static IArrayType ArrayType { get; }
    public static ITypeDefinitionMember TypeDefinitionMember { get; }
    public static IAliasForType get_AliasForType();
    public static IAssembly get_Assembly();
    public static AssemblyIdentity get_AssemblyIdentity();
    public static IMetadataHost get_CompilationHostEnvironment();
    public static IMetadataConstant get_Constant();
    public static ICustomModifier get_CustomModifier();
    public static IEventDefinition get_Event();
    public static IEventDefinition get_EventDefinition();
    public static IFieldDefinition get_Field();
    public static IFieldDefinition get_FieldDefinition();
    public static IMetadataExpression get_Expression();
    public static IFunctionPointer get_FunctionPointer();
    public static IGenericMethodParameter get_GenericMethodParameter();
    public static IGenericTypeInstance get_GenericTypeInstance();
    public static IGenericTypeInstanceReference get_GenericTypeInstanceReference();
    public static IGenericTypeParameter get_GenericTypeParameter();
    public static IMethodDefinition get_Method();
    public static IMethodDefinition get_MethodDefinition();
    public static IMethodBody get_MethodBody();
    public static IName get_Name();
    public static IMetadataNamedArgument get_NamedArgument();
    public static INamedTypeReference get_NamedTypeReference();
    public static INameTable get_NameTable();
    public static INestedTypeDefinition get_NestedType();
    public static INestedTypeDefinition get_NestedTypeDefinition();
    public static INestedTypeReference get_NestedTypeReference();
    public static INestedUnitNamespace get_NestedUnitNamespace();
    public static IPlatformType get_PlatformType();
    public static IPropertyDefinition get_Property();
    public static IPropertyDefinition get_PropertyDefinition();
    public static IRootUnitNamespace get_RootUnitNamespace();
    public static ITypeDefinition get_Type();
    public static ITypeDefinition get_TypeDefinition();
    public static ITypeReference get_TypeReference();
    public static IUnit get_Unit();
    public static UnitIdentity get_UnitIdentity();
    public static IUnitNamespace get_UnitNamespace();
    public static IUnitNamespaceReference get_UnitNamespaceReference();
    public static IUnitReference get_UnitReference();
    public static IUnitSet get_UnitSet();
    public static IUnitSetNamespace get_UnitSetNamespace();
    public static IRootUnitSetNamespace get_RootUnitSetNamespace();
    public static IModule get_Module();
    public static ModuleIdentity get_ModuleIdentity();
    public static IMethodReference get_MethodReference();
    public static Version get_Version();
    public static ICustomAttribute get_CustomAttribute();
    public static IFileReference get_FileReference();
    public static IResource get_Resource();
    public static IModuleReference get_ModuleReference();
    public static IAssemblyReference get_AssemblyReference();
    public static IMarshallingInformation get_MarshallingInformation();
    public static IParameterTypeInformation get_ParameterTypeInformation();
    public static INamedTypeDefinition get_NamedTypeDefinition();
    public static INamespaceDefinition get_NamespaceDefinition();
    public static INamespaceRootOwner get_NamespaceRootOwner();
    public static INamespaceTypeDefinition get_NamespaceTypeDefinition();
    public static INamespaceTypeReference get_NamespaceTypeReference();
    public static ISectionBlock get_SectionBlock();
    public static ISecurityAttribute get_SecurityAttribute();
    public static ISignature get_Signature();
    public static ISpecializedNestedTypeDefinition get_SpecializedNestedTypeDefinition();
    public static ISpecializedFieldDefinition get_SpecializedFieldDefinition();
    public static ISpecializedMethodDefinition get_SpecializedMethodDefinition();
    public static ISpecializedPropertyDefinition get_SpecializedPropertyDefinition();
    public static ILocalDefinition get_LocalVariable();
    public static IFieldReference get_FieldReference();
    public static IParameterDefinition get_ParameterDefinition();
    public static IPlatformInvokeInformation get_PlatformInvokeInformation();
    public static IGlobalMethodDefinition get_GlobalMethod();
    public static IGlobalFieldDefinition get_GlobalField();
    public static IOperation get_Operation();
    public static ILocation get_Location();
    public static IDocument get_Document();
    public static IOperationExceptionInformation get_OperationExceptionInformation();
    public static IInternFactory get_InternFactory();
    public static IArrayType get_ArrayType();
    public static ITypeDefinitionMember get_TypeDefinitionMember();
}
internal class Microsoft.Cci.DummyAddressableExpression : object {
    public object Definition { get; }
    public IExpression Instance { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public bool IsPure { get; }
    public sealed virtual object get_Definition();
    public sealed virtual IExpression get_Instance();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsPure();
}
internal class Microsoft.Cci.DummyArrayType : Dummy {
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public ITypeDefinition ResolvedType { get; }
    public UInt32 InternedKey { get; }
    public ITypeReference ElementType { get; }
    public bool IsVector { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual ITypeReference get_ElementType();
    public sealed virtual bool get_IsVector();
    public sealed virtual IEnumerable`1<int> get_LowerBounds();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual IEnumerable`1<ulong> get_Sizes();
}
internal class Microsoft.Cci.DummyAssembly : Dummy {
    public IEnumerable`1<ICustomAttribute> AssemblyAttributes { get; }
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public string Culture { get; }
    public IEnumerable`1<IAliasForType> ExportedTypes { get; }
    public IEnumerable`1<IResourceReference> Resources { get; }
    public IEnumerable`1<IFileReference> Files { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public IEnumerable`1<IModule> MemberModules { get; }
    public UInt32 Flags { get; }
    public bool ContainsForeignTypes { get; }
    public IEnumerable`1<byte> PublicKey { get; }
    public Version Version { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public IName ModuleName { get; }
    public IAssembly ContainingAssembly { get; }
    public IEnumerable`1<IAssemblyReference> AssemblyReferences { get; }
    public ulong BaseAddress { get; }
    public string DebugInformationLocation { get; }
    public string DebugInformationVersion { get; }
    public ushort DllCharacteristics { get; }
    public IMethodReference EntryPoint { get; }
    public UInt32 FileAlignment { get; }
    public bool ILOnly { get; }
    public bool StrongNameSigned { get; }
    public bool Prefers32bits { get; }
    public ModuleKind Kind { get; }
    public byte LinkerMajorVersion { get; }
    public byte LinkerMinorVersion { get; }
    public byte MetadataFormatMajorVersion { get; }
    public byte MetadataFormatMinorVersion { get; }
    public IEnumerable`1<ICustomAttribute> ModuleAttributes { get; }
    public IEnumerable`1<IModuleReference> ModuleReferences { get; }
    public Guid PersistentIdentifier { get; }
    public Machine Machine { get; }
    public bool RequiresAmdInstructionSet { get; }
    public bool RequiresStartupStub { get; }
    public bool Requires32bits { get; }
    public bool Requires64bits { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfHeapCommit { get; }
    public ulong SizeOfStackReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ushort SubsystemMajorVersion { get; }
    public ushort SubsystemMinorVersion { get; }
    public string TargetRuntimeVersion { get; }
    public bool TrackDebugData { get; }
    public bool UsePublicKeyTokensForAssemblyReferences { get; }
    public IEnumerable`1<IWin32Resource> Win32Resources { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IPlatformType PlatformType { get; }
    public string Location { get; }
    public IEnumerable`1<IPESection> UninterpretedSections { get; }
    public IName Name { get; }
    public IRootUnitNamespace UnitNamespaceRoot { get; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public UnitIdentity UnitIdentity { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public IUnit ResolvedUnit { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public IEnumerable`1<IName> Aliases { get; }
    public bool IsRetargetable { get; }
    public IAssembly ResolvedAssembly { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public sealed virtual IEnumerable`1<ICustomAttribute> get_AssemblyAttributes();
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual string get_Culture();
    public sealed virtual IEnumerable`1<IAliasForType> get_ExportedTypes();
    public sealed virtual IEnumerable`1<IResourceReference> get_Resources();
    public sealed virtual IEnumerable`1<IFileReference> get_Files();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual IEnumerable`1<IModule> get_MemberModules();
    public sealed virtual UInt32 get_Flags();
    public sealed virtual bool get_ContainsForeignTypes();
    public sealed virtual IEnumerable`1<byte> get_PublicKey();
    public sealed virtual Version get_Version();
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public sealed virtual IName get_ModuleName();
    public sealed virtual IAssembly get_ContainingAssembly();
    public sealed virtual IEnumerable`1<IAssemblyReference> get_AssemblyReferences();
    public sealed virtual ulong get_BaseAddress();
    public sealed virtual string get_DebugInformationLocation();
    public sealed virtual string get_DebugInformationVersion();
    public sealed virtual ushort get_DllCharacteristics();
    public sealed virtual IMethodReference get_EntryPoint();
    public sealed virtual UInt32 get_FileAlignment();
    public sealed virtual bool get_ILOnly();
    public sealed virtual bool get_StrongNameSigned();
    public sealed virtual bool get_Prefers32bits();
    public sealed virtual ModuleKind get_Kind();
    public sealed virtual byte get_LinkerMajorVersion();
    public sealed virtual byte get_LinkerMinorVersion();
    public sealed virtual byte get_MetadataFormatMajorVersion();
    public sealed virtual byte get_MetadataFormatMinorVersion();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ModuleAttributes();
    public sealed virtual IEnumerable`1<IModuleReference> get_ModuleReferences();
    public sealed virtual Guid get_PersistentIdentifier();
    public sealed virtual Machine get_Machine();
    public sealed virtual bool get_RequiresAmdInstructionSet();
    public sealed virtual bool get_RequiresStartupStub();
    public sealed virtual bool get_Requires32bits();
    public sealed virtual bool get_Requires64bits();
    public sealed virtual ulong get_SizeOfHeapReserve();
    public sealed virtual ulong get_SizeOfHeapCommit();
    public sealed virtual ulong get_SizeOfStackReserve();
    public sealed virtual ulong get_SizeOfStackCommit();
    public sealed virtual ushort get_SubsystemMajorVersion();
    public sealed virtual ushort get_SubsystemMinorVersion();
    public sealed virtual string get_TargetRuntimeVersion();
    public sealed virtual bool get_TrackDebugData();
    public sealed virtual bool get_UsePublicKeyTokensForAssemblyReferences();
    public sealed virtual IEnumerable`1<IWin32Resource> get_Win32Resources();
    public sealed virtual IEnumerable`1<string> GetStrings();
    public sealed virtual IEnumerable`1<INamedTypeDefinition> GetAllTypes();
    public sealed virtual IEnumerable`1<IGenericMethodInstanceReference> GetGenericMethodInstances();
    public sealed virtual IEnumerable`1<ITypeReference> GetStructuralTypeInstances();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetStructuralTypeInstanceMembers();
    public sealed virtual IEnumerable`1<ITypeReference> GetTypeReferences();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetTypeMemberReferences();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual string get_Location();
    public sealed virtual IEnumerable`1<IPESection> get_UninterpretedSections();
    public sealed virtual IName get_Name();
    public sealed virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public sealed virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual IEnumerable`1<IName> get_Aliases();
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual IAssembly get_ResolvedAssembly();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public sealed virtual IEnumerable`1<byte> get_PublicKeyToken();
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
}
internal class Microsoft.Cci.DummyAssemblyReference : Dummy {
    public IEnumerable`1<IName> Aliases { get; }
    public string Culture { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public IEnumerable`1<byte> PublicKey { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public Version Version { get; }
    public IName Name { get; }
    public IAssembly ResolvedAssembly { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public bool IsRetargetable { get; }
    public bool ContainsForeignTypes { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IAssemblyReference ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public UnitIdentity UnitIdentity { get; }
    public IUnit ResolvedUnit { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IName> get_Aliases();
    public sealed virtual string get_Culture();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public sealed virtual IEnumerable`1<byte> get_PublicKey();
    public sealed virtual IEnumerable`1<byte> get_PublicKeyToken();
    public sealed virtual Version get_Version();
    public sealed virtual IName get_Name();
    public sealed virtual IAssembly get_ResolvedAssembly();
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual bool get_ContainsForeignTypes();
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.DummyAssignment : object {
    public IExpression Source { get; }
    public ITargetExpression Target { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public bool IsPure { get; }
    public sealed virtual IExpression get_Source();
    public sealed virtual ITargetExpression get_Target();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsPure();
}
internal class Microsoft.Cci.DummyBlock : object {
    public IEnumerable`1<IStatement> Statements { get; }
    public bool UseCheckedArithmetic { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IStatement> get_Statements();
    public sealed virtual bool get_UseCheckedArithmetic();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
}
internal class Microsoft.Cci.DummyCompilation : object {
    public IPlatformType PlatformType { get; }
    public IUnit Result { get; }
    public IUnitSet UnitSet { get; }
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual bool Contains(ISourceDocument sourceDocument);
    public sealed virtual IUnitSet GetUnitSetFor(IName unitSetName);
    public sealed virtual IUnit get_Result();
    public sealed virtual IUnitSet get_UnitSet();
}
internal class Microsoft.Cci.DummyCompileTimeConstant : object {
    public bool IsPure { get; }
    public object Value { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public bool get_IsPure();
    public sealed virtual object get_Value();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.DummyCreateArray : object {
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IExpression> Initializers { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<IExpression> Sizes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public bool IsPure { get; }
    public sealed virtual ITypeReference get_ElementType();
    public sealed virtual IEnumerable`1<IExpression> get_Initializers();
    public sealed virtual IEnumerable`1<int> get_LowerBounds();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual IEnumerable`1<IExpression> get_Sizes();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsPure();
}
internal class Microsoft.Cci.DummyCustomAttribute : Dummy {
    public IEnumerable`1<IMetadataExpression> Arguments { get; }
    public IMethodReference Constructor { get; }
    public IEnumerable`1<IMetadataNamedArgument> NamedArguments { get; }
    public ushort NumberOfNamedArguments { get; }
    public ITypeReference Type { get; }
    public sealed virtual IEnumerable`1<IMetadataExpression> get_Arguments();
    public sealed virtual IMethodReference get_Constructor();
    public sealed virtual IEnumerable`1<IMetadataNamedArgument> get_NamedArguments();
    public sealed virtual ushort get_NumberOfNamedArguments();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.DummyCustomModifier : Dummy {
    public bool IsOptional { get; }
    public ITypeReference Modifier { get; }
    public sealed virtual bool get_IsOptional();
    public sealed virtual ITypeReference get_Modifier();
}
internal class Microsoft.Cci.DummyDocument : Dummy {
    public string Location { get; }
    public IName Name { get; }
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.DummyEventDefinition : Dummy {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMethodReference Adder { get; }
    public IMethodReference Caller { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMethodReference Remover { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMethodReference get_Adder();
    public sealed virtual IMethodReference get_Caller();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual IMethodReference get_Remover();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
}
internal class Microsoft.Cci.DummyExpression : object {
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public bool IsPure { get; }
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsPure();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
}
internal class Microsoft.Cci.DummyFieldDefinition : Dummy {
    public UInt32 BitLength { get; }
    public bool IsBitField { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public ISectionBlock FieldMapping { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public UInt32 InternedKey { get; }
    public bool IsStatic { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual UInt32 get_BitLength();
    public sealed virtual bool get_IsBitField();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual ISectionBlock get_FieldMapping();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual int get_SequenceNumber();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IMetadataConstant get_Constant();
}
internal class Microsoft.Cci.DummyFieldReference : Dummy {
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public UInt32 InternedKey { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public ITypeReference Type { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.DummyFileReference : Dummy {
    public IAssembly ContainingAssembly { get; }
    public bool HasMetadata { get; }
    public IName FileName { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public sealed virtual IAssembly get_ContainingAssembly();
    public sealed virtual bool get_HasMetadata();
    public sealed virtual IName get_FileName();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
}
internal class Microsoft.Cci.DummyFunctionPointerType : Dummy {
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraArgumentTypes { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraArgumentTypes();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
}
internal class Microsoft.Cci.DummyGenericMethodParameter : Dummy {
    public IMethodDefinition DefiningMethod { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public ushort Index { get; }
    public IName Name { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public sealed virtual IMethodDefinition get_DefiningMethod();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual ushort get_Index();
    public sealed virtual IName get_Name();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.DummyGenericTypeInstance : Dummy {
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public INamedTypeReference GenericType { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsSealed { get; }
    public bool IsReferenceType { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public sealed virtual INamedTypeReference get_GenericType();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
}
internal class Microsoft.Cci.DummyGenericTypeParameter : Dummy {
    public ITypeDefinition DefiningType { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public ushort Index { get; }
    public IName Name { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public sealed virtual ITypeDefinition get_DefiningType();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual ushort get_Index();
    public sealed virtual IName get_Name();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.DummyGlobalFieldDefinition : Dummy {
    public IName Name { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public UInt32 BitLength { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsBitField { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public ISectionBlock FieldMapping { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    private ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Container { get; }
    private IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.ContainingScope { get; }
    public UInt32 InternedKey { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual IName get_Name();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual UInt32 get_BitLength();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsBitField();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ISectionBlock get_FieldMapping();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual int get_SequenceNumber();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Container();
    private sealed virtual override IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.get_ContainingScope();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IMetadataConstant get_Constant();
}
internal class Microsoft.Cci.DummyGlobalMethodDefinition : Dummy {
    public bool ReturnValueIsByRef { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsModified { get; }
    public IName Name { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public bool AcceptsExtraArguments { get; }
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsConstructor { get; }
    public bool IsStaticConstructor { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public CallingConvention CallingConvention { get; }
    public bool PreserveSignature { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    private ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Container { get; }
    private IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.ContainingScope { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public UInt32 InternedKey { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual IName get_Name();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual IMethodBody get_Body();
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public sealed virtual IName get_ReturnValueName();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Container();
    private sealed virtual override IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.get_ContainingScope();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
internal class Microsoft.Cci.DummyGotoStatement : object {
    public ILabeledStatement TargetStatement { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ILabeledStatement get_TargetStatement();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.DummyInternFactory : Dummy {
    public sealed virtual UInt32 GetAssemblyInternedKey(AssemblyIdentity assemblyIdentity);
    public sealed virtual UInt32 GetModuleInternedKey(ModuleIdentity moduleIdentity);
    public sealed virtual UInt32 GetFieldInternedKey(IFieldReference fieldReference);
    public sealed virtual UInt32 GetMethodInternedKey(IMethodReference methodReference);
    public sealed virtual UInt32 GetVectorTypeReferenceInternedKey(ITypeReference elementTypeReference);
    public sealed virtual UInt32 GetMatrixTypeReferenceInternedKey(ITypeReference elementTypeReference, int rank, IEnumerable`1<ulong> sizes, IEnumerable`1<int> lowerBounds);
    public sealed virtual UInt32 GetGenericTypeInstanceReferenceInternedKey(ITypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    public sealed virtual UInt32 GetPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    public sealed virtual UInt32 GetManagedPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    public sealed virtual UInt32 GetFunctionPointerTypeReferenceInternedKey(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    public sealed virtual UInt32 GetTypeReferenceInternedKey(ITypeReference typeReference);
    public sealed virtual UInt32 GetNamespaceTypeReferenceInternedKey(IUnitNamespaceReference containingUnitNamespace, IName typeName, UInt32 genericParameterCount);
    public sealed virtual UInt32 GetNestedTypeReferenceInternedKey(ITypeReference containingTypeReference, IName typeName, UInt32 genericParameterCount);
    public sealed virtual UInt32 GetGenericTypeParameterReferenceInternedKey(ITypeReference definingTypeReference, int index);
    public sealed virtual UInt32 GetModifiedTypeReferenceInternedKey(ITypeReference typeReference, IEnumerable`1<ICustomModifier> customModifiers);
    public sealed virtual UInt32 GetGenericMethodParameterReferenceInternedKey(IMethodReference definingMethodReference, int index);
}
internal class Microsoft.Cci.DummyLabeledStatement : object {
    public IName Label { get; }
    public IStatement Statement { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IName get_Label();
    public sealed virtual IStatement get_Statement();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.DummyLocalVariable : Dummy {
    public IMetadataConstant CompileTimeValue { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.DummyLocation : Dummy {
    public IDocument Document { get; }
    public sealed virtual IDocument get_Document();
}
internal class Microsoft.Cci.DummyMarshallingInformation : Dummy {
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public UInt32 IidParameterIndex { get; }
    public UnmanagedType UnmanagedType { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UnmanagedType get_UnmanagedType();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.Cci.DummyMetadataConstant : Dummy {
    public object Value { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public sealed virtual object get_Value();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.DummyMetadataExpression : Dummy {
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public void DispatchAsReference(IMetadataVisitor visitor);
}
internal class Microsoft.Cci.DummyMetadataHost : Dummy {
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Errors;
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public AssemblyIdentity SystemCoreAssemblySymbolicIdentity { get; }
    public INameTable NameTable { get; }
    public IPlatformType PlatformType { get; }
    public byte PointerSize { get; }
    public IEnumerable`1<IUnit> LoadedUnits { get; }
    public IInternFactory InternFactory { get; }
    public bool PreserveILLocations { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_Errors(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Errors(EventHandler`1<ErrorEventArgs> value);
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_SystemCoreAssemblySymbolicIdentity();
    public sealed virtual IAssembly FindAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule FindModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit FindUnit(UnitIdentity unitIdentity);
    public sealed virtual IAssembly LoadAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule LoadModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit LoadUnit(UnitIdentity unitIdentity);
    public sealed virtual IUnit LoadUnitFrom(string location);
    public sealed virtual INameTable get_NameTable();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual byte get_PointerSize();
    public sealed virtual void ReportErrors(ErrorEventArgs errorEventArguments);
    public sealed virtual void ReportError(IErrorMessage error);
    public sealed virtual AssemblyIdentity ProbeAssemblyReference(IUnit unit, AssemblyIdentity referedAssemblyIdentity);
    public sealed virtual ModuleIdentity ProbeModuleReference(IUnit unit, ModuleIdentity referedModuleIdentity);
    public sealed virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual AssemblyIdentity UnifyAssembly(IAssemblyReference assemblyReference);
    public sealed virtual IEnumerable`1<IUnit> get_LoadedUnits();
    public sealed virtual IInternFactory get_InternFactory();
    public sealed virtual bool get_PreserveILLocations();
}
internal class Microsoft.Cci.DummyMethodBody : Dummy {
    public IMethodDefinition MethodDefinition { get; }
    public IEnumerable`1<ILocalDefinition> LocalVariables { get; }
    public bool LocalsAreZeroed { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public IEnumerable`1<ITypeDefinition> PrivateHelperTypes { get; }
    public ushort MaxStack { get; }
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public UInt32 Size { get; }
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual IEnumerable`1<ILocalDefinition> get_LocalVariables();
    public sealed virtual bool get_LocalsAreZeroed();
    public sealed virtual IEnumerable`1<IOperation> get_Operations();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_PrivateHelperTypes();
    public sealed virtual ushort get_MaxStack();
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public sealed virtual UInt32 get_Size();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public void DispatchAsReference(IMetadataVisitor visitor);
}
internal class Microsoft.Cci.DummyMethodCall : object {
    public IEnumerable`1<IExpression> Arguments { get; }
    public bool IsJumpCall { get; }
    public bool IsVirtualCall { get; }
    public bool IsStaticCall { get; }
    public bool IsTailCall { get; }
    public IMethodReference MethodToCall { get; }
    public IExpression ThisArgument { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public bool IsPure { get; }
    public sealed virtual IEnumerable`1<IExpression> get_Arguments();
    public sealed virtual bool get_IsJumpCall();
    public sealed virtual bool get_IsVirtualCall();
    public sealed virtual bool get_IsStaticCall();
    public sealed virtual bool get_IsTailCall();
    public sealed virtual IMethodReference get_MethodToCall();
    public sealed virtual IExpression get_ThisArgument();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsPure();
}
internal class Microsoft.Cci.DummyMethodDefinition : Dummy {
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsConstructor { get; }
    public bool IsStaticConstructor { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public CallingConvention CallingConvention { get; }
    public bool PreserveSignature { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsModified { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public bool ReturnValueIsByRef { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public bool AcceptsExtraArguments { get; }
    public UInt32 InternedKey { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual IMethodBody get_Body();
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public sealed virtual IName get_ReturnValueName();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
internal class Microsoft.Cci.DummyMethodReference : Dummy {
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.DummyModule : Dummy {
    public IName ModuleName { get; }
    public IAssembly ContainingAssembly { get; }
    public IEnumerable`1<IAssemblyReference> AssemblyReferences { get; }
    public ulong BaseAddress { get; }
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public string DebugInformationLocation { get; }
    public string DebugInformationVersion { get; }
    public ushort DllCharacteristics { get; }
    public IMethodReference EntryPoint { get; }
    public UInt32 FileAlignment { get; }
    public bool ILOnly { get; }
    public bool StrongNameSigned { get; }
    public bool Prefers32bits { get; }
    public ModuleKind Kind { get; }
    public byte LinkerMajorVersion { get; }
    public byte LinkerMinorVersion { get; }
    public byte MetadataFormatMajorVersion { get; }
    public byte MetadataFormatMinorVersion { get; }
    public IEnumerable`1<ICustomAttribute> ModuleAttributes { get; }
    public IEnumerable`1<IModuleReference> ModuleReferences { get; }
    public Guid PersistentIdentifier { get; }
    public Machine Machine { get; }
    public bool RequiresAmdInstructionSet { get; }
    public bool RequiresStartupStub { get; }
    public bool Requires32bits { get; }
    public bool Requires64bits { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfHeapCommit { get; }
    public ulong SizeOfStackReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ushort SubsystemMajorVersion { get; }
    public ushort SubsystemMinorVersion { get; }
    public string TargetRuntimeVersion { get; }
    public bool TrackDebugData { get; }
    public bool UsePublicKeyTokensForAssemblyReferences { get; }
    public IEnumerable`1<IWin32Resource> Win32Resources { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IPlatformType PlatformType { get; }
    public string Location { get; }
    public IEnumerable`1<IPESection> UninterpretedSections { get; }
    public IName Name { get; }
    public IRootUnitNamespace UnitNamespaceRoot { get; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public UnitIdentity UnitIdentity { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public IUnit ResolvedUnit { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public sealed virtual IName get_ModuleName();
    public sealed virtual IAssembly get_ContainingAssembly();
    public sealed virtual IEnumerable`1<IAssemblyReference> get_AssemblyReferences();
    public sealed virtual ulong get_BaseAddress();
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual string get_DebugInformationLocation();
    public sealed virtual string get_DebugInformationVersion();
    public sealed virtual ushort get_DllCharacteristics();
    public sealed virtual IMethodReference get_EntryPoint();
    public sealed virtual UInt32 get_FileAlignment();
    public sealed virtual bool get_ILOnly();
    public sealed virtual bool get_StrongNameSigned();
    public sealed virtual bool get_Prefers32bits();
    public sealed virtual ModuleKind get_Kind();
    public sealed virtual byte get_LinkerMajorVersion();
    public sealed virtual byte get_LinkerMinorVersion();
    public sealed virtual byte get_MetadataFormatMajorVersion();
    public sealed virtual byte get_MetadataFormatMinorVersion();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ModuleAttributes();
    public sealed virtual IEnumerable`1<IModuleReference> get_ModuleReferences();
    public sealed virtual Guid get_PersistentIdentifier();
    public sealed virtual Machine get_Machine();
    public sealed virtual bool get_RequiresAmdInstructionSet();
    public sealed virtual bool get_RequiresStartupStub();
    public sealed virtual bool get_Requires32bits();
    public sealed virtual bool get_Requires64bits();
    public sealed virtual ulong get_SizeOfHeapReserve();
    public sealed virtual ulong get_SizeOfHeapCommit();
    public sealed virtual ulong get_SizeOfStackReserve();
    public sealed virtual ulong get_SizeOfStackCommit();
    public sealed virtual ushort get_SubsystemMajorVersion();
    public sealed virtual ushort get_SubsystemMinorVersion();
    public sealed virtual string get_TargetRuntimeVersion();
    public sealed virtual bool get_TrackDebugData();
    public sealed virtual bool get_UsePublicKeyTokensForAssemblyReferences();
    public sealed virtual IEnumerable`1<IWin32Resource> get_Win32Resources();
    public sealed virtual IEnumerable`1<string> GetStrings();
    public sealed virtual IEnumerable`1<INamedTypeDefinition> GetAllTypes();
    public sealed virtual IEnumerable`1<IGenericMethodInstanceReference> GetGenericMethodInstances();
    public sealed virtual IEnumerable`1<ITypeReference> GetStructuralTypeInstances();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetStructuralTypeInstanceMembers();
    public sealed virtual IEnumerable`1<ITypeReference> GetTypeReferences();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetTypeMemberReferences();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual string get_Location();
    public sealed virtual IEnumerable`1<IPESection> get_UninterpretedSections();
    public sealed virtual IName get_Name();
    public sealed virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public sealed virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
}
internal class Microsoft.Cci.DummyModuleReference : Dummy {
    public IName Name { get; }
    public IAssemblyReference ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public IUnit ResolvedUnit { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public UnitIdentity UnitIdentity { get; }
    public sealed virtual IName get_Name();
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual UnitIdentity get_UnitIdentity();
}
internal class Microsoft.Cci.DummyName : Dummy {
    public int UniqueKey { get; }
    public int UniqueKeyIgnoringCase { get; }
    public string Value { get; }
    public sealed virtual int get_UniqueKey();
    public sealed virtual int get_UniqueKeyIgnoringCase();
    public sealed virtual string get_Value();
}
internal class Microsoft.Cci.DummyNamedArgument : Dummy {
    public IName ArgumentName { get; }
    public IMetadataExpression ArgumentValue { get; }
    public bool IsField { get; }
    public object ResolvedDefinition { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public sealed virtual IName get_ArgumentName();
    public sealed virtual IMetadataExpression get_ArgumentValue();
    public sealed virtual bool get_IsField();
    public sealed virtual object get_ResolvedDefinition();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.DummyNamespaceAliasForType : Dummy {
    public INamedTypeReference AliasedType { get; }
    public IEnumerable`1<IAliasMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public bool IsPublic { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IName Name { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public sealed virtual INamedTypeReference get_AliasedType();
    public sealed virtual IEnumerable`1<IAliasMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(IAliasMember member);
    public sealed virtual IEnumerable`1<IAliasMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<IAliasMember, bool> predicate);
    public sealed virtual IEnumerable`1<IAliasMember> GetMatchingMembers(Function`2<IAliasMember, bool> predicate);
    public sealed virtual IEnumerable`1<IAliasMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_IsPublic();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
}
internal class Microsoft.Cci.DummyNamespaceTypeDefinition : Dummy {
    public IUnitNamespace ContainingUnitNamespace { get; }
    public bool IsPublic { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IName Name { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.ContainingUnitNamespace { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public bool IsForeignObject { get; }
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public sealed virtual bool get_IsPublic();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.get_ContainingUnitNamespace();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
    public sealed virtual IEnumerable`1<ICustomAttribute> AttributesFor(ITypeReference implementedInterface);
    public sealed virtual bool get_IsForeignObject();
}
internal class Microsoft.Cci.DummyNamespaceTypeReference : Dummy {
    public ushort GenericParameterCount { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.DummyNameTable : Dummy {
    public IName Address { get; }
    public IName AllowMultiple { get; }
    public IName BeginInvoke { get; }
    public IName BoolOpBool { get; }
    public IName DecimalOpDecimal { get; }
    public IName DelegateOpDelegate { get; }
    public IName Cctor { get; }
    public IName Ctor { get; }
    public IName EmptyName { get; }
    public IName EndInvoke { get; }
    public IName EnumOpEnum { get; }
    public IName EnumOpNum { get; }
    public IName Equals { get; }
    public IName Float32OpFloat32 { get; }
    public IName Float64OpFloat64 { get; }
    public IName Get { get; }
    public IName global { get; }
    public IName HasValue { get; }
    public IName Inherited { get; }
    public IName Invoke { get; }
    public IName Int16OpInt16 { get; }
    public IName Int32OpInt32 { get; }
    public IName Int32OpUInt32 { get; }
    public IName Int64OpInt32 { get; }
    public IName Int64OpUInt32 { get; }
    public IName Int64OpUInt64 { get; }
    public IName Int64OpInt64 { get; }
    public IName Int8OpInt8 { get; }
    public IName NullCoalescing { get; }
    public IName NumOpEnum { get; }
    public IName ObjectOpObject { get; }
    public IName ObjectOpString { get; }
    public IName OpAddition { get; }
    public IName OpBoolean { get; }
    public IName OpChar { get; }
    public IName OpDecimal { get; }
    public IName OpEnum { get; }
    public IName OpEquality { get; }
    public IName OpInequality { get; }
    public IName OpInt8 { get; }
    public IName OpInt16 { get; }
    public IName OpInt32 { get; }
    public IName OpInt64 { get; }
    public IName OpBitwiseAnd { get; }
    public IName OpBitwiseOr { get; }
    public IName OpComma { get; }
    public IName OpConcatentation { get; }
    public IName OpDivision { get; }
    public IName OpExclusiveOr { get; }
    public IName OpExplicit { get; }
    public IName OpExponentiation { get; }
    public IName OpFalse { get; }
    public IName OpFloat32 { get; }
    public IName OpFloat64 { get; }
    public IName OpGreaterThan { get; }
    public IName OpGreaterThanOrEqual { get; }
    public IName OpImplicit { get; }
    public IName OpIntegerDivision { get; }
    public IName OpLeftShift { get; }
    public IName OpLessThan { get; }
    public IName OpLessThanOrEqual { get; }
    public IName OpLike { get; }
    public IName OpLogicalNot { get; }
    public IName OpLogicalOr { get; }
    public IName OpModulus { get; }
    public IName OpMultiply { get; }
    public IName OpOnesComplement { get; }
    public IName OpDecrement { get; }
    public IName OpIncrement { get; }
    public IName OpRightShift { get; }
    public IName OpSubtraction { get; }
    public IName OpTrue { get; }
    public IName OpUInt8 { get; }
    public IName OpUInt16 { get; }
    public IName OpUInt32 { get; }
    public IName OpUInt64 { get; }
    public IName OpUnaryNegation { get; }
    public IName OpUnaryPlus { get; }
    public IName StringOpObject { get; }
    public IName StringOpString { get; }
    public IName value { get; }
    public IName UIntPtrOpUIntPtr { get; }
    public IName UInt32OpInt32 { get; }
    public IName UInt32OpUInt32 { get; }
    public IName UInt64OpInt32 { get; }
    public IName UInt64OpUInt32 { get; }
    public IName UInt64OpUInt64 { get; }
    public IName System { get; }
    public IName Void { get; }
    public IName VoidPtrOpVoidPtr { get; }
    public IName Boolean { get; }
    public IName Char { get; }
    public IName Byte { get; }
    public IName SByte { get; }
    public IName Int16 { get; }
    public IName UInt16 { get; }
    public IName Int32 { get; }
    public IName UInt32 { get; }
    public IName Int64 { get; }
    public IName UInt64 { get; }
    public IName String { get; }
    public IName IntPtr { get; }
    public IName UIntPtr { get; }
    public IName Object { get; }
    public IName Set { get; }
    public IName Single { get; }
    public IName Double { get; }
    public IName TypedReference { get; }
    public IName Enum { get; }
    public IName MulticastDelegate { get; }
    public IName ValueType { get; }
    public IName Type { get; }
    public IName Array { get; }
    public IName AttributeUsageAttribute { get; }
    public IName Attribute { get; }
    public IName Combine { get; }
    public IName Concat { get; }
    public IName DateTime { get; }
    public IName DebuggerHiddenAttribute { get; }
    public IName Decimal { get; }
    public IName Delegate { get; }
    public IName Diagnostics { get; }
    public IName DBNull { get; }
    public IName Length { get; }
    public IName LongLength { get; }
    public IName Nullable { get; }
    public IName Remove { get; }
    public IName Result { get; }
    public sealed virtual IName get_Address();
    public sealed virtual IName get_AllowMultiple();
    public sealed virtual IName get_BeginInvoke();
    public sealed virtual IName get_BoolOpBool();
    public sealed virtual IName get_DecimalOpDecimal();
    public sealed virtual IName get_DelegateOpDelegate();
    public sealed virtual IName get_Cctor();
    public sealed virtual IName get_Ctor();
    public sealed virtual IName get_EmptyName();
    public sealed virtual IName get_EndInvoke();
    public sealed virtual IName get_EnumOpEnum();
    public sealed virtual IName get_EnumOpNum();
    public sealed virtual IName get_Equals();
    public sealed virtual IName get_Float32OpFloat32();
    public sealed virtual IName get_Float64OpFloat64();
    public sealed virtual IName get_Get();
    public sealed virtual IName GetNameFor(string name);
    public sealed virtual IName get_global();
    public sealed virtual IName get_HasValue();
    public sealed virtual IName get_Inherited();
    public sealed virtual IName get_Invoke();
    public sealed virtual IName get_Int16OpInt16();
    public sealed virtual IName get_Int32OpInt32();
    public sealed virtual IName get_Int32OpUInt32();
    public sealed virtual IName get_Int64OpInt32();
    public sealed virtual IName get_Int64OpUInt32();
    public sealed virtual IName get_Int64OpUInt64();
    public sealed virtual IName get_Int64OpInt64();
    public sealed virtual IName get_Int8OpInt8();
    public sealed virtual IName get_NullCoalescing();
    public sealed virtual IName get_NumOpEnum();
    public sealed virtual IName get_ObjectOpObject();
    public sealed virtual IName get_ObjectOpString();
    public sealed virtual IName get_OpAddition();
    public sealed virtual IName get_OpBoolean();
    public sealed virtual IName get_OpChar();
    public sealed virtual IName get_OpDecimal();
    public sealed virtual IName get_OpEnum();
    public sealed virtual IName get_OpEquality();
    public sealed virtual IName get_OpInequality();
    public sealed virtual IName get_OpInt8();
    public sealed virtual IName get_OpInt16();
    public sealed virtual IName get_OpInt32();
    public sealed virtual IName get_OpInt64();
    public sealed virtual IName get_OpBitwiseAnd();
    public sealed virtual IName get_OpBitwiseOr();
    public sealed virtual IName get_OpComma();
    public sealed virtual IName get_OpConcatentation();
    public sealed virtual IName get_OpDivision();
    public sealed virtual IName get_OpExclusiveOr();
    public sealed virtual IName get_OpExplicit();
    public sealed virtual IName get_OpExponentiation();
    public sealed virtual IName get_OpFalse();
    public sealed virtual IName get_OpFloat32();
    public sealed virtual IName get_OpFloat64();
    public sealed virtual IName get_OpGreaterThan();
    public sealed virtual IName get_OpGreaterThanOrEqual();
    public sealed virtual IName get_OpImplicit();
    public sealed virtual IName get_OpIntegerDivision();
    public sealed virtual IName get_OpLeftShift();
    public sealed virtual IName get_OpLessThan();
    public sealed virtual IName get_OpLessThanOrEqual();
    public sealed virtual IName get_OpLike();
    public sealed virtual IName get_OpLogicalNot();
    public sealed virtual IName get_OpLogicalOr();
    public sealed virtual IName get_OpModulus();
    public sealed virtual IName get_OpMultiply();
    public sealed virtual IName get_OpOnesComplement();
    public sealed virtual IName get_OpDecrement();
    public sealed virtual IName get_OpIncrement();
    public sealed virtual IName get_OpRightShift();
    public sealed virtual IName get_OpSubtraction();
    public sealed virtual IName get_OpTrue();
    public sealed virtual IName get_OpUInt8();
    public sealed virtual IName get_OpUInt16();
    public sealed virtual IName get_OpUInt32();
    public sealed virtual IName get_OpUInt64();
    public sealed virtual IName get_OpUnaryNegation();
    public sealed virtual IName get_OpUnaryPlus();
    public sealed virtual IName get_StringOpObject();
    public sealed virtual IName get_StringOpString();
    public sealed virtual IName get_value();
    public sealed virtual IName get_UIntPtrOpUIntPtr();
    public sealed virtual IName get_UInt32OpInt32();
    public sealed virtual IName get_UInt32OpUInt32();
    public sealed virtual IName get_UInt64OpInt32();
    public sealed virtual IName get_UInt64OpUInt32();
    public sealed virtual IName get_UInt64OpUInt64();
    public sealed virtual IName get_System();
    public sealed virtual IName get_Void();
    public sealed virtual IName get_VoidPtrOpVoidPtr();
    public sealed virtual IName get_Boolean();
    public sealed virtual IName get_Char();
    public sealed virtual IName get_Byte();
    public sealed virtual IName get_SByte();
    public sealed virtual IName get_Int16();
    public sealed virtual IName get_UInt16();
    public sealed virtual IName get_Int32();
    public sealed virtual IName get_UInt32();
    public sealed virtual IName get_Int64();
    public sealed virtual IName get_UInt64();
    public sealed virtual IName get_String();
    public sealed virtual IName get_IntPtr();
    public sealed virtual IName get_UIntPtr();
    public sealed virtual IName get_Object();
    public sealed virtual IName get_Set();
    public sealed virtual IName get_Single();
    public sealed virtual IName get_Double();
    public sealed virtual IName get_TypedReference();
    public sealed virtual IName get_Enum();
    public sealed virtual IName get_MulticastDelegate();
    public sealed virtual IName get_ValueType();
    public sealed virtual IName get_Type();
    public sealed virtual IName get_Array();
    public sealed virtual IName get_AttributeUsageAttribute();
    public sealed virtual IName get_Attribute();
    public sealed virtual IName get_Combine();
    public sealed virtual IName get_Concat();
    public sealed virtual IName get_DateTime();
    public sealed virtual IName get_DebuggerHiddenAttribute();
    public sealed virtual IName get_Decimal();
    public sealed virtual IName get_Delegate();
    public sealed virtual IName get_Diagnostics();
    public sealed virtual IName get_DBNull();
    public sealed virtual IName get_Length();
    public sealed virtual IName get_LongLength();
    public sealed virtual IName get_Nullable();
    public sealed virtual IName get_Remove();
    public sealed virtual IName get_Result();
}
internal class Microsoft.Cci.DummyNestedType : Dummy {
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public bool DoesNotInheritGenericParameters { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private ITypeReference Microsoft.Cci.ITypeMemberReference.ContainingType { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual bool get_DoesNotInheritGenericParameters();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.get_ContainingType();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.DummyNestedTypeReference : Dummy {
    public ushort GenericParameterCount { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
internal class Microsoft.Cci.DummyNestedUnitNamespace : Dummy {
    public IEnumerable`1<ILocation> Locations { get; }
    public IUnit Unit { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IName Name { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IUnitNamespace ContainingUnitNamespace { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    private IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IUnit get_Unit();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.get_ContainingUnitNamespace();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
}
internal class Microsoft.Cci.DummyNestedUnitNamespaceReference : Dummy {
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public IUnitReference Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public sealed virtual IUnitReference get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.DummyOperation : Dummy {
    public OperationCode OperationCode { get; }
    public UInt32 Offset { get; }
    public ILocation Location { get; }
    public object Value { get; }
    public sealed virtual OperationCode get_OperationCode();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ILocation get_Location();
    public sealed virtual object get_Value();
}
internal class Microsoft.Cci.DummyOperationExceptionInformation : Dummy {
    public HandlerKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public UInt32 TryStartOffset { get; }
    public UInt32 TryEndOffset { get; }
    public UInt32 FilterDecisionStartOffset { get; }
    public UInt32 HandlerStartOffset { get; }
    public UInt32 HandlerEndOffset { get; }
    public sealed virtual HandlerKind get_HandlerKind();
    public sealed virtual ITypeReference get_ExceptionType();
    public sealed virtual UInt32 get_TryStartOffset();
    public sealed virtual UInt32 get_TryEndOffset();
    public sealed virtual UInt32 get_FilterDecisionStartOffset();
    public sealed virtual UInt32 get_HandlerStartOffset();
    public sealed virtual UInt32 get_HandlerEndOffset();
}
internal class Microsoft.Cci.DummyParameterDefinition : Dummy {
    public ISignature ContainingSignature { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference ParamArrayElementType { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IName Name { get; }
    public ushort Index { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ITypeReference get_ParamArrayElementType();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IMetadataConstant get_Constant();
}
internal class Microsoft.Cci.DummyParameterTypeInformation : Dummy {
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    public ushort Index { get; }
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ushort get_Index();
}
internal class Microsoft.Cci.DummyPlatformInvokeInformation : Dummy {
    public IName ImportName { get; }
    public IModuleReference ImportModule { get; }
    public StringFormatKind StringFormat { get; }
    public bool NoMangle { get; }
    public bool SupportsLastError { get; }
    public PInvokeCallingConvention PInvokeCallingConvention { get; }
    public Nullable`1<bool> UseBestFit { get; }
    public Nullable`1<bool> ThrowExceptionForUnmappableChar { get; }
    public sealed virtual IName get_ImportName();
    public sealed virtual IModuleReference get_ImportModule();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_NoMangle();
    public sealed virtual bool get_SupportsLastError();
    public sealed virtual PInvokeCallingConvention get_PInvokeCallingConvention();
    public sealed virtual Nullable`1<bool> get_UseBestFit();
    public sealed virtual Nullable`1<bool> get_ThrowExceptionForUnmappableChar();
}
internal class Microsoft.Cci.DummyPlatformType : Dummy {
    public INamespaceTypeReference SystemDiagnosticsContractsContract { get; }
    public byte PointerSize { get; }
    public INamespaceTypeReference SystemArgIterator { get; }
    public INamespaceTypeReference SystemArray { get; }
    public INamespaceTypeReference SystemAttribute { get; }
    public INamespaceTypeReference SystemAttributeUsageAttribute { get; }
    public INamespaceTypeReference SystemAsyncCallback { get; }
    public INamespaceTypeReference SystemBoolean { get; }
    public INamespaceTypeReference SystemChar { get; }
    public INamespaceTypeReference SystemCollectionsGenericDictionary { get; }
    public INamespaceTypeReference SystemCollectionsGenericICollection { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsGenericIList { get; }
    public INamespaceTypeReference SystemCollectionsICollection { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsIList { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralComparable { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralEquatable { get; }
    public INamespaceTypeReference SystemContextStaticAttribute { get; }
    public INamespaceTypeReference SystemIAsyncResult { get; }
    public INamespaceTypeReference SystemICloneable { get; }
    public INamespaceTypeReference SystemDateTime { get; }
    public INamespaceTypeReference SystemDateTimeOffset { get; }
    public INamespaceTypeReference SystemDecimal { get; }
    public INamespaceTypeReference SystemDelegate { get; }
    public INamespaceTypeReference SystemDBNull { get; }
    public INamespaceTypeReference SystemEnum { get; }
    public INamespaceTypeReference SystemException { get; }
    public INamespaceTypeReference SystemFloat32 { get; }
    public INamespaceTypeReference SystemFloat64 { get; }
    public INamespaceTypeReference SystemGlobalizationCultureInfo { get; }
    public INamespaceTypeReference SystemInt16 { get; }
    public INamespaceTypeReference SystemInt32 { get; }
    public INamespaceTypeReference SystemInt64 { get; }
    public INamespaceTypeReference SystemInt8 { get; }
    public INamespaceTypeReference SystemIntPtr { get; }
    public INamespaceTypeReference SystemMulticastDelegate { get; }
    public INamespaceTypeReference SystemNullable { get; }
    public INamespaceTypeReference SystemObject { get; }
    public INamespaceTypeReference SystemReflectionAssemblySignatureKeyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeArgumentHandle { get; }
    public INamespaceTypeReference SystemRuntimeFieldHandle { get; }
    public INamespaceTypeReference SystemRuntimeMethodHandle { get; }
    public INamespaceTypeReference SystemRuntimeTypeHandle { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCallConvCdecl { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCompilerGeneratedAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesExtensionAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesInternalsVisibleToAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsConst { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsVolatile { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesReferenceAssemblyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeInteropServicesDllImportAttribute { get; }
    public INamespaceTypeReference SystemSecurityPermissionsSecurityAction { get; }
    public INamespaceTypeReference SystemSecuritySecurityCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySecuritySafeCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySuppressUnmanagedCodeSecurityAttribute { get; }
    public INamespaceTypeReference SystemString { get; }
    public INamespaceTypeReference SystemThreadStaticAttribute { get; }
    public INamespaceTypeReference SystemType { get; }
    public INamespaceTypeReference SystemTypedReference { get; }
    public INamespaceTypeReference SystemUInt16 { get; }
    public INamespaceTypeReference SystemUInt32 { get; }
    public INamespaceTypeReference SystemUInt64 { get; }
    public INamespaceTypeReference SystemUInt8 { get; }
    public INamespaceTypeReference SystemUIntPtr { get; }
    public INamespaceTypeReference SystemValueType { get; }
    public INamespaceTypeReference SystemVoid { get; }
    public sealed virtual INamespaceTypeReference get_SystemDiagnosticsContractsContract();
    public sealed virtual byte get_PointerSize();
    public sealed virtual INamespaceTypeReference get_SystemArgIterator();
    public sealed virtual INamespaceTypeReference get_SystemArray();
    public sealed virtual INamespaceTypeReference get_SystemAttribute();
    public sealed virtual INamespaceTypeReference get_SystemAttributeUsageAttribute();
    public sealed virtual INamespaceTypeReference get_SystemAsyncCallback();
    public sealed virtual INamespaceTypeReference get_SystemBoolean();
    public sealed virtual INamespaceTypeReference get_SystemChar();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericDictionary();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericICollection();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerator();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIList();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsICollection();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIEnumerable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIEnumerator();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIList();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIStructuralComparable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIStructuralEquatable();
    public sealed virtual INamespaceTypeReference get_SystemContextStaticAttribute();
    public sealed virtual INamespaceTypeReference get_SystemIAsyncResult();
    public sealed virtual INamespaceTypeReference get_SystemICloneable();
    public sealed virtual INamespaceTypeReference get_SystemDateTime();
    public sealed virtual INamespaceTypeReference get_SystemDateTimeOffset();
    public sealed virtual INamespaceTypeReference get_SystemDecimal();
    public sealed virtual INamespaceTypeReference get_SystemDelegate();
    public sealed virtual INamespaceTypeReference get_SystemDBNull();
    public sealed virtual INamespaceTypeReference get_SystemEnum();
    public sealed virtual INamespaceTypeReference get_SystemException();
    public sealed virtual INamespaceTypeReference get_SystemFloat32();
    public sealed virtual INamespaceTypeReference get_SystemFloat64();
    public sealed virtual INamespaceTypeReference get_SystemGlobalizationCultureInfo();
    public sealed virtual INamespaceTypeReference get_SystemInt16();
    public sealed virtual INamespaceTypeReference get_SystemInt32();
    public sealed virtual INamespaceTypeReference get_SystemInt64();
    public sealed virtual INamespaceTypeReference get_SystemInt8();
    public sealed virtual INamespaceTypeReference get_SystemIntPtr();
    public sealed virtual INamespaceTypeReference get_SystemMulticastDelegate();
    public sealed virtual INamespaceTypeReference get_SystemNullable();
    public sealed virtual INamespaceTypeReference get_SystemObject();
    public sealed virtual INamespaceTypeReference get_SystemReflectionAssemblySignatureKeyAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeArgumentHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeFieldHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeMethodHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeTypeHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCallConvCdecl();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCompilerGeneratedAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesExtensionAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesInternalsVisibleToAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsConst();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsVolatile();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesReferenceAssemblyAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeInteropServicesDllImportAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecurityPermissionsSecurityAction();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySecurityCriticalAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySecuritySafeCriticalAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySuppressUnmanagedCodeSecurityAttribute();
    public sealed virtual INamespaceTypeReference get_SystemString();
    public sealed virtual INamespaceTypeReference get_SystemThreadStaticAttribute();
    public sealed virtual INamespaceTypeReference get_SystemType();
    public sealed virtual INamespaceTypeReference get_SystemTypedReference();
    public sealed virtual INamespaceTypeReference get_SystemUInt16();
    public sealed virtual INamespaceTypeReference get_SystemUInt32();
    public sealed virtual INamespaceTypeReference get_SystemUInt64();
    public sealed virtual INamespaceTypeReference get_SystemUInt8();
    public sealed virtual INamespaceTypeReference get_SystemUIntPtr();
    public sealed virtual INamespaceTypeReference get_SystemValueType();
    public sealed virtual INamespaceTypeReference get_SystemVoid();
    public sealed virtual INamespaceTypeReference GetTypeFor(PrimitiveTypeCode typeCode);
}
internal class Microsoft.Cci.DummyPrimarySourceDocument : object {
    private Guid Microsoft.Cci.IPrimarySourceDocument.DocumentType { get; }
    private Guid Microsoft.Cci.IPrimarySourceDocument.Language { get; }
    private Guid Microsoft.Cci.IPrimarySourceDocument.LanguageVendor { get; }
    private Guid Microsoft.Cci.IPrimarySourceDocument.ChecksumAlgorithm { get; }
    private Byte[] Microsoft.Cci.IPrimarySourceDocument.Checksum { get; }
    private IPrimarySourceLocation Microsoft.Cci.IPrimarySourceDocument.PrimarySourceLocation { get; }
    private int Microsoft.Cci.ISourceDocument.Length { get; }
    private string Microsoft.Cci.ISourceDocument.SourceLanguage { get; }
    private ISourceLocation Microsoft.Cci.ISourceDocument.SourceLocation { get; }
    private string Microsoft.Cci.IDocument.Location { get; }
    private IName Microsoft.Cci.IDocument.Name { get; }
    private sealed virtual override Guid Microsoft.Cci.IPrimarySourceDocument.get_DocumentType();
    private sealed virtual override Guid Microsoft.Cci.IPrimarySourceDocument.get_Language();
    private sealed virtual override Guid Microsoft.Cci.IPrimarySourceDocument.get_LanguageVendor();
    private sealed virtual override Guid Microsoft.Cci.IPrimarySourceDocument.get_ChecksumAlgorithm();
    private sealed virtual override Byte[] Microsoft.Cci.IPrimarySourceDocument.get_Checksum();
    private sealed virtual override IPrimarySourceLocation Microsoft.Cci.IPrimarySourceDocument.get_PrimarySourceLocation();
    private sealed virtual override IPrimarySourceLocation Microsoft.Cci.IPrimarySourceDocument.GetPrimarySourceLocation(int position, int length);
    private sealed virtual override void Microsoft.Cci.IPrimarySourceDocument.ToLineColumn(int position, Int32& line, Int32& column);
    private sealed virtual override int Microsoft.Cci.ISourceDocument.CopyTo(int position, Char[] destination, int destinationOffset, int length);
    private sealed virtual override ISourceLocation Microsoft.Cci.ISourceDocument.GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    private sealed virtual override ISourceLocation Microsoft.Cci.ISourceDocument.GetSourceLocation(int position, int length);
    private sealed virtual override string Microsoft.Cci.ISourceDocument.GetText();
    private sealed virtual override bool Microsoft.Cci.ISourceDocument.IsUpdatedVersionOf(ISourceDocument sourceDocument);
    private sealed virtual override int Microsoft.Cci.ISourceDocument.get_Length();
    private sealed virtual override string Microsoft.Cci.ISourceDocument.get_SourceLanguage();
    private sealed virtual override ISourceLocation Microsoft.Cci.ISourceDocument.get_SourceLocation();
    private sealed virtual override string Microsoft.Cci.IDocument.get_Location();
    private sealed virtual override IName Microsoft.Cci.IDocument.get_Name();
}
internal class Microsoft.Cci.DummyPrimarySourceLocation : object {
    private int Microsoft.Cci.IPrimarySourceLocation.EndColumn { get; }
    private int Microsoft.Cci.IPrimarySourceLocation.EndLine { get; }
    private IPrimarySourceDocument Microsoft.Cci.IPrimarySourceLocation.PrimarySourceDocument { get; }
    private int Microsoft.Cci.IPrimarySourceLocation.StartColumn { get; }
    private int Microsoft.Cci.IPrimarySourceLocation.StartLine { get; }
    private int Microsoft.Cci.ISourceLocation.EndIndex { get; }
    private int Microsoft.Cci.ISourceLocation.Length { get; }
    private ISourceDocument Microsoft.Cci.ISourceLocation.SourceDocument { get; }
    private string Microsoft.Cci.ISourceLocation.Source { get; }
    private int Microsoft.Cci.ISourceLocation.StartIndex { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    private sealed virtual override int Microsoft.Cci.IPrimarySourceLocation.get_EndColumn();
    private sealed virtual override int Microsoft.Cci.IPrimarySourceLocation.get_EndLine();
    private sealed virtual override IPrimarySourceDocument Microsoft.Cci.IPrimarySourceLocation.get_PrimarySourceDocument();
    private sealed virtual override int Microsoft.Cci.IPrimarySourceLocation.get_StartColumn();
    private sealed virtual override int Microsoft.Cci.IPrimarySourceLocation.get_StartLine();
    private sealed virtual override bool Microsoft.Cci.ISourceLocation.Contains(ISourceLocation location);
    private sealed virtual override int Microsoft.Cci.ISourceLocation.CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_EndIndex();
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_Length();
    private sealed virtual override ISourceDocument Microsoft.Cci.ISourceLocation.get_SourceDocument();
    private sealed virtual override string Microsoft.Cci.ISourceLocation.get_Source();
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_StartIndex();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
internal class Microsoft.Cci.DummyPropertyDefinition : Dummy {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodReference Setter { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public CallingConvention CallingConvention { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual IMethodReference get_Getter();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodReference get_Setter();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IMetadataConstant get_Constant();
}
internal class Microsoft.Cci.DummyResource : Dummy {
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<byte> Data { get; }
    public IAssemblyReference DefiningAssembly { get; }
    public bool IsInExternalFile { get; }
    public IFileReference ExternalFile { get; }
    public bool IsPublic { get; }
    public IName Name { get; }
    public IResource Resource { get; }
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<byte> get_Data();
    public sealed virtual IAssemblyReference get_DefiningAssembly();
    public sealed virtual bool get_IsInExternalFile();
    public sealed virtual IFileReference get_ExternalFile();
    public sealed virtual bool get_IsPublic();
    public sealed virtual IName get_Name();
    public sealed virtual IResource get_Resource();
}
internal class Microsoft.Cci.DummyRootUnitNamespace : Dummy {
    public IEnumerable`1<ILocation> Locations { get; }
    public IUnit Unit { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IName Name { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IUnit get_Unit();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
}
internal class Microsoft.Cci.DummyRootUnitSetNamespace : Dummy {
    public IUnitSet UnitSet { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IUnitSet get_UnitSet();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
}
internal class Microsoft.Cci.DummySectionBlock : Dummy {
    public PESectionKind PESectionKind { get; }
    public UInt32 Offset { get; }
    public UInt32 Size { get; }
    public IEnumerable`1<byte> Data { get; }
    public sealed virtual PESectionKind get_PESectionKind();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Size();
    public sealed virtual IEnumerable`1<byte> get_Data();
}
internal class Microsoft.Cci.DummySecurityAttribute : Dummy {
    public SecurityAction Action { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public sealed virtual SecurityAction get_Action();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
}
internal class Microsoft.Cci.DummySourceDocument : object {
    public string Location { get; }
    public int Length { get; }
    public IName Name { get; }
    public string SourceLanguage { get; }
    public ISourceLocation SourceLocation { get; }
    public sealed virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public sealed virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public sealed virtual ISourceLocation GetSourceLocation(int position, int length);
    public sealed virtual string GetText();
    public sealed virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public sealed virtual string get_Location();
    public sealed virtual int get_Length();
    public sealed virtual IName get_Name();
    public sealed virtual string get_SourceLanguage();
    public sealed virtual ISourceLocation get_SourceLocation();
}
internal class Microsoft.Cci.DummySourceDocumentEdit : object {
    public ISourceLocation SourceLocationBeforeEdit { get; }
    public ISourceDocument SourceDocumentAfterEdit { get; }
    public sealed virtual ISourceLocation get_SourceLocationBeforeEdit();
    public sealed virtual ISourceDocument get_SourceDocumentAfterEdit();
}
internal class Microsoft.Cci.DummySourceLocation : object {
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public IDocument Document { get; }
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual ISourceDocument get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    public sealed virtual IDocument get_Document();
}
internal class Microsoft.Cci.DummySpecializedFieldDefinition : Dummy {
    public UInt32 BitLength { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsBitField { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public ISectionBlock FieldMapping { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public IFieldDefinition UnspecializedVersion { get; }
    private IFieldReference Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion { get; }
    public UInt32 InternedKey { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual UInt32 get_BitLength();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsBitField();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ISectionBlock get_FieldMapping();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual int get_SequenceNumber();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual IFieldDefinition get_UnspecializedVersion();
    private sealed virtual override IFieldReference Microsoft.Cci.ISpecializedFieldReference.get_UnspecializedVersion();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IMetadataConstant get_Constant();
}
internal class Microsoft.Cci.DummySpecializedMethodDefinition : Dummy {
    public IMethodDefinition UnspecializedVersion { get; }
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    public bool AcceptsExtraArguments { get; }
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsConstructor { get; }
    public bool IsStaticConstructor { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public CallingConvention CallingConvention { get; }
    public bool PreserveSignature { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsModified { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public bool ReturnValueIsByRef { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public UInt32 InternedKey { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual IMethodDefinition get_UnspecializedVersion();
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual IMethodBody get_Body();
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public sealed virtual IName get_ReturnValueName();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
internal class Microsoft.Cci.DummySpecializedNestedTypeDefinition : Dummy {
    public INestedTypeDefinition UnspecializedVersion { get; }
    private INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public bool DoesNotInheritGenericParameters { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private ITypeReference Microsoft.Cci.ITypeMemberReference.ContainingType { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public sealed virtual INestedTypeDefinition get_UnspecializedVersion();
    private sealed virtual override INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.get_UnspecializedVersion();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual bool get_DoesNotInheritGenericParameters();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.get_ContainingType();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.DummySpecializedPropertyDefinition : Dummy {
    public IPropertyDefinition UnspecializedVersion { get; }
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodReference Setter { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public CallingConvention CallingConvention { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual IPropertyDefinition get_UnspecializedVersion();
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual IMethodReference get_Getter();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodReference get_Setter();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IMetadataConstant get_Constant();
}
internal class Microsoft.Cci.DummySwitchCase : object {
    public IEnumerable`1<IStatement> Body { get; }
    public ICompileTimeConstant Expression { get; }
    public bool IsDefault { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IStatement> get_Body();
    public sealed virtual ICompileTimeConstant get_Expression();
    public sealed virtual bool get_IsDefault();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.DummySwitchStatement : object {
    public IEnumerable`1<ISwitchCase> Cases { get; }
    public IExpression Expression { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<ISwitchCase> get_Cases();
    public sealed virtual IExpression get_Expression();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.DummyTargetExpression : object {
    public byte Alignment { get; }
    public object Definition { get; }
    public IExpression Instance { get; }
    public bool GetterIsVirtual { get; }
    public bool SetterIsVirtual { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    public bool IsPure { get; }
    public sealed virtual byte get_Alignment();
    public sealed virtual object get_Definition();
    public sealed virtual IExpression get_Instance();
    public sealed virtual bool get_GetterIsVirtual();
    public sealed virtual bool get_SetterIsVirtual();
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsPure();
}
internal class Microsoft.Cci.DummyUnitSet : Dummy {
    public IEnumerable`1<IUnit> Units { get; }
    public IUnitSetNamespace UnitSetNamespaceRoot { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public sealed virtual bool Contains(IUnit unit);
    public sealed virtual IEnumerable`1<IUnit> get_Units();
    public sealed virtual IUnitSetNamespace get_UnitSetNamespaceRoot();
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
}
public class Microsoft.Cci.EditDescriptor : object {
    private IDefinition affectedDefinition;
    private EditEventKind kind;
    private ISourceDocument modifiedSourceDocument;
    private IDefinition modifiedParent;
    private ISourceDocument originalSourceDocument;
    private IDefinition originalParent;
    public IDefinition AffectedDefinition { get; }
    public EditEventKind Kind { get; }
    public ISourceDocument ModifiedSourceDocument { get; }
    public IDefinition ModifiedParent { get; }
    public ISourceDocument OriginalSourceDocument { get; }
    public IDefinition OriginalParent { get; }
    public EditDescriptor(EditEventKind kind, IDefinition affectedDefinition, IDefinition modifiedParent, IDefinition originalParent, ISourceDocument modifiedSourceDocument, ISourceDocument originalSourceDocument);
    private void ObjectInvariant();
    public sealed virtual IDefinition get_AffectedDefinition();
    public sealed virtual EditEventKind get_Kind();
    public sealed virtual ISourceDocument get_ModifiedSourceDocument();
    public sealed virtual IDefinition get_ModifiedParent();
    public sealed virtual ISourceDocument get_OriginalSourceDocument();
    public sealed virtual IDefinition get_OriginalParent();
}
public class Microsoft.Cci.EditEventArgs : EventArgs {
    private IEnumerable`1<IEditDescriptor> edits;
    public IEnumerable`1<IEditDescriptor> Edits { get; }
    public EditEventArgs(IEnumerable`1<IEditDescriptor> edits);
    private void ObjectInvariant();
    public IEnumerable`1<IEditDescriptor> get_Edits();
}
public enum Microsoft.Cci.EditEventKind : Enum {
    public int value__;
    public static EditEventKind Addition;
    public static EditEventKind Deletion;
    public static EditEventKind Modification;
}
public static class Microsoft.Cci.Enumerable`1 : object {
    private static IEnumerable`1<T> empty;
    public static IEnumerable`1<T> Empty { get; }
    private static Enumerable`1();
    public static IEnumerable`1<T> get_Empty();
}
internal class Microsoft.Cci.EnumerableAdapter`1 : ValueType {
    private IEnumerator`1<T> m_enum;
    private IReadOnlyList`1<T> m_list;
    private int m_pos;
    public T Current { get; }
    public EnumerableAdapter`1(IEnumerable`1<T> en);
    public T get_Current();
    public bool MoveNext();
    public void Dispose();
    public EnumerableAdapter`1<T> GetEnumerator();
}
public class Microsoft.Cci.ErrorEventArgs : EventArgs {
    private object errorReporter;
    private ILocation location;
    private IEnumerable`1<IErrorMessage> errors;
    public object ErrorReporter { get; }
    public ILocation Location { get; }
    public IEnumerable`1<IErrorMessage> Errors { get; }
    public ErrorEventArgs(object errorReporter, ILocation location, IEnumerable`1<IErrorMessage> errors);
    private void ObjectInvariant();
    public object get_ErrorReporter();
    public ILocation get_Location();
    public IEnumerable`1<IErrorMessage> get_Errors();
}
[DebuggerDisplayAttribute("Message = {Message}")]
public abstract class Microsoft.Cci.ErrorMessage : object {
    private static IEnumerable`1<ILocation> EmptyLocations;
    private long errorCode;
    private String[] messageArguments;
    private string messageKey;
    private IEnumerable`1<ILocation> relatedLocations;
    private ISourceLocation sourceLocation;
    public object ErrorReporter { get; }
    public string ErrorReporterIdentifier { get; }
    public long Code { get; }
    public bool IsWarning { get; }
    public string Message { get; }
    protected string MessageKey { get; }
    public IEnumerable`1<ILocation> RelatedLocations { get; }
    public ISourceLocation SourceLocation { get; }
    private ILocation Microsoft.Cci.IErrorMessage.Location { get; }
    protected ErrorMessage(ISourceLocation sourceLocation, long errorCode, string messageKey, String[] messageArguments);
    protected ErrorMessage(ISourceLocation sourceLocation, long errorCode, string messageKey, IEnumerable`1<ILocation> relatedLocations, String[] messageArguments);
    private static ErrorMessage();
    private void ObjectInvariant();
    public abstract virtual object get_ErrorReporter();
    public abstract virtual string get_ErrorReporterIdentifier();
    public sealed virtual long get_Code();
    protected string GetMessage(ResourceManager rm);
    public virtual bool get_IsWarning();
    public abstract virtual ISourceErrorMessage MakeShallowCopy(ISourceDocument targetDocument);
    public abstract virtual string get_Message();
    protected String[] MessageArguments();
    protected string get_MessageKey();
    public sealed virtual IEnumerable`1<ILocation> get_RelatedLocations();
    public sealed virtual ISourceLocation get_SourceLocation();
    private sealed virtual override ILocation Microsoft.Cci.IErrorMessage.get_Location();
}
public static class Microsoft.Cci.ExpressionHelper : object {
    public static bool IsFiniteNumeric(ICompileTimeConstant constExpression);
    public static bool IsIntegerInRangeOf(ICompileTimeConstant constExpression, ITypeReference targetType);
    public static bool IsIntegralMinusOne(IExpression expression);
    public static bool IsIntegralMinusOne(ICompileTimeConstant constExpression);
    public static bool IsIntegralNonzero(IExpression expression);
    public static bool IsIntegralNonzero(ICompileTimeConstant constExpression);
    public static bool IsIntegralOne(IExpression expression);
    public static bool IsIntegralOne(ICompileTimeConstant constExpression);
    public static bool IsNumericOne(ICompileTimeConstant constExpression);
    public static bool IsIntegralZero(IExpression expression);
    public static bool IsIntegralZero(ICompileTimeConstant constExpression);
    public static bool IsNumericZero(ICompileTimeConstant constExpression);
    public static bool IsNullLiteral(IExpression expression);
    public static bool IsZeroIntPtr(IExpression expression);
}
public class Microsoft.Cci.Function`2 : MulticastDelegate {
    public Function`2(object object, IntPtr method);
    public virtual R Invoke(P p);
    public virtual IAsyncResult BeginInvoke(P p, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
public class Microsoft.Cci.Function`3 : MulticastDelegate {
    public Function`3(object object, IntPtr method);
    public virtual R Invoke(P p, Q q);
    public virtual IAsyncResult BeginInvoke(P p, Q q, AsyncCallback callback, object object);
    public virtual R EndInvoke(IAsyncResult result);
}
public class Microsoft.Cci.GeneratorLocal : object {
    private IMetadataConstant compileTimeValue;
    private List`1<ICustomModifier> customModifiers;
    private bool isCompilerGenerated;
    private bool isModified;
    private bool isPinned;
    private bool isReference;
    private IName name;
    private List`1<ILocation> locations;
    private IMethodDefinition methodDefinition;
    private ITypeReference type;
    public IMetadataConstant CompileTimeValue { get; public set; }
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public bool IsCompilerGenerated { get; public set; }
    public bool IsConstant { get; }
    public bool IsModified { get; public set; }
    public bool IsPinned { get; public set; }
    public bool IsReference { get; public set; }
    public IName Name { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public IMethodDefinition MethodDefinition { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ILocalDefinition.CustomModifiers { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private void ObjectInvariant();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public void set_CompileTimeValue(IMetadataConstant value);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public bool get_IsCompilerGenerated();
    public void set_IsCompilerGenerated(bool value);
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public void set_IsModified(bool value);
    public sealed virtual bool get_IsPinned();
    public void set_IsPinned(bool value);
    public sealed virtual bool get_IsReference();
    public void set_IsReference(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public void set_MethodDefinition(IMethodDefinition value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ILocalDefinition.get_CustomModifiers();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.GenericMethodParameterInformationComparer : object {
    private bool resolveTypes;
    public GenericMethodParameterInformationComparer(bool resolveTypes);
    public sealed virtual bool Equals(IParameterTypeInformation x, IParameterTypeInformation y);
    public sealed virtual int GetHashCode(IParameterTypeInformation parameterTypeInformation);
}
public static class Microsoft.Cci.GlobalAssemblyCache : object {
    public static bool Contains(Uri codeBaseUri);
    public static string GetLocation(AssemblyIdentity assemblyIdentity, IMetadataHost metadataHost);
}
public static class Microsoft.Cci.GlobalLock : object {
    public static object LockingObject;
    private static GlobalLock();
}
public enum Microsoft.Cci.HandlerKind : Enum {
    public int value__;
    public static HandlerKind Illegal;
    public static HandlerKind Catch;
    public static HandlerKind Filter;
    public static HandlerKind Finally;
    public static HandlerKind Fault;
}
public interface Microsoft.Cci.IAddition {
    public bool CheckOverflow { get; }
    public bool TreatOperandsAsUnsignedIntegers { get; }
    public abstract virtual bool get_CheckOverflow();
    public abstract virtual bool get_TreatOperandsAsUnsignedIntegers();
}
public interface Microsoft.Cci.IAddressableExpression {
    public object Definition { get; }
    public IExpression Instance { get; }
    public abstract virtual object get_Definition();
    public abstract virtual IExpression get_Instance();
}
internal abstract class Microsoft.Cci.IAddressableExpressionContract : object {
    public object Definition { get; }
    public IExpression Instance { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual object get_Definition();
    public sealed virtual IExpression get_Instance();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IAddressDereference {
    public IExpression Address { get; }
    public byte Alignment { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public abstract virtual IExpression get_Address();
    public abstract virtual byte get_Alignment();
    public abstract virtual bool get_IsUnaligned();
    public abstract virtual bool get_IsVolatile();
}
internal abstract class Microsoft.Cci.IAddressDereferenceContract : object {
    public IExpression Address { get; }
    public byte Alignment { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Address();
    public sealed virtual byte get_Alignment();
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IAddressOf {
    public IAddressableExpression Expression { get; }
    public bool ObjectControlsMutability { get; }
    public abstract virtual IAddressableExpression get_Expression();
    public abstract virtual bool get_ObjectControlsMutability();
}
internal abstract class Microsoft.Cci.IAddressOfContract : object {
    public IAddressableExpression Expression { get; }
    public bool ObjectControlsMutability { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IAddressableExpression get_Expression();
    public sealed virtual bool get_ObjectControlsMutability();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IAliasForType {
    public INamedTypeReference AliasedType { get; }
    public IEnumerable`1<IAliasMember> Members { get; }
    public abstract virtual INamedTypeReference get_AliasedType();
    public abstract virtual IEnumerable`1<IAliasMember> get_Members();
}
internal abstract class Microsoft.Cci.IAliasForTypeContract : object {
    public INamedTypeReference AliasedType { get; }
    private IEnumerable`1<IAliasMember> Microsoft.Cci.IAliasForType.Members { get; }
    public IEnumerable`1<IAliasMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual INamedTypeReference get_AliasedType();
    private sealed virtual override IEnumerable`1<IAliasMember> Microsoft.Cci.IAliasForType.get_Members();
    public sealed virtual IEnumerable`1<IAliasMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(IAliasMember member);
    public sealed virtual IEnumerable`1<IAliasMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<IAliasMember, bool> predicate);
    public sealed virtual IEnumerable`1<IAliasMember> GetMatchingMembers(Function`2<IAliasMember, bool> predicate);
    public sealed virtual IEnumerable`1<IAliasMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IAliasMember {
    public IAliasForType ContainingAlias { get; }
    public TypeMemberVisibility Visibility { get; }
    public abstract virtual IAliasForType get_ContainingAlias();
    public abstract virtual TypeMemberVisibility get_Visibility();
}
public interface Microsoft.Cci.IAnonymousDelegate {
    public IBlockStatement Body { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ITypeReference ReturnType { get; }
    public ITypeReference Type { get; }
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public abstract virtual ITypeReference get_ReturnType();
    public abstract virtual ITypeReference get_Type();
}
public interface Microsoft.Cci.IArrayIndexer {
    public IExpression IndexedObject { get; }
    public IEnumerable`1<IExpression> Indices { get; }
    public abstract virtual IExpression get_IndexedObject();
    public abstract virtual IEnumerable`1<IExpression> get_Indices();
}
internal abstract class Microsoft.Cci.IArrayIndexerContract : object {
    public IExpression IndexedObject { get; }
    public IEnumerable`1<IExpression> Indices { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_IndexedObject();
    public sealed virtual IEnumerable`1<IExpression> get_Indices();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IArrayType {
}
public interface Microsoft.Cci.IArrayTypeReference {
    public ITypeReference ElementType { get; }
    public bool IsVector { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    public abstract virtual ITypeReference get_ElementType();
    public abstract virtual bool get_IsVector();
    public abstract virtual IEnumerable`1<int> get_LowerBounds();
    public abstract virtual UInt32 get_Rank();
    public abstract virtual IEnumerable`1<ulong> get_Sizes();
}
internal abstract class Microsoft.Cci.IArrayTypeReferenceContract : object {
    public ITypeReference ElementType { get; }
    public bool IsVector { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ITypeReference get_ElementType();
    public sealed virtual bool get_IsVector();
    public sealed virtual IEnumerable`1<int> get_LowerBounds();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual IEnumerable`1<ulong> get_Sizes();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IAssembly {
    public IEnumerable`1<ICustomAttribute> AssemblyAttributes { get; }
    public IEnumerable`1<IAliasForType> ExportedTypes { get; }
    public IEnumerable`1<IFileReference> Files { get; }
    public UInt32 Flags { get; }
    public IEnumerable`1<IModule> MemberModules { get; }
    public IEnumerable`1<IResourceReference> Resources { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public abstract virtual IEnumerable`1<ICustomAttribute> get_AssemblyAttributes();
    public abstract virtual IEnumerable`1<IAliasForType> get_ExportedTypes();
    public abstract virtual IEnumerable`1<IFileReference> get_Files();
    public abstract virtual UInt32 get_Flags();
    public abstract virtual IEnumerable`1<IModule> get_MemberModules();
    public abstract virtual IEnumerable`1<IResourceReference> get_Resources();
    public abstract virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
}
internal abstract class Microsoft.Cci.IAssemblyContract : object {
    public IEnumerable`1<ICustomAttribute> AssemblyAttributes { get; }
    public IEnumerable`1<IAliasForType> ExportedTypes { get; }
    public IEnumerable`1<IFileReference> Files { get; }
    public UInt32 Flags { get; }
    public IEnumerable`1<IModule> MemberModules { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public IEnumerable`1<byte> PublicKey { get; }
    public IEnumerable`1<IResourceReference> Resources { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public IEnumerable`1<IAssemblyReference> AssemblyReferences { get; }
    public ulong BaseAddress { get; }
    public IAssembly ContainingAssembly { get; }
    public string DebugInformationLocation { get; }
    public string DebugInformationVersion { get; }
    public ushort DllCharacteristics { get; }
    public IMethodReference EntryPoint { get; }
    public UInt32 FileAlignment { get; }
    public bool ILOnly { get; }
    public bool StrongNameSigned { get; }
    public bool Prefers32bits { get; }
    public ModuleKind Kind { get; }
    public byte LinkerMajorVersion { get; }
    public byte LinkerMinorVersion { get; }
    public byte MetadataFormatMajorVersion { get; }
    public byte MetadataFormatMinorVersion { get; }
    public IEnumerable`1<ICustomAttribute> ModuleAttributes { get; }
    public IName ModuleName { get; }
    public IEnumerable`1<IModuleReference> ModuleReferences { get; }
    public Guid PersistentIdentifier { get; }
    public Machine Machine { get; }
    public bool RequiresAmdInstructionSet { get; }
    public bool RequiresStartupStub { get; }
    public bool Requires32bits { get; }
    public bool Requires64bits { get; }
    public ulong SizeOfHeapCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfStackReserve { get; }
    public ushort SubsystemMajorVersion { get; }
    public ushort SubsystemMinorVersion { get; }
    public string TargetRuntimeVersion { get; }
    public bool TrackDebugData { get; }
    public bool UsePublicKeyTokensForAssemblyReferences { get; }
    public IEnumerable`1<IWin32Resource> Win32Resources { get; }
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public IPlatformType PlatformType { get; }
    public string Location { get; }
    public IEnumerable`1<IPESection> UninterpretedSections { get; }
    public IRootUnitNamespace UnitNamespaceRoot { get; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IEnumerable`1<IName> Aliases { get; }
    public IAssembly ResolvedAssembly { get; }
    public string Culture { get; }
    public bool IsRetargetable { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public Version Version { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public bool ContainsForeignTypes { get; }
    public sealed virtual IEnumerable`1<ICustomAttribute> get_AssemblyAttributes();
    public sealed virtual IEnumerable`1<IAliasForType> get_ExportedTypes();
    public sealed virtual IEnumerable`1<IFileReference> get_Files();
    public sealed virtual UInt32 get_Flags();
    public sealed virtual IEnumerable`1<IModule> get_MemberModules();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public sealed virtual IEnumerable`1<byte> get_PublicKey();
    public sealed virtual IEnumerable`1<IResourceReference> get_Resources();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual IEnumerable`1<IAssemblyReference> get_AssemblyReferences();
    public sealed virtual ulong get_BaseAddress();
    public sealed virtual IAssembly get_ContainingAssembly();
    public sealed virtual string get_DebugInformationLocation();
    public sealed virtual string get_DebugInformationVersion();
    public sealed virtual ushort get_DllCharacteristics();
    public sealed virtual IMethodReference get_EntryPoint();
    public sealed virtual UInt32 get_FileAlignment();
    public sealed virtual IEnumerable`1<string> GetStrings();
    public sealed virtual IEnumerable`1<INamedTypeDefinition> GetAllTypes();
    public sealed virtual IEnumerable`1<IGenericMethodInstanceReference> GetGenericMethodInstances();
    public sealed virtual IEnumerable`1<ITypeReference> GetStructuralTypeInstances();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetStructuralTypeInstanceMembers();
    public sealed virtual IEnumerable`1<ITypeReference> GetTypeReferences();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetTypeMemberReferences();
    public sealed virtual bool get_ILOnly();
    public sealed virtual bool get_StrongNameSigned();
    public sealed virtual bool get_Prefers32bits();
    public sealed virtual ModuleKind get_Kind();
    public sealed virtual byte get_LinkerMajorVersion();
    public sealed virtual byte get_LinkerMinorVersion();
    public sealed virtual byte get_MetadataFormatMajorVersion();
    public sealed virtual byte get_MetadataFormatMinorVersion();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ModuleAttributes();
    public sealed virtual IName get_ModuleName();
    public sealed virtual IEnumerable`1<IModuleReference> get_ModuleReferences();
    public sealed virtual Guid get_PersistentIdentifier();
    public sealed virtual Machine get_Machine();
    public sealed virtual bool get_RequiresAmdInstructionSet();
    public sealed virtual bool get_RequiresStartupStub();
    public sealed virtual bool get_Requires32bits();
    public sealed virtual bool get_Requires64bits();
    public sealed virtual ulong get_SizeOfHeapCommit();
    public sealed virtual ulong get_SizeOfHeapReserve();
    public sealed virtual ulong get_SizeOfStackCommit();
    public sealed virtual ulong get_SizeOfStackReserve();
    public sealed virtual ushort get_SubsystemMajorVersion();
    public sealed virtual ushort get_SubsystemMinorVersion();
    public sealed virtual string get_TargetRuntimeVersion();
    public sealed virtual bool get_TrackDebugData();
    public sealed virtual bool get_UsePublicKeyTokensForAssemblyReferences();
    public sealed virtual IEnumerable`1<IWin32Resource> get_Win32Resources();
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual string get_Location();
    public sealed virtual IEnumerable`1<IPESection> get_UninterpretedSections();
    public sealed virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public sealed virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IEnumerable`1<IName> get_Aliases();
    public sealed virtual IAssembly get_ResolvedAssembly();
    public sealed virtual string get_Culture();
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual IEnumerable`1<byte> get_PublicKeyToken();
    public sealed virtual Version get_Version();
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_ContainsForeignTypes();
}
public interface Microsoft.Cci.IAssemblyReference {
    public IEnumerable`1<IName> Aliases { get; }
    public IAssembly ResolvedAssembly { get; }
    public string Culture { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public bool IsRetargetable { get; }
    public bool ContainsForeignTypes { get; }
    public IEnumerable`1<byte> PublicKey { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public Version Version { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public abstract virtual IEnumerable`1<IName> get_Aliases();
    public abstract virtual IAssembly get_ResolvedAssembly();
    public abstract virtual string get_Culture();
    public abstract virtual IEnumerable`1<byte> get_HashValue();
    public abstract virtual bool get_IsRetargetable();
    public abstract virtual bool get_ContainsForeignTypes();
    public abstract virtual IEnumerable`1<byte> get_PublicKey();
    public abstract virtual IEnumerable`1<byte> get_PublicKeyToken();
    public abstract virtual Version get_Version();
    public abstract virtual AssemblyIdentity get_AssemblyIdentity();
    public abstract virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
}
internal abstract class Microsoft.Cci.IAssemblyReferenceContract : object {
    public IEnumerable`1<IName> Aliases { get; }
    public IAssembly ResolvedAssembly { get; }
    public string Culture { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public bool IsRetargetable { get; }
    public bool ContainsForeignTypes { get; }
    public IEnumerable`1<byte> PublicKey { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public Version Version { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public IAssemblyReference ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IEnumerable`1<IName> get_Aliases();
    public sealed virtual IAssembly get_ResolvedAssembly();
    public sealed virtual string get_Culture();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual bool get_ContainsForeignTypes();
    public sealed virtual IEnumerable`1<byte> get_PublicKey();
    public sealed virtual IEnumerable`1<byte> get_PublicKeyToken();
    public sealed virtual Version get_Version();
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IAssertStatement {
    public IExpression Condition { get; }
    public IExpression Description { get; }
    public string OriginalSource { get; }
    public bool HasBeenVerified { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IExpression get_Description();
    public abstract virtual string get_OriginalSource();
    public abstract virtual bool get_HasBeenVerified();
}
public interface Microsoft.Cci.IAssignment {
    public IExpression Source { get; }
    public ITargetExpression Target { get; }
    public abstract virtual IExpression get_Source();
    public abstract virtual ITargetExpression get_Target();
}
internal abstract class Microsoft.Cci.IAssignmentContract : object {
    public IExpression Source { get; }
    public ITargetExpression Target { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Source();
    public sealed virtual ITargetExpression get_Target();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IAssumeStatement {
    public IExpression Condition { get; }
    public IExpression Description { get; }
    public string OriginalSource { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IExpression get_Description();
    public abstract virtual string get_OriginalSource();
}
public interface Microsoft.Cci.IBinaryDocument {
    public UInt32 Length { get; }
    public abstract virtual UInt32 get_Length();
}
public interface Microsoft.Cci.IBinaryDocumentMemoryBlock {
    public IBinaryDocument BinaryDocument { get; }
    public Byte* Pointer { get; }
    public UInt32 Length { get; }
    public abstract virtual IBinaryDocument get_BinaryDocument();
    public abstract virtual Byte* get_Pointer();
    public abstract virtual UInt32 get_Length();
}
internal abstract class Microsoft.Cci.IBinaryDocumentMemoryBlockContract : object {
    public IBinaryDocument BinaryDocument { get; }
    public Byte* Pointer { get; }
    public UInt32 Length { get; }
    public sealed virtual IBinaryDocument get_BinaryDocument();
    public sealed virtual Byte* get_Pointer();
    public sealed virtual UInt32 get_Length();
}
public interface Microsoft.Cci.IBinaryLocation {
    public IBinaryDocument BinaryDocument { get; }
    public UInt32 Offset { get; }
    public abstract virtual IBinaryDocument get_BinaryDocument();
    public abstract virtual UInt32 get_Offset();
}
internal abstract class Microsoft.Cci.IBinaryLocationContract : object {
    public IBinaryDocument BinaryDocument { get; }
    public UInt32 Offset { get; }
    public IDocument Document { get; }
    public sealed virtual IBinaryDocument get_BinaryDocument();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IBinaryOperation {
    public IExpression LeftOperand { get; }
    public IExpression RightOperand { get; }
    public bool ResultIsUnmodifiedLeftOperand { get; }
    public abstract virtual IExpression get_LeftOperand();
    public abstract virtual IExpression get_RightOperand();
    public abstract virtual bool get_ResultIsUnmodifiedLeftOperand();
}
internal abstract class Microsoft.Cci.IBinaryOperationContract : object {
    public IExpression LeftOperand { get; }
    public IExpression RightOperand { get; }
    public bool ResultIsUnmodifiedLeftOperand { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_LeftOperand();
    public sealed virtual IExpression get_RightOperand();
    public sealed virtual bool get_ResultIsUnmodifiedLeftOperand();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IBitwiseAnd {
}
public interface Microsoft.Cci.IBitwiseOr {
}
public interface Microsoft.Cci.IBlockExpression {
    public IBlockStatement BlockStatement { get; }
    public IExpression Expression { get; }
    public abstract virtual IBlockStatement get_BlockStatement();
    public abstract virtual IExpression get_Expression();
}
internal abstract class Microsoft.Cci.IBlockExpressionContract : object {
    public IBlockStatement BlockStatement { get; }
    public IExpression Expression { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IBlockStatement get_BlockStatement();
    public sealed virtual IExpression get_Expression();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IBlockStatement {
    public IEnumerable`1<IStatement> Statements { get; }
    public bool UseCheckedArithmetic { get; }
    public abstract virtual IEnumerable`1<IStatement> get_Statements();
    public abstract virtual bool get_UseCheckedArithmetic();
}
public interface Microsoft.Cci.IBoundExpression {
    public byte Alignment { get; }
    public object Definition { get; }
    public IExpression Instance { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public abstract virtual byte get_Alignment();
    public abstract virtual object get_Definition();
    public abstract virtual IExpression get_Instance();
    public abstract virtual bool get_IsUnaligned();
    public abstract virtual bool get_IsVolatile();
}
internal abstract class Microsoft.Cci.IBoundExpressionContract : object {
    public byte Alignment { get; }
    public object Definition { get; }
    public IExpression Instance { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual byte get_Alignment();
    public sealed virtual object get_Definition();
    public sealed virtual IExpression get_Instance();
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IBreakStatement {
}
public interface Microsoft.Cci.ICachingFactory {
    public abstract virtual IGenericTypeInstanceReference GetOrMakeGenericTypeInstanceReference(INamedTypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    public abstract virtual void FlushCache();
}
public interface Microsoft.Cci.ICastIfPossible {
    public IExpression ValueToCast { get; }
    public ITypeReference TargetType { get; }
    public abstract virtual IExpression get_ValueToCast();
    public abstract virtual ITypeReference get_TargetType();
}
internal abstract class Microsoft.Cci.ICastIfPossibleContract : object {
    public IExpression ValueToCast { get; }
    public ITypeReference TargetType { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_ValueToCast();
    public sealed virtual ITypeReference get_TargetType();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICatchClause {
    public IBlockStatement Body { get; }
    public ILocalDefinition ExceptionContainer { get; }
    public ITypeReference ExceptionType { get; }
    public IExpression FilterCondition { get; }
    public abstract virtual IBlockStatement get_Body();
    public abstract virtual ILocalDefinition get_ExceptionContainer();
    public abstract virtual ITypeReference get_ExceptionType();
    public abstract virtual IExpression get_FilterCondition();
}
internal abstract class Microsoft.Cci.ICatchClauseContract : object {
    public IBlockStatement Body { get; }
    public ILocalDefinition ExceptionContainer { get; }
    public ITypeReference ExceptionType { get; }
    public IExpression FilterCondition { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IBlockStatement get_Body();
    public sealed virtual ILocalDefinition get_ExceptionContainer();
    public sealed virtual ITypeReference get_ExceptionType();
    public sealed virtual IExpression get_FilterCondition();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICheckIfInstance {
    public IExpression Operand { get; }
    public ITypeReference TypeToCheck { get; }
    public abstract virtual IExpression get_Operand();
    public abstract virtual ITypeReference get_TypeToCheck();
}
internal abstract class Microsoft.Cci.ICheckIfInstanceContract : object {
    public IExpression Operand { get; }
    public ITypeReference TypeToCheck { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Operand();
    public sealed virtual ITypeReference get_TypeToCheck();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICodeVisitor {
    public abstract virtual void Visit(IAddition addition);
    public abstract virtual void Visit(IAddressableExpression addressableExpression);
    public abstract virtual void Visit(IAddressDereference addressDereference);
    public abstract virtual void Visit(IAddressOf addressOf);
    public abstract virtual void Visit(IAnonymousDelegate anonymousDelegate);
    public abstract virtual void Visit(IArrayIndexer arrayIndexer);
    public abstract virtual void Visit(IAssertStatement assertStatement);
    public abstract virtual void Visit(IAssignment assignment);
    public abstract virtual void Visit(IAssumeStatement assumeStatement);
    public abstract virtual void Visit(IBitwiseAnd bitwiseAnd);
    public abstract virtual void Visit(IBitwiseOr bitwiseOr);
    public abstract virtual void Visit(IBlockExpression blockExpression);
    public abstract virtual void Visit(IBlockStatement block);
    public abstract virtual void Visit(IBreakStatement breakStatement);
    public abstract virtual void Visit(IBoundExpression boundExpression);
    public abstract virtual void Visit(ICastIfPossible castIfPossible);
    public abstract virtual void Visit(ICatchClause catchClause);
    public abstract virtual void Visit(ICheckIfInstance checkIfInstance);
    public abstract virtual void Visit(ICompileTimeConstant constant);
    public abstract virtual void Visit(IConversion conversion);
    public abstract virtual void Visit(IConditional conditional);
    public abstract virtual void Visit(IConditionalStatement conditionalStatement);
    public abstract virtual void Visit(IContinueStatement continueStatement);
    public abstract virtual void Visit(ICopyMemoryStatement copyMemoryStatement);
    public abstract virtual void Visit(ICreateArray createArray);
    public abstract virtual void Visit(ICreateDelegateInstance createDelegateInstance);
    public abstract virtual void Visit(ICreateObjectInstance createObjectInstance);
    public abstract virtual void Visit(IDebuggerBreakStatement debuggerBreakStatement);
    public abstract virtual void Visit(IDefaultValue defaultValue);
    public abstract virtual void Visit(IDivision division);
    public abstract virtual void Visit(IDoUntilStatement doUntilStatement);
    public abstract virtual void Visit(IDupValue dupValue);
    public abstract virtual void Visit(IEmptyStatement emptyStatement);
    public abstract virtual void Visit(IEquality equality);
    public abstract virtual void Visit(IExclusiveOr exclusiveOr);
    public abstract virtual void Visit(IExpressionStatement expressionStatement);
    public abstract virtual void Visit(IFillMemoryStatement fillMemoryStatement);
    public abstract virtual void Visit(IForEachStatement forEachStatement);
    public abstract virtual void Visit(IForStatement forStatement);
    public abstract virtual void Visit(IGotoStatement gotoStatement);
    public abstract virtual void Visit(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public abstract virtual void Visit(IGetTypeOfTypedReference getTypeOfTypedReference);
    public abstract virtual void Visit(IGetValueOfTypedReference getValueOfTypedReference);
    public abstract virtual void Visit(IGreaterThan greaterThan);
    public abstract virtual void Visit(IGreaterThanOrEqual greaterThanOrEqual);
    public abstract virtual void Visit(ILabeledStatement labeledStatement);
    public abstract virtual void Visit(ILeftShift leftShift);
    public abstract virtual void Visit(ILessThan lessThan);
    public abstract virtual void Visit(ILessThanOrEqual lessThanOrEqual);
    public abstract virtual void Visit(ILocalDeclarationStatement localDeclarationStatement);
    public abstract virtual void Visit(ILockStatement lockStatement);
    public abstract virtual void Visit(ILogicalNot logicalNot);
    public abstract virtual void Visit(IMakeTypedReference makeTypedReference);
    public abstract virtual void Visit(IMethodCall methodCall);
    public abstract virtual void Visit(IModulus modulus);
    public abstract virtual void Visit(IMultiplication multiplication);
    public abstract virtual void Visit(INamedArgument namedArgument);
    public abstract virtual void Visit(INotEquality notEquality);
    public abstract virtual void Visit(IOldValue oldValue);
    public abstract virtual void Visit(IOnesComplement onesComplement);
    public abstract virtual void Visit(IOutArgument outArgument);
    public abstract virtual void Visit(IPointerCall pointerCall);
    public abstract virtual void Visit(IPopValue popValue);
    public abstract virtual void Visit(IPushStatement pushStatement);
    public abstract virtual void Visit(IRefArgument refArgument);
    public abstract virtual void Visit(IResourceUseStatement resourceUseStatement);
    public abstract virtual void Visit(IReturnValue returnValue);
    public abstract virtual void Visit(IRethrowStatement rethrowStatement);
    public abstract virtual void Visit(IReturnStatement returnStatement);
    public abstract virtual void Visit(IRightShift rightShift);
    public abstract virtual void Visit(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public abstract virtual void Visit(ISizeOf sizeOf);
    public abstract virtual void Visit(IStackArrayCreate stackArrayCreate);
    public abstract virtual void Visit(ISubtraction subtraction);
    public abstract virtual void Visit(ISwitchCase switchCase);
    public abstract virtual void Visit(ISwitchStatement switchStatement);
    public abstract virtual void Visit(ITargetExpression targetExpression);
    public abstract virtual void Visit(IThisReference thisReference);
    public abstract virtual void Visit(IThrowStatement throwStatement);
    public abstract virtual void Visit(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public abstract virtual void Visit(ITokenOf tokenOf);
    public abstract virtual void Visit(ITypeOf typeOf);
    public abstract virtual void Visit(IUnaryNegation unaryNegation);
    public abstract virtual void Visit(IUnaryPlus unaryPlus);
    public abstract virtual void Visit(IVectorLength vectorLength);
    public abstract virtual void Visit(IWhileDoStatement whileDoStatement);
    public abstract virtual void Visit(IYieldBreakStatement yieldBreakStatement);
    public abstract virtual void Visit(IYieldReturnStatement yieldReturnStatement);
}
internal abstract class Microsoft.Cci.ICodeVisitorContract : object {
    public sealed virtual void Visit(IAddition addition);
    public sealed virtual void Visit(IAddressableExpression addressableExpression);
    public sealed virtual void Visit(IAddressDereference addressDereference);
    public sealed virtual void Visit(IAddressOf addressOf);
    public sealed virtual void Visit(IAnonymousDelegate anonymousDelegate);
    public sealed virtual void Visit(IArrayIndexer arrayIndexer);
    public sealed virtual void Visit(IAssertStatement assertStatement);
    public sealed virtual void Visit(IAssignment assignment);
    public sealed virtual void Visit(IAssumeStatement assumeStatement);
    public sealed virtual void Visit(IBitwiseAnd bitwiseAnd);
    public sealed virtual void Visit(IBitwiseOr bitwiseOr);
    public sealed virtual void Visit(IBlockExpression blockExpression);
    public sealed virtual void Visit(IBlockStatement block);
    public sealed virtual void Visit(IBreakStatement breakStatement);
    public sealed virtual void Visit(IBoundExpression boundExpression);
    public sealed virtual void Visit(ICastIfPossible castIfPossible);
    public sealed virtual void Visit(ICatchClause catchClause);
    public sealed virtual void Visit(ICheckIfInstance checkIfInstance);
    public sealed virtual void Visit(ICompileTimeConstant constant);
    public sealed virtual void Visit(IConversion conversion);
    public sealed virtual void Visit(IConditional conditional);
    public sealed virtual void Visit(IConditionalStatement conditionalStatement);
    public sealed virtual void Visit(IContinueStatement continueStatement);
    public sealed virtual void Visit(ICopyMemoryStatement copyMemoryStatement);
    public sealed virtual void Visit(ICreateArray createArray);
    public sealed virtual void Visit(ICreateDelegateInstance createDelegateInstance);
    public sealed virtual void Visit(ICreateObjectInstance createObjectInstance);
    public sealed virtual void Visit(IDebuggerBreakStatement debuggerBreakStatement);
    public sealed virtual void Visit(IDefaultValue defaultValue);
    public sealed virtual void Visit(IDivision division);
    public sealed virtual void Visit(IDoUntilStatement doUntilStatement);
    public sealed virtual void Visit(IDupValue dupValue);
    public sealed virtual void Visit(IEmptyStatement emptyStatement);
    public sealed virtual void Visit(IEquality equality);
    public sealed virtual void Visit(IExclusiveOr exclusiveOr);
    public sealed virtual void Visit(IExpressionStatement expressionStatement);
    public sealed virtual void Visit(IFillMemoryStatement fillMemoryStatement);
    public sealed virtual void Visit(IForEachStatement forEachStatement);
    public sealed virtual void Visit(IForStatement forStatement);
    public sealed virtual void Visit(IGotoStatement gotoStatement);
    public sealed virtual void Visit(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public sealed virtual void Visit(IGetTypeOfTypedReference getTypeOfTypedReference);
    public sealed virtual void Visit(IGetValueOfTypedReference getValueOfTypedReference);
    public sealed virtual void Visit(IGreaterThan greaterThan);
    public sealed virtual void Visit(IGreaterThanOrEqual greaterThanOrEqual);
    public sealed virtual void Visit(ILabeledStatement labeledStatement);
    public sealed virtual void Visit(ILeftShift leftShift);
    public sealed virtual void Visit(ILessThan lessThan);
    public sealed virtual void Visit(ILessThanOrEqual lessThanOrEqual);
    public sealed virtual void Visit(ILocalDeclarationStatement localDeclarationStatement);
    public sealed virtual void Visit(ILockStatement lockStatement);
    public sealed virtual void Visit(ILogicalNot logicalNot);
    public sealed virtual void Visit(IMakeTypedReference makeTypedReference);
    public sealed virtual void Visit(IMethodCall methodCall);
    public sealed virtual void Visit(IModulus modulus);
    public sealed virtual void Visit(IMultiplication multiplication);
    public sealed virtual void Visit(INamedArgument namedArgument);
    public sealed virtual void Visit(INotEquality notEquality);
    public sealed virtual void Visit(IOldValue oldValue);
    public sealed virtual void Visit(IOnesComplement onesComplement);
    public sealed virtual void Visit(IOutArgument outArgument);
    public sealed virtual void Visit(IPointerCall pointerCall);
    public sealed virtual void Visit(IPopValue popValue);
    public sealed virtual void Visit(IPushStatement pushStatement);
    public sealed virtual void Visit(IRefArgument refArgument);
    public sealed virtual void Visit(IResourceUseStatement resourceUseStatement);
    public sealed virtual void Visit(IReturnValue returnValue);
    public sealed virtual void Visit(IRethrowStatement rethrowStatement);
    public sealed virtual void Visit(IReturnStatement returnStatement);
    public sealed virtual void Visit(IRightShift rightShift);
    public sealed virtual void Visit(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public sealed virtual void Visit(ISizeOf sizeOf);
    public sealed virtual void Visit(IStackArrayCreate stackArrayCreate);
    public sealed virtual void Visit(ISubtraction subtraction);
    public sealed virtual void Visit(ISwitchCase switchCase);
    public sealed virtual void Visit(ISwitchStatement switchStatement);
    public sealed virtual void Visit(ITargetExpression targetExpression);
    public sealed virtual void Visit(IThisReference thisReference);
    public sealed virtual void Visit(IThrowStatement throwStatement);
    public sealed virtual void Visit(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public sealed virtual void Visit(ITokenOf tokenOf);
    public sealed virtual void Visit(ITypeOf typeOf);
    public sealed virtual void Visit(IUnaryNegation unaryNegation);
    public sealed virtual void Visit(IUnaryPlus unaryPlus);
    public sealed virtual void Visit(IVectorLength vectorLength);
    public sealed virtual void Visit(IWhileDoStatement whileDoStatement);
    public sealed virtual void Visit(IYieldBreakStatement yieldBreakStatement);
    public sealed virtual void Visit(IYieldReturnStatement yieldReturnStatement);
    public sealed virtual void Visit(IArrayTypeReference arrayTypeReference);
    public sealed virtual void Visit(IAssembly assembly);
    public sealed virtual void Visit(IAssemblyReference assemblyReference);
    public sealed virtual void Visit(ICustomAttribute customAttribute);
    public sealed virtual void Visit(ICustomModifier customModifier);
    public sealed virtual void Visit(IEventDefinition eventDefinition);
    public sealed virtual void Visit(IFieldDefinition fieldDefinition);
    public sealed virtual void Visit(IFieldReference fieldReference);
    public sealed virtual void Visit(IFileReference fileReference);
    public sealed virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public sealed virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public sealed virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public sealed virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public sealed virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public sealed virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public sealed virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public sealed virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public sealed virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public sealed virtual void Visit(ILocalDefinition localDefinition);
    public sealed virtual void VisitReference(ILocalDefinition localDefinition);
    public sealed virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public sealed virtual void Visit(IMarshallingInformation marshallingInformation);
    public sealed virtual void Visit(IMetadataConstant constant);
    public sealed virtual void Visit(IMetadataCreateArray createArray);
    public sealed virtual void Visit(IMetadataExpression expression);
    public sealed virtual void Visit(IMetadataNamedArgument namedArgument);
    public sealed virtual void Visit(IMetadataTypeOf typeOf);
    public sealed virtual void Visit(IMethodBody methodBody);
    public sealed virtual void Visit(IMethodDefinition method);
    public sealed virtual void Visit(IMethodImplementation methodImplementation);
    public sealed virtual void Visit(IMethodReference methodReference);
    public sealed virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public sealed virtual void Visit(IModule module);
    public sealed virtual void Visit(IModuleReference moduleReference);
    public sealed virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public sealed virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public sealed virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public sealed virtual void Visit(INestedAliasForType nestedAliasForType);
    public sealed virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public sealed virtual void Visit(INestedTypeReference nestedTypeReference);
    public sealed virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public sealed virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public sealed virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public sealed virtual void Visit(IOperation operation);
    public sealed virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public sealed virtual void Visit(IParameterDefinition parameterDefinition);
    public sealed virtual void VisitReference(IParameterDefinition parameterDefinition);
    public sealed virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public sealed virtual void Visit(IPESection peSection);
    public sealed virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public sealed virtual void Visit(IPointerTypeReference pointerTypeReference);
    public sealed virtual void Visit(IPropertyDefinition propertyDefinition);
    public sealed virtual void Visit(IResourceReference resourceReference);
    public sealed virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public sealed virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public sealed virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public sealed virtual void Visit(ISecurityAttribute securityAttribute);
    public sealed virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public sealed virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public sealed virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public sealed virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public sealed virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public sealed virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public sealed virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public sealed virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public sealed virtual void Visit(IUnitSet unitSet);
    public sealed virtual void Visit(IWin32Resource win32Resource);
}
public interface Microsoft.Cci.ICompilation {
    public IPlatformType PlatformType { get; }
    public IUnit Result { get; }
    public IUnitSet UnitSet { get; }
    public abstract virtual bool Contains(ISourceDocument sourceDocument);
    public abstract virtual IUnitSet GetUnitSetFor(IName unitSetName);
    public abstract virtual IPlatformType get_PlatformType();
    public abstract virtual IUnit get_Result();
    public abstract virtual IUnitSet get_UnitSet();
}
internal abstract class Microsoft.Cci.ICompilationContract : object {
    public IPlatformType PlatformType { get; }
    public IUnit Result { get; }
    public IUnitSet UnitSet { get; }
    public sealed virtual bool Contains(ISourceDocument sourceDocument);
    public sealed virtual IUnitSet GetUnitSetFor(IName unitSetName);
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IUnit get_Result();
    public sealed virtual IUnitSet get_UnitSet();
}
public interface Microsoft.Cci.ICompileTimeConstant {
    public object Value { get; }
    public abstract virtual object get_Value();
}
public interface Microsoft.Cci.IConditional {
    public IExpression Condition { get; }
    public IExpression ResultIfTrue { get; }
    public IExpression ResultIfFalse { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IExpression get_ResultIfTrue();
    public abstract virtual IExpression get_ResultIfFalse();
}
internal abstract class Microsoft.Cci.IConditionalContract : object {
    public IExpression Condition { get; }
    public IExpression ResultIfTrue { get; }
    public IExpression ResultIfFalse { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Condition();
    public sealed virtual IExpression get_ResultIfTrue();
    public sealed virtual IExpression get_ResultIfFalse();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IConditionalStatement {
    public IExpression Condition { get; }
    public IStatement TrueBranch { get; }
    public IStatement FalseBranch { get; }
    public abstract virtual IExpression get_Condition();
    public abstract virtual IStatement get_TrueBranch();
    public abstract virtual IStatement get_FalseBranch();
}
internal abstract class Microsoft.Cci.IConditionalStatementContract : object {
    public IExpression Condition { get; }
    public IStatement TrueBranch { get; }
    public IStatement FalseBranch { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Condition();
    public sealed virtual IStatement get_TrueBranch();
    public sealed virtual IStatement get_FalseBranch();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IContainer`1 {
    public IEnumerable`1<MemberType> Members { get; }
    public abstract virtual IEnumerable`1<MemberType> get_Members();
}
internal abstract class Microsoft.Cci.IContainerContract`1 : object {
    public IEnumerable`1<MemberType> Members { get; }
    public sealed virtual IEnumerable`1<MemberType> get_Members();
}
public interface Microsoft.Cci.IContainerMember`1 {
    public ContainerType Container { get; }
    public IName Name { get; }
    public abstract virtual ContainerType get_Container();
    public abstract virtual IName get_Name();
}
internal abstract class Microsoft.Cci.IContainerMemberContract`1 : object {
    public ContainerType Container { get; }
    private IName Microsoft.Cci.IContainerMember<ContainerType>.Name { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    public sealed virtual ContainerType get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<ContainerType>.get_Name();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
}
public interface Microsoft.Cci.IContinueStatement {
}
public interface Microsoft.Cci.IConversion {
    public IExpression ValueToConvert { get; }
    public bool CheckNumericRange { get; }
    public ITypeReference TypeAfterConversion { get; }
    public abstract virtual IExpression get_ValueToConvert();
    public abstract virtual bool get_CheckNumericRange();
    public abstract virtual ITypeReference get_TypeAfterConversion();
}
internal abstract class Microsoft.Cci.IConversionContract : object {
    public IExpression ValueToConvert { get; }
    public bool CheckNumericRange { get; }
    public ITypeReference TypeAfterConversion { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_ValueToConvert();
    public sealed virtual bool get_CheckNumericRange();
    public sealed virtual ITypeReference get_TypeAfterConversion();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICopyMemoryStatement {
    public IExpression TargetAddress { get; }
    public IExpression SourceAddress { get; }
    public IExpression NumberOfBytesToCopy { get; }
    public abstract virtual IExpression get_TargetAddress();
    public abstract virtual IExpression get_SourceAddress();
    public abstract virtual IExpression get_NumberOfBytesToCopy();
}
internal abstract class Microsoft.Cci.ICopyMemoryStatementContract : object {
    public IExpression TargetAddress { get; }
    public IExpression SourceAddress { get; }
    public IExpression NumberOfBytesToCopy { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_TargetAddress();
    public sealed virtual IExpression get_SourceAddress();
    public sealed virtual IExpression get_NumberOfBytesToCopy();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICreateArray {
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IExpression> Initializers { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<IExpression> Sizes { get; }
    public abstract virtual ITypeReference get_ElementType();
    public abstract virtual IEnumerable`1<IExpression> get_Initializers();
    public abstract virtual IEnumerable`1<int> get_LowerBounds();
    public abstract virtual UInt32 get_Rank();
    public abstract virtual IEnumerable`1<IExpression> get_Sizes();
}
internal abstract class Microsoft.Cci.ICreateArrayContract : object {
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IExpression> Initializers { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<IExpression> Sizes { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ITypeReference get_ElementType();
    public sealed virtual IEnumerable`1<IExpression> get_Initializers();
    public sealed virtual IEnumerable`1<int> get_LowerBounds();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual IEnumerable`1<IExpression> get_Sizes();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICreateDelegateInstance {
    public IExpression Instance { get; }
    public bool IsVirtualDelegate { get; }
    public IMethodReference MethodToCallViaDelegate { get; }
    public abstract virtual IExpression get_Instance();
    public abstract virtual bool get_IsVirtualDelegate();
    public abstract virtual IMethodReference get_MethodToCallViaDelegate();
}
internal abstract class Microsoft.Cci.ICreateDelegateInstanceContract : object {
    public IExpression Instance { get; }
    public bool IsVirtualDelegate { get; }
    public IMethodReference MethodToCallViaDelegate { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Instance();
    public sealed virtual bool get_IsVirtualDelegate();
    public sealed virtual IMethodReference get_MethodToCallViaDelegate();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICreateObjectInstance {
    public IEnumerable`1<IExpression> Arguments { get; }
    public IMethodReference MethodToCall { get; }
    public abstract virtual IEnumerable`1<IExpression> get_Arguments();
    public abstract virtual IMethodReference get_MethodToCall();
}
internal abstract class Microsoft.Cci.ICreateObjectInstanceContract : object {
    public IEnumerable`1<IExpression> Arguments { get; }
    public IMethodReference MethodToCall { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IExpression> get_Arguments();
    public sealed virtual IMethodReference get_MethodToCall();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ICustomAttribute {
    public IEnumerable`1<IMetadataExpression> Arguments { get; }
    public IMethodReference Constructor { get; }
    public IEnumerable`1<IMetadataNamedArgument> NamedArguments { get; }
    public ushort NumberOfNamedArguments { get; }
    public ITypeReference Type { get; }
    public abstract virtual IEnumerable`1<IMetadataExpression> get_Arguments();
    public abstract virtual IMethodReference get_Constructor();
    public abstract virtual IEnumerable`1<IMetadataNamedArgument> get_NamedArguments();
    public abstract virtual ushort get_NumberOfNamedArguments();
    public abstract virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.ICustomAttributeContract : object {
    public IEnumerable`1<IMetadataExpression> Arguments { get; }
    public IMethodReference Constructor { get; }
    public IEnumerable`1<IMetadataNamedArgument> NamedArguments { get; }
    public ushort NumberOfNamedArguments { get; }
    public ITypeReference Type { get; }
    public sealed virtual IEnumerable`1<IMetadataExpression> get_Arguments();
    public sealed virtual IMethodReference get_Constructor();
    public sealed virtual IEnumerable`1<IMetadataNamedArgument> get_NamedArguments();
    public sealed virtual ushort get_NumberOfNamedArguments();
    public sealed virtual ITypeReference get_Type();
}
public interface Microsoft.Cci.ICustomModifier {
    public bool IsOptional { get; }
    public ITypeReference Modifier { get; }
    public abstract virtual bool get_IsOptional();
    public abstract virtual ITypeReference get_Modifier();
}
internal abstract class Microsoft.Cci.ICustomModifierContract : object {
    public bool IsOptional { get; }
    public ITypeReference Modifier { get; }
    public sealed virtual bool get_IsOptional();
    public sealed virtual ITypeReference get_Modifier();
}
public interface Microsoft.Cci.IDebuggerBreakStatement {
}
public interface Microsoft.Cci.IDefaultValue {
    public ITypeReference DefaultValueType { get; }
    public abstract virtual ITypeReference get_DefaultValueType();
}
internal abstract class Microsoft.Cci.IDefaultValueContract : object {
    public ITypeReference DefaultValueType { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ITypeReference get_DefaultValueType();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IDefinition {
}
public interface Microsoft.Cci.IDerivedSourceDocument {
    public IDerivedSourceLocation DerivedSourceLocation { get; }
    public abstract virtual IDerivedSourceLocation get_DerivedSourceLocation();
    public abstract virtual IDerivedSourceLocation GetDerivedSourceLocation(int position, int length);
    public abstract virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IDerivedSourceLocation derivedSourceLocation);
}
internal abstract class Microsoft.Cci.IDerivedSourceDocumentContract : object {
    public IDerivedSourceLocation DerivedSourceLocation { get; }
    public int Length { get; }
    public string SourceLanguage { get; }
    public ISourceLocation SourceLocation { get; }
    public string Location { get; }
    public IName Name { get; }
    public sealed virtual IDerivedSourceLocation get_DerivedSourceLocation();
    public sealed virtual IDerivedSourceLocation GetDerivedSourceLocation(int position, int length);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IDerivedSourceLocation derivedSourceLocation);
    public sealed virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public sealed virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public sealed virtual ISourceLocation GetSourceLocation(int position, int length);
    public sealed virtual string GetText();
    public sealed virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public sealed virtual int get_Length();
    public sealed virtual string get_SourceLanguage();
    public sealed virtual ISourceLocation get_SourceLocation();
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.IDerivedSourceLocation {
    public IDerivedSourceDocument DerivedSourceDocument { get; }
    public IEnumerable`1<IPrimarySourceLocation> PrimarySourceLocations { get; }
    public abstract virtual IDerivedSourceDocument get_DerivedSourceDocument();
    public abstract virtual IEnumerable`1<IPrimarySourceLocation> get_PrimarySourceLocations();
}
internal abstract class Microsoft.Cci.IDerivedSourceLocationContract : object {
    public IDerivedSourceDocument DerivedSourceDocument { get; }
    public IEnumerable`1<IPrimarySourceLocation> PrimarySourceLocations { get; }
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public IDocument Document { get; }
    public sealed virtual IDerivedSourceDocument get_DerivedSourceDocument();
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> get_PrimarySourceLocations();
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual ISourceDocument get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IDivision {
    public bool TreatOperandsAsUnsignedIntegers { get; }
    public abstract virtual bool get_TreatOperandsAsUnsignedIntegers();
}
public interface Microsoft.Cci.IDocument {
    public string Location { get; }
    public IName Name { get; }
    public abstract virtual string get_Location();
    public abstract virtual IName get_Name();
}
internal abstract class Microsoft.Cci.IDocumentContract : object {
    public string Location { get; }
    public IName Name { get; }
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.IDoUntilStatement {
    public IStatement Body { get; }
    public IExpression Condition { get; }
    public abstract virtual IStatement get_Body();
    public abstract virtual IExpression get_Condition();
}
public interface Microsoft.Cci.IDupValue {
}
public interface Microsoft.Cci.IEditDescriptor {
    public IDefinition AffectedDefinition { get; }
    public EditEventKind Kind { get; }
    public ISourceDocument ModifiedSourceDocument { get; }
    public IDefinition ModifiedParent { get; }
    public ISourceDocument OriginalSourceDocument { get; }
    public IDefinition OriginalParent { get; }
    public abstract virtual IDefinition get_AffectedDefinition();
    public abstract virtual EditEventKind get_Kind();
    public abstract virtual ISourceDocument get_ModifiedSourceDocument();
    public abstract virtual IDefinition get_ModifiedParent();
    public abstract virtual ISourceDocument get_OriginalSourceDocument();
    public abstract virtual IDefinition get_OriginalParent();
}
internal abstract class Microsoft.Cci.IEditDescriptorContract : object {
    public IDefinition AffectedDefinition { get; }
    public EditEventKind Kind { get; }
    public ISourceDocument ModifiedSourceDocument { get; }
    public IDefinition ModifiedParent { get; }
    public ISourceDocument OriginalSourceDocument { get; }
    public IDefinition OriginalParent { get; }
    public sealed virtual IDefinition get_AffectedDefinition();
    public sealed virtual EditEventKind get_Kind();
    public sealed virtual ISourceDocument get_ModifiedSourceDocument();
    public sealed virtual IDefinition get_ModifiedParent();
    public sealed virtual ISourceDocument get_OriginalSourceDocument();
    public sealed virtual IDefinition get_OriginalParent();
}
public interface Microsoft.Cci.IEmptyStatement {
    public bool IsSentinel { get; }
    public abstract virtual bool get_IsSentinel();
}
public interface Microsoft.Cci.IEquality {
}
public interface Microsoft.Cci.IErrorMessage {
    public object ErrorReporter { get; }
    public string ErrorReporterIdentifier { get; }
    public long Code { get; }
    public bool IsWarning { get; }
    public string Message { get; }
    public ILocation Location { get; }
    public IEnumerable`1<ILocation> RelatedLocations { get; }
    public abstract virtual object get_ErrorReporter();
    public abstract virtual string get_ErrorReporterIdentifier();
    public abstract virtual long get_Code();
    public abstract virtual bool get_IsWarning();
    public abstract virtual string get_Message();
    public abstract virtual ILocation get_Location();
    public abstract virtual IEnumerable`1<ILocation> get_RelatedLocations();
}
internal abstract class Microsoft.Cci.IErrorMessageContract : object {
    public object ErrorReporter { get; }
    public string ErrorReporterIdentifier { get; }
    public long Code { get; }
    public bool IsWarning { get; }
    public string Message { get; }
    public ILocation Location { get; }
    public IEnumerable`1<ILocation> RelatedLocations { get; }
    public sealed virtual object get_ErrorReporter();
    public sealed virtual string get_ErrorReporterIdentifier();
    public sealed virtual long get_Code();
    public sealed virtual bool get_IsWarning();
    public sealed virtual string get_Message();
    public sealed virtual ILocation get_Location();
    public sealed virtual IEnumerable`1<ILocation> get_RelatedLocations();
}
public interface Microsoft.Cci.IEventDefinition {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMethodReference Adder { get; }
    public IMethodReference Caller { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMethodReference Remover { get; }
    public ITypeReference Type { get; }
    public abstract virtual IEnumerable`1<IMethodReference> get_Accessors();
    public abstract virtual IMethodReference get_Adder();
    public abstract virtual IMethodReference get_Caller();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual IMethodReference get_Remover();
    public abstract virtual ITypeReference get_Type();
}
public interface Microsoft.Cci.IExclusiveOr {
}
public interface Microsoft.Cci.IExpression {
    public ITypeReference Type { get; }
    public abstract virtual void Dispatch(ICodeVisitor visitor);
    public abstract virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.IExpressionContract : object {
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IExpressionSourceLocation {
    public IPrimarySourceLocation PrimarySourceLocation { get; }
    public abstract virtual IPrimarySourceLocation get_PrimarySourceLocation();
}
internal abstract class Microsoft.Cci.IExpressionSourceLocationContract : object {
    public IPrimarySourceLocation PrimarySourceLocation { get; }
    public IDocument Document { get; }
    public sealed virtual IPrimarySourceLocation get_PrimarySourceLocation();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IExpressionStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
internal abstract class Microsoft.Cci.IExpressionStatementContract : object {
    public IExpression Expression { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Expression();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IFieldDefinition {
    public UInt32 BitLength { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public ISectionBlock FieldMapping { get; }
    public bool IsBitField { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public abstract virtual UInt32 get_BitLength();
    public abstract virtual IMetadataConstant get_CompileTimeValue();
    public abstract virtual ISectionBlock get_FieldMapping();
    public abstract virtual bool get_IsBitField();
    public abstract virtual bool get_IsCompileTimeConstant();
    public abstract virtual bool get_IsMapped();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public abstract virtual bool get_IsNotSerialized();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual UInt32 get_Offset();
    public abstract virtual int get_SequenceNumber();
}
internal abstract class Microsoft.Cci.IFieldDefinitionContract : object {
    public UInt32 BitLength { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public ISectionBlock FieldMapping { get; }
    public bool IsBitField { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public UInt32 InternedKey { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public ITypeReference Type { get; }
    public IFieldDefinition ResolvedField { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual UInt32 get_BitLength();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual ISectionBlock get_FieldMapping();
    public sealed virtual bool get_IsBitField();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual int get_SequenceNumber();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual IMetadataConstant get_Constant();
}
public interface Microsoft.Cci.IFieldReference {
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public UInt32 InternedKey { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public ITypeReference Type { get; }
    public IFieldDefinition ResolvedField { get; }
    public abstract virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual UInt32 get_InternedKey();
    public abstract virtual bool get_IsModified();
    public abstract virtual bool get_IsStatic();
    public abstract virtual ITypeReference get_Type();
    public abstract virtual IFieldDefinition get_ResolvedField();
}
internal abstract class Microsoft.Cci.IFieldReferenceContract : object {
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public UInt32 InternedKey { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public ITypeReference Type { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IFileReference {
    public IAssembly ContainingAssembly { get; }
    public bool HasMetadata { get; }
    public IName FileName { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public abstract virtual IAssembly get_ContainingAssembly();
    public abstract virtual bool get_HasMetadata();
    public abstract virtual IName get_FileName();
    public abstract virtual IEnumerable`1<byte> get_HashValue();
}
public interface Microsoft.Cci.IFillMemoryStatement {
    public IExpression TargetAddress { get; }
    public IExpression FillValue { get; }
    public IExpression NumberOfBytesToFill { get; }
    public abstract virtual IExpression get_TargetAddress();
    public abstract virtual IExpression get_FillValue();
    public abstract virtual IExpression get_NumberOfBytesToFill();
}
internal abstract class Microsoft.Cci.IFillMemoryStatementContract : object {
    public IExpression TargetAddress { get; }
    public IExpression FillValue { get; }
    public IExpression NumberOfBytesToFill { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_TargetAddress();
    public sealed virtual IExpression get_FillValue();
    public sealed virtual IExpression get_NumberOfBytesToFill();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IForEachStatement {
    public IStatement Body { get; }
    public IExpression Collection { get; }
    public ILocalDefinition Variable { get; }
    public abstract virtual IStatement get_Body();
    public abstract virtual IExpression get_Collection();
    public abstract virtual ILocalDefinition get_Variable();
}
public interface Microsoft.Cci.IForStatement {
    public IStatement Body { get; }
    public IExpression Condition { get; }
    public IEnumerable`1<IStatement> IncrementStatements { get; }
    public IEnumerable`1<IStatement> InitStatements { get; }
    public abstract virtual IStatement get_Body();
    public abstract virtual IExpression get_Condition();
    public abstract virtual IEnumerable`1<IStatement> get_IncrementStatements();
    public abstract virtual IEnumerable`1<IStatement> get_InitStatements();
}
internal abstract class Microsoft.Cci.IForStatementContract : object {
    public IStatement Body { get; }
    public IExpression Condition { get; }
    public IEnumerable`1<IStatement> IncrementStatements { get; }
    public IEnumerable`1<IStatement> InitStatements { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IStatement get_Body();
    public sealed virtual IExpression get_Condition();
    public sealed virtual IEnumerable`1<IStatement> get_IncrementStatements();
    public sealed virtual IEnumerable`1<IStatement> get_InitStatements();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IFunctionPointer {
}
public interface Microsoft.Cci.IFunctionPointerTypeReference {
    public IEnumerable`1<IParameterTypeInformation> ExtraArgumentTypes { get; }
    public abstract virtual IEnumerable`1<IParameterTypeInformation> get_ExtraArgumentTypes();
}
internal abstract class Microsoft.Cci.IFunctionPointerTypeReferenceContract : object {
    public IEnumerable`1<IParameterTypeInformation> ExtraArgumentTypes { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public bool IsStatic { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraArgumentTypes();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IGenericMethodInstance {
}
public interface Microsoft.Cci.IGenericMethodInstanceReference {
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public IMethodReference GenericMethod { get; }
    public abstract virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public abstract virtual IMethodReference get_GenericMethod();
}
internal abstract class Microsoft.Cci.IGenericMethodInstanceReferenceContract : object {
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public IMethodReference GenericMethod { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public sealed virtual IMethodReference get_GenericMethod();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.IGenericMethodParameter {
    public IMethodDefinition DefiningMethod { get; }
    public abstract virtual IMethodDefinition get_DefiningMethod();
}
internal abstract class Microsoft.Cci.IGenericMethodParameterContract : object {
    public IMethodDefinition DefiningMethod { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public ushort GenericParameterCount { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    public ushort Index { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    public sealed virtual IMethodDefinition get_DefiningMethod();
    public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IGenericMethodParameterReference {
    public IMethodReference DefiningMethod { get; }
    public IGenericMethodParameter ResolvedType { get; }
    public abstract virtual IMethodReference get_DefiningMethod();
    public abstract virtual IGenericMethodParameter get_ResolvedType();
}
internal abstract class Microsoft.Cci.IGenericMethodParameterReferenceContract : object {
    public IMethodReference DefiningMethod { get; }
    public IGenericMethodParameter ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ushort Index { get; }
    public sealed virtual IMethodReference get_DefiningMethod();
    public sealed virtual IGenericMethodParameter get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IGenericParameter {
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public ushort GenericParameterCount { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public abstract virtual IEnumerable`1<ITypeReference> get_Constraints();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_MustBeReferenceType();
    public abstract virtual bool get_MustBeValueType();
    public abstract virtual bool get_MustHaveDefaultConstructor();
    public abstract virtual TypeParameterVariance get_Variance();
}
internal abstract class Microsoft.Cci.IGenericParameterContract : object {
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public ushort GenericParameterCount { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    public ushort Index { get; }
    public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IGenericParameterReference {
}
public interface Microsoft.Cci.IGenericTypeInstance {
}
public interface Microsoft.Cci.IGenericTypeInstanceReference {
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public INamedTypeReference GenericType { get; }
    public abstract virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public abstract virtual INamedTypeReference get_GenericType();
}
internal abstract class Microsoft.Cci.IGenericTypeInstanceReferenceContract : object {
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public INamedTypeReference GenericType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public sealed virtual INamedTypeReference get_GenericType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IGenericTypeParameter {
    public ITypeDefinition DefiningType { get; }
    public abstract virtual ITypeDefinition get_DefiningType();
}
internal abstract class Microsoft.Cci.IGenericTypeParameterContract : object {
    public ITypeDefinition DefiningType { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public ushort GenericParameterCount { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    public ushort Index { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    public sealed virtual ITypeDefinition get_DefiningType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
}
public interface Microsoft.Cci.IGenericTypeParameterReference {
    public ITypeReference DefiningType { get; }
    public IGenericTypeParameter ResolvedType { get; }
    public abstract virtual ITypeReference get_DefiningType();
    public abstract virtual IGenericTypeParameter get_ResolvedType();
}
internal abstract class Microsoft.Cci.IGenericTypeParameterReferenceContract : object {
    public ITypeReference DefiningType { get; }
    public IGenericTypeParameter ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ushort Index { get; }
    public sealed virtual ITypeReference get_DefiningType();
    public sealed virtual IGenericTypeParameter get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IGetTypeOfTypedReference {
    public IExpression TypedReference { get; }
    public abstract virtual IExpression get_TypedReference();
}
public interface Microsoft.Cci.IGetValueOfTypedReference {
    public IExpression TypedReference { get; }
    public ITypeReference TargetType { get; }
    public abstract virtual IExpression get_TypedReference();
    public abstract virtual ITypeReference get_TargetType();
}
internal abstract class Microsoft.Cci.IGetValueOfTypedReferenceContract : object {
    public IExpression TypedReference { get; }
    public ITypeReference TargetType { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_TypedReference();
    public sealed virtual ITypeReference get_TargetType();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IGlobalFieldDefinition {
    public IName Name { get; }
    public abstract virtual IName get_Name();
}
public interface Microsoft.Cci.IGlobalMethodDefinition {
    public IName Name { get; }
    public abstract virtual IName get_Name();
}
public interface Microsoft.Cci.IGotoStatement {
    public ILabeledStatement TargetStatement { get; }
    public abstract virtual ILabeledStatement get_TargetStatement();
}
internal abstract class Microsoft.Cci.IGotoStatementContract : object {
    public ILabeledStatement TargetStatement { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ILabeledStatement get_TargetStatement();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IGotoSwitchCaseStatement {
    public ISwitchCase TargetCase { get; }
    public abstract virtual ISwitchCase get_TargetCase();
}
public interface Microsoft.Cci.IGreaterThan {
    public bool IsUnsignedOrUnordered { get; }
    public abstract virtual bool get_IsUnsignedOrUnordered();
}
public interface Microsoft.Cci.IGreaterThanOrEqual {
    public bool IsUnsignedOrUnordered { get; }
    public abstract virtual bool get_IsUnsignedOrUnordered();
}
public interface Microsoft.Cci.IILLocation {
    public IMethodDefinition MethodDefinition { get; }
    public UInt32 Offset { get; }
    public abstract virtual IMethodDefinition get_MethodDefinition();
    public abstract virtual UInt32 get_Offset();
}
internal abstract class Microsoft.Cci.IILLocationContract : object {
    public IMethodDefinition MethodDefinition { get; }
    public UInt32 Offset { get; }
    public IDocument Document { get; }
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IIncludedSourceLocation {
    public int OriginalEndLine { get; }
    public string OriginalSourceDocumentName { get; }
    public int OriginalStartLine { get; }
    public abstract virtual int get_OriginalEndLine();
    public abstract virtual string get_OriginalSourceDocumentName();
    public abstract virtual int get_OriginalStartLine();
}
internal abstract class Microsoft.Cci.IIncludedSourceLocationContract : object {
    public int OriginalEndLine { get; }
    public string OriginalSourceDocumentName { get; }
    public int OriginalStartLine { get; }
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public IDocument Document { get; }
    public sealed virtual int get_OriginalEndLine();
    public sealed virtual string get_OriginalSourceDocumentName();
    public sealed virtual int get_OriginalStartLine();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartLine();
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual ISourceDocument get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IInternFactory {
    public abstract virtual UInt32 GetAssemblyInternedKey(AssemblyIdentity assemblyIdentity);
    public abstract virtual UInt32 GetFieldInternedKey(IFieldReference fieldReference);
    public abstract virtual UInt32 GetMethodInternedKey(IMethodReference methodReference);
    public abstract virtual UInt32 GetModuleInternedKey(ModuleIdentity moduleIdentity);
    public abstract virtual UInt32 GetNamespaceTypeReferenceInternedKey(IUnitNamespaceReference containingUnitNamespace, IName typeName, UInt32 genericParameterCount);
    public abstract virtual UInt32 GetNestedTypeReferenceInternedKey(ITypeReference containingTypeReference, IName typeName, UInt32 genericParameterCount);
    public abstract virtual UInt32 GetVectorTypeReferenceInternedKey(ITypeReference elementTypeReference);
    public abstract virtual UInt32 GetMatrixTypeReferenceInternedKey(ITypeReference elementTypeReference, int rank, IEnumerable`1<ulong> sizes, IEnumerable`1<int> lowerBounds);
    public abstract virtual UInt32 GetGenericTypeInstanceReferenceInternedKey(ITypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    public abstract virtual UInt32 GetPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    public abstract virtual UInt32 GetManagedPointerTypeReferenceInternedKey(ITypeReference targetTypeReferece);
    public abstract virtual UInt32 GetGenericTypeParameterReferenceInternedKey(ITypeReference definingTypeReference, int index);
    public abstract virtual UInt32 GetGenericMethodParameterReferenceInternedKey(IMethodReference defininingMethodReference, int index);
    public abstract virtual UInt32 GetFunctionPointerTypeReferenceInternedKey(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    public abstract virtual UInt32 GetModifiedTypeReferenceInternedKey(ITypeReference typeReference, IEnumerable`1<ICustomModifier> customModifiers);
    public abstract virtual UInt32 GetTypeReferenceInternedKey(ITypeReference typeReference);
}
internal abstract class Microsoft.Cci.IInternFactoryContract : object {
    public sealed virtual UInt32 GetAssemblyInternedKey(AssemblyIdentity assemblyIdentity);
    public sealed virtual UInt32 GetFieldInternedKey(IFieldReference fieldReference);
    public sealed virtual UInt32 GetMethodInternedKey(IMethodReference methodReference);
    public sealed virtual UInt32 GetModuleInternedKey(ModuleIdentity moduleIdentity);
    public sealed virtual UInt32 GetNamespaceTypeReferenceInternedKey(IUnitNamespaceReference containingUnitNamespace, IName typeName, UInt32 genericParameterCount);
    public sealed virtual UInt32 GetNestedTypeReferenceInternedKey(ITypeReference containingTypeReference, IName typeName, UInt32 genericParameterCount);
    public sealed virtual UInt32 GetVectorTypeReferenceInternedKey(ITypeReference elementTypeReference);
    public sealed virtual UInt32 GetMatrixTypeReferenceInternedKey(ITypeReference elementTypeReference, int rank, IEnumerable`1<ulong> sizes, IEnumerable`1<int> lowerBounds);
    public sealed virtual UInt32 GetGenericTypeInstanceReferenceInternedKey(ITypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    public sealed virtual UInt32 GetPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    public sealed virtual UInt32 GetManagedPointerTypeReferenceInternedKey(ITypeReference targetTypeReferece);
    public sealed virtual UInt32 GetGenericTypeParameterReferenceInternedKey(ITypeReference definingTypeReference, int index);
    public sealed virtual UInt32 GetGenericMethodParameterReferenceInternedKey(IMethodReference defininingMethodReference, int index);
    public sealed virtual UInt32 GetFunctionPointerTypeReferenceInternedKey(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    public sealed virtual UInt32 GetModifiedTypeReferenceInternedKey(ITypeReference typeReference, IEnumerable`1<ICustomModifier> customModifiers);
    public sealed virtual UInt32 GetTypeReferenceInternedKey(ITypeReference typeReference);
}
public interface Microsoft.Cci.ILabeledStatement {
    public IName Label { get; }
    public IStatement Statement { get; }
    public abstract virtual IName get_Label();
    public abstract virtual IStatement get_Statement();
}
internal abstract class Microsoft.Cci.ILabeledStatementContract : object {
    public IName Label { get; }
    public IStatement Statement { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IName get_Label();
    public sealed virtual IStatement get_Statement();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ILeftShift {
}
public interface Microsoft.Cci.ILessThan {
    public bool IsUnsignedOrUnordered { get; }
    public abstract virtual bool get_IsUnsignedOrUnordered();
}
public interface Microsoft.Cci.ILessThanOrEqual {
    public bool IsUnsignedOrUnordered { get; }
    public abstract virtual bool get_IsUnsignedOrUnordered();
}
public class Microsoft.Cci.ILGenerator : object {
    private List`1<ExceptionHandler> handlers;
    private IMetadataHost host;
    private IMethodDefinition method;
    private ILocation location;
    private ILocation expressionLocation;
    private UInt32 offset;
    private List`1<Operation> operations;
    private List`1<ILocalScope> iteratorScopes;
    private List`1<ILGeneratorScope> scopes;
    private Stack`1<ILGeneratorScope> scopeStack;
    private Stack`1<TryBody> tryBodyStack;
    private List`1<SynchronizationPoint> synchronizationPoints;
    private IMethodDefinition asyncMethodDefinition;
    public UInt32 CurrentOffset { get; }
    public bool InTryBody { get; }
    public IMethodDefinition Method { get; }
    public ILGenerator(IMetadataHost host, IMethodDefinition methodDefinition, IMethodDefinition asyncMethodDefinition);
    private void ObjectInvariant();
    public void AddConstantToCurrentScope(ILocalDefinition local);
    public void AddVariableToCurrentScope(ILocalDefinition local);
    public void AddExceptionHandlerInformation(HandlerKind kind, ITypeReference exceptionType, ILGeneratorLabel tryStart, ILGeneratorLabel tryEnd, ILGeneratorLabel handlerStart, ILGeneratorLabel handlerEnd, ILGeneratorLabel filterStart);
    public void AdjustBranchSizesToBestFit(bool eliminateBranchesToNext);
    public void BeginCatchBlock(ITypeReference exceptionType);
    public void BeginFilterBlock();
    public void BeginFilterBody();
    private ExceptionHandler BeginHandler(HandlerKind kind);
    public void BeginTryBody();
    public void BeginFaultBlock();
    public void BeginFinallyBlock();
    public void BeginScope();
    public void BeginScope(UInt32 numberOfIteratorLocalsInScope);
    public UInt32 get_CurrentOffset();
    public void Emit(OperationCode opcode);
    public void Emit(OperationCode opcode, object value);
    public void Emit(OperationCode opcode, byte arg);
    public void Emit(OperationCode opcode, double arg);
    public void Emit(OperationCode opcode, IFieldReference field);
    public void Emit(OperationCode opcode, float arg);
    public void Emit(OperationCode opcode, int arg);
    public void Emit(OperationCode opcode, ILGeneratorLabel label);
    public void Emit(OperationCode opcode, ILGeneratorLabel[] labels);
    public void Emit(OperationCode opcode, ILocalDefinition local);
    public void Emit(OperationCode opcode, long arg);
    public void Emit(OperationCode opcode, IMethodReference meth);
    public void Emit(OperationCode opcode, IParameterDefinition parameter);
    public void Emit(OperationCode opcode, sbyte arg);
    public void Emit(OperationCode opcode, short arg);
    public void Emit(OperationCode opcode, ISignature signature);
    public void Emit(OperationCode opcode, string str);
    public void Emit(OperationCode opcode, ITypeReference cls);
    public void EndTryBody();
    public void EndScope();
    private ILocation GetCurrentSequencePoint();
    public bool get_InTryBody();
    public void MarkExpressionLocation(ILocation expressionLocation);
    public void MarkLabel(ILGeneratorLabel label);
    public void MarkSequencePoint(ILocation location);
    public void MarkSynchronizationPoint(IMethodDefinition continuationMethod, ILGeneratorLabel continuationLabel);
    public IMethodDefinition get_Method();
    public static OperationCode LongVersionOf(OperationCode operationCode);
    public static OperationCode ShortVersionOf(OperationCode operationCode);
    private static UInt32 SizeOfOffset(OperationCode opcode);
    private static UInt32 SizeOfOperationCode(OperationCode opcode);
    public void UseNamespace(string namespaceToUse);
    public IEnumerable`1<ILocalScope> GetIteratorScopes();
    public IEnumerable`1<ILGeneratorScope> GetLocalScopes();
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGenerator/<GetNamespaceScopes>d__66")]
public IEnumerable`1<INamespaceScope> GetNamespaceScopes();
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGenerator/<GetOperations>d__67")]
public IEnumerable`1<IOperation> GetOperations();
    public IEnumerable`1<IOperationExceptionInformation> GetOperationExceptionInformation();
    public ISynchronizationInformation GetSynchronizationInformation();
}
internal class Microsoft.Cci.ILGeneratorImplementation.ExceptionHandler : object {
    internal HandlerKind Kind;
    internal ITypeReference ExceptionType;
    internal ILGeneratorLabel TryStart;
    internal ILGeneratorLabel TryEnd;
    internal ILGeneratorLabel HandlerEnd;
    internal ILGeneratorLabel HandlerStart;
    internal ILGeneratorLabel FilterDecisionStart;
    private TryBody tryBlock;
    private HandlerKind Microsoft.Cci.IOperationExceptionInformation.HandlerKind { get; }
    private ITypeReference Microsoft.Cci.IOperationExceptionInformation.ExceptionType { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.TryStartOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.TryEndOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.FilterDecisionStartOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.HandlerStartOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.HandlerEndOffset { get; }
    internal ExceptionHandler(HandlerKind kind, TryBody tryBlock, ILGeneratorLabel handlerStart);
    private sealed virtual override HandlerKind Microsoft.Cci.IOperationExceptionInformation.get_HandlerKind();
    private sealed virtual override ITypeReference Microsoft.Cci.IOperationExceptionInformation.get_ExceptionType();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_TryStartOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_TryEndOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_FilterDecisionStartOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_HandlerStartOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_HandlerEndOffset();
}
internal class Microsoft.Cci.ILGeneratorImplementation.Operation : object {
    internal OperationCode operationCode;
    internal UInt32 offset;
    private ILocation location;
    internal object value;
    public OperationCode OperationCode { get; }
    public UInt32 Offset { get; }
    public ILocation Location { get; }
    public object Value { get; }
    internal Operation(OperationCode operationCode, UInt32 offset, ILocation location, object value);
    public sealed virtual OperationCode get_OperationCode();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ILocation get_Location();
    public sealed virtual object get_Value();
}
internal class Microsoft.Cci.ILGeneratorImplementation.Stack`1 : object {
    private T[] elements;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    internal int Count { get; internal set; }
    private void ObjectInvariant();
    [CompilerGeneratedAttribute]
internal int get_Count();
    [CompilerGeneratedAttribute]
internal void set_Count(int value);
    internal T Peek();
    internal T Pop();
    internal void Push(T element);
}
internal class Microsoft.Cci.ILGeneratorImplementation.SynchronizationInformation : object {
    internal IMethodDefinition asyncMethod;
    internal IMethodDefinition moveNextMethod;
    internal UInt32 generatedCatchHandlerOffset;
    internal IEnumerable`1<ISynchronizationPoint> synchronizationPoints;
    public IMethodDefinition AsyncMethod { get; }
    public IMethodDefinition MoveNextMethod { get; }
    public UInt32 GeneratedCatchHandlerOffset { get; }
    public IEnumerable`1<ISynchronizationPoint> SynchronizationPoints { get; }
    public sealed virtual IMethodDefinition get_AsyncMethod();
    public sealed virtual IMethodDefinition get_MoveNextMethod();
    public sealed virtual UInt32 get_GeneratedCatchHandlerOffset();
    public sealed virtual IEnumerable`1<ISynchronizationPoint> get_SynchronizationPoints();
}
internal class Microsoft.Cci.ILGeneratorImplementation.SynchronizationPoint : object {
    internal ILGeneratorLabel startOfSynchronize;
    internal ILGeneratorLabel startOfContinuation;
    internal IMethodDefinition continuationMethod;
    public UInt32 SynchronizeOffset { get; }
    public IMethodDefinition ContinuationMethod { get; }
    public UInt32 ContinuationOffset { get; }
    public sealed virtual UInt32 get_SynchronizeOffset();
    public sealed virtual IMethodDefinition get_ContinuationMethod();
    public sealed virtual UInt32 get_ContinuationOffset();
}
internal class Microsoft.Cci.ILGeneratorImplementation.TryBody : object {
    internal ILGeneratorLabel start;
    internal ILGeneratorLabel end;
    internal TryBody(ILGeneratorLabel start);
}
internal class Microsoft.Cci.ILGeneratorImplementation.UsedNamespace : object {
    private IName namespaceName;
    public IName Alias { get; }
    public IName NamespaceName { get; }
    internal UsedNamespace(IName namespaceName);
    public sealed virtual IName get_Alias();
    public sealed virtual IName get_NamespaceName();
}
public class Microsoft.Cci.ILGeneratorLabel : object {
    private UInt32 offset;
    internal ILGeneratorLabel alias;
    internal bool mayAlias;
    internal ILocation locationOfReturnInstruction;
    public UInt32 Offset { get; public set; }
    internal ILGeneratorLabel(bool mayAlias);
    public UInt32 get_Offset();
    public void set_Offset(UInt32 value);
}
public class Microsoft.Cci.ILGeneratorMethodBody : object {
    private IEnumerable`1<ILocalScope> generatorIteratorScopes;
    private IEnumerable`1<ILGeneratorScope> generatorLocalScopes;
    private ISynchronizationInformation synchronizationInformation;
    private IEnumerable`1<IOperationExceptionInformation> operationExceptionInformation;
    private bool localsAreZeroed;
    private IEnumerable`1<ILocalDefinition> localVariables;
    private IMethodDefinition methodDefinition;
    private IEnumerable`1<IOperation> operations;
    private ushort maxStack;
    private IEnumerable`1<ITypeDefinition> privateHelperTypes;
    private UInt32 size;
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public bool LocalsAreZeroed { get; }
    public IEnumerable`1<ILocalDefinition> LocalVariables { get; }
    public IMethodDefinition MethodDefinition { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public ushort MaxStack { get; }
    public IEnumerable`1<ITypeDefinition> PrivateHelperTypes { get; }
    public UInt32 Size { get; }
    public ILGeneratorMethodBody(ILGenerator generator, bool localsAreZeroed, ushort maxStack, IMethodDefinition methodDefinition, IEnumerable`1<ILocalDefinition> localVariables, IEnumerable`1<ITypeDefinition> privateHelperTypes);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public IEnumerable`1<ILocalScope> GetIteratorScopes();
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGeneratorMethodBody/<GetLocalScopes>d__6")]
public IEnumerable`1<ILocalScope> GetLocalScopes();
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGeneratorMethodBody/<GetNamespaceScopes>d__7")]
public IEnumerable`1<INamespaceScope> GetNamespaceScopes();
    public ISynchronizationInformation GetSynchronizationInformation();
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public sealed virtual bool get_LocalsAreZeroed();
    public sealed virtual IEnumerable`1<ILocalDefinition> get_LocalVariables();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual IEnumerable`1<IOperation> get_Operations();
    public sealed virtual ushort get_MaxStack();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_PrivateHelperTypes();
    public sealed virtual UInt32 get_Size();
}
public class Microsoft.Cci.ILGeneratorScope : object {
    private ILGeneratorLabel startLabel;
    private ILGeneratorLabel endLabel;
    internal List`1<ILocalDefinition> constants;
    internal List`1<ILocalDefinition> locals;
    private INameTable nameTable;
    private IMethodDefinition methodDefinition;
    internal List`1<string> usedNamespaces;
    public IEnumerable`1<ILocalDefinition> Constants { get; }
    public UInt32 Length { get; }
    public IEnumerable`1<ILocalDefinition> Locals { get; }
    public IMethodDefinition MethodDefinition { get; }
    public UInt32 Offset { get; }
    public IEnumerable`1<string> UsedNamespaceNames { get; }
    public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    internal ILGeneratorScope(ILGeneratorLabel startLabel, INameTable nameTable, IMethodDefinition containingMethod);
    private void ObjectInvariant();
    internal void CloseScope(ILGeneratorLabel endLabel);
    public IEnumerable`1<ILocalDefinition> get_Constants();
    public sealed virtual UInt32 get_Length();
    public IEnumerable`1<ILocalDefinition> get_Locals();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual UInt32 get_Offset();
    public IEnumerable`1<string> get_UsedNamespaceNames();
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGeneratorScope/<get_UsedNamespaces>d__23")]
public sealed virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
public class Microsoft.Cci.ILGeneratorSourceInformationProvider : object {
    public virtual IEnumerable`1<ILocalScope> GetIteratorScopes(IMethodBody methodBody);
    public virtual IEnumerable`1<ILocalScope> GetLocalScopes(IMethodBody methodBody);
    public virtual IEnumerable`1<INamespaceScope> GetNamespaceScopes(IMethodBody methodBody);
    public virtual IEnumerable`1<ILocalDefinition> GetConstantsInScope(ILocalScope scope);
    public virtual IEnumerable`1<ILocalDefinition> GetVariablesInScope(ILocalScope scope);
    public virtual bool IsIterator(IMethodBody methodBody);
    public sealed virtual ISynchronizationInformation GetSynchronizationInformation(IMethodBody methodBody);
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGeneratorSourceInformationProvider/<GetPrimarySourceLocationsFor>d__7")]
public virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IEnumerable`1<ILocation> locations);
    [IteratorStateMachineAttribute("Microsoft.Cci.ILGeneratorSourceInformationProvider/<GetPrimarySourceLocationsFor>d__8")]
public virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(ILocation location);
    public virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsForDefinitionOf(ILocalDefinition localDefinition);
    public virtual string GetSourceNameFor(ILocalDefinition localDefinition, Boolean& isCompilerGenerated);
}
public class Microsoft.Cci.ILLocation : object {
    private IBinaryDocument binaryDocument;
    private IMethodDefinition methodDefinition;
    private UInt32 offset;
    private IMethodDefinition Microsoft.Cci.IILLocation.MethodDefinition { get; }
    private UInt32 Microsoft.Cci.IILLocation.Offset { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    public ILLocation(IBinaryDocument binaryDocument, IMethodDefinition methodDefinition, UInt32 offset);
    private sealed virtual override IMethodDefinition Microsoft.Cci.IILLocation.get_MethodDefinition();
    private sealed virtual override UInt32 Microsoft.Cci.IILLocation.get_Offset();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface Microsoft.Cci.ILocalDeclarationStatement {
    public IExpression InitialValue { get; }
    public ILocalDefinition LocalVariable { get; }
    public abstract virtual IExpression get_InitialValue();
    public abstract virtual ILocalDefinition get_LocalVariable();
}
internal abstract class Microsoft.Cci.ILocalDeclarationStatementContract : object {
    public IExpression InitialValue { get; }
    public ILocalDefinition LocalVariable { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_InitialValue();
    public sealed virtual ILocalDefinition get_LocalVariable();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ILocalDefinition {
    public IMetadataConstant CompileTimeValue { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public abstract virtual IMetadataConstant get_CompileTimeValue();
    public abstract virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual bool get_IsConstant();
    public abstract virtual bool get_IsModified();
    public abstract virtual bool get_IsPinned();
    public abstract virtual bool get_IsReference();
    public abstract virtual IMethodDefinition get_MethodDefinition();
    public abstract virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.ILocalDefinitionContract : object {
    public IMetadataConstant CompileTimeValue { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ILocalScope {
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public IMethodDefinition MethodDefinition { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual UInt32 get_Length();
    public abstract virtual IMethodDefinition get_MethodDefinition();
}
internal abstract class Microsoft.Cci.ILocalScopeContract : object {
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public IMethodDefinition MethodDefinition { get; }
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
    public sealed virtual IMethodDefinition get_MethodDefinition();
}
public interface Microsoft.Cci.ILocalScopeProvider {
    public abstract virtual IEnumerable`1<ILocalScope> GetIteratorScopes(IMethodBody methodBody);
    public abstract virtual IEnumerable`1<ILocalScope> GetLocalScopes(IMethodBody methodBody);
    public abstract virtual IEnumerable`1<INamespaceScope> GetNamespaceScopes(IMethodBody methodBody);
    public abstract virtual IEnumerable`1<ILocalDefinition> GetConstantsInScope(ILocalScope scope);
    public abstract virtual IEnumerable`1<ILocalDefinition> GetVariablesInScope(ILocalScope scope);
    public abstract virtual bool IsIterator(IMethodBody methodBody);
    public abstract virtual ISynchronizationInformation GetSynchronizationInformation(IMethodBody methodBody);
}
internal abstract class Microsoft.Cci.ILocalScopeProviderContract : object {
    public sealed virtual IEnumerable`1<ILocalScope> GetIteratorScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<ILocalScope> GetLocalScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<INamespaceScope> GetNamespaceScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<ILocalDefinition> GetConstantsInScope(ILocalScope scope);
    public sealed virtual IEnumerable`1<ILocalDefinition> GetVariablesInScope(ILocalScope scope);
    public sealed virtual bool IsIterator(IMethodBody methodBody);
    public sealed virtual ISynchronizationInformation GetSynchronizationInformation(IMethodBody methodBody);
}
public interface Microsoft.Cci.ILocation {
    public IDocument Document { get; }
    public abstract virtual IDocument get_Document();
}
internal abstract class Microsoft.Cci.ILocationContract : object {
    public IDocument Document { get; }
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.ILockStatement {
    public IStatement Body { get; }
    public IExpression Guard { get; }
    public abstract virtual IStatement get_Body();
    public abstract virtual IExpression get_Guard();
}
public interface Microsoft.Cci.ILogicalNot {
}
public class Microsoft.Cci.ILRewriter : object {
    protected IMetadataHost host;
    protected ILocalScopeProvider localScopeProvider;
    protected ISourceLocationProvider sourceLocationProvider;
    private ILGenerator generator;
    private Hashtable`1<ILGeneratorLabel> labelFor;
    private HashtableForUintValues`1<ILocalDefinition> localIndex;
    private List`1<ILocalDefinition> localVariables;
    private Stack`1<ILocalScope> scopeStack;
    private IEnumerator`1<ILocalScope> scopeEnumerator;
    private bool scopeEnumeratorIsValid;
    private IEnumerator`1<ILocalScope> iteratorScopeEnumerator;
    private bool iteratorScopeEnumeratorIsValid;
    private ISynchronizationInformation synchronizationInfo;
    private IEnumerator`1<ISynchronizationPoint> syncPointEnumerator;
    private bool syncPointEnumeratorIsValid;
    protected ushort maxStack;
    protected ILGenerator Generator { get; }
    protected IMetadataHost Host { get; }
    public ILRewriter(IMetadataHost host, ILocalScopeProvider localScopeProvider, ISourceLocationProvider sourceLocationProvider);
    private void ObjectInvariant();
    protected ILGenerator get_Generator();
    protected IMetadataHost get_Host();
    public virtual IMethodBody Rewrite(IMethodBody methodBody);
    protected virtual void EmitMethodBody(IMethodBody methodBody);
    protected virtual void EmitDebugInformationFor(IOperation operation);
    protected virtual void EmitOperation(IOperation operation);
    protected void TrackLocal(object operationValue);
    protected virtual ILGeneratorLabel GetLabelFor(UInt32 offset);
}
internal class Microsoft.Cci.ImageDebugDirectory : ValueType {
    internal int Characteristics;
    internal int TimeDateStamp;
    internal short MajorVersion;
    internal short MinorVersion;
    internal int Type;
    internal int SizeOfData;
    internal int AddressOfRawData;
    internal int PointerToRawData;
    internal ImageDebugDirectory(object dummy);
}
public interface Microsoft.Cci.IMakeTypedReference {
    public IExpression Operand { get; }
    public abstract virtual IExpression get_Operand();
}
public interface Microsoft.Cci.IManagedPointerType {
}
public interface Microsoft.Cci.IManagedPointerTypeReference {
    public ITypeReference TargetType { get; }
    public abstract virtual ITypeReference get_TargetType();
}
internal abstract class Microsoft.Cci.IManagedPointerTypeReferenceContract : object {
    public ITypeReference TargetType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ITypeReference get_TargetType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IMarshallingInformation {
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public UInt32 IidParameterIndex { get; }
    public UnmanagedType UnmanagedType { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    public abstract virtual ITypeReference get_CustomMarshaller();
    public abstract virtual string get_CustomMarshallerRuntimeArgument();
    public abstract virtual UnmanagedType get_ElementType();
    public abstract virtual UInt32 get_IidParameterIndex();
    public abstract virtual UnmanagedType get_UnmanagedType();
    public abstract virtual UInt32 get_NumberOfElements();
    public abstract virtual Nullable`1<UInt32> get_ParamIndex();
    public abstract virtual VarEnum get_SafeArrayElementSubtype();
    public abstract virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
public interface Microsoft.Cci.IMetadataConstant {
    public object Value { get; }
    public abstract virtual object get_Value();
}
public interface Microsoft.Cci.IMetadataConstantContainer {
    public IMetadataConstant Constant { get; }
    public abstract virtual IMetadataConstant get_Constant();
}
public interface Microsoft.Cci.IMetadataCreateArray {
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IMetadataExpression> Initializers { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    public abstract virtual ITypeReference get_ElementType();
    public abstract virtual IEnumerable`1<IMetadataExpression> get_Initializers();
    public abstract virtual IEnumerable`1<int> get_LowerBounds();
    public abstract virtual UInt32 get_Rank();
    public abstract virtual IEnumerable`1<ulong> get_Sizes();
}
internal abstract class Microsoft.Cci.IMetadataCreateArrayContract : object {
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IMetadataExpression> Initializers { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ITypeReference get_ElementType();
    public sealed virtual IEnumerable`1<IMetadataExpression> get_Initializers();
    public sealed virtual IEnumerable`1<int> get_LowerBounds();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual IEnumerable`1<ulong> get_Sizes();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IMetadataExpression {
    public ITypeReference Type { get; }
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.IMetadataExpressionContract : object {
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IMetadataHost {
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public AssemblyIdentity SystemCoreAssemblySymbolicIdentity { get; }
    public IInternFactory InternFactory { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<IUnit> LoadedUnits { get; }
    public INameTable NameTable { get; }
    public byte PointerSize { get; }
    public bool PreserveILLocations { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_Errors(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Errors(EventHandler`1<ErrorEventArgs> value);
    public abstract virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public abstract virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public abstract virtual AssemblyIdentity get_SystemCoreAssemblySymbolicIdentity();
    public abstract virtual IAssembly FindAssembly(AssemblyIdentity assemblyIdentity);
    public abstract virtual IModule FindModule(ModuleIdentity moduleIdentity);
    public abstract virtual IUnit FindUnit(UnitIdentity unitIdentity);
    public abstract virtual IInternFactory get_InternFactory();
    public abstract virtual IPlatformType get_PlatformType();
    public abstract virtual IAssembly LoadAssembly(AssemblyIdentity assemblyIdentity);
    public abstract virtual IModule LoadModule(ModuleIdentity moduleIdentity);
    public abstract virtual IUnit LoadUnit(UnitIdentity unitIdentity);
    public abstract virtual IUnit LoadUnitFrom(string location);
    public abstract virtual IEnumerable`1<IUnit> get_LoadedUnits();
    public abstract virtual INameTable get_NameTable();
    public abstract virtual byte get_PointerSize();
    public abstract virtual void ReportErrors(ErrorEventArgs errorEventArguments);
    public abstract virtual void ReportError(IErrorMessage error);
    public abstract virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public abstract virtual ModuleIdentity ProbeModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public abstract virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public abstract virtual AssemblyIdentity UnifyAssembly(IAssemblyReference assemblyReference);
    public abstract virtual bool get_PreserveILLocations();
}
internal abstract class Microsoft.Cci.IMetadataHostContract : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Errors;
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public AssemblyIdentity SystemCoreAssemblySymbolicIdentity { get; }
    public IInternFactory InternFactory { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<IUnit> LoadedUnits { get; }
    public INameTable NameTable { get; }
    public byte PointerSize { get; }
    public bool PreserveILLocations { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_Errors(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Errors(EventHandler`1<ErrorEventArgs> value);
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_SystemCoreAssemblySymbolicIdentity();
    public sealed virtual IAssembly FindAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule FindModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit FindUnit(UnitIdentity unitIdentity);
    public sealed virtual IInternFactory get_InternFactory();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IAssembly LoadAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule LoadModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit LoadUnit(UnitIdentity unitIdentity);
    public sealed virtual IUnit LoadUnitFrom(string location);
    public sealed virtual IEnumerable`1<IUnit> get_LoadedUnits();
    public sealed virtual INameTable get_NameTable();
    public sealed virtual byte get_PointerSize();
    public sealed virtual void ReportErrors(ErrorEventArgs errorEventArguments);
    public sealed virtual void ReportError(IErrorMessage error);
    public sealed virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public sealed virtual ModuleIdentity ProbeModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public sealed virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual AssemblyIdentity UnifyAssembly(IAssemblyReference assemblyReference);
    public sealed virtual bool get_PreserveILLocations();
}
public interface Microsoft.Cci.IMetadataLocation {
    public IMetadataObjectWithToken Definition { get; }
    public abstract virtual IMetadataObjectWithToken get_Definition();
}
internal abstract class Microsoft.Cci.IMetadataLocationContract : object {
    public IMetadataObjectWithToken Definition { get; }
    public IDocument Document { get; }
    public sealed virtual IMetadataObjectWithToken get_Definition();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IMetadataNamedArgument {
    public IName ArgumentName { get; }
    public IMetadataExpression ArgumentValue { get; }
    public bool IsField { get; }
    public object ResolvedDefinition { get; }
    public abstract virtual IName get_ArgumentName();
    public abstract virtual IMetadataExpression get_ArgumentValue();
    public abstract virtual bool get_IsField();
    public abstract virtual object get_ResolvedDefinition();
}
internal abstract class Microsoft.Cci.IMetadataNamedArgumentContract : object {
    public IName ArgumentName { get; }
    public IMetadataExpression ArgumentValue { get; }
    public bool IsField { get; }
    public object ResolvedDefinition { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IName get_ArgumentName();
    public sealed virtual IMetadataExpression get_ArgumentValue();
    public sealed virtual bool get_IsField();
    public sealed virtual object get_ResolvedDefinition();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IMetadataObjectWithToken {
    public UInt32 TokenValue { get; }
    public abstract virtual UInt32 get_TokenValue();
}
public interface Microsoft.Cci.IMetadataReaderErrorsReporter {
}
public interface Microsoft.Cci.IMetadataReaderHost {
    public abstract virtual IBinaryDocumentMemoryBlock OpenBinaryDocument(IBinaryDocument sourceDocument);
    public abstract virtual IBinaryDocumentMemoryBlock OpenBinaryDocument(IBinaryDocument parentSourceDocument, string childDocumentName);
    public abstract virtual IEnumerable`1<IAssemblyReference> Redirect(IUnit referringUnit, IEnumerable`1<IAssemblyReference> assemblyReferences);
    public abstract virtual INamedTypeReference Redirect(IUnit referringUnit, INamedTypeReference typeReference);
    public abstract virtual ICustomAttribute Rewrite(IUnit containingUnit, ICustomAttribute customAttribute);
    public abstract virtual IMethodDefinition Rewrite(IUnit containingUnit, IMethodDefinition methodDefinition);
    public abstract virtual void ResolvingAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public abstract virtual void ResolvingModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public abstract virtual void StartGuessingGame();
    public abstract virtual bool TryNextPermutation();
    public abstract virtual void WinGuessingGame();
    public abstract virtual byte GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(ITypeReference reference);
}
internal abstract class Microsoft.Cci.IMetadataReaderHostContract : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Errors;
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public AssemblyIdentity SystemCoreAssemblySymbolicIdentity { get; }
    public IInternFactory InternFactory { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<IUnit> LoadedUnits { get; }
    public INameTable NameTable { get; }
    public byte PointerSize { get; }
    public bool PreserveILLocations { get; }
    public sealed virtual IBinaryDocumentMemoryBlock OpenBinaryDocument(IBinaryDocument sourceDocument);
    public sealed virtual IBinaryDocumentMemoryBlock OpenBinaryDocument(IBinaryDocument parentSourceDocument, string childDocumentName);
    public sealed virtual IEnumerable`1<IAssemblyReference> Redirect(IUnit referringUnit, IEnumerable`1<IAssemblyReference> assemblyReferences);
    public sealed virtual INamedTypeReference Redirect(IUnit referringUnit, INamedTypeReference typeReference);
    public sealed virtual ICustomAttribute Rewrite(IUnit containingUnit, ICustomAttribute customAttribute);
    public sealed virtual IMethodDefinition Rewrite(IUnit containingUnit, IMethodDefinition methodDefinition);
    public sealed virtual void ResolvingAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public sealed virtual void ResolvingModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public sealed virtual void StartGuessingGame();
    public sealed virtual bool TryNextPermutation();
    public sealed virtual void WinGuessingGame();
    public sealed virtual byte GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(ITypeReference reference);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Errors(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Errors(EventHandler`1<ErrorEventArgs> value);
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_SystemCoreAssemblySymbolicIdentity();
    public sealed virtual IAssembly FindAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule FindModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit FindUnit(UnitIdentity unitIdentity);
    public sealed virtual IInternFactory get_InternFactory();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IAssembly LoadAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule LoadModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit LoadUnit(UnitIdentity unitIdentity);
    public sealed virtual IUnit LoadUnitFrom(string location);
    public sealed virtual IEnumerable`1<IUnit> get_LoadedUnits();
    public sealed virtual INameTable get_NameTable();
    public sealed virtual byte get_PointerSize();
    public sealed virtual void ReportErrors(ErrorEventArgs errorEventArguments);
    public sealed virtual void ReportError(IErrorMessage error);
    public sealed virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public sealed virtual ModuleIdentity ProbeModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public sealed virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual AssemblyIdentity UnifyAssembly(IAssemblyReference assemblyReference);
    public sealed virtual bool get_PreserveILLocations();
}
public interface Microsoft.Cci.IMetadataTypeOf {
    public ITypeReference TypeToGet { get; }
    public abstract virtual ITypeReference get_TypeToGet();
}
public interface Microsoft.Cci.IMetadataVisitor {
    public abstract virtual void Visit(IArrayTypeReference arrayTypeReference);
    public abstract virtual void Visit(IAssembly assembly);
    public abstract virtual void Visit(IAssemblyReference assemblyReference);
    public abstract virtual void Visit(ICustomAttribute customAttribute);
    public abstract virtual void Visit(ICustomModifier customModifier);
    public abstract virtual void Visit(IEventDefinition eventDefinition);
    public abstract virtual void Visit(IFieldDefinition fieldDefinition);
    public abstract virtual void Visit(IFieldReference fieldReference);
    public abstract virtual void Visit(IFileReference fileReference);
    public abstract virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public abstract virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public abstract virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public abstract virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public abstract virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public abstract virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public abstract virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public abstract virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public abstract virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public abstract virtual void Visit(ILocalDefinition localDefinition);
    public abstract virtual void VisitReference(ILocalDefinition localDefinition);
    public abstract virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public abstract virtual void Visit(IMarshallingInformation marshallingInformation);
    public abstract virtual void Visit(IMetadataConstant constant);
    public abstract virtual void Visit(IMetadataCreateArray createArray);
    public abstract virtual void Visit(IMetadataExpression expression);
    public abstract virtual void Visit(IMetadataNamedArgument namedArgument);
    public abstract virtual void Visit(IMetadataTypeOf typeOf);
    public abstract virtual void Visit(IMethodBody methodBody);
    public abstract virtual void Visit(IMethodDefinition method);
    public abstract virtual void Visit(IMethodImplementation methodImplementation);
    public abstract virtual void Visit(IMethodReference methodReference);
    public abstract virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public abstract virtual void Visit(IModule module);
    public abstract virtual void Visit(IModuleReference moduleReference);
    public abstract virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public abstract virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public abstract virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public abstract virtual void Visit(INestedAliasForType nestedAliasForType);
    public abstract virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public abstract virtual void Visit(INestedTypeReference nestedTypeReference);
    public abstract virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public abstract virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public abstract virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public abstract virtual void Visit(IOperation operation);
    public abstract virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public abstract virtual void Visit(IParameterDefinition parameterDefinition);
    public abstract virtual void VisitReference(IParameterDefinition parameterDefinition);
    public abstract virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public abstract virtual void Visit(IPESection peSection);
    public abstract virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public abstract virtual void Visit(IPointerTypeReference pointerTypeReference);
    public abstract virtual void Visit(IPropertyDefinition propertyDefinition);
    public abstract virtual void Visit(IResourceReference resourceReference);
    public abstract virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public abstract virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public abstract virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public abstract virtual void Visit(ISecurityAttribute securityAttribute);
    public abstract virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public abstract virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public abstract virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public abstract virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public abstract virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public abstract virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public abstract virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public abstract virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public abstract virtual void Visit(IUnitSet unitSet);
    public abstract virtual void Visit(IWin32Resource win32Resource);
}
internal abstract class Microsoft.Cci.IMetadataVisitorContract : object {
    public sealed virtual void Visit(IArrayTypeReference arrayTypeReference);
    public sealed virtual void Visit(IAssembly assembly);
    public sealed virtual void Visit(IAssemblyReference assemblyReference);
    public sealed virtual void Visit(ICustomAttribute customAttribute);
    public sealed virtual void Visit(ICustomModifier customModifier);
    public sealed virtual void Visit(IEventDefinition eventDefinition);
    public sealed virtual void Visit(IFieldDefinition fieldDefinition);
    public sealed virtual void Visit(IFieldReference fieldReference);
    public sealed virtual void Visit(IFileReference fileReference);
    public sealed virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public sealed virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public sealed virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public sealed virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public sealed virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public sealed virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public sealed virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public sealed virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public sealed virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public sealed virtual void Visit(ILocalDefinition localDefinition);
    public sealed virtual void VisitReference(ILocalDefinition localDefinition);
    public sealed virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public sealed virtual void Visit(IMarshallingInformation marshallingInformation);
    public sealed virtual void Visit(IMetadataConstant constant);
    public sealed virtual void Visit(IMetadataCreateArray createArray);
    public sealed virtual void Visit(IMetadataExpression expression);
    public sealed virtual void Visit(IMetadataNamedArgument namedArgument);
    public sealed virtual void Visit(IMetadataTypeOf typeOf);
    public sealed virtual void Visit(IMethodBody methodBody);
    public sealed virtual void Visit(IMethodDefinition method);
    public sealed virtual void Visit(IMethodImplementation methodImplementation);
    public sealed virtual void Visit(IMethodReference methodReference);
    public sealed virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public sealed virtual void Visit(IModule module);
    public sealed virtual void Visit(IModuleReference moduleReference);
    public sealed virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public sealed virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public sealed virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public sealed virtual void Visit(INestedAliasForType nestedAliasForType);
    public sealed virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public sealed virtual void Visit(INestedTypeReference nestedTypeReference);
    public sealed virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public sealed virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public sealed virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public sealed virtual void Visit(IOperation operation);
    public sealed virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public sealed virtual void Visit(IParameterDefinition parameterDefinition);
    public sealed virtual void VisitReference(IParameterDefinition parameterDefinition);
    public sealed virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public sealed virtual void Visit(IPESection peSection);
    public sealed virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public sealed virtual void Visit(IPointerTypeReference pointerTypeReference);
    public sealed virtual void Visit(IPropertyDefinition propertyDefinition);
    public sealed virtual void Visit(IResourceReference resourceReference);
    public sealed virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public sealed virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public sealed virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public sealed virtual void Visit(ISecurityAttribute securityAttribute);
    public sealed virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public sealed virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public sealed virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public sealed virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public sealed virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public sealed virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public sealed virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public sealed virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public sealed virtual void Visit(IUnitSet unitSet);
    public sealed virtual void Visit(IWin32Resource win32Resource);
}
public interface Microsoft.Cci.IMethodBody {
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public bool LocalsAreZeroed { get; }
    public IEnumerable`1<ILocalDefinition> LocalVariables { get; }
    public IMethodDefinition MethodDefinition { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public ushort MaxStack { get; }
    public IEnumerable`1<ITypeDefinition> PrivateHelperTypes { get; }
    public UInt32 Size { get; }
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public abstract virtual bool get_LocalsAreZeroed();
    public abstract virtual IEnumerable`1<ILocalDefinition> get_LocalVariables();
    public abstract virtual IMethodDefinition get_MethodDefinition();
    public abstract virtual IEnumerable`1<IOperation> get_Operations();
    public abstract virtual ushort get_MaxStack();
    public abstract virtual IEnumerable`1<ITypeDefinition> get_PrivateHelperTypes();
    public abstract virtual UInt32 get_Size();
}
internal abstract class Microsoft.Cci.IMethodBodyContract : object {
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public bool LocalsAreZeroed { get; }
    public IEnumerable`1<ILocalDefinition> LocalVariables { get; }
    public IMethodDefinition MethodDefinition { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public ushort MaxStack { get; }
    public IEnumerable`1<ITypeDefinition> PrivateHelperTypes { get; }
    public UInt32 Size { get; }
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public sealed virtual bool get_LocalsAreZeroed();
    public sealed virtual IEnumerable`1<ILocalDefinition> get_LocalVariables();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual IEnumerable`1<IOperation> get_Operations();
    public sealed virtual ushort get_MaxStack();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_PrivateHelperTypes();
    public sealed virtual UInt32 get_Size();
}
public interface Microsoft.Cci.IMethodCall {
    public IEnumerable`1<IExpression> Arguments { get; }
    public bool IsJumpCall { get; }
    public bool IsVirtualCall { get; }
    public bool IsStaticCall { get; }
    public bool IsTailCall { get; }
    public IMethodReference MethodToCall { get; }
    public IExpression ThisArgument { get; }
    public abstract virtual IEnumerable`1<IExpression> get_Arguments();
    public abstract virtual bool get_IsJumpCall();
    public abstract virtual bool get_IsVirtualCall();
    public abstract virtual bool get_IsStaticCall();
    public abstract virtual bool get_IsTailCall();
    public abstract virtual IMethodReference get_MethodToCall();
    public abstract virtual IExpression get_ThisArgument();
}
internal abstract class Microsoft.Cci.IMethodCallContract : object {
    public IEnumerable`1<IExpression> Arguments { get; }
    public bool IsJumpCall { get; }
    public bool IsVirtualCall { get; }
    public bool IsStaticCall { get; }
    public bool IsTailCall { get; }
    public IMethodReference MethodToCall { get; }
    public IExpression ThisArgument { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IExpression> get_Arguments();
    public sealed virtual bool get_IsJumpCall();
    public sealed virtual bool get_IsVirtualCall();
    public sealed virtual bool get_IsStaticCall();
    public sealed virtual bool get_IsTailCall();
    public sealed virtual IMethodReference get_MethodToCall();
    public sealed virtual IExpression get_ThisArgument();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IMethodDefinition {
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsCil { get; }
    public bool IsConstructor { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStaticConstructor { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public bool PreserveSignature { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public abstract virtual IMethodBody get_Body();
    public abstract virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual bool get_HasExplicitThisParameter();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsAccessCheckedOnOverride();
    public abstract virtual bool get_IsAggressivelyInlined();
    public abstract virtual bool get_IsCil();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsExternal();
    public abstract virtual bool get_IsForwardReference();
    public abstract virtual bool get_IsHiddenBySignature();
    public abstract virtual bool get_IsNativeCode();
    public abstract virtual bool get_IsNewSlot();
    public abstract virtual bool get_IsNeverInlined();
    public abstract virtual bool get_IsNeverOptimized();
    public abstract virtual bool get_IsPlatformInvoke();
    public abstract virtual bool get_IsRuntimeImplemented();
    public abstract virtual bool get_IsRuntimeInternal();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStaticConstructor();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsUnmanaged();
    public abstract virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public abstract virtual bool get_PreserveSignature();
    public abstract virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public abstract virtual bool get_RequiresSecurityObject();
    public abstract virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public abstract virtual bool get_ReturnValueIsMarshalledExplicitly();
    public abstract virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public abstract virtual IName get_ReturnValueName();
    public abstract virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
}
internal abstract class Microsoft.Cci.IMethodDefinitionContract : object {
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsConstructor { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStaticConstructor { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public bool PreserveSignature { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public sealed virtual IMethodBody get_Body();
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public sealed virtual IName get_ReturnValueName();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IMethodImplementation {
    public ITypeDefinition ContainingType { get; }
    public IMethodReference ImplementedMethod { get; }
    public IMethodReference ImplementingMethod { get; }
    public abstract virtual ITypeDefinition get_ContainingType();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual IMethodReference get_ImplementedMethod();
    public abstract virtual IMethodReference get_ImplementingMethod();
}
internal abstract class Microsoft.Cci.IMethodImplementationContract : object {
    public ITypeDefinition ContainingType { get; }
    public IMethodReference ImplementedMethod { get; }
    public IMethodReference ImplementingMethod { get; }
    public sealed virtual ITypeDefinition get_ContainingType();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_ImplementedMethod();
    public sealed virtual IMethodReference get_ImplementingMethod();
}
public interface Microsoft.Cci.IMethodReference {
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public abstract virtual bool get_AcceptsExtraArguments();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual UInt32 get_InternedKey();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual ushort get_ParameterCount();
    public abstract virtual IMethodDefinition get_ResolvedMethod();
    public abstract virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
}
internal abstract class Microsoft.Cci.IMethodReferenceContract : object {
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public abstract class Microsoft.Cci.Immutable.AggregatedNamespace`2 : AggregatedScope`3<INamespaceMember, ContainerType, ContainerMemberType> {
    private IName name;
    private IEnumerable`1<INamespaceMember> Microsoft.Cci.IContainer<Microsoft.Cci.INamespaceMember>.Members { get; }
    private IEnumerable`1<INamespaceMember> Microsoft.Cci.INamespaceDefinition.Members { get; }
    public IName Name { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    protected AggregatedNamespace`2(IName name);
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<INamespaceMember> Microsoft.Cci.IContainer<Microsoft.Cci.INamespaceMember>.get_Members();
    private sealed virtual override IEnumerable`1<INamespaceMember> Microsoft.Cci.INamespaceDefinition.get_Members();
    public sealed virtual IName get_Name();
    public abstract virtual INamespaceRootOwner get_RootOwner();
    public abstract virtual IEnumerable`1<ILocation> get_Locations();
    public virtual IEnumerable`1<ICustomAttribute> get_Attributes();
}
public abstract class Microsoft.Cci.Immutable.AggregatedScope`3 : Scope`1<ScopeMemberType> {
    private void AddContainerMemberToCache(ContainerMemberType member);
    protected virtual void AddContainer(ContainerType container);
    protected abstract virtual ScopeMemberType GetAggregatedMember(ContainerMemberType member);
}
public abstract class Microsoft.Cci.Immutable.ArrayType : SystemDefinedStructuralType {
    private ITypeReference elementType;
    private IEnumerable`1<ITypeReference> interfaces;
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public ITypeReference ElementType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsVector { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IPlatformType PlatformType { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    private IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.BaseClasses { get; }
    private IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IContainer<Microsoft.Cci.ITypeDefinitionMember>.Members { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.Members { get; }
    internal ArrayType(ITypeReference elementType, IInternFactory internFactory);
    public virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public virtual bool Contains(ITypeDefinitionMember member);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_ElementType();
    protected virtual IEnumerable`1<ITypeReference> GetInterfaceList();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.ArrayType/<GetMatchingMembersNamed>d__10")]
public virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.ArrayType/<GetMatchingMembers>d__11")]
public virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.ArrayType/<GetMembersNamed>d__12")]
public virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsVector();
    public virtual IEnumerable`1<int> get_LowerBounds();
    public virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public virtual IPlatformType get_PlatformType();
    public virtual UInt32 get_Rank();
    public virtual IEnumerable`1<ulong> get_Sizes();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.get_BaseClasses();
    private sealed virtual override IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IContainer<Microsoft.Cci.ITypeDefinitionMember>.get_Members();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.GetMembersNamed(IName name, bool ignoreCase);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.get_Members();
}
public class Microsoft.Cci.Immutable.AssemblyReference : object {
    private AssemblyIdentity assemblyIdentity;
    private IMetadataHost host;
    private bool isRetargetable;
    private bool containsForeignTypes;
    private IAssembly resolvedAssembly;
    private AssemblyIdentity unifiedAssemblyIdentity;
    public IEnumerable`1<IName> Aliases { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IAssemblyReference ContainingAssembly { get; }
    public string Culture { get; }
    public bool IsRetargetable { get; }
    public bool ContainsForeignTypes { get; }
    public IEnumerable`1<byte> HashValue { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IName Name { get; }
    public IEnumerable`1<byte> PublicKey { get; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public IAssembly ResolvedAssembly { get; }
    public IModule ResolvedModule { get; }
    public IUnit ResolvedUnit { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public UnitIdentity UnitIdentity { get; }
    public Version Version { get; }
    public AssemblyReference(IMetadataHost host, AssemblyIdentity assemblyIdentity, bool isRetargetable, bool containsForeignTypes);
    public sealed virtual IEnumerable`1<IName> get_Aliases();
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public sealed virtual string get_Culture();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual bool get_ContainsForeignTypes();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<byte> get_PublicKey();
    public sealed virtual IEnumerable`1<byte> get_PublicKeyToken();
    public sealed virtual IAssembly get_ResolvedAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual Version get_Version();
}
public abstract class Microsoft.Cci.Immutable.BaseTypeReference : object {
    protected IMetadataHost host;
    private bool isEnum;
    private bool isValueType;
    public IAliasForType AliasForType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    protected BaseTypeReference(IMetadataHost host, bool isEnum, bool isValueType);
    public abstract virtual IAliasForType get_AliasForType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public abstract virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    protected abstract virtual ITypeDefinition Resolve();
    public virtual PrimitiveTypeCode get_TypeCode();
}
public class Microsoft.Cci.Immutable.CustomModifier : object {
    private bool isOptional;
    private ITypeReference modifier;
    public bool IsOptional { get; }
    public ITypeReference Modifier { get; }
    public CustomModifier(bool isOptional, ITypeReference modifier);
    public sealed virtual bool get_IsOptional();
    public sealed virtual ITypeReference get_Modifier();
    internal static ICustomModifier CopyModifierToNewContainer(ICustomModifier customModifier, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ICustomModifier Specialize(ICustomModifier customModifier, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ICustomModifier Specialize(ICustomModifier customModifier, IMethodReference targetContainer, IInternFactory internFactory);
    public static ICustomModifier SpecializeIfConstructedFromApplicableTypeParameter(ICustomModifier customModifier, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ICustomModifier SpecializeIfConstructedFromApplicableTypeParameter(ICustomModifier customModifier, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ICustomModifier SpecializeIfConstructedFromApplicableMethodTypeParameter(ICustomModifier customModifier, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
}
internal class Microsoft.Cci.Immutable.DummyArrayMethodParameter : object {
    private ISignature containingSignature;
    private ushort index;
    private ITypeReference type;
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ushort Index { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    internal DummyArrayMethodParameter(ISignature containingSignature, ushort index, ITypeReference type);
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ushort get_Index();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
}
public class Microsoft.Cci.Immutable.DummyArrayMethodReference : object {
    private IArrayTypeReference arrayType;
    private OperationCode arrayOperation;
    private IPlatformType platformType;
    private IName name;
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public ushort ParameterCount { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public UInt32 InternedKey { get; }
    public DummyArrayMethodReference(IArrayTypeReference arrayType, OperationCode arrayOperation, IMetadataHost host);
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.DummyArrayMethodReference/<get_Parameters>d__21")]
public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual UInt32 get_InternedKey();
}
public class Microsoft.Cci.Immutable.FunctionPointerType : SystemDefinedStructuralType {
    private CallingConvention callingConvention;
    private IEnumerable`1<IParameterTypeInformation> extraArgumentTypes;
    private IEnumerable`1<IParameterTypeInformation> parameters;
    private IEnumerable`1<ICustomModifier> returnValueCustomModifiers;
    private bool returnValueIsByRef;
    private ITypeReference type;
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraArgumentTypes { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public PrimitiveTypeCode TypeCode { get; }
    private bool Microsoft.Cci.ISignature.IsStatic { get; }
    private ITypeReference Microsoft.Cci.ISignature.Type { get; }
    public FunctionPointerType(ISignature signature, IInternFactory internFactory);
    public FunctionPointerType(CallingConvention callingConvention, bool returnValueIsByRef, ITypeReference type, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IInternFactory internFactory);
    public sealed virtual CallingConvention get_CallingConvention();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraArgumentTypes();
    public virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public ITypeReference get_Type();
    public virtual PrimitiveTypeCode get_TypeCode();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_IsStatic();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.get_Type();
}
public class Microsoft.Cci.Immutable.GenericMethodInstance : object {
    private IMethodBody body;
    private IEnumerable`1<ITypeReference> genericArguments;
    private IMethodDefinition genericMethod;
    private ITypeReference type;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    public IMethodBody Body { get; }
    public CallingConvention CallingConvention { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public IMethodDefinition GenericMethod { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ushort ParameterCount { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public bool ReturnValueIsModified { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public ITypeReference Type { get; }
    public TypeMemberVisibility Visibility { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool AcceptsExtraArguments { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public IInternFactory InternFactory { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSynchronized { get; }
    public bool IsUnmanaged { get; }
    public bool IsVirtual { get; }
    public bool PreserveSignature { get; }
    public bool RequiresSecurityObject { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public bool IsConstructor { get; }
    public bool IsStaticConstructor { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public UInt32 InternedKey { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodInstanceReference.GenericMethod { get; }
    public GenericMethodInstance(IMethodDefinition genericMethod, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory);
    public sealed virtual IMethodBody get_Body();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public IMethodDefinition get_GenericMethod();
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.GenericMethodInstance/<get_Parameters>d__21")]
public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public IInternFactory get_InternFactory();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual IName get_ReturnValueName();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsStaticConstructor();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodInstanceReference.get_GenericMethod();
}
public class Microsoft.Cci.Immutable.GenericMethodInstanceReference : object {
    private IEnumerable`1<ITypeReference> genericArguments;
    private IMethodReference genericMethod;
    private ITypeReference type;
    private IInternFactory internFactory;
    private IMethodDefinition resolvedMethod;
    private UInt32 internedKey;
    public bool AcceptsExtraArguments { get; }
    public CallingConvention CallingConvention { get; }
    public ITypeReference ContainingType { get; }
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public IMethodReference GenericMethod { get; }
    public ushort GenericParameterCount { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public ushort ParameterCount { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public IInternFactory InternFactory { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public UInt32 InternedKey { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public GenericMethodInstanceReference(IMethodReference genericMethod, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory);
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public sealed virtual IMethodReference get_GenericMethod();
    public sealed virtual ushort get_GenericParameterCount();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.GenericMethodInstanceReference/<get_Parameters>d__18")]
public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    public IInternFactory get_InternFactory();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
public class Microsoft.Cci.Immutable.GenericMethodParameterReference : object {
    private IMetadataHost host;
    private IMethodReference definingMethod;
    private IGenericMethodParameter resolvedType;
    private IName name;
    private ushort index;
    public IMethodReference DefiningMethod { get; public set; }
    public IGenericMethodParameter ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ushort Index { get; }
    public GenericMethodParameterReference(IName name, ushort index, IMetadataHost host);
    public GenericMethodParameterReference(IName name, ushort index, IMethodReference definingMethod, IMetadataHost host);
    public sealed virtual IMethodReference get_DefiningMethod();
    public void set_DefiningMethod(IMethodReference value);
    public sealed virtual IGenericMethodParameter get_ResolvedType();
    private void Resolve();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
}
internal static class Microsoft.Cci.Immutable.GenericParameter : object {
    public static ITypeReference DeepCopyTypeReference(IGenericTypeParameterReference genericTypeParameter, SpecializedNestedTypeDefinition targetContainer);
    internal static ITypeReference SpecializeTypeReference(IGenericTypeParameterReference genericTypeParameter, ITypeReference targetContainer);
    internal static ITypeReference SpecializeTypeReference(IGenericTypeParameterReference genericTypeParameter, IMethodReference targetContainer);
    internal static ITypeReference SpecializeTypeReference(IGenericMethodParameterReference genericMethodParameter, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IGenericMethodParameterReference genericMethodParameter, IGenericMethodInstanceReference containingMethodInstance);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IGenericTypeParameterReference genericTypeParameter, IGenericTypeInstanceReference containingTypeInstance);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IGenericMethodParameterReference genericMethodParameter, ISpecializedMethodReference specializedMethodReference);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IGenericTypeParameterReference genericTypeParameter, ISpecializedMethodReference specializedMethodReference);
}
public class Microsoft.Cci.Immutable.GenericTypeInstance : Scope`1<ITypeDefinitionMember> {
    private IEnumerable`1<IEventDefinition> events;
    private IEnumerable`1<IFieldDefinition> fields;
    private IEnumerable`1<ITypeReference> genericArguments;
    private INamedTypeReference genericType;
    private bool initialized;
    private IEnumerable`1<IMethodDefinition> methods;
    private IEnumerable`1<INestedTypeDefinition> nestedTypes;
    private IEnumerable`1<IPropertyDefinition> properties;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    public ushort Alignment { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public INamedTypeReference GenericType { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public UInt32 SizeOf { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public ITypeReference UnderlyingType { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    private IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.ITypeDefinition.Members { get; }
    private IEnumerable`1<ISecurityAttribute> Microsoft.Cci.ITypeDefinition.SecurityAttributes { get; }
    private IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IContainer<Microsoft.Cci.ITypeDefinitionMember>.Members { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public IInternFactory InternFactory { get; }
    public UInt32 InternedKey { get; }
    private GenericTypeInstance(INamedTypeDefinition genericType, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory);
    public static GenericTypeInstance GetGenericTypeInstance(INamedTypeDefinition genericType, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory);
    public sealed virtual ushort get_Alignment();
    public virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.GenericTypeInstance/<get_BaseClasses>d__7")]
public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.GenericTypeInstance/<get_ExplicitImplementationOverrides>d__19")]
public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public sealed virtual INamedTypeReference get_GenericType();
    protected virtual void InitializeIfNecessary();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.GenericTypeInstance/<get_Interfaces>d__31")]
public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    internal static ITypeReference DeepCopyTypeReference(IGenericTypeInstanceReference genericTypeInstance, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IGenericTypeInstanceReference genericTypeInstance, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IGenericTypeInstanceReference genericTypeInstance, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IGenericTypeInstanceReference genericTypeInstance, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IGenericTypeInstanceReference genericTypeInstance, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IGenericTypeInstanceReference genericTypeInstance, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    public ITypeDefinitionMember SpecializeMember(ITypeDefinitionMember unspecializedMember, IInternFactory internFactory);
    public sealed virtual UInt32 get_SizeOf();
    public virtual string ToString();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    private sealed virtual override IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.ITypeDefinition.get_Members();
    private sealed virtual override IEnumerable`1<ISecurityAttribute> Microsoft.Cci.ITypeDefinition.get_SecurityAttributes();
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IContainer<Microsoft.Cci.ITypeDefinitionMember>.get_Members();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public IInternFactory get_InternFactory();
    public sealed virtual UInt32 get_InternedKey();
}
public class Microsoft.Cci.Immutable.GenericTypeInstanceReference : object {
    private IEnumerable`1<ITypeReference> genericArguments;
    private INamedTypeReference genericType;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    private ITypeDefinition resolvedType;
    public IEnumerable`1<ITypeReference> GenericArguments { get; }
    public INamedTypeReference GenericType { get; }
    public IAliasForType AliasForType { get; }
    public IInternFactory InternFactory { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    internal GenericTypeInstanceReference(INamedTypeReference genericType, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory, bool cached);
    public GenericTypeInstanceReference(INamedTypeReference genericType, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory);
    internal static IGenericTypeInstanceReference GetOrMake(INamedTypeReference genericType, IEnumerable`1<ITypeReference> arguments, IInternFactory internFactory);
    public sealed virtual IEnumerable`1<ITypeReference> get_GenericArguments();
    public sealed virtual INamedTypeReference get_GenericType();
    public sealed virtual IAliasForType get_AliasForType();
    public IInternFactory get_InternFactory();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public virtual string ToString();
    public virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual IEnumerable`1<ILocation> get_Locations();
}
public class Microsoft.Cci.Immutable.ManagedPointerType : SystemDefinedStructuralType {
    private ITypeReference targetType;
    public IPlatformType PlatformType { get; }
    public ITypeReference TargetType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    protected ManagedPointerType(ITypeReference targetType, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public static ManagedPointerType GetManagedPointerType(ITypeReference targetType, IInternFactory internFactory);
    public virtual IPlatformType get_PlatformType();
    internal static ITypeReference DeepCopyTypeReference(IManagedPointerTypeReference pointer, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IManagedPointerTypeReference pointer, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IManagedPointerTypeReference pointer, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IManagedPointerTypeReference pointer, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IManagedPointerTypeReference pointer, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IManagedPointerTypeReference pointer, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    public sealed virtual ITypeReference get_TargetType();
    public virtual PrimitiveTypeCode get_TypeCode();
}
public class Microsoft.Cci.Immutable.Matrix : ArrayType {
    private IEnumerable`1<int> lowerBounds;
    private UInt32 rank;
    private IEnumerable`1<ulong> sizes;
    public bool IsVector { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    protected Matrix(ITypeReference elementType, UInt32 rank, IEnumerable`1<int> lowerBounds, IEnumerable`1<ulong> sizes, IInternFactory internFactory);
    public static Matrix GetMatrix(ITypeReference elementType, UInt32 rank, IInternFactory internFactory);
    public static Matrix GetMatrix(ITypeReference elementType, UInt32 rank, IEnumerable`1<int> lowerBounds, IEnumerable`1<ulong> sizes, IInternFactory internFactory);
    public virtual bool get_IsVector();
    public virtual IEnumerable`1<int> get_LowerBounds();
    public virtual UInt32 get_Rank();
    public virtual IEnumerable`1<ulong> get_Sizes();
    internal static ITypeReference DeepCopyTypeReference(IArrayTypeReference array, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IArrayTypeReference array, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IArrayTypeReference array, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IArrayTypeReference array, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IArrayTypeReference array, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IArrayTypeReference array, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
}
public class Microsoft.Cci.Immutable.ModifiedPointerType : PointerType {
    private IEnumerable`1<ICustomModifier> customModifiers;
    public bool IsModified { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    private ModifiedPointerType(ITypeReference targetType, IEnumerable`1<ICustomModifier> customModifiers, IInternFactory internFactory);
    public virtual bool get_IsModified();
    internal static ITypeReference DeepCopyTypeReference(ModifiedPointerType modifiedPointer, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(ModifiedPointerType modifiedPointer, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(ModifiedPointerType modifiedPointer, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(ModifiedPointerType modifiedPointer, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(ModifiedPointerType modifiedPointer, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(ModifiedPointerType modifiedPointer, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    public static ModifiedPointerType GetModifiedPointerType(ITypeReference targetType, IEnumerable`1<ICustomModifier> customModifiers, IInternFactory internFactory);
    public virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ITypeReference get_UnmodifiedType();
}
public class Microsoft.Cci.Immutable.ModifiedTypeReference : object {
    private IInternFactory internFactory;
    private IEnumerable`1<ICustomModifier> customModifiers;
    private ITypeReference unmodifiedType;
    private UInt32 internedKey;
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    private ModifiedTypeReference(IInternFactory internFactory, ITypeReference unmodifiedType, IEnumerable`1<ICustomModifier> customModifiers);
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ITypeReference get_UnmodifiedType();
    public static ModifiedTypeReference GetModifiedTypeReference(ITypeReference unmodifiedType, IEnumerable`1<ICustomModifier> customModifiers, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReference(IModifiedTypeReference modifiedTypeReference, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IModifiedTypeReference modifiedTypeReference, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IModifiedTypeReference modifiedTypeReference, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IModifiedTypeReference modifiedTypeReference, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IModifiedTypeReference modifiedTypeReference, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IModifiedTypeReference modifiedTypeReference, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public class Microsoft.Cci.Immutable.ModuleReference : object {
    private IMetadataHost host;
    private ModuleIdentity moduleIdentity;
    private IModule resolvedModule;
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IAssemblyReference ContainingAssembly { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IName Name { get; }
    public IModule ResolvedModule { get; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public ModuleReference(IMetadataHost host, ModuleIdentity moduleIdentity);
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IName get_Name();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
}
public class Microsoft.Cci.Immutable.NamespaceTypeReference : BaseTypeReference {
    private IAliasForType aliasForType;
    private IUnitNamespaceReference containingUnitNamespace;
    private ushort genericParameterCount;
    private UInt32 internedKey;
    private IName name;
    private INamespaceTypeDefinition resolvedType;
    private PrimitiveTypeCode typeCode;
    private bool mangleName;
    public IAliasForType AliasForType { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public IName Name { get; }
    public INamespaceTypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public NamespaceTypeReference(IMetadataHost host, IUnitNamespaceReference containingUnitNamespace, IName name, ushort genericParameterCount, bool isEnum, bool isValueType, bool mangleName, PrimitiveTypeCode typeCode);
    public virtual IAliasForType get_AliasForType();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ushort get_GenericParameterCount();
    public virtual UInt32 get_InternedKey();
    public sealed virtual IName get_Name();
    public sealed virtual INamespaceTypeDefinition get_ResolvedType();
    private INamespaceTypeDefinition GetResolvedType();
    protected virtual ITypeDefinition Resolve();
    public virtual string ToString();
    public virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
}
public class Microsoft.Cci.Immutable.NestedTypeReference : BaseTypeReference {
    private IAliasForType aliasForType;
    private ITypeReference containingType;
    private ushort genericParameterCount;
    private UInt32 internedKey;
    private bool mangleName;
    private IName name;
    private INestedTypeDefinition resolvedType;
    public IAliasForType AliasForType { get; }
    public ITypeReference ContainingType { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool MangleName { get; }
    public IName Name { get; }
    public INestedTypeDefinition ResolvedType { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    private ITypeDefinitionMember Microsoft.Cci.ITypeMemberReference.ResolvedTypeDefinitionMember { get; }
    public NestedTypeReference(IMetadataHost host, ITypeReference containingType, IName name, ushort genericParameterCount, bool isEnum, bool isValueType, bool mangleName);
    public virtual IAliasForType get_AliasForType();
    public sealed virtual ITypeReference get_ContainingType();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ushort get_GenericParameterCount();
    public virtual UInt32 get_InternedKey();
    public sealed virtual bool get_MangleName();
    public sealed virtual IName get_Name();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    private INestedTypeDefinition GetResolvedType();
    protected virtual ITypeDefinition Resolve();
    public virtual string ToString();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    private sealed virtual override ITypeDefinitionMember Microsoft.Cci.ITypeMemberReference.get_ResolvedTypeDefinitionMember();
}
public class Microsoft.Cci.Immutable.NestedUnitNamespaceReference : object {
    private IUnitNamespaceReference containingUnitNamespace;
    private IName name;
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public IName Name { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public IUnitReference Unit { get; }
    private IUnitNamespace Microsoft.Cci.IUnitNamespaceReference.ResolvedUnitNamespace { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public NestedUnitNamespaceReference(IUnitNamespaceReference containingUnitNamespace, IName name);
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public sealed virtual IUnitReference get_Unit();
    private sealed virtual override IUnitNamespace Microsoft.Cci.IUnitNamespaceReference.get_ResolvedUnitNamespace();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.Immutable.NestedUnitSetNamespace : UnitSetNamespace {
    private bool isInitialized;
    private UnitSetNamespace containingNamespace;
    public UnitSetNamespace ContainingNamespace { get; }
    private INamespaceDefinition Microsoft.Cci.INamespaceMember.ContainingNamespace { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public INamespaceDefinition Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    public IUnitSetNamespace ContainingUnitSetNamespace { get; }
    internal NestedUnitSetNamespace(UnitSetNamespace containingNamespace, IName name, IUnitSet unitSet, List`1<IUnitNamespace> nestedUnitNamepaces);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    protected virtual void InitializeIfNecessary();
    public UnitSetNamespace get_ContainingNamespace();
    public virtual string ToString();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.INamespaceMember.get_ContainingNamespace();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual INamespaceDefinition get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    public sealed virtual IUnitSetNamespace get_ContainingUnitSetNamespace();
}
public class Microsoft.Cci.Immutable.PlatformType : object {
    protected IMetadataHost host;
    private IAssemblyReference contractAssemblyRef;
    private IAssemblyReference coreAssemblyRef;
    private IAssemblyReference systemCoreAssemblyRef;
    private INamespaceTypeReference systemDiagnosticsContractsContract;
    private INamespaceTypeReference systemArgIterator;
    private INamespaceTypeReference systemArray;
    private INamespaceTypeReference systemAsyncCallback;
    private INamespaceTypeReference systemAttribute;
    private INamespaceTypeReference systemAttributeUsageAttribute;
    private INamespaceTypeReference systemBoolean;
    private INamespaceTypeReference systemChar;
    private INamespaceTypeReference systemCollectionsGenericDictionary;
    private INamespaceTypeReference systemCollectionsGenericICollection;
    private INamespaceTypeReference systemCollectionsGenericIEnumerable;
    private INamespaceTypeReference systemCollectionsGenericIEnumerator;
    private INamespaceTypeReference systemCollectionsGenericIList;
    private INamespaceTypeReference systemCollectionsICollection;
    private INamespaceTypeReference systemCollectionsIEnumerable;
    private INamespaceTypeReference systemCollectionsIEnumerator;
    private INamespaceTypeReference systemCollectionsIList;
    private INamespaceTypeReference systemCollectionsIStructuralComparable;
    private INamespaceTypeReference systemCollectionsIStructuralEquatable;
    private INamespaceTypeReference systemContextStaticAttribute;
    private INamespaceTypeReference systemDateTime;
    private INamespaceTypeReference systemDateTimeOffset;
    private INamespaceTypeReference systemDecimal;
    private INamespaceTypeReference systemDelegate;
    private INamespaceTypeReference systemDBNull;
    private INamespaceTypeReference systemEnum;
    private INamespaceTypeReference systemException;
    private INamespaceTypeReference systemFloat32;
    private INamespaceTypeReference systemFloat64;
    private INamespaceTypeReference systemGlobalizationCultureInfo;
    private INamespaceTypeReference systemIAsyncResult;
    private INamespaceTypeReference systemICloneable;
    private INamespaceTypeReference systemInt16;
    private INamespaceTypeReference systemInt32;
    private INamespaceTypeReference systemInt64;
    private INamespaceTypeReference systemInt8;
    private INamespaceTypeReference systemIntPtr;
    private INamespaceTypeReference systemMulticastDelegate;
    private INamespaceTypeReference systemNullable;
    private INamespaceTypeReference systemObject;
    private INamespaceTypeReference systemReflectionAssemblySignatureKeyAttribute;
    private INamespaceTypeReference systemRuntimeArgumentHandle;
    private INamespaceTypeReference systemRuntimeFieldHandle;
    private INamespaceTypeReference systemRuntimeMethodHandle;
    private INamespaceTypeReference systemRuntimeTypeHandle;
    private INamespaceTypeReference systemRuntimeCompilerServicesCallConvCdecl;
    private INamespaceTypeReference systemRuntimeCompilerServicesCompilerGeneratedAttribute;
    private INamespaceTypeReference systemRuntimeCompilerServicesExtensionAttribute;
    private INamespaceTypeReference systemRuntimeCompilerServicesInternalsVisibleToAttribute;
    private INamespaceTypeReference systemRuntimeCompilerServicesIsConst;
    private INamespaceTypeReference systemRuntimeCompilerServicesIsVolatile;
    private INamespaceTypeReference systemRuntimeCompilerServicesReferenceAssemblyAttribute;
    private INamespaceTypeReference systemRuntimeInteropServicesDllImportAttribute;
    private INamespaceTypeReference systemSecurityPermissionsSecurityAction;
    private INamespaceTypeReference systemSecuritySecurityCriticalAttribute;
    private INamespaceTypeReference systemSecuritySecuritySafeCriticalAttribute;
    private INamespaceTypeReference systemSecuritySuppressUnmanagedCodeSecurityAttribute;
    private INamespaceTypeReference systemString;
    private INamespaceTypeReference systemThreadStaticAttribute;
    private INamespaceTypeReference systemType;
    private INamespaceTypeReference systemTypedReference;
    private INamespaceTypeReference systemUInt16;
    private INamespaceTypeReference systemUInt32;
    private INamespaceTypeReference systemUInt64;
    private INamespaceTypeReference systemUInt8;
    private INamespaceTypeReference systemUIntPtr;
    private INamespaceTypeReference systemValueType;
    private INamespaceTypeReference systemVoid;
    private IPointerTypeReference systemVoidPtr;
    public IAssemblyReference ContractAssemblyRef { get; }
    public IAssemblyReference CoreAssemblyRef { get; }
    public IAssemblyReference SystemCoreAssemblyRef { get; }
    public INamespaceTypeReference SystemDiagnosticsContractsContract { get; }
    public byte PointerSize { get; }
    public INamespaceTypeReference SystemArgIterator { get; }
    public INamespaceTypeReference SystemArray { get; }
    public INamespaceTypeReference SystemAsyncCallback { get; }
    public INamespaceTypeReference SystemAttribute { get; }
    public INamespaceTypeReference SystemAttributeUsageAttribute { get; }
    public INamespaceTypeReference SystemBoolean { get; }
    public INamespaceTypeReference SystemChar { get; }
    public INamespaceTypeReference SystemCollectionsGenericDictionary { get; }
    public INamespaceTypeReference SystemCollectionsGenericICollection { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsGenericIList { get; }
    public INamespaceTypeReference SystemCollectionsICollection { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsIList { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralComparable { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralEquatable { get; }
    public INamespaceTypeReference SystemContextStaticAttribute { get; }
    public INamespaceTypeReference SystemDateTime { get; }
    public INamespaceTypeReference SystemDateTimeOffset { get; }
    public INamespaceTypeReference SystemDecimal { get; }
    public INamespaceTypeReference SystemDelegate { get; }
    public INamespaceTypeReference SystemDBNull { get; }
    public INamespaceTypeReference SystemEnum { get; }
    public INamespaceTypeReference SystemException { get; }
    public INamespaceTypeReference SystemFloat32 { get; }
    public INamespaceTypeReference SystemFloat64 { get; }
    public INamespaceTypeReference SystemGlobalizationCultureInfo { get; }
    public INamespaceTypeReference SystemIAsyncResult { get; }
    public INamespaceTypeReference SystemICloneable { get; }
    public INamespaceTypeReference SystemInt16 { get; }
    public INamespaceTypeReference SystemInt32 { get; }
    public INamespaceTypeReference SystemInt64 { get; }
    public INamespaceTypeReference SystemInt8 { get; }
    public INamespaceTypeReference SystemIntPtr { get; }
    public INamespaceTypeReference SystemMulticastDelegate { get; }
    public INamespaceTypeReference SystemNullable { get; }
    public INamespaceTypeReference SystemObject { get; }
    public INamespaceTypeReference SystemReflectionAssemblySignatureKeyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeArgumentHandle { get; }
    public INamespaceTypeReference SystemRuntimeFieldHandle { get; }
    public INamespaceTypeReference SystemRuntimeMethodHandle { get; }
    public INamespaceTypeReference SystemRuntimeTypeHandle { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCallConvCdecl { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCompilerGeneratedAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesExtensionAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesInternalsVisibleToAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsConst { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsVolatile { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesReferenceAssemblyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeInteropServicesDllImportAttribute { get; }
    public INamespaceTypeReference SystemSecurityPermissionsSecurityAction { get; }
    public INamespaceTypeReference SystemSecuritySecurityCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySecuritySafeCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySuppressUnmanagedCodeSecurityAttribute { get; }
    public INamespaceTypeReference SystemString { get; }
    public INamespaceTypeReference SystemThreadStaticAttribute { get; }
    public INamespaceTypeReference SystemType { get; }
    public INamespaceTypeReference SystemTypedReference { get; }
    public INamespaceTypeReference SystemUInt16 { get; }
    public INamespaceTypeReference SystemUInt32 { get; }
    public INamespaceTypeReference SystemUInt64 { get; }
    public INamespaceTypeReference SystemUInt8 { get; }
    public INamespaceTypeReference SystemUIntPtr { get; }
    public INamespaceTypeReference SystemValueType { get; }
    public INamespaceTypeReference SystemVoid { get; }
    public IPointerTypeReference SystemVoidPtr { get; }
    public PlatformType(IMetadataHost host);
    public INamespaceTypeReference CreateReference(IAssemblyReference assemblyReference, String[] names);
    public INamespaceTypeReference CreateReference(IAssemblyReference assemblyReference, bool isValueType, String[] names);
    public INamespaceTypeReference CreateReference(IAssemblyReference assemblyReference, PrimitiveTypeCode typeCode, String[] names);
    public INamespaceTypeReference CreateReference(IAssemblyReference assemblyReference, ushort genericParameterCount, String[] names);
    public INamespaceTypeReference CreateReference(IAssemblyReference assemblyReference, bool isValueType, ushort genericParameterCount, PrimitiveTypeCode typeCode, String[] names);
    public IAssemblyReference get_ContractAssemblyRef();
    public IAssemblyReference get_CoreAssemblyRef();
    public IAssemblyReference get_SystemCoreAssemblyRef();
    public sealed virtual INamespaceTypeReference get_SystemDiagnosticsContractsContract();
    public sealed virtual byte get_PointerSize();
    public sealed virtual INamespaceTypeReference get_SystemArgIterator();
    public sealed virtual INamespaceTypeReference get_SystemArray();
    public sealed virtual INamespaceTypeReference get_SystemAsyncCallback();
    public sealed virtual INamespaceTypeReference get_SystemAttribute();
    public sealed virtual INamespaceTypeReference get_SystemAttributeUsageAttribute();
    public sealed virtual INamespaceTypeReference get_SystemBoolean();
    public sealed virtual INamespaceTypeReference get_SystemChar();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericDictionary();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericICollection();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerator();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIList();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsICollection();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIEnumerable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIEnumerator();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIList();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIStructuralComparable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIStructuralEquatable();
    public sealed virtual INamespaceTypeReference get_SystemContextStaticAttribute();
    public sealed virtual INamespaceTypeReference get_SystemDateTime();
    public sealed virtual INamespaceTypeReference get_SystemDateTimeOffset();
    public sealed virtual INamespaceTypeReference get_SystemDecimal();
    public sealed virtual INamespaceTypeReference get_SystemDelegate();
    public sealed virtual INamespaceTypeReference get_SystemDBNull();
    public sealed virtual INamespaceTypeReference get_SystemEnum();
    public sealed virtual INamespaceTypeReference get_SystemException();
    public sealed virtual INamespaceTypeReference get_SystemFloat32();
    public sealed virtual INamespaceTypeReference get_SystemFloat64();
    public sealed virtual INamespaceTypeReference get_SystemGlobalizationCultureInfo();
    public sealed virtual INamespaceTypeReference get_SystemIAsyncResult();
    public sealed virtual INamespaceTypeReference get_SystemICloneable();
    public sealed virtual INamespaceTypeReference get_SystemInt16();
    public sealed virtual INamespaceTypeReference get_SystemInt32();
    public sealed virtual INamespaceTypeReference get_SystemInt64();
    public sealed virtual INamespaceTypeReference get_SystemInt8();
    public sealed virtual INamespaceTypeReference get_SystemIntPtr();
    public sealed virtual INamespaceTypeReference get_SystemMulticastDelegate();
    public sealed virtual INamespaceTypeReference get_SystemNullable();
    public sealed virtual INamespaceTypeReference get_SystemObject();
    public sealed virtual INamespaceTypeReference get_SystemReflectionAssemblySignatureKeyAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeArgumentHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeFieldHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeMethodHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeTypeHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCallConvCdecl();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCompilerGeneratedAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesExtensionAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesInternalsVisibleToAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsConst();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsVolatile();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesReferenceAssemblyAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeInteropServicesDllImportAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecurityPermissionsSecurityAction();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySecurityCriticalAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySecuritySafeCriticalAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySuppressUnmanagedCodeSecurityAttribute();
    public sealed virtual INamespaceTypeReference get_SystemString();
    public sealed virtual INamespaceTypeReference get_SystemThreadStaticAttribute();
    public sealed virtual INamespaceTypeReference get_SystemType();
    public sealed virtual INamespaceTypeReference get_SystemTypedReference();
    public sealed virtual INamespaceTypeReference get_SystemUInt16();
    public sealed virtual INamespaceTypeReference get_SystemUInt32();
    public sealed virtual INamespaceTypeReference get_SystemUInt64();
    public sealed virtual INamespaceTypeReference get_SystemUInt8();
    public sealed virtual INamespaceTypeReference get_SystemUIntPtr();
    public sealed virtual INamespaceTypeReference get_SystemValueType();
    public sealed virtual INamespaceTypeReference get_SystemVoid();
    public IPointerTypeReference get_SystemVoidPtr();
    public sealed virtual INamespaceTypeReference GetTypeFor(PrimitiveTypeCode typeCode);
}
public class Microsoft.Cci.Immutable.PointerType : SystemDefinedStructuralType {
    private ITypeReference targetType;
    public IPlatformType PlatformType { get; }
    public ITypeReference TargetType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    protected PointerType(ITypeReference targetType, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public static PointerType GetPointerType(ITypeReference targetType, IInternFactory internFactory);
    public virtual IPlatformType get_PlatformType();
    internal static ITypeReference DeepCopyTypeReference(IPointerTypeReference pointer, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IPointerTypeReference pointer, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IPointerTypeReference pointer, IMethodReference targetContainer, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IPointerTypeReference pointer, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IPointerTypeReference pointer, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceReplacingGenericMethodParameter(IPointerTypeReference pointer, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    public sealed virtual ITypeReference get_TargetType();
    public virtual PrimitiveTypeCode get_TypeCode();
}
public class Microsoft.Cci.Immutable.RootUnitNamespaceReference : object {
    private IUnitReference unit;
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IUnitReference Unit { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public RootUnitNamespaceReference(IUnitReference unit);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IUnitReference get_Unit();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.Immutable.RootUnitSetNamespace : UnitSetNamespace {
    public RootUnitSetNamespace(IName name, UnitSet unitSet);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual string ToString();
}
public abstract class Microsoft.Cci.Immutable.Scope`1 : object {
    private NameScope`2<int, MemberType> caseSensitiveMemberNameToMemberListMap;
    private NameScope`2<int, MemberType> caseInsensitiveMemberNameToMemberListMap;
    private static IEnumerable`1<MemberType> emptyList;
    public IEnumerable`1<MemberType> Members { get; }
    private static Scope`1();
    protected void AddMemberToCache(MemberType member);
    public sealed virtual bool Contains(MemberType member);
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.Scope`1/<GetMatchingMembersNamed>d__4")]
public sealed virtual IEnumerable`1<MemberType> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<MemberType, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.Scope`1/<GetMatchingMembers>d__5")]
public sealed virtual IEnumerable`1<MemberType> GetMatchingMembers(Function`2<MemberType, bool> predicate);
    private void GenerateCaseSensitiveMap();
    public sealed virtual IEnumerable`1<MemberType> GetMembersNamed(IName name, bool ignoreCase);
    protected virtual void InitializeIfNecessary();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.Scope`1/<get_Members>d__11")]
public virtual IEnumerable`1<MemberType> get_Members();
}
public class Microsoft.Cci.Immutable.SpecializedEventDefinition : SpecializedTypeDefinitionMember`1<IEventDefinition> {
    private IEnumerable`1<IMethodReference> accessors;
    private IMethodReference adder;
    private IMethodReference caller;
    private IEventDefinition partiallySpecializedVersion;
    private IMethodReference remover;
    private ITypeReference type;
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMethodReference Adder { get; }
    public IMethodReference Caller { get; }
    public IMethodReference Remover { get; }
    public ITypeReference Type { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public SpecializedEventDefinition(IEventDefinition unspecializedVersion, IEventDefinition partiallySpecializedVersion, ITypeDefinition containingTypeDefinition, GenericTypeInstance containingGenericTypeInstance);
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMethodReference get_Adder();
    public sealed virtual IMethodReference get_Caller();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_Remover();
    public sealed virtual ITypeReference get_Type();
    private ITypeReference SpecializeIfConstructed(ITypeReference partiallySpecializedTypeReference);
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
}
public class Microsoft.Cci.Immutable.SpecializedFieldDefinition : SpecializedTypeDefinitionMember`1<IFieldDefinition> {
    private IFieldDefinition partiallySpecializedVersion;
    private UInt32 internedKey;
    private ITypeReference type;
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    public UInt32 InternedKey { get; }
    public ITypeReference Type { get; }
    public UInt32 BitLength { get; }
    public bool IsBitField { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ISectionBlock FieldMapping { get; }
    private IMetadataConstant Microsoft.Cci.IFieldDefinition.CompileTimeValue { get; }
    public IFieldDefinition ResolvedField { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    private IFieldReference Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion { get; }
    public SpecializedFieldDefinition(IFieldDefinition unspecializedVersion, IFieldDefinition partiallySpecializedVersion, ITypeDefinition containingTypeDefinition, GenericTypeInstance containingGenericTypeInstance);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsModified();
    public sealed virtual UInt32 get_InternedKey();
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    private ITypeReference CopyAndSpecialize(ITypeReference partiallySpecializedTypeReference);
    public sealed virtual UInt32 get_BitLength();
    public sealed virtual bool get_IsBitField();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual int get_SequenceNumber();
    public IMetadataConstant get_CompileTimeValue();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ISectionBlock get_FieldMapping();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IFieldDefinition.get_CompileTimeValue();
    public sealed virtual IFieldDefinition get_ResolvedField();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
    private sealed virtual override IFieldReference Microsoft.Cci.ISpecializedFieldReference.get_UnspecializedVersion();
}
public class Microsoft.Cci.Immutable.SpecializedFieldReference : object {
    private IInternFactory internFactory;
    private IFieldReference unspecializedVersion;
    private UInt32 internedKey;
    private ITypeReference type;
    private IFieldDefinition resolvedField;
    private ITypeReference containingType;
    public IFieldReference UnspecializedVersion { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public UInt32 InternedKey { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public ITypeReference Type { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public SpecializedFieldReference(ITypeReference containingType, IFieldReference unspecializedVersion, IInternFactory internFactory);
    public sealed virtual IFieldReference get_UnspecializedVersion();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public virtual string ToString();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public class Microsoft.Cci.Immutable.SpecializedGenericMethodParameter : SpecializedGenericParameter`1<IGenericMethodParameter> {
    private IEnumerable`1<ITypeReference> constraints;
    private SpecializedMethodDefinition definingMethod;
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public SpecializedMethodDefinition DefiningMethod { get; }
    private IMethodDefinition Microsoft.Cci.IGenericMethodParameter.DefiningMethod { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    public SpecializedGenericMethodParameter(IGenericMethodParameter partiallySpecializedParameter, SpecializedMethodDefinition definingMethod);
    public virtual IEnumerable`1<ITypeReference> get_Constraints();
    private ITypeReference CopyAndSpecialize(ITypeReference partiallySpecializedTypeReference);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public SpecializedMethodDefinition get_DefiningMethod();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IGenericMethodParameter.get_DefiningMethod();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
}
internal class Microsoft.Cci.Immutable.SpecializedGenericMethodParameterReference : object {
    private IGenericMethodParameterReference unspecializedVersion;
    private IInternFactory internFactory;
    private IMethodReference definingMethod;
    private IGenericMethodParameter resolvedType;
    private UInt32 internedKey;
    public IMethodReference DefiningMethod { get; }
    public IGenericMethodParameter ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ushort Index { get; }
    internal SpecializedGenericMethodParameterReference(IMethodReference definingMethod, IGenericMethodParameterReference unspecializedVersion, IInternFactory internFactory);
    public sealed virtual IMethodReference get_DefiningMethod();
    public sealed virtual IGenericMethodParameter get_ResolvedType();
    private void Resolve();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
}
public abstract class Microsoft.Cci.Immutable.SpecializedGenericParameter`1 : object {
    private ParameterType unspecializedParameter;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IPlatformType PlatformType { get; }
    public ParameterType PartiallySpecializedParameter { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public ushort GenericParameterCount { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public ushort Index { get; }
    public IName Name { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public IInternFactory InternFactory { get; }
    public UInt32 InternedKey { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    protected SpecializedGenericParameter`1(ParameterType partiallySpecializedParameter, IInternFactory internFactory);
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public abstract virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IPlatformType get_PlatformType();
    public ParameterType get_PartiallySpecializedParameter();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ushort get_Index();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public bool get_IsModified();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public IInternFactory get_InternFactory();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
public class Microsoft.Cci.Immutable.SpecializedGenericTypeParameter : SpecializedGenericParameter`1<IGenericTypeParameter> {
    private IGenericTypeInstanceReference containingGenericTypeInstance;
    private IEnumerable`1<ITypeReference> constraints;
    private ISpecializedNestedTypeReference definingType;
    public IGenericTypeInstanceReference ContainingGenericTypeInstance { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public ISpecializedNestedTypeReference DefiningType { get; }
    private ITypeDefinition Microsoft.Cci.IGenericTypeParameter.DefiningType { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    public SpecializedGenericTypeParameter(IGenericTypeParameter partiallySpecializedParameter, ISpecializedNestedTypeReference definingTypeInstance, IInternFactory internFactory);
    public IGenericTypeInstanceReference get_ContainingGenericTypeInstance();
    public virtual IEnumerable`1<ITypeReference> get_Constraints();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public ISpecializedNestedTypeReference get_DefiningType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IGenericTypeParameter.get_DefiningType();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
}
internal class Microsoft.Cci.Immutable.SpecializedLocalDefinition : object {
    private ILocalDefinition unspecializedLocal;
    private IMethodDefinition containingMethod;
    private ITypeReference type;
    public IMetadataConstant CompileTimeValue { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    internal SpecializedLocalDefinition(ILocalDefinition unspecializedLocal, IMethodDefinition containingMethod, ITypeReference type);
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.Immutable.SpecializedMethodBody : object {
    private IMethodBody unspecializedBody;
    private IMethodDefinition containingMethod;
    private IInternFactory internFactory;
    private IEnumerable`1<IOperationExceptionInformation> operationExceptionInformation;
    private IEnumerable`1<ILocalDefinition> localVariables;
    private IEnumerable`1<IOperation> operations;
    private IEnumerable`1<ITypeDefinition> privateHelperTypes;
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public bool LocalsAreZeroed { get; }
    public IEnumerable`1<ILocalDefinition> LocalVariables { get; }
    public ushort MaxStack { get; }
    public IMethodDefinition MethodDefinition { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public IEnumerable`1<ITypeDefinition> PrivateHelperTypes { get; }
    public UInt32 Size { get; }
    internal SpecializedMethodBody(IMethodBody unspecializedBody, IMethodDefinition containingMethod, IInternFactory internFactory);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public sealed virtual bool get_LocalsAreZeroed();
    public sealed virtual IEnumerable`1<ILocalDefinition> get_LocalVariables();
    private void MapBody();
    private ITypeReference Specialize(ITypeReference unspecializedType, Dictionary`2<object, object> map);
    private object Specialize(object unspecialized, Dictionary`2<object, object> map);
    private object Specialize(IGenericMethodInstanceReference unspecialized, Dictionary`2<object, object> map);
    public sealed virtual ushort get_MaxStack();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual IEnumerable`1<IOperation> get_Operations();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_PrivateHelperTypes();
    public sealed virtual UInt32 get_Size();
}
public class Microsoft.Cci.Immutable.SpecializedMethodDefinition : SpecializedTypeDefinitionMember`1<IMethodDefinition> {
    private IMethodBody body;
    private IEnumerable`1<IGenericMethodParameter> genericParameters;
    private IEnumerable`1<IParameterDefinition> parameters;
    private IMethodDefinition partiallySpecializedVersion;
    private ITypeReference type;
    private UInt32 internedKey;
    public IMethodBody Body { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool IsConstructor { get; }
    public bool IsStaticConstructor { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition PartiallySpecializedVersion { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public IName ReturnValueName { get; }
    public ITypeReference Type { get; }
    private IMethodDefinition Microsoft.Cci.ISpecializedMethodDefinition.UnspecializedVersion { get; }
    public bool AcceptsExtraArguments { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSynchronized { get; }
    public bool IsUnmanaged { get; }
    public bool IsVirtual { get; }
    public bool PreserveSignature { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 InternedKey { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public bool ReturnValueIsModified { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    public SpecializedMethodDefinition(IMethodDefinition unspecializedVersion, IMethodDefinition partiallySpecializedVersion, ITypeDefinition containingTypeDefinition, GenericTypeInstance containingGenericTypeInstance);
    public sealed virtual IMethodBody get_Body();
    public sealed virtual CallingConvention get_CallingConvention();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual ushort get_ParameterCount();
    public IMethodDefinition get_PartiallySpecializedVersion();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual IName get_ReturnValueName();
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    private ITypeReference CopyAndSpecialize(ITypeReference partiallySpecializedTypeReference);
    private sealed virtual override IMethodDefinition Microsoft.Cci.ISpecializedMethodDefinition.get_UnspecializedVersion();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
}
public class Microsoft.Cci.Immutable.SpecializedMethodImplementation : object {
    private ITypeDefinition containingType;
    private IMethodReference implementedMethod;
    private IMethodReference implementingMethod;
    private IInternFactory internFactory;
    private IMethodImplementation unspecializedVersion;
    public ITypeDefinition ContainingType { get; }
    public IMethodReference ImplementedMethod { get; }
    public IMethodReference ImplementingMethod { get; }
    public IMethodImplementation UnspecializedVersion { get; }
    public SpecializedMethodImplementation(ITypeDefinition containingType, IMethodImplementation unspecializedVersion, IInternFactory internFactory);
    public sealed virtual ITypeDefinition get_ContainingType();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_ImplementedMethod();
    public sealed virtual IMethodReference get_ImplementingMethod();
    public IMethodImplementation get_UnspecializedVersion();
}
internal class Microsoft.Cci.Immutable.SpecializedMethodParameterTypeInformation : object {
    private IParameterTypeInformation unspecializedVersion;
    private IInternFactory internFactory;
    private ISpecializedMethodReference containingMethod;
    private ITypeReference type;
    public ISignature ContainingSignature { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ushort Index { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    internal SpecializedMethodParameterTypeInformation(ISpecializedMethodReference containingMethod, IParameterTypeInformation unspecializedVersion, IInternFactory internFactory);
    public sealed virtual ISignature get_ContainingSignature();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ushort get_Index();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
}
public class Microsoft.Cci.Immutable.SpecializedMethodReference : object {
    private IInternFactory internFactory;
    private IMethodReference unspecializedVersion;
    private UInt32 internedKey;
    private IMethodDefinition resolvedMethod;
    private IEnumerable`1<IParameterTypeInformation> extraParameters;
    private IEnumerable`1<IParameterTypeInformation> parameters;
    private ITypeReference type;
    private ITypeReference containingType;
    public IMethodReference UnspecializedVersion { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public SpecializedMethodReference(ITypeReference containingType, IMethodReference unspecializedVersion, IInternFactory internFactory);
    public sealed virtual IMethodReference get_UnspecializedVersion();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public virtual string ToString();
}
public class Microsoft.Cci.Immutable.SpecializedNestedTypeDefinition : Scope`1<ITypeDefinitionMember> {
    private IEnumerable`1<ITypeReference> baseClasses;
    private IEnumerable`1<IGenericTypeParameter> genericParameters;
    private bool initialized;
    private GenericTypeInstance containingGenericTypeInstance;
    private IEnumerable`1<ITypeReference> interfaces;
    private IGenericTypeInstanceReference instanceType;
    internal INestedTypeDefinition partiallySpecializedVersion;
    private INestedTypeDefinition unspecializedVersion;
    private TypeMemberVisibility visibility;
    private ITypeDefinition containingTypeDefinition;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public bool DoesNotInheritGenericParameters { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public GenericTypeInstance ContainingGenericTypeInstance { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public ITypeReference UnderlyingType { get; }
    public INestedTypeDefinition UnspecializedVersion { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public ushort GenericParameterCount { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    private IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IContainer<Microsoft.Cci.ITypeDefinitionMember>.Members { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    private ITypeReference Microsoft.Cci.ITypeMemberReference.ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    public IInternFactory InternFactory { get; }
    public UInt32 InternedKey { get; }
    private INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public SpecializedNestedTypeDefinition(INestedTypeDefinition unspecializedVersion, INestedTypeDefinition partiallySpecializedVersion, ITypeDefinition containingTypeDefinition, GenericTypeInstance containingGenericTypeInstance, IInternFactory internFactory);
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual bool get_DoesNotInheritGenericParameters();
    internal static ITypeReference DeepCopyTypeReference(INestedTypeReference nestedType, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(INestedTypeReference nestedType, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(INestedTypeReference nestedType, IMethodReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(INestedTypeReference nestedType, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    internal static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(INestedTypeReference nestedType, IGenericMethodInstanceReference genericMethodInstance, IInternFactory internFactory);
    internal static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(INestedTypeReference nestedType, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    protected virtual void InitializeIfNecessary();
    public GenericTypeInstance get_ContainingGenericTypeInstance();
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.SpecializedNestedTypeDefinition/<get_ExplicitImplementationOverrides>d__21")]
public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    private ITypeReference CopyAndSpecialize(ITypeReference partiallySpecializedTypeReference);
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual INestedTypeDefinition get_UnspecializedVersion();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public ITypeDefinitionMember SpecializeMember(ITypeDefinitionMember unspecializedMember, IInternFactory internFactory);
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public virtual string ToString();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IContainer<Microsoft.Cci.ITypeDefinitionMember>.get_Members();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    public IInternFactory get_InternFactory();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.get_UnspecializedVersion();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
public class Microsoft.Cci.Immutable.SpecializedNestedTypeReference : object {
    private IInternFactory internFactory;
    private INestedTypeReference unspecializedVersion;
    private INestedTypeDefinition resolvedType;
    private ITypeReference containingType;
    private UInt32 internedKey;
    public INestedTypeReference UnspecializedVersion { get; }
    public ushort GenericParameterCount { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public SpecializedNestedTypeReference(INestedTypeReference unspecializedVersion, ITypeReference containingType, IInternFactory internFactory);
    public sealed virtual INestedTypeReference get_UnspecializedVersion();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    public virtual string ToString();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.Immutable.SpecializedOperation : object {
    private IOperation unspecializedOperation;
    private object specializedValue;
    public OperationCode OperationCode { get; }
    public UInt32 Offset { get; }
    public ILocation Location { get; }
    public object Value { get; }
    internal SpecializedOperation(IOperation unspecializedOperation, object specializedValue);
    public sealed virtual OperationCode get_OperationCode();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ILocation get_Location();
    public sealed virtual object get_Value();
}
internal class Microsoft.Cci.Immutable.SpecializedOperationExceptionInformation : object {
    private IOperationExceptionInformation unspecializedVersion;
    private ITypeReference specialziedExceptionType;
    public HandlerKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public UInt32 TryStartOffset { get; }
    public UInt32 TryEndOffset { get; }
    public UInt32 FilterDecisionStartOffset { get; }
    public UInt32 HandlerStartOffset { get; }
    public UInt32 HandlerEndOffset { get; }
    internal SpecializedOperationExceptionInformation(IOperationExceptionInformation unspecializedVersion, ITypeReference specialziedExceptionType);
    public sealed virtual HandlerKind get_HandlerKind();
    public sealed virtual ITypeReference get_ExceptionType();
    public sealed virtual UInt32 get_TryStartOffset();
    public sealed virtual UInt32 get_TryEndOffset();
    public sealed virtual UInt32 get_FilterDecisionStartOffset();
    public sealed virtual UInt32 get_HandlerStartOffset();
    public sealed virtual UInt32 get_HandlerEndOffset();
}
public class Microsoft.Cci.Immutable.SpecializedParameterDefinition : object {
    private ISignature containingSignature;
    private IParameterDefinition partiallySpecializedParameter;
    private ITypeReference paramArrayElementType;
    private ITypeReference type;
    private IInternFactory internFactory;
    public ISignature ContainingSignature { get; }
    public IParameterDefinition PartiallySpecializedParameter { get; }
    public ITypeReference ParamArrayElementType { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public ushort Index { get; }
    public IInternFactory InternFactory { get; }
    public bool IsByReference { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public bool IsParameterArray { get; }
    private IMetadataConstant Microsoft.Cci.IParameterDefinition.DefaultValue { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    protected internal SpecializedParameterDefinition(IParameterDefinition partiallySpecializedParameter, IGenericMethodInstanceReference containingSignature, IInternFactory internFactory);
    protected internal SpecializedParameterDefinition(IParameterDefinition partiallySpecializedParameter, SpecializedMethodDefinition containingSignature, IInternFactory internFactory);
    protected internal SpecializedParameterDefinition(IParameterDefinition partiallySpecializedParameter, SpecializedPropertyDefinition containingSignature, IInternFactory internFactory);
    public sealed virtual ISignature get_ContainingSignature();
    public IParameterDefinition get_PartiallySpecializedParameter();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_ParamArrayElementType();
    private ITypeReference CopyAndSpecialize(ITypeReference partiallySpecializedType);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public IMetadataConstant get_DefaultValue();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual ushort get_Index();
    public IInternFactory get_InternFactory();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual bool get_IsParameterArray();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IParameterDefinition.get_DefaultValue();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
internal class Microsoft.Cci.Immutable.SpecializedParameterTypeInformation : object {
    private IGenericMethodInstanceReference containingSignature;
    private IParameterTypeInformation partiallySpecializedParameter;
    private ITypeReference type;
    private IInternFactory internFactory;
    public ISignature ContainingSignature { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ushort Index { get; }
    public IInternFactory InternFactory { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    internal SpecializedParameterTypeInformation(IParameterTypeInformation partiallySpecializedParameter, IGenericMethodInstanceReference containingSignature, IInternFactory internFactory);
    public sealed virtual ISignature get_ContainingSignature();
    public virtual void Dispatch(IMetadataVisitor visitor);
    private ITypeReference SpecializeIfConstructed(ITypeReference partiallySpecializedType);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ushort get_Index();
    public IInternFactory get_InternFactory();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
}
public class Microsoft.Cci.Immutable.SpecializedPropertyDefinition : SpecializedTypeDefinitionMember`1<IPropertyDefinition> {
    private IEnumerable`1<IMethodReference> accessors;
    private IMethodReference getter;
    private IEnumerable`1<IParameterDefinition> parameters;
    private IPropertyDefinition partiallySpecializedVersion;
    private IMethodReference setter;
    private ITypeReference type;
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMethodReference Getter { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public IMethodReference Setter { get; }
    public ITypeReference Type { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    private IMetadataConstant Microsoft.Cci.IPropertyDefinition.DefaultValue { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public CallingConvention CallingConvention { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    public SpecializedPropertyDefinition(IPropertyDefinition unspecializedVersion, IPropertyDefinition partiallySpecializedVersion, ITypeDefinition containingTypeDefinition, GenericTypeInstance containingGenericTypeInstance);
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_Getter();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual IMethodReference get_Setter();
    public sealed virtual ITypeReference get_Type();
    private ITypeReference CopyAndSpecialize(ITypeReference partiallySpecializedTypeReference);
    public IMetadataConstant get_DefaultValue();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IPropertyDefinition.get_DefaultValue();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual CallingConvention get_CallingConvention();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
public abstract class Microsoft.Cci.Immutable.SpecializedTypeDefinitionMember`1 : object {
    private GenericTypeInstance containingGenericTypeInstance;
    private MemberType unspecializedVersion;
    private ITypeDefinition containingTypeDefinition;
    public GenericTypeInstance ContainingGenericTypeInstance { get; }
    public TypeMemberVisibility Visibility { get; }
    public MemberType UnspecializedVersion { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    protected SpecializedTypeDefinitionMember`1(MemberType unspecializedVersion, ITypeDefinition containingTypeDefinition, GenericTypeInstance containingGenericTypeInstance);
    protected SpecializedMethodDefinition SpecializeMethod(IMethodReference unspecializedMethod);
    public GenericTypeInstance get_ContainingGenericTypeInstance();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual MemberType get_UnspecializedVersion();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
}
public abstract class Microsoft.Cci.Immutable.SystemDefinedStructuralType : object {
    private IInternFactory internFactory;
    private UInt32 internedKey;
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsValueType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    public ITypeDefinition ResolvedType { get; }
    public IInternFactory InternFactory { get; }
    public UInt32 InternedKey { get; }
    protected SystemDefinedStructuralType(IInternFactory internFactory);
    public sealed virtual ushort get_Alignment();
    public virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public abstract virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public virtual string ToString();
    public virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public virtual bool Contains(ITypeDefinitionMember member);
    public virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>.GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public virtual bool get_IsModified();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public IInternFactory get_InternFactory();
    public sealed virtual UInt32 get_InternedKey();
}
internal static class Microsoft.Cci.Immutable.TypeDefinition : object {
    internal static ITypeReference DeepCopyTypeReference(ITypeReference partiallySpecializedTypeReference, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(ITypeReference partiallySpecializedTypeReference, IGenericMethodInstanceReference containingMethodInstance, IInternFactory internFactory);
    internal static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(ITypeReference partiallySpecializedTypeReference, IGenericTypeInstanceReference containingTypeInstance, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(ITypeReference partiallySpecializedTypeReference, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
}
public class Microsoft.Cci.Immutable.UnitSet : object {
    private IEnumerable`1<IUnit> units;
    private IRootUnitSetNamespace unitSetNamespaceRoot;
    public IEnumerable`1<IUnit> Units { get; }
    public IUnitSetNamespace UnitSetNamespaceRoot { get; }
    private INamespaceDefinition Microsoft.Cci.INamespaceRootOwner.NamespaceRoot { get; }
    public UnitSet(IEnumerable`1<IUnit> units);
    public sealed virtual bool Contains(IUnit unit);
    public sealed virtual IEnumerable`1<IUnit> get_Units();
    public sealed virtual IUnitSetNamespace get_UnitSetNamespaceRoot();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.INamespaceRootOwner.get_NamespaceRoot();
}
public abstract class Microsoft.Cci.Immutable.UnitSetNamespace : AggregatedNamespace`2<INamespaceDefinition, INamespaceMember> {
    private Dictionary`2<int, NestedUnitSetNamespace> nestedUnitNamespaceToNestedUnitSetNamespaceMap;
    private List`1<IUnitNamespace> unitNamespaces;
    private IUnitSet unitSet;
    public IEnumerable`1<ILocation> Locations { get; }
    public INamespaceRootOwner RootOwner { get; }
    protected List`1<IUnitNamespace> UnitNamespaces { get; }
    public IUnitSet UnitSet { get; }
    protected UnitSetNamespace(IName name, UnitSet unitSet);
    protected UnitSetNamespace(IName name, IUnitSet unitSet, List`1<IUnitNamespace> nestedUnitNamespaces);
    [IteratorStateMachineAttribute("Microsoft.Cci.Immutable.UnitSetNamespace/<get_Locations>d__3")]
public virtual IEnumerable`1<ILocation> get_Locations();
    protected virtual INamespaceMember GetAggregatedMember(INamespaceMember member);
    public virtual INamespaceRootOwner get_RootOwner();
    protected List`1<IUnitNamespace> get_UnitNamespaces();
    public sealed virtual IUnitSet get_UnitSet();
}
public class Microsoft.Cci.Immutable.Vector : ArrayType {
    protected Vector(ITypeReference elementType, IInternFactory internFactory);
    protected virtual IEnumerable`1<ITypeReference> GetInterfaceList();
    public static ITypeReference DeepCopyTypeReference(IArrayTypeReference array, SpecializedNestedTypeDefinition targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IArrayTypeReference array, ITypeReference targetContainer, IInternFactory internFactory);
    internal static ITypeReference SpecializeTypeReference(IArrayTypeReference array, IMethodReference targetContainer, IInternFactory internFactory);
    public static Vector GetVector(ITypeReference elementType, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IArrayTypeReference array, IGenericMethodInstanceReference method, IInternFactory internFactory);
    public static ITypeReference SpecializeIfConstructedFromApplicableTypeParameter(IArrayTypeReference array, IGenericTypeInstanceReference type, IInternFactory internFactory);
    internal static ITypeReference DeepCopyTypeReferenceWRTSpecializedMethod(IArrayTypeReference array, ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
}
public interface Microsoft.Cci.IModifiedTypeReference {
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    public abstract virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual ITypeReference get_UnmodifiedType();
}
internal abstract class Microsoft.Cci.IModifiedTypeReferenceContract : object {
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ITypeReference get_UnmodifiedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IModule {
    public IEnumerable`1<IAssemblyReference> AssemblyReferences { get; }
    public ulong BaseAddress { get; }
    public IAssembly ContainingAssembly { get; }
    public string DebugInformationLocation { get; }
    public string DebugInformationVersion { get; }
    public ushort DllCharacteristics { get; }
    public IMethodReference EntryPoint { get; }
    public UInt32 FileAlignment { get; }
    public bool ILOnly { get; }
    public bool StrongNameSigned { get; }
    public ModuleKind Kind { get; }
    public byte LinkerMajorVersion { get; }
    public byte LinkerMinorVersion { get; }
    public Machine Machine { get; }
    public byte MetadataFormatMajorVersion { get; }
    public byte MetadataFormatMinorVersion { get; }
    public IEnumerable`1<ICustomAttribute> ModuleAttributes { get; }
    public IName ModuleName { get; }
    public IEnumerable`1<IModuleReference> ModuleReferences { get; }
    public Guid PersistentIdentifier { get; }
    public bool Prefers32bits { get; }
    public bool RequiresAmdInstructionSet { get; }
    public bool RequiresStartupStub { get; }
    public bool Requires32bits { get; }
    public bool Requires64bits { get; }
    public ulong SizeOfHeapCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfStackReserve { get; }
    public ushort SubsystemMajorVersion { get; }
    public ushort SubsystemMinorVersion { get; }
    public string TargetRuntimeVersion { get; }
    public bool TrackDebugData { get; }
    public bool UsePublicKeyTokensForAssemblyReferences { get; }
    public IEnumerable`1<IWin32Resource> Win32Resources { get; }
    public abstract virtual IEnumerable`1<IAssemblyReference> get_AssemblyReferences();
    public abstract virtual ulong get_BaseAddress();
    public abstract virtual IAssembly get_ContainingAssembly();
    public abstract virtual string get_DebugInformationLocation();
    public abstract virtual string get_DebugInformationVersion();
    public abstract virtual ushort get_DllCharacteristics();
    public abstract virtual IMethodReference get_EntryPoint();
    public abstract virtual UInt32 get_FileAlignment();
    public abstract virtual IEnumerable`1<string> GetStrings();
    public abstract virtual IEnumerable`1<INamedTypeDefinition> GetAllTypes();
    public abstract virtual IEnumerable`1<IGenericMethodInstanceReference> GetGenericMethodInstances();
    public abstract virtual IEnumerable`1<ITypeReference> GetStructuralTypeInstances();
    public abstract virtual IEnumerable`1<ITypeMemberReference> GetStructuralTypeInstanceMembers();
    public abstract virtual IEnumerable`1<ITypeReference> GetTypeReferences();
    public abstract virtual IEnumerable`1<ITypeMemberReference> GetTypeMemberReferences();
    public abstract virtual bool get_ILOnly();
    public abstract virtual bool get_StrongNameSigned();
    public abstract virtual ModuleKind get_Kind();
    public abstract virtual byte get_LinkerMajorVersion();
    public abstract virtual byte get_LinkerMinorVersion();
    public abstract virtual Machine get_Machine();
    public abstract virtual byte get_MetadataFormatMajorVersion();
    public abstract virtual byte get_MetadataFormatMinorVersion();
    public abstract virtual IEnumerable`1<ICustomAttribute> get_ModuleAttributes();
    public abstract virtual IName get_ModuleName();
    public abstract virtual IEnumerable`1<IModuleReference> get_ModuleReferences();
    public abstract virtual Guid get_PersistentIdentifier();
    public abstract virtual bool get_Prefers32bits();
    public abstract virtual bool get_RequiresAmdInstructionSet();
    public abstract virtual bool get_RequiresStartupStub();
    public abstract virtual bool get_Requires32bits();
    public abstract virtual bool get_Requires64bits();
    public abstract virtual ulong get_SizeOfHeapCommit();
    public abstract virtual ulong get_SizeOfHeapReserve();
    public abstract virtual ulong get_SizeOfStackCommit();
    public abstract virtual ulong get_SizeOfStackReserve();
    public abstract virtual ushort get_SubsystemMajorVersion();
    public abstract virtual ushort get_SubsystemMinorVersion();
    public abstract virtual string get_TargetRuntimeVersion();
    public abstract virtual bool get_TrackDebugData();
    public abstract virtual bool get_UsePublicKeyTokensForAssemblyReferences();
    public abstract virtual IEnumerable`1<IWin32Resource> get_Win32Resources();
}
internal abstract class Microsoft.Cci.IModuleContract : object {
    public IEnumerable`1<IAssemblyReference> AssemblyReferences { get; }
    public ulong BaseAddress { get; }
    public IAssembly ContainingAssembly { get; }
    public string DebugInformationLocation { get; }
    public string DebugInformationVersion { get; }
    public ushort DllCharacteristics { get; }
    public IMethodReference EntryPoint { get; }
    public UInt32 FileAlignment { get; }
    public bool ILOnly { get; }
    public bool StrongNameSigned { get; }
    public bool Prefers32bits { get; }
    public ModuleKind Kind { get; }
    public byte LinkerMajorVersion { get; }
    public byte LinkerMinorVersion { get; }
    public byte MetadataFormatMajorVersion { get; }
    public byte MetadataFormatMinorVersion { get; }
    public IEnumerable`1<ICustomAttribute> ModuleAttributes { get; }
    public IName ModuleName { get; }
    public IEnumerable`1<IModuleReference> ModuleReferences { get; }
    public Guid PersistentIdentifier { get; }
    public Machine Machine { get; }
    public bool RequiresAmdInstructionSet { get; }
    public bool RequiresStartupStub { get; }
    public bool Requires32bits { get; }
    public bool Requires64bits { get; }
    public ulong SizeOfHeapCommit { get; }
    public ulong SizeOfHeapReserve { get; }
    public ulong SizeOfStackCommit { get; }
    public ulong SizeOfStackReserve { get; }
    public ushort SubsystemMajorVersion { get; }
    public ushort SubsystemMinorVersion { get; }
    public string TargetRuntimeVersion { get; }
    public bool TrackDebugData { get; }
    public bool UsePublicKeyTokensForAssemblyReferences { get; }
    public IEnumerable`1<IWin32Resource> Win32Resources { get; }
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public IPlatformType PlatformType { get; }
    public string Location { get; }
    public IEnumerable`1<IPESection> UninterpretedSections { get; }
    public IRootUnitNamespace UnitNamespaceRoot { get; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public sealed virtual IEnumerable`1<IAssemblyReference> get_AssemblyReferences();
    public sealed virtual ulong get_BaseAddress();
    public sealed virtual IAssembly get_ContainingAssembly();
    public sealed virtual string get_DebugInformationLocation();
    public sealed virtual string get_DebugInformationVersion();
    public sealed virtual ushort get_DllCharacteristics();
    public sealed virtual IMethodReference get_EntryPoint();
    public sealed virtual UInt32 get_FileAlignment();
    public sealed virtual IEnumerable`1<string> GetStrings();
    public sealed virtual IEnumerable`1<INamedTypeDefinition> GetAllTypes();
    public sealed virtual IEnumerable`1<IGenericMethodInstanceReference> GetGenericMethodInstances();
    public sealed virtual IEnumerable`1<ITypeReference> GetStructuralTypeInstances();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetStructuralTypeInstanceMembers();
    public sealed virtual IEnumerable`1<ITypeReference> GetTypeReferences();
    public sealed virtual IEnumerable`1<ITypeMemberReference> GetTypeMemberReferences();
    public sealed virtual bool get_ILOnly();
    public sealed virtual bool get_StrongNameSigned();
    public sealed virtual bool get_Prefers32bits();
    public sealed virtual ModuleKind get_Kind();
    public sealed virtual byte get_LinkerMajorVersion();
    public sealed virtual byte get_LinkerMinorVersion();
    public sealed virtual byte get_MetadataFormatMajorVersion();
    public sealed virtual byte get_MetadataFormatMinorVersion();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ModuleAttributes();
    public sealed virtual IName get_ModuleName();
    public sealed virtual IEnumerable`1<IModuleReference> get_ModuleReferences();
    public sealed virtual Guid get_PersistentIdentifier();
    public sealed virtual Machine get_Machine();
    public sealed virtual bool get_RequiresAmdInstructionSet();
    public sealed virtual bool get_RequiresStartupStub();
    public sealed virtual bool get_Requires32bits();
    public sealed virtual bool get_Requires64bits();
    public sealed virtual ulong get_SizeOfHeapCommit();
    public sealed virtual ulong get_SizeOfHeapReserve();
    public sealed virtual ulong get_SizeOfStackCommit();
    public sealed virtual ulong get_SizeOfStackReserve();
    public sealed virtual ushort get_SubsystemMajorVersion();
    public sealed virtual ushort get_SubsystemMinorVersion();
    public sealed virtual string get_TargetRuntimeVersion();
    public sealed virtual bool get_TrackDebugData();
    public sealed virtual bool get_UsePublicKeyTokensForAssemblyReferences();
    public sealed virtual IEnumerable`1<IWin32Resource> get_Win32Resources();
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual string get_Location();
    public sealed virtual IEnumerable`1<IPESection> get_UninterpretedSections();
    public sealed virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public sealed virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
}
public interface Microsoft.Cci.IModuleReference {
    public IAssemblyReference ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public abstract virtual IAssemblyReference get_ContainingAssembly();
    public abstract virtual IModule get_ResolvedModule();
    public abstract virtual ModuleIdentity get_ModuleIdentity();
}
internal abstract class Microsoft.Cci.IModuleReferenceContract : object {
    public IAssemblyReference ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public ModuleIdentity ModuleIdentity { get; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.IModulus {
    public bool TreatOperandsAsUnsignedIntegers { get; }
    public abstract virtual bool get_TreatOperandsAsUnsignedIntegers();
}
public interface Microsoft.Cci.IMultiplication {
    public bool CheckOverflow { get; }
    public bool TreatOperandsAsUnsignedIntegers { get; }
    public abstract virtual bool get_CheckOverflow();
    public abstract virtual bool get_TreatOperandsAsUnsignedIntegers();
}
public interface Microsoft.Cci.IName {
    public int UniqueKey { get; }
    public int UniqueKeyIgnoringCase { get; }
    public string Value { get; }
    public abstract virtual int get_UniqueKey();
    public abstract virtual int get_UniqueKeyIgnoringCase();
    public abstract virtual string get_Value();
}
internal abstract class Microsoft.Cci.INameContract : object {
    public int UniqueKey { get; }
    public int UniqueKeyIgnoringCase { get; }
    public string Value { get; }
    public sealed virtual int get_UniqueKey();
    public sealed virtual int get_UniqueKeyIgnoringCase();
    public sealed virtual string get_Value();
}
public interface Microsoft.Cci.INamedArgument {
    public IName ArgumentName { get; }
    public IExpression ArgumentValue { get; }
    public object ResolvedDefinition { get; }
    public bool GetterIsVirtual { get; }
    public bool SetterIsVirtual { get; }
    public abstract virtual IName get_ArgumentName();
    public abstract virtual IExpression get_ArgumentValue();
    public abstract virtual object get_ResolvedDefinition();
    public abstract virtual bool get_GetterIsVirtual();
    public abstract virtual bool get_SetterIsVirtual();
}
internal abstract class Microsoft.Cci.INamedArgumentContract : object {
    public IName ArgumentName { get; }
    public IExpression ArgumentValue { get; }
    public object ResolvedDefinition { get; }
    public bool GetterIsVirtual { get; }
    public bool SetterIsVirtual { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IName get_ArgumentName();
    public sealed virtual IExpression get_ArgumentValue();
    public sealed virtual object get_ResolvedDefinition();
    public sealed virtual bool get_GetterIsVirtual();
    public sealed virtual bool get_SetterIsVirtual();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.INamedEntity {
    public IName Name { get; }
    public abstract virtual IName get_Name();
}
internal abstract class Microsoft.Cci.INamedEntityContract : object {
    public IName Name { get; }
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.INamedTypeDefinition {
    public ushort GenericParameterCount { get; }
    public abstract virtual ushort get_GenericParameterCount();
}
internal abstract class Microsoft.Cci.INamedTypeDefinitionContract : object {
    private ushort Microsoft.Cci.INamedTypeDefinition.GenericParameterCount { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private sealed virtual override ushort Microsoft.Cci.INamedTypeDefinition.get_GenericParameterCount();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
}
public interface Microsoft.Cci.INamedTypeReference {
    public ushort GenericParameterCount { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_MangleName();
    public abstract virtual INamedTypeDefinition get_ResolvedType();
}
internal abstract class Microsoft.Cci.INamedTypeReferenceContract : object {
    public ushort GenericParameterCount { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.INamespaceAliasForType {
    public bool IsPublic { get; }
    public abstract virtual bool get_IsPublic();
}
public interface Microsoft.Cci.INamespaceDefinition {
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public abstract virtual INamespaceRootOwner get_RootOwner();
    public abstract virtual IEnumerable`1<INamespaceMember> get_Members();
}
internal abstract class Microsoft.Cci.INamespaceDefinitionContract : object {
    public INamespaceRootOwner RootOwner { get; }
    private IEnumerable`1<INamespaceMember> Microsoft.Cci.INamespaceDefinition.Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public sealed virtual INamespaceRootOwner get_RootOwner();
    private sealed virtual override IEnumerable`1<INamespaceMember> Microsoft.Cci.INamespaceDefinition.get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
}
public interface Microsoft.Cci.INamespaceMember {
    public INamespaceDefinition ContainingNamespace { get; }
    public abstract virtual INamespaceDefinition get_ContainingNamespace();
}
internal abstract class Microsoft.Cci.INamespaceMemberContract : object {
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IName Name { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.INamespaceRootOwner {
    public INamespaceDefinition NamespaceRoot { get; }
    public abstract virtual INamespaceDefinition get_NamespaceRoot();
}
internal abstract class Microsoft.Cci.INamespaceRootOwnerContract : object {
    public INamespaceDefinition NamespaceRoot { get; }
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
}
public interface Microsoft.Cci.INamespaceScope {
    public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    public abstract virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
internal abstract class Microsoft.Cci.INamespaceScopeContract : object {
    public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    public sealed virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
public interface Microsoft.Cci.INamespaceTypeDefinition {
    public ushort GenericParameterCount { get; }
    public IUnitNamespace ContainingUnitNamespace { get; }
    public bool IsPublic { get; }
    public bool IsForeignObject { get; }
    public abstract virtual IEnumerable`1<ICustomAttribute> AttributesFor(ITypeReference implementedInterface);
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual IUnitNamespace get_ContainingUnitNamespace();
    public abstract virtual bool get_IsPublic();
    public abstract virtual bool get_IsForeignObject();
}
internal abstract class Microsoft.Cci.INamespaceTypeDefinitionContract : object {
    public ushort GenericParameterCount { get; }
    public IUnitNamespace ContainingUnitNamespace { get; }
    public bool IsPublic { get; }
    public bool IsForeignObject { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    private IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.ContainingUnitNamespace { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public sealed virtual IEnumerable`1<ICustomAttribute> AttributesFor(ITypeReference implementedInterface);
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsForeignObject();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.get_ContainingUnitNamespace();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
}
public interface Microsoft.Cci.INamespaceTypeReference {
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public ushort GenericParameterCount { get; }
    public INamespaceTypeDefinition ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public abstract virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual INamespaceTypeDefinition get_ResolvedType();
    public abstract virtual bool get_KeepDistinctFromDefinition();
}
internal abstract class Microsoft.Cci.INamespaceTypeReferenceContract : object {
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public ushort GenericParameterCount { get; }
    public INamespaceTypeDefinition ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual INamespaceTypeDefinition get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.INameTable {
    public IName EmptyName { get; }
    public IName Address { get; }
    public IName AllowMultiple { get; }
    public IName BeginInvoke { get; }
    public IName BoolOpBool { get; }
    public IName Combine { get; }
    public IName Concat { get; }
    public IName DecimalOpDecimal { get; }
    public IName DelegateOpDelegate { get; }
    public IName EndInvoke { get; }
    public IName EnumOpEnum { get; }
    public IName EnumOpNum { get; }
    public IName Equals { get; }
    public IName Float32OpFloat32 { get; }
    public IName Float64OpFloat64 { get; }
    public IName Get { get; }
    public IName global { get; }
    public IName HasValue { get; }
    public IName Inherited { get; }
    public IName Invoke { get; }
    public IName Int16OpInt16 { get; }
    public IName Int32OpInt32 { get; }
    public IName Int32OpUInt32 { get; }
    public IName Int64OpInt32 { get; }
    public IName Int64OpUInt32 { get; }
    public IName Int64OpUInt64 { get; }
    public IName Int64OpInt64 { get; }
    public IName Int8OpInt8 { get; }
    public IName NullCoalescing { get; }
    public IName NumOpEnum { get; }
    public IName ObjectOpObject { get; }
    public IName ObjectOpString { get; }
    public IName OpAddition { get; }
    public IName OpBitwiseAnd { get; }
    public IName OpBitwiseOr { get; }
    public IName OpEnum { get; }
    public IName OpEquality { get; }
    public IName OpExplicit { get; }
    public IName OpImplicit { get; }
    public IName OpInequality { get; }
    public IName OpInt8 { get; }
    public IName OpInt16 { get; }
    public IName OpInt32 { get; }
    public IName OpInt64 { get; }
    public IName OpComma { get; }
    public IName OpConcatentation { get; }
    public IName OpDivision { get; }
    public IName OpExclusiveOr { get; }
    public IName OpExponentiation { get; }
    public IName OpFalse { get; }
    public IName OpFloat32 { get; }
    public IName OpFloat64 { get; }
    public IName OpGreaterThan { get; }
    public IName OpGreaterThanOrEqual { get; }
    public IName OpIntegerDivision { get; }
    public IName OpLeftShift { get; }
    public IName OpLessThan { get; }
    public IName OpLessThanOrEqual { get; }
    public IName OpLike { get; }
    public IName OpLogicalNot { get; }
    public IName OpLogicalOr { get; }
    public IName OpModulus { get; }
    public IName OpMultiply { get; }
    public IName OpOnesComplement { get; }
    public IName OpBoolean { get; }
    public IName OpChar { get; }
    public IName OpDecimal { get; }
    public IName OpDecrement { get; }
    public IName OpIncrement { get; }
    public IName OpRightShift { get; }
    public IName OpSubtraction { get; }
    public IName OpTrue { get; }
    public IName OpUInt8 { get; }
    public IName OpUInt16 { get; }
    public IName OpUInt32 { get; }
    public IName OpUInt64 { get; }
    public IName OpUnaryNegation { get; }
    public IName OpUnaryPlus { get; }
    public IName StringOpString { get; }
    public IName StringOpObject { get; }
    public IName UIntPtrOpUIntPtr { get; }
    public IName UInt32OpInt32 { get; }
    public IName UInt32OpUInt32 { get; }
    public IName UInt64OpInt32 { get; }
    public IName UInt64OpUInt32 { get; }
    public IName UInt64OpUInt64 { get; }
    public IName value { get; }
    public IName System { get; }
    public IName Void { get; }
    public IName VoidPtrOpVoidPtr { get; }
    public IName Boolean { get; }
    public IName Cctor { get; }
    public IName Char { get; }
    public IName Ctor { get; }
    public IName Byte { get; }
    public IName SByte { get; }
    public IName Int16 { get; }
    public IName UInt16 { get; }
    public IName Int32 { get; }
    public IName UInt32 { get; }
    public IName Int64 { get; }
    public IName UInt64 { get; }
    public IName String { get; }
    public IName IntPtr { get; }
    public IName UIntPtr { get; }
    public IName Object { get; }
    public IName Remove { get; }
    public IName Result { get; }
    public IName Set { get; }
    public IName Single { get; }
    public IName Double { get; }
    public IName TypedReference { get; }
    public IName Enum { get; }
    public IName Length { get; }
    public IName LongLength { get; }
    public IName MulticastDelegate { get; }
    public IName ValueType { get; }
    public IName Type { get; }
    public IName Array { get; }
    public IName Attribute { get; }
    public IName AttributeUsageAttribute { get; }
    public IName DateTime { get; }
    public IName DebuggerHiddenAttribute { get; }
    public IName Decimal { get; }
    public IName Delegate { get; }
    public IName Diagnostics { get; }
    public IName DBNull { get; }
    public IName Nullable { get; }
    public abstract virtual IName get_EmptyName();
    public abstract virtual IName GetNameFor(string name);
    public abstract virtual IName get_Address();
    public abstract virtual IName get_AllowMultiple();
    public abstract virtual IName get_BeginInvoke();
    public abstract virtual IName get_BoolOpBool();
    public abstract virtual IName get_Combine();
    public abstract virtual IName get_Concat();
    public abstract virtual IName get_DecimalOpDecimal();
    public abstract virtual IName get_DelegateOpDelegate();
    public abstract virtual IName get_EndInvoke();
    public abstract virtual IName get_EnumOpEnum();
    public abstract virtual IName get_EnumOpNum();
    public abstract virtual IName get_Equals();
    public abstract virtual IName get_Float32OpFloat32();
    public abstract virtual IName get_Float64OpFloat64();
    public abstract virtual IName get_Get();
    public abstract virtual IName get_global();
    public abstract virtual IName get_HasValue();
    public abstract virtual IName get_Inherited();
    public abstract virtual IName get_Invoke();
    public abstract virtual IName get_Int16OpInt16();
    public abstract virtual IName get_Int32OpInt32();
    public abstract virtual IName get_Int32OpUInt32();
    public abstract virtual IName get_Int64OpInt32();
    public abstract virtual IName get_Int64OpUInt32();
    public abstract virtual IName get_Int64OpUInt64();
    public abstract virtual IName get_Int64OpInt64();
    public abstract virtual IName get_Int8OpInt8();
    public abstract virtual IName get_NullCoalescing();
    public abstract virtual IName get_NumOpEnum();
    public abstract virtual IName get_ObjectOpObject();
    public abstract virtual IName get_ObjectOpString();
    public abstract virtual IName get_OpAddition();
    public abstract virtual IName get_OpBitwiseAnd();
    public abstract virtual IName get_OpBitwiseOr();
    public abstract virtual IName get_OpEnum();
    public abstract virtual IName get_OpEquality();
    public abstract virtual IName get_OpExplicit();
    public abstract virtual IName get_OpImplicit();
    public abstract virtual IName get_OpInequality();
    public abstract virtual IName get_OpInt8();
    public abstract virtual IName get_OpInt16();
    public abstract virtual IName get_OpInt32();
    public abstract virtual IName get_OpInt64();
    public abstract virtual IName get_OpComma();
    public abstract virtual IName get_OpConcatentation();
    public abstract virtual IName get_OpDivision();
    public abstract virtual IName get_OpExclusiveOr();
    public abstract virtual IName get_OpExponentiation();
    public abstract virtual IName get_OpFalse();
    public abstract virtual IName get_OpFloat32();
    public abstract virtual IName get_OpFloat64();
    public abstract virtual IName get_OpGreaterThan();
    public abstract virtual IName get_OpGreaterThanOrEqual();
    public abstract virtual IName get_OpIntegerDivision();
    public abstract virtual IName get_OpLeftShift();
    public abstract virtual IName get_OpLessThan();
    public abstract virtual IName get_OpLessThanOrEqual();
    public abstract virtual IName get_OpLike();
    public abstract virtual IName get_OpLogicalNot();
    public abstract virtual IName get_OpLogicalOr();
    public abstract virtual IName get_OpModulus();
    public abstract virtual IName get_OpMultiply();
    public abstract virtual IName get_OpOnesComplement();
    public abstract virtual IName get_OpBoolean();
    public abstract virtual IName get_OpChar();
    public abstract virtual IName get_OpDecimal();
    public abstract virtual IName get_OpDecrement();
    public abstract virtual IName get_OpIncrement();
    public abstract virtual IName get_OpRightShift();
    public abstract virtual IName get_OpSubtraction();
    public abstract virtual IName get_OpTrue();
    public abstract virtual IName get_OpUInt8();
    public abstract virtual IName get_OpUInt16();
    public abstract virtual IName get_OpUInt32();
    public abstract virtual IName get_OpUInt64();
    public abstract virtual IName get_OpUnaryNegation();
    public abstract virtual IName get_OpUnaryPlus();
    public abstract virtual IName get_StringOpString();
    public abstract virtual IName get_StringOpObject();
    public abstract virtual IName get_UIntPtrOpUIntPtr();
    public abstract virtual IName get_UInt32OpInt32();
    public abstract virtual IName get_UInt32OpUInt32();
    public abstract virtual IName get_UInt64OpInt32();
    public abstract virtual IName get_UInt64OpUInt32();
    public abstract virtual IName get_UInt64OpUInt64();
    public abstract virtual IName get_value();
    public abstract virtual IName get_System();
    public abstract virtual IName get_Void();
    public abstract virtual IName get_VoidPtrOpVoidPtr();
    public abstract virtual IName get_Boolean();
    public abstract virtual IName get_Cctor();
    public abstract virtual IName get_Char();
    public abstract virtual IName get_Ctor();
    public abstract virtual IName get_Byte();
    public abstract virtual IName get_SByte();
    public abstract virtual IName get_Int16();
    public abstract virtual IName get_UInt16();
    public abstract virtual IName get_Int32();
    public abstract virtual IName get_UInt32();
    public abstract virtual IName get_Int64();
    public abstract virtual IName get_UInt64();
    public abstract virtual IName get_String();
    public abstract virtual IName get_IntPtr();
    public abstract virtual IName get_UIntPtr();
    public abstract virtual IName get_Object();
    public abstract virtual IName get_Remove();
    public abstract virtual IName get_Result();
    public abstract virtual IName get_Set();
    public abstract virtual IName get_Single();
    public abstract virtual IName get_Double();
    public abstract virtual IName get_TypedReference();
    public abstract virtual IName get_Enum();
    public abstract virtual IName get_Length();
    public abstract virtual IName get_LongLength();
    public abstract virtual IName get_MulticastDelegate();
    public abstract virtual IName get_ValueType();
    public abstract virtual IName get_Type();
    public abstract virtual IName get_Array();
    public abstract virtual IName get_Attribute();
    public abstract virtual IName get_AttributeUsageAttribute();
    public abstract virtual IName get_DateTime();
    public abstract virtual IName get_DebuggerHiddenAttribute();
    public abstract virtual IName get_Decimal();
    public abstract virtual IName get_Delegate();
    public abstract virtual IName get_Diagnostics();
    public abstract virtual IName get_DBNull();
    public abstract virtual IName get_Nullable();
}
internal abstract class Microsoft.Cci.INameTableContract : object {
    public IName EmptyName { get; }
    public IName Address { get; }
    public IName AllowMultiple { get; }
    public IName BeginInvoke { get; }
    public IName BoolOpBool { get; }
    public IName Combine { get; }
    public IName Concat { get; }
    public IName DecimalOpDecimal { get; }
    public IName DelegateOpDelegate { get; }
    public IName EndInvoke { get; }
    public IName EnumOpEnum { get; }
    public IName EnumOpNum { get; }
    public IName Equals { get; }
    public IName Float32OpFloat32 { get; }
    public IName Float64OpFloat64 { get; }
    public IName Get { get; }
    public IName global { get; }
    public IName HasValue { get; }
    public IName Inherited { get; }
    public IName Invoke { get; }
    public IName Int16OpInt16 { get; }
    public IName Int32OpInt32 { get; }
    public IName Int32OpUInt32 { get; }
    public IName Int64OpInt32 { get; }
    public IName Int64OpUInt32 { get; }
    public IName Int64OpUInt64 { get; }
    public IName Int64OpInt64 { get; }
    public IName Int8OpInt8 { get; }
    public IName NullCoalescing { get; }
    public IName NumOpEnum { get; }
    public IName ObjectOpObject { get; }
    public IName ObjectOpString { get; }
    public IName OpAddition { get; }
    public IName OpBitwiseAnd { get; }
    public IName OpBitwiseOr { get; }
    public IName OpEnum { get; }
    public IName OpEquality { get; }
    public IName OpExplicit { get; }
    public IName OpImplicit { get; }
    public IName OpInequality { get; }
    public IName OpInt8 { get; }
    public IName OpInt16 { get; }
    public IName OpInt32 { get; }
    public IName OpInt64 { get; }
    public IName OpComma { get; }
    public IName OpConcatentation { get; }
    public IName OpDivision { get; }
    public IName OpExclusiveOr { get; }
    public IName OpExponentiation { get; }
    public IName OpFalse { get; }
    public IName OpFloat32 { get; }
    public IName OpFloat64 { get; }
    public IName OpGreaterThan { get; }
    public IName OpGreaterThanOrEqual { get; }
    public IName OpIntegerDivision { get; }
    public IName OpLeftShift { get; }
    public IName OpLessThan { get; }
    public IName OpLessThanOrEqual { get; }
    public IName OpLike { get; }
    public IName OpLogicalNot { get; }
    public IName OpLogicalOr { get; }
    public IName OpModulus { get; }
    public IName OpMultiply { get; }
    public IName OpOnesComplement { get; }
    public IName OpBoolean { get; }
    public IName OpChar { get; }
    public IName OpDecimal { get; }
    public IName OpDecrement { get; }
    public IName OpIncrement { get; }
    public IName OpRightShift { get; }
    public IName OpSubtraction { get; }
    public IName OpTrue { get; }
    public IName OpUInt8 { get; }
    public IName OpUInt16 { get; }
    public IName OpUInt32 { get; }
    public IName OpUInt64 { get; }
    public IName OpUnaryNegation { get; }
    public IName OpUnaryPlus { get; }
    public IName StringOpString { get; }
    public IName StringOpObject { get; }
    public IName UIntPtrOpUIntPtr { get; }
    public IName UInt32OpInt32 { get; }
    public IName UInt32OpUInt32 { get; }
    public IName UInt64OpInt32 { get; }
    public IName UInt64OpUInt32 { get; }
    public IName UInt64OpUInt64 { get; }
    public IName value { get; }
    public IName System { get; }
    public IName Void { get; }
    public IName VoidPtrOpVoidPtr { get; }
    public IName Boolean { get; }
    public IName Cctor { get; }
    public IName Char { get; }
    public IName Ctor { get; }
    public IName Byte { get; }
    public IName SByte { get; }
    public IName Int16 { get; }
    public IName UInt16 { get; }
    public IName Int32 { get; }
    public IName UInt32 { get; }
    public IName Int64 { get; }
    public IName UInt64 { get; }
    public IName String { get; }
    public IName IntPtr { get; }
    public IName UIntPtr { get; }
    public IName Object { get; }
    public IName Remove { get; }
    public IName Result { get; }
    public IName Set { get; }
    public IName Single { get; }
    public IName Double { get; }
    public IName TypedReference { get; }
    public IName Enum { get; }
    public IName Length { get; }
    public IName LongLength { get; }
    public IName MulticastDelegate { get; }
    public IName ValueType { get; }
    public IName Type { get; }
    public IName Array { get; }
    public IName Attribute { get; }
    public IName AttributeUsageAttribute { get; }
    public IName DateTime { get; }
    public IName DebuggerHiddenAttribute { get; }
    public IName Decimal { get; }
    public IName Delegate { get; }
    public IName Diagnostics { get; }
    public IName DBNull { get; }
    public IName Nullable { get; }
    public sealed virtual IName get_EmptyName();
    public sealed virtual IName GetNameFor(string name);
    public sealed virtual IName get_Address();
    public sealed virtual IName get_AllowMultiple();
    public sealed virtual IName get_BeginInvoke();
    public sealed virtual IName get_BoolOpBool();
    public sealed virtual IName get_Combine();
    public sealed virtual IName get_Concat();
    public sealed virtual IName get_DecimalOpDecimal();
    public sealed virtual IName get_DelegateOpDelegate();
    public sealed virtual IName get_EndInvoke();
    public sealed virtual IName get_EnumOpEnum();
    public sealed virtual IName get_EnumOpNum();
    public sealed virtual IName get_Equals();
    public sealed virtual IName get_Float32OpFloat32();
    public sealed virtual IName get_Float64OpFloat64();
    public sealed virtual IName get_Get();
    public sealed virtual IName get_global();
    public sealed virtual IName get_HasValue();
    public sealed virtual IName get_Inherited();
    public sealed virtual IName get_Invoke();
    public sealed virtual IName get_Int16OpInt16();
    public sealed virtual IName get_Int32OpInt32();
    public sealed virtual IName get_Int32OpUInt32();
    public sealed virtual IName get_Int64OpInt32();
    public sealed virtual IName get_Int64OpUInt32();
    public sealed virtual IName get_Int64OpUInt64();
    public sealed virtual IName get_Int64OpInt64();
    public sealed virtual IName get_Int8OpInt8();
    public sealed virtual IName get_NullCoalescing();
    public sealed virtual IName get_NumOpEnum();
    public sealed virtual IName get_ObjectOpObject();
    public sealed virtual IName get_ObjectOpString();
    public sealed virtual IName get_OpAddition();
    public sealed virtual IName get_OpBitwiseAnd();
    public sealed virtual IName get_OpBitwiseOr();
    public sealed virtual IName get_OpEnum();
    public sealed virtual IName get_OpEquality();
    public sealed virtual IName get_OpExplicit();
    public sealed virtual IName get_OpImplicit();
    public sealed virtual IName get_OpInequality();
    public sealed virtual IName get_OpInt8();
    public sealed virtual IName get_OpInt16();
    public sealed virtual IName get_OpInt32();
    public sealed virtual IName get_OpInt64();
    public sealed virtual IName get_OpComma();
    public sealed virtual IName get_OpConcatentation();
    public sealed virtual IName get_OpDivision();
    public sealed virtual IName get_OpExclusiveOr();
    public sealed virtual IName get_OpExponentiation();
    public sealed virtual IName get_OpFalse();
    public sealed virtual IName get_OpFloat32();
    public sealed virtual IName get_OpFloat64();
    public sealed virtual IName get_OpGreaterThan();
    public sealed virtual IName get_OpGreaterThanOrEqual();
    public sealed virtual IName get_OpIntegerDivision();
    public sealed virtual IName get_OpLeftShift();
    public sealed virtual IName get_OpLessThan();
    public sealed virtual IName get_OpLessThanOrEqual();
    public sealed virtual IName get_OpLike();
    public sealed virtual IName get_OpLogicalNot();
    public sealed virtual IName get_OpLogicalOr();
    public sealed virtual IName get_OpModulus();
    public sealed virtual IName get_OpMultiply();
    public sealed virtual IName get_OpOnesComplement();
    public sealed virtual IName get_OpBoolean();
    public sealed virtual IName get_OpChar();
    public sealed virtual IName get_OpDecimal();
    public sealed virtual IName get_OpDecrement();
    public sealed virtual IName get_OpIncrement();
    public sealed virtual IName get_OpRightShift();
    public sealed virtual IName get_OpSubtraction();
    public sealed virtual IName get_OpTrue();
    public sealed virtual IName get_OpUInt8();
    public sealed virtual IName get_OpUInt16();
    public sealed virtual IName get_OpUInt32();
    public sealed virtual IName get_OpUInt64();
    public sealed virtual IName get_OpUnaryNegation();
    public sealed virtual IName get_OpUnaryPlus();
    public sealed virtual IName get_StringOpString();
    public sealed virtual IName get_StringOpObject();
    public sealed virtual IName get_UIntPtrOpUIntPtr();
    public sealed virtual IName get_UInt32OpInt32();
    public sealed virtual IName get_UInt32OpUInt32();
    public sealed virtual IName get_UInt64OpInt32();
    public sealed virtual IName get_UInt64OpUInt32();
    public sealed virtual IName get_UInt64OpUInt64();
    public sealed virtual IName get_value();
    public sealed virtual IName get_System();
    public sealed virtual IName get_Void();
    public sealed virtual IName get_VoidPtrOpVoidPtr();
    public sealed virtual IName get_Boolean();
    public sealed virtual IName get_Cctor();
    public sealed virtual IName get_Char();
    public sealed virtual IName get_Ctor();
    public sealed virtual IName get_Byte();
    public sealed virtual IName get_SByte();
    public sealed virtual IName get_Int16();
    public sealed virtual IName get_UInt16();
    public sealed virtual IName get_Int32();
    public sealed virtual IName get_UInt32();
    public sealed virtual IName get_Int64();
    public sealed virtual IName get_UInt64();
    public sealed virtual IName get_String();
    public sealed virtual IName get_IntPtr();
    public sealed virtual IName get_UIntPtr();
    public sealed virtual IName get_Object();
    public sealed virtual IName get_Remove();
    public sealed virtual IName get_Result();
    public sealed virtual IName get_Set();
    public sealed virtual IName get_Single();
    public sealed virtual IName get_Double();
    public sealed virtual IName get_TypedReference();
    public sealed virtual IName get_Enum();
    public sealed virtual IName get_Length();
    public sealed virtual IName get_LongLength();
    public sealed virtual IName get_MulticastDelegate();
    public sealed virtual IName get_ValueType();
    public sealed virtual IName get_Type();
    public sealed virtual IName get_Array();
    public sealed virtual IName get_Attribute();
    public sealed virtual IName get_AttributeUsageAttribute();
    public sealed virtual IName get_DateTime();
    public sealed virtual IName get_DebuggerHiddenAttribute();
    public sealed virtual IName get_Decimal();
    public sealed virtual IName get_Delegate();
    public sealed virtual IName get_Diagnostics();
    public sealed virtual IName get_DBNull();
    public sealed virtual IName get_Nullable();
}
public class Microsoft.Cci.IncludedSourceLocation : object {
    private int length;
    private int startIndex;
    private SourceDocumentWithInclusion sourceDocument;
    public int EndColumn { get; }
    public int EndIndex { get; }
    public int EndLine { get; }
    private int InclusionStartLine { get; }
    public int Length { get; }
    public string OriginalSourceDocumentName { get; }
    public int OriginalEndLine { get; }
    public int OriginalStartLine { get; }
    public string Source { get; }
    public int StartColumn { get; }
    public int StartIndex { get; }
    public int StartLine { get; }
    public SourceDocumentWithInclusion SourceDocument { get; }
    private IPrimarySourceDocument Microsoft.Cci.IPrimarySourceLocation.PrimarySourceDocument { get; }
    private ISourceDocument Microsoft.Cci.ISourceLocation.SourceDocument { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    internal IncludedSourceLocation(SourceDocumentWithInclusion document, int startIndex, int length);
    private void ObjectInvariant();
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_EndLine();
    private int get_InclusionStartLine();
    public sealed virtual int get_Length();
    public sealed virtual string get_OriginalSourceDocumentName();
    public sealed virtual int get_OriginalEndLine();
    public sealed virtual int get_OriginalStartLine();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartIndex();
    public sealed virtual int get_StartLine();
    public SourceDocumentWithInclusion get_SourceDocument();
    private sealed virtual override IPrimarySourceDocument Microsoft.Cci.IPrimarySourceLocation.get_PrimarySourceDocument();
    private sealed virtual override ISourceDocument Microsoft.Cci.ISourceLocation.get_SourceDocument();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
public interface Microsoft.Cci.INestedAliasForType {
}
public interface Microsoft.Cci.INestedTypeDefinition {
    public bool DoesNotInheritGenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public abstract virtual bool get_DoesNotInheritGenericParameters();
    public abstract virtual ushort get_GenericParameterCount();
}
internal abstract class Microsoft.Cci.INestedTypeDefinitionContract : object {
    private ushort Microsoft.Cci.INestedTypeDefinition.GenericParameterCount { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public bool DoesNotInheritGenericParameters { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    private ushort Microsoft.Cci.INamedTypeDefinition.GenericParameterCount { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private ushort Microsoft.Cci.INestedTypeReference.GenericParameterCount { get; }
    private sealed virtual override ushort Microsoft.Cci.INestedTypeDefinition.get_GenericParameterCount();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual bool get_DoesNotInheritGenericParameters();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeDefinition.get_GenericParameterCount();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override ushort Microsoft.Cci.INestedTypeReference.get_GenericParameterCount();
}
public interface Microsoft.Cci.INestedTypeReference {
    public ushort GenericParameterCount { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual INestedTypeDefinition get_ResolvedType();
}
internal abstract class Microsoft.Cci.INestedTypeReferenceContract : object {
    public ushort GenericParameterCount { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.INestedUnitNamespace {
    public IUnitNamespace ContainingUnitNamespace { get; }
    public abstract virtual IUnitNamespace get_ContainingUnitNamespace();
}
internal abstract class Microsoft.Cci.INestedUnitNamespaceContract : object {
    public IUnitNamespace ContainingUnitNamespace { get; }
    public IUnit Unit { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    private IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public sealed virtual IUnit get_Unit();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.get_ContainingUnitNamespace();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.INestedUnitNamespaceReference {
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public abstract virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public abstract virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
}
internal abstract class Microsoft.Cci.INestedUnitNamespaceReferenceContract : object {
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public IUnitReference Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public sealed virtual IUnitReference get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.INestedUnitSetNamespace {
    public IUnitSetNamespace ContainingUnitSetNamespace { get; }
    public abstract virtual IUnitSetNamespace get_ContainingUnitSetNamespace();
}
internal abstract class Microsoft.Cci.INestedUnitSetNamespaceContract : object {
    public IUnitSetNamespace ContainingUnitSetNamespace { get; }
    public IUnitSet UnitSet { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public sealed virtual IUnitSetNamespace get_ContainingUnitSetNamespace();
    public sealed virtual IUnitSet get_UnitSet();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.INotEquality {
}
public class Microsoft.Cci.InternFactory : object {
    private UInt32 CurrentAssemblyInternValue;
    private UInt32 CurrentModuleInternValue;
    private UInt32 CurrentNamespaceInternValue;
    private UInt32 CurrentTypeInternValue;
    private UInt32 CurrentTypeListInternValue;
    private UInt32 CurrentCustomModifierInternValue;
    private UInt32 CurrentCustomModifierListInternValue;
    private UInt32 CurrentParameterTypeInternValue;
    private UInt32 CurrentParameterTypeListInternValue;
    private UInt32 CurrentSignatureInternValue;
    private UInt32 CurrentMethodReferenceInternValue;
    private UInt32 CurrentFieldReferenceInternValue;
    private IMethodReference CurrentMethodReference;
    private MultiHashtable`1<AssemblyStore> AssemblyHashtable;
    private MultiHashtable`1<ModuleStore> ModuleHashtable;
    private DoubleHashtable NestedNamespaceHashtable;
    private MultiHashtable`1<NamespaceTypeStore> NamespaceTypeHashtable;
    private Hashtable`1<MultiHashtable`1<NestedTypeStore>> NestedTypeHashtable;
    private Hashtable VectorTypeHashTable;
    private Hashtable PointerTypeHashTable;
    private Hashtable ManagedPointerTypeHashTable;
    private MultiHashtable`1<MatrixTypeStore> MatrixTypeHashtable;
    private DoubleHashtable TypeListHashtable;
    private DoubleHashtable GenericTypeInstanceHashtable;
    private DoubleHashtable GenericMethodInstanceHashtable;
    private DoubleHashtable GenericTypeParameterHashtable;
    private DoubleHashtable GenericMethodTypeParameterHashTable;
    private DoubleHashtable CustomModifierHashTable;
    private DoubleHashtable CustomModifierListHashTable;
    private MultiHashtable`1<ParameterTypeStore> ParameterTypeHashtable;
    private DoubleHashtable ParameterTypeListHashtable;
    private MultiHashtable`1<SignatureStore> SignatureHashtable;
    private Hashtable FunctionTypeHashTable;
    private DoubleHashtable ModifiedTypeHashtable;
    private Hashtable`1<MultiHashtable`1<SignatureStore>> MethodReferenceHashtable;
    private Hashtable`1<DoubleHashtable> FieldReferenceHashtable;
    public bool InternKeysAreReliablyUnique { get; }
    private void ObjectInvariant();
    private AssemblyStore GetAssemblyStore(AssemblyIdentity assemblyIdentity);
    private ModuleStore GetModuleStore(ModuleIdentity moduleIdentity);
    private UInt32 GetUnitRootNamespaceInternId(IUnitReference unitReference);
    private UInt32 GetNestedNamespaceInternId(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    private UInt32 GetUnitNamespaceInternId(IUnitNamespaceReference unitNamespaceReference);
    private UInt32 GetNamespaceTypeReferenceInternId(IUnitNamespaceReference containingUnitNamespace, IName typeName, UInt32 genericParameterCount);
    private UInt32 GetNestedTypeReferenceInternId(ITypeReference containingTypeReference, IName typeName, UInt32 genericParameterCount);
    private UInt32 GetVectorTypeReferenceInternId(ITypeReference elementTypeReference);
    private UInt32 GetMatrixTypeReferenceInternId(ITypeReference elementTypeReference, int rank, IEnumerable`1<ulong> sizes, IEnumerable`1<int> lowerBounds);
    private UInt32 GetTypeReferenceListInternedId(IEnumerable`1<ITypeReference> typeReferences);
    private UInt32 GetTypeReferenceListInternedId(IEnumerator`1<ITypeReference> typeReferences);
    private UInt32 GetTypeReferenceListInternedId(IReadOnlyList`1<ITypeReference> typeReferences, int i, int count);
    private UInt32 GetGenericTypeInstanceReferenceInternId(ITypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    private UInt32 GetPointerTypeReferenceInternId(ITypeReference targetTypeReference);
    private UInt32 GetManagedPointerTypeReferenceInternId(ITypeReference targetTypeReference);
    private UInt32 GetGenericTypeParameterReferenceInternId(ITypeReference definingTypeReference, int index);
    private static ITypeReference GetUninstantiatedGenericType(ITypeReference typeReference);
    private UInt32 GetGenericMethodParameterReferenceInternId(IMethodReference definingMethodReference, UInt32 index);
    private UInt32 GetParameterTypeInternId(IParameterTypeInformation parameterTypeInformation);
    private UInt32 GetParameterTypeListInternId(IEnumerator`1<IParameterTypeInformation> parameterTypeInformations, UInt32 pCount);
    private UInt32 GetSignatureInternId(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    private UInt32 GetMethodReferenceInternedId(IMethodReference potentiallySpecializedMethodReference);
    private UInt32 GetGenericMethodInstanceReferenceInternedKey(IGenericMethodInstanceReference genericMethodInstanceReference);
    private UInt32 GetFieldReferenceInternedId(IFieldReference fieldReference);
    private UInt32 GetFunctionPointerTypeReferenceInternId(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    private UInt32 GetCustomModifierInternId(ICustomModifier customModifier);
    private UInt32 GetCustomModifierListInternId(IEnumerator`1<ICustomModifier> customModifiers);
    private UInt32 GetTypeReferenceInterendIdIgnoringCustomModifiers(ITypeReference typeReference);
    private UInt32 GetModifiedTypeReferenceInternId(ITypeReference typeReference, IEnumerable`1<ICustomModifier> customModifiers);
    private UInt32 GetTypeReferenceInternId(ITypeReference typeReference);
    public bool get_InternKeysAreReliablyUnique();
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetAssemblyInternedKey(AssemblyIdentity assemblyIdentity);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetFieldInternedKey(IFieldReference methodReference);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetMethodInternedKey(IMethodReference methodReference);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetModuleInternedKey(ModuleIdentity moduleIdentity);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetVectorTypeReferenceInternedKey(ITypeReference elementTypeReference);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetMatrixTypeReferenceInternedKey(ITypeReference elementTypeReference, int rank, IEnumerable`1<ulong> sizes, IEnumerable`1<int> lowerBounds);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetGenericTypeInstanceReferenceInternedKey(ITypeReference genericTypeReference, IEnumerable`1<ITypeReference> genericArguments);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetManagedPointerTypeReferenceInternedKey(ITypeReference targetTypeReference);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetFunctionPointerTypeReferenceInternedKey(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference returnType);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetTypeReferenceInternedKey(ITypeReference typeReference);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetNamespaceTypeReferenceInternedKey(IUnitNamespaceReference containingUnitNamespace, IName typeName, UInt32 genericParameterCount);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetNestedTypeReferenceInternedKey(ITypeReference containingTypeReference, IName typeName, UInt32 genericParameterCount);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetGenericTypeParameterReferenceInternedKey(ITypeReference definingTypeReference, int index);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetModifiedTypeReferenceInternedKey(ITypeReference typeReference, IEnumerable`1<ICustomModifier> customModifiers);
    private sealed virtual override UInt32 Microsoft.Cci.IInternFactory.GetGenericMethodParameterReferenceInternedKey(IMethodReference methodReference, int index);
}
public interface Microsoft.Cci.IObjectWithLocations {
    public IEnumerable`1<ILocation> Locations { get; }
    public abstract virtual IEnumerable`1<ILocation> get_Locations();
}
internal abstract class Microsoft.Cci.IObjectWithLocationsContract : object {
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IOldValue {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
internal abstract class Microsoft.Cci.IOldValueContract : object {
    public IExpression Expression { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Expression();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IOnesComplement {
}
public interface Microsoft.Cci.IOperation {
    public OperationCode OperationCode { get; }
    public UInt32 Offset { get; }
    public ILocation Location { get; }
    public object Value { get; }
    public abstract virtual OperationCode get_OperationCode();
    public abstract virtual UInt32 get_Offset();
    public abstract virtual ILocation get_Location();
    public abstract virtual object get_Value();
}
internal abstract class Microsoft.Cci.IOperationContract : object {
    public OperationCode OperationCode { get; }
    public UInt32 Offset { get; }
    public ILocation Location { get; }
    public object Value { get; }
    public sealed virtual OperationCode get_OperationCode();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual ILocation get_Location();
    public sealed virtual object get_Value();
}
public interface Microsoft.Cci.IOperationExceptionInformation {
    public HandlerKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public UInt32 TryStartOffset { get; }
    public UInt32 TryEndOffset { get; }
    public UInt32 FilterDecisionStartOffset { get; }
    public UInt32 HandlerStartOffset { get; }
    public UInt32 HandlerEndOffset { get; }
    public abstract virtual HandlerKind get_HandlerKind();
    public abstract virtual ITypeReference get_ExceptionType();
    public abstract virtual UInt32 get_TryStartOffset();
    public abstract virtual UInt32 get_TryEndOffset();
    public abstract virtual UInt32 get_FilterDecisionStartOffset();
    public abstract virtual UInt32 get_HandlerStartOffset();
    public abstract virtual UInt32 get_HandlerEndOffset();
}
internal abstract class Microsoft.Cci.IOperationExceptionInformationContract : object {
    public HandlerKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public UInt32 TryStartOffset { get; }
    public UInt32 TryEndOffset { get; }
    public UInt32 FilterDecisionStartOffset { get; }
    public UInt32 HandlerStartOffset { get; }
    public UInt32 HandlerEndOffset { get; }
    public sealed virtual HandlerKind get_HandlerKind();
    public sealed virtual ITypeReference get_ExceptionType();
    public sealed virtual UInt32 get_TryStartOffset();
    public sealed virtual UInt32 get_TryEndOffset();
    public sealed virtual UInt32 get_FilterDecisionStartOffset();
    public sealed virtual UInt32 get_HandlerStartOffset();
    public sealed virtual UInt32 get_HandlerEndOffset();
}
public interface Microsoft.Cci.IOutArgument {
    public ITargetExpression Expression { get; }
    public abstract virtual ITargetExpression get_Expression();
}
public interface Microsoft.Cci.IParameterDefinition {
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference ParamArrayElementType { get; }
    public abstract virtual IMetadataConstant get_DefaultValue();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsOut();
    public abstract virtual bool get_IsParameterArray();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual ITypeReference get_ParamArrayElementType();
}
public interface Microsoft.Cci.IParameterListEntry {
    public ushort Index { get; }
    public abstract virtual ushort get_Index();
}
public interface Microsoft.Cci.IParameterTypeInformation {
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    public abstract virtual ISignature get_ContainingSignature();
    public abstract virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual bool get_IsByReference();
    public abstract virtual bool get_IsModified();
    public abstract virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.IParameterTypeInformationContract : object {
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    public ushort Index { get; }
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ushort get_Index();
}
public interface Microsoft.Cci.IPdbWriter {
    public abstract virtual void CloseMethod(UInt32 offset);
    public abstract virtual void CloseScope(UInt32 offset);
    public abstract virtual void CloseTokenSourceLocationsScope();
    public abstract virtual void DefineCustomMetadata(string name, Byte[] metadata);
    public abstract virtual void DefineLocalConstant(string name, object value, UInt32 contantSignatureToken);
    public abstract virtual void DefineLocalVariable(UInt32 index, string name, bool isCompilerGenerated, UInt32 localVariablesSignatureToken);
    public abstract virtual void DefineSequencePoint(ILocation location, UInt32 offset);
    public abstract virtual void DefineTokenSourceLocation(UInt32 token, ILocation location);
    public abstract virtual PeDebugDirectory GetDebugDirectory();
    public abstract virtual void OpenMethod(UInt32 methodToken);
    public abstract virtual void OpenScope(UInt32 offset);
    public abstract virtual void OpenTokenSourceLocationsScope();
    public abstract virtual void SetEntryPoint(UInt32 entryMethodToken);
    public abstract virtual void UsingNamespace(string fullName);
}
public interface Microsoft.Cci.IPESection {
    public IName SectionName { get; }
    public PESectionCharacteristics Characteristics { get; }
    public int VirtualAddress { get; }
    public int VirtualSize { get; }
    public int SizeOfRawData { get; }
    public IEnumerable`1<byte> Rawdata { get; }
    public abstract virtual IName get_SectionName();
    public abstract virtual PESectionCharacteristics get_Characteristics();
    public abstract virtual int get_VirtualAddress();
    public abstract virtual int get_VirtualSize();
    public abstract virtual int get_SizeOfRawData();
    public abstract virtual IEnumerable`1<byte> get_Rawdata();
}
internal abstract class Microsoft.Cci.IPESectionContract : object {
    public IName SectionName { get; }
    public PESectionCharacteristics Characteristics { get; }
    public int VirtualAddress { get; }
    public int VirtualSize { get; }
    public int SizeOfRawData { get; }
    public IEnumerable`1<byte> Rawdata { get; }
    public sealed virtual IName get_SectionName();
    public sealed virtual PESectionCharacteristics get_Characteristics();
    public sealed virtual int get_VirtualAddress();
    public sealed virtual int get_VirtualSize();
    public sealed virtual int get_SizeOfRawData();
    public sealed virtual IEnumerable`1<byte> get_Rawdata();
}
public interface Microsoft.Cci.IPlatformInvokeInformation {
    public IName ImportName { get; }
    public IModuleReference ImportModule { get; }
    public StringFormatKind StringFormat { get; }
    public bool NoMangle { get; }
    public PInvokeCallingConvention PInvokeCallingConvention { get; }
    public bool SupportsLastError { get; }
    public Nullable`1<bool> UseBestFit { get; }
    public Nullable`1<bool> ThrowExceptionForUnmappableChar { get; }
    public abstract virtual IName get_ImportName();
    public abstract virtual IModuleReference get_ImportModule();
    public abstract virtual StringFormatKind get_StringFormat();
    public abstract virtual bool get_NoMangle();
    public abstract virtual PInvokeCallingConvention get_PInvokeCallingConvention();
    public abstract virtual bool get_SupportsLastError();
    public abstract virtual Nullable`1<bool> get_UseBestFit();
    public abstract virtual Nullable`1<bool> get_ThrowExceptionForUnmappableChar();
}
internal abstract class Microsoft.Cci.IPlatformInvokeInformationContract : object {
    public IName ImportName { get; }
    public IModuleReference ImportModule { get; }
    public StringFormatKind StringFormat { get; }
    public bool NoMangle { get; }
    public PInvokeCallingConvention PInvokeCallingConvention { get; }
    public bool SupportsLastError { get; }
    public Nullable`1<bool> UseBestFit { get; }
    public Nullable`1<bool> ThrowExceptionForUnmappableChar { get; }
    public sealed virtual IName get_ImportName();
    public sealed virtual IModuleReference get_ImportModule();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_NoMangle();
    public sealed virtual PInvokeCallingConvention get_PInvokeCallingConvention();
    public sealed virtual bool get_SupportsLastError();
    public sealed virtual Nullable`1<bool> get_UseBestFit();
    public sealed virtual Nullable`1<bool> get_ThrowExceptionForUnmappableChar();
}
public interface Microsoft.Cci.IPlatformType {
    public INamespaceTypeReference SystemDiagnosticsContractsContract { get; }
    public byte PointerSize { get; }
    public INamespaceTypeReference SystemArgIterator { get; }
    public INamespaceTypeReference SystemArray { get; }
    public INamespaceTypeReference SystemAsyncCallback { get; }
    public INamespaceTypeReference SystemAttribute { get; }
    public INamespaceTypeReference SystemAttributeUsageAttribute { get; }
    public INamespaceTypeReference SystemBoolean { get; }
    public INamespaceTypeReference SystemChar { get; }
    public INamespaceTypeReference SystemCollectionsGenericDictionary { get; }
    public INamespaceTypeReference SystemCollectionsGenericICollection { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsGenericIList { get; }
    public INamespaceTypeReference SystemCollectionsICollection { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsIList { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralComparable { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralEquatable { get; }
    public INamespaceTypeReference SystemDateTime { get; }
    public INamespaceTypeReference SystemDateTimeOffset { get; }
    public INamespaceTypeReference SystemDecimal { get; }
    public INamespaceTypeReference SystemDelegate { get; }
    public INamespaceTypeReference SystemDBNull { get; }
    public INamespaceTypeReference SystemEnum { get; }
    public INamespaceTypeReference SystemException { get; }
    public INamespaceTypeReference SystemFloat32 { get; }
    public INamespaceTypeReference SystemFloat64 { get; }
    public INamespaceTypeReference SystemGlobalizationCultureInfo { get; }
    public INamespaceTypeReference SystemIAsyncResult { get; }
    public INamespaceTypeReference SystemICloneable { get; }
    public INamespaceTypeReference SystemContextStaticAttribute { get; }
    public INamespaceTypeReference SystemInt16 { get; }
    public INamespaceTypeReference SystemInt32 { get; }
    public INamespaceTypeReference SystemInt64 { get; }
    public INamespaceTypeReference SystemInt8 { get; }
    public INamespaceTypeReference SystemIntPtr { get; }
    public INamespaceTypeReference SystemMulticastDelegate { get; }
    public INamespaceTypeReference SystemNullable { get; }
    public INamespaceTypeReference SystemObject { get; }
    public INamespaceTypeReference SystemReflectionAssemblySignatureKeyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeArgumentHandle { get; }
    public INamespaceTypeReference SystemRuntimeFieldHandle { get; }
    public INamespaceTypeReference SystemRuntimeMethodHandle { get; }
    public INamespaceTypeReference SystemRuntimeTypeHandle { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCallConvCdecl { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCompilerGeneratedAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesExtensionAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesInternalsVisibleToAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsConst { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsVolatile { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesReferenceAssemblyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeInteropServicesDllImportAttribute { get; }
    public INamespaceTypeReference SystemSecurityPermissionsSecurityAction { get; }
    public INamespaceTypeReference SystemSecuritySecurityCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySecuritySafeCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySuppressUnmanagedCodeSecurityAttribute { get; }
    public INamespaceTypeReference SystemString { get; }
    public INamespaceTypeReference SystemThreadStaticAttribute { get; }
    public INamespaceTypeReference SystemType { get; }
    public INamespaceTypeReference SystemTypedReference { get; }
    public INamespaceTypeReference SystemUInt16 { get; }
    public INamespaceTypeReference SystemUInt32 { get; }
    public INamespaceTypeReference SystemUInt64 { get; }
    public INamespaceTypeReference SystemUInt8 { get; }
    public INamespaceTypeReference SystemUIntPtr { get; }
    public INamespaceTypeReference SystemValueType { get; }
    public INamespaceTypeReference SystemVoid { get; }
    public abstract virtual INamespaceTypeReference get_SystemDiagnosticsContractsContract();
    public abstract virtual byte get_PointerSize();
    public abstract virtual INamespaceTypeReference get_SystemArgIterator();
    public abstract virtual INamespaceTypeReference get_SystemArray();
    public abstract virtual INamespaceTypeReference get_SystemAsyncCallback();
    public abstract virtual INamespaceTypeReference get_SystemAttribute();
    public abstract virtual INamespaceTypeReference get_SystemAttributeUsageAttribute();
    public abstract virtual INamespaceTypeReference get_SystemBoolean();
    public abstract virtual INamespaceTypeReference get_SystemChar();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsGenericDictionary();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsGenericICollection();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerable();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerator();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsGenericIList();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsICollection();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsIEnumerable();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsIEnumerator();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsIList();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsIStructuralComparable();
    public abstract virtual INamespaceTypeReference get_SystemCollectionsIStructuralEquatable();
    public abstract virtual INamespaceTypeReference get_SystemDateTime();
    public abstract virtual INamespaceTypeReference get_SystemDateTimeOffset();
    public abstract virtual INamespaceTypeReference get_SystemDecimal();
    public abstract virtual INamespaceTypeReference get_SystemDelegate();
    public abstract virtual INamespaceTypeReference get_SystemDBNull();
    public abstract virtual INamespaceTypeReference get_SystemEnum();
    public abstract virtual INamespaceTypeReference get_SystemException();
    public abstract virtual INamespaceTypeReference get_SystemFloat32();
    public abstract virtual INamespaceTypeReference get_SystemFloat64();
    public abstract virtual INamespaceTypeReference get_SystemGlobalizationCultureInfo();
    public abstract virtual INamespaceTypeReference get_SystemIAsyncResult();
    public abstract virtual INamespaceTypeReference get_SystemICloneable();
    public abstract virtual INamespaceTypeReference get_SystemContextStaticAttribute();
    public abstract virtual INamespaceTypeReference get_SystemInt16();
    public abstract virtual INamespaceTypeReference get_SystemInt32();
    public abstract virtual INamespaceTypeReference get_SystemInt64();
    public abstract virtual INamespaceTypeReference get_SystemInt8();
    public abstract virtual INamespaceTypeReference get_SystemIntPtr();
    public abstract virtual INamespaceTypeReference get_SystemMulticastDelegate();
    public abstract virtual INamespaceTypeReference get_SystemNullable();
    public abstract virtual INamespaceTypeReference get_SystemObject();
    public abstract virtual INamespaceTypeReference get_SystemReflectionAssemblySignatureKeyAttribute();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeArgumentHandle();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeFieldHandle();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeMethodHandle();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeTypeHandle();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCallConvCdecl();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCompilerGeneratedAttribute();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesExtensionAttribute();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesInternalsVisibleToAttribute();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsConst();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsVolatile();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesReferenceAssemblyAttribute();
    public abstract virtual INamespaceTypeReference get_SystemRuntimeInteropServicesDllImportAttribute();
    public abstract virtual INamespaceTypeReference get_SystemSecurityPermissionsSecurityAction();
    public abstract virtual INamespaceTypeReference get_SystemSecuritySecurityCriticalAttribute();
    public abstract virtual INamespaceTypeReference get_SystemSecuritySecuritySafeCriticalAttribute();
    public abstract virtual INamespaceTypeReference get_SystemSecuritySuppressUnmanagedCodeSecurityAttribute();
    public abstract virtual INamespaceTypeReference get_SystemString();
    public abstract virtual INamespaceTypeReference get_SystemThreadStaticAttribute();
    public abstract virtual INamespaceTypeReference get_SystemType();
    public abstract virtual INamespaceTypeReference get_SystemTypedReference();
    public abstract virtual INamespaceTypeReference get_SystemUInt16();
    public abstract virtual INamespaceTypeReference get_SystemUInt32();
    public abstract virtual INamespaceTypeReference get_SystemUInt64();
    public abstract virtual INamespaceTypeReference get_SystemUInt8();
    public abstract virtual INamespaceTypeReference get_SystemUIntPtr();
    public abstract virtual INamespaceTypeReference get_SystemValueType();
    public abstract virtual INamespaceTypeReference get_SystemVoid();
    public abstract virtual INamespaceTypeReference GetTypeFor(PrimitiveTypeCode typeCode);
}
internal abstract class Microsoft.Cci.IPlatformTypeContract : object {
    public INamespaceTypeReference SystemDiagnosticsContractsContract { get; }
    public byte PointerSize { get; }
    public INamespaceTypeReference SystemArgIterator { get; }
    public INamespaceTypeReference SystemArray { get; }
    public INamespaceTypeReference SystemAsyncCallback { get; }
    public INamespaceTypeReference SystemAttribute { get; }
    public INamespaceTypeReference SystemAttributeUsageAttribute { get; }
    public INamespaceTypeReference SystemBoolean { get; }
    public INamespaceTypeReference SystemChar { get; }
    public INamespaceTypeReference SystemCollectionsGenericDictionary { get; }
    public INamespaceTypeReference SystemCollectionsGenericICollection { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsGenericIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsGenericIList { get; }
    public INamespaceTypeReference SystemCollectionsICollection { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerable { get; }
    public INamespaceTypeReference SystemCollectionsIEnumerator { get; }
    public INamespaceTypeReference SystemCollectionsIList { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralComparable { get; }
    public INamespaceTypeReference SystemCollectionsIStructuralEquatable { get; }
    public INamespaceTypeReference SystemDateTime { get; }
    public INamespaceTypeReference SystemDateTimeOffset { get; }
    public INamespaceTypeReference SystemDecimal { get; }
    public INamespaceTypeReference SystemDelegate { get; }
    public INamespaceTypeReference SystemDBNull { get; }
    public INamespaceTypeReference SystemEnum { get; }
    public INamespaceTypeReference SystemException { get; }
    public INamespaceTypeReference SystemFloat32 { get; }
    public INamespaceTypeReference SystemFloat64 { get; }
    public INamespaceTypeReference SystemGlobalizationCultureInfo { get; }
    public INamespaceTypeReference SystemIAsyncResult { get; }
    public INamespaceTypeReference SystemICloneable { get; }
    public INamespaceTypeReference SystemInt16 { get; }
    public INamespaceTypeReference SystemInt32 { get; }
    public INamespaceTypeReference SystemInt64 { get; }
    public INamespaceTypeReference SystemInt8 { get; }
    public INamespaceTypeReference SystemIntPtr { get; }
    public INamespaceTypeReference SystemMulticastDelegate { get; }
    public INamespaceTypeReference SystemNullable { get; }
    public INamespaceTypeReference SystemObject { get; }
    public INamespaceTypeReference SystemReflectionAssemblySignatureKeyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeArgumentHandle { get; }
    public INamespaceTypeReference SystemRuntimeFieldHandle { get; }
    public INamespaceTypeReference SystemRuntimeMethodHandle { get; }
    public INamespaceTypeReference SystemRuntimeTypeHandle { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCallConvCdecl { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesCompilerGeneratedAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesExtensionAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesInternalsVisibleToAttribute { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsConst { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesIsVolatile { get; }
    public INamespaceTypeReference SystemRuntimeCompilerServicesReferenceAssemblyAttribute { get; }
    public INamespaceTypeReference SystemRuntimeInteropServicesDllImportAttribute { get; }
    public INamespaceTypeReference SystemSecurityPermissionsSecurityAction { get; }
    public INamespaceTypeReference SystemSecuritySecurityCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySecuritySafeCriticalAttribute { get; }
    public INamespaceTypeReference SystemSecuritySuppressUnmanagedCodeSecurityAttribute { get; }
    public INamespaceTypeReference SystemString { get; }
    public INamespaceTypeReference SystemType { get; }
    public INamespaceTypeReference SystemTypedReference { get; }
    public INamespaceTypeReference SystemUInt16 { get; }
    public INamespaceTypeReference SystemUInt32 { get; }
    public INamespaceTypeReference SystemUInt64 { get; }
    public INamespaceTypeReference SystemUInt8 { get; }
    public INamespaceTypeReference SystemUIntPtr { get; }
    public INamespaceTypeReference SystemValueType { get; }
    public INamespaceTypeReference SystemVoid { get; }
    public INamespaceTypeReference SystemContextStaticAttribute { get; }
    public INamespaceTypeReference SystemThreadStaticAttribute { get; }
    public sealed virtual INamespaceTypeReference get_SystemDiagnosticsContractsContract();
    public sealed virtual byte get_PointerSize();
    public sealed virtual INamespaceTypeReference get_SystemArgIterator();
    public sealed virtual INamespaceTypeReference get_SystemArray();
    public sealed virtual INamespaceTypeReference get_SystemAsyncCallback();
    public sealed virtual INamespaceTypeReference get_SystemAttribute();
    public sealed virtual INamespaceTypeReference get_SystemAttributeUsageAttribute();
    public sealed virtual INamespaceTypeReference get_SystemBoolean();
    public sealed virtual INamespaceTypeReference get_SystemChar();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericDictionary();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericICollection();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIEnumerator();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsGenericIList();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsICollection();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIEnumerable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIEnumerator();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIList();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIStructuralComparable();
    public sealed virtual INamespaceTypeReference get_SystemCollectionsIStructuralEquatable();
    public sealed virtual INamespaceTypeReference get_SystemDateTime();
    public sealed virtual INamespaceTypeReference get_SystemDateTimeOffset();
    public sealed virtual INamespaceTypeReference get_SystemDecimal();
    public sealed virtual INamespaceTypeReference get_SystemDelegate();
    public sealed virtual INamespaceTypeReference get_SystemDBNull();
    public sealed virtual INamespaceTypeReference get_SystemEnum();
    public sealed virtual INamespaceTypeReference get_SystemException();
    public sealed virtual INamespaceTypeReference get_SystemFloat32();
    public sealed virtual INamespaceTypeReference get_SystemFloat64();
    public sealed virtual INamespaceTypeReference get_SystemGlobalizationCultureInfo();
    public sealed virtual INamespaceTypeReference get_SystemIAsyncResult();
    public sealed virtual INamespaceTypeReference get_SystemICloneable();
    public sealed virtual INamespaceTypeReference get_SystemInt16();
    public sealed virtual INamespaceTypeReference get_SystemInt32();
    public sealed virtual INamespaceTypeReference get_SystemInt64();
    public sealed virtual INamespaceTypeReference get_SystemInt8();
    public sealed virtual INamespaceTypeReference get_SystemIntPtr();
    public sealed virtual INamespaceTypeReference get_SystemMulticastDelegate();
    public sealed virtual INamespaceTypeReference get_SystemNullable();
    public sealed virtual INamespaceTypeReference get_SystemObject();
    public sealed virtual INamespaceTypeReference get_SystemReflectionAssemblySignatureKeyAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeArgumentHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeFieldHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeMethodHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeTypeHandle();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCallConvCdecl();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesCompilerGeneratedAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesExtensionAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesInternalsVisibleToAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsConst();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesIsVolatile();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeCompilerServicesReferenceAssemblyAttribute();
    public sealed virtual INamespaceTypeReference get_SystemRuntimeInteropServicesDllImportAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecurityPermissionsSecurityAction();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySecurityCriticalAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySecuritySafeCriticalAttribute();
    public sealed virtual INamespaceTypeReference get_SystemSecuritySuppressUnmanagedCodeSecurityAttribute();
    public sealed virtual INamespaceTypeReference get_SystemString();
    public sealed virtual INamespaceTypeReference get_SystemType();
    public sealed virtual INamespaceTypeReference get_SystemTypedReference();
    public sealed virtual INamespaceTypeReference get_SystemUInt16();
    public sealed virtual INamespaceTypeReference get_SystemUInt32();
    public sealed virtual INamespaceTypeReference get_SystemUInt64();
    public sealed virtual INamespaceTypeReference get_SystemUInt8();
    public sealed virtual INamespaceTypeReference get_SystemUIntPtr();
    public sealed virtual INamespaceTypeReference get_SystemValueType();
    public sealed virtual INamespaceTypeReference get_SystemVoid();
    public sealed virtual INamespaceTypeReference GetTypeFor(PrimitiveTypeCode typeCode);
    public sealed virtual INamespaceTypeReference get_SystemContextStaticAttribute();
    public sealed virtual INamespaceTypeReference get_SystemThreadStaticAttribute();
}
public interface Microsoft.Cci.IPointerCall {
    public IEnumerable`1<IExpression> Arguments { get; }
    public bool IsTailCall { get; }
    public IExpression Pointer { get; }
    public abstract virtual IEnumerable`1<IExpression> get_Arguments();
    public abstract virtual bool get_IsTailCall();
    public abstract virtual IExpression get_Pointer();
}
internal abstract class Microsoft.Cci.IPointerCallContract : object {
    public IEnumerable`1<IExpression> Arguments { get; }
    public bool IsTailCall { get; }
    public IExpression Pointer { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<IExpression> get_Arguments();
    public sealed virtual bool get_IsTailCall();
    public sealed virtual IExpression get_Pointer();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IPointerType {
}
public interface Microsoft.Cci.IPointerTypeReference {
    public ITypeReference TargetType { get; }
    public abstract virtual ITypeReference get_TargetType();
}
internal abstract class Microsoft.Cci.IPointerTypeReferenceContract : object {
    public ITypeReference TargetType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual ITypeReference get_TargetType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IPopValue {
}
public interface Microsoft.Cci.IPrimarySourceDocument {
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid ChecksumAlgorithm { get; }
    public Byte[] Checksum { get; }
    public IPrimarySourceLocation PrimarySourceLocation { get; }
    public abstract virtual Guid get_DocumentType();
    public abstract virtual Guid get_Language();
    public abstract virtual Guid get_LanguageVendor();
    public abstract virtual Guid get_ChecksumAlgorithm();
    public abstract virtual Byte[] get_Checksum();
    public abstract virtual IPrimarySourceLocation get_PrimarySourceLocation();
    public abstract virtual IPrimarySourceLocation GetPrimarySourceLocation(int position, int length);
    public abstract virtual void ToLineColumn(int position, Int32& line, Int32& column);
}
internal abstract class Microsoft.Cci.IPrimarySourceDocumentContract : object {
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid ChecksumAlgorithm { get; }
    public Byte[] Checksum { get; }
    public IPrimarySourceLocation PrimarySourceLocation { get; }
    public int Length { get; }
    public string SourceLanguage { get; }
    public ISourceLocation SourceLocation { get; }
    public string Location { get; }
    public IName Name { get; }
    public sealed virtual Guid get_DocumentType();
    public sealed virtual Guid get_Language();
    public sealed virtual Guid get_LanguageVendor();
    public sealed virtual Guid get_ChecksumAlgorithm();
    public sealed virtual Byte[] get_Checksum();
    public sealed virtual IPrimarySourceLocation get_PrimarySourceLocation();
    public sealed virtual IPrimarySourceLocation GetPrimarySourceLocation(int position, int length);
    public sealed virtual void ToLineColumn(int position, Int32& line, Int32& column);
    public sealed virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public sealed virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public sealed virtual ISourceLocation GetSourceLocation(int position, int length);
    public sealed virtual string GetText();
    public sealed virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public sealed virtual int get_Length();
    public sealed virtual string get_SourceLanguage();
    public sealed virtual ISourceLocation get_SourceLocation();
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.IPrimarySourceLocation {
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public abstract virtual int get_EndColumn();
    public abstract virtual int get_EndLine();
    public abstract virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public abstract virtual int get_StartColumn();
    public abstract virtual int get_StartLine();
}
internal abstract class Microsoft.Cci.IPrimarySourceLocationContract : object {
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public IDocument Document { get; }
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartLine();
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual ISourceDocument get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.IPropertyDefinition {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public IMethodReference Setter { get; }
    public abstract virtual IEnumerable`1<IMethodReference> get_Accessors();
    public abstract virtual IMetadataConstant get_DefaultValue();
    public abstract virtual IMethodReference get_Getter();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public abstract virtual IMethodReference get_Setter();
}
internal abstract class Microsoft.Cci.IPropertyDefinitionContract : object {
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public IMethodReference Setter { get; }
    public CallingConvention CallingConvention { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public IMetadataConstant Constant { get; }
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual IMethodReference get_Getter();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual IMethodReference get_Setter();
    public sealed virtual CallingConvention get_CallingConvention();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual IMetadataConstant get_Constant();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IPushStatement {
    public IExpression ValueToPush { get; }
    public abstract virtual IExpression get_ValueToPush();
}
internal abstract class Microsoft.Cci.IPushStatementContract : object {
    public IExpression ValueToPush { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_ValueToPush();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IRefArgument {
    public IAddressableExpression Expression { get; }
    public abstract virtual IAddressableExpression get_Expression();
}
internal abstract class Microsoft.Cci.IRefArgumentContract : object {
    public IAddressableExpression Expression { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IAddressableExpression get_Expression();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IReference {
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public abstract virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
}
internal abstract class Microsoft.Cci.IReferenceContract : object {
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IResource {
    public IEnumerable`1<byte> Data { get; }
    public bool IsInExternalFile { get; }
    public IFileReference ExternalFile { get; }
    public abstract virtual IEnumerable`1<byte> get_Data();
    public abstract virtual bool get_IsInExternalFile();
    public abstract virtual IFileReference get_ExternalFile();
}
public interface Microsoft.Cci.IResourceReference {
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IAssemblyReference DefiningAssembly { get; }
    public bool IsPublic { get; }
    public IName Name { get; }
    public IResource Resource { get; }
    public abstract virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public abstract virtual IAssemblyReference get_DefiningAssembly();
    public abstract virtual bool get_IsPublic();
    public abstract virtual IName get_Name();
    public abstract virtual IResource get_Resource();
}
internal abstract class Microsoft.Cci.IResourceReferenceContract : object {
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IAssemblyReference DefiningAssembly { get; }
    public bool IsPublic { get; }
    public IName Name { get; }
    public IResource Resource { get; }
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IAssemblyReference get_DefiningAssembly();
    public sealed virtual bool get_IsPublic();
    public sealed virtual IName get_Name();
    public sealed virtual IResource get_Resource();
}
public interface Microsoft.Cci.IResourceUseStatement {
    public IStatement Body { get; }
    public IStatement ResourceAcquisitions { get; }
    public abstract virtual IStatement get_Body();
    public abstract virtual IStatement get_ResourceAcquisitions();
}
public interface Microsoft.Cci.IRethrowStatement {
}
public interface Microsoft.Cci.IReturnStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public interface Microsoft.Cci.IReturnValue {
}
public interface Microsoft.Cci.IRightShift {
}
public interface Microsoft.Cci.IRootUnitNamespace {
}
public interface Microsoft.Cci.IRootUnitNamespaceReference {
}
public interface Microsoft.Cci.IRootUnitSetNamespace {
}
public interface Microsoft.Cci.IRuntimeArgumentHandleExpression {
}
public interface Microsoft.Cci.IScope`1 {
    public IEnumerable`1<MemberType> Members { get; }
    public abstract virtual bool Contains(MemberType member);
    public abstract virtual IEnumerable`1<MemberType> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<MemberType, bool> predicate);
    public abstract virtual IEnumerable`1<MemberType> GetMatchingMembers(Function`2<MemberType, bool> predicate);
    public abstract virtual IEnumerable`1<MemberType> GetMembersNamed(IName name, bool ignoreCase);
    public abstract virtual IEnumerable`1<MemberType> get_Members();
}
internal abstract class Microsoft.Cci.ISCopeContract`1 : object {
    public IEnumerable`1<MemberType> Members { get; }
    public sealed virtual bool Contains(MemberType member);
    public sealed virtual IEnumerable`1<MemberType> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<MemberType, bool> predicate);
    public sealed virtual IEnumerable`1<MemberType> GetMatchingMembers(Function`2<MemberType, bool> predicate);
    public sealed virtual IEnumerable`1<MemberType> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IEnumerable`1<MemberType> get_Members();
}
public interface Microsoft.Cci.IScopeMember`1 {
    public ScopeType ContainingScope { get; }
    public abstract virtual ScopeType get_ContainingScope();
}
internal abstract class Microsoft.Cci.IScopeMemberContract`1 : object {
    public ScopeType ContainingScope { get; }
    public IName Name { get; }
    public sealed virtual ScopeType get_ContainingScope();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.ISectionBlock {
    public PESectionKind PESectionKind { get; }
    public UInt32 Offset { get; }
    public UInt32 Size { get; }
    public IEnumerable`1<byte> Data { get; }
    public abstract virtual PESectionKind get_PESectionKind();
    public abstract virtual UInt32 get_Offset();
    public abstract virtual UInt32 get_Size();
    public abstract virtual IEnumerable`1<byte> get_Data();
}
public interface Microsoft.Cci.ISecurityAttribute {
    public SecurityAction Action { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public abstract virtual SecurityAction get_Action();
    public abstract virtual IEnumerable`1<ICustomAttribute> get_Attributes();
}
public interface Microsoft.Cci.ISemanticErrorsReporter {
}
public interface Microsoft.Cci.ISignature {
    public CallingConvention CallingConvention { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public abstract virtual CallingConvention get_CallingConvention();
    public abstract virtual bool get_IsStatic();
    public abstract virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public abstract virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public abstract virtual bool get_ReturnValueIsByRef();
    public abstract virtual bool get_ReturnValueIsModified();
    public abstract virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.ISignatureContract : object {
    public CallingConvention CallingConvention { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
}
public interface Microsoft.Cci.ISizeOf {
    public ITypeReference TypeToSize { get; }
    public abstract virtual ITypeReference get_TypeToSize();
}
public interface Microsoft.Cci.ISourceDocument {
    public int Length { get; }
    public string SourceLanguage { get; }
    public ISourceLocation SourceLocation { get; }
    public abstract virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public abstract virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public abstract virtual ISourceLocation GetSourceLocation(int position, int length);
    public abstract virtual string GetText();
    public abstract virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public abstract virtual int get_Length();
    public abstract virtual string get_SourceLanguage();
    public abstract virtual ISourceLocation get_SourceLocation();
}
internal abstract class Microsoft.Cci.ISourceDocumentContract : object {
    public int Length { get; }
    public string SourceLanguage { get; }
    public ISourceLocation SourceLocation { get; }
    public string Location { get; }
    public IName Name { get; }
    public sealed virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public sealed virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public sealed virtual ISourceLocation GetSourceLocation(int position, int length);
    public sealed virtual string GetText();
    public sealed virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public sealed virtual int get_Length();
    public sealed virtual string get_SourceLanguage();
    public sealed virtual ISourceLocation get_SourceLocation();
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.ISourceDocumentEdit {
    public ISourceLocation SourceLocationBeforeEdit { get; }
    public ISourceDocument SourceDocumentAfterEdit { get; }
    public abstract virtual ISourceLocation get_SourceLocationBeforeEdit();
    public abstract virtual ISourceDocument get_SourceDocumentAfterEdit();
}
internal abstract class Microsoft.Cci.ISourceDocumentEditContract : object {
    public ISourceLocation SourceLocationBeforeEdit { get; }
    public ISourceDocument SourceDocumentAfterEdit { get; }
    public sealed virtual ISourceLocation get_SourceLocationBeforeEdit();
    public sealed virtual ISourceDocument get_SourceDocumentAfterEdit();
}
public interface Microsoft.Cci.ISourceEditHost {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Edits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Edits(EventHandler`1<EditEventArgs> value);
    public abstract virtual void RegisterAsLatest(ICompilation compilation);
    public abstract virtual void ReportEdits(EditEventArgs editEventArguments);
    public abstract virtual void ReportSymbolTableEdits(EditEventArgs editEventArguments);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SymbolTableEdits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SymbolTableEdits(EventHandler`1<EditEventArgs> value);
}
internal abstract class Microsoft.Cci.ISourceEditHostContract : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EditEventArgs> Edits;
    [CompilerGeneratedAttribute]
private EventHandler`1<EditEventArgs> SymbolTableEdits;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Errors;
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public AssemblyIdentity SystemCoreAssemblySymbolicIdentity { get; }
    public IInternFactory InternFactory { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<IUnit> LoadedUnits { get; }
    public INameTable NameTable { get; }
    public byte PointerSize { get; }
    public bool PreserveILLocations { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_Edits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Edits(EventHandler`1<EditEventArgs> value);
    public sealed virtual void RegisterAsLatest(ICompilation compilation);
    public sealed virtual void ReportEdits(EditEventArgs editEventArguments);
    public sealed virtual void ReportSymbolTableEdits(EditEventArgs editEventArguments);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SymbolTableEdits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SymbolTableEdits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Errors(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Errors(EventHandler`1<ErrorEventArgs> value);
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_SystemCoreAssemblySymbolicIdentity();
    public sealed virtual IAssembly FindAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule FindModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit FindUnit(UnitIdentity unitIdentity);
    public sealed virtual IInternFactory get_InternFactory();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IAssembly LoadAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule LoadModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit LoadUnit(UnitIdentity unitIdentity);
    public sealed virtual IUnit LoadUnitFrom(string location);
    public sealed virtual IEnumerable`1<IUnit> get_LoadedUnits();
    public sealed virtual INameTable get_NameTable();
    public sealed virtual byte get_PointerSize();
    public sealed virtual void ReportErrors(ErrorEventArgs errorEventArguments);
    public sealed virtual void ReportError(IErrorMessage error);
    public sealed virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public sealed virtual ModuleIdentity ProbeModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public sealed virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual AssemblyIdentity UnifyAssembly(IAssemblyReference assemblyReference);
    public sealed virtual bool get_PreserveILLocations();
}
public interface Microsoft.Cci.ISourceErrorMessage {
    public ISourceLocation SourceLocation { get; }
    public abstract virtual ISourceLocation get_SourceLocation();
    public abstract virtual ISourceErrorMessage MakeShallowCopy(ISourceDocument targetDocument);
}
internal abstract class Microsoft.Cci.ISourceErrorMessageContract : object {
    public ISourceLocation SourceLocation { get; }
    public object ErrorReporter { get; }
    public string ErrorReporterIdentifier { get; }
    public long Code { get; }
    public bool IsWarning { get; }
    public string Message { get; }
    public ILocation Location { get; }
    public IEnumerable`1<ILocation> RelatedLocations { get; }
    public sealed virtual ISourceLocation get_SourceLocation();
    public sealed virtual ISourceErrorMessage MakeShallowCopy(ISourceDocument targetDocument);
    public sealed virtual object get_ErrorReporter();
    public sealed virtual string get_ErrorReporterIdentifier();
    public sealed virtual long get_Code();
    public sealed virtual bool get_IsWarning();
    public sealed virtual string get_Message();
    public sealed virtual ILocation get_Location();
    public sealed virtual IEnumerable`1<ILocation> get_RelatedLocations();
}
public interface Microsoft.Cci.ISourceLocation {
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public abstract virtual bool Contains(ISourceLocation location);
    public abstract virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public abstract virtual int get_EndIndex();
    public abstract virtual int get_Length();
    public abstract virtual ISourceDocument get_SourceDocument();
    public abstract virtual string get_Source();
    public abstract virtual int get_StartIndex();
}
internal abstract class Microsoft.Cci.ISourceLocationContract : object {
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public IDocument Document { get; }
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual ISourceDocument get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    public sealed virtual IDocument get_Document();
}
public interface Microsoft.Cci.ISourceLocationProvider {
    public abstract virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IEnumerable`1<ILocation> locations);
    public abstract virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(ILocation location);
    public abstract virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsForDefinitionOf(ILocalDefinition localDefinition);
    public abstract virtual string GetSourceNameFor(ILocalDefinition localDefinition, Boolean& isCompilerGenerated);
}
internal abstract class Microsoft.Cci.ISourceLocationProviderContract : object {
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IEnumerable`1<ILocation> locations);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(ILocation location);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsForDefinitionOf(ILocalDefinition localDefinition);
    public sealed virtual string GetSourceNameFor(ILocalDefinition localDefinition, Boolean& isCompilerGenerated);
}
public interface Microsoft.Cci.ISourceMethodBody {
    public IBlockStatement Block { get; }
    public abstract virtual IBlockStatement get_Block();
}
public interface Microsoft.Cci.ISourceToILConverter {
    public ushort MaximumStackSizeNeeded { get; }
    public abstract virtual void ConvertToIL(IBlockStatement body);
    public abstract virtual IEnumerable`1<ILocalDefinition> GetLocalVariables();
    public abstract virtual IEnumerable`1<IOperation> GetOperations();
    public abstract virtual IEnumerable`1<IOperationExceptionInformation> GetOperationExceptionInformation();
    public abstract virtual IEnumerable`1<ITypeDefinition> GetPrivateHelperTypes();
    public abstract virtual ushort get_MaximumStackSizeNeeded();
}
public interface Microsoft.Cci.ISpecializedEventDefinition {
    public IEventDefinition UnspecializedVersion { get; }
    public abstract virtual IEventDefinition get_UnspecializedVersion();
}
public interface Microsoft.Cci.ISpecializedFieldDefinition {
    public IFieldDefinition UnspecializedVersion { get; }
    public abstract virtual IFieldDefinition get_UnspecializedVersion();
}
public interface Microsoft.Cci.ISpecializedFieldReference {
    public IFieldReference UnspecializedVersion { get; }
    public abstract virtual IFieldReference get_UnspecializedVersion();
}
internal abstract class Microsoft.Cci.ISpecializedFieldReferenceContract : object {
    public IFieldReference UnspecializedVersion { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public UInt32 InternedKey { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public ITypeReference Type { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IFieldReference get_UnspecializedVersion();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.ISpecializedMethodDefinition {
    public IMethodDefinition UnspecializedVersion { get; }
    public abstract virtual IMethodDefinition get_UnspecializedVersion();
}
internal abstract class Microsoft.Cci.ISpecializedMethodDefinitionContract : object {
    public IMethodDefinition UnspecializedVersion { get; }
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsCil { get; }
    public bool IsConstructor { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStaticConstructor { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public bool PreserveSignature { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public bool IsStatic { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    public sealed virtual IMethodDefinition get_UnspecializedVersion();
    public sealed virtual IMethodBody get_Body();
    public sealed virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual bool get_RequiresSecurityObject();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public sealed virtual IName get_ReturnValueName();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_IsStatic();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
}
public interface Microsoft.Cci.ISpecializedMethodReference {
    public IMethodReference UnspecializedVersion { get; }
    public abstract virtual IMethodReference get_UnspecializedVersion();
}
internal abstract class Microsoft.Cci.ISpecializedMethodReferenceContract : object {
    public IMethodReference UnspecializedVersion { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public bool IsStatic { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IMethodReference get_UnspecializedVersion();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.ISpecializedNestedTypeDefinition {
    public INestedTypeDefinition UnspecializedVersion { get; }
    public abstract virtual INestedTypeDefinition get_UnspecializedVersion();
}
internal abstract class Microsoft.Cci.ISpecializedNestedTypeDefinitionContract : object {
    public INestedTypeDefinition UnspecializedVersion { get; }
    public ushort GenericParameterCount { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public bool DoesNotInheritGenericParameters { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    private INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion { get; }
    public sealed virtual INestedTypeDefinition get_UnspecializedVersion();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual bool get_DoesNotInheritGenericParameters();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    private sealed virtual override INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.get_UnspecializedVersion();
}
public interface Microsoft.Cci.ISpecializedNestedTypeReference {
    public INestedTypeReference UnspecializedVersion { get; }
    public abstract virtual INestedTypeReference get_UnspecializedVersion();
}
internal abstract class Microsoft.Cci.ISpecializedNestedTypeReferenceContract : object {
    public INestedTypeReference UnspecializedVersion { get; }
    public ushort GenericParameterCount { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual INestedTypeReference get_UnspecializedVersion();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.ISpecializedPropertyDefinition {
    public IPropertyDefinition UnspecializedVersion { get; }
    public abstract virtual IPropertyDefinition get_UnspecializedVersion();
}
public interface Microsoft.Cci.IStackArrayCreate {
    public ITypeReference ElementType { get; }
    public IExpression Size { get; }
    public abstract virtual ITypeReference get_ElementType();
    public abstract virtual IExpression get_Size();
}
public interface Microsoft.Cci.IStatement {
    public abstract virtual void Dispatch(ICodeVisitor visitor);
}
internal abstract class Microsoft.Cci.IStatementContract : object {
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ISubtraction {
    public bool CheckOverflow { get; }
    public bool TreatOperandsAsUnsignedIntegers { get; }
    public abstract virtual bool get_CheckOverflow();
    public abstract virtual bool get_TreatOperandsAsUnsignedIntegers();
}
public interface Microsoft.Cci.ISwitchCase {
    public IEnumerable`1<IStatement> Body { get; }
    public ICompileTimeConstant Expression { get; }
    public bool IsDefault { get; }
    public abstract virtual IEnumerable`1<IStatement> get_Body();
    public abstract virtual ICompileTimeConstant get_Expression();
    public abstract virtual bool get_IsDefault();
}
public interface Microsoft.Cci.ISwitchStatement {
    public IEnumerable`1<ISwitchCase> Cases { get; }
    public IExpression Expression { get; }
    public abstract virtual IEnumerable`1<ISwitchCase> get_Cases();
    public abstract virtual IExpression get_Expression();
}
public interface Microsoft.Cci.ISymbolSyntaxErrorsReporter {
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
internal interface Microsoft.Cci.ISymUnmanagedDocumentWriter {
    public abstract virtual void SetSource(UInt32 sourceSize, Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, UInt32 checkSumSize, Byte[] checkSum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0B97726E-9E6D-4f05-9A26-424022093CAA")]
internal interface Microsoft.Cci.ISymUnmanagedWriter2 {
    public abstract virtual ISymUnmanagedDocumentWriter DefineDocument(string url, Guid& language, Guid& languageVendor, Guid& documentType);
    public abstract virtual void SetUserEntryPoint(UInt32 entryMethod);
    public abstract virtual void OpenMethod(UInt32 method);
    public abstract virtual void CloseMethod();
    public abstract virtual UInt32 OpenScope(UInt32 startOffset);
    public abstract virtual void CloseScope(UInt32 endOffset);
    public abstract virtual void SetScopeRange(UInt32 scopeID, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineLocalVariable(string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineParameter(string name, UInt32 attributes, UInt32 sequence, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineField(UInt32 parent, string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineGlobalVariable(string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, UInt32 cData, IntPtr signature);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange(ISymUnmanagedDocumentWriter startDoc, UInt32 startLine, UInt32 startColumn, object endDoc, UInt32 endLine, UInt32 endColumn);
    public abstract virtual void Initialize(object emitter, string filename, object pIStream, bool fFullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& pIDD, UInt32 cData, UInt32& pcData, IntPtr data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, UInt32 spCount, UInt32[] offsets, UInt32[] lines, UInt32[] columns, UInt32[] endLines, UInt32[] endColumns);
    public abstract virtual void RemapToken(UInt32 oldToken, UInt32 newToken);
    public abstract virtual void Initialize2(object emitter, string tempfilename, object pIStream, bool fFullBuild, string finalfilename);
    public abstract virtual void DefineConstant(string name, object value, UInt32 cSig, IntPtr signature);
    public abstract virtual void Abort();
    public abstract virtual void DefineLocalVariable2(string name, UInt32 attributes, UInt32 sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineGlobalVariable2(string name, UInt32 attributes, UInt32 sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineConstant2(string name, object value, UInt32 sigToken);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("DCF7780D-BDE9-45DF-ACFE-21731A32000C")]
internal interface Microsoft.Cci.ISymUnmanagedWriter5 {
    public abstract virtual ISymUnmanagedDocumentWriter DefineDocument(string url, Guid& language, Guid& languageVendor, Guid& documentType);
    public abstract virtual void SetUserEntryPoint(UInt32 entryMethod);
    public abstract virtual void OpenMethod(UInt32 method);
    public abstract virtual void CloseMethod();
    public abstract virtual UInt32 OpenScope(UInt32 startOffset);
    public abstract virtual void CloseScope(UInt32 endOffset);
    public abstract virtual void SetScopeRange(UInt32 scopeID, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineLocalVariable(string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineParameter(string name, UInt32 attributes, UInt32 sequence, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineField(UInt32 parent, string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineGlobalVariable(string name, UInt32 attributes, UInt32 cSig, IntPtr signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, UInt32 cData, IntPtr signature);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange(ISymUnmanagedDocumentWriter startDoc, UInt32 startLine, UInt32 startColumn, object endDoc, UInt32 endLine, UInt32 endColumn);
    public abstract virtual void Initialize(object emitter, string filename, object pIStream, bool fFullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& pIDD, UInt32 cData, UInt32& pcData, IntPtr data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, UInt32 spCount, UInt32[] offsets, UInt32[] lines, UInt32[] columns, UInt32[] endLines, UInt32[] endColumns);
    public abstract virtual void RemapToken(UInt32 oldToken, UInt32 newToken);
    public abstract virtual void Initialize2(object emitter, string tempfilename, object pIStream, bool fFullBuild, string finalfilename);
    public abstract virtual void DefineConstant(string name, object value, UInt32 cSig, IntPtr signature);
    public abstract virtual void Abort();
    public abstract virtual void DefineLocalVariable2(string name, UInt32 attributes, UInt32 sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineGlobalVariable2(string name, UInt32 attributes, UInt32 sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineConstant2(string name, object value, UInt32 sigToken);
    public abstract virtual void OpenMethod2(UInt32 method, UInt32 isect, UInt32 offset);
    public abstract virtual void Commit();
    public abstract virtual void GetDebugInfoWithPadding(ImageDebugDirectory& pIDD, UInt32 cData, UInt32& pcData, IntPtr data);
    public abstract virtual void OpenMapTokensToSourceSpans();
    public abstract virtual void CloseMapTokensToSourceSpans();
    public abstract virtual void MapTokenToSourceSpan(UInt32 token, ISymUnmanagedDocumentWriter document, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn);
}
public interface Microsoft.Cci.ISynchronizationInformation {
    public IMethodDefinition AsyncMethod { get; }
    public IMethodDefinition MoveNextMethod { get; }
    public UInt32 GeneratedCatchHandlerOffset { get; }
    public IEnumerable`1<ISynchronizationPoint> SynchronizationPoints { get; }
    public abstract virtual IMethodDefinition get_AsyncMethod();
    public abstract virtual IMethodDefinition get_MoveNextMethod();
    public abstract virtual UInt32 get_GeneratedCatchHandlerOffset();
    public abstract virtual IEnumerable`1<ISynchronizationPoint> get_SynchronizationPoints();
}
internal abstract class Microsoft.Cci.ISynchronizationInformationContract : object {
    public IMethodDefinition AsyncMethod { get; }
    public IMethodDefinition MoveNextMethod { get; }
    public UInt32 GeneratedCatchHandlerOffset { get; }
    public IEnumerable`1<ISynchronizationPoint> SynchronizationPoints { get; }
    public sealed virtual IMethodDefinition get_AsyncMethod();
    public sealed virtual IMethodDefinition get_MoveNextMethod();
    public sealed virtual UInt32 get_GeneratedCatchHandlerOffset();
    public sealed virtual IEnumerable`1<ISynchronizationPoint> get_SynchronizationPoints();
}
public interface Microsoft.Cci.ISynchronizationPoint {
    public UInt32 SynchronizeOffset { get; }
    public IMethodDefinition ContinuationMethod { get; }
    public UInt32 ContinuationOffset { get; }
    public abstract virtual UInt32 get_SynchronizeOffset();
    public abstract virtual IMethodDefinition get_ContinuationMethod();
    public abstract virtual UInt32 get_ContinuationOffset();
}
internal abstract class Microsoft.Cci.ISynchronizationPointContract : object {
    public UInt32 SynchronizeOffset { get; }
    public IMethodDefinition ContinuationMethod { get; }
    public UInt32 ContinuationOffset { get; }
    public sealed virtual UInt32 get_SynchronizeOffset();
    public sealed virtual IMethodDefinition get_ContinuationMethod();
    public sealed virtual UInt32 get_ContinuationOffset();
}
public interface Microsoft.Cci.ISyntaxErrorsReporter {
}
public interface Microsoft.Cci.ITargetExpression {
    public byte Alignment { get; }
    public object Definition { get; }
    public bool GetterIsVirtual { get; }
    public bool SetterIsVirtual { get; }
    public IExpression Instance { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public abstract virtual byte get_Alignment();
    public abstract virtual object get_Definition();
    public abstract virtual bool get_GetterIsVirtual();
    public abstract virtual bool get_SetterIsVirtual();
    public abstract virtual IExpression get_Instance();
    public abstract virtual bool get_IsUnaligned();
    public abstract virtual bool get_IsVolatile();
}
internal abstract class Microsoft.Cci.ITargetExpressionContract : object {
    public byte Alignment { get; }
    public object Definition { get; }
    public bool GetterIsVirtual { get; }
    public bool SetterIsVirtual { get; }
    public IExpression Instance { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual byte get_Alignment();
    public sealed virtual object get_Definition();
    public sealed virtual bool get_GetterIsVirtual();
    public sealed virtual bool get_SetterIsVirtual();
    public sealed virtual IExpression get_Instance();
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ITargetSliceExpression {
    public IExpression StartOfSlice { get; }
    public IExpression LengthOfSlice { get; }
    public abstract virtual IExpression get_StartOfSlice();
    public abstract virtual IExpression get_LengthOfSlice();
}
[ExtensionAttribute]
public static class Microsoft.Cci.IteratorHelper : object {
    public static bool EnumerablesAreEqual(IEnumerable`1<T> left, IEnumerable`1<T> right);
    internal static bool ArraysAreEqual(T[] array1, T[] array2);
    public static bool IEquatableEnumerablesAreEqual(IEnumerable`1<T> left, IEnumerable`1<T> right);
    public static bool EnumerablesAreEqual(IEnumerable`1<T> left, IEnumerable`1<T> right, IEqualityComparer`1<T> comparer);
    public static T[] GetAsArray(IEnumerable`1<T> enumerable);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<GetEmptyEnumerable>d__5`1")]
[ObsoleteAttribute("Please use Enumerable<T>.Empty instead")]
public static IEnumerable`1<T> GetEmptyEnumerable();
    public static IEnumerable`1<T> GetReadonly(T[] array);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<GetSingletonEnumerable>d__8`1")]
public static IEnumerable`1<T> GetSingletonEnumerable(T t);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<GetConversionEnumerable>d__9`2")]
public static IEnumerable`1<TargetType> GetConversionEnumerable(IEnumerable`1<SourceType> sourceEnumeration);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<GetConversionEnumerable>d__10`2")]
public static IEnumerable`1<TargetType> GetConversionEnumerable(IEnumerable`1<SourceType> sourceEnumeration, Func`2<SourceType, TargetType> convert);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<GetFilterEnumerable>d__11`2")]
public static IEnumerable`1<TargetType> GetFilterEnumerable(IEnumerable`1<SourceType> sourceEnumeration);
    public static bool EnumerableIsNotEmpty(IEnumerable`1<T> enumerable);
    internal static List`1<T> CopyToList(IEnumerable`1<T> en);
    internal static List`1<T> CopyToList(IReadOnlyList`1<T> list);
    internal static List`1<T> CopyToList(IEnumerable`1<T> en, int count, bool checkList);
    public static bool EnumerableIsEmpty(IEnumerable`1<T> enumerable);
    public static bool EnumerableContains(IEnumerable`1<T> enumerable, T element);
    public static UInt32 EnumerableCount(IEnumerable`1<T> enumerable);
    public static bool EnumerableHasLength(IEnumerable`1<T> enumerable, ulong length);
    public static T Single(IEnumerable`1<T> enumerable);
    public static T First(IEnumerable`1<T> enumerable);
    public static bool Any(IEnumerable`1<T> enumerable, Predicate`1<T> pred);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<Concat>d__23`1")]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> left, IEnumerable`1<T> right);
    [IteratorStateMachineAttribute("Microsoft.Cci.IteratorHelper/<Zip>d__24`3")]
public static IEnumerable`1<TResult> Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Function`3<TFirst, TSecond, TResult> resultSelector);
    public static void Zip(IEnumerable`1<TFirst> first, IEnumerable`1<TSecond> second, Action`2<TFirst, TSecond> action);
    [ExtensionAttribute]
internal static IEnumerable`1<T> ToReadOnly(List`1<T> list);
}
public interface Microsoft.Cci.IThisReference {
}
public interface Microsoft.Cci.IThrowStatement {
    public IExpression Exception { get; }
    public abstract virtual IExpression get_Exception();
}
public interface Microsoft.Cci.ITokenDecoder {
    public abstract virtual object GetObjectForToken(UInt32 token);
}
public interface Microsoft.Cci.ITokenOf {
    public object Definition { get; }
    public abstract virtual object get_Definition();
}
public interface Microsoft.Cci.ITokenProvider {
    public abstract virtual UInt32 GetTokenFor(IFieldReference field);
    public abstract virtual UInt32 GetTokenFor(IMethodReference method);
    public abstract virtual UInt32 GetTokenFor(ITypeReference typeReference);
    public abstract virtual UInt32 GetTokenFor(string str);
}
public interface Microsoft.Cci.ITryCatchFinallyStatement {
    public IEnumerable`1<ICatchClause> CatchClauses { get; }
    public IBlockStatement FinallyBody { get; }
    public IBlockStatement FaultBody { get; }
    public IBlockStatement TryBody { get; }
    public abstract virtual IEnumerable`1<ICatchClause> get_CatchClauses();
    public abstract virtual IBlockStatement get_FinallyBody();
    public abstract virtual IBlockStatement get_FaultBody();
    public abstract virtual IBlockStatement get_TryBody();
}
internal abstract class Microsoft.Cci.ITryCatchFinallyStatementContract : object {
    public IEnumerable`1<ICatchClause> CatchClauses { get; }
    public IBlockStatement FinallyBody { get; }
    public IBlockStatement FaultBody { get; }
    public IBlockStatement TryBody { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IEnumerable`1<ICatchClause> get_CatchClauses();
    public sealed virtual IBlockStatement get_FinallyBody();
    public sealed virtual IBlockStatement get_FaultBody();
    public sealed virtual IBlockStatement get_TryBody();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.ITypeDefinition {
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public abstract virtual ushort get_Alignment();
    public abstract virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public abstract virtual IEnumerable`1<IEventDefinition> get_Events();
    public abstract virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public abstract virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public abstract virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public abstract virtual IGenericTypeInstanceReference get_InstanceType();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsBeforeFieldInit();
    public abstract virtual bool get_IsClass();
    public abstract virtual bool get_IsComObject();
    public abstract virtual bool get_IsDelegate();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsReferenceType();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStruct();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsStatic();
    public abstract virtual LayoutKind get_Layout();
    public abstract virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public abstract virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public abstract virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public abstract virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public abstract virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public abstract virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public abstract virtual UInt32 get_SizeOf();
    public abstract virtual StringFormatKind get_StringFormat();
    public abstract virtual ITypeReference get_UnderlyingType();
}
internal abstract class Microsoft.Cci.ITypeDefinitionContract : object {
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.ITypeDefinitionMember {
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public abstract virtual ITypeDefinition get_ContainingTypeDefinition();
    public abstract virtual TypeMemberVisibility get_Visibility();
}
internal abstract class Microsoft.Cci.ITypeDefinitionMemberContract : object {
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ITypeDefinition Container { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeDefinition get_Container();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.ITypeMemberReference {
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public abstract virtual ITypeReference get_ContainingType();
    public abstract virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
internal abstract class Microsoft.Cci.ITypeMemberReferenceContract : object {
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.ITypeOf {
    public ITypeReference TypeToGet { get; }
    public abstract virtual ITypeReference get_TypeToGet();
}
public interface Microsoft.Cci.ITypeReference {
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public abstract virtual IAliasForType get_AliasForType();
    public abstract virtual UInt32 get_InternedKey();
    public abstract virtual bool get_IsAlias();
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsValueType();
    public abstract virtual IPlatformType get_PlatformType();
    public abstract virtual ITypeDefinition get_ResolvedType();
    public abstract virtual PrimitiveTypeCode get_TypeCode();
}
internal abstract class Microsoft.Cci.ITypeReferenceContract : object {
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IUnaryNegation {
    public bool CheckOverflow { get; }
    public abstract virtual bool get_CheckOverflow();
}
public interface Microsoft.Cci.IUnaryOperation {
    public IExpression Operand { get; }
    public abstract virtual IExpression get_Operand();
}
internal abstract class Microsoft.Cci.IUnaryOperationContract : object {
    public IExpression Operand { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Operand();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IUnaryPlus {
}
public interface Microsoft.Cci.IUnit {
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public IPlatformType PlatformType { get; }
    public string Location { get; }
    public IEnumerable`1<IPESection> UninterpretedSections { get; }
    public IRootUnitNamespace UnitNamespaceRoot { get; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public abstract virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public abstract virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public abstract virtual IPlatformType get_PlatformType();
    public abstract virtual string get_Location();
    public abstract virtual IEnumerable`1<IPESection> get_UninterpretedSections();
    public abstract virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public abstract virtual IEnumerable`1<IUnitReference> get_UnitReferences();
}
internal abstract class Microsoft.Cci.IUnitContract : object {
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public IPlatformType PlatformType { get; }
    public string Location { get; }
    public IEnumerable`1<IPESection> UninterpretedSections { get; }
    public IRootUnitNamespace UnitNamespaceRoot { get; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual string get_Location();
    public sealed virtual IEnumerable`1<IPESection> get_UninterpretedSections();
    public sealed virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public sealed virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IUnitNamespace {
    public IUnit Unit { get; }
    public abstract virtual IUnit get_Unit();
}
internal abstract class Microsoft.Cci.IUnitNamespaceContract : object {
    public IUnit Unit { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public sealed virtual IUnit get_Unit();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IUnitNamespaceReference {
    public IUnitReference Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public abstract virtual IUnitReference get_Unit();
    public abstract virtual IUnitNamespace get_ResolvedUnitNamespace();
}
internal abstract class Microsoft.Cci.IUnitNamespaceReferenceContract : object {
    public IUnitReference Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IUnitReference get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IUnitReference {
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public abstract virtual IUnit get_ResolvedUnit();
    public abstract virtual UnitIdentity get_UnitIdentity();
}
internal abstract class Microsoft.Cci.IUnitReferenceContract : object {
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IUnit get_ResolvedUnit();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
}
public interface Microsoft.Cci.IUnitSet {
    public IEnumerable`1<IUnit> Units { get; }
    public IUnitSetNamespace UnitSetNamespaceRoot { get; }
    public abstract virtual bool Contains(IUnit unit);
    public abstract virtual IEnumerable`1<IUnit> get_Units();
    public abstract virtual IUnitSetNamespace get_UnitSetNamespaceRoot();
}
public interface Microsoft.Cci.IUnitSetNamespace {
    public IUnitSet UnitSet { get; }
    public abstract virtual IUnitSet get_UnitSet();
}
internal abstract class Microsoft.Cci.IUnitSetNamespaceContract : object {
    public IUnitSet UnitSet { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IEnumerable`1<INamespaceMember> Members { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public sealed virtual IUnitSet get_UnitSet();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IEnumerable`1<INamespaceMember> get_Members();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual bool Contains(INamespaceMember member);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
}
public interface Microsoft.Cci.IUnmanagedPdbWriter {
    public abstract virtual void SetMetadataEmitter(object metadataEmitter);
}
public interface Microsoft.Cci.IUsedNamespace {
    public IName Alias { get; }
    public IName NamespaceName { get; }
    public abstract virtual IName get_Alias();
    public abstract virtual IName get_NamespaceName();
}
internal abstract class Microsoft.Cci.IUsedNamespaceContract : object {
    public IName Alias { get; }
    public IName NamespaceName { get; }
    public sealed virtual IName get_Alias();
    public sealed virtual IName get_NamespaceName();
}
public interface Microsoft.Cci.IVectorLength {
    public IExpression Vector { get; }
    public abstract virtual IExpression get_Vector();
}
internal abstract class Microsoft.Cci.IVectorLengthContract : object {
    public IExpression Vector { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IExpression get_Vector();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IWhileDoStatement {
    public IStatement Body { get; }
    public IExpression Condition { get; }
    public abstract virtual IStatement get_Body();
    public abstract virtual IExpression get_Condition();
}
internal abstract class Microsoft.Cci.IWhileDoStatementContract : object {
    public IStatement Body { get; }
    public IExpression Condition { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public sealed virtual IStatement get_Body();
    public sealed virtual IExpression get_Condition();
    public sealed virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
public interface Microsoft.Cci.IWin32Resource {
    public string TypeName { get; }
    public int TypeId { get; }
    public string Name { get; }
    public int Id { get; }
    public UInt32 LanguageId { get; }
    public UInt32 CodePage { get; }
    public IEnumerable`1<byte> Data { get; }
    public abstract virtual string get_TypeName();
    public abstract virtual int get_TypeId();
    public abstract virtual string get_Name();
    public abstract virtual int get_Id();
    public abstract virtual UInt32 get_LanguageId();
    public abstract virtual UInt32 get_CodePage();
    public abstract virtual IEnumerable`1<byte> get_Data();
}
public interface Microsoft.Cci.IYieldBreakStatement {
}
public interface Microsoft.Cci.IYieldReturnStatement {
    public IExpression Expression { get; }
    public abstract virtual IExpression get_Expression();
}
public enum Microsoft.Cci.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Auto;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
}
public enum Microsoft.Cci.Machine : Enum {
    public ushort value__;
    public static Machine Unknown;
    public static Machine I386;
    public static Machine R3000;
    public static Machine R4000;
    public static Machine R10000;
    public static Machine WCEMIPSV2;
    public static Machine Alpha;
    public static Machine SH3;
    public static Machine SH3DSP;
    public static Machine SH3E;
    public static Machine SH4;
    public static Machine SH5;
    public static Machine ARM;
    public static Machine Thumb;
    public static Machine AM33;
    public static Machine PowerPC;
    public static Machine PowerPCFP;
    public static Machine IA64;
    public static Machine MIPS16;
    public static Machine Alpha64;
    public static Machine MIPSFPU;
    public static Machine MIPSFPU16;
    public static Machine AXP64;
    public static Machine Tricore;
    public static Machine CEF;
    public static Machine EBC;
    public static Machine AMD64;
    public static Machine M32R;
    public static Machine CEE;
}
public static class Microsoft.Cci.MemberHelper : object {
    public static GenericMethodParameterInformationComparer GenericMethodParameterEqualityComparer;
    public static GenericMethodParameterInformationComparer ResolvingGenericMethodParameterEqualityComparer;
    public static ParameterInformationComparer ParameterInformationComparer;
    public static ParameterInformationComparer ResolvingParameterInformationComparer;
    private static MemberHelper();
    public static UInt32 ComputeFieldOffset(ITypeDefinitionMember item, ITypeDefinition containingTypeDefinition);
    [IteratorStateMachineAttribute("Microsoft.Cci.MemberHelper/<GetExplicitlyOverriddenMethods>d__1")]
public static IEnumerable`1<IMethodReference> GetExplicitlyOverriddenMethods(IMethodDefinition overridingMethod);
    public static UInt32 GetFieldBitOffset(IFieldDefinition field);
    public static UInt32 GetFieldOffset(IFieldDefinition field);
    public static bool MethodsAreEquivalent(IMethodDefinition m1, IMethodDefinition m2);
    [IteratorStateMachineAttribute("Microsoft.Cci.MemberHelper/<GetImplicitlyImplementedInterfaceMethods>d__5")]
public static IEnumerable`1<IMethodDefinition> GetImplicitlyImplementedInterfaceMethods(IMethodDefinition implementingMethod);
    public static IMethodDefinition GetImplicitlyOverriddenBaseClassMethod(IMethodDefinition derivedClassMethod);
    private static IMethodDefinition GetImplicitlyOverriddenBaseClassMethod(IMethodDefinition derivedClassMethod, ITypeDefinition baseClass);
    public static IMethodDefinition GetImplicitlyOverridingDerivedClassMethod(IMethodDefinition baseClassMethod, ITypeDefinition derivedClass);
    public static string GetMemberSignature(ITypeMemberReference member, NameFormattingOptions formattingOptions);
    public static string GetMethodSignature(IMethodReference method, NameFormattingOptions formattingOptions);
    public static bool IsGetter(IMethodDefinition method);
    public static bool IsSetter(IMethodDefinition method);
    public static bool IsAdder(IMethodDefinition method);
    public static bool IsRemover(IMethodDefinition method);
    public static bool IsCaller(IMethodDefinition method);
    private static bool QualifiedMethodNameBeginsWith(string methodName, string prefix);
    public static bool IsVisibleOutsideAssembly(ITypeDefinitionMember typeDefinitionMember);
    private static bool IsExplicitImplementationVisible(IMethodReference methodReference, ITypeDefinition containingTypeDefinition);
    public static bool IsVolatile(IFieldDefinition field);
    public static IMethodDefinition ResolveMethod(IMethodReference methodReference);
    private static IMethodDefinition ResolveMethod(ITypeDefinition declaringType, IMethodReference methodReference);
    public static bool SignaturesAreEqual(ISignature signature1, ISignature signature2, bool resolveTypes);
    public static bool GenericMethodSignaturesAreEqual(ISignature method1, ISignature method2, bool resolveTypes);
    public static IFieldDefinition ResolveField(IFieldReference fieldReference, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace, ITypeDefinition type);
    private static IFieldDefinition ResolveField(IFieldReference fieldReference, ITypeDefinition type, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace);
    public static IMethodDefinition ResolveMethod(IMethodReference methodReference, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace, ITypeDefinition type);
    private static IMethodDefinition ResolveMethod(IMethodReference methodReference, ITypeDefinition type, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace);
    private static bool SignaturesAreEqual(ISignature signature1, ISignature signature2, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace, IMethodDefinition method);
    public static IEventDefinition Unspecialize(IEventDefinition potentiallySpecializedEventDefinition);
    public static IFieldReference Unspecialize(IFieldReference potentiallySpecializedFieldReference);
    public static IFieldDefinition Unspecialize(IFieldDefinition potentiallySpecializedFieldDefinition);
    public static IMethodReference UninstantiateAndUnspecialize(IMethodReference potentiallySpecializedMethodReference);
    public static IMethodDefinition UninstantiateAndUnspecialize(IMethodDefinition potentiallySpecializedMethod);
    public static IPropertyDefinition Unspecialize(IPropertyDefinition potentiallySpecializedPropertyDefinition);
}
public abstract class Microsoft.Cci.MetadataHostEnvironment : object {
    private List`1<string> libPaths;
    [CompilerGeneratedAttribute]
private bool <SearchInGAC>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ErrorEventArgs> Errors;
    private AssemblyIdentity contractAssemblySymbolicIdentity;
    private SetOfObjects coreIdentities;
    private AssemblyIdentity coreAssemblySymbolicIdentity;
    private AssemblyIdentity systemCoreAssemblySymbolicIdentity;
    private IInternFactory internFactory;
    private INameTable nameTable;
    protected IPlatformType platformType;
    private byte pointerSize;
    private Dictionary`2<UnitIdentity, IUnit> unitCache;
    protected List`1<string> LibPaths { get; }
    public bool SearchInGAC { get; protected set; }
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    protected SetOfObjects CoreIdentities { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    public AssemblyIdentity SystemCoreAssemblySymbolicIdentity { get; }
    public IInternFactory InternFactory { get; }
    public IEnumerable`1<IUnit> LoadedUnits { get; }
    public INameTable NameTable { get; }
    public IPlatformType PlatformType { get; }
    public byte PointerSize { get; }
    public bool PreserveILLocations { get; }
    protected MetadataHostEnvironment(INameTable nameTable, IInternFactory factory, byte pointerSize, IEnumerable`1<string> searchPaths, bool searchInGAC);
    private void ObjectInvariant();
    public virtual void AddLibPath(string path);
    protected List`1<string> get_LibPaths();
    [CompilerGeneratedAttribute]
public bool get_SearchInGAC();
    [CompilerGeneratedAttribute]
protected void set_SearchInGAC(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Errors(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Errors(EventHandler`1<ErrorEventArgs> value);
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    protected SetOfObjects get_CoreIdentities();
    protected virtual AssemblyIdentity GetContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    protected virtual AssemblyIdentity GetCoreAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_SystemCoreAssemblySymbolicIdentity();
    protected virtual AssemblyIdentity GetSystemCoreAssemblySymbolicIdentity();
    public sealed virtual IAssembly FindAssembly(AssemblyIdentity assemblyIdentity);
    public sealed virtual IModule FindModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit FindUnit(UnitIdentity unitIdentity);
    public sealed virtual IInternFactory get_InternFactory();
    public virtual IAssembly LoadAssembly(AssemblyIdentity assemblyIdentity);
    public virtual IModule LoadModule(ModuleIdentity moduleIdentity);
    public sealed virtual IUnit LoadUnit(UnitIdentity unitIdentity);
    public abstract virtual IUnit LoadUnitFrom(string location);
    public sealed virtual IEnumerable`1<IUnit> get_LoadedUnits();
    public sealed virtual INameTable get_NameTable();
    public sealed virtual IPlatformType get_PlatformType();
    protected virtual IPlatformType GetPlatformType();
    public sealed virtual byte get_PointerSize();
    protected virtual byte GetTargetPlatformPointerSize();
    protected virtual AssemblyIdentity Probe(string probeDir, AssemblyIdentity referencedAssembly);
    public virtual AssemblyIdentity ProbeAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public virtual ModuleIdentity ProbeModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public void RegisterAsLatest(IUnit unit);
    public bool RemoveUnit(UnitIdentity unitIdentity);
    public virtual void ReportErrors(ErrorEventArgs errorEventArguments);
    protected void SynchronousReportErrors(object state);
    public sealed virtual void ReportError(IErrorMessage error);
    public virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    public virtual AssemblyIdentity UnifyAssembly(IAssemblyReference assemblyReference);
    public virtual bool get_PreserveILLocations();
}
internal abstract class Microsoft.Cci.MetadataReader.AttributeDecoder : object {
    internal bool decodeFailed;
    internal bool morePermutationsArePossible;
    protected PEFileToObjectModel PEFileToObjectModel;
    protected MemoryReader SignatureMemoryReader;
    protected AttributeDecoder(PEFileToObjectModel peFileToObjectModel, MemoryReader signatureMemoryReader);
    protected object GetPrimitiveValue(ITypeReference type);
    protected string GetSerializedString();
    protected ITypeReference GetFieldOrPropType();
    protected TypeName ConvertToTypeName(string serializedTypeName);
    protected ExpressionBase ReadSerializedValue(ITypeReference type);
}
internal class Microsoft.Cci.MetadataReader.CoreTypes : object {
    internal IMetadataReaderNamedTypeReference SystemEnum;
    internal IMetadataReaderNamedTypeReference SystemValueType;
    internal IMetadataReaderNamedTypeReference SystemMulticastDelegate;
    internal IMetadataReaderNamedTypeReference SystemType;
    internal IMetadataReaderNamedTypeReference SystemParamArrayAttribute;
    internal CoreTypes(PEFileToObjectModel peFileToObjectModel);
}
internal class Microsoft.Cci.MetadataReader.CustomAttributeDecoder : AttributeDecoder {
    internal ICustomAttribute CustomAttribute;
    internal CustomAttributeDecoder(PEFileToObjectModel peFileToObjectModel, MemoryReader signatureMemoryReader, UInt32 customAttributeRowId, IMethodReference attributeConstructor);
}
public class Microsoft.Cci.MetadataReader.DefaultWindowsRuntimeHost : WindowsRuntimeMetadataReaderHost {
    private PeReader peReader;
    public DefaultWindowsRuntimeHost(bool projectToCLRTypes);
    public DefaultWindowsRuntimeHost(INameTable nameTable, bool projectToCLRTypes);
    public virtual IUnit LoadUnitFrom(string location);
}
internal class Microsoft.Cci.MetadataReader.Errors.DirectoryLocation : object {
    internal IBinaryDocument binaryDocument;
    internal Directories directory;
    internal UInt32 offset;
    public IBinaryDocument BinaryDocument { get; }
    public string DirectoryName { get; }
    public UInt32 Offset { get; }
    public IDocument Document { get; }
    internal DirectoryLocation(IBinaryDocument binaryDocument, Directories directory, UInt32 offset);
    public sealed virtual IBinaryDocument get_BinaryDocument();
    public sealed virtual string get_DirectoryName();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual IDocument get_Document();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface Microsoft.Cci.MetadataReader.Errors.IDirectoryLocation {
    public IBinaryDocument BinaryDocument { get; }
    public string DirectoryName { get; }
    public UInt32 Offset { get; }
    public abstract virtual IBinaryDocument get_BinaryDocument();
    public abstract virtual string get_DirectoryName();
    public abstract virtual UInt32 get_Offset();
}
public interface Microsoft.Cci.MetadataReader.Errors.IMetadataLocation {
    public IBinaryDocument BinaryDocument { get; }
    public string TableName { get; }
    public int RowId { get; }
    public abstract virtual IBinaryDocument get_BinaryDocument();
    public abstract virtual string get_TableName();
    public abstract virtual int get_RowId();
}
public interface Microsoft.Cci.MetadataReader.Errors.IMetadataStreamLocation {
    public IBinaryDocument BinaryDocument { get; }
    public string StreamName { get; }
    public UInt32 Offset { get; }
    public abstract virtual IBinaryDocument get_BinaryDocument();
    public abstract virtual string get_StreamName();
    public abstract virtual UInt32 get_Offset();
}
internal class Microsoft.Cci.MetadataReader.Errors.MetadataErrorContainer : object {
    private PeReader MetadataReader;
    private IBinaryDocument BinaryDocument;
    private MultiHashtable`1<MetadataReaderErrorMessage> ErrorList;
    internal MetadataErrorContainer(PeReader metadataReader, IBinaryDocument binaryDocument);
    private void AddMetadataReaderErrorMessage(MetadataReaderErrorMessage errMessage);
    internal void AddBinaryError(UInt32 offset, MetadataReaderErrorKind errorKind);
    internal void AddDirectoryError(Directories directory, UInt32 offset, MetadataReaderErrorKind errorKind);
    internal void AddMetadataStreamError(string streamName, UInt32 offset, MetadataReaderErrorKind errorKind);
    internal void AddMetadataError(TableIndices tableIndex, UInt32 rowId, MetadataReaderErrorKind errorKind);
    internal void AddILError(IMethodDefinition methodDefinition, UInt32 offset, MetadataReaderErrorKind errorKind);
}
internal class Microsoft.Cci.MetadataReader.Errors.MetadataLocation : object {
    internal IBinaryDocument binaryDocument;
    internal TableIndices tableIndex;
    internal UInt32 rowId;
    public IBinaryDocument BinaryDocument { get; }
    public string TableName { get; }
    public int RowId { get; }
    public IDocument Document { get; }
    internal MetadataLocation(IBinaryDocument binaryDocument, TableIndices tableIndex, UInt32 rowId);
    public sealed virtual IBinaryDocument get_BinaryDocument();
    public sealed virtual string get_TableName();
    public sealed virtual int get_RowId();
    public sealed virtual IDocument get_Document();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum Microsoft.Cci.MetadataReader.Errors.MetadataReaderErrorKind : Enum {
    public int value__;
    public static MetadataReaderErrorKind FileSizeTooSmall;
    public static MetadataReaderErrorKind DosHeader;
    public static MetadataReaderErrorKind PESignature;
    public static MetadataReaderErrorKind COFFHeaderTooSmall;
    public static MetadataReaderErrorKind UnknownPEMagic;
    public static MetadataReaderErrorKind OptionalHeaderStandardFields32TooSmall;
    public static MetadataReaderErrorKind OptionalHeaderStandardFields64TooSmall;
    public static MetadataReaderErrorKind OptionalHeaderNTAdditionalFields32TooSmall;
    public static MetadataReaderErrorKind OptionalHeaderNTAdditionalFields64TooSmall;
    public static MetadataReaderErrorKind OptionalHeaderDirectoryEntriesTooSmall;
    public static MetadataReaderErrorKind SectionHeadersTooSmall;
    public static MetadataReaderErrorKind NotEnoughSpaceForCOR20HeaderTableDirectory;
    public static MetadataReaderErrorKind COR20HeaderTooSmall;
    public static MetadataReaderErrorKind NotEnoughSpaceForMetadataDirectory;
    public static MetadataReaderErrorKind MetadataHeaderTooSmall;
    public static MetadataReaderErrorKind MetadataSignature;
    public static MetadataReaderErrorKind NotEnoughSpaceForVersionString;
    public static MetadataReaderErrorKind StorageHeaderTooSmall;
    public static MetadataReaderErrorKind StreamHeaderTooSmall;
    public static MetadataReaderErrorKind NotEnoughSpaceForStreamHeaderName;
    public static MetadataReaderErrorKind NotEnoughSpaceForStringStream;
    public static MetadataReaderErrorKind NotEnoughSpaceForBlobStream;
    public static MetadataReaderErrorKind NotEnoughSpaceForGUIDStream;
    public static MetadataReaderErrorKind NotEnoughSpaceForUserStringStream;
    public static MetadataReaderErrorKind NotEnoughSpaceForMetadataStream;
    public static MetadataReaderErrorKind UnknownMetadataStream;
    public static MetadataReaderErrorKind MetadataTableHeaderTooSmall;
    public static MetadataReaderErrorKind UnknownVersionOfMetadata;
    public static MetadataReaderErrorKind UnknownTables;
    public static MetadataReaderErrorKind SomeRequiredTablesNotSorted;
    public static MetadataReaderErrorKind IllegalTablesInCompressedMetadataStream;
    public static MetadataReaderErrorKind TableRowCountSpaceTooSmall;
    public static MetadataReaderErrorKind MetadataTablesTooSmall;
    public static MetadataReaderErrorKind NestedClassParentError;
    public static MetadataReaderErrorKind UnknownILInstruction;
}
internal class Microsoft.Cci.MetadataReader.Errors.MetadataReaderErrorMessage : object {
    private object errorReporter;
    internal ILocation location;
    internal MetadataReaderErrorKind mrwErrorKind;
    public object ErrorReporter { get; }
    public string ErrorReporterIdentifier { get; }
    public long Code { get; }
    public bool IsWarning { get; }
    public string Message { get; }
    public ILocation Location { get; }
    public IEnumerable`1<ILocation> RelatedLocations { get; }
    internal MetadataReaderErrorMessage(object errorReporter, ILocation location, MetadataReaderErrorKind mrwErrorKind);
    public sealed virtual object get_ErrorReporter();
    public sealed virtual string get_ErrorReporterIdentifier();
    public sealed virtual long get_Code();
    public sealed virtual bool get_IsWarning();
    public sealed virtual string get_Message();
    public sealed virtual ILocation get_Location();
    public sealed virtual IEnumerable`1<ILocation> get_RelatedLocations();
}
internal class Microsoft.Cci.MetadataReader.Errors.MetadataStreamLocation : object {
    internal IBinaryDocument binaryDocument;
    internal string streamName;
    internal UInt32 offset;
    public IBinaryDocument BinaryDocument { get; }
    public string StreamName { get; }
    public UInt32 Offset { get; }
    public IDocument Document { get; }
    internal MetadataStreamLocation(IBinaryDocument binaryDocument, string streamName, UInt32 offset);
    public sealed virtual IBinaryDocument get_BinaryDocument();
    public sealed virtual string get_StreamName();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual IDocument get_Document();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.Cci.MetadataReader.Extensions.ModuleExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITypeMemberReference> GetConstructedTypeInstanceMembers(IModule module);
}
internal class Microsoft.Cci.MetadataReader.FieldSignatureConverter : SignatureConverter {
    internal byte FirstByte;
    internal ITypeReference TypeReference;
    internal IEnumerable`1<ICustomModifier> customModifiers;
    internal FieldSignatureConverter(PEFileToObjectModel peFileToObjectModel, MetadataObject moduleField, MemoryReader signatureMemoryReader);
}
internal enum Microsoft.Cci.MetadataReader.LoadState : Enum {
    public byte value__;
    public static LoadState Uninitialized;
    public static LoadState Loading;
    public static LoadState Loaded;
}
internal class Microsoft.Cci.MetadataReader.MethodBody.CilExceptionInformation : object {
    internal HandlerKind HandlerKind;
    internal ITypeReference ExceptionType;
    internal UInt32 TryStartOffset;
    internal UInt32 TryEndOffset;
    internal UInt32 FilterDecisionStartOffset;
    internal UInt32 HandlerStartOffset;
    internal UInt32 HandlerEndOffset;
    private HandlerKind Microsoft.Cci.IOperationExceptionInformation.HandlerKind { get; }
    private ITypeReference Microsoft.Cci.IOperationExceptionInformation.ExceptionType { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.TryStartOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.TryEndOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.FilterDecisionStartOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.HandlerStartOffset { get; }
    private UInt32 Microsoft.Cci.IOperationExceptionInformation.HandlerEndOffset { get; }
    internal CilExceptionInformation(HandlerKind handlerKind, ITypeReference exceptionType, UInt32 tryStartOffset, UInt32 tryEndOffset, UInt32 filterDecisionStartOffset, UInt32 handlerStartOffset, UInt32 handlerEndOffset);
    private sealed virtual override HandlerKind Microsoft.Cci.IOperationExceptionInformation.get_HandlerKind();
    private sealed virtual override ITypeReference Microsoft.Cci.IOperationExceptionInformation.get_ExceptionType();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_TryStartOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_TryEndOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_FilterDecisionStartOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_HandlerStartOffset();
    private sealed virtual override UInt32 Microsoft.Cci.IOperationExceptionInformation.get_HandlerEndOffset();
}
internal class Microsoft.Cci.MetadataReader.MethodBody.CilInstruction : object {
    internal OperationCode CilOpCode;
    private MethodBodyDocument document;
    private UInt32 offset;
    internal object Value;
    public OperationCode OperationCode { get; }
    private UInt32 Microsoft.Cci.IOperation.Offset { get; }
    private ILocation Microsoft.Cci.IOperation.Location { get; }
    private object Microsoft.Cci.IOperation.Value { get; }
    public IMethodDefinition MethodDefinition { get; }
    private UInt32 Microsoft.Cci.IILLocation.Offset { get; }
    public IDocument Document { get; }
    internal CilInstruction(OperationCode cilOpCode, MethodBodyDocument document, UInt32 offset, object value);
    public sealed virtual OperationCode get_OperationCode();
    private sealed virtual override UInt32 Microsoft.Cci.IOperation.get_Offset();
    private sealed virtual override ILocation Microsoft.Cci.IOperation.get_Location();
    private sealed virtual override object Microsoft.Cci.IOperation.get_Value();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    private sealed virtual override UInt32 Microsoft.Cci.IILLocation.get_Offset();
    public sealed virtual IDocument get_Document();
}
internal class Microsoft.Cci.MetadataReader.MethodBody.ILOperationList : VirtualReadOnlyList`1<IOperation> {
    private ILReader m_reader;
    private UInt32[] m_offsets;
    internal ILOperationList(ILReader reader, int count);
    private void LoadOffsets();
    internal void FreeOffsets();
    public virtual IOperation GetItem(int index);
    internal Operation GetOperation(int index);
    internal IEnumerable`1<IOperation> GetAllOperations();
    internal static ILOperationList RetrieveFrom(IMethodBody body);
}
internal class Microsoft.Cci.MetadataReader.MethodBody.ILReader : object {
    internal static EnumerableArrayWrapper`2<LocalVariableDefinition, ILocalDefinition> EmptyLocalVariables;
    private static HandlerKind[] HandlerKindMap;
    internal PEFileToObjectModel PEFileToObjectModel;
    internal MethodDefinition MethodDefinition;
    internal MethodBody MethodBody;
    internal MethodIL MethodIL;
    internal UInt32 EndOfMethodOffset;
    private static object c_I4_M1;
    private static object c_I4_0;
    private static object c_I4_1;
    private static object c_I4_2;
    private static object c_I4_3;
    private static object c_I4_4;
    private static object c_I4_5;
    private static object c_I4_6;
    private static object c_I4_7;
    private static object c_I4_8;
    private MethodBodyDocument m_document;
    internal ILReader(MethodDefinition methodDefinition, MethodIL methodIL);
    private static ILReader();
    private bool LoadLocalSignature();
    private string GetUserStringForToken(UInt32 token);
    private FunctionPointerType GetStandAloneMethodSignature(UInt32 standAloneMethodToken);
    private IParameterDefinition GetParameter(UInt32 rawParamNum);
    private ILocalDefinition GetLocal(UInt32 rawLocNum);
    private IMethodReference GetMethod(UInt32 methodToken);
    private IFieldReference GetField(UInt32 fieldToken);
    private ITypeReference GetType(UInt32 typeToken);
    private IFunctionPointerTypeReference GetFunctionPointerType(UInt32 standAloneSigToken);
    private object GetRuntimeHandleFromToken(UInt32 token);
    private bool PopulateCilInstructions();
    internal IOperation GetIOperation(UInt32 offset);
    internal Operation GetOperation(UInt32 offset);
    private object ReadInstruction(UInt32 offset, OperationCode& cilOpCode);
    internal static int CountCilInstructions(MemoryReader memReader, UInt32[] offsets);
    private bool PopulateExceptionInformation();
    internal bool ReadIL();
}
internal class Microsoft.Cci.MetadataReader.MethodBody.LocalVariableDefinition : object {
    private MethodBody methodBody;
    private IEnumerable`1<ICustomModifier> customModifiers;
    private bool isPinned;
    private bool isReference;
    private UInt32 index;
    private ITypeReference typeReference;
    private IName name;
    private IMetadataConstant Microsoft.Cci.ILocalDefinition.CompileTimeValue { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ILocalDefinition.CustomModifiers { get; }
    private bool Microsoft.Cci.ILocalDefinition.IsConstant { get; }
    private bool Microsoft.Cci.ILocalDefinition.IsModified { get; }
    private bool Microsoft.Cci.ILocalDefinition.IsPinned { get; }
    private bool Microsoft.Cci.ILocalDefinition.IsReference { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    internal LocalVariableDefinition(MethodBody methodBody, IEnumerable`1<ICustomModifier> customModifiers, bool isPinned, bool isReference, UInt32 index, ITypeReference typeReference);
    public virtual string ToString();
    private sealed virtual override IMetadataConstant Microsoft.Cci.ILocalDefinition.get_CompileTimeValue();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ILocalDefinition.get_CustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ILocalDefinition.get_IsConstant();
    private sealed virtual override bool Microsoft.Cci.ILocalDefinition.get_IsModified();
    private sealed virtual override bool Microsoft.Cci.ILocalDefinition.get_IsPinned();
    private sealed virtual override bool Microsoft.Cci.ILocalDefinition.get_IsReference();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.MetadataReader.MethodBody.LocalVariableSignatureConverter : SignatureConverter {
    internal ILocalDefinition[] LocalVariables;
    private MethodBody OwningMethodBody;
    internal LocalVariableSignatureConverter(PEFileToObjectModel peFileToObjectModel, MethodBody owningMethodBody, MemoryReader signatureMemoryReader);
    private LocalVariableDefinition GetLocalVariable(UInt32 index);
}
internal class Microsoft.Cci.MetadataReader.MethodBody.MethodBody : object {
    internal MethodDefinition MethodDefinition;
    internal ILocalDefinition[] LocalVariables;
    internal IEnumerable`1<IOperation> cilInstructions;
    private IEnumerable`1<IOperationExceptionInformation> cilExceptionInformation;
    internal bool IsLocalsInited;
    internal ushort StackSize;
    private UInt32 bodySize;
    private IMethodDefinition Microsoft.Cci.IMethodBody.MethodDefinition { get; }
    private IEnumerable`1<ILocalDefinition> Microsoft.Cci.IMethodBody.LocalVariables { get; }
    private bool Microsoft.Cci.IMethodBody.LocalsAreZeroed { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public IEnumerable`1<ITypeDefinition> PrivateHelperTypes { get; }
    public ushort MaxStack { get; }
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public UInt32 Size { get; }
    internal MethodBody(MethodDefinition methodDefinition, bool isLocalsInited, ushort stackSize, UInt32 bodySize);
    internal void SetLocalVariables(ILocalDefinition[] localVariables);
    internal void SetCilInstructions(IEnumerable`1<IOperation> cilInstructions);
    internal void SetExceptionInformation(IOperationExceptionInformation[] cilExceptionInformation);
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodBody.get_MethodDefinition();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<ILocalDefinition> Microsoft.Cci.IMethodBody.get_LocalVariables();
    private sealed virtual override bool Microsoft.Cci.IMethodBody.get_LocalsAreZeroed();
    public sealed virtual IEnumerable`1<IOperation> get_Operations();
    public sealed virtual IEnumerable`1<ITypeDefinition> get_PrivateHelperTypes();
    public sealed virtual ushort get_MaxStack();
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public sealed virtual UInt32 get_Size();
}
internal class Microsoft.Cci.MetadataReader.MethodBody.StandAloneMethodSignatureConverter : SignatureConverter {
    internal byte FirstByte;
    internal IEnumerable`1<ICustomModifier> ReturnCustomModifiers;
    internal ITypeReference ReturnTypeReference;
    internal bool IsReturnByReference;
    internal IEnumerable`1<IParameterTypeInformation> RequiredParameters;
    internal IEnumerable`1<IParameterTypeInformation> VarArgParameters;
    internal StandAloneMethodSignatureConverter(PEFileToObjectModel peFileToObjectModel, MethodDefinition moduleMethodDef, MemoryReader signatureMemoryReader);
}
public class Microsoft.Cci.MetadataReader.MethodBodyDocument : object {
    internal MethodDefinition method;
    public string Location { get; }
    public UInt32 MethodToken { get; }
    public IName Name { get; }
    public ITokenDecoder TokenDecoder { get; }
    internal MethodBodyDocument(MethodDefinition method);
    public ITypeReference GetTypeFromToken(UInt32 standAloneSignatureToken);
    public sealed virtual string get_Location();
    public UInt32 get_MethodToken();
    public sealed virtual IName get_Name();
    public ITokenDecoder get_TokenDecoder();
}
internal class Microsoft.Cci.MetadataReader.MethodBodyLocation : object {
    private MethodBodyDocument document;
    private UInt32 offset;
    public MethodBodyDocument Document { get; }
    public IMethodDefinition MethodDefinition { get; }
    public UInt32 Offset { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    internal MethodBodyLocation(MethodBodyDocument document, UInt32 offset);
    public MethodBodyDocument get_Document();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual UInt32 get_Offset();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
internal class Microsoft.Cci.MetadataReader.MethodDefSignatureConverter : SignatureConverter {
    internal byte FirstByte;
    internal UInt32 GenericParamCount;
    internal int paramCount;
    internal IEnumerable`1<ICustomModifier> ReturnCustomModifiers;
    internal ITypeReference ReturnTypeReference;
    internal IParameterDefinition[] Parameters;
    internal ReturnParameter ReturnParameter;
    private ParamInfo[] ParamInfoArray;
    internal MethodDefSignatureConverter(PEFileToObjectModel peFileToObjectModel, MethodDefinition moduleMethod, MemoryReader signatureMemoryReader);
    protected virtual Nullable`1<ParamInfo> GetParamInfo(int paramSequence);
}
internal class Microsoft.Cci.MetadataReader.MethodRefSignatureConverter : SignatureConverter {
    internal ushort GenericParamCount;
    internal IEnumerable`1<ICustomModifier> ReturnCustomModifiers;
    internal ITypeReference ReturnTypeReference;
    internal bool IsReturnByReference;
    internal IParameterTypeInformation[] RequiredParameters;
    internal IParameterTypeInformation[] VarArgParameters;
    internal MethodRefSignatureConverter(PEFileToObjectModel peFileToObjectModel, MethodReference moduleMethodRef, MemoryReader signatureMemoryReader);
}
internal class Microsoft.Cci.MetadataReader.MethodSpecSignatureConverter : SignatureConverter {
    internal EnumerableArrayWrapper`2<ITypeReference, ITypeReference> GenericTypeArguments;
    internal MethodSpecSignatureConverter(PEFileToObjectModel peFileToObjectModel, MetadataObject owningObject, MemoryReader signatureMemoryReader);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation._Module_Type : NonGenericNamespaceType {
    public PrimitiveTypeCode TypeCode { get; }
    internal _Module_Type(PEFileToObjectModel peFileToObjectModel, IName memberName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace);
    internal virtual void LoadMembers();
    public virtual PrimitiveTypeCode get_TypeCode();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ArrayExpression : ExpressionBase {
    internal IArrayTypeReference VectorType;
    internal EnumerableArrayWrapper`2<ExpressionBase, IMetadataExpression> Elements;
    internal ITypeReference ModuleTypeReference { get; }
    public ITypeReference ElementType { get; }
    public IEnumerable`1<IMetadataExpression> Initializers { get; }
    public IEnumerable`1<int> LowerBounds { get; }
    public UInt32 Rank { get; }
    public IEnumerable`1<ulong> Sizes { get; }
    internal ArrayExpression(IArrayTypeReference vectorType, EnumerableArrayWrapper`2<ExpressionBase, IMetadataExpression> elements);
    internal virtual ITypeReference get_ModuleTypeReference();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_ElementType();
    public sealed virtual IEnumerable`1<IMetadataExpression> get_Initializers();
    public sealed virtual IEnumerable`1<int> get_LowerBounds();
    public sealed virtual UInt32 get_Rank();
    public sealed virtual IEnumerable`1<ulong> get_Sizes();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ArrayTypeName : TypeName {
    private TypeName ElementType;
    private UInt32 Rank;
    internal ArrayTypeName(TypeName elementType, UInt32 rank);
    internal virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.Assembly : Module {
    private IName AssemblyName;
    private AssemblyFlags AssemblyFlags;
    private Byte[] publicKey;
    internal AssemblyIdentity AssemblyIdentity;
    internal IModule[] MemberModules;
    public bool IsRetargetable { get; }
    public bool ContainsForeignTypes { get; }
    internal UInt32 TokenValue { get; }
    private IEnumerable`1<IAliasForType> Microsoft.Cci.IAssembly.ExportedTypes { get; }
    public IEnumerable`1<byte> HashValue { get; }
    private IEnumerable`1<IResourceReference> Microsoft.Cci.IAssembly.Resources { get; }
    private IEnumerable`1<IFileReference> Microsoft.Cci.IAssembly.Files { get; }
    private IEnumerable`1<IModule> Microsoft.Cci.IAssembly.MemberModules { get; }
    private IEnumerable`1<ISecurityAttribute> Microsoft.Cci.IAssembly.SecurityAttributes { get; }
    private UInt32 Microsoft.Cci.IAssembly.Flags { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.PublicKey { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IAssembly.AssemblyAttributes { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    private AssemblyIdentity Microsoft.Cci.IAssemblyReference.AssemblyIdentity { get; }
    private AssemblyIdentity Microsoft.Cci.IAssemblyReference.UnifiedAssemblyIdentity { get; }
    private IEnumerable`1<IName> Microsoft.Cci.IAssemblyReference.Aliases { get; }
    private IAssembly Microsoft.Cci.IAssemblyReference.ResolvedAssembly { get; }
    private string Microsoft.Cci.IAssemblyReference.Culture { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.PublicKeyToken { get; }
    private Version Microsoft.Cci.IAssemblyReference.Version { get; }
    internal Assembly(PEFileToObjectModel peFileToObjectModel, IName moduleName, COR20Flags corFlags, UInt32 internedModuleId, AssemblyIdentity assemblyIdentity, IName assemblyName, AssemblyFlags assemblyFlags, Byte[] publicKey);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual bool get_ContainsForeignTypes();
    internal virtual UInt32 get_TokenValue();
    internal IModule FindMemberModuleNamed(IName moduleName);
    internal void SetMemberModules(IModule[] memberModules);
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<IAliasForType> Microsoft.Cci.IAssembly.get_ExportedTypes();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    private sealed virtual override IEnumerable`1<IResourceReference> Microsoft.Cci.IAssembly.get_Resources();
    private sealed virtual override IEnumerable`1<IFileReference> Microsoft.Cci.IAssembly.get_Files();
    private sealed virtual override IEnumerable`1<IModule> Microsoft.Cci.IAssembly.get_MemberModules();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.Assembly/<Microsoft-Cci-IAssembly-get_SecurityAttributes>d__28")]
private sealed virtual override IEnumerable`1<ISecurityAttribute> Microsoft.Cci.IAssembly.get_SecurityAttributes();
    private sealed virtual override UInt32 Microsoft.Cci.IAssembly.get_Flags();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_PublicKey();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IAssembly.get_AssemblyAttributes();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    private sealed virtual override AssemblyIdentity Microsoft.Cci.IAssemblyReference.get_AssemblyIdentity();
    private sealed virtual override AssemblyIdentity Microsoft.Cci.IAssemblyReference.get_UnifiedAssemblyIdentity();
    private sealed virtual override IEnumerable`1<IName> Microsoft.Cci.IAssemblyReference.get_Aliases();
    private sealed virtual override IAssembly Microsoft.Cci.IAssemblyReference.get_ResolvedAssembly();
    private sealed virtual override string Microsoft.Cci.IAssemblyReference.get_Culture();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_PublicKeyToken();
    private sealed virtual override Version Microsoft.Cci.IAssemblyReference.get_Version();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.AssemblyQualifiedTypeName : TypeName {
    private TypeName TypeName;
    private AssemblyIdentity AssemblyIdentity;
    private bool Retargetable;
    internal AssemblyQualifiedTypeName(TypeName typeName, AssemblyIdentity assemblyIdentity, bool retargetable);
    internal virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.AssemblyReference : MetadataObject {
    private UInt32 AssemblyRefRowId;
    internal AssemblyIdentity AssemblyIdentity;
    private AssemblyFlags AssemblyFlags;
    private UInt32 internedId;
    private IAssembly resolvedAssembly;
    private AssemblyIdentity unifiedAssemblyIdentity;
    internal UInt32 InternedId { get; }
    public bool IsRetargetable { get; }
    public bool ContainsForeignTypes { get; }
    internal IAssembly ResolvedAssembly { get; }
    internal UInt32 TokenValue { get; }
    internal AssemblyIdentity UnifiedAssemblyIdentity { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    private UnitIdentity Microsoft.Cci.IUnitReference.UnitIdentity { get; }
    private IUnit Microsoft.Cci.IUnitReference.ResolvedUnit { get; }
    private ModuleIdentity Microsoft.Cci.IModuleReference.ModuleIdentity { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    private IModule Microsoft.Cci.IModuleReference.ResolvedModule { get; }
    private AssemblyIdentity Microsoft.Cci.IAssemblyReference.AssemblyIdentity { get; }
    private AssemblyIdentity Microsoft.Cci.IAssemblyReference.UnifiedAssemblyIdentity { get; }
    private IAssembly Microsoft.Cci.IAssemblyReference.ResolvedAssembly { get; }
    private IEnumerable`1<IName> Microsoft.Cci.IAssemblyReference.Aliases { get; }
    private string Microsoft.Cci.IAssemblyReference.Culture { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.HashValue { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.PublicKey { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.PublicKeyToken { get; }
    private Version Microsoft.Cci.IAssemblyReference.Version { get; }
    public UInt32 InternedModuleId { get; }
    internal AssemblyReference(PEFileToObjectModel peFileToObjectModel, UInt32 assemblyRefRowId, AssemblyIdentity assemblyIdentity, AssemblyFlags assemblyFlags);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal UInt32 get_InternedId();
    public sealed virtual bool get_IsRetargetable();
    public sealed virtual bool get_ContainsForeignTypes();
    internal IAssembly get_ResolvedAssembly();
    internal virtual UInt32 get_TokenValue();
    internal AssemblyIdentity get_UnifiedAssemblyIdentity();
    public virtual string ToString();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override UnitIdentity Microsoft.Cci.IUnitReference.get_UnitIdentity();
    private sealed virtual override IUnit Microsoft.Cci.IUnitReference.get_ResolvedUnit();
    private sealed virtual override ModuleIdentity Microsoft.Cci.IModuleReference.get_ModuleIdentity();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    private sealed virtual override IModule Microsoft.Cci.IModuleReference.get_ResolvedModule();
    private sealed virtual override AssemblyIdentity Microsoft.Cci.IAssemblyReference.get_AssemblyIdentity();
    private sealed virtual override AssemblyIdentity Microsoft.Cci.IAssemblyReference.get_UnifiedAssemblyIdentity();
    private sealed virtual override IAssembly Microsoft.Cci.IAssemblyReference.get_ResolvedAssembly();
    private sealed virtual override IEnumerable`1<IName> Microsoft.Cci.IAssemblyReference.get_Aliases();
    private sealed virtual override string Microsoft.Cci.IAssemblyReference.get_Culture();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_HashValue();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_PublicKey();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_PublicKeyToken();
    private sealed virtual override Version Microsoft.Cci.IAssemblyReference.get_Version();
    public sealed virtual UInt32 get_InternedModuleId();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ByValArrayMarshallingInformation : object {
    private UnmanagedType arrayElementType;
    private UInt32 numberOfElements;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    private UnmanagedType Microsoft.Cci.IMarshallingInformation.UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal ByValArrayMarshallingInformation(UnmanagedType arrayElementType, UInt32 numberOfElements);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    private sealed virtual override UnmanagedType Microsoft.Cci.IMarshallingInformation.get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ByValTStrMarshallingInformation : object {
    private UInt32 numberOfElements;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public UnmanagedType UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal ByValTStrMarshallingInformation(UInt32 numberOfElements);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    public sealed virtual UnmanagedType get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ConstantExpression : ExpressionBase {
    private ITypeReference TypeReference;
    internal object value;
    internal ITypeReference ModuleTypeReference { get; }
    public object Value { get; }
    internal ConstantExpression(ITypeReference typeReference, object value);
    internal virtual ITypeReference get_ModuleTypeReference();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual object get_Value();
}
internal enum Microsoft.Cci.MetadataReader.ObjectModelImplementation.ContainerState : Enum {
    public byte value__;
    public static ContainerState Initialized;
    public static ContainerState StartedLoading;
    public static ContainerState Loaded;
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.CoreTypeReference : MetadataObject {
    internal IMetadataReaderModuleReference moduleReference;
    internal NamespaceReference namespaceReference;
    internal IName mangledTypeName;
    internal IName name;
    internal ushort genericParamCount;
    internal MetadataReaderSignatureTypeCode signatureTypeCode;
    private bool isResolved;
    private ITypeDefinition resolvedModuleTypeDefintion;
    private UInt32 internedKey;
    internal UInt32 TokenValue { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    private IPlatformType Microsoft.Cci.ITypeReference.PlatformType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IMetadataReaderModuleReference ModuleReference { get; }
    public IName NamespaceFullName { get; }
    public IName MangledTypeName { get; }
    public ushort GenericParameterCount { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    internal CoreTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference moduleReference, NamespaceReference namespaceReference, IName typeName, ushort genericParamCount, MetadataReaderSignatureTypeCode signatureTypeCode);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    private sealed virtual override IPlatformType Microsoft.Cci.ITypeReference.get_PlatformType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public virtual string ToString();
    public sealed virtual IMetadataReaderModuleReference get_ModuleReference();
    public sealed virtual IName get_NamespaceFullName();
    public sealed virtual IName get_MangledTypeName();
    public sealed virtual ExportedTypeAliasBase TryResolveAsExportedType();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
    public sealed virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.CustomAttribute : MetadataObject {
    internal IMethodReference Constructor;
    internal IMetadataExpression[] Arguments;
    internal IMetadataNamedArgument[] NamedArguments;
    internal UInt32 AttributeRowId;
    internal UInt32 TokenValue { get; }
    private IEnumerable`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.Arguments { get; }
    private IMethodReference Microsoft.Cci.ICustomAttribute.Constructor { get; }
    private IEnumerable`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.NamedArguments { get; }
    private ushort Microsoft.Cci.ICustomAttribute.NumberOfNamedArguments { get; }
    public ITypeReference Type { get; }
    internal CustomAttribute(PEFileToObjectModel peFileToObjectModel, UInt32 attributeRowId, IMethodReference constructor, IMetadataExpression[] arguments, IMetadataNamedArgument[] namedArguments);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    private sealed virtual override IEnumerable`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.get_Arguments();
    private sealed virtual override IMethodReference Microsoft.Cci.ICustomAttribute.get_Constructor();
    private sealed virtual override IEnumerable`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.get_NamedArguments();
    private sealed virtual override ushort Microsoft.Cci.ICustomAttribute.get_NumberOfNamedArguments();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.CustomMarshallingInformation : object {
    private ITypeReference Marshaller;
    private string MarshallerRuntimeArgument;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    private UnmanagedType Microsoft.Cci.IMarshallingInformation.UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal CustomMarshallingInformation(ITypeReference marshaller, string marshallerRuntimeArgument);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    private sealed virtual override UnmanagedType Microsoft.Cci.IMarshallingInformation.get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.CustomModifier : object {
    internal bool IsOptional;
    internal ITypeReference Modifier;
    private bool Microsoft.Cci.ICustomModifier.IsOptional { get; }
    private ITypeReference Microsoft.Cci.ICustomModifier.Modifier { get; }
    internal CustomModifier(bool isOptional, ITypeReference modifier);
    private sealed virtual override bool Microsoft.Cci.ICustomModifier.get_IsOptional();
    private sealed virtual override ITypeReference Microsoft.Cci.ICustomModifier.get_Modifier();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.EventDefinition : TypeMember {
    internal UInt32 EventRowId;
    private EventFlags EventFlags;
    private bool eventTypeInited;
    private ITypeReference eventType;
    private IMethodDefinition adderMethod;
    private IMethodDefinition removerMethod;
    private IMethodDefinition fireMethod;
    private TypeMemberVisibility visibility;
    internal UInt32 TokenValue { get; }
    internal IMethodDefinition AdderMethod { get; }
    internal IMethodDefinition RemoverMethod { get; }
    internal IMethodDefinition FireMethod { get; }
    public TypeMemberVisibility Visibility { get; }
    internal ITypeReference EventType { get; }
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMethodReference Adder { get; }
    public IMethodReference Caller { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMethodReference Remover { get; }
    public ITypeReference Type { get; }
    internal EventDefinition(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 eventRowId, EventFlags eventFlags);
    internal virtual UInt32 get_TokenValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal IMethodDefinition get_AdderMethod();
    internal IMethodDefinition get_RemoverMethod();
    internal IMethodDefinition get_FireMethod();
    public virtual TypeMemberVisibility get_Visibility();
    internal ITypeReference get_EventType();
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMethodReference get_Adder();
    public sealed virtual IMethodReference get_Caller();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual IMethodReference get_Remover();
    public sealed virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ExportedTypeAliasBase : ScopedContainerMetadataObject`3<IAliasMember, IAliasMember, IAliasForType> {
    internal IName TypeName;
    internal UInt32 ExportedTypeRowId;
    internal TypeDefFlags TypeDefFlags;
    private INamedTypeReference aliasTypeReference;
    internal UInt32 TokenValue { get; }
    public INamedTypeReference AliasedType { get; }
    internal ExportedTypeAliasBase(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 exportedTypeDefRowId, TypeDefFlags typeDefFlags);
    internal virtual void LoadMembers();
    internal virtual UInt32 get_TokenValue();
    public sealed virtual INamedTypeReference get_AliasedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ExportedTypeNamespaceAlias : ExportedTypeAliasBase {
    private Namespace ParentModuleNamespace;
    public bool IsPublic { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    public IName Name { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    internal ExportedTypeNamespaceAlias(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 exportedTypeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace);
    public sealed virtual bool get_IsPublic();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ExportedTypeNestedAlias : ExportedTypeAliasBase {
    private ExportedTypeAliasBase ParentExportedTypeAlias;
    public IAliasForType ContainingAlias { get; }
    public TypeMemberVisibility Visibility { get; }
    public IAliasForType Container { get; }
    public IName Name { get; }
    public IScope`1<IAliasMember> ContainingScope { get; }
    internal ExportedTypeNestedAlias(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 exportedTypeDefRowId, TypeDefFlags typeDefFlags, ExportedTypeAliasBase parentExportedTypeAlias);
    public sealed virtual IAliasForType get_ContainingAlias();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual IAliasForType get_Container();
    public sealed virtual IName get_Name();
    public sealed virtual IScope`1<IAliasMember> get_ContainingScope();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ExpressionBase : object {
    internal ITypeReference ModuleTypeReference { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    internal abstract virtual ITypeReference get_ModuleTypeReference();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.FieldDefinition : TypeMember {
    internal UInt32 FieldDefRowId;
    private FieldFlags FieldFlags;
    private IEnumerable`1<ICustomModifier> customModifiers;
    private ITypeReference fieldType;
    private UInt32 internedKey;
    internal UInt32 TokenValue { get; }
    public UInt32 InternedKey { get; }
    public TypeMemberVisibility Visibility { get; }
    public UInt32 BitLength { get; }
    public bool IsBitField { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public UInt32 Offset { get; }
    public int SequenceNumber { get; }
    public IMetadataConstant CompileTimeValue { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference Type { get; }
    public ISectionBlock FieldMapping { get; }
    public ITypeReference OwningTypeReference { get; }
    public ITypeReference FieldType { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    public IFieldDefinition ResolvedField { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    internal FieldDefinition(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 fieldDefRowId, FieldFlags fieldFlags);
    internal virtual UInt32 get_TokenValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private void InitFieldSignature();
    public sealed virtual UInt32 get_InternedKey();
    public virtual TypeMemberVisibility get_Visibility();
    public sealed virtual UInt32 get_BitLength();
    public sealed virtual bool get_IsBitField();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual UInt32 get_Offset();
    public sealed virtual int get_SequenceNumber();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ISectionBlock get_FieldMapping();
    public ITypeReference get_OwningTypeReference();
    public ITypeReference get_FieldType();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsModified();
    public sealed virtual IFieldDefinition get_ResolvedField();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.FieldOrPropertyNamedArgumentExpression : ExpressionBase {
    private static int IsFieldFlag;
    private static int IsResolvedFlag;
    private IName Name;
    private ITypeReference ContainingType;
    private int Flags;
    private ITypeReference fieldOrPropTypeReference;
    private object resolvedFieldOrProperty;
    internal ExpressionBase ExpressionValue;
    public bool IsField { get; }
    internal ITypeReference ModuleTypeReference { get; }
    public IName ArgumentName { get; }
    public IMetadataExpression ArgumentValue { get; }
    public object ResolvedDefinition { get; }
    internal FieldOrPropertyNamedArgumentExpression(IName name, ITypeReference containingType, bool isField, ITypeReference fieldOrPropTypeReference, ExpressionBase expressionValue);
    public sealed virtual bool get_IsField();
    internal virtual ITypeReference get_ModuleTypeReference();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IName get_ArgumentName();
    public sealed virtual IMetadataExpression get_ArgumentValue();
    public sealed virtual object get_ResolvedDefinition();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.FieldReference : MemberReference {
    protected bool signatureLoaded;
    protected IEnumerable`1<ICustomModifier> customModifiers;
    protected ITypeReference typeReference;
    internal bool isStatic;
    private UInt32 internedKey;
    public UInt32 InternedKey { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeReference FieldType { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    public bool IsStatic { get; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeReference Type { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    internal FieldReference(PEFileToObjectModel peFileToObjectModel, UInt32 memberRefRowId, ITypeReference parentTypeReference, IName name);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    protected virtual void InitFieldSignature();
    public sealed virtual UInt32 get_InternedKey();
    public virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public ITypeReference get_FieldType();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeReference get_Type();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.FileReference : MetadataObject {
    internal UInt32 FileRowId;
    internal FileFlags FileFlags;
    internal IName Name;
    internal UInt32 TokenValue { get; }
    public IAssembly ContainingAssembly { get; }
    public bool HasMetadata { get; }
    public IName FileName { get; }
    public IEnumerable`1<byte> HashValue { get; }
    internal FileReference(PEFileToObjectModel peFileToObjectModel, UInt32 fileRowId, FileFlags fileFlags, IName name);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    public sealed virtual IAssembly get_ContainingAssembly();
    public sealed virtual bool get_HasMetadata();
    public sealed virtual IName get_FileName();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.FunctionPointerTypeWithToken : FunctionPointerType {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    public FunctionPointerTypeWithToken(UInt32 tokenValue, CallingConvention callingConvention, bool returnValueIsByRef, ITypeReference type, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, IInternFactory internFactory);
    public sealed virtual UInt32 get_TokenValue();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericMethod : MethodDefinition {
    internal UInt32 GenericParamRowIdStart;
    internal UInt32 GenericParamRowIdEnd;
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public ushort GenericMethodParameterCardinality { get; }
    internal GenericMethod(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 methodDefRowId, MethodFlags methodFlags, MethodImplFlags methodImplFlags, UInt32 genericParamRowIdStart, UInt32 genericParamRowIdEnd);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericMethod/<get_GenericParameters>d__4")]
public virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public virtual ushort get_GenericParameterCount();
    public virtual bool get_IsGeneric();
    public ushort get_GenericMethodParameterCardinality();
    public ITypeReference GetGenericMethodParameterFromOrdinal(ushort genericParamOrdinal);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericMethodInstanceReferenceWithToken : GenericMethodInstanceReference {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    internal GenericMethodInstanceReferenceWithToken(IMethodReference genericMethod, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory, UInt32 tokenValue);
    public sealed virtual UInt32 get_TokenValue();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericMethodParameter : GenericParameter {
    internal GenericMethod OwningGenericMethod;
    public ushort Index { get; }
    public IMethodDefinition DefiningMethod { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    internal GenericMethodParameter(PEFileToObjectModel peFileToObjectModel, ushort genericParameterOrdinality, GenericParamFlags genericParamFlags, IName genericParamName, UInt32 genericParameterRowId, GenericMethod owningGenericMethod);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ushort get_Index();
    public sealed virtual IMethodDefinition get_DefiningMethod();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericNamespaceType : NamespaceType {
    private IName MangledName;
    private UInt32 GenericParamRowIdStart;
    private UInt32 GenericParamRowIdEnd;
    private IGenericTypeInstanceReference genericTypeInstance;
    public IName MangledTypeName { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public ushort GenericTypeParameterCardinality { get; }
    public ushort ParentGenericTypeParameterCardinality { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public ITypeReference UnderlyingType { get; }
    public bool MangleName { get; }
    internal GenericNamespaceType(PEFileToObjectModel peFileToObjectModel, IName unmangledName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace, IName mangledName, UInt32 genericParamRowIdStart, UInt32 genericParamRowIdEnd);
    public virtual IName get_MangledTypeName();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericNamespaceType/<get_GenericParameters>d__8")]
public virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public virtual ushort get_GenericParameterCount();
    public virtual bool get_IsGeneric();
    public virtual IGenericTypeInstanceReference get_InstanceType();
    public virtual ushort get_GenericTypeParameterCardinality();
    public virtual ushort get_ParentGenericTypeParameterCardinality();
    public virtual ITypeReference GetGenericTypeParameterFromOrdinal(ushort genericParamOrdinal);
    public virtual PrimitiveTypeCode get_TypeCode();
    public virtual ITypeReference get_UnderlyingType();
    public virtual bool get_MangleName();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericNamespaceTypeRefReference : NamespaceTypeRefReference {
    private IName mangledTypeName;
    private ushort genericParamCount;
    public ushort GenericParameterCount { get; }
    public IName MangledTypeName { get; }
    public bool MangleName { get; }
    internal GenericNamespaceTypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, NamespaceReference namespaceReference, IName mangledTypeName, ushort genericParamCount, bool isValueType);
    public virtual ushort get_GenericParameterCount();
    public virtual IName get_MangledTypeName();
    public virtual bool get_MangleName();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericNestedType : NestedType {
    private IName MangledName;
    internal UInt32 GenericParamRowIdStart;
    internal UInt32 GenericParamRowIdEnd;
    private IGenericTypeInstanceReference genericTypeInstance;
    public bool DoesNotInheritGenericParameters { get; }
    public IName MangledTypeName { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public ushort GenericTypeParameterCardinality { get; }
    public ushort ParentGenericTypeParameterCardinality { get; }
    public bool MangleName { get; }
    internal GenericNestedType(PEFileToObjectModel peFileToObjectModel, IName unmangledName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, TypeBase parentModuleType, IName mangledName, UInt32 genericParamRowIdStart, UInt32 genericParamRowIdEnd);
    public virtual bool get_DoesNotInheritGenericParameters();
    private bool ContainingParametersAreNotAPrefixOfOwnParameters();
    public virtual IName get_MangledTypeName();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericNestedType/<get_GenericParameters>d__11")]
public virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public virtual ushort get_GenericParameterCount();
    public virtual bool get_IsGeneric();
    public virtual IGenericTypeInstanceReference get_InstanceType();
    private ITypeReference GetSpecializedTypeReference(INamedTypeReference nominalType, Int32& argumentsUsed, bool outer);
    public virtual ushort get_GenericTypeParameterCardinality();
    public virtual ushort get_ParentGenericTypeParameterCardinality();
    public virtual ITypeReference GetGenericTypeParameterFromOrdinal(ushort genericParamOrdinal);
    public virtual bool get_MangleName();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericNestedTypeRefReference : NestedTypeRefReference {
    private IName mangledTypeName;
    private ushort genericParamCount;
    public ushort GenericParameterCount { get; }
    public IName MangledTypeName { get; }
    public bool MangleName { get; }
    internal GenericNestedTypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, IMetadataReaderNamedTypeReference parentTypeReference, IName mangledTypeName, ushort genericParamCount, bool isValueType);
    public virtual ushort get_GenericParameterCount();
    public virtual IName get_MangledTypeName();
    public virtual bool get_MangleName();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericParameter : SimpleStructuralType {
    protected ushort GenericParameterOrdinality;
    internal GenericParamFlags GenericParameterFlags;
    protected IName GenericParameterName;
    internal UInt32 GenericParameterRowId;
    private UInt32 genericParamConstraintRowIDStart;
    private UInt32 genericParamConstraintRowIDEnd;
    internal UInt32 GenericParamConstraintRowIDStart { get; }
    internal UInt32 GenericParamConstraintRowIDEnd { get; }
    internal UInt32 GenericParamConstraintCount { get; }
    private ushort Microsoft.Cci.INamedTypeDefinition.GenericParameterCount { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Index { get; }
    public IName Name { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    internal GenericParameter(PEFileToObjectModel peFileToObjectModel, ushort genericParameterOrdinality, GenericParamFlags genericParamFlags, IName genericParamName, UInt32 genericParameterRowId);
    internal UInt32 get_GenericParamConstraintRowIDStart();
    internal UInt32 get_GenericParamConstraintRowIDEnd();
    internal UInt32 get_GenericParamConstraintCount();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeDefinition.get_GenericParameterCount();
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericParameter/<get_Constraints>d__20")]
public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public abstract virtual ushort get_Index();
    public sealed virtual IName get_Name();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericTypeInstanceReferenceWithToken : GenericTypeInstanceReference {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    public GenericTypeInstanceReferenceWithToken(UInt32 tokenValue, INamedTypeReference genericType, IEnumerable`1<ITypeReference> genericArguments, IInternFactory internFactory);
    public sealed virtual UInt32 get_TokenValue();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericTypeName : TypeName {
    internal NominalTypeName GenericTemplate;
    internal List`1<TypeName> GenericArguments;
    internal GenericTypeName(NominalTypeName genericTemplate, List`1<TypeName> genericArguments);
    internal virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
    private ITypeReference GetSpecializedTypeReference(PEFileToObjectModel peFileToObjectModel, INamedTypeReference nominalType, Int32& argumentUsed, bool mostNested);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GenericTypeParameter : GenericParameter {
    internal TypeBase OwningGenericType;
    public ushort Index { get; }
    public ITypeDefinition DefiningType { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    internal GenericTypeParameter(PEFileToObjectModel peFileToObjectModel, ushort genericParameterOrdinality, GenericParamFlags genericParamFlags, IName genericParamName, UInt32 genericParameterRowId, TypeBase owningGenericType);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ushort get_Index();
    public sealed virtual ITypeDefinition get_DefiningType();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GlobalFieldDefinition : FieldDefinition {
    private Namespace ParentModuleNamespace;
    private IName NamespaceMemberName;
    public INamespaceDefinition ContainingNamespace { get; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    internal GlobalFieldDefinition(PEFileToObjectModel peFileToObjectModel, IName typeMemberName, TypeBase parentModuleType, UInt32 fieldDefRowId, FieldFlags fieldFlags, IName namespaceMemberName, Namespace parentModuleNamespace);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GlobalGenericMethod : GenericMethod {
    private Namespace ParentModuleNamespace;
    private IName NamespaceMemberName;
    private IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    internal GlobalGenericMethod(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 methodDefRowId, MethodFlags methodFlags, MethodImplFlags methodImplFlags, UInt32 genericParamRowIdStart, UInt32 genericParamRowIdEnd, IName namespaceMemberName, Namespace parentModuleNamespace);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.GlobalNonGenericMethod : NonGenericMethod {
    private Namespace ParentModuleNamespace;
    private IName NamespaceMemberName;
    private IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    internal GlobalNonGenericMethod(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 methodDefRowId, MethodFlags methodFlags, MethodImplFlags methodImplFlags, IName namespaceMemberName, Namespace parentModuleNamespace);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.IidParameterIndexMarshallingInformation : object {
    private UInt32 iidParameterIndex;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public UnmanagedType UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal IidParameterIndexMarshallingInformation(UInt32 iidParameterIndex);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    public sealed virtual UnmanagedType get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal interface Microsoft.Cci.MetadataReader.ObjectModelImplementation.IMetadataReaderModuleReference {
    public UInt32 InternedModuleId { get; }
    public abstract virtual UInt32 get_InternedModuleId();
}
internal interface Microsoft.Cci.MetadataReader.ObjectModelImplementation.IMetadataReaderNamedTypeReference {
    public IMetadataReaderModuleReference ModuleReference { get; }
    public IName NamespaceFullName { get; }
    public IName MangledTypeName { get; }
    public abstract virtual IMetadataReaderModuleReference get_ModuleReference();
    public abstract virtual IName get_NamespaceFullName();
    public abstract virtual IName get_MangledTypeName();
    public abstract virtual ExportedTypeAliasBase TryResolveAsExportedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.LPArrayMarshallingInformation : object {
    private UnmanagedType ArrayElementType;
    private int paramIndex;
    private UInt32 numElement;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    private UnmanagedType Microsoft.Cci.IMarshallingInformation.UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal LPArrayMarshallingInformation(UnmanagedType arrayElementType, int paramIndex, UInt32 numElement);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    private sealed virtual override UnmanagedType Microsoft.Cci.IMarshallingInformation.get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ManagedPointerTypeName : TypeName {
    internal TypeName TargetType;
    internal ManagedPointerTypeName(TypeName targetType);
    internal virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ManagedPointerTypeWithToken : ManagedPointerType {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    internal ManagedPointerTypeWithToken(UInt32 tokenValue, ITypeReference targetType, IInternFactory internFactory);
    public sealed virtual UInt32 get_TokenValue();
}
internal static class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MarshallingInformationHelper : object {
    internal static UnmanagedType UnmanagedTypeDefaultValue;
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MatrixWithToken : Matrix {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    internal MatrixWithToken(UInt32 tokenValue, ITypeReference elementType, UInt32 rank, IEnumerable`1<int> lowerBounds, IEnumerable`1<ulong> sizes, IInternFactory internFactory);
    public sealed virtual UInt32 get_TokenValue();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MemberReference : MetadataObject {
    internal UInt32 MemberRefRowId;
    internal IName Name;
    internal ITypeReference ParentTypeReference;
    internal UInt32 TokenValue { get; }
    public ITypeReference OwningTypeReference { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    internal MemberReference(PEFileToObjectModel peFileToObjectModel, UInt32 memberRefRowId, ITypeReference parentTypeReference, IName name);
    internal virtual UInt32 get_TokenValue();
    public virtual string ToString();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public ITypeReference get_OwningTypeReference();
    public sealed virtual ITypeReference get_ContainingType();
    public abstract virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MetadataDefinitionObject : MetadataObject {
    public IEnumerable`1<ILocation> Locations { get; }
    public IMetadataObjectWithToken Definition { get; }
    public IDocument Document { get; }
    protected MetadataDefinitionObject(PEFileToObjectModel peFileToObjectModel);
    public virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMetadataObjectWithToken get_Definition();
    public sealed virtual IDocument get_Document();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MetadataLocation : object {
    private IMetadataObjectWithToken definition;
    private IDocument document;
    public IMetadataObjectWithToken Definition { get; }
    public IDocument Document { get; }
    internal MetadataLocation(IDocument document, IMetadataObjectWithToken definition);
    public sealed virtual IMetadataObjectWithToken get_Definition();
    public sealed virtual IDocument get_Document();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MetadataObject : object {
    internal PEFileToObjectModel PEFileToObjectModel;
    private IEnumerable`1<ICustomAttribute> attributes;
    internal UInt32 TokenValue { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    private UInt32 Microsoft.Cci.IMetadataObjectWithToken.TokenValue { get; }
    protected MetadataObject(PEFileToObjectModel peFileToObjectModel);
    internal abstract virtual UInt32 get_TokenValue();
    public IPlatformType get_PlatformType();
    public virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    protected virtual IEnumerable`1<ICustomAttribute> GetAttributes();
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual IEnumerable`1<ILocation> get_Locations();
    private sealed virtual override UInt32 Microsoft.Cci.IMetadataObjectWithToken.get_TokenValue();
    public sealed virtual object GetObjectForToken(UInt32 token);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MetadataObjectDocument : object {
    private PEFileToObjectModel peFileToObjectModel;
    public string Location { get; }
    public IName Name { get; }
    internal MetadataObjectDocument(PEFileToObjectModel peFileToObjectModel);
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
internal enum Microsoft.Cci.MetadataReader.ObjectModelImplementation.MetadataReaderSignatureTypeCode : Enum {
    public int value__;
    public static MetadataReaderSignatureTypeCode SByte;
    public static MetadataReaderSignatureTypeCode Int16;
    public static MetadataReaderSignatureTypeCode Int32;
    public static MetadataReaderSignatureTypeCode Int64;
    public static MetadataReaderSignatureTypeCode Byte;
    public static MetadataReaderSignatureTypeCode UInt16;
    public static MetadataReaderSignatureTypeCode UInt32;
    public static MetadataReaderSignatureTypeCode UInt64;
    public static MetadataReaderSignatureTypeCode Single;
    public static MetadataReaderSignatureTypeCode Double;
    public static MetadataReaderSignatureTypeCode IntPtr;
    public static MetadataReaderSignatureTypeCode UIntPtr;
    public static MetadataReaderSignatureTypeCode Void;
    public static MetadataReaderSignatureTypeCode Boolean;
    public static MetadataReaderSignatureTypeCode Char;
    public static MetadataReaderSignatureTypeCode Object;
    public static MetadataReaderSignatureTypeCode String;
    public static MetadataReaderSignatureTypeCode TypedReference;
    public static MetadataReaderSignatureTypeCode ValueType;
    public static MetadataReaderSignatureTypeCode NotModulePrimitive;
}
internal enum Microsoft.Cci.MetadataReader.ObjectModelImplementation.MetadataReaderTypeKind : Enum {
    public int value__;
    public static MetadataReaderTypeKind Dummy;
    public static MetadataReaderTypeKind Nominal;
    public static MetadataReaderTypeKind TypeSpec;
    public static MetadataReaderTypeKind GenericInstance;
    public static MetadataReaderTypeKind Vector;
    public static MetadataReaderTypeKind Matrix;
    public static MetadataReaderTypeKind FunctionPointer;
    public static MetadataReaderTypeKind Pointer;
    public static MetadataReaderTypeKind ManagedPointer;
    public static MetadataReaderTypeKind GenericTypeParameter;
    public static MetadataReaderTypeKind GenericMethodParameter;
    public static MetadataReaderTypeKind ModifiedType;
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MethodDefinition : TypeMember {
    internal UInt32 MethodDefRowId;
    internal MethodFlags MethodFlags;
    internal MethodImplFlags MethodImplFlags;
    private IEnumerable`1<ICustomModifier> returnValueCustomModifiers;
    private ITypeReference modreq(System.Runtime.CompilerServices.IsVolatile) returnType;
    private byte FirstSignatureByte;
    private IParameterDefinition[] moduleParameters;
    private ReturnParameter returnParameter;
    private MethodBodyDocument bodyDocument;
    private IMethodBody body;
    private IEnumerable`1<IParameterDefinition> parameters;
    private UInt32 internedKey;
    internal MethodBodyDocument BodyDocument { get; }
    internal UInt32 TokenValue { get; }
    public TypeMemberVisibility Visibility { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public bool AcceptsExtraArguments { get; }
    public IMethodBody Body { get; }
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool HasExplicitThisParameter { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsCil { get; }
    public bool IsExternal { get; }
    public bool IsForwardReference { get; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNativeCode { get; }
    public bool IsNewSlot { get; }
    public bool IsNeverInlined { get; }
    public bool IsNeverOptimized { get; }
    public bool IsAggressivelyInlined { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeImplemented { get; }
    public bool IsRuntimeInternal { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsSynchronized { get; }
    public bool IsVirtual { get; }
    public bool IsUnmanaged { get; }
    public bool PreserveSignature { get; }
    public bool RequiresSecurityObject { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public bool IsConstructor { get; }
    public bool IsStaticConstructor { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public ushort ParameterCount { get; }
    public IEnumerable`1<ICustomAttribute> ReturnValueAttributes { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public IName ReturnValueName { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public CallingConvention CallingConvention { get; }
    public ITypeReference OwningTypeReference { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    internal IParameterDefinition[] RequiredModuleParameters { get; }
    public UInt32 InternedKey { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    internal MethodDefinition(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 methodDefRowId, MethodFlags methodFlags, MethodImplFlags methodImplFlags);
    internal MethodBodyDocument get_BodyDocument();
    internal virtual UInt32 get_TokenValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual TypeMemberVisibility get_Visibility();
    private void InitMethodSignature();
    public virtual IEnumerable`1<ILocation> get_Locations();
    public virtual string ToString();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual IMethodBody get_Body();
    public abstract virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public abstract virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_HasExplicitThisParameter();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public sealed virtual bool get_IsCil();
    public sealed virtual bool get_IsExternal();
    public sealed virtual bool get_IsForwardReference();
    public abstract virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public sealed virtual bool get_IsNativeCode();
    public sealed virtual bool get_IsNewSlot();
    public sealed virtual bool get_IsNeverInlined();
    public sealed virtual bool get_IsNeverOptimized();
    public sealed virtual bool get_IsAggressivelyInlined();
    public sealed virtual bool get_IsPlatformInvoke();
    public sealed virtual bool get_IsRuntimeImplemented();
    public sealed virtual bool get_IsRuntimeInternal();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsUnmanaged();
    public sealed virtual bool get_PreserveSignature();
    public sealed virtual bool get_RequiresSecurityObject();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.MethodDefinition/<get_SecurityAttributes>d__84")]
public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_ReturnValueAttributes();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.MethodDefinition/<GetAttributes>d__98")]
private IEnumerable`1<ICustomAttribute> GetAttributes(MetadataObject owner, UInt32 rowIdStart, UInt32 rowIdEnd);
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public sealed virtual IName get_ReturnValueName();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual CallingConvention get_CallingConvention();
    public ITypeReference get_OwningTypeReference();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    internal IParameterDefinition[] get_RequiredModuleParameters();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MethodImplementation : object {
    private ITypeDefinition containingType;
    private IMethodReference methodDeclaration;
    private IMethodReference methodBody;
    public ITypeDefinition ContainingType { get; }
    public IMethodReference ImplementedMethod { get; }
    public IMethodReference ImplementingMethod { get; }
    internal MethodImplementation(ITypeDefinition containingType, IMethodReference methodDeclaration, IMethodReference methodBody);
    public sealed virtual ITypeDefinition get_ContainingType();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_ImplementedMethod();
    public sealed virtual IMethodReference get_ImplementingMethod();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.MethodReference : MemberReference {
    internal byte FirstByte;
    protected ushort genericParameterCount;
    protected IEnumerable`1<ICustomModifier> returnCustomModifiers;
    protected ITypeReference returnTypeReference;
    protected bool isReturnByReference;
    protected IParameterTypeInformation[] requiredParameters;
    protected IParameterTypeInformation[] varArgParameters;
    private UInt32 internedKey;
    private IMethodDefinition resolvedMethod;
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IEnumerable`1<ICustomModifier> ReturnCustomModifiers { get; }
    public IParameterTypeInformation[] RequiredModuleParameterInfos { get; }
    public IParameterTypeInformation[] VarArgModuleParameterInfos { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public ushort ParameterCount { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public CallingConvention CallingConvention { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    internal MethodReference(PEFileToObjectModel peFileToObjectModel, UInt32 memberRefRowId, ITypeReference parentTypeReference, IName name, byte firstByte);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    protected virtual void InitMethodSignature();
    public virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public virtual string ToString();
    public IEnumerable`1<ICustomModifier> get_ReturnCustomModifiers();
    public IParameterTypeInformation[] get_RequiredModuleParameterInfos();
    public IParameterTypeInformation[] get_VarArgModuleParameterInfos();
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ModifiedTypeReference : object {
    private PEFileToObjectModel peFileToObjectModel;
    private ITypeReference unmodifiedType;
    private IEnumerable`1<ICustomModifier> customModifiers;
    private UInt32 internedKey;
    public IPlatformType PlatformType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public ITypeDefinition ResolvedType { get; }
    public UInt32 InternedKey { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    internal ModifiedTypeReference(PEFileToObjectModel peFileToObjectModel, ITypeReference unmodifiedType, IEnumerable`1<ICustomModifier> customModifiers);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ITypeReference get_UnmodifiedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.Module : MetadataObject {
    internal IName ModuleName;
    private COR20Flags Cor20Flags;
    internal UInt32 InternedModuleId;
    internal ModuleIdentity ModuleIdentity;
    private IMethodReference entryPointMethodReference;
    internal UInt32 TokenValue { get; }
    private ulong Microsoft.Cci.IModule.BaseAddress { get; }
    private IAssembly Microsoft.Cci.IModule.ContainingAssembly { get; }
    private IEnumerable`1<IAssemblyReference> Microsoft.Cci.IModule.AssemblyReferences { get; }
    private string Microsoft.Cci.IModule.DebugInformationLocation { get; }
    private string Microsoft.Cci.IModule.DebugInformationVersion { get; }
    private ushort Microsoft.Cci.IModule.DllCharacteristics { get; }
    private IMethodReference Microsoft.Cci.IModule.EntryPoint { get; }
    private UInt32 Microsoft.Cci.IModule.FileAlignment { get; }
    private bool Microsoft.Cci.IModule.ILOnly { get; }
    private bool Microsoft.Cci.IModule.StrongNameSigned { get; }
    private bool Microsoft.Cci.IModule.Prefers32bits { get; }
    private ModuleKind Microsoft.Cci.IModule.Kind { get; }
    private byte Microsoft.Cci.IModule.LinkerMajorVersion { get; }
    private byte Microsoft.Cci.IModule.LinkerMinorVersion { get; }
    private byte Microsoft.Cci.IModule.MetadataFormatMajorVersion { get; }
    private byte Microsoft.Cci.IModule.MetadataFormatMinorVersion { get; }
    private IName Microsoft.Cci.IModule.ModuleName { get; }
    private IEnumerable`1<IModuleReference> Microsoft.Cci.IModule.ModuleReferences { get; }
    private Guid Microsoft.Cci.IModule.PersistentIdentifier { get; }
    private Machine Microsoft.Cci.IModule.Machine { get; }
    private bool Microsoft.Cci.IModule.RequiresAmdInstructionSet { get; }
    private bool Microsoft.Cci.IModule.RequiresStartupStub { get; }
    private bool Microsoft.Cci.IModule.Requires32bits { get; }
    private bool Microsoft.Cci.IModule.Requires64bits { get; }
    private ulong Microsoft.Cci.IModule.SizeOfHeapCommit { get; }
    private ulong Microsoft.Cci.IModule.SizeOfHeapReserve { get; }
    private ulong Microsoft.Cci.IModule.SizeOfStackCommit { get; }
    private ulong Microsoft.Cci.IModule.SizeOfStackReserve { get; }
    private ushort Microsoft.Cci.IModule.SubsystemMajorVersion { get; }
    private ushort Microsoft.Cci.IModule.SubsystemMinorVersion { get; }
    private string Microsoft.Cci.IModule.TargetRuntimeVersion { get; }
    private bool Microsoft.Cci.IModule.TrackDebugData { get; }
    private bool Microsoft.Cci.IModule.UsePublicKeyTokensForAssemblyReferences { get; }
    private IEnumerable`1<IWin32Resource> Microsoft.Cci.IModule.Win32Resources { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.ModuleAttributes { get; }
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    private IPlatformType Microsoft.Cci.IUnit.PlatformType { get; }
    private string Microsoft.Cci.IUnit.Location { get; }
    private IEnumerable`1<IPESection> Microsoft.Cci.IUnit.UninterpretedSections { get; }
    private IRootUnitNamespace Microsoft.Cci.IUnit.UnitNamespaceRoot { get; }
    private IEnumerable`1<IUnitReference> Microsoft.Cci.IUnit.UnitReferences { get; }
    private INamespaceDefinition Microsoft.Cci.INamespaceRootOwner.NamespaceRoot { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    private ModuleIdentity Microsoft.Cci.IModuleReference.ModuleIdentity { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    private IModule Microsoft.Cci.IModuleReference.ResolvedModule { get; }
    public UnitIdentity UnitIdentity { get; }
    public IUnit ResolvedUnit { get; }
    private UInt32 Microsoft.Cci.MetadataReader.ObjectModelImplementation.IMetadataReaderModuleReference.InternedModuleId { get; }
    internal Module(PEFileToObjectModel peFileToObjectModel, IName moduleName, COR20Flags cor20Flags, UInt32 internedModuleId, ModuleIdentity moduleIdentity);
    public IEnumerable`1<ITypeMemberReference> GetConstructedTypeInstanceMembers();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    public virtual string ToString();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_BaseAddress();
    private sealed virtual override IAssembly Microsoft.Cci.IModule.get_ContainingAssembly();
    private sealed virtual override IEnumerable`1<IAssemblyReference> Microsoft.Cci.IModule.get_AssemblyReferences();
    private sealed virtual override string Microsoft.Cci.IModule.get_DebugInformationLocation();
    private sealed virtual override string Microsoft.Cci.IModule.get_DebugInformationVersion();
    private sealed virtual override ushort Microsoft.Cci.IModule.get_DllCharacteristics();
    private sealed virtual override IMethodReference Microsoft.Cci.IModule.get_EntryPoint();
    private sealed virtual override UInt32 Microsoft.Cci.IModule.get_FileAlignment();
    private sealed virtual override bool Microsoft.Cci.IModule.get_ILOnly();
    private sealed virtual override bool Microsoft.Cci.IModule.get_StrongNameSigned();
    private sealed virtual override bool Microsoft.Cci.IModule.get_Prefers32bits();
    private sealed virtual override ModuleKind Microsoft.Cci.IModule.get_Kind();
    private sealed virtual override byte Microsoft.Cci.IModule.get_LinkerMajorVersion();
    private sealed virtual override byte Microsoft.Cci.IModule.get_LinkerMinorVersion();
    private sealed virtual override byte Microsoft.Cci.IModule.get_MetadataFormatMajorVersion();
    private sealed virtual override byte Microsoft.Cci.IModule.get_MetadataFormatMinorVersion();
    private sealed virtual override IName Microsoft.Cci.IModule.get_ModuleName();
    private sealed virtual override IEnumerable`1<IModuleReference> Microsoft.Cci.IModule.get_ModuleReferences();
    private sealed virtual override Guid Microsoft.Cci.IModule.get_PersistentIdentifier();
    private sealed virtual override Machine Microsoft.Cci.IModule.get_Machine();
    private sealed virtual override bool Microsoft.Cci.IModule.get_RequiresAmdInstructionSet();
    private sealed virtual override bool Microsoft.Cci.IModule.get_RequiresStartupStub();
    private sealed virtual override bool Microsoft.Cci.IModule.get_Requires32bits();
    private sealed virtual override bool Microsoft.Cci.IModule.get_Requires64bits();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfHeapCommit();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfHeapReserve();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfStackCommit();
    private sealed virtual override ulong Microsoft.Cci.IModule.get_SizeOfStackReserve();
    private sealed virtual override ushort Microsoft.Cci.IModule.get_SubsystemMajorVersion();
    private sealed virtual override ushort Microsoft.Cci.IModule.get_SubsystemMinorVersion();
    private sealed virtual override string Microsoft.Cci.IModule.get_TargetRuntimeVersion();
    private sealed virtual override bool Microsoft.Cci.IModule.get_TrackDebugData();
    private sealed virtual override bool Microsoft.Cci.IModule.get_UsePublicKeyTokensForAssemblyReferences();
    private sealed virtual override IEnumerable`1<IWin32Resource> Microsoft.Cci.IModule.get_Win32Resources();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.get_ModuleAttributes();
    private sealed virtual override IEnumerable`1<string> Microsoft.Cci.IModule.GetStrings();
    private sealed virtual override IEnumerable`1<INamedTypeDefinition> Microsoft.Cci.IModule.GetAllTypes();
    private sealed virtual override IEnumerable`1<IGenericMethodInstanceReference> Microsoft.Cci.IModule.GetGenericMethodInstances();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IModule.GetStructuralTypeInstances();
    private sealed virtual override IEnumerable`1<ITypeMemberReference> Microsoft.Cci.IModule.GetStructuralTypeInstanceMembers();
    private sealed virtual override IEnumerable`1<ITypeMemberReference> Microsoft.Cci.IModule.GetTypeMemberReferences();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IModule.GetTypeReferences();
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    private sealed virtual override IPlatformType Microsoft.Cci.IUnit.get_PlatformType();
    private sealed virtual override string Microsoft.Cci.IUnit.get_Location();
    private sealed virtual override IEnumerable`1<IPESection> Microsoft.Cci.IUnit.get_UninterpretedSections();
    private sealed virtual override IRootUnitNamespace Microsoft.Cci.IUnit.get_UnitNamespaceRoot();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.Module/<Microsoft-Cci-IUnit-get_UnitReferences>d__102")]
private sealed virtual override IEnumerable`1<IUnitReference> Microsoft.Cci.IUnit.get_UnitReferences();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.INamespaceRootOwner.get_NamespaceRoot();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override ModuleIdentity Microsoft.Cci.IModuleReference.get_ModuleIdentity();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    private sealed virtual override IModule Microsoft.Cci.IModuleReference.get_ResolvedModule();
    public sealed virtual UnitIdentity get_UnitIdentity();
    public sealed virtual IUnit get_ResolvedUnit();
    private sealed virtual override UInt32 Microsoft.Cci.MetadataReader.ObjectModelImplementation.IMetadataReaderModuleReference.get_InternedModuleId();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ModuleReference : MetadataObject {
    private UInt32 ModuleRefRowId;
    internal UInt32 InternedId;
    internal ModuleIdentity ModuleIdentity;
    private IModule resolvedModule;
    internal UInt32 TokenValue { get; }
    internal IModule ResolvedModule { get; }
    private UnitIdentity Microsoft.Cci.IUnitReference.UnitIdentity { get; }
    private IUnit Microsoft.Cci.IUnitReference.ResolvedUnit { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    private ModuleIdentity Microsoft.Cci.IModuleReference.ModuleIdentity { get; }
    private IModule Microsoft.Cci.IModuleReference.ResolvedModule { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public UInt32 InternedModuleId { get; }
    internal ModuleReference(PEFileToObjectModel peFileToObjectModel, UInt32 moduleRefRowId, UInt32 internedId, ModuleIdentity moduleIdentity);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    internal IModule get_ResolvedModule();
    public virtual string ToString();
    private sealed virtual override UnitIdentity Microsoft.Cci.IUnitReference.get_UnitIdentity();
    private sealed virtual override IUnit Microsoft.Cci.IUnitReference.get_ResolvedUnit();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override ModuleIdentity Microsoft.Cci.IModuleReference.get_ModuleIdentity();
    private sealed virtual override IModule Microsoft.Cci.IModuleReference.get_ResolvedModule();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual UInt32 get_InternedModuleId();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.Namespace : ScopedContainerMetadataObject`3<INamespaceMember, INamespaceMember, INamespaceDefinition> {
    internal IName NamespaceName;
    internal IName NamespaceFullName;
    private UInt32 namespaceNameOffset;
    internal UInt32 NamespaceNameOffset { get; }
    internal UInt32 TokenValue { get; }
    public IUnit Unit { get; }
    public INamespaceRootOwner RootOwner { get; }
    public IName Name { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    private IUnitNamespace Microsoft.Cci.IUnitNamespaceReference.ResolvedUnitNamespace { get; }
    protected Namespace(PEFileToObjectModel peFileToObjectModel, IName namespaceName, IName namespaceFullName);
    internal void SetNamespaceNameOffset(UInt32 namespaceNameOffset);
    internal UInt32 get_NamespaceNameOffset();
    internal virtual UInt32 get_TokenValue();
    internal virtual void LoadMembers();
    public virtual string ToString();
    public sealed virtual IUnit get_Unit();
    public sealed virtual INamespaceRootOwner get_RootOwner();
    public sealed virtual IName get_Name();
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    private sealed virtual override IUnitNamespace Microsoft.Cci.IUnitNamespaceReference.get_ResolvedUnitNamespace();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceName : object {
    internal IName FullyQualifiedName;
    internal NamespaceName ParentNamespaceName;
    internal IName Name;
    internal NamespaceName(INameTable nameTable, NamespaceName parentNamespaceName, IName name);
    internal IUnitNamespace Resolve(IModule module);
    public virtual string ToString();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceReference : MetadataObject {
    internal IName NamespaceName;
    internal IName NamespaceFullName;
    internal IMetadataReaderModuleReference ModuleReference;
    internal UInt32 TokenValue { get; }
    public IUnitReference Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IName Name { get; }
    protected NamespaceReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference moduleReference, IName namespaceName, IName namespaceFullName);
    internal virtual UInt32 get_TokenValue();
    public virtual string ToString();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IUnitReference get_Unit();
    public abstract virtual IUnitNamespace get_ResolvedUnitNamespace();
    public IName get_Name();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceType : TypeBase {
    private Namespace ParentModuleNamespace;
    public IName NamespaceFullName { get; }
    public IUnitNamespace ContainingUnitNamespace { get; }
    public bool IsPublic { get; }
    public bool IsForeignObject { get; }
    public INamespaceDefinition ContainingNamespace { get; }
    public INamespaceDefinition Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    private IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.ContainingUnitNamespace { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    protected NamespaceType(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceType/<AttributesFor>d__2")]
public sealed virtual IEnumerable`1<ICustomAttribute> AttributesFor(ITypeReference implementedInterface);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual IName get_NamespaceFullName();
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public sealed virtual bool get_IsPublic();
    public sealed virtual bool get_IsForeignObject();
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.get_ContainingUnitNamespace();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceTypeName : NominalTypeName {
    private ushort genericParameterCount;
    internal NamespaceName NamespaceName;
    internal IName Name;
    internal IName unmanagledTypeName;
    internal UInt32 GenericParameterCount { get; }
    internal IName UnmangledTypeName { get; }
    internal bool MangleName { get; }
    internal NamespaceTypeName(INameTable nameTable, NamespaceName namespaceName, IName name);
    private NamespaceTypeName(INameTable nameTable, NamespaceName namespaceName, IName name, IName unmangledTypeName);
    internal virtual UInt32 get_GenericParameterCount();
    internal virtual IMetadataReaderNamedTypeReference GetAsNomimalType(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
    private NamespaceName GetNamespaceName(INameTable nameTable, INestedUnitNamespaceReference nestedUnitNamespaceReference);
    internal virtual IName get_UnmangledTypeName();
    internal virtual INamedTypeDefinition ResolveNominalTypeName(IMetadataReaderModuleReference module);
    internal bool get_MangleName();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceTypeNameNamespaceReference : object {
    protected NamespaceTypeNameTypeReference NamespaceTypeNameTypeReference;
    public IUnitReference Unit { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    protected NamespaceTypeNameNamespaceReference(NamespaceTypeNameTypeReference namespaceTypeNameTypeReference);
    public sealed virtual IUnitReference get_Unit();
    public sealed virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceTypeNameTypeReference : TypeNameTypeReference {
    internal NamespaceTypeName NamespaceTypeName;
    private PrimitiveTypeCode typeCode;
    private INamespaceTypeDefinition resolvedType;
    public PrimitiveTypeCode TypeCode { get; }
    public ushort GenericParameterCount { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INamespaceTypeDefinition ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    public IName Name { get; }
    public IName MangledTypeName { get; }
    public IName NamespaceFullName { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    internal NamespaceTypeNameTypeReference(IMetadataReaderModuleReference module, NamespaceTypeName namespaceTypeName, PEFileToObjectModel peFileToObjectModel);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private INamedTypeDefinition Resolve();
    public virtual PrimitiveTypeCode get_TypeCode();
    private PrimitiveTypeCode UseNameToResolveTypeCode();
    public virtual ushort get_GenericParameterCount();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    internal virtual INamedTypeDefinition GetResolvedType();
    public sealed virtual INamespaceTypeDefinition get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public virtual IName get_Name();
    public virtual IName get_MangledTypeName();
    public virtual IName get_NamespaceFullName();
    public virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceTypeRefReference : TypeRefReference {
    private NamespaceReference namespaceReference;
    public IName NamespaceFullName { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INamespaceTypeDefinition ResolvedType { get; }
    public bool KeepDistinctFromDefinition { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    internal NamespaceTypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, NamespaceReference namespaceReference, bool isValueType);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ExportedTypeAliasBase TryResolveAsExportedType();
    public virtual IName get_NamespaceFullName();
    public virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual INamespaceTypeDefinition get_ResolvedType();
    public sealed virtual bool get_KeepDistinctFromDefinition();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceTypeRefReferenceWithoutPrimitiveTypeCode : NonGenericNamespaceTypeRefReference {
    internal NamespaceTypeRefReferenceWithoutPrimitiveTypeCode(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, NamespaceReference namespaceReference, bool isValueType);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NamespaceTypeRefReferenceWithPrimitiveTypeCode : NonGenericNamespaceTypeRefReference {
    private MetadataReaderSignatureTypeCode signatureTypeCode;
    public PrimitiveTypeCode TypeCode { get; }
    internal NamespaceTypeRefReferenceWithPrimitiveTypeCode(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, NamespaceReference namespaceReference, MetadataReaderSignatureTypeCode signatureTypeCode);
    public virtual PrimitiveTypeCode get_TypeCode();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedNamespace : Namespace {
    private Namespace ParentModuleNamespace;
    public INamespaceDefinition ContainingNamespace { get; }
    public IUnitNamespace ContainingUnitNamespace { get; }
    public INamespaceDefinition Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    private IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.ContainingUnitNamespace { get; }
    private INestedUnitNamespace Microsoft.Cci.INestedUnitNamespaceReference.ResolvedNestedUnitNamespace { get; }
    internal NestedNamespace(PEFileToObjectModel peFileToObjectModel, IName namespaceName, IName namespaceFullName, Namespace parentModuleNamespace);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public sealed virtual INamespaceDefinition get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.get_ContainingUnitNamespace();
    private sealed virtual override INestedUnitNamespace Microsoft.Cci.INestedUnitNamespaceReference.get_ResolvedNestedUnitNamespace();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedNamespaceReference : NamespaceReference {
    private NamespaceReference ParentModuleNamespaceReference;
    private INestedUnitNamespace resolvedNamespace;
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    private IName Microsoft.Cci.INamedEntity.Name { get; }
    internal NestedNamespaceReference(PEFileToObjectModel peFileToObjectModel, IName namespaceName, IName namespaceFullName, NamespaceReference parentModuleNamespaceReference);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    private sealed virtual override IName Microsoft.Cci.INamedEntity.get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedNamespaceTypeNameNamespaceReference : NamespaceTypeNameNamespaceReference {
    private NamespaceName NamespaceName;
    public IUnitNamespaceReference ContainingUnitNamespace { get; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public IName Name { get; }
    internal NestedNamespaceTypeNameNamespaceReference(NamespaceName namespaceName, NamespaceTypeNameTypeReference namespaceTypeNameTypeReference);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public sealed virtual IName get_Name();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedType : TypeBase {
    internal TypeBase OwningModuleType;
    private ITypeReference enumUnderlyingType;
    public bool DoesNotInheritGenericParameters { get; }
    public ITypeReference UnderlyingType { get; }
    public IName NamespaceFullName { get; }
    public PrimitiveTypeCode TypeCode { get; }
    private ushort Microsoft.Cci.INestedTypeDefinition.GenericParameterCount { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeDefinition Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Name { get; }
    public IScope`1<ITypeDefinitionMember> ContainingScope { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    protected NestedType(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, TypeBase parentModuleType);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual bool get_DoesNotInheritGenericParameters();
    public virtual ITypeReference get_UnderlyingType();
    public virtual IName get_NamespaceFullName();
    public virtual PrimitiveTypeCode get_TypeCode();
    private sealed virtual override ushort Microsoft.Cci.INestedTypeDefinition.get_GenericParameterCount();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeDefinition get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Name();
    public sealed virtual IScope`1<ITypeDefinitionMember> get_ContainingScope();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedTypeName : NominalTypeName {
    private ushort genericParameterCount;
    internal NominalTypeName ContainingTypeName;
    internal IName Name;
    internal IName unmangledTypeName;
    internal UInt32 GenericParameterCount { get; }
    internal IName UnmangledTypeName { get; }
    internal bool MangleName { get; }
    internal NestedTypeName(INameTable nameTable, NominalTypeName containingTypeName, IName mangledName);
    internal virtual UInt32 get_GenericParameterCount();
    internal virtual IMetadataReaderNamedTypeReference GetAsNomimalType(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
    internal virtual IName get_UnmangledTypeName();
    internal virtual INamedTypeDefinition ResolveNominalTypeName(IMetadataReaderModuleReference module);
    internal bool get_MangleName();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedTypeNameTypeReference : TypeNameTypeReference {
    internal NestedTypeName NestedTypeName;
    private INestedTypeDefinition resolvedType;
    public ushort GenericParameterCount { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public IName Name { get; }
    public IName MangledTypeName { get; }
    public IName NamespaceFullName { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    internal NestedTypeNameTypeReference(IMetadataReaderModuleReference module, NestedTypeName nestedTypeName, PEFileToObjectModel peFileToObjectModel);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private INamedTypeDefinition Resolve();
    public virtual ushort get_GenericParameterCount();
    internal virtual INamedTypeDefinition GetResolvedType();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public virtual IName get_Name();
    public virtual IName get_MangledTypeName();
    public virtual IName get_NamespaceFullName();
    public virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NestedTypeRefReference : TypeRefReference {
    private IMetadataReaderNamedTypeReference parentTypeReference;
    public IName NamespaceFullName { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public INestedTypeDefinition ResolvedType { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    internal NestedTypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, IMetadataReaderNamedTypeReference parentTypeReference, bool isValueType);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ExportedTypeAliasBase TryResolveAsExportedType();
    public virtual IName get_NamespaceFullName();
    public virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual INestedTypeDefinition get_ResolvedType();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NominalTypeName : TypeName {
    internal UInt32 GenericParameterCount { get; }
    internal IName UnmangledTypeName { get; }
    internal abstract virtual UInt32 get_GenericParameterCount();
    internal abstract virtual IMetadataReaderNamedTypeReference GetAsNomimalType(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
    internal virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
    internal IMetadataReaderNamedTypeReference GetAsNamedTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
    internal abstract virtual INamedTypeDefinition ResolveNominalTypeName(IMetadataReaderModuleReference module);
    internal abstract virtual IName get_UnmangledTypeName();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericMethod : MethodDefinition {
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public bool IsGeneric { get; }
    public ushort GenericParameterCount { get; }
    internal NonGenericMethod(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase parentModuleType, UInt32 methodDefRowId, MethodFlags methodFlags, MethodImplFlags methodImplFlags);
    public virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public virtual bool get_IsGeneric();
    public virtual ushort get_GenericParameterCount();
    public virtual string ToString();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericNamespaceType : NamespaceType {
    private ITypeReference enumUnderlyingType;
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public ushort GenericTypeParameterCardinality { get; }
    public ushort ParentGenericTypeParameterCardinality { get; }
    public ITypeReference UnderlyingType { get; }
    public bool MangleName { get; }
    internal NonGenericNamespaceType(PEFileToObjectModel peFileToObjectModel, IName memberName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace);
    public virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public virtual ushort get_GenericParameterCount();
    public virtual bool get_IsGeneric();
    public virtual IGenericTypeInstanceReference get_InstanceType();
    public virtual ushort get_GenericTypeParameterCardinality();
    public virtual ushort get_ParentGenericTypeParameterCardinality();
    public virtual ITypeReference GetGenericTypeParameterFromOrdinal(ushort genericParamOrdinal);
    public virtual ITypeReference get_UnderlyingType();
    public sealed virtual bool get_MangleName();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericNamespaceTypeRefReference : NamespaceTypeRefReference {
    public ushort GenericParameterCount { get; }
    public IName MangledTypeName { get; }
    public bool MangleName { get; }
    internal NonGenericNamespaceTypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, NamespaceReference namespaceReference, bool isValueType);
    public virtual ushort get_GenericParameterCount();
    public virtual IName get_MangledTypeName();
    public sealed virtual bool get_MangleName();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericNamespaceTypeWithoutPrimitiveType : NonGenericNamespaceType {
    public PrimitiveTypeCode TypeCode { get; }
    internal NonGenericNamespaceTypeWithoutPrimitiveType(PEFileToObjectModel peFileToObjectModel, IName memberName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace);
    public virtual PrimitiveTypeCode get_TypeCode();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericNamespaceTypeWithPrimitiveType : NonGenericNamespaceType {
    private MetadataReaderSignatureTypeCode signatureTypeCode;
    public PrimitiveTypeCode TypeCode { get; }
    internal NonGenericNamespaceTypeWithPrimitiveType(PEFileToObjectModel peFileToObjectModel, IName memberName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, Namespace parentModuleNamespace, MetadataReaderSignatureTypeCode signatureTypeCode);
    public virtual string ToString();
    public virtual PrimitiveTypeCode get_TypeCode();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericNestedType : NestedType {
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public ushort GenericTypeParameterCardinality { get; }
    public ushort ParentGenericTypeParameterCardinality { get; }
    internal NonGenericNestedType(PEFileToObjectModel peFileToObjectModel, IName memberName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags, TypeBase parentModuleType);
    public virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public virtual ushort get_GenericParameterCount();
    public virtual bool get_IsGeneric();
    public virtual IGenericTypeInstanceReference get_InstanceType();
    public virtual ushort get_GenericTypeParameterCardinality();
    public virtual ushort get_ParentGenericTypeParameterCardinality();
    public virtual ITypeReference GetGenericTypeParameterFromOrdinal(ushort genericParamOrdinal);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.NonGenericNestedTypeRefReference : NestedTypeRefReference {
    public ushort GenericParameterCount { get; }
    public IName MangledTypeName { get; }
    internal NonGenericNestedTypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, IMetadataReaderNamedTypeReference parentTypeReference, bool isValueType);
    public virtual ushort get_GenericParameterCount();
    public virtual IName get_MangledTypeName();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.Parameter : MetadataDefinitionObject {
    private ushort index;
    private IEnumerable`1<ICustomModifier> customModifiers;
    private ITypeReference type;
    private ISignature containingSignature;
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsByReference { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference ParamArrayElementType { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    public ushort Index { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    internal Parameter(PEFileToObjectModel peFileToObjectModel, int index, IEnumerable`1<ICustomModifier> customModifiers, ITypeReference type, ISignature containingSignature);
    public virtual string ToString();
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual IMetadataConstant get_DefaultValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsByReference();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsOut();
    public abstract virtual bool get_IsParameterArray();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual ITypeReference get_ParamArrayElementType();
    public sealed virtual ITypeReference get_Type();
    public abstract virtual IName get_Name();
    public sealed virtual ushort get_Index();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ParameterInfo : MetadataObject {
    private ushort index;
    private IEnumerable`1<ICustomModifier> customModifiers;
    private ITypeReference type;
    private ISignature containingSignature;
    private bool isByReference;
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    public ushort Index { get; }
    internal UInt32 TokenValue { get; }
    internal ParameterInfo(PEFileToObjectModel peFileToObjectModel, int parameterIndex, IEnumerable`1<ICustomModifier> moduleCustomModifiers, ITypeReference typeReference, ISignature containingSignatureDefinition, bool isByReference);
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual ushort get_Index();
    internal virtual UInt32 get_TokenValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ParameterWithMetadata : Parameter {
    private ParamFlags ParameterFlags;
    private IName ParameterName;
    private UInt32 ParamRowId;
    internal UInt32 TokenValue { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsByReference { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference ParamArrayElementType { get; }
    public IName Name { get; }
    internal ParameterWithMetadata(PEFileToObjectModel peFileToObjectModel, int parameterIndex, IEnumerable`1<ICustomModifier> moduleCustomModifiers, ITypeReference typeReference, ISignature containingSignatureDefinition, bool isByReference, bool possibleParamArray, UInt32 paramRowId, IName parameterName, ParamFlags parameterFlags);
    internal virtual UInt32 get_TokenValue();
    public virtual IMetadataConstant get_DefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool get_IsByReference();
    public virtual bool get_IsIn();
    public virtual bool get_IsMarshalledExplicitly();
    public virtual bool get_IsOptional();
    public virtual bool get_IsOut();
    public virtual bool get_IsParameterArray();
    public virtual IMarshallingInformation get_MarshallingInformation();
    public virtual ITypeReference get_ParamArrayElementType();
    public virtual IName get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ParameterWithoutMetadata : Parameter {
    private bool isByReference;
    internal UInt32 TokenValue { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsByReference { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference ParamArrayElementType { get; }
    public IName Name { get; }
    internal ParameterWithoutMetadata(PEFileToObjectModel peFileToObjectModel, int index, IEnumerable`1<ICustomModifier> moduleCustomModifiers, ITypeReference typeReference, ISignature containingSignature, bool isByReference);
    internal virtual UInt32 get_TokenValue();
    public virtual IMetadataConstant get_DefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool get_IsByReference();
    public virtual bool get_IsIn();
    public virtual bool get_IsMarshalledExplicitly();
    public virtual bool get_IsOptional();
    public virtual bool get_IsOut();
    public virtual bool get_IsParameterArray();
    public virtual IMarshallingInformation get_MarshallingInformation();
    public virtual ITypeReference get_ParamArrayElementType();
    public virtual IName get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.PESection : object {
    private SectionHeader[] sectionHeaders;
    private int index;
    private IName sectionName;
    private PEFileToObjectModel peFileToObjectModel;
    public IName SectionName { get; }
    public PESectionCharacteristics Characteristics { get; }
    public int VirtualAddress { get; }
    public int VirtualSize { get; }
    public int SizeOfRawData { get; }
    public IEnumerable`1<byte> Rawdata { get; }
    internal PESection(SectionHeader[] sectionHeaders, int index, IName sectionName, PEFileToObjectModel peFileToObjectModel);
    public sealed virtual IName get_SectionName();
    public sealed virtual PESectionCharacteristics get_Characteristics();
    public sealed virtual int get_VirtualAddress();
    public sealed virtual int get_VirtualSize();
    public sealed virtual int get_SizeOfRawData();
    public sealed virtual IEnumerable`1<byte> get_Rawdata();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.PlatformInvokeInformation : object {
    private PInvokeMapFlags PInvokeMapFlags;
    private IName ImportName;
    private ModuleReference ImportModule;
    private IName Microsoft.Cci.IPlatformInvokeInformation.ImportName { get; }
    private IModuleReference Microsoft.Cci.IPlatformInvokeInformation.ImportModule { get; }
    private StringFormatKind Microsoft.Cci.IPlatformInvokeInformation.StringFormat { get; }
    private bool Microsoft.Cci.IPlatformInvokeInformation.NoMangle { get; }
    private bool Microsoft.Cci.IPlatformInvokeInformation.SupportsLastError { get; }
    public PInvokeCallingConvention PInvokeCallingConvention { get; }
    private Nullable`1<bool> Microsoft.Cci.IPlatformInvokeInformation.ThrowExceptionForUnmappableChar { get; }
    private Nullable`1<bool> Microsoft.Cci.IPlatformInvokeInformation.UseBestFit { get; }
    internal PlatformInvokeInformation(PInvokeMapFlags pInvokeMapFlags, IName importName, ModuleReference importModule);
    private sealed virtual override IName Microsoft.Cci.IPlatformInvokeInformation.get_ImportName();
    private sealed virtual override IModuleReference Microsoft.Cci.IPlatformInvokeInformation.get_ImportModule();
    private sealed virtual override StringFormatKind Microsoft.Cci.IPlatformInvokeInformation.get_StringFormat();
    private sealed virtual override bool Microsoft.Cci.IPlatformInvokeInformation.get_NoMangle();
    private sealed virtual override bool Microsoft.Cci.IPlatformInvokeInformation.get_SupportsLastError();
    public sealed virtual PInvokeCallingConvention get_PInvokeCallingConvention();
    private sealed virtual override Nullable`1<bool> Microsoft.Cci.IPlatformInvokeInformation.get_ThrowExceptionForUnmappableChar();
    private sealed virtual override Nullable`1<bool> Microsoft.Cci.IPlatformInvokeInformation.get_UseBestFit();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.PointerTypeName : TypeName {
    internal TypeName TargetType;
    internal PointerTypeName(TypeName targetType);
    internal virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.PointerTypeWithToken : PointerType {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    internal PointerTypeWithToken(UInt32 tokenValue, ITypeReference targetType, IInternFactory internFactory);
    public sealed virtual UInt32 get_TokenValue();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.PropertyDefinition : TypeMember {
    internal UInt32 PropertyRowId;
    private PropertyFlags PropertyFlags;
    private byte FirstSignatureByte;
    private IEnumerable`1<ICustomModifier> returnValueCustomModifiers;
    private ITypeReference returnType;
    private IEnumerable`1<IParameterDefinition> parameters;
    private IMethodDefinition getterMethod;
    private IMethodDefinition setterMethod;
    private TypeMemberVisibility visibility;
    internal UInt32 TokenValue { get; }
    public TypeMemberVisibility Visibility { get; }
    internal IEnumerable`1<ICustomModifier> ReturnModuleCustomModifiers { get; }
    internal ITypeReference ReturnType { get; }
    internal IMethodDefinition GetterMethod { get; }
    internal IMethodDefinition SetterMethod { get; }
    public IEnumerable`1<IMethodReference> Accessors { get; }
    public IMetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMethodReference Setter { get; }
    public IEnumerable`1<IParameterDefinition> Parameters { get; }
    public bool IsStatic { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    public IEnumerable`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; }
    public CallingConvention CallingConvention { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    internal PropertyDefinition(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase containingType, UInt32 propertyRowId, PropertyFlags propertyFlags);
    internal virtual UInt32 get_TokenValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual TypeMemberVisibility get_Visibility();
    private void InitPropertySignature();
    internal IEnumerable`1<ICustomModifier> get_ReturnModuleCustomModifiers();
    internal ITypeReference get_ReturnType();
    internal IMethodDefinition get_GetterMethod();
    internal IMethodDefinition get_SetterMethod();
    public sealed virtual IEnumerable`1<IMethodReference> get_Accessors();
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual IMethodReference get_Getter();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual IMethodReference get_Setter();
    public sealed virtual IEnumerable`1<IParameterDefinition> get_Parameters();
    public sealed virtual bool get_IsStatic();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    public sealed virtual IEnumerable`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual bool get_ReturnValueIsByRef();
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual CallingConvention get_CallingConvention();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.Resource : ResourceReference {
    internal UInt32 TokenValue { get; }
    public IEnumerable`1<byte> Data { get; }
    public IFileReference ExternalFile { get; }
    public bool IsInExternalFile { get; }
    private IAssemblyReference Microsoft.Cci.IResourceReference.DefiningAssembly { get; }
    private IResource Microsoft.Cci.IResourceReference.Resource { get; }
    internal Resource(PEFileToObjectModel peFileToObjectModel, UInt32 resourceRowId, IName name, ManifestResourceFlags flags, bool inExternalFile);
    internal virtual UInt32 get_TokenValue();
    public sealed virtual IEnumerable`1<byte> get_Data();
    public sealed virtual IFileReference get_ExternalFile();
    public sealed virtual bool get_IsInExternalFile();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IResourceReference.get_DefiningAssembly();
    private sealed virtual override IResource Microsoft.Cci.IResourceReference.get_Resource();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ResourceReference : MetadataObject {
    internal UInt32 ResourceRowId;
    private IAssemblyReference DefiningAssembly;
    protected ManifestResourceFlags Flags;
    internal IName Name;
    private IResource resolvedResource;
    internal UInt32 TokenValue { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IResourceReference.Attributes { get; }
    private IAssemblyReference Microsoft.Cci.IResourceReference.DefiningAssembly { get; }
    public bool IsPublic { get; }
    private IName Microsoft.Cci.IResourceReference.Name { get; }
    public IResource Resource { get; }
    internal ResourceReference(PEFileToObjectModel peFileToObjectModel, UInt32 resourceRowId, IAssemblyReference definingAssembly, ManifestResourceFlags flags, IName name);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IResourceReference.get_Attributes();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IResourceReference.get_DefiningAssembly();
    public sealed virtual bool get_IsPublic();
    private sealed virtual override IName Microsoft.Cci.IResourceReference.get_Name();
    public sealed virtual IResource get_Resource();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ReturnParameter : MetadataObject {
    private IName name;
    internal ParamFlags ReturnParamFlags;
    internal UInt32 ReturnParamRowId;
    internal UInt32 TokenValue { get; }
    public bool IsMarshalledExplicitly { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public IName Name { get; }
    internal ReturnParameter(PEFileToObjectModel peFileToObjectModel, IName name, ParamFlags returnParamFlags, UInt32 returnParamRowId);
    internal virtual UInt32 get_TokenValue();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public bool get_IsMarshalledExplicitly();
    public IMarshallingInformation get_MarshallingInformation();
    public IName get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.RootNamespace : Namespace {
    internal RootNamespace(PEFileToObjectModel peFileToObjectModel);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.RootNamespaceReference : NamespaceReference {
    public IUnitNamespace ResolvedUnitNamespace { get; }
    internal RootNamespaceReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference moduleReference);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual IUnitNamespace get_ResolvedUnitNamespace();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.RootNamespaceTypeNameNamespaceReference : NamespaceTypeNameNamespaceReference {
    internal RootNamespaceTypeNameNamespaceReference(NamespaceTypeNameTypeReference namespaceTypeNameTypeReference);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SafeArrayMarshallingInformation : object {
    private VarEnum ArrayElementType;
    private ITypeReference safeArrayElementUserDefinedSubType;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    private UnmanagedType Microsoft.Cci.IMarshallingInformation.UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal SafeArrayMarshallingInformation(VarEnum arrayElementType, ITypeReference safeArrayElementUserDefinedSubType);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    private sealed virtual override UnmanagedType Microsoft.Cci.IMarshallingInformation.get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ScannerState : ValueType {
    internal int CurrentIndex;
    internal TypeNameTokenKind CurrentTypeNameTokenKind;
    internal IName CurrentIdentifierInfo;
    internal ScannerState(int currentIndex, TypeNameTokenKind currentTypeNameTokenKind, IName currentIdentifierInfo);
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.ScopedContainerMetadataObject`3 : MetadataDefinitionObject {
    private MultiHashtable`1<InternalMemberType> caseSensitiveMemberHashTable;
    private MultiHashtable`1<InternalMemberType> caseInsensitiveMemberHashTable;
    protected ContainerState ContainerState;
    internal ValuesEnumerable<InternalMemberType> InternalMembers { get; }
    public IEnumerable`1<ExternalMemberType> Members { get; }
    protected ScopedContainerMetadataObject`3(PEFileToObjectModel peFileToObjectModel);
    internal void StartLoadingMembers();
    internal void AddMember(InternalMemberType member);
    protected void DoneLoadingMembers();
    internal abstract virtual void LoadMembers();
    internal ValuesEnumerable<InternalMemberType> get_InternalMembers();
    public sealed virtual bool Contains(ExternalMemberType member);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.ScopedContainerMetadataObject`3/<GetMatchingMembersNamed>d__11")]
public sealed virtual IEnumerable`1<ExternalMemberType> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ExternalMemberType, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.ScopedContainerMetadataObject`3/<GetMatchingMembers>d__12")]
public sealed virtual IEnumerable`1<ExternalMemberType> GetMatchingMembers(Function`2<ExternalMemberType, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.ScopedContainerMetadataObject`3/<GetMembersNamed>d__13")]
public sealed virtual IEnumerable`1<ExternalMemberType> GetMembersNamed(IName name, bool ignoreCase);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.ScopedContainerMetadataObject`3/<get_Members>d__15")]
public sealed virtual IEnumerable`1<ExternalMemberType> get_Members();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SectionBlock : object {
    private PESectionKind PESectionKind;
    private UInt32 Offset;
    private MemoryBlock MemoryBlock;
    private PESectionKind Microsoft.Cci.ISectionBlock.PESectionKind { get; }
    private UInt32 Microsoft.Cci.ISectionBlock.Offset { get; }
    private UInt32 Microsoft.Cci.ISectionBlock.Size { get; }
    private IEnumerable`1<byte> Microsoft.Cci.ISectionBlock.Data { get; }
    internal SectionBlock(PESectionKind peSectionKind, UInt32 offset, MemoryBlock memoryBlock);
    private sealed virtual override PESectionKind Microsoft.Cci.ISectionBlock.get_PESectionKind();
    private sealed virtual override UInt32 Microsoft.Cci.ISectionBlock.get_Offset();
    private sealed virtual override UInt32 Microsoft.Cci.ISectionBlock.get_Size();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.ISectionBlock.get_Data();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SecurityAttribute : MetadataObject {
    internal SecurityAction Action;
    internal UInt32 DeclSecurityRowId;
    internal UInt32 TokenValue { get; }
    private SecurityAction Microsoft.Cci.ISecurityAttribute.Action { get; }
    internal SecurityAttribute(PEFileToObjectModel peFileToObjectModel, UInt32 declSecurityRowId, SecurityAction action);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    protected virtual IEnumerable`1<ICustomAttribute> GetAttributes();
    private sealed virtual override SecurityAction Microsoft.Cci.ISecurityAttribute.get_Action();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SecurityCustomAttribute : object {
    internal SecurityAttribute ContainingSecurityAttribute;
    internal IMethodReference ConstructorReference;
    internal IMetadataNamedArgument[] NamedArguments;
    private IEnumerable`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.Arguments { get; }
    public IMethodReference Constructor { get; }
    private IEnumerable`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.NamedArguments { get; }
    private ushort Microsoft.Cci.ICustomAttribute.NumberOfNamedArguments { get; }
    public ITypeReference Type { get; }
    internal SecurityCustomAttribute(SecurityAttribute containingSecurityAttribute, IMethodReference constructorReference, IMetadataNamedArgument[] namedArguments);
    private sealed virtual override IEnumerable`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.get_Arguments();
    public sealed virtual IMethodReference get_Constructor();
    private sealed virtual override IEnumerable`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.get_NamedArguments();
    private sealed virtual override ushort Microsoft.Cci.ICustomAttribute.get_NumberOfNamedArguments();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SignatureGenericMethodParameter : SignatureGenericParameter {
    private IMethodReference ModuleMethodReference;
    private ushort GenericParameterOrdinality;
    private IName name;
    private IGenericMethodParameter resolvedType;
    public ushort Index { get; }
    public IName Name { get; }
    public ITypeDefinition ResolvedType { get; }
    public IMethodDefinition DefiningMethod { get; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    internal SignatureGenericMethodParameter(PEFileToObjectModel peFileToObjectModel, IMethodReference moduleMethodReference, ushort genericParameterOrdinality);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ushort get_Index();
    public virtual IName get_Name();
    public virtual ITypeDefinition get_ResolvedType();
    private void Resolve();
    public virtual string ToString();
    public IMethodDefinition get_DefiningMethod();
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SignatureGenericParameter : object {
    internal PEFileToObjectModel PEFileToObjectModel;
    private UInt32 internedKey;
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsSealed { get; }
    public bool IsReferenceType { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasSecurityAttributes { get; }
    public IPlatformType PlatformType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ushort Index { get; }
    public IName Name { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public ITypeDefinition ResolvedType { get; }
    public UInt32 InternedKey { get; }
    protected SignatureGenericParameter(PEFileToObjectModel peFileToObjectModel);
    public IEnumerable`1<ITypeReference> get_Constraints();
    public bool get_MustBeReferenceType();
    public bool get_MustBeValueType();
    public bool get_MustHaveDefaultConstructor();
    public TypeParameterVariance get_Variance();
    public ushort get_Alignment();
    public IEnumerable`1<ITypeReference> get_BaseClasses();
    public IEnumerable`1<IEventDefinition> get_Events();
    public IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public IEnumerable`1<IFieldDefinition> get_Fields();
    public IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public ushort get_GenericParameterCount();
    public IEnumerable`1<ITypeReference> get_Interfaces();
    public IGenericTypeInstanceReference get_InstanceType();
    public bool get_IsAbstract();
    public bool get_IsClass();
    public bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public bool get_IsGeneric();
    public bool get_IsInterface();
    public bool get_IsSealed();
    public bool get_IsReferenceType();
    public bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public bool get_IsStruct();
    public IEnumerable`1<ITypeDefinitionMember> get_Members();
    public IEnumerable`1<IMethodDefinition> get_Methods();
    public IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public IEnumerable`1<IPropertyDefinition> get_Properties();
    public UInt32 get_SizeOf();
    public IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public ITypeReference get_UnderlyingType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public LayoutKind get_Layout();
    public bool get_IsSpecialName();
    public bool get_IsComObject();
    public bool get_IsSerializable();
    public bool get_IsBeforeFieldInit();
    public StringFormatKind get_StringFormat();
    public bool get_IsRuntimeSpecial();
    public bool get_HasSecurityAttributes();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public bool Contains(ITypeDefinitionMember member);
    public IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public abstract virtual ushort get_Index();
    public abstract virtual IName get_Name();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public abstract virtual ITypeDefinition get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SignatureGenericTypeParameter : SignatureGenericParameter {
    private INamedTypeReference TypeReference;
    private ushort GenericParameterIndex;
    private IName name;
    private IGenericTypeParameter resolvedType;
    public ushort Index { get; }
    public IName Name { get; }
    public ITypeDefinition ResolvedType { get; }
    public ITypeDefinition DefiningType { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    internal SignatureGenericTypeParameter(PEFileToObjectModel peFileToObjectModel, ITypeReference typeReference, ushort genericParameterOrdinality);
    private INamedTypeReference Unspecialize(ITypeReference typeReference);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ushort get_Index();
    public virtual IName get_Name();
    public virtual ITypeDefinition get_ResolvedType();
    private IGenericTypeParameter Resolve();
    public virtual string ToString();
    public ITypeDefinition get_DefiningType();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SimpleMarshallingInformation : object {
    private UnmanagedType unmanagedType;
    public ITypeReference CustomMarshaller { get; }
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public UnmanagedType UnmanagedType { get; }
    public UInt32 IidParameterIndex { get; }
    public UInt32 NumberOfElements { get; }
    public Nullable`1<UInt32> ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; }
    internal SimpleMarshallingInformation(UnmanagedType unmanagedType);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public sealed virtual UnmanagedType get_ElementType();
    public sealed virtual UnmanagedType get_UnmanagedType();
    public sealed virtual UInt32 get_IidParameterIndex();
    public sealed virtual UInt32 get_NumberOfElements();
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SimpleStructuralType : MetadataDefinitionObject {
    private UInt32 TypeSpecToken;
    private UInt32 internedKey;
    internal UInt32 TokenValue { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public ITypeDefinition ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private IPlatformType Microsoft.Cci.ITypeReference.PlatformType { get; }
    protected SimpleStructuralType(PEFileToObjectModel peFileToObjectModel, UInt32 typeSpecToken);
    internal virtual UInt32 get_TokenValue();
    internal void UpdateTypeSpecToken(UInt32 typeSpecToken);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ushort get_Alignment();
    public virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual ITypeReference get_UnderlyingType();
    public virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public virtual string ToString();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override IPlatformType Microsoft.Cci.ITypeReference.get_PlatformType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SpecializedParameter : object {
    internal IParameterDefinition RawTemplateParameter;
    internal ISignature ContainingSignatureDefinition;
    internal ITypeReference TypeReference;
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsByReference { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ITypeReference ParamArrayElementType { get; }
    public ITypeReference Type { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IName Name { get; }
    public ushort Index { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    internal SpecializedParameter(IParameterDefinition rawTemplateParameter, ISignature containingSignatureDefinition, ITypeReference typeReference);
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ITypeReference get_ParamArrayElementType();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_Index();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.SpecializedParameterInfo : object {
    internal IParameterTypeInformation RawTemplateParameterInfo;
    internal ISignature ContainingSignatureDefinition;
    internal ITypeReference TypeReference;
    public ushort Index { get; }
    public ISignature ContainingSignature { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public ITypeReference Type { get; }
    internal SpecializedParameterInfo(IParameterTypeInformation rawTemplateParameterInfo, ISignature containingSignatureDefinition, ITypeReference typeReference);
    public sealed virtual ushort get_Index();
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeBase : ScopedContainerMetadataObject`3<ITypeDefinitionMember, ITypeDefinitionMember, ITypeDefinition> {
    internal IName TypeName;
    internal UInt32 TypeDefRowId;
    internal TypeDefFlags TypeDefFlags;
    internal ITypeReference baseTypeReference;
    private UInt32 interfaceRowIdStart;
    private UInt32 interfaceRowIdEnd;
    protected byte initFlags;
    internal static byte BaseInitFlag;
    internal static byte EnumInited;
    internal static byte InheritTypeParametersInited;
    internal IEnumerable`1<INestedTypeDefinition> nestedTypes;
    private UInt32 internedKey;
    internal UInt32 TokenValue { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    internal ITypeReference BaseTypeReference { get; }
    internal UInt32 InterfaceRowIdStart { get; }
    internal UInt32 InterfaceRowIdEnd { get; }
    internal UInt32 InterfaceCount { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsClass { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public bool IsValueType { get; }
    public bool IsStruct { get; }
    public UInt32 SizeOf { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public ITypeReference UnderlyingType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public LayoutKind Layout { get; }
    public bool IsSpecialName { get; }
    public bool IsComObject { get; }
    public bool IsSerializable { get; }
    public bool IsBeforeFieldInit { get; }
    public StringFormatKind StringFormat { get; }
    public bool IsRuntimeSpecial { get; }
    public bool HasDeclarativeSecurity { get; }
    public IName Name { get; }
    public IMetadataReaderModuleReference ModuleReference { get; }
    public IName NamespaceFullName { get; }
    public IName MangledTypeName { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private IPlatformType Microsoft.Cci.ITypeReference.PlatformType { get; }
    public ushort GenericTypeParameterCardinality { get; }
    public ushort ParentGenericTypeParameterCardinality { get; }
    public bool MangleName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    protected TypeBase(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeDefRowId, TypeDefFlags typeDefFlags);
    internal virtual UInt32 get_TokenValue();
    internal virtual void LoadMembers();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    internal ITypeReference get_BaseTypeReference();
    internal UInt32 get_InterfaceRowIdStart();
    internal UInt32 get_InterfaceRowIdEnd();
    internal UInt32 get_InterfaceCount();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeBase/<get_ExplicitImplementationOverrides>d__40")]
public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public abstract virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public abstract virtual ushort get_GenericParameterCount();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeBase/<get_Interfaces>d__46")]
public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public abstract virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public abstract virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsStruct();
    public sealed virtual UInt32 get_SizeOf();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeBase/<get_SecurityAttributes>d__74")]
public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public abstract virtual ITypeReference get_UnderlyingType();
    public abstract virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public virtual string ToString();
    public sealed virtual IName get_Name();
    public sealed virtual IMetadataReaderModuleReference get_ModuleReference();
    public abstract virtual IName get_NamespaceFullName();
    public virtual IName get_MangledTypeName();
    public sealed virtual ExportedTypeAliasBase TryResolveAsExportedType();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override IPlatformType Microsoft.Cci.ITypeReference.get_PlatformType();
    public abstract virtual ushort get_GenericTypeParameterCardinality();
    public abstract virtual ushort get_ParentGenericTypeParameterCardinality();
    public abstract virtual ITypeReference GetGenericTypeParameterFromOrdinal(ushort genericParamOrdinal);
    public virtual bool get_MangleName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeCache : object {
    internal static Byte[] EmptyByteArray;
    internal static PrimitiveTypeCode[] PrimitiveTypeCodeConv;
    internal PEFileToObjectModel PEFileToObjectModel;
    private Hashtable`1<ITypeReference> ModuleTypeHashTable;
    private static TypeMemberVisibility[0...,0...] LUB;
    private static TypeMemberVisibility[0...,0...] GLB;
    internal TypeCache(PEFileToObjectModel peFileToObjectModel);
    private static TypeCache();
    internal CoreTypeReference CreateCoreTypeReference(AssemblyReference coreAssemblyReference, NamespaceReference namespaceReference, IName typeName, MetadataReaderSignatureTypeCode signatureTypeCode);
    internal CoreTypeReference CreateCoreTypeReference(AssemblyReference coreAssemblyReference, NamespaceReference namespaceReference, IName typeName, ushort genericParameterCount, MetadataReaderSignatureTypeCode signatureTypeCode);
    internal static TypeMemberVisibility LeastUpperBound(TypeMemberVisibility left, TypeMemberVisibility right);
    internal static void SplitMangledTypeName(string mangledTypeName, String& typeName, UInt16& genericParamCount);
    internal static INamedTypeReference Unspecialize(ITypeReference typeReference);
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeMember : MetadataDefinitionObject {
    protected IName MemberName;
    internal TypeBase OwningModuleType;
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public ITypeReference ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    private ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Name { get; }
    private IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.ContainingScope { get; }
    public IName Name { get; }
    protected TypeMember(PEFileToObjectModel peFileToObjectModel, IName memberName, TypeBase owningModuleType);
    public virtual string ToString();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public abstract virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Name();
    private sealed virtual override IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.get_ContainingScope();
    public virtual IName get_Name();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeName : object {
    internal abstract virtual ITypeReference GetAsTypeReference(PEFileToObjectModel peFileToObjectModel, IMetadataReaderModuleReference module);
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeNameParser : object {
    private INameTable NameTable;
    private string TypeName;
    private int Length;
    private IName Version;
    private IName Retargetable;
    private IName PublicKeyToken;
    private IName Culture;
    private IName neutral;
    private IName ContentType;
    private IName WindowsRuntime;
    private int CurrentIndex;
    private TypeNameTokenKind CurrentTypeNameTokenKind;
    private IName CurrentIdentifierInfo;
    internal TypeNameParser(INameTable nameTable, string typeName);
    private ScannerState ScannerSnapshot();
    private void RestoreScanner(ScannerState scannerState);
    private void SkipSpaces();
    private static bool IsEndofIdentifier(char c, bool honorPunctuation, bool assemblyName);
    private Version ScanVersion();
    private bool ScanYesNo(Boolean& value);
    private Byte[] ScanPublicKeyToken();
    private void NextToken(bool assemblyName);
    private static bool IsTypeNameStart(TypeNameTokenKind typeNameTokenKind);
    private NamespaceTypeName ParseNamespaceTypeName();
    private TypeName ParseGenericTypeArgument();
    private NominalTypeName ParseNominalTypeName();
    private TypeName ParsePossiblyGenericTypeName();
    private TypeName ParseFullName();
    private AssemblyIdentity ParseAssemblyName(Boolean& retargetable);
    private TypeName ParseTypeNameWithPossibleAssemblyName();
    internal TypeName ParseTypeName();
}
internal enum Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeNameTokenKind : Enum {
    public int value__;
    public static TypeNameTokenKind EOS;
    public static TypeNameTokenKind Identifier;
    public static TypeNameTokenKind Dot;
    public static TypeNameTokenKind Plus;
    public static TypeNameTokenKind OpenBracket;
    public static TypeNameTokenKind CloseBracket;
    public static TypeNameTokenKind Astrix;
    public static TypeNameTokenKind Comma;
    public static TypeNameTokenKind Ampersand;
    public static TypeNameTokenKind Equals;
    public static TypeNameTokenKind PublicKeyToken;
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeNameTypeReference : object {
    internal IMetadataReaderModuleReference Module;
    internal PEFileToObjectModel PEFileToObjectModel;
    private UInt32 internedKey;
    private bool isEnum;
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; public set; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMetadataReaderModuleReference ModuleReference { get; }
    public IName NamespaceFullName { get; }
    public IName MangledTypeName { get; }
    public ushort GenericParameterCount { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    public IName Name { get; }
    internal TypeNameTypeReference(IMetadataReaderModuleReference module, PEFileToObjectModel peFileToObjectModel);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual string ToString();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public void set_IsEnum(bool value);
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMetadataReaderModuleReference get_ModuleReference();
    public abstract virtual IName get_NamespaceFullName();
    public abstract virtual IName get_MangledTypeName();
    public sealed virtual ExportedTypeAliasBase TryResolveAsExportedType();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    internal abstract virtual INamedTypeDefinition GetResolvedType();
    public abstract virtual IName get_Name();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeOfExpression : ExpressionBase {
    private PEFileToObjectModel PEFileToObjectModel;
    private ITypeReference TypeExpression;
    internal ITypeReference ModuleTypeReference { get; }
    public ITypeReference TypeToGet { get; }
    internal TypeOfExpression(PEFileToObjectModel peFileToObjectModel, ITypeReference typeExpression);
    internal virtual ITypeReference get_ModuleTypeReference();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_TypeToGet();
}
internal abstract class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeRefReference : MetadataObject {
    internal UInt32 TypeRefRowId;
    private IMetadataReaderModuleReference moduleReference;
    protected IName typeName;
    private bool isResolved;
    private bool isAliasIsInitialized;
    protected internal bool isValueType;
    private INamedTypeDefinition resolvedTypeDefinition;
    private ExportedTypeAliasBase exportedAliasBase;
    private UInt32 internedKey;
    internal UInt32 TokenValue { get; }
    public IMetadataReaderModuleReference ModuleReference { get; }
    public IName NamespaceFullName { get; }
    public IName MangledTypeName { get; }
    public INamedTypeDefinition ResolvedType { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public UInt32 InternedKey { get; }
    private IPlatformType Microsoft.Cci.ITypeReference.PlatformType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public IName Name { get; }
    public bool MangleName { get; }
    public ushort GenericParameterCount { get; }
    internal TypeRefReference(PEFileToObjectModel peFileToObjectModel, IName typeName, UInt32 typeRefRowId, IMetadataReaderModuleReference moduleReference, bool isValueType);
    internal virtual UInt32 get_TokenValue();
    public abstract virtual ExportedTypeAliasBase TryResolveAsExportedType();
    internal void InitResolvedModuleType();
    internal void InitExportedAliasBase();
    public virtual string ToString();
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IMetadataReaderModuleReference get_ModuleReference();
    public abstract virtual IName get_NamespaceFullName();
    public abstract virtual IName get_MangledTypeName();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual bool get_IsEnum();
    public virtual bool get_IsValueType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override IPlatformType Microsoft.Cci.ITypeReference.get_PlatformType();
    public abstract virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual IName get_Name();
    public abstract virtual bool get_MangleName();
    public abstract virtual ushort get_GenericParameterCount();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.TypeSpecReference : MetadataObject {
    internal UInt32 TypeSpecRowId;
    internal MetadataObject TypeSpecOwner;
    private bool underlyingTypeInited;
    private ITypeReference underlyingModuleTypeReference;
    private UInt32 internedKey;
    internal UInt32 TokenValue { get; }
    internal ITypeReference UnderlyingModuleTypeReference { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public ITypeDefinition ResolvedType { get; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public UInt32 InternedKey { get; }
    public PrimitiveTypeCode TypeCode { get; }
    private IPlatformType Microsoft.Cci.ITypeReference.PlatformType { get; }
    internal TypeSpecReference(PEFileToObjectModel peFileToObjectModel, UInt32 typeSpecRowId, MetadataObject typeSpecOwner);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual UInt32 get_TokenValue();
    internal ITypeReference get_UnderlyingModuleTypeReference();
    public virtual string ToString();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsValueType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    private sealed virtual override IPlatformType Microsoft.Cci.ITypeReference.get_PlatformType();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.VectorWithToken : Vector {
    private UInt32 tokenValue;
    public UInt32 TokenValue { get; }
    internal VectorWithToken(UInt32 tokenValue, ITypeReference elementType, IInternFactory internFactory);
    public sealed virtual UInt32 get_TokenValue();
}
internal class Microsoft.Cci.MetadataReader.ObjectModelImplementation.Win32Resource : object {
    internal PEFileToObjectModel PEFileToObjectModel;
    internal int TypeIdOrName;
    internal int IdOrName;
    internal int LanguageIdOrName;
    internal int RVAToData;
    internal UInt32 Size;
    internal UInt32 CodePage;
    public string TypeName { get; }
    public int TypeId { get; }
    public string Name { get; }
    public int Id { get; }
    public UInt32 LanguageId { get; }
    private UInt32 Microsoft.Cci.IWin32Resource.CodePage { get; }
    public IEnumerable`1<byte> Data { get; }
    internal Win32Resource(PEFileToObjectModel peFileTOObjectModel, int typeIdOrName, int idOrName, int languageIdOrName, int rvaToData, UInt32 size, UInt32 codePage);
    public sealed virtual string get_TypeName();
    public sealed virtual int get_TypeId();
    public sealed virtual string get_Name();
    public sealed virtual int get_Id();
    public sealed virtual UInt32 get_LanguageId();
    private sealed virtual override UInt32 Microsoft.Cci.IWin32Resource.get_CodePage();
    public sealed virtual IEnumerable`1<byte> get_Data();
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyOSRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyOSTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal int OSPlatformIdOffset;
    internal int OSMajorVersionIdOffset;
    internal int OSMinorVersionIdOffset;
    internal int RowSize;
    internal MemoryReader AssemblyOSTableMemoryReader;
    internal AssemblyOSTableReader(UInt32 numberOfRows, Byte* buffer);
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyProcessorRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyProcessorTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal int ProcessorOffset;
    internal int RowSize;
    internal MemoryReader AssemblyProcessorTableMemoryReader;
    internal AssemblyProcessorTableReader(UInt32 numberOfRows, Byte* buffer);
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRefOSRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRefOSTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsAssemblyRefTableRowRefSizeSmall;
    internal int OSPlatformIdOffset;
    internal int OSMajorVersionIdOffset;
    internal int OSMinorVersionIdOffset;
    internal int AssemblyRefOffset;
    internal int RowSize;
    internal MemoryReader AssemblyRefOSTableMemoryReader;
    internal AssemblyRefOSTableReader(UInt32 numberOfRows, int assembyRefTableRowRefSize, Byte* buffer);
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRefProcessorRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRefProcessorTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsAssemblyRefTableRowSizeSmall;
    internal int ProcessorOffset;
    internal int AssemblyRefOffset;
    internal int RowSize;
    internal MemoryReader AssemblyRefProcessorTableMemoryReader;
    internal AssemblyRefProcessorTableReader(UInt32 numberOfRows, int assembyRefTableRowRefSize, Byte* buffer);
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRefRow : ValueType {
    internal ushort MajorVersion;
    internal ushort MinorVersion;
    internal ushort BuildNumber;
    internal ushort RevisionNumber;
    internal AssemblyFlags Flags;
    internal UInt32 PublicKeyOrToken;
    internal UInt32 Name;
    internal UInt32 Culture;
    internal UInt32 HashValue;
    internal AssemblyRefRow(ushort majorVersion, ushort minorVersion, ushort buildNumber, ushort revisionNumber, AssemblyFlags flags, UInt32 publicKeyOrToken, UInt32 name, UInt32 culture, UInt32 hashValue);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRefTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int MajorVersionOffset;
    internal int MinorVersionOffset;
    internal int BuildNumberOffset;
    internal int RevisionNumberOffset;
    internal int FlagsOffset;
    internal int PublicKeyOrTokenOffset;
    internal int NameOffset;
    internal int CultureOffset;
    internal int HashValueOffset;
    internal int RowSize;
    internal MemoryReader AssemblyRefTableMemoryReader;
    internal AssemblyRefRow Item { get; }
    internal AssemblyRefTableReader(UInt32 numberOfRows, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal AssemblyRefRow get_Item(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyRow : ValueType {
    internal UInt32 HashAlgId;
    internal ushort MajorVersion;
    internal ushort MinorVersion;
    internal ushort BuildNumber;
    internal ushort RevisionNumber;
    internal AssemblyFlags Flags;
    internal UInt32 PublicKey;
    internal UInt32 Name;
    internal UInt32 Culture;
    internal AssemblyRow(UInt32 hashAlgId, ushort majorVersion, ushort minorVersion, ushort buildNumber, ushort revisionNumber, AssemblyFlags flags, UInt32 publicKey, UInt32 name, UInt32 culture);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.AssemblyTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int HashAlgIdOffset;
    internal int MajorVersionOffset;
    internal int MinorVersionOffset;
    internal int BuildNumberOffset;
    internal int RevisionNumberOffset;
    internal int FlagsOffset;
    internal int PublicKeyOffset;
    internal int NameOffset;
    internal int CultureOffset;
    internal int RowSize;
    internal MemoryReader AssemblyTableMemoryReader;
    internal AssemblyRow Item { get; }
    internal AssemblyTableReader(UInt32 numberOfRows, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal AssemblyRow get_Item(UInt32 rowId);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.BlobStreamReader : ValueType {
    internal static Byte[] Empty;
    internal MemoryReader MemoryReader;
    internal Byte[] Item { get; }
    private static BlobStreamReader();
    internal Byte[] get_Item(UInt32 offset);
    internal byte GetByteAt(UInt32 offset, int index);
    internal MemoryBlock GetMemoryBlockAt(UInt32 offset);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.CILMethodFlags : object {
    internal static byte ILTinyFormat;
    internal static byte ILFatFormat;
    internal static byte ILFormatMask;
    internal static int ILTinyFormatSizeShift;
    internal static byte ILMoreSects;
    internal static byte ILInitLocals;
    internal static byte ILFatFormatHeaderSize;
    internal static int ILFatFormatHeaderSizeShift;
    internal static byte SectEHTable;
    internal static byte SectOptILTable;
    internal static byte SectFatFormat;
    internal static byte SectMoreSects;
}
internal class Microsoft.Cci.MetadataReader.PEFile.ClassLayoutRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.ClassLayoutTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefTableRowRefSizeSmall;
    internal int PackagingSizeOffset;
    internal int ClassSizeOffset;
    internal int ParentOffset;
    internal int RowSize;
    internal MemoryReader ClassLayoutTableMemoryReader;
    internal ClassLayoutTableReader(UInt32 numberOfRows, int typeDefTableRowRefSize, Byte* buffer);
    internal ushort GetPackingSize(UInt32 typeRowId);
    internal UInt32 GetClassSize(UInt32 typeRowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.COFFFileHeader : ValueType {
    internal Machine Machine;
    internal short NumberOfSections;
    internal int TimeDateStamp;
    internal int PointerToSymbolTable;
    internal int NumberOfSymbols;
    internal short SizeOfOptionalHeader;
    internal Characteristics Characteristics;
}
internal class Microsoft.Cci.MetadataReader.PEFile.ConstantRow : ValueType {
    internal byte Type;
    internal UInt32 Parent;
    internal UInt32 Value;
    internal ConstantRow(byte type, UInt32 parent, UInt32 value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ConstantTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsHasConstantRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int TypeOffset;
    internal int ParentOffset;
    internal int ValueOffset;
    internal int RowSize;
    internal MemoryReader ConstantTableMemoryReader;
    internal ConstantRow Item { get; }
    internal ConstantTableReader(UInt32 numberOfRows, int hasConstantRefSize, int blobHeapRefSize, Byte* buffer);
    internal ConstantRow get_Item(UInt32 rowId);
    internal UInt32 GetConstantRowId(UInt32 parentToken);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.COR20Constants : object {
    internal static int SizeOfCOR20Header;
    internal static UInt32 COR20MetadataSignature;
    internal static int MinimumSizeofMetadataHeader;
    internal static int SizeofStorageHeader;
    internal static int MinimumSizeofStreamHeader;
    internal static string StringStreamName;
    internal static string BlobStreamName;
    internal static string GUIDStreamName;
    internal static string UserStringStreamName;
    internal static string CompressedMetadataTableStreamName;
    internal static string UncompressedMetadataTableStreamName;
    internal static int LargeStreamHeapSize;
}
internal class Microsoft.Cci.MetadataReader.PEFile.COR20Header : ValueType {
    internal int CountBytes;
    internal ushort MajorRuntimeVersion;
    internal ushort MinorRuntimeVersion;
    internal DirectoryEntry MetaDataDirectory;
    internal COR20Flags COR20Flags;
    internal UInt32 EntryPointTokenOrRVA;
    internal DirectoryEntry ResourcesDirectory;
    internal DirectoryEntry StrongNameSignatureDirectory;
    internal DirectoryEntry CodeManagerTableDirectory;
    internal DirectoryEntry VtableFixupsDirectory;
    internal DirectoryEntry ExportAddressTableJumpsDirectory;
    internal DirectoryEntry ManagedNativeHeaderDirectory;
}
internal class Microsoft.Cci.MetadataReader.PEFile.CustomAttributeRow : ValueType {
    internal UInt32 Parent;
    internal UInt32 Type;
    internal UInt32 Value;
    internal CustomAttributeRow(UInt32 parent, UInt32 type, UInt32 value);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.CustomAttributeTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsHasCustomAttributeRefSizeSmall;
    internal bool IsCustomAttriubuteTypeRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int ParentOffset;
    internal int TypeOffset;
    internal int ValueOffset;
    internal int RowSize;
    internal MemoryReader CustomAttributeTableMemoryReader;
    internal CustomAttributeRow Item { get; }
    internal CustomAttributeTableReader(UInt32 numberOfRows, int hasCustomAttributeRefSize, int customAttributeTypeRefSize, int blobHeapRefSize, Byte* buffer);
    internal CustomAttributeRow get_Item(UInt32 rowId);
    internal UInt32 FindCustomAttributesForToken(UInt32 token, UInt32& customAttributeCount);
    private UInt32 BinarySearchTag(UInt32 searchCodedTag, UInt32& customAttributeCount);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.CustomAttributeTypeTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Method;
    internal static UInt32 MemberRef;
    internal static UInt32 TagMask;
    internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static CustomAttributeTypeTag();
    internal static UInt32 ConvertToToken(UInt32 customAttributeType);
}
internal class Microsoft.Cci.MetadataReader.PEFile.DeclSecurityRow : ValueType {
    internal DeclSecurityActionFlags ActionFlags;
    internal UInt32 Parent;
    internal UInt32 PermissionSet;
    internal DeclSecurityRow(DeclSecurityActionFlags actionFlags, UInt32 parent, UInt32 permissionSet);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.DeclSecurityTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsHasDeclSecurityRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int ActionOffset;
    internal int ParentOffset;
    internal int PermissionSetOffset;
    internal int RowSize;
    internal MemoryReader DeclSecurityTableMemoryReader;
    internal DeclSecurityRow Item { get; }
    internal DeclSecurityTableReader(UInt32 numberOfRows, int hasDeclSecurityRefSize, int blobHeapRefSize, Byte* buffer);
    internal DeclSecurityRow get_Item(UInt32 rowId);
    internal UInt32 FindSecurityAttributesForToken(UInt32 token, UInt32& securityAttributeCount);
    private UInt32 BinarySearchTag(UInt32 searchCodedTag, UInt32& securityAttributeCount);
}
internal class Microsoft.Cci.MetadataReader.PEFile.DirectoryEntry : ValueType {
    internal int RelativeVirtualAddress;
    internal UInt32 Size;
}
internal class Microsoft.Cci.MetadataReader.PEFile.EnCLogRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.EnCLogTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal int TokenOffset;
    internal int FuncCodeOffset;
    internal int RowSize;
    internal MemoryReader EnCLogTableMemoryReader;
    internal EnCLogTableReader(UInt32 numberOfRows, Byte* buffer);
}
internal class Microsoft.Cci.MetadataReader.PEFile.EnCMapRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.EnCMapTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal int TokenOffset;
    internal int RowSize;
    internal MemoryReader EnCMapTableMemoryReader;
    internal EnCMapTableReader(UInt32 numberOfRows, Byte* buffer);
}
internal class Microsoft.Cci.MetadataReader.PEFile.EventMapRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.EventMapTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefTableRowRefSizeSmall;
    internal bool IsEventRefSizeSmall;
    internal int ParentOffset;
    internal int EventListOffset;
    internal int RowSize;
    internal MemoryReader EventMapTableMemoryReader;
    internal EventMapTableReader(UInt32 numberOfRows, int typeDefTableRowRefSize, int eventRefSize, Byte* buffer);
    internal UInt32 FindEventMapRowIdFor(UInt32 typeDefRowId);
    internal UInt32 GetEventListStartFor(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.EventPtrRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.EventPtrTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsEventTableRowRefSizeSmall;
    internal int EventOffset;
    internal int RowSize;
    internal MemoryReader EventPtrTableMemoryReader;
    internal EventPtrTableReader(UInt32 numberOfRows, int eventTableRowRefSize, Byte* buffer);
    internal UInt32 GetEventFor(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.EventRow : ValueType {
    internal EventFlags Flags;
    internal UInt32 Name;
    internal UInt32 EventType;
    internal EventRow(EventFlags flags, UInt32 name, UInt32 eventType);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.EventTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefOrRefRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int EventTypeOffset;
    internal int RowSize;
    internal MemoryReader EventTableMemoryReader;
    internal EventRow Item { get; }
    internal EventTableReader(UInt32 numberOfRows, int typeDefOrRefRefSize, int stringHeapRefSize, Byte* buffer);
    internal EventRow get_Item(UInt32 rowId);
    internal UInt32 GetEventType(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ExportedTypeRow : ValueType {
    internal TypeDefFlags Flags;
    internal UInt32 TypeDefId;
    internal UInt32 TypeName;
    internal UInt32 TypeNamespace;
    internal UInt32 Implementation;
    internal bool IsNested { get; }
    internal ExportedTypeRow(TypeDefFlags typeDefFlags, UInt32 TypeDefId, UInt32 typeName, UInt32 typeNamespace, UInt32 implementation);
    internal bool get_IsNested();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ExportedTypeTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsImplementationRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int TypeDefIdOffset;
    internal int TypeNameOffset;
    internal int TypeNamespaceOffset;
    internal int ImplementationOffset;
    internal int RowSize;
    internal MemoryReader ExportedTypeTableMemoryReader;
    internal ExportedTypeRow Item { get; }
    internal ExportedTypeTableReader(UInt32 numberOfRows, int implementationRefSize, int stringHeapRefSize, Byte* buffer);
    internal ExportedTypeRow get_Item(UInt32 rowId);
    internal UInt32 GetNamespace(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldLayoutRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldLayoutTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsFieldTableRowRefSizeSmall;
    internal int OffsetOffset;
    internal int FieldOffset;
    internal int RowSize;
    internal MemoryReader FieldLayoutTableMemoryReader;
    internal FieldLayoutTableReader(UInt32 numberOfRows, int fieldTableRowRefSize, Byte* buffer);
    internal UInt32 GetOffset(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldMarshalRow : ValueType {
    internal UInt32 Parent;
    internal UInt32 NativeType;
    internal FieldMarshalRow(UInt32 parent, UInt32 nativeType);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.FieldMarshalTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsHasFieldMarshalRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int ParentOffset;
    internal int NativeTypeOffset;
    internal int RowSize;
    internal MemoryReader FieldMarshalTableMemoryReader;
    internal FieldMarshalRow Item { get; }
    internal FieldMarshalTableReader(UInt32 numberOfRows, int hasFieldMarshalRefSize, int blobHeapRefSize, Byte* buffer);
    internal FieldMarshalRow get_Item(UInt32 rowId);
    internal UInt32 GetFieldMarshalRowId(UInt32 token);
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldPtrRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldPtrTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsFieldTableRowRefSizeSmall;
    internal int FieldOffset;
    internal int RowSize;
    internal MemoryReader FieldPtrTableMemoryReader;
    internal FieldPtrTableReader(UInt32 numberOfRows, int fieldTableRowRefSize, Byte* buffer);
    internal UInt32 GetFieldFor(UInt32 rowId);
    internal UInt32 GetRowIdForFieldDefRow(UInt32 fieldDefRowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldRow : ValueType {
    internal FieldFlags Flags;
    internal UInt32 Name;
    internal UInt32 Signature;
    internal FieldRow(FieldFlags flags, UInt32 name, UInt32 signature);
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldRVARow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.FieldRVATableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsFieldTableRowRefSizeSmall;
    internal int RVAOffset;
    internal int FieldOffset;
    internal int RowSize;
    internal MemoryReader FieldRVATableMemoryReader;
    internal FieldRVATableReader(UInt32 numberOfRows, int fieldTableRowRefSize, Byte* buffer);
    internal int GetFieldRVA(UInt32 fieldDefRowId);
    internal int GetNextRVA(int rva);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.FieldTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int SignatureOffset;
    internal int RowSize;
    internal MemoryReader FieldTableMemoryReader;
    internal FieldRow Item { get; }
    internal FieldTableReader(UInt32 numberOfRows, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal FieldRow get_Item(UInt32 rowId);
    internal UInt32 GetSignature(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.FileRow : ValueType {
    internal FileFlags Flags;
    internal UInt32 Name;
    internal UInt32 HashValue;
    internal FileRow(FileFlags flags, UInt32 name, UInt32 hashValue);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.FileTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int HashValueOffset;
    internal int RowSize;
    internal MemoryReader FileTableMemoryReader;
    internal FileRow Item { get; }
    internal FileTableReader(UInt32 numberOfRows, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal FileRow get_Item(UInt32 rowId);
    internal UInt32 GetHashValue(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.GenericParamConstraintRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.GenericParamConstraintTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsGenericParamTableRowRefSizeSmall;
    internal bool IsTypeDefOrRefRefSizeSmall;
    internal int OwnerOffset;
    internal int ConstraintOffset;
    internal int RowSize;
    internal MemoryReader GenericParamConstraintTableMemoryReader;
    internal GenericParamConstraintTableReader(UInt32 numberOfRows, int genericParamTableRowRefSize, int typeDefOrRefRefSize, Byte* buffer);
    internal UInt32 FindConstraintForGenericParam(UInt32 genericParamRowId, UInt32& genericParamConstraintCount);
    internal UInt32 GetConstraint(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.GenericParamRow : ValueType {
    internal ushort Number;
    internal GenericParamFlags Flags;
    internal UInt32 Owner;
    internal UInt32 Name;
    internal GenericParamRow(ushort number, GenericParamFlags flags, UInt32 owner, UInt32 name);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.GenericParamTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeOrMethodDefRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int NumberOffset;
    internal int FlagsOffset;
    internal int OwnerOffset;
    internal int NameOffset;
    internal int RowSize;
    internal MemoryReader GenericParamTableMemoryReader;
    internal GenericParamRow Item { get; }
    internal GenericParamTableReader(UInt32 numberOfRows, int typeOrMethodDefRefSize, int stringHeapRefSize, Byte* buffer);
    internal GenericParamRow get_Item(UInt32 rowId);
    internal UInt32 FindGenericParametersForType(UInt32 typeDefRowId, UInt16& genericParamCount);
    internal UInt32 FindGenericParametersForMethod(UInt32 typeDefRowId, UInt16& genericParamCount);
    private UInt32 BinarySearchTag(UInt32 searchCodedTag, UInt16& genericParamCount);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.GUIDStreamReader : ValueType {
    internal MemoryReader MemoryReader;
    internal Guid Item { get; }
    internal Guid get_Item(UInt32 offset);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.HasConstantTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Param;
    internal static UInt32 Property;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static HasConstantTag();
    internal static UInt32 ConvertToToken(UInt32 hasConstant);
    internal static UInt32 ConvertToTag(UInt32 token);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.HasCustomAttributeTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Method;
    internal static UInt32 Field;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 Param;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 Module;
    internal static UInt32 DeclSecurity;
    internal static UInt32 Property;
    internal static UInt32 Event;
    internal static UInt32 StandAloneSig;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 GenericParameter;
    internal static UInt32 GenericParameterConstraint;
    internal static UInt32 MethodSpec;
    internal static UInt32 TagMask;
    internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static HasCustomAttributeTag();
    internal static UInt32 ConvertToToken(UInt32 hasCustomAttribute);
    internal static UInt32 ConvertToTag(UInt32 token);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.HasDeclSecurityTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 Method;
    internal static UInt32 Assembly;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static HasDeclSecurityTag();
    internal static UInt32 ConvertToToken(UInt32 hasDeclSecurity);
    internal static UInt32 ConvertToTag(UInt32 token);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.HasFieldMarshalTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Param;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static HasFieldMarshalTag();
    internal static UInt32 ConvertToToken(UInt32 hasFieldMarshal);
    internal static UInt32 ConvertToTag(UInt32 token);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.HasSemanticsTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Event;
    internal static UInt32 Property;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static HasSemanticsTag();
    internal static UInt32 ConvertToToken(UInt32 hasSemantic);
    internal static UInt32 ConvertEventRowIdToTag(UInt32 eventRowId);
    internal static UInt32 ConvertPropertyRowIdToTag(UInt32 propertyRowId);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.ImplementationTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 File;
    internal static UInt32 AssemblyRef;
    internal static UInt32 ExportedType;
    internal static UInt32 TagMask;
    internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static ImplementationTag();
    internal static UInt32 ConvertToToken(UInt32 implementation);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ImplMapRow : ValueType {
    internal PInvokeMapFlags PInvokeMapFlags;
    internal UInt32 MemberForwarded;
    internal UInt32 ImportName;
    internal UInt32 ImportScope;
    internal ImplMapRow(PInvokeMapFlags pInvokeMapFlags, UInt32 memberForwarded, UInt32 importName, UInt32 importScope);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ImplMapTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsModuleRefTableRowRefSizeSmall;
    internal bool IsMemberForwardRowRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int MemberForwardedOffset;
    internal int ImportNameOffset;
    internal int ImportScopeOffset;
    internal int RowSize;
    internal MemoryReader ImplMapTableMemoryReader;
    internal ImplMapRow Item { get; }
    internal ImplMapTableReader(UInt32 numberOfRows, int moduleRefTableRowRefSize, int memberForwardedRefSize, int stringHeapRefSize, Byte* buffer);
    internal ImplMapRow get_Item(UInt32 rowId);
    internal UInt32 FindImplForMethod(UInt32 methodRowId);
    private UInt32 BinarySearchTag(UInt32 searchCodedTag);
}
internal class Microsoft.Cci.MetadataReader.PEFile.InterfaceImplRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.InterfaceImplTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefTableRowRefSizeSmall;
    internal bool IsTypeDefOrRefRefSizeSmall;
    internal int ClassOffset;
    internal int InterfaceOffset;
    internal int RowSize;
    internal MemoryReader InterfaceImplTableMemoryReader;
    internal InterfaceImplTableReader(UInt32 numberOfRows, int typeDefTableRowRefSize, int typeDefOrRefRefSize, Byte* buffer);
    internal UInt32 FindInterfaceImplForType(UInt32 typeDefRowId, UInt32& interfaceCount);
    internal UInt32 GetInterface(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ManifestResourceRow : ValueType {
    internal UInt32 Offset;
    internal ManifestResourceFlags Flags;
    internal UInt32 Name;
    internal UInt32 Implementation;
    internal ManifestResourceRow(UInt32 offset, ManifestResourceFlags flags, UInt32 name, UInt32 implementation);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ManifestResourceTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsImplementationRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int OffsetOffset;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int ImplementationOffset;
    internal int RowSize;
    internal MemoryReader ManifestResourceTableMemoryReader;
    internal ManifestResourceRow Item { get; }
    internal ManifestResourceTableReader(UInt32 numberOfRows, int implementationRefSize, int stringHeapRefSize, Byte* buffer);
    internal ManifestResourceRow get_Item(UInt32 rowId);
    internal UInt32 GetImplementation(UInt32 rowId);
    internal UInt32 GetOffset(UInt32 rowId);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.MemberForwardedTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Field;
    internal static UInt32 Method;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static MemberForwardedTag();
    internal static UInt32 ConvertToToken(UInt32 memberForwarded);
    internal static UInt32 ConvertMethodDefRowIdToTag(UInt32 methodDefRowId);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.MemberRefParentTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 TypeRef;
    internal static UInt32 ModuleRef;
    internal static UInt32 Method;
    internal static UInt32 TypeSpec;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static MemberRefParentTag();
    internal static UInt32 ConvertToToken(UInt32 memberRef);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MemberRefRow : ValueType {
    internal UInt32 Class;
    internal UInt32 Name;
    internal UInt32 Signature;
    internal MemberRefRow(UInt32 class, UInt32 name, UInt32 signature);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.MemberRefTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsMemberRefParentRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int ClassOffset;
    internal int NameOffset;
    internal int SignatureOffset;
    internal int RowSize;
    internal MemoryReader MemberRefTableMemoryReader;
    internal MemberRefRow Item { get; }
    internal MemberRefTableReader(UInt32 numberOfRows, int memberRefParentRefSize, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal MemberRefRow get_Item(UInt32 rowId);
    internal UInt32 GetSignature(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MetadataHeader : ValueType {
    internal UInt32 Signature;
    internal ushort MajorVersion;
    internal ushort MinorVersion;
    internal UInt32 ExtraData;
    internal int VersionStringSize;
    internal string VersionString;
}
internal static class Microsoft.Cci.MetadataReader.PEFile.MetadataStreamConstants : object {
    internal static int SizeOfMetadataTableHeader;
    internal static UInt32 LargeTableRowCount;
}
internal class Microsoft.Cci.MetadataReader.PEFile.MetadataTableHeader : ValueType {
    internal UInt32 Reserved;
    internal byte MajorVersion;
    internal byte MinorVersion;
    internal HeapSizeFlag HeapSizeFlags;
    internal byte RowId;
    internal TableMask ValidTables;
    internal TableMask SortedTables;
    internal int GetNumberOfTablesPresent();
}
internal static class Microsoft.Cci.MetadataReader.PEFile.MethodDefOrRefTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Method;
    internal static UInt32 MemberRef;
    internal static UInt32 TagMask;
    internal static TableMask TablesReferenced;
    internal static UInt32[] TagToTokenTypeArray;
    private static MethodDefOrRefTag();
    internal static UInt32 ConvertToToken(UInt32 methodDefOrRef);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodIL : object {
    internal bool LocalVariablesInited;
    internal ushort MaxStack;
    internal UInt32 LocalSignatureToken;
    internal MemoryBlock EncodedILMemoryBlock;
    internal SEHTableEntry[] SEHTable;
    internal MethodIL(bool localVariablesInited, ushort maxStack, UInt32 localSignatureToken, MemoryBlock encodedILMemoryBlock, SEHTableEntry[] sehTable);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodImplRow : ValueType {
    internal UInt32 Class;
    internal UInt32 MethodBody;
    internal UInt32 MethodDeclaration;
    internal MethodImplRow(UInt32 class, UInt32 methodBody, UInt32 methodDeclaration);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.MethodImplTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefTableRowRefSizeSmall;
    internal bool IsMethodDefOrRefRefSizeSmall;
    internal int ClassOffset;
    internal int MethodBodyOffset;
    internal int MethodDeclarationOffset;
    internal int RowSize;
    internal MemoryReader MethodImplTableMemoryReader;
    internal MethodImplRow Item { get; }
    internal MethodImplTableReader(UInt32 numberOfRows, int typeDefTableRowRefSize, int methodDefOrRefRefSize, Byte* buffer);
    internal MethodImplRow get_Item(UInt32 rowId);
    internal UInt32 FindMethodsImplForClass(UInt32 typeDefRowId, UInt16& methodImplCount);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodPtrRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodPtrTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsMethodTableRowRefSizeSmall;
    internal int MethodOffset;
    internal int RowSize;
    internal MemoryReader MethodPtrTableMemoryReader;
    internal MethodPtrTableReader(UInt32 numberOfRows, int methodTableRowRefSize, Byte* buffer);
    internal UInt32 GetMethodFor(UInt32 rowId);
    internal UInt32 GetRowIdForMethodDefRow(UInt32 methodDefRowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodRow : ValueType {
    internal int RVA;
    internal MethodImplFlags ImplFlags;
    internal MethodFlags Flags;
    internal UInt32 Name;
    internal UInt32 Signature;
    internal UInt32 ParamList;
    internal MethodRow(int rva, MethodImplFlags implFlags, MethodFlags flags, UInt32 name, UInt32 signature, UInt32 paramList);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodSemanticsRow : ValueType {
    internal MethodSemanticsFlags SemanticsFlag;
    internal UInt32 Method;
    internal UInt32 Association;
    internal MethodSemanticsRow(MethodSemanticsFlags semanticsFlag, UInt32 method, UInt32 association);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.MethodSemanticsTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsMethodTableRowRefSizeSmall;
    internal bool IsHasSemanticRefSizeSmall;
    internal int SemanticsFlagOffset;
    internal int MethodOffset;
    internal int AssociationOffset;
    internal int RowSize;
    internal MemoryReader MethodSemanticsTableMemoryReader;
    internal MethodSemanticsRow Item { get; }
    internal MethodSemanticsTableReader(UInt32 numberOfRows, int methodTableRowRefSize, int hasSemanticRefSize, Byte* buffer);
    internal MethodSemanticsRow get_Item(UInt32 rowId);
    internal UInt32 FindSemanticMethodsForEvent(UInt32 eventRowId, UInt16& methodCount);
    internal UInt32 FindSemanticMethodsForProperty(UInt32 propertyRowId, UInt16& methodCount);
    private UInt32 BinarySearchTag(UInt32 searchCodedTag, UInt16& methodCount);
}
internal class Microsoft.Cci.MetadataReader.PEFile.MethodSpecRow : ValueType {
    internal UInt32 Method;
    internal UInt32 Instantiation;
    internal MethodSpecRow(UInt32 method, UInt32 instantiation);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.MethodSpecTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsMethodDefOrRefRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int MethodOffset;
    internal int InstantiationOffset;
    internal int RowSize;
    internal MemoryReader MethodSpecTableMemoryReader;
    internal MethodSpecRow Item { get; }
    internal MethodSpecTableReader(UInt32 numberOfRows, int methodDefOrRefRefSize, int blobHeapRefSize, Byte* buffer);
    internal MethodSpecRow get_Item(UInt32 rowId);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.MethodTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsParamRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int RVAOffset;
    internal int ImplFlagsOffset;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int SignatureOffset;
    internal int ParamListOffset;
    internal int RowSize;
    internal MemoryReader MethodTableMemoryReader;
    internal MethodRow Item { get; }
    internal MethodTableReader(UInt32 numberOfRows, int paramRefSize, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal MethodRow get_Item(UInt32 rowId);
    internal UInt32 GetParamStart(UInt32 rowId);
    internal UInt32 GetSignature(UInt32 rowId);
    internal int GetNextRVA(int rva);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ModuleRefRow : ValueType {
    internal UInt32 Name;
    internal ModuleRefRow(UInt32 name);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ModuleRefTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal int NameOffset;
    internal int RowSize;
    internal MemoryReader ModuleRefTableMemoryReader;
    internal ModuleRefRow Item { get; }
    internal ModuleRefTableReader(UInt32 numberOfRows, int stringHeapRefSize, Byte* buffer);
    internal ModuleRefRow get_Item(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ModuleRow : ValueType {
    internal ushort Generation;
    internal UInt32 Name;
    internal UInt32 MVId;
    internal UInt32 EnCId;
    internal UInt32 EnCBaseId;
    internal ModuleRow(ushort generation, UInt32 name, UInt32 mvId, UInt32 encId, UInt32 encBaseId);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ModuleTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsGUIDHeapRefSizeSmall;
    internal UInt32 GenerationOffset;
    internal UInt32 NameOffset;
    internal UInt32 MVIdOffset;
    internal UInt32 EnCIdOffset;
    internal UInt32 EnCBaseIdOffset;
    internal UInt32 RowSize;
    internal MemoryReader ModuleTableMemoryReader;
    internal ModuleRow Item { get; }
    internal ModuleTableReader(UInt32 numberOfRows, int stringHeapRefSize, int guidHeapRefSize, Byte* buffer);
    internal ModuleRow get_Item(UInt32 rowId);
    internal UInt32 GetName(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.NestedClassRow : ValueType {
    internal UInt32 NestedClass;
    internal UInt32 EnclosingClass;
    internal NestedClassRow(UInt32 nestedClass, UInt32 enclosingClass);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.NestedClassTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefTableRowRefSizeSmall;
    internal int NestedClassOffset;
    internal int EnclosingClassOffset;
    internal int RowSize;
    internal MemoryReader NestedClassTableMemoryReader;
    internal NestedClassRow Item { get; }
    internal NestedClassTableReader(UInt32 numberOfRows, int typeDefTableRowRefSize, Byte* buffer);
    internal NestedClassRow get_Item(UInt32 rowId);
    internal UInt32 FindParentTypeDefRowId(UInt32 nestedTypeRowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.OptionalHeaderDirectoryEntries : ValueType {
    internal DirectoryEntry ExportTableDirectory;
    internal DirectoryEntry ImportTableDirectory;
    internal DirectoryEntry ResourceTableDirectory;
    internal DirectoryEntry ExceptionTableDirectory;
    internal DirectoryEntry CertificateTableDirectory;
    internal DirectoryEntry BaseRelocationTableDirectory;
    internal DirectoryEntry DebugTableDirectory;
    internal DirectoryEntry CopyrightTableDirectory;
    internal DirectoryEntry GlobalPointerTableDirectory;
    internal DirectoryEntry ThreadLocalStorageTableDirectory;
    internal DirectoryEntry LoadConfigTableDirectory;
    internal DirectoryEntry BoundImportTableDirectory;
    internal DirectoryEntry ImportAddressTableDirectory;
    internal DirectoryEntry DelayImportTableDirectory;
    internal DirectoryEntry COR20HeaderTableDirectory;
    internal DirectoryEntry ReservedDirectory;
}
internal class Microsoft.Cci.MetadataReader.PEFile.OptionalHeaderNTAdditionalFields : ValueType {
    internal ulong ImageBase;
    internal int SectionAlignment;
    internal UInt32 FileAlignment;
    internal ushort MajorOperatingSystemVersion;
    internal ushort MinorOperatingSystemVersion;
    internal ushort MajorImageVersion;
    internal ushort MinorImageVersion;
    internal ushort MajorSubsystemVersion;
    internal ushort MinorSubsystemVersion;
    internal UInt32 Win32VersionValue;
    internal int SizeOfImage;
    internal int SizeOfHeaders;
    internal UInt32 CheckSum;
    internal Subsystem Subsystem;
    internal DllCharacteristics DllCharacteristics;
    internal ulong SizeOfStackReserve;
    internal ulong SizeOfStackCommit;
    internal ulong SizeOfHeapReserve;
    internal ulong SizeOfHeapCommit;
    internal UInt32 LoaderFlags;
    internal int NumberOfRvaAndSizes;
}
internal class Microsoft.Cci.MetadataReader.PEFile.OptionalHeaderStandardFields : ValueType {
    internal PEMagic PEMagic;
    internal byte MajorLinkerVersion;
    internal byte MinorLinkerVersion;
    internal int SizeOfCode;
    internal int SizeOfInitializedData;
    internal int SizeOfUninitializedData;
    internal int RVAOfEntryPoint;
    internal int BaseOfCode;
    internal int BaseOfData;
}
internal class Microsoft.Cci.MetadataReader.PEFile.ParamPtrRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.ParamPtrTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsParamTableRowRefSizeSmall;
    internal int ParamOffset;
    internal int RowSize;
    internal MemoryReader ParamPtrTableMemoryReader;
    internal ParamPtrTableReader(UInt32 numberOfRows, int paramTableRowRefSize, Byte* buffer);
    internal UInt32 GetParamFor(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ParamRow : ValueType {
    internal ParamFlags Flags;
    internal ushort Sequence;
    internal UInt32 Name;
    internal ParamRow(ParamFlags flags, ushort sequence, UInt32 name);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.ParamTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int SequenceOffset;
    internal int NameOffset;
    internal int RowSize;
    internal MemoryReader ParamTableMemoryReader;
    internal ParamRow Item { get; }
    internal ParamTableReader(UInt32 numberOfRows, int stringHeapRefSize, Byte* buffer);
    internal ParamRow get_Item(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.PeDebugDirectory : object {
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public UInt32 Type;
    public UInt32 SizeOfData;
    public UInt32 AddressOfRawData;
    public UInt32 PointerToRawData;
}
internal static class Microsoft.Cci.MetadataReader.PEFile.PEFileConstants : object {
    internal static ushort DosSignature;
    internal static int PESignatureOffsetLocation;
    internal static UInt32 PESignature;
    internal static int BasicPEHeaderSize;
    internal static int SizeofCOFFFileHeader;
    internal static int SizeofOptionalHeaderStandardFields32;
    internal static int SizeofOptionalHeaderStandardFields64;
    internal static int SizeofOptionalHeaderNTAdditionalFields32;
    internal static int SizeofOptionalHeaderNTAdditionalFields64;
    internal static int NumberofOptionalHeaderDirectoryEntries;
    internal static int SizeofOptionalHeaderDirectoriesEntries;
    internal static int SizeofSectionHeader;
    internal static int SizeofSectionName;
    internal static int SizeofResourceDirectory;
    internal static int SizeofResourceDirectoryEntry;
}
internal class Microsoft.Cci.MetadataReader.PEFile.PEFileDebugInformation : object {
    [CompilerGeneratedAttribute]
private Guid <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Age>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbFileName>k__BackingField;
    public Guid Signature { get; public set; }
    public UInt32 Age { get; public set; }
    public string PdbVersion { get; public set; }
    public string PdbFileName { get; public set; }
    [CompilerGeneratedAttribute]
public Guid get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(Guid value);
    [CompilerGeneratedAttribute]
public UInt32 get_Age();
    [CompilerGeneratedAttribute]
public void set_Age(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_PdbVersion();
    [CompilerGeneratedAttribute]
public void set_PdbVersion(string value);
    [CompilerGeneratedAttribute]
public string get_PdbFileName();
    [CompilerGeneratedAttribute]
public void set_PdbFileName(string value);
}
internal class Microsoft.Cci.MetadataReader.PEFile.PEFileReader : object {
    internal ReaderState ReaderState;
    internal MetadataErrorContainer ErrorContainer;
    internal IBinaryDocumentMemoryBlock BinaryDocumentMemoryBlock;
    private COFFFileHeader COFFFileHeader;
    private OptionalHeaderStandardFields OptionalHeaderStandardFields;
    internal OptionalHeaderNTAdditionalFields OptionalHeaderNTAdditionalFields;
    private OptionalHeaderDirectoryEntries OptionalHeaderDirectoryEntries;
    internal SectionHeader[] SectionHeaders;
    internal MemoryReader Win32ResourceMemoryReader;
    private PEFileDebugInformation debugInformation;
    internal COR20Header COR20Header;
    internal MetadataHeader MetadataHeader;
    private StorageHeader StorageHeader;
    private StreamHeader[] StreamHeaders;
    internal StringStreamReader StringStream;
    internal BlobStreamReader BlobStream;
    internal GUIDStreamReader GUIDStream;
    internal UserStringStreamReader UserStringStream;
    internal MetadataStreamKind MetadataStreamKind;
    private MemoryBlock MetadataTableStream;
    internal MemoryReader ResourceMemoryReader;
    internal MemoryBlock StrongNameSignature;
    internal MetadataTableHeader MetadataTableHeader;
    private UInt32[] MetadataTableRowCount;
    internal ModuleTableReader ModuleTable;
    internal TypeRefTableReader TypeRefTable;
    internal TypeDefTableReader TypeDefTable;
    internal FieldPtrTableReader FieldPtrTable;
    internal FieldTableReader FieldTable;
    internal MethodPtrTableReader MethodPtrTable;
    internal MethodTableReader MethodTable;
    internal ParamPtrTableReader ParamPtrTable;
    internal ParamTableReader ParamTable;
    internal InterfaceImplTableReader InterfaceImplTable;
    internal MemberRefTableReader MemberRefTable;
    internal ConstantTableReader ConstantTable;
    internal CustomAttributeTableReader CustomAttributeTable;
    internal FieldMarshalTableReader FieldMarshalTable;
    internal DeclSecurityTableReader DeclSecurityTable;
    internal ClassLayoutTableReader ClassLayoutTable;
    internal FieldLayoutTableReader FieldLayoutTable;
    internal StandAloneSigTableReader StandAloneSigTable;
    internal EventMapTableReader EventMapTable;
    internal EventPtrTableReader EventPtrTable;
    internal EventTableReader EventTable;
    internal PropertyMapTableReader PropertyMapTable;
    internal PropertyPtrTableReader PropertyPtrTable;
    internal PropertyTableReader PropertyTable;
    internal MethodSemanticsTableReader MethodSemanticsTable;
    internal MethodImplTableReader MethodImplTable;
    internal ModuleRefTableReader ModuleRefTable;
    internal TypeSpecTableReader TypeSpecTable;
    internal ImplMapTableReader ImplMapTable;
    internal FieldRVATableReader FieldRVATable;
    internal EnCLogTableReader EnCLogTable;
    internal EnCMapTableReader EnCMapTable;
    internal AssemblyTableReader AssemblyTable;
    internal AssemblyProcessorTableReader AssemblyProcessorTable;
    internal AssemblyOSTableReader AssemblyOSTable;
    internal AssemblyRefTableReader AssemblyRefTable;
    internal AssemblyRefProcessorTableReader AssemblyRefProcessorTable;
    internal AssemblyRefOSTableReader AssemblyRefOSTable;
    internal FileTableReader FileTable;
    internal ExportedTypeTableReader ExportedTypeTable;
    internal ManifestResourceTableReader ManifestResourceTable;
    internal NestedClassTableReader NestedClassTable;
    internal GenericParamTableReader GenericParamTable;
    internal MethodSpecTableReader MethodSpecTable;
    internal GenericParamConstraintTableReader GenericParamConstraintTable;
    internal PEFileDebugInformation DebugInformation { get; }
    internal DllCharacteristics DllCharacteristics { get; }
    internal UInt32 FileAlignment { get; }
    internal ulong ImageBase { get; }
    internal bool IsDll { get; }
    internal bool IsExe { get; }
    internal bool IsConsoleApplication { get; }
    internal bool IsUnmanaged { get; }
    internal byte LinkerMajorVersion { get; }
    internal byte LinkerMinorVersion { get; }
    internal Machine Machine { get; }
    internal bool RequiresAmdInstructionSet { get; }
    internal bool RequiresStartupStub { get; }
    internal bool Requires64Bits { get; }
    internal ulong SizeOfHeapCommit { get; }
    internal ulong SizeOfHeapReserve { get; }
    internal ulong SizeOfStackCommit { get; }
    internal ulong SizeOfStackReserve { get; }
    private string MetadataStreamName { get; }
    internal Guid ModuleGuidIdentifier { get; }
    internal bool IsAssembly { get; }
    internal bool UseFieldPtrTable { get; }
    internal bool UseMethodPtrTable { get; }
    internal bool UseParamPtrTable { get; }
    internal bool UseEventPtrTable { get; }
    internal bool UsePropertyPtrTable { get; }
    internal PEFileReader(PeReader moduleReadWriteFactory, IBinaryDocumentMemoryBlock binaryDocumentMemoryBlock, bool snapshot);
    internal PEFileDebugInformation get_DebugInformation();
    internal DllCharacteristics get_DllCharacteristics();
    internal UInt32 get_FileAlignment();
    internal ulong get_ImageBase();
    internal bool get_IsDll();
    internal bool get_IsExe();
    internal bool get_IsConsoleApplication();
    internal bool get_IsUnmanaged();
    internal byte get_LinkerMajorVersion();
    internal byte get_LinkerMinorVersion();
    internal Machine get_Machine();
    internal bool get_RequiresAmdInstructionSet();
    internal bool get_RequiresStartupStub();
    internal bool get_Requires64Bits();
    internal ulong get_SizeOfHeapCommit();
    internal ulong get_SizeOfHeapReserve();
    internal ulong get_SizeOfStackCommit();
    internal ulong get_SizeOfStackReserve();
    private PEFileDebugInformation ReadDebugInformationLocationFromDebugTableDirectoryData();
    private bool ReadCOFFFileHeader(MemoryReader& memReader);
    private bool ReadOptionalHeaderStandardFields32(MemoryReader& memReader);
    private bool ReadOptionalHeaderNTAdditionalFields32(MemoryReader& memReader);
    private bool ReadOptionalHeaderStandardFields64(MemoryReader& memReader);
    private bool ReadOptionalHeaderNTAdditionalFields64(MemoryReader& memReader);
    private bool ReadOptionalHeaderDirectoryEntries(MemoryReader& memReader);
    private bool ReadSectionHeaders(MemoryReader& memReader);
    private bool ReadPEFileLevelData();
    internal ResourceDirectory GetResourceDirectoryAt(int offset);
    internal ResourceDirectoryEntry GetResourceDirectoryEntryAt(int offset);
    internal ResourceDataEntry GetResourceDataEntryAt(int offset);
    internal MemoryBlock DirectoryToMemoryBlock(DirectoryEntry directory);
    internal MemoryBlock RVAToMemoryBlockWithSize(int RVA, int size);
    internal MemoryBlock RVAToMemoryBlock(int RVA);
    internal bool RVAsInSameSection(int RVA1, int RVA2);
    internal SubSection RVAToSubSection(int RVA, int size);
    internal string RVAToSubSectionName(int RVA);
    internal int GetSizeOfRemainderOfSectionContaining(int RVA);
    private string get_MetadataStreamName();
    private bool ReadCOR20Header();
    private bool ReadMetadataHeader(MemoryReader& memReader);
    private bool ReadStorageHeader(MemoryReader& memReader);
    private bool ReadStreamHeaders(MemoryReader& memReader);
    private bool ProcessAndCacheStreams(MemoryBlock& metadataRoot);
    private bool ReadCORModuleLevelData();
    private bool ReadMetadataRoot();
    internal Guid get_ModuleGuidIdentifier();
    internal bool get_IsAssembly();
    internal bool get_UseFieldPtrTable();
    internal bool get_UseMethodPtrTable();
    internal bool get_UseParamPtrTable();
    internal bool get_UseEventPtrTable();
    internal bool get_UsePropertyPtrTable();
    private bool ReadMetadataTableInformation(MemoryReader& memReader);
    private static int ComputeCodedTokenSize(UInt32 largeRowSize, UInt32[] rowCountArray, TableMask tablesReferenced);
    private bool ProcessAndCacheMetadataTableBlocks(MemoryBlock metadataTablesMemoryBlock);
    private bool ReadMetadataLevelData();
    internal UInt32 GetFieldInformation(UInt32 typeDefRowId, UInt32& fieldCount);
    internal UInt32 GetMethodInformation(UInt32 typeDefRowId, UInt32& methodCount);
    internal UInt32 GetEventInformation(UInt32 typeDefRowId, UInt32& eventCount);
    internal UInt32 GetPropertyInformation(UInt32 typeDefRowId, UInt32& propertyCount);
    internal UInt32 GetParamInformation(UInt32 methodDefRowId, UInt32& paramRowCount);
    internal static SEHTableEntry[] GetSmallSEHEntries(MemoryReader memReader, int numEntries);
    internal static SEHTableEntry[] GetFatSEHEntries(MemoryReader memReader, int numEntries);
    internal bool IsMethodILNull(UInt32 methodDefRowId);
    internal MethodIL GetMethodIL(UInt32 methodDefRowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.PropertyMapRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.PropertyMapTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsTypeDefTableRowRefSizeSmall;
    internal bool IsPropertyRefSizeSmall;
    internal int ParentOffset;
    internal int PropertyListOffset;
    internal int RowSize;
    internal MemoryReader PropertyMapTableMemoryReader;
    internal PropertyMapTableReader(UInt32 numberOfRows, int typeDefTableRowRefSize, int propertyRefSize, Byte* buffer);
    internal UInt32 FindPropertyMapRowIdFor(UInt32 typeDefRowId);
    internal UInt32 GetPropertyListStartFor(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.PropertyPtrRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.PropertyPtrTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsPropertyTableRowRefSizeSmall;
    internal int PropertyOffset;
    internal int RowSize;
    internal MemoryReader PropertyPtrTableMemoryReader;
    internal PropertyPtrTableReader(UInt32 numberOfRows, int propertyTableRowRefSize, Byte* buffer);
    internal UInt32 GetPropertyFor(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.PropertyRow : ValueType {
    internal PropertyFlags Flags;
    internal UInt32 Name;
    internal UInt32 Signature;
    internal PropertyRow(PropertyFlags flags, UInt32 name, UInt32 signature);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.PropertyTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsStringHeapRefSizeSmall;
    internal bool IsBlobHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int SignatureOffset;
    internal int RowSize;
    internal MemoryReader PropertyTableMemoryReader;
    internal PropertyRow Item { get; }
    internal PropertyTableReader(UInt32 numberOfRows, int stringHeapRefSize, int blobHeapRefSize, Byte* buffer);
    internal PropertyRow get_Item(UInt32 rowId);
    internal UInt32 GetSignature(UInt32 rowId);
}
internal enum Microsoft.Cci.MetadataReader.PEFile.ReaderState : Enum {
    public int value__;
    public static ReaderState Initialized;
    public static ReaderState PEFile;
    public static ReaderState CORModule;
    public static ReaderState Metadata;
}
internal static class Microsoft.Cci.MetadataReader.PEFile.ResolutionScopeTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 Module;
    internal static UInt32 ModuleRef;
    internal static UInt32 AssemblyRef;
    internal static UInt32 TypeRef;
    internal static UInt32 TagMask;
    internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static ResolutionScopeTag();
    internal static UInt32 ConvertToToken(UInt32 resolutionScope);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ResourceDataEntry : ValueType {
    internal int RVAToData;
    internal int Size;
    internal int CodePage;
    internal int Reserved;
    internal ResourceDataEntry(int rvaToData, int size, int codePage, int reserved);
}
internal class Microsoft.Cci.MetadataReader.PEFile.ResourceDirectory : ValueType {
    internal UInt32 Charecteristics;
    internal UInt32 TimeDateStamp;
    internal short MajorVersion;
    internal short MinorVersion;
    internal short NumberOfNamedEntries;
    internal short NumberOfIdEntries;
}
internal class Microsoft.Cci.MetadataReader.PEFile.ResourceDirectoryEntry : ValueType {
    internal int NameOrId;
    private int DataOffset;
    internal bool IsDirectory { get; }
    internal int OffsetToDirectory { get; }
    internal int OffsetToData { get; }
    internal ResourceDirectoryEntry(int nameOrId, int dataOffset);
    internal bool get_IsDirectory();
    internal int get_OffsetToDirectory();
    internal int get_OffsetToData();
}
internal class Microsoft.Cci.MetadataReader.PEFile.SectionHeader : ValueType {
    internal string Name;
    internal int VirtualSize;
    internal int VirtualAddress;
    internal int SizeOfRawData;
    internal int OffsetToRawData;
    internal int RVAToRelocations;
    internal int PointerToLineNumbers;
    internal ushort NumberOfRelocations;
    internal ushort NumberOfLineNumbers;
    internal SectionCharacteristics SectionCharacteristics;
}
internal enum Microsoft.Cci.MetadataReader.PEFile.SEHFlags : Enum {
    public UInt32 value__;
    public static SEHFlags Catch;
    public static SEHFlags Filter;
    public static SEHFlags Finally;
    public static SEHFlags Fault;
}
internal class Microsoft.Cci.MetadataReader.PEFile.SEHTableEntry : ValueType {
    internal SEHFlags SEHFlags;
    internal UInt32 TryOffset;
    internal UInt32 TryLength;
    internal UInt32 HandlerOffset;
    internal UInt32 HandlerLength;
    internal UInt32 ClassTokenOrFilterOffset;
    internal SEHTableEntry(SEHFlags sehFlags, UInt32 tryOffset, UInt32 tryLength, UInt32 handlerOffset, UInt32 handlerLength, UInt32 classTokenOrFilterOffset);
}
internal class Microsoft.Cci.MetadataReader.PEFile.StandAloneSigRow : ValueType {
    internal UInt32 Signature;
    internal StandAloneSigRow(UInt32 signature);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.StandAloneSigTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsBlobHeapRefSizeSmall;
    internal int SignatureOffset;
    internal int RowSize;
    internal MemoryReader StandAloneSigTableMemoryReader;
    internal StandAloneSigRow Item { get; }
    internal StandAloneSigTableReader(UInt32 numberOfRows, int blobHeapRefSize, Byte* buffer);
    internal StandAloneSigRow get_Item(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.StorageHeader : ValueType {
    internal ushort Flags;
    internal short NumberOfStreams;
}
internal class Microsoft.Cci.MetadataReader.PEFile.StreamHeader : ValueType {
    internal UInt32 Offset;
    internal int Size;
    internal string Name;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.StringStreamReader : ValueType {
    internal MemoryReader MemoryReader;
    internal string Item { get; }
    internal string get_Item(UInt32 offset);
}
internal class Microsoft.Cci.MetadataReader.PEFile.SubSection : ValueType {
    internal string SectionName;
    internal UInt32 Offset;
    internal MemoryBlock MemoryBlock;
    internal SubSection(string sectionName, UInt32 offset, MemoryBlock memoryBlock);
    internal SubSection(string sectionName, int offset, MemoryBlock memoryBlock);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.TypeDefOrRefTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 TagMask;
    internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static TypeDefOrRefTag();
    internal static UInt32 ConvertToToken(UInt32 typeDefOrRefTag);
}
internal class Microsoft.Cci.MetadataReader.PEFile.TypeDefRow : ValueType {
    internal TypeDefFlags Flags;
    internal UInt32 Name;
    internal UInt32 Namespace;
    internal UInt32 Extends;
    internal UInt32 FieldList;
    internal UInt32 MethodList;
    internal bool IsNested { get; }
    internal TypeDefRow(TypeDefFlags flags, UInt32 name, UInt32 namespace, UInt32 extends, UInt32 fieldList, UInt32 methodList);
    internal bool get_IsNested();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.TypeDefTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsFieldRefSizeSmall;
    internal bool IsMethodRefSizeSmall;
    internal bool IsTypeDefOrRefRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int FlagsOffset;
    internal int NameOffset;
    internal int NamespaceOffset;
    internal int ExtendsOffset;
    internal int FieldListOffset;
    internal int MethodListOffset;
    internal int RowSize;
    internal MemoryReader TypeDefTableMemoryReader;
    internal TypeDefRow Item { get; }
    internal TypeDefTableReader(UInt32 numberOfRows, int fieldRefSize, int methodRefSize, int typeDefOrRefRefSize, int stringHeapRefSize, Byte* buffer);
    internal TypeDefRow get_Item(UInt32 rowId);
    internal UInt32 GetNamespace(UInt32 rowId);
    internal UInt32 GetName(UInt32 rowId);
    internal UInt32 GetExtends(UInt32 rowId);
    internal UInt32 GetFieldStart(UInt32 rowId);
    internal UInt32 GetMethodStart(UInt32 rowId);
    internal UInt32 FindTypeContainingMethod(UInt32 methodDefOrPtrRowId, int numberOfMethods);
    internal UInt32 FindTypeContainingField(UInt32 fieldDefOrPtrRowId, int numberOfFields);
}
internal static class Microsoft.Cci.MetadataReader.PEFile.TypeOrMethodDefTag : object {
    internal static int NumberOfBits;
    internal static UInt32 LargeRowSize;
    internal static UInt32 TypeDef;
    internal static UInt32 MethodDef;
    internal static UInt32 TagMask;
    internal static UInt32[] TagToTokenTypeArray;
    internal static TableMask TablesReferenced;
    private static TypeOrMethodDefTag();
    internal static UInt32 ConvertToToken(UInt32 typeOrMethodDef);
    internal static UInt32 ConvertTypeDefRowIdToTag(UInt32 typeDefRowId);
    internal static UInt32 ConvertMethodDefRowIdToTag(UInt32 methodDefRowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.TypeRefRow : ValueType {
    internal UInt32 ResolutionScope;
    internal UInt32 Name;
    internal UInt32 Namespace;
    internal TypeRefRow(UInt32 resolutionScope, UInt32 name, UInt32 namespace);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.TypeRefTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsResolutionScopeRefSizeSmall;
    internal bool IsStringHeapRefSizeSmall;
    internal int ResolutionScopeOffset;
    internal int NameOffset;
    internal int NamespaceOffset;
    internal int RowSize;
    internal MemoryReader TypeRefTableMemoryReader;
    internal TypeRefRow Item { get; }
    internal TypeRefTableReader(UInt32 numberOfRows, int resolutionScopeRefSize, int stringHeapRefSize, Byte* buffer);
    internal TypeRefRow get_Item(UInt32 rowId);
}
internal class Microsoft.Cci.MetadataReader.PEFile.TypeSpecRow : ValueType {
}
internal class Microsoft.Cci.MetadataReader.PEFile.TypeSpecTableReader : ValueType {
    internal UInt32 NumberOfRows;
    internal bool IsBlobHeapRefSizeSmall;
    internal int SignatureOffset;
    internal int RowSize;
    internal MemoryReader TypeSpecTableMemoryReader;
    internal TypeSpecTableReader(UInt32 numberOfRows, int blobHeapRefSize, Byte* buffer);
    internal UInt32 GetSignature(UInt32 rowId);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.MetadataReader.PEFile.UserStringStreamReader : ValueType {
    internal MemoryReader MemoryReader;
    internal string Item { get; }
    internal string get_Item(UInt32 offset);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFile.UserStringStreamReader/<GetStrings>d__3")]
internal IEnumerable`1<string> GetStrings();
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.AssemblyFlags : Enum {
    public UInt32 value__;
    public static AssemblyFlags PublicKey;
    public static AssemblyFlags Retargetable;
    public static AssemblyFlags ContainsForeignTypes;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.AssemblyHashAlgorithmFlags : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithmFlags None;
    public static AssemblyHashAlgorithmFlags MD5;
    public static AssemblyHashAlgorithmFlags SHA1;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.Characteristics : Enum {
    public ushort value__;
    public static Characteristics RelocsStripped;
    public static Characteristics ExecutableImage;
    public static Characteristics LineNumsStripped;
    public static Characteristics LocalSymsStripped;
    public static Characteristics AggressiveWsTrim;
    public static Characteristics LargeAddressAware;
    public static Characteristics BytesReversedLo;
    public static Characteristics Bit32Machine;
    public static Characteristics DebugStripped;
    public static Characteristics RemovableRunFromSwap;
    public static Characteristics NetRunFromSwap;
    public static Characteristics System;
    public static Characteristics Dll;
    public static Characteristics UpSystemOnly;
    public static Characteristics BytesReversedHi;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.COR20Flags : Enum {
    public UInt32 value__;
    public static COR20Flags ILOnly;
    public static COR20Flags Bit32Required;
    public static COR20Flags ILLibrary;
    public static COR20Flags StrongNameSigned;
    public static COR20Flags Prefers32bits;
    public static COR20Flags TrackDebugData;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.DeclSecurityActionFlags : Enum {
    public ushort value__;
    public static DeclSecurityActionFlags ActionNil;
    public static DeclSecurityActionFlags Request;
    public static DeclSecurityActionFlags Demand;
    public static DeclSecurityActionFlags Assert;
    public static DeclSecurityActionFlags Deny;
    public static DeclSecurityActionFlags PermitOnly;
    public static DeclSecurityActionFlags LinktimeCheck;
    public static DeclSecurityActionFlags InheritanceCheck;
    public static DeclSecurityActionFlags RequestMinimum;
    public static DeclSecurityActionFlags RequestOptional;
    public static DeclSecurityActionFlags RequestRefuse;
    public static DeclSecurityActionFlags PrejitGrant;
    public static DeclSecurityActionFlags PrejitDenied;
    public static DeclSecurityActionFlags NonCasDemand;
    public static DeclSecurityActionFlags NonCasLinkDemand;
    public static DeclSecurityActionFlags NonCasInheritance;
    public static DeclSecurityActionFlags MaximumValue;
    public static DeclSecurityActionFlags ActionMask;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.Directories : Enum {
    public ushort value__;
    public static Directories Export;
    public static Directories Import;
    public static Directories Resource;
    public static Directories Exception;
    public static Directories Certificate;
    public static Directories BaseRelocation;
    public static Directories Debug;
    public static Directories Copyright;
    public static Directories GlobalPointer;
    public static Directories ThreadLocalStorage;
    public static Directories LoadConfig;
    public static Directories BoundImport;
    public static Directories ImportAddress;
    public static Directories DelayImport;
    public static Directories COR20Header;
    public static Directories Reserved;
    public static Directories Cor20HeaderMetaData;
    public static Directories Cor20HeaderResources;
    public static Directories Cor20HeaderStrongNameSignature;
    public static Directories Cor20HeaderCodeManagerTable;
    public static Directories Cor20HeaderVtableFixups;
    public static Directories Cor20HeaderExportAddressTableJumps;
    public static Directories Cor20HeaderManagedNativeHeader;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.DllCharacteristics : Enum {
    public ushort value__;
    public static DllCharacteristics ProcessInit;
    public static DllCharacteristics ProcessTerm;
    public static DllCharacteristics ThreadInit;
    public static DllCharacteristics ThreadTerm;
    public static DllCharacteristics DynamicBase;
    public static DllCharacteristics NxCompatible;
    public static DllCharacteristics NoIsolation;
    public static DllCharacteristics NoSEH;
    public static DllCharacteristics NoBind;
    public static DllCharacteristics AppContainer;
    public static DllCharacteristics WDM_Driver;
    public static DllCharacteristics TerminalServerAware;
}
internal static class Microsoft.Cci.MetadataReader.PEFileFlags.ElementType : object {
    internal static byte End;
    internal static byte Void;
    internal static byte Boolean;
    internal static byte Char;
    internal static byte Int8;
    internal static byte UInt8;
    internal static byte Int16;
    internal static byte UInt16;
    internal static byte Int32;
    internal static byte UInt32;
    internal static byte Int64;
    internal static byte UInt64;
    internal static byte Single;
    internal static byte Double;
    internal static byte String;
    internal static byte Pointer;
    internal static byte ByReference;
    internal static byte ValueType;
    internal static byte Class;
    internal static byte GenericTypeParameter;
    internal static byte Array;
    internal static byte GenericTypeInstance;
    internal static byte TypedReference;
    internal static byte IntPtr;
    internal static byte UIntPtr;
    internal static byte FunctionPointer;
    internal static byte Object;
    internal static byte SzArray;
    internal static byte GenericMethodParameter;
    internal static byte RequiredModifier;
    internal static byte OptionalModifier;
    internal static byte Internal;
    internal static byte Max;
    internal static byte Modifier;
    internal static byte Sentinel;
    internal static byte Pinned;
    internal static byte SingleHFA;
    internal static byte DoubleHFA;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.EventFlags : Enum {
    public ushort value__;
    public static EventFlags SpecialNameImpl;
    public static EventFlags RTSpecialNameReserved;
    public static EventFlags AdderLoaded;
    public static EventFlags RemoverLoaded;
    public static EventFlags FireLoaded;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.FieldFlags : Enum {
    public ushort value__;
    public static FieldFlags CompilerControlledAccess;
    public static FieldFlags PrivateAccess;
    public static FieldFlags FamilyAndAssemblyAccess;
    public static FieldFlags AssemblyAccess;
    public static FieldFlags FamilyAccess;
    public static FieldFlags FamilyOrAssemblyAccess;
    public static FieldFlags PublicAccess;
    public static FieldFlags AccessMask;
    public static FieldFlags StaticContract;
    public static FieldFlags InitOnlyContract;
    public static FieldFlags LiteralContract;
    public static FieldFlags NotSerializedContract;
    public static FieldFlags SpecialNameImpl;
    public static FieldFlags PInvokeImpl;
    public static FieldFlags RTSpecialNameReserved;
    public static FieldFlags HasFieldMarshalReserved;
    public static FieldFlags HasDefaultReserved;
    public static FieldFlags HasFieldRVAReserved;
    public static FieldFlags FieldLoaded;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.FileFlags : Enum {
    public UInt32 value__;
    public static FileFlags ContainsMetadata;
    public static FileFlags ContainsNoMetadata;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.GenericParamFlags : Enum {
    public ushort value__;
    public static GenericParamFlags NonVariant;
    public static GenericParamFlags Covariant;
    public static GenericParamFlags Contravariant;
    public static GenericParamFlags VarianceMask;
    public static GenericParamFlags ReferenceTypeConstraint;
    public static GenericParamFlags ValueTypeConstraint;
    public static GenericParamFlags DefaultConstructorConstraint;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.HeapSizeFlag : Enum {
    public byte value__;
    public static HeapSizeFlag StringHeapLarge;
    public static HeapSizeFlag GUIDHeapLarge;
    public static HeapSizeFlag BlobHeapLarge;
    public static HeapSizeFlag EnCDeltas;
    public static HeapSizeFlag DeletedMarks;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.ManifestResourceFlags : Enum {
    public UInt32 value__;
    public static ManifestResourceFlags PublicVisibility;
    public static ManifestResourceFlags PrivateVisibility;
    public static ManifestResourceFlags VisibilityMask;
    public static ManifestResourceFlags InExternalFile;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.MetadataStreamKind : Enum {
    public int value__;
    public static MetadataStreamKind Illegal;
    public static MetadataStreamKind Compressed;
    public static MetadataStreamKind UnCompressed;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.MethodFlags : Enum {
    public ushort value__;
    public static MethodFlags CompilerControlledAccess;
    public static MethodFlags PrivateAccess;
    public static MethodFlags FamilyAndAssemblyAccess;
    public static MethodFlags AssemblyAccess;
    public static MethodFlags FamilyAccess;
    public static MethodFlags FamilyOrAssemblyAccess;
    public static MethodFlags PublicAccess;
    public static MethodFlags AccessMask;
    public static MethodFlags StaticContract;
    public static MethodFlags FinalContract;
    public static MethodFlags VirtualContract;
    public static MethodFlags HideBySignatureContract;
    public static MethodFlags ReuseSlotVTable;
    public static MethodFlags NewSlotVTable;
    public static MethodFlags CheckAccessOnOverrideImpl;
    public static MethodFlags AbstractImpl;
    public static MethodFlags SpecialNameImpl;
    public static MethodFlags PInvokeInterop;
    public static MethodFlags UnmanagedExportInterop;
    public static MethodFlags RTSpecialNameReserved;
    public static MethodFlags HasSecurityReserved;
    public static MethodFlags RequiresSecurityObjectReserved;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.MethodImplFlags : Enum {
    public ushort value__;
    public static MethodImplFlags ILCodeType;
    public static MethodImplFlags NativeCodeType;
    public static MethodImplFlags OPTILCodeType;
    public static MethodImplFlags RuntimeCodeType;
    public static MethodImplFlags CodeTypeMask;
    public static MethodImplFlags Unmanaged;
    public static MethodImplFlags NoInlining;
    public static MethodImplFlags ForwardRefInterop;
    public static MethodImplFlags Synchronized;
    public static MethodImplFlags NoOptimization;
    public static MethodImplFlags PreserveSigInterop;
    public static MethodImplFlags AggressiveInlining;
    public static MethodImplFlags InternalCall;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.MethodSemanticsFlags : Enum {
    public ushort value__;
    public static MethodSemanticsFlags Setter;
    public static MethodSemanticsFlags Getter;
    public static MethodSemanticsFlags Other;
    public static MethodSemanticsFlags AddOn;
    public static MethodSemanticsFlags RemoveOn;
    public static MethodSemanticsFlags Fire;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.ParamFlags : Enum {
    public ushort value__;
    public static ParamFlags InSemantics;
    public static ParamFlags OutSemantics;
    public static ParamFlags OptionalSemantics;
    public static ParamFlags HasDefaultReserved;
    public static ParamFlags HasFieldMarshalReserved;
    public static ParamFlags ByReference;
    public static ParamFlags ParamArray;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.PEMagic : Enum {
    public ushort value__;
    public static PEMagic PEMagic32;
    public static PEMagic PEMagic64;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.PInvokeMapFlags : Enum {
    public ushort value__;
    public static PInvokeMapFlags NoMangle;
    public static PInvokeMapFlags DisabledBestFit;
    public static PInvokeMapFlags EnabledBestFit;
    public static PInvokeMapFlags UseAssemblyBestFit;
    public static PInvokeMapFlags BestFitMask;
    public static PInvokeMapFlags CharSetNotSpec;
    public static PInvokeMapFlags CharSetAnsi;
    public static PInvokeMapFlags CharSetUnicode;
    public static PInvokeMapFlags CharSetAuto;
    public static PInvokeMapFlags CharSetMask;
    public static PInvokeMapFlags EnabledThrowOnUnmappableChar;
    public static PInvokeMapFlags DisabledThrowOnUnmappableChar;
    public static PInvokeMapFlags UseAssemblyThrowOnUnmappableChar;
    public static PInvokeMapFlags ThrowOnUnmappableCharMask;
    public static PInvokeMapFlags SupportsLastError;
    public static PInvokeMapFlags WinAPICallingConvention;
    public static PInvokeMapFlags CDeclCallingConvention;
    public static PInvokeMapFlags StdCallCallingConvention;
    public static PInvokeMapFlags ThisCallCallingConvention;
    public static PInvokeMapFlags FastCallCallingConvention;
    public static PInvokeMapFlags CallingConventionMask;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.PropertyFlags : Enum {
    public ushort value__;
    public static PropertyFlags SpecialNameImpl;
    public static PropertyFlags RTSpecialNameReserved;
    public static PropertyFlags HasDefaultReserved;
    public static PropertyFlags HasThis;
    public static PropertyFlags ReturnValueIsByReference;
    public static PropertyFlags GetterLoaded;
    public static PropertyFlags SetterLoaded;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.SectionCharacteristics : Enum {
    public UInt32 value__;
    public static SectionCharacteristics TypeReg;
    public static SectionCharacteristics TypeDSect;
    public static SectionCharacteristics TypeNoLoad;
    public static SectionCharacteristics TypeGroup;
    public static SectionCharacteristics TypeNoPad;
    public static SectionCharacteristics TypeCopy;
    public static SectionCharacteristics CNTCode;
    public static SectionCharacteristics CNTInitializedData;
    public static SectionCharacteristics CNTUninitializedData;
    public static SectionCharacteristics LNKOther;
    public static SectionCharacteristics LNKInfo;
    public static SectionCharacteristics TypeOver;
    public static SectionCharacteristics LNKRemove;
    public static SectionCharacteristics LNKCOMDAT;
    public static SectionCharacteristics MemProtected;
    public static SectionCharacteristics No_Defer_Spec_Exc;
    public static SectionCharacteristics GPRel;
    public static SectionCharacteristics MemFardata;
    public static SectionCharacteristics MemSysheap;
    public static SectionCharacteristics MemPurgeable;
    public static SectionCharacteristics Mem16Bit;
    public static SectionCharacteristics MemLocked;
    public static SectionCharacteristics MemPreload;
    public static SectionCharacteristics Align1Bytes;
    public static SectionCharacteristics Align2Bytes;
    public static SectionCharacteristics Align4Bytes;
    public static SectionCharacteristics Align8Bytes;
    public static SectionCharacteristics Align16Bytes;
    public static SectionCharacteristics Align32Bytes;
    public static SectionCharacteristics Align64Bytes;
    public static SectionCharacteristics Align128Bytes;
    public static SectionCharacteristics Align256Bytes;
    public static SectionCharacteristics Align512Bytes;
    public static SectionCharacteristics Align1024Bytes;
    public static SectionCharacteristics Align2048Bytes;
    public static SectionCharacteristics Align4096Bytes;
    public static SectionCharacteristics Align8192Bytes;
    public static SectionCharacteristics AlignMask;
    public static SectionCharacteristics LNKNRelocOvfl;
    public static SectionCharacteristics MemDiscardable;
    public static SectionCharacteristics MemNotCached;
    public static SectionCharacteristics MemNotPaged;
    public static SectionCharacteristics MemShared;
    public static SectionCharacteristics MemExecute;
    public static SectionCharacteristics MemRead;
    public static SectionCharacteristics MemWrite;
}
internal static class Microsoft.Cci.MetadataReader.PEFileFlags.SerializationType : object {
    internal static ushort CustomAttributeStart;
    internal static byte SecurityAttribute20Start;
    internal static byte Undefined;
    internal static byte Boolean;
    internal static byte Char;
    internal static byte Int8;
    internal static byte UInt8;
    internal static byte Int16;
    internal static byte UInt16;
    internal static byte Int32;
    internal static byte UInt32;
    internal static byte Int64;
    internal static byte UInt64;
    internal static byte Single;
    internal static byte Double;
    internal static byte String;
    internal static byte SZArray;
    internal static byte Type;
    internal static byte TaggedObject;
    internal static byte Field;
    internal static byte Property;
    internal static byte Enum;
}
internal static class Microsoft.Cci.MetadataReader.PEFileFlags.SignatureHeader : object {
    internal static byte DefaultCall;
    internal static byte CCall;
    internal static byte StdCall;
    internal static byte ThisCall;
    internal static byte FastCall;
    internal static byte VarArgCall;
    internal static byte Field;
    internal static byte LocalVar;
    internal static byte Property;
    internal static byte GenericInstance;
    internal static byte Max;
    internal static byte CallingConventionMask;
    internal static byte HasThis;
    internal static byte ExplicitThis;
    internal static byte Generic;
    internal static bool IsMethodSignature(byte signatureHeader);
    internal static bool IsVarArgCallSignature(byte signatureHeader);
    internal static bool IsFieldSignature(byte signatureHeader);
    internal static bool IsLocalVarSignature(byte signatureHeader);
    internal static bool IsPropertySignature(byte signatureHeader);
    internal static bool IsGenericInstanceSignature(byte signatureHeader);
    internal static bool IsExplicitThis(byte signatureHeader);
    internal static bool IsGeneric(byte signatureHeader);
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.Subsystem : Enum {
    public ushort value__;
    public static Subsystem Unknown;
    public static Subsystem Native;
    public static Subsystem WindowsGUI;
    public static Subsystem WindowsCUI;
    public static Subsystem OS2CUI;
    public static Subsystem POSIXCUI;
    public static Subsystem NativeWindows;
    public static Subsystem WindowsCEGUI;
    public static Subsystem EFIApplication;
    public static Subsystem EFIBootServiceDriver;
    public static Subsystem EFIRuntimeDriver;
    public static Subsystem EFIROM;
    public static Subsystem XBOX;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.TableIndices : Enum {
    public byte value__;
    public static TableIndices Module;
    public static TableIndices TypeRef;
    public static TableIndices TypeDef;
    public static TableIndices FieldPtr;
    public static TableIndices Field;
    public static TableIndices MethodPtr;
    public static TableIndices Method;
    public static TableIndices ParamPtr;
    public static TableIndices Param;
    public static TableIndices InterfaceImpl;
    public static TableIndices MemberRef;
    public static TableIndices Constant;
    public static TableIndices CustomAttribute;
    public static TableIndices FieldMarshal;
    public static TableIndices DeclSecurity;
    public static TableIndices ClassLayout;
    public static TableIndices FieldLayout;
    public static TableIndices StandAloneSig;
    public static TableIndices EventMap;
    public static TableIndices EventPtr;
    public static TableIndices Event;
    public static TableIndices PropertyMap;
    public static TableIndices PropertyPtr;
    public static TableIndices Property;
    public static TableIndices MethodSemantics;
    public static TableIndices MethodImpl;
    public static TableIndices ModuleRef;
    public static TableIndices TypeSpec;
    public static TableIndices ImplMap;
    public static TableIndices FieldRva;
    public static TableIndices EnCLog;
    public static TableIndices EnCMap;
    public static TableIndices Assembly;
    public static TableIndices AssemblyProcessor;
    public static TableIndices AssemblyOS;
    public static TableIndices AssemblyRef;
    public static TableIndices AssemblyRefProcessor;
    public static TableIndices AssemblyRefOS;
    public static TableIndices File;
    public static TableIndices ExportedType;
    public static TableIndices ManifestResource;
    public static TableIndices NestedClass;
    public static TableIndices GenericParam;
    public static TableIndices MethodSpec;
    public static TableIndices GenericParamConstraint;
    public static TableIndices Count;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.TableMask : Enum {
    public ulong value__;
    public static TableMask Module;
    public static TableMask TypeRef;
    public static TableMask TypeDef;
    public static TableMask FieldPtr;
    public static TableMask Field;
    public static TableMask MethodPtr;
    public static TableMask Method;
    public static TableMask ParamPtr;
    public static TableMask Param;
    public static TableMask InterfaceImpl;
    public static TableMask MemberRef;
    public static TableMask Constant;
    public static TableMask CustomAttribute;
    public static TableMask FieldMarshal;
    public static TableMask DeclSecurity;
    public static TableMask ClassLayout;
    public static TableMask FieldLayout;
    public static TableMask StandAloneSig;
    public static TableMask EventMap;
    public static TableMask EventPtr;
    public static TableMask Event;
    public static TableMask PropertyMap;
    public static TableMask PropertyPtr;
    public static TableMask Property;
    public static TableMask MethodSemantics;
    public static TableMask MethodImpl;
    public static TableMask ModuleRef;
    public static TableMask TypeSpec;
    public static TableMask ImplMap;
    public static TableMask FieldRva;
    public static TableMask EnCLog;
    public static TableMask EnCMap;
    public static TableMask Assembly;
    public static TableMask AssemblyProcessor;
    public static TableMask AssemblyOS;
    public static TableMask AssemblyRef;
    public static TableMask AssemblyRefProcessor;
    public static TableMask AssemblyRefOS;
    public static TableMask File;
    public static TableMask ExportedType;
    public static TableMask ManifestResource;
    public static TableMask NestedClass;
    public static TableMask GenericParam;
    public static TableMask MethodSpec;
    public static TableMask GenericParamConstraint;
    public static TableMask SortedTablesMask;
    public static TableMask CompressedStreamNotAllowedMask;
    public static TableMask V1_0_TablesMask;
    public static TableMask V1_1_TablesMask;
    public static TableMask V2_0_TablesMask;
}
internal static class Microsoft.Cci.MetadataReader.PEFileFlags.TokenTypeIds : object {
    internal static UInt32 Module;
    internal static UInt32 TypeRef;
    internal static UInt32 TypeDef;
    internal static UInt32 FieldDef;
    internal static UInt32 MethodDef;
    internal static UInt32 ParamDef;
    internal static UInt32 InterfaceImpl;
    internal static UInt32 MemberRef;
    internal static UInt32 CustomAttribute;
    internal static UInt32 Permission;
    internal static UInt32 Signature;
    internal static UInt32 Event;
    internal static UInt32 Property;
    internal static UInt32 ModuleRef;
    internal static UInt32 TypeSpec;
    internal static UInt32 Assembly;
    internal static UInt32 AssemblyRef;
    internal static UInt32 File;
    internal static UInt32 ExportedType;
    internal static UInt32 ManifestResource;
    internal static UInt32 GenericParam;
    internal static UInt32 MethodSpec;
    internal static UInt32 GenericParamConstraint;
    internal static UInt32 String;
    internal static UInt32 Name;
    internal static UInt32 BaseType;
    internal static UInt32 RIDMask;
    internal static UInt32 TokenTypeMask;
}
internal enum Microsoft.Cci.MetadataReader.PEFileFlags.TypeDefFlags : Enum {
    public UInt32 value__;
    public static TypeDefFlags PrivateAccess;
    public static TypeDefFlags PublicAccess;
    public static TypeDefFlags NestedPublicAccess;
    public static TypeDefFlags NestedPrivateAccess;
    public static TypeDefFlags NestedFamilyAccess;
    public static TypeDefFlags NestedAssemblyAccess;
    public static TypeDefFlags NestedFamilyAndAssemblyAccess;
    public static TypeDefFlags NestedFamilyOrAssemblyAccess;
    public static TypeDefFlags AccessMask;
    public static TypeDefFlags NestedMask;
    public static TypeDefFlags AutoLayout;
    public static TypeDefFlags SeqentialLayout;
    public static TypeDefFlags ExplicitLayout;
    public static TypeDefFlags LayoutMask;
    public static TypeDefFlags ClassSemantics;
    public static TypeDefFlags InterfaceSemantics;
    public static TypeDefFlags AbstractSemantics;
    public static TypeDefFlags SealedSemantics;
    public static TypeDefFlags SpecialNameSemantics;
    public static TypeDefFlags RTSpecialNameReserved;
    public static TypeDefFlags ImportImplementation;
    public static TypeDefFlags SerializableImplementation;
    public static TypeDefFlags IsForeign;
    public static TypeDefFlags AnsiString;
    public static TypeDefFlags UnicodeString;
    public static TypeDefFlags AutoCharString;
    public static TypeDefFlags StringMask;
    public static TypeDefFlags HasSecurityReserved;
    public static TypeDefFlags BeforeFieldInitImplementation;
    public static TypeDefFlags ForwarderImplementation;
    public static TypeDefFlags DoesNotInheritTypeParameters;
}
internal class Microsoft.Cci.MetadataReader.PEFileToObjectModel : object {
    internal PeReader ModuleReader;
    internal Assembly ContainingAssembly;
    internal IInternFactory InternFactory;
    internal PEFileReader PEFileReader;
    internal INameTable NameTable;
    internal TypeCache typeCache;
    internal byte pointerSize;
    internal MetadataObjectDocument document;
    internal Hashtable`1<IGenericTypeInstanceReference> genericInstanceCache;
    private Hashtable`1<IName> StringIndexToNameTable;
    private Hashtable`1<IName> StringIndexToUnmangledNameTable;
    internal _Module_Type _Module_;
    internal AssemblyReference SystemEnumAssembly;
    internal AssemblyReference SystemValueTypeAssembly;
    internal AssemblyReference SystemMulticastDelegateAssembly;
    internal AssemblyReference SystemTypeAssembly;
    internal AssemblyReference SystemParamArrayAttributeAssembly;
    private CoreTypes coreTypes;
    private AssemblyIdentity contractAssemblySymbolicIdentity;
    private AssemblyIdentity coreAssemblySymbolicIdentity;
    internal Module Module;
    internal AssemblyReference[] AssemblyReferenceArray;
    internal IEnumerable`1<IAssemblyReference> AssemblyReferences;
    private ModuleReference[] ModuleReferenceArray;
    private FileReference[] FileReferenceArray;
    private ResourceReference[] ResourceReferenceArray;
    internal RootNamespace RootModuleNamespace;
    private Hashtable`1<Namespace> NamespaceINameHashtable;
    private DoubleHashtable`1<NamespaceReference> NamespaceReferenceINameHashtable;
    private DoubleHashtable NamespaceTypeTokenTable;
    private DoubleHashtable NestedTypeTokenTable;
    private TypeBase[] ModuleTypeDefArray;
    private INamedTypeReference[] RedirectedTypeDefArray;
    private LoadState[] ModuleTypeDefLoadState;
    private ExportedTypeAliasBase[] ExportedTypeArray;
    private LoadState[] ExportedTypeLoadState;
    private GenericParameter[] ModuleGenericParamArray;
    private INamedTypeReference[] ModuleTypeRefReferenceArray;
    private LoadState[] ModuleTypeRefReferenceLoadState;
    private DoubleHashtable`1<TypeSpecReference> ModuleTypeSpecHashtable;
    private FieldDefinition[] ModuleFieldArray;
    private IMethodDefinition[] ModuleMethodArray;
    private EventDefinition[] ModuleEventArray;
    private PropertyDefinition[] ModulePropertyArray;
    private MemberReference[] ModuleMemberReferenceArray;
    private MemberReference[] UnspecializedMemberReferenceArray;
    private DoubleHashtable`1<ISpecializedFieldReference> SpecializedFieldHashtable;
    private DoubleHashtable`1<ISpecializedMethodReference> SpecializedMethodHashtable;
    private DoubleHashtable`1<IGenericMethodInstanceReference> ModuleMethodSpecHashtable;
    private ICustomAttribute[] CustomAttributeArray;
    private ISecurityAttribute[] DeclSecurityArray;
    private MetadataObject currentOwningObject;
    private CoreTypes CoreTypes { get; }
    internal IMetadataReaderNamedTypeReference SystemEnum { get; }
    internal IMetadataReaderNamedTypeReference SystemValueType { get; }
    internal IMetadataReaderNamedTypeReference SystemMulticastDelegate { get; }
    internal IMetadataReaderNamedTypeReference SystemType { get; }
    internal IMetadataReaderNamedTypeReference SystemParamArrayAttribute { get; }
    internal AssemblyIdentity ContractAssemblySymbolicIdentity { get; }
    internal AssemblyIdentity CoreAssemblySymbolicIdentity { get; }
    internal byte MetadataFormatMajorVersion { get; }
    internal byte MetadataFormatMinorVersion { get; }
    internal Machine Machine { get; }
    internal bool RequiresAmdInstructionSet { get; }
    internal bool RequiresStartupStub { get; }
    internal bool Requires64Bits { get; }
    internal Guid ModuleGuidIdentifier { get; }
    internal ushort SubsystemMajorVersion { get; }
    internal ushort SubsystemMinorVersion { get; }
    internal string TargetRuntimeVersion { get; }
    internal ModuleKind ModuleKind { get; }
    internal IPlatformType PlatformType { get; }
    internal PEFileToObjectModel(PeReader peReader, PEFileReader peFileReader, ModuleIdentity moduleIdentity, Assembly containingAssembly, byte pointerSize);
    private CoreTypes get_CoreTypes();
    internal IMetadataReaderNamedTypeReference get_SystemEnum();
    internal IMetadataReaderNamedTypeReference get_SystemValueType();
    internal IMetadataReaderNamedTypeReference get_SystemMulticastDelegate();
    internal IMetadataReaderNamedTypeReference get_SystemType();
    internal IMetadataReaderNamedTypeReference get_SystemParamArrayAttribute();
    internal AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    internal AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    private AssemblyIdentity GetContractAssemblySymbolicIdentity();
    private AssemblyIdentity GetCoreAssemblySymbolicIdentity();
    internal IName GetNameFromOffset(UInt32 offset);
    private IName GetUnmangledNameFromOffset(UInt32 offset, int genericParameterCount);
    internal byte get_MetadataFormatMajorVersion();
    internal byte get_MetadataFormatMinorVersion();
    internal Machine get_Machine();
    internal bool get_RequiresAmdInstructionSet();
    internal bool get_RequiresStartupStub();
    internal bool get_Requires64Bits();
    internal Guid get_ModuleGuidIdentifier();
    internal ushort get_SubsystemMajorVersion();
    internal ushort get_SubsystemMinorVersion();
    internal string get_TargetRuntimeVersion();
    internal ModuleKind get_ModuleKind();
    internal IPlatformType get_PlatformType();
    private void LoadAssemblyReferences();
    private void LoadModuleReferences();
    internal AssemblyReference GetAssemblyReferenceAt(UInt32 assemRefRowId);
    internal ModuleReference GetModuleReferenceAt(UInt32 moduleRefRowId);
    internal IEnumerable`1<IAssemblyReference> GetAssemblyReferences();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetModuleReferences>d__74")]
internal IEnumerable`1<IModuleReference> GetModuleReferences();
    internal Assembly ResolveAssemblyRefReference(AssemblyReference assemblyReference);
    internal IModule ResolveModuleRefReference(ModuleReference moduleReference);
    internal AssemblyReference FindAssemblyReference(AssemblyIdentity assemblyIdentity);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetUninterpretedPESections>d__80")]
internal IEnumerable`1<IPESection> GetUninterpretedPESections();
    internal string GetWin32ResourceName(int idOrName);
    internal EnumerableMemoryBlockWrapper GetWin32ResourceBytes(int dataRVA, int size);
    internal EnumerableMemoryBlockWrapper GetWin32ResourceBytes(UInt32 dataRVA, UInt32 size);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetWin32Resources>d__84")]
internal IEnumerable`1<IWin32Resource> GetWin32Resources();
    internal EnumerableMemoryBlockWrapper GetFileHash(UInt32 fileRowId);
    private void InitFileReferenceArray();
    internal FileReference GetFileReferenceAt(UInt32 fileRefRowId);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetFiles>d__88")]
internal IEnumerable`1<IFileReference> GetFiles();
    private void InitResourceReferenceArray();
    internal ResourceReference LookupResourceReference(IName name);
    internal IResource ResolveResource(ResourceReference resourceReference, ResourceReference originalReference);
    internal IFileReference GetExternalFileForResource(UInt32 resourceRowId);
    internal IEnumerable`1<byte> GetResourceData(Resource resource);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetResources>d__94")]
internal IEnumerable`1<IResourceReference> GetResources();
    internal string GetDebugInformationLocation();
    internal string GetDebugInformationVersion();
    internal DllCharacteristics GetDllCharacteristics();
    internal IMethodReference GetEntryPointMethod();
    private Namespace GetNamespaceForString(string namespaceFullName);
    private void BuildNamespaceForNameOffset(UInt32 namespaceNameOffset, Hashtable`1<Namespace> namespaceOffsetHashtable);
    private void LoadNamespaces();
    private Namespace GetNamespaceForNameOffset(UInt32 namespaceNameOffset);
    internal NamespaceReference GetNamespaceReferenceForString(IMetadataReaderModuleReference moduleReference, IName iNamespaceFullName);
    private void PreLoadTypeDefTableLookup();
    private NamespaceType CreateModuleNamespaceType(UInt32 typeDefRowId, TypeDefRow typeDefRow, Namespace moduleNamespace, MetadataReaderSignatureTypeCode signatureTypeCode);
    private NestedType CreateModuleNestedType(UInt32 typeDefRowId, TypeDefRow typeDefRow, TypeBase parentModuleType);
    private ExportedTypeNamespaceAlias CreateExportedNamespaceType(UInt32 exportedTypeRowId, ExportedTypeRow exportedTypeRow, Namespace moduleNamespace);
    private ExportedTypeNestedAlias CreateExportedNestedType(UInt32 exportedTypeRowId, ExportedTypeRow exportedTypeRow, ExportedTypeAliasBase parentExportedType);
    internal void LoadTypesInNamespace(Namespace moduleNamespace);
    internal NamespaceType GetPredefinedTypeDefinitionAtRowWorker(UInt32 typeDefRowId, MetadataReaderSignatureTypeCode signatureTypeCode);
    internal _Module_Type Create_Module_Type();
    internal TypeBase GetTypeDefinitionAtRowWorker(UInt32 typeDefRowId);
    internal INamedTypeReference GetTypeDefinitionAtRow(UInt32 typeDefRowId);
    internal ExportedTypeAliasBase GetExportedTypeAtRowWorker(UInt32 exportedTypeRowId);
    internal ExportedTypeAliasBase GetExportedTypeAtRow(UInt32 exportedTypeRowId);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetEnumberableForExportedTypes>d__126")]
internal IEnumerable`1<IAliasForType> GetEnumberableForExportedTypes();
    internal void LoadNestedExportedTypesOfAlias(ExportedTypeAliasBase exportedType);
    internal INamedTypeDefinition ResolveNamespaceTypeDefinition(IName namespaceName, IName mangledTypeName);
    internal INamedTypeDefinition ResolveNestedTypeDefinition(INamedTypeDefinition parentType, IName typeName);
    internal ExportedTypeAliasBase TryToResolveAsNamespaceTypeAlias(IName namespaceName, IName mangledTypeName);
    internal ExportedTypeAliasBase ResolveExportedNestedType(ExportedTypeAliasBase parentType, IName typeName);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetAllTypes>d__132")]
internal IEnumerable`1<INamedTypeDefinition> GetAllTypes();
    internal void GetGenericParamInfoForType(UInt32 typeDefRowId, UInt32& genericParamRowIdStart, UInt32& genericParamRowIdEnd);
    internal ITypeReference GetBaseTypeForType(TypeBase moduleType);
    internal void GetInterfaceInfoForType(TypeBase moduleType, UInt32& interfaceRowIdStart, UInt32& interfaceRowIdEnd);
    internal void GetMethodImplInfoForType(TypeBase moduleType, UInt32& methodImplRowIdStart, UInt32& methodImplRowIdEnd);
    internal void GetConstraintInfoForGenericParam(GenericParameter genericParam, UInt32& genericParamConstraintRowIdStart, UInt32& genericParamConstraintRowIdEnd);
    internal ITypeReference GetInterfaceForInterfaceRowId(TypeBase moduleType, UInt32 interfaceRowId);
    internal MethodImplementation GetMethodImplementation(TypeBase moduleType, UInt32 methodImplRowId);
    internal ITypeReference GetTypeReferenceForGenericConstraintRowId(GenericParameter genParam, UInt32 interfaceRowId);
    internal ITypeReference GetSerializedTypeNameAsTypeReference(TypeName typeName);
    internal ITypeReference GetSerializedTypeNameAsTypeReference(string serializedTypeName);
    internal ushort GetAlignment(TypeBase type);
    internal UInt32 GetClassSize(TypeBase type);
    internal GenericTypeParameter GetGenericTypeParamAtRow(UInt32 genericParamRowId, TypeBase moduleTypeOwner);
    internal GenericMethodParameter GetGenericMethodParamAtRow(UInt32 genericParamRowId, GenericMethod moduleMethodOwner);
    private TypeRefReference CreateTypeRefReference(UInt32 typeRefRowId, TypeRefRow typeRefRow, IMetadataReaderNamedTypeReference parentModuleTypeReference, IMetadataReaderModuleReference moduleReference, MetadataReaderSignatureTypeCode signatureTypeCode);
    internal IMetadataReaderNamedTypeReference GetPredefinedTypeRefReferenceAtRowWorker(UInt32 typeRefRowId, MetadataReaderSignatureTypeCode signatureTypeCode);
    private IMetadataReaderNamedTypeReference GetTypeRefReferenceAtRowWorker(UInt32 typeRefRowId);
    private INamedTypeReference GetTypeRefReferenceAtRowWorker(UInt32 typeRefRowId, bool mustBeStruct);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetMemberReferences>d__155")]
internal IEnumerable`1<ITypeMemberReference> GetMemberReferences();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetStructuralMemberReferences>d__156")]
internal IEnumerable`1<ITypeMemberReference> GetStructuralMemberReferences();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetTypeReferences>d__157")]
internal IEnumerable`1<ITypeReference> GetTypeReferences();
    internal INamedTypeReference GetTypeRefReferenceAtRow(UInt32 typeRefRowId);
    internal INamedTypeReference GetTypeRefReferenceAtRow(UInt32 typeRefRowId, bool mustBeStruct);
    internal TypeSpecReference GetTypeSpecReferenceAtRow(MetadataObject owningObject, UInt32 typeSpecRowId);
    internal ITypeReference GetTypeReferenceForToken(MetadataObject owningObject, UInt32 token);
    internal ITypeReference GetTypeReferenceForToken(MetadataObject owningObject, UInt32 token, bool mustBeStruct);
    internal INamedTypeDefinition ResolveModuleTypeRefReference(IMetadataReaderNamedTypeReference namedTypeReference);
    internal ExportedTypeAliasBase TryToResolveNamespaceTypeReferenceAsExportedType(NamespaceTypeRefReference namespaceTypeReference);
    internal INamedTypeReference GetReferenceToAliasedType(ExportedTypeAliasBase alias);
    internal ITypeReference UnderlyingModuleTypeSpecReference(TypeSpecReference moduleTypeSpecReference);
    internal TypeBase FindCoreTypeReference(CoreTypeReference coreTypeReference);
    private FieldDefinition CreateField(UInt32 fieldDefRowId, TypeBase parentModuleType);
    private IMethodDefinition CreateMethod(UInt32 methodDefRowId, TypeBase parentModuleType);
    private EventDefinition CreateEvent(UInt32 eventDefRowId, TypeBase parentModuleType);
    private PropertyDefinition CreateProperty(UInt32 propertyDefRowId, TypeBase parentModuleType);
    private void LoadNestedTypesOfType(TypeBase moduleType);
    private void LoadFieldsOfType(TypeBase moduleType);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetFieldsOfType>d__178")]
internal IEnumerable`1<IFieldDefinition> GetFieldsOfType(TypeBase moduleType);
    private void LoadMethodsOfType(TypeBase moduleType);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetMethodsOfType>d__180")]
internal IEnumerable`1<IMethodDefinition> GetMethodsOfType(TypeBase moduleType);
    private void LoadEventsOfType(TypeBase moduleType);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetEventsOfType>d__182")]
internal IEnumerable`1<IEventDefinition> GetEventsOfType(TypeBase moduleType);
    private void LoadPropertiesOfType(TypeBase moduleType);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetPropertiesOfType>d__184")]
internal IEnumerable`1<IPropertyDefinition> GetPropertiesOfType(TypeBase moduleType);
    internal void LoadMembersOfType(TypeBase moduleType);
    internal IMethodDefinition GetMethodDefAtRow(UInt32 methodDefRowId);
    internal FieldDefinition GetFieldDefAtRow(UInt32 fieldDefRowId);
    private FieldDefinition CreateGlobalField(UInt32 fieldDefRowId);
    private MethodDefinition CreateGlobalMethod(UInt32 methodDefRowId);
    internal void LoadMembersOf_Module_Type();
    internal void GetGenericParamInfoForMethod(UInt32 methodDefRowId, UInt32& genericParamRowIdStart, UInt32& genericParamRowIdEnd);
    internal FieldSignatureConverter GetFieldSignature(FieldDefinition moduleField);
    internal PropertySignatureConverter GetPropertySignature(PropertyDefinition moduleProperty);
    internal MethodDefSignatureConverter GetMethodSignature(MethodDefinition moduleMethod);
    internal ushort GetMethodParameterCount(MethodDefinition moduleMethod);
    internal ITypeReference GetEventType(EventDefinition moduleEvent);
    internal UInt32 GetFieldOffset(FieldDefinition fieldDefinition);
    internal int GetFieldSequenceNumber(FieldDefinition fieldDefinition);
    internal ISectionBlock GetFieldMapping(FieldDefinition fieldDefinition);
    private UInt32 GetFieldSizeIfPossibleToDoSoWithoutResolving(ITypeReference typeReference);
    internal void GetSemanticInfoForProperty(UInt32 propertyRowId, UInt32& methodSemanticRowIdStart, UInt32& methodSemanticRowIdEnd);
    internal void GetSemanticInfoForEvent(UInt32 eventRowId, UInt32& methodSemanticRowIdStart, UInt32& methodSemanticRowIdEnd);
    internal IMethodDefinition GetPropertyGetterOrSetterMethod(PropertyDefinition propertyDefinition, MethodSemanticsFlags getterOrSetterFlag);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetPropertyAccessorMethods>d__204")]
internal IEnumerable`1<IMethodReference> GetPropertyAccessorMethods(PropertyDefinition propertyDefinition);
    internal IMethodDefinition GetEventAddOrRemoveOrFireMethod(EventDefinition eventDefinition, MethodSemanticsFlags addOrRemoveOrFireFlag);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetEventAccessorMethods>d__206")]
internal IEnumerable`1<IMethodReference> GetEventAccessorMethods(EventDefinition eventDefinition);
    internal IMetadataConstant GetDefaultValue(MetadataObject metadataObject);
    internal IMarshallingInformation GetMarshallingInformation(MetadataObject metadataObject);
    internal IPlatformInvokeInformation GetPlatformInvokeInformation(MethodDefinition methodDefinition);
    internal IMethodBody GetMethodBody(MethodDefinition methodDefinition);
    internal ITypeMemberReference GetModuleMemberReferenceAtRowWorker(MetadataObject owningObject, UInt32 memberRefRowId);
    internal ITypeMemberReference GetModuleMemberReferenceAtRow(MetadataObject owningObject, UInt32 memberRefRowId);
    internal MethodRefSignatureConverter GetMethodRefSignature(MethodReference moduleMethodReference);
    internal int GetMethodRefParameterCount(MethodReference moduleMethodReference);
    internal int GetMethodRefGenericParameterCount(MethodReference moduleMethodReference);
    internal FieldSignatureConverter GetFieldRefSignature(FieldReference moduleFieldReference);
    internal IMethodReference GetMethodSpecAtRow(MetadataObject owningObject, UInt32 methodSpecRowId);
    internal IMethodReference GetMethodReferenceForToken(MetadataObject owningObject, UInt32 methodRefToken);
    internal IFieldReference GetFieldReferenceForToken(MetadataObject owningObject, UInt32 fieldRefToken);
    internal ITypeReference GetTypeReferenceFromStandaloneSignatureToken(MethodDefinition owningObject, UInt32 token);
    internal object GetReferenceForToken(MetadataObject owningObject, UInt32 token);
    internal void GetCustomAttributeInfo(MetadataObject metadataObject, UInt32& customAttributeRowIdStart, UInt32& customAttributeRowIdEnd);
    internal ICustomAttribute GetCustomAttributeAtRow(MetadataObject owningObject, UInt32 token, UInt32 customAttributeRowId);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetModuleCustomAttributes>d__232")]
internal IEnumerable`1<ICustomAttribute> GetModuleCustomAttributes();
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetAssemblyCustomAttributes>d__233")]
internal IEnumerable`1<ICustomAttribute> GetAssemblyCustomAttributes();
    internal void GetSecurityAttributeInfo(MetadataObject metadataObject, UInt32& securityAttributeRowIdStart, UInt32& securityAttributeRowIdEnd);
    internal ISecurityAttribute GetSecurityAttributeAtRow(MetadataObject owningObject, UInt32 securityAttributeRowId);
    internal IEnumerable`1<ICustomAttribute> GetSecurityAttributeData(SecurityAttribute securityAttribute);
    [IteratorStateMachineAttribute("Microsoft.Cci.MetadataReader.PEFileToObjectModel/<GetAttributesForSameParentAs>d__237")]
internal IEnumerable`1<ICustomAttribute> GetAttributesForSameParentAs(UInt32 tokenValue);
}
internal class Microsoft.Cci.MetadataReader.PropertySignatureConverter : SignatureConverter {
    internal byte firstByte;
    internal IEnumerable`1<ICustomModifier> returnCustomModifiers;
    internal bool returnValueIsByReference;
    internal ITypeReference type;
    internal IEnumerable`1<IParameterDefinition> parameters;
    internal PropertySignatureConverter(PEFileToObjectModel peFileToObjectModel, PropertyDefinition moduleProperty, MemoryReader signatureMemoryReader);
}
internal class Microsoft.Cci.MetadataReader.SecurityAttributeDecoder20 : AttributeDecoder {
    internal IEnumerable`1<ICustomAttribute> SecurityAttributes;
    internal SecurityAttributeDecoder20(PEFileToObjectModel peFileToObjectModel, MemoryReader signatureMemoryReader, SecurityAttribute securityAttribute);
    private SecurityCustomAttribute ReadSecurityAttribute(SecurityAttribute securityAttribute);
}
internal abstract class Microsoft.Cci.MetadataReader.SignatureConverter : object {
    protected PEFileToObjectModel PEFileToObjectModel;
    protected MetadataObject MetadataOwnerObject;
    protected TypeBase ModuleGenericType;
    protected GenericMethod ModuleGenericMethod;
    protected IMethodReference ModuleMethodReference;
    protected ITypeMemberReference ModuleMemberReference;
    protected MemoryReader SignatureMemoryReader;
    internal SignatureConverter(PEFileToObjectModel peFileToObjectModel, MemoryReader signatureMemoryReader, MetadataObject metadataOwnerObject);
    protected IEnumerable`1<ICustomModifier> GetCustomModifiers(Boolean& isPinned);
    protected ITypeReference GetModuleGenericTypeInstanceReference(UInt32 typeSpecToken);
    private static bool SeeIfTypeNamesAreMangled(INamedTypeReference templateTypeReference);
    private ITypeReference SpecializeAndOrInstantiate(UInt32 typeSpecToken, INamedTypeReference namedTypeReference, UInt16& genericArgumentCount, bool outer);
    private ITypeReference Instantiate(UInt32 typeSpecToken, INamedTypeReference templateTypeReference, ushort genericArgumentCount);
    protected ManagedPointerType GetModuleManagedPointerType(UInt32 typeSpecToken);
    protected PointerType GetModulePointerType(UInt32 typeSpecToken);
    protected Matrix GetModuleMatrixType(UInt32 typeSpecToken);
    protected Vector GetModuleVectorType(UInt32 typeSpecToken);
    protected FunctionPointerType GetModuleFuntionPointer(UInt32 typeSpecToken);
    protected ITypeReference GetTypeReference();
    protected virtual Nullable`1<ParamInfo> GetParamInfo(int paramSequence);
    protected IParameterDefinition[] GetModuleParameters(bool useParamInfo, ISignature signatureDefinition, int paramCount);
    protected IParameterTypeInformation[] GetModuleParameterTypeInformations(ISignature signature, int paramCount);
}
internal class Microsoft.Cci.MetadataReader.TypeSpecSignatureConverter : SignatureConverter {
    internal ITypeReference TypeReference;
    internal TypeSpecSignatureConverter(PEFileToObjectModel peFileToObjectModel, TypeSpecReference moduleTypeSpecReference, MemoryReader signatureMemoryReader);
}
public abstract class Microsoft.Cci.MetadataReader.WindowsRuntimeMetadataReaderHost : MetadataReaderHost {
    private bool projectToCLRTypes;
    private IName AllowMultiple;
    private IName AllowMultipleAttribute;
    private IName Animation;
    private IName Collections;
    private IName Controls;
    private IName Data;
    private IName Foundation;
    private IName HResult;
    private IName IBindableIterable;
    private IName IBindableVector;
    private IName IClosable;
    private IName IIterable;
    private IName IKeyValuePair;
    private IName IMap;
    private IName IMapView;
    private IName INotifyCollectionChanged;
    private IName INotifyPropertyChanged;
    private IName Input;
    private IName Interop;
    private IName IReference;
    private IName IVector;
    private IName IVectorView;
    private IName Media;
    private IName Media3D;
    private IName Metadata;
    private IName NotifyCollectionChangedAction;
    private IName NotifyCollectionChangedEventArgs;
    private IName NotifyCollectionChangedEventHandler;
    private IName Primitives;
    private IName PropertyChangedEventArgs;
    private IName PropertyChangedEventHandler;
    private IName TypeName;
    private IName UI;
    private IName Windows;
    private IName Xaml;
    private WindowsRuntimePlatform platformType;
    protected WindowsRuntimeMetadataReaderHost(INameTable nameTable, IInternFactory factory, byte pointerSize, IEnumerable`1<string> searchPaths, bool searchInGAC, bool projectToCLRTypes);
    protected virtual IPlatformType GetPlatformType();
    public virtual IMethodDefinition Rewrite(IUnit containingUnit, IMethodDefinition methodDefinition);
    public virtual IEnumerable`1<IAssemblyReference> Redirect(IUnit referringUnit, IEnumerable`1<IAssemblyReference> assemblyReferences);
    public virtual INamedTypeReference Redirect(IUnit referringUnit, INamedTypeReference typeReference);
    public virtual ICustomAttribute Rewrite(IUnit referringUnit, ICustomAttribute customAttribute);
    private bool FellowCustomAttributeIncludeAllowMultiple(CustomAttribute customAttr);
    public virtual AssemblyIdentity UnifyAssembly(AssemblyIdentity assemblyIdentity);
    private bool IsWindows(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsFoundation(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsFoundationCollections(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsFoundationMetadata(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUI(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXaml(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlControls(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlControlsPrimitives(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlData(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlInput(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlInterop(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlMedia(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlMediaAnimation(INestedUnitNamespaceReference namespaceReference);
    private bool IsWindowsUIXamlMediaMedia3D(INestedUnitNamespaceReference namespaceReference);
}
internal class Microsoft.Cci.MetadataReader.WindowsRuntimePlatform : PlatformType {
    private IAssemblyReference system;
    private IAssemblyReference systemObjectModel;
    private IAssemblyReference systemRuntimeInteropServicesWindowsRuntime;
    private IAssemblyReference systemRuntimeWindowsRuntime;
    private IAssemblyReference systemRuntimeWindowsRuntimeUIXaml;
    private INamespaceTypeReference systemAttributeTargets;
    private INamespaceTypeReference systemCollectionsGenericIDictionary;
    private INamespaceTypeReference systemCollectionsGenericKeyValuePair;
    private INamespaceTypeReference systemCollectionsGenericReadOnlyDictionary;
    private INamespaceTypeReference systemCollectionsGenericReadOnlyList;
    private INamespaceTypeReference systemCollectionsSpecializedINotifyColletionChanged;
    private INamespaceTypeReference systemCollectionsSpecializedNotifyCollectionChangedAction;
    private INamespaceTypeReference systemCollectionsSpecializedNotifyCollectionChangedEventArgs;
    private INamespaceTypeReference systemCollectionsSpecializedNotifyCollectionChangedEventHandler;
    private INamespaceTypeReference systemComponentModelINotifyPropertyChanged;
    private INamespaceTypeReference systemComponentModelPropertyChangedEventArgs;
    private INamespaceTypeReference systemComponentModelPropertyChangedEventHandler;
    private INamespaceTypeReference systemEventHandler1;
    private INamespaceTypeReference systemIDisposable;
    private INamespaceTypeReference systemNullable1;
    private INamespaceTypeReference systemRuntimeInteropServicesWindowsRuntimeEventRegistrationToken;
    private INamespaceTypeReference systemTimeSpan;
    private INamespaceTypeReference systemUri;
    private INamespaceTypeReference systemWindowsInputICommand;
    private INamespaceTypeReference windowsFoundationColor;
    private INamespaceTypeReference windowsFoundationPoint;
    private INamespaceTypeReference windowsFoundationRect;
    private INamespaceTypeReference windowsFoundationSize;
    private INamespaceTypeReference windowsUIXamlCornerRadius;
    private INamespaceTypeReference windowsUIXamlDuration;
    private INamespaceTypeReference windowsUIXamlDurationType;
    private INamespaceTypeReference windowsUIXamlGridLength;
    private INamespaceTypeReference windowsUIXamlGridUnitType;
    private INamespaceTypeReference windowsUIXamlThickness;
    private INamespaceTypeReference windowsUIXamlControlsPrimitivesGeneratorPosition;
    private INamespaceTypeReference windowsUIXamlMediaMatrix;
    private INamespaceTypeReference windowsUIXamlMediaAnimationKeyTime;
    private INamespaceTypeReference windowsUIXamlMediaAnimationRepeatBehavior;
    private INamespaceTypeReference windowsUIXamlMediaAnimationRepeatBehaviorType;
    private INamespaceTypeReference windowsUIXamlMediaMedia3DMatrix3D;
    internal IAssemblyReference System { get; }
    internal IAssemblyReference SystemObjectModel { get; }
    internal IAssemblyReference SystemRuntimeInteropServicesWindowsRuntime { get; }
    internal IAssemblyReference SystemRuntimeWindowsRuntime { get; }
    internal IAssemblyReference SystemRuntimeWindowsRuntimeUIXaml { get; }
    internal INamespaceTypeReference SystemAttributeTargets { get; }
    internal INamespaceTypeReference SystemCollectionsGenericIDictionary { get; }
    internal INamespaceTypeReference SystemCollectionsGenericKeyValuePair { get; }
    internal INamespaceTypeReference SystemCollectionsGenericReadOnlyDictionary { get; }
    public INamespaceTypeReference SystemCollectionsGenericReadOnlyList { get; }
    public INamespaceTypeReference SystemCollectionsSpecializedINotifyColletionChanged { get; }
    public INamespaceTypeReference SystemCollectionsSpecializedNotifyCollectionChangedAction { get; }
    public INamespaceTypeReference SystemCollectionsSpecializedNotifyCollectionChangedEventArgs { get; }
    public INamespaceTypeReference SystemCollectionsSpecializedNotifyCollectionChangedEventHandler { get; }
    public INamespaceTypeReference SystemComponentModelINotifyPropertyChanged { get; }
    public INamespaceTypeReference SystemComponentModelPropertyChangedEventArgs { get; }
    public INamespaceTypeReference SystemComponentModelPropertyChangedEventHandler { get; }
    public INamespaceTypeReference SystemEventHandler1 { get; }
    internal INamespaceTypeReference SystemIDisposable { get; }
    internal INamespaceTypeReference SystemNullable1 { get; }
    internal INamespaceTypeReference SystemRuntimeInteropServicesWindowsRuntimeEventRegistrationToken { get; }
    internal INamespaceTypeReference SystemTimeSpan { get; }
    internal INamespaceTypeReference SystemUri { get; }
    internal INamespaceTypeReference SystemWindowsInputICommand { get; }
    public INamespaceTypeReference WindowsUIColor { get; }
    public INamespaceTypeReference WindowsFoundationPoint { get; }
    public INamespaceTypeReference WindowsFoundationRect { get; }
    public INamespaceTypeReference WindowsFoundationSize { get; }
    public INamespaceTypeReference WindowsUIXamlCornerRadius { get; }
    public INamespaceTypeReference WindowsUIXamlDuration { get; }
    public INamespaceTypeReference WindowsUIXamlDurationType { get; }
    public INamespaceTypeReference WindowsUIXamlGridLength { get; }
    public INamespaceTypeReference WindowsUIXamlGridUnitType { get; }
    public INamespaceTypeReference WindowsUIXamlThickness { get; }
    public INamespaceTypeReference WindowsUIXamlControlsPrimitivesGeneratorPosition { get; }
    public INamespaceTypeReference WindowsUIXamlMediaMatrix { get; }
    public INamespaceTypeReference WindowsUIXamlMediaAnimationKeyTime { get; }
    public INamespaceTypeReference WindowsUIXamlMediaAnimationRepeatBehavior { get; }
    public INamespaceTypeReference WindowsUIXamlMediaAnimationRepeatBehaviorType { get; }
    public INamespaceTypeReference WindowsUIXamlMediaMedia3DMatrix3D { get; }
    internal WindowsRuntimePlatform(IMetadataHost host);
    internal IAssemblyReference get_System();
    private AssemblyIdentity GetSystemSymbolicIdentity();
    internal IAssemblyReference get_SystemObjectModel();
    private AssemblyIdentity GetSystemObjectModelSymbolicIdentity();
    internal IAssemblyReference get_SystemRuntimeInteropServicesWindowsRuntime();
    private AssemblyIdentity GetSystemRuntimeInteropServicesWindowsRuntimeSymbolicIdentity();
    internal IAssemblyReference get_SystemRuntimeWindowsRuntime();
    private AssemblyIdentity GetSystemRuntimeWindowsRuntimeSymbolicIdentity();
    internal IAssemblyReference get_SystemRuntimeWindowsRuntimeUIXaml();
    private AssemblyIdentity GetSystemRuntimeWindowsRuntimeUIXamlSymbolicIdentity();
    internal INamespaceTypeReference get_SystemAttributeTargets();
    internal INamespaceTypeReference get_SystemCollectionsGenericIDictionary();
    internal INamespaceTypeReference get_SystemCollectionsGenericKeyValuePair();
    internal INamespaceTypeReference get_SystemCollectionsGenericReadOnlyDictionary();
    public INamespaceTypeReference get_SystemCollectionsGenericReadOnlyList();
    public INamespaceTypeReference get_SystemCollectionsSpecializedINotifyColletionChanged();
    public INamespaceTypeReference get_SystemCollectionsSpecializedNotifyCollectionChangedAction();
    public INamespaceTypeReference get_SystemCollectionsSpecializedNotifyCollectionChangedEventArgs();
    public INamespaceTypeReference get_SystemCollectionsSpecializedNotifyCollectionChangedEventHandler();
    public INamespaceTypeReference get_SystemComponentModelINotifyPropertyChanged();
    public INamespaceTypeReference get_SystemComponentModelPropertyChangedEventArgs();
    public INamespaceTypeReference get_SystemComponentModelPropertyChangedEventHandler();
    public INamespaceTypeReference get_SystemEventHandler1();
    internal INamespaceTypeReference get_SystemIDisposable();
    internal INamespaceTypeReference get_SystemNullable1();
    internal INamespaceTypeReference get_SystemRuntimeInteropServicesWindowsRuntimeEventRegistrationToken();
    internal INamespaceTypeReference get_SystemTimeSpan();
    internal INamespaceTypeReference get_SystemUri();
    internal INamespaceTypeReference get_SystemWindowsInputICommand();
    public INamespaceTypeReference get_WindowsUIColor();
    public INamespaceTypeReference get_WindowsFoundationPoint();
    public INamespaceTypeReference get_WindowsFoundationRect();
    public INamespaceTypeReference get_WindowsFoundationSize();
    public INamespaceTypeReference get_WindowsUIXamlCornerRadius();
    public INamespaceTypeReference get_WindowsUIXamlDuration();
    public INamespaceTypeReference get_WindowsUIXamlDurationType();
    public INamespaceTypeReference get_WindowsUIXamlGridLength();
    public INamespaceTypeReference get_WindowsUIXamlGridUnitType();
    public INamespaceTypeReference get_WindowsUIXamlThickness();
    public INamespaceTypeReference get_WindowsUIXamlControlsPrimitivesGeneratorPosition();
    public INamespaceTypeReference get_WindowsUIXamlMediaMatrix();
    public INamespaceTypeReference get_WindowsUIXamlMediaAnimationKeyTime();
    public INamespaceTypeReference get_WindowsUIXamlMediaAnimationRepeatBehavior();
    public INamespaceTypeReference get_WindowsUIXamlMediaAnimationRepeatBehaviorType();
    public INamespaceTypeReference get_WindowsUIXamlMediaMedia3DMatrix3D();
}
internal class Microsoft.Cci.MetadataReaderErrorsReporter : object {
}
internal class Microsoft.Cci.MetadataReaderException : Exception {
    internal MetadataReaderException(string message);
}
public abstract class Microsoft.Cci.MetadataReaderHost : MetadataHostEnvironment {
    protected List`1<IDisposable> disposableObjectAllocatedByThisHost;
    private Dictionary`2<UInt32, byte> successfulGuesses;
    private Dictionary`2<UInt32, byte> currentWildGuesses;
    private Dictionary`2<UInt32, byte> currentGoodGuesses;
    protected MetadataReaderHost(INameTable nameTable, IInternFactory factory, byte pointerSize, IEnumerable`1<string> searchPaths, bool searchInGAC);
    protected virtual override void Finalize();
    public virtual void Dispose();
    private void Close();
    public virtual IBinaryDocumentMemoryBlock OpenBinaryDocument(IBinaryDocument sourceDocument);
    public virtual IBinaryDocumentMemoryBlock OpenBinaryDocument(IBinaryDocument parentSourceDocument, string childDocumentName);
    public virtual IEnumerable`1<IAssemblyReference> Redirect(IUnit referringUnit, IEnumerable`1<IAssemblyReference> assemblyReferences);
    public virtual INamedTypeReference Redirect(IUnit referringUnit, INamedTypeReference typeReference);
    public virtual ICustomAttribute Rewrite(IUnit containingUnit, ICustomAttribute customAttribute);
    public virtual IMethodDefinition Rewrite(IUnit containingUnit, IMethodDefinition methodDefinition);
    public virtual void ResolvingAssemblyReference(IUnit referringUnit, AssemblyIdentity referencedAssembly);
    public virtual void ResolvingModuleReference(IUnit referringUnit, ModuleIdentity referencedModule);
    public sealed virtual void StartGuessingGame();
    public sealed virtual bool TryNextPermutation();
    public sealed virtual void WinGuessingGame();
    public sealed virtual byte GuessUnderlyingTypeSizeOfUnresolvableReferenceToEnum(ITypeReference reference);
}
public class Microsoft.Cci.MetadataTraverser : object {
    private Dispatcher dispatchingVisitor;
    protected SetOfObjects objectsThatHaveAlreadyBeenTraversed;
    private IMetadataVisitor preorderVisitor;
    private IMetadataVisitor postorderVisitor;
    private bool stopTraversal;
    private bool traverseIntoMethodBodies;
    public IMetadataVisitor PreorderVisitor { get; public set; }
    public IMetadataVisitor PostorderVisitor { get; public set; }
    public bool StopTraversal { get; public set; }
    public bool TraverseIntoMethodBodies { get; public set; }
    public sealed virtual void Dispose();
    public IMetadataVisitor get_PreorderVisitor();
    public void set_PreorderVisitor(IMetadataVisitor value);
    public IMetadataVisitor get_PostorderVisitor();
    public void set_PostorderVisitor(IMetadataVisitor value);
    public bool get_StopTraversal();
    public void set_StopTraversal(bool value);
    public bool get_TraverseIntoMethodBodies();
    public void set_TraverseIntoMethodBodies(bool value);
    public void Traverse(IAliasForType aliasForType);
    public void Traverse(IAliasMember aliasMember);
    public void Traverse(IArrayTypeReference arrayTypeReference);
    public void Traverse(IAssembly assembly);
    public void Traverse(IAssemblyReference assemblyReference);
    public void Traverse(ICustomAttribute customAttribute);
    public void Traverse(ICustomModifier customModifier);
    public void Traverse(IDefinition definition);
    public void Traverse(IEventDefinition eventDefinition);
    public void Traverse(IFieldDefinition fieldDefinition);
    public void Traverse(IFieldReference fieldReference);
    private void TraverseUnspecialized(IFieldReference fieldReference);
    public void Traverse(IFileReference fileReference);
    public void Traverse(IFunctionPointerTypeReference functionPointerTypeReference);
    public void Traverse(IGenericMethodInstanceReference genericMethodInstanceReference);
    public void Traverse(IGenericMethodParameter genericMethodParameter);
    public void Traverse(IGenericMethodParameterReference genericMethodParameterReference);
    public void Traverse(IGenericTypeInstanceReference genericTypeInstanceReference);
    public void Traverse(IGenericTypeParameter genericTypeParameter);
    public void Traverse(IGenericTypeParameterReference genericTypeParameterReference);
    public void Traverse(IGlobalFieldDefinition globalFieldDefinition);
    public void Traverse(IGlobalMethodDefinition globalMethodDefinition);
    public void Traverse(ILocalDefinition localDefinition);
    public void Traverse(IManagedPointerTypeReference managedPointerTypeReference);
    public void Traverse(IMarshallingInformation marshallingInformation);
    public void Traverse(IMetadataConstant constant);
    public void Traverse(IMetadataCreateArray createArray);
    public void Traverse(IMetadataExpression expression);
    public void Traverse(IMetadataNamedArgument namedArgument);
    public void Traverse(IMetadataTypeOf typeOf);
    public virtual void Traverse(IMethodBody methodBody);
    public void Traverse(IMethodDefinition method);
    public void Traverse(IMethodImplementation methodImplementation);
    public void Traverse(IMethodReference methodReference);
    private void TraverseUnspecialized(IMethodReference methodReference);
    public void Traverse(IModifiedTypeReference modifiedTypeReference);
    public void Traverse(IModule module);
    public void Traverse(IModuleReference moduleReference);
    public void Traverse(INamespaceAliasForType namespaceAliasForType);
    public void Traverse(INamespaceDefinition namespaceDefinition);
    public void Traverse(INamespaceMember namespaceMember);
    public void Traverse(INamespaceTypeDefinition namespaceTypeDefinition);
    public void Traverse(INamespaceTypeReference namespaceTypeReference);
    public void Traverse(INestedAliasForType nestedAliasForType);
    public void Traverse(INestedTypeDefinition nestedTypeDefinition);
    public void Traverse(INestedTypeReference nestedTypeReference);
    private void TraverseUnspecialized(INestedTypeReference nestedTypeReference);
    public void Traverse(INestedUnitNamespace nestedUnitNamespace);
    public void Traverse(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public void Traverse(INestedUnitSetNamespace nestedUnitSetNamespace);
    public void Traverse(IOperation operation);
    public void Traverse(IOperationExceptionInformation operationExceptionInformation);
    public void Traverse(IParameterDefinition parameterDefinition);
    public void Traverse(IParameterTypeInformation parameterTypeInformation);
    public void Traverse(IPESection peSection);
    public void Traverse(IPlatformInvokeInformation platformInvokeInformation);
    public void Traverse(IPointerTypeReference pointerTypeReference);
    public void Traverse(IPropertyDefinition propertyDefinition);
    public void Traverse(IResourceReference resourceReference);
    public void Traverse(IRootUnitNamespace rootUnitNamespace);
    public void Traverse(IRootUnitSetNamespace rootUnitSetNamespace);
    public void Traverse(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public void Traverse(ISecurityAttribute securityAttribute);
    public void Traverse(ISpecializedFieldReference specializedFieldReference);
    public void Traverse(ISpecializedMethodReference specializedMethodReference);
    public void Traverse(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public void Traverse(ITypeDefinition typeDefinition);
    public void Traverse(ITypeDefinitionMember typeMember);
    private void Traverse(ITypeMemberReference typeMemberReference);
    public void Traverse(ITypeReference typeReference);
    public void Traverse(IUnitNamespace namespaceDefinition);
    public void Traverse(IUnitNamespaceReference unitNamespaceReference);
    public void Traverse(IUnitReference unitReference);
    public void Traverse(IWin32Resource win32Resource);
    public void Traverse(IEnumerable`1<IAliasForType> aliasesForTypes);
    public void Traverse(IEnumerable`1<IAliasMember> aliasMembers);
    public void Traverse(IEnumerable`1<IAssemblyReference> assemblyReferences);
    public void Traverse(IEnumerable`1<ICustomAttribute> customAttributes);
    public void Traverse(IEnumerable`1<ICustomModifier> customModifiers);
    public void Traverse(IEnumerable`1<IEventDefinition> events);
    public void Traverse(IEnumerable`1<IFieldDefinition> fields);
    public void Traverse(IEnumerable`1<IFileReference> fileReferences);
    public void Traverse(IEnumerable`1<IGenericMethodParameter> genericMethodParameters);
    public void Traverse(IEnumerable`1<IGenericTypeParameter> genericTypeParameters);
    public void Traverse(IEnumerable`1<ILocalDefinition> localDefinitions);
    public void Traverse(IEnumerable`1<IMetadataExpression> expressions);
    public void Traverse(IEnumerable`1<IMetadataNamedArgument> namedArguments);
    public void Traverse(IEnumerable`1<IMethodDefinition> methods);
    public void Traverse(IEnumerable`1<IMethodImplementation> methodImplementations);
    public void Traverse(IEnumerable`1<IMethodReference> methodReferences);
    public void Traverse(IEnumerable`1<IModule> modules);
    public void Traverse(IEnumerable`1<IModuleReference> moduleReferences);
    public void Traverse(IEnumerable`1<INamedTypeDefinition> types);
    public void Traverse(IEnumerable`1<INamespaceMember> namespaceMembers);
    public void Traverse(IEnumerable`1<INestedTypeDefinition> nestedTypes);
    public void Traverse(IEnumerable`1<IOperation> operations);
    public void Traverse(IEnumerable`1<IOperationExceptionInformation> operationExceptionInformations);
    public void Traverse(IEnumerable`1<IParameterDefinition> parameters);
    public void Traverse(IEnumerable`1<IParameterTypeInformation> parameterTypeInformations);
    public void Traverse(IEnumerable`1<IPESection> peSections);
    public void Traverse(IEnumerable`1<IPropertyDefinition> properties);
    public void Traverse(IEnumerable`1<IResourceReference> resourceReferences);
    public void Traverse(IEnumerable`1<ISecurityAttribute> securityAttributes);
    public void Traverse(IEnumerable`1<ITypeMemberReference> typeMemberReferences);
    public void Traverse(IEnumerable`1<ITypeDefinitionMember> typeMembers);
    public void Traverse(IEnumerable`1<ITypeReference> typeReferences);
    public void Traverse(IEnumerable`1<IWin32Resource> win32Resources);
    public virtual void TraverseChildren(IAliasForType aliasForType);
    public virtual void TraverseChildren(IArrayTypeReference arrayTypeReference);
    public virtual void TraverseChildren(IAssembly assembly);
    public virtual void TraverseChildren(IAssemblyReference assemblyReference);
    public virtual void TraverseChildren(ICustomAttribute customAttribute);
    public virtual void TraverseChildren(ICustomModifier customModifier);
    public virtual void TraverseChildren(IEventDefinition eventDefinition);
    public virtual void TraverseChildren(IFieldDefinition fieldDefinition);
    public virtual void TraverseChildren(IFieldReference fieldReference);
    public virtual void TraverseChildren(IFileReference fileReference);
    public virtual void TraverseChildren(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual void TraverseChildren(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void TraverseChildren(IGenericMethodParameter genericMethodParameter);
    public virtual void TraverseChildren(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual void TraverseChildren(IGenericParameterReference genericParameterReference);
    public virtual void TraverseChildren(IGenericParameter genericParameter);
    public virtual void TraverseChildren(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void TraverseChildren(IGenericTypeParameter genericTypeParameter);
    public virtual void TraverseChildren(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual void TraverseChildren(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void TraverseChildren(IGlobalMethodDefinition globalMethodDefinition);
    public virtual void TraverseChildren(ILocalDefinition localDefinition);
    public virtual void TraverseChildren(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual void TraverseChildren(IMarshallingInformation marshallingInformation);
    public virtual void TraverseChildren(IMetadataConstant constant);
    public virtual void TraverseChildren(IMetadataCreateArray createArray);
    public virtual void TraverseChildren(IMetadataExpression expression);
    public virtual void TraverseChildren(IMetadataNamedArgument namedArgument);
    public virtual void TraverseChildren(IMetadataTypeOf typeOf);
    public virtual void TraverseChildren(IMethodBody methodBody);
    public virtual void TraverseChildren(IMethodDefinition method);
    public virtual void TraverseChildren(IMethodImplementation methodImplementation);
    public virtual void TraverseChildren(IMethodReference methodReference);
    public virtual void TraverseChildren(IModifiedTypeReference modifiedTypeReference);
    public virtual void TraverseChildren(IModule module);
    public virtual void TraverseChildren(IModuleReference moduleReference);
    public virtual void TraverseChildren(INamedTypeDefinition namedTypeDefinition);
    public virtual void TraverseChildren(INamespaceAliasForType namespaceAliasForType);
    public virtual void TraverseChildren(INamespaceDefinition namespaceDefinition);
    public virtual void TraverseChildren(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void TraverseChildren(INamespaceTypeReference namespaceTypeReference);
    public virtual void TraverseChildren(INestedAliasForType nestedAliasForType);
    public virtual void TraverseChildren(INestedTypeDefinition nestedTypeDefinition);
    public virtual void TraverseChildren(INestedTypeReference nestedTypeReference);
    public virtual void TraverseChildren(INestedUnitNamespace nestedUnitNamespace);
    public virtual void TraverseChildren(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual void TraverseChildren(INestedUnitSetNamespace nestedUnitSetNamespace);
    public virtual void TraverseChildren(IOperation operation);
    public virtual void TraverseChildren(IOperationExceptionInformation operationExceptionInformation);
    public virtual void TraverseChildren(IParameterDefinition parameterDefinition);
    public virtual void TraverseChildren(IParameterTypeInformation parameterTypeInformation);
    public virtual void TraverseChildren(IPESection peSection);
    public virtual void TraverseChildren(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void TraverseChildren(IPointerTypeReference pointerTypeReference);
    public virtual void TraverseChildren(IPropertyDefinition propertyDefinition);
    public virtual void TraverseChildren(IResourceReference resourceReference);
    public virtual void TraverseChildren(IRootUnitNamespace rootUnitNamespace);
    public virtual void TraverseChildren(IRootUnitSetNamespace rootUnitSetNamespace);
    public virtual void TraverseChildren(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual void TraverseChildren(ISecurityAttribute securityAttribute);
    public virtual void TraverseChildren(ISpecializedFieldReference specializedFieldReference);
    public virtual void TraverseChildren(ISpecializedMethodReference specializedMethodReference);
    public virtual void TraverseChildren(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual void TraverseChildren(ITypeDefinition typeDefinition);
    public virtual void TraverseChildren(ITypeDefinitionMember typeMember);
    public virtual void TraverseChildren(ITypeReference typeReference);
    public virtual void TraverseChildren(IUnitNamespace namespaceDefinition);
    public virtual void TraverseChildren(IUnitSetNamespace unitSetNamespace);
    public virtual void TraverseChildren(IUnitNamespaceReference unitNamespaceReference);
    public virtual void TraverseChildren(IUnitReference unitReference);
    public virtual void TraverseChildren(IWin32Resource win32Resource);
    public virtual void TraverseInterfaceImplementationAttributes(INamespaceTypeDefinition namespaceTypeDefinition);
}
public class Microsoft.Cci.MetadataValidator : object {
    protected IAssembly currentAssembly;
    protected IDefinition currentDefinition;
    protected IModule currentModule;
    protected ISecurityAttribute currentSecurityAttribute;
    protected MetadataDocument document;
    protected static IEnumerable`1<ILocation> emptyLocations;
    protected IMetadataHost host;
    private ValidatingTraverser traverser;
    public MetadataValidator(IMetadataHost host);
    protected MetadataValidator(IMetadataHost host, ValidatingTraverser traverser);
    private static MetadataValidator();
    public virtual void Validate(IAssembly assembly);
    private void IntializeDocument(IModule moduleToValidate);
}
public class Microsoft.Cci.MetadataVisitor : object {
    public virtual void Visit(IAliasForType aliasForType);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public virtual void Visit(IAssembly assembly);
    public virtual void Visit(IAssemblyReference assemblyReference);
    public virtual void Visit(ICustomAttribute customAttribute);
    public virtual void Visit(ICustomModifier customModifier);
    public virtual void Visit(IEventDefinition eventDefinition);
    public virtual void Visit(IFieldDefinition fieldDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    public virtual void Visit(IFileReference fileReference);
    public virtual void Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual void Visit(IGenericParameter genericParameter);
    public virtual void Visit(IGenericParameterReference genericParameterReference);
    public virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual void Visit(ILocalDefinition localDefinition);
    public virtual void VisitReference(ILocalDefinition localDefinition);
    public virtual void Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(IMetadataConstant constant);
    public virtual void Visit(IMetadataCreateArray createArray);
    public virtual void Visit(IMetadataExpression expression);
    public virtual void Visit(IMetadataNamedArgument namedArgument);
    public virtual void Visit(IMetadataTypeOf typeOf);
    public virtual void Visit(IMethodBody methodBody);
    public virtual void Visit(IMethodDefinition method);
    public virtual void Visit(IMethodImplementation methodImplementation);
    public virtual void Visit(IMethodReference methodReference);
    public virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public virtual void Visit(IModule module);
    public virtual void Visit(IModuleReference moduleReference);
    public virtual void Visit(INamedTypeDefinition namedTypeDefinition);
    public virtual void Visit(INamedTypeReference namedTypeReference);
    public virtual void Visit(INamespaceAliasForType namespaceAliasForType);
    public virtual void Visit(INamespaceDefinition namespaceDefinition);
    public virtual void Visit(INamespaceMember namespaceMember);
    public virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public virtual void Visit(INestedAliasForType nestedAliasForType);
    public virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public virtual void Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual void Visit(INestedUnitSetNamespace nestedUnitSetNamespace);
    public virtual void Visit(IOperation operation);
    public virtual void Visit(IOperationExceptionInformation operationExceptionInformation);
    public virtual void Visit(IParameterDefinition parameterDefinition);
    public virtual void VisitReference(IParameterDefinition parameterDefinition);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public virtual void Visit(IPESection peSection);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public virtual void Visit(IResourceReference resourceReference);
    public virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public virtual void Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual void Visit(IRootUnitSetNamespace rootUnitSetNamespace);
    public virtual void Visit(ISecurityAttribute securityAttribute);
    public virtual void Visit(ISpecializedEventDefinition specializedEventDefinition);
    public virtual void Visit(ISpecializedFieldDefinition specializedFieldDefinition);
    public virtual void Visit(ISpecializedFieldReference specializedFieldReference);
    public virtual void Visit(ISpecializedMethodDefinition specializedMethodDefinition);
    public virtual void Visit(ISpecializedMethodReference specializedMethodReference);
    public virtual void Visit(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public virtual void Visit(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public virtual void Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual void Visit(ITypeDefinition typeDefinition);
    public virtual void Visit(ITypeDefinitionMember typeMember);
    public virtual void Visit(ITypeMemberReference typeMember);
    public virtual void Visit(ITypeReference typeReference);
    public virtual void Visit(IUnit unit);
    public virtual void Visit(IUnitReference unitReference);
    public virtual void Visit(IUnitNamespace unitNamespace);
    public virtual void Visit(IUnitNamespaceReference unitNamespaceReference);
    public virtual void Visit(IUnitSet unitSet);
    public virtual void Visit(IUnitSetNamespace unitSetNamespace);
    public virtual void Visit(IWin32Resource win32Resource);
}
public class Microsoft.Cci.MethodReference : object {
    private CallingConvention callingConvention;
    private ITypeReference containingType;
    private IEnumerable`1<IParameterTypeInformation> extraParameters;
    private ushort genericParameterCount;
    protected IMetadataHost host;
    private UInt32 internedKey;
    private IName name;
    private ushort parameterCount;
    private IEnumerable`1<IParameterTypeInformation> parameters;
    private IMethodDefinition resolvedMethod;
    private ITypeReference type;
    public bool AcceptsExtraArguments { get; }
    public CallingConvention CallingConvention { get; }
    public ITypeReference ContainingType { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public ushort GenericParameterCount { get; }
    public UInt32 InternedKey { get; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public IName Name { get; }
    public ushort ParameterCount { get; }
    public IEnumerable`1<IParameterTypeInformation> Parameters { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public ITypeReference Type { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsModified { get; }
    private ITypeDefinitionMember Microsoft.Cci.ITypeMemberReference.ResolvedTypeDefinitionMember { get; }
    public MethodReference(IMetadataHost host, ITypeReference containingType, CallingConvention callingConvention, ITypeReference returnType, IName name, ushort genericParameterCount, ITypeReference[] parameterTypes);
    public MethodReference(IMetadataHost host, ITypeReference containingType, CallingConvention callingConvention, ITypeReference returnType, IName name, ushort genericParameterCount, IEnumerable`1<IParameterTypeInformation> parameters, ITypeReference[] extraParameterTypes);
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ITypeReference get_ContainingType();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public sealed virtual IName get_Name();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_Parameters();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsModified();
    private sealed virtual override ITypeDefinitionMember Microsoft.Cci.ITypeMemberReference.get_ResolvedTypeDefinitionMember();
}
internal class Microsoft.Cci.MethodVisitor : object {
    protected IMetadataHost host;
    public MethodVisitor(IMetadataHost host);
    public virtual void VisitAssembly(Assembly assembly);
    public virtual void VisitModule(Module module);
    public virtual void VisitNamespace(UnitNamespace unitNamespace);
    public virtual void VisitType(NamedTypeDefinition typeDef);
    public virtual void VisitMethod(MethodDefinition methodDef, NamedTypeDefinition typeDef);
}
public class Microsoft.Cci.ModuleIdentity : UnitIdentity {
    private AssemblyIdentity containingAssembly;
    public AssemblyIdentity ContainingAssembly { get; }
    public ModuleIdentity(IName name, string location);
    public ModuleIdentity(IName name, string location, AssemblyIdentity containingAssembly);
    public virtual AssemblyIdentity get_ContainingAssembly();
    public virtual bool Equals(object obj);
    internal virtual int ComputeHashCode();
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Microsoft.Cci.ModuleKind : Enum {
    public int value__;
    public static ModuleKind ConsoleApplication;
    public static ModuleKind WindowsApplication;
    public static ModuleKind DynamicallyLinkedLibrary;
    public static ModuleKind ManifestResourceFile;
    public static ModuleKind UnmanagedDynamicallyLinkedLibrary;
}
public class Microsoft.Cci.MutableCodeModel.Addition : BinaryOperation {
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatOperandsAsUnsignedIntegers>k__BackingField;
    public bool CheckOverflow { get; public set; }
    public bool TreatOperandsAsUnsignedIntegers { get; public set; }
    public Addition(IAddition addition);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
public void set_CheckOverflow(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatOperandsAsUnsignedIntegers();
    [CompilerGeneratedAttribute]
public void set_TreatOperandsAsUnsignedIntegers(bool value);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.AddressableExpression : Expression {
    private object definition;
    private IExpression instance;
    public object Definition { get; public set; }
    public IExpression Instance { get; public set; }
    public AddressableExpression(IAddressableExpression addressableExpression);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual object get_Definition();
    public void set_Definition(object value);
    public sealed virtual IExpression get_Instance();
    public void set_Instance(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.AddressDereference : Expression {
    private IExpression address;
    private byte alignment;
    private bool isVolatile;
    public IExpression Address { get; public set; }
    public byte Alignment { get; public set; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; public set; }
    public AddressDereference(IAddressDereference addressDereference);
    public sealed virtual IExpression get_Address();
    public void set_Address(IExpression value);
    public sealed virtual byte get_Alignment();
    public void set_Alignment(byte value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public void set_IsVolatile(bool value);
}
public class Microsoft.Cci.MutableCodeModel.AddressOf : Expression {
    private IAddressableExpression expression;
    private bool objectControlsMutability;
    public IAddressableExpression Expression { get; public set; }
    public bool ObjectControlsMutability { get; public set; }
    public AddressOf(IAddressOf addressOf);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IAddressableExpression get_Expression();
    public void set_Expression(IAddressableExpression value);
    public sealed virtual bool get_ObjectControlsMutability();
    public void set_ObjectControlsMutability(bool value);
}
public abstract class Microsoft.Cci.MutableCodeModel.AliasForType : object {
    private INamedTypeReference aliasedType;
    private List`1<ICustomAttribute> attributes;
    private List`1<ILocation> locations;
    private List`1<IAliasMember> members;
    public INamedTypeReference AliasedType { get; public set; }
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public List`1<IAliasMember> Members { get; public set; }
    private IEnumerable`1<IAliasMember> Microsoft.Cci.IAliasForType.Members { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private IEnumerable`1<IAliasMember> Microsoft.Cci.IContainer<Microsoft.Cci.IAliasMember>.Members { get; }
    private IEnumerable`1<IAliasMember> Microsoft.Cci.IScope<Microsoft.Cci.IAliasMember>.Members { get; }
    public sealed virtual void Copy(IAliasForType aliasForType, IInternFactory internFactory);
    public sealed virtual INamedTypeReference get_AliasedType();
    public void set_AliasedType(INamedTypeReference value);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual bool Contains(IAliasMember member);
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.AliasForType/<GetMatchingMembersNamed>d__13")]
public sealed virtual IEnumerable`1<IAliasMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<IAliasMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.AliasForType/<GetMatchingMembers>d__14")]
public sealed virtual IEnumerable`1<IAliasMember> GetMatchingMembers(Function`2<IAliasMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.AliasForType/<GetMembersNamed>d__15")]
public sealed virtual IEnumerable`1<IAliasMember> GetMembersNamed(IName name, bool ignoreCase);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public List`1<IAliasMember> get_Members();
    public void set_Members(List`1<IAliasMember> value);
    private sealed virtual override IEnumerable`1<IAliasMember> Microsoft.Cci.IAliasForType.get_Members();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
    private sealed virtual override IEnumerable`1<IAliasMember> Microsoft.Cci.IContainer<Microsoft.Cci.IAliasMember>.get_Members();
    private sealed virtual override IEnumerable`1<IAliasMember> Microsoft.Cci.IScope<Microsoft.Cci.IAliasMember>.get_Members();
}
public class Microsoft.Cci.MutableCodeModel.AnonymousDelegate : Expression {
    private IBlockStatement body;
    private CallingConvention callingConvention;
    private List`1<IParameterDefinition> parameters;
    private ITypeReference returnType;
    private List`1<ICustomModifier> returnValueCustomModifiers;
    private bool returnValueIsByRef;
    public IBlockStatement Body { get; public set; }
    public CallingConvention CallingConvention { get; public set; }
    public bool IsStatic { get; }
    public List`1<IParameterDefinition> Parameters { get; public set; }
    public ITypeReference ReturnType { get; public set; }
    public List`1<ICustomModifier> ReturnValueCustomModifiers { get; public set; }
    public bool ReturnValueIsByRef { get; public set; }
    public bool ReturnValueIsModified { get; }
    private IEnumerable`1<IParameterDefinition> Microsoft.Cci.IAnonymousDelegate.Parameters { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private ITypeReference Microsoft.Cci.ISignature.Type { get; }
    public AnonymousDelegate(IAnonymousDelegate anonymousDelegate);
    public sealed virtual IBlockStatement get_Body();
    public void set_Body(IBlockStatement value);
    public sealed virtual CallingConvention get_CallingConvention();
    public void set_CallingConvention(CallingConvention value);
    public sealed virtual bool get_IsStatic();
    public virtual void Dispatch(ICodeVisitor visitor);
    public List`1<IParameterDefinition> get_Parameters();
    public void set_Parameters(List`1<IParameterDefinition> value);
    public sealed virtual ITypeReference get_ReturnType();
    public void set_ReturnType(ITypeReference value);
    public List`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public void set_ReturnValueCustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_ReturnValueIsByRef();
    public void set_ReturnValueIsByRef(bool value);
    public sealed virtual bool get_ReturnValueIsModified();
    private sealed virtual override IEnumerable`1<IParameterDefinition> Microsoft.Cci.IAnonymousDelegate.get_Parameters();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.get_Type();
}
public class Microsoft.Cci.MutableCodeModel.AnonymousDelegateRemover : CodeRewriter {
    private MetadataDeepCopier copier;
    internal List`1<ITypeDefinition> closureClasses;
    private List`1<ITypeDefinitionMember> helperMembers;
    private Dictionary`2<object, bool> scopesWithCapturedLocals;
    private Dictionary`2<object, IFieldReference> fieldReferencesForUseInsideAnonymousMethods;
    private Dictionary`2<object, IFieldReference> fieldReferencesForUseInsideThisMethod;
    private Dictionary`2<ushort, IGenericParameterReference> genericMethodParameterMap;
    private Dictionary`2<IAnonymousDelegate, bool> anonymousDelegatesThatCaptureThis;
    private Dictionary`2<IAnonymousDelegate, bool> anonymousDelegatesThatCaptureLocalsOrParameters;
    private ISourceLocationProvider sourceLocationProvider;
    private NamedTypeDefinition currentClosureClass;
    private ITypeReference currentClosureSelfInstance;
    private ITypeReference currentClosureInstance;
    private IExpression currentClosureObject;
    private ILocalDefinition currentClosureLocal;
    private List`1<IExpression> closureLocalInstances;
    private ICustomAttribute compilerGenerated;
    private int anonymousDelegateCounter;
    private bool isInsideAnonymousMethod;
    private IMethodDefinition method;
    private IMethodReference objectCtor;
    private int popTempCounter;
    public AnonymousDelegateRemover(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public ICollection`1<ITypeDefinition> RemoveAnonymousDelegates(IMethodDefinition method, BlockStatement body);
    private void InsertStatementsToAllocateAndInitializeTopLevelClosure(BlockStatement body);
    private int GetOffsetOfFirstStatementAfterBaseOrThisConstructorCall(List`1<IStatement> list);
    private void GenerateTopLevelClosure();
    private void CreateClosureField(object capturedDefinition, ITypeReference fieldType, ITypeReference typeToUseInThisMethod, string name);
    private void CreateClosureClass();
    private IMethodReference CreateClosureMethod(AnonymousDelegate anonymousDelegate);
    private IExpression GetClosureObjectInstanceContaining(IFieldReference closureField);
    private void MakeDelegateMethodGeneric(MethodDefinition delegateMethod);
    public virtual IExpression Rewrite(IAnonymousDelegate anonymousDelegate);
    private IFieldReference CreateStaticCacheField(ITypeReference fieldType);
    public virtual void RewriteChildren(AddressableExpression addressableExpression);
    public virtual void RewriteChildren(BlockExpression blockExpression);
    public virtual void RewriteChildren(BlockStatement block);
    private void AllocateClosureFor(object scope, List`1<IStatement> statements, Action rewriteScope);
    private IMethodReference GetReferenceToDefaultConstructor(ITypeReference containingType);
    public virtual IExpression Rewrite(IAssignment assignment);
    public virtual void RewriteChildren(BoundExpression boundExpression);
    public virtual void RewriteChildren(CatchClause catchClause);
    public virtual void RewriteChildren(ForEachStatement forEachStatement);
    public virtual void RewriteChildren(GenericMethodInstanceReference genericMethodInstanceReference);
    public virtual ITypeReference Rewrite(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual IStatement Rewrite(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void RewriteChildren(TargetExpression targetExpression);
    public virtual IExpression Rewrite(IThisReference thisReference);
    [CompilerGeneratedAttribute]
private void <>n__0(BlockStatement block);
    [CompilerGeneratedAttribute]
private void <>n__1(CatchClause catchClause);
}
public class Microsoft.Cci.MutableCodeModel.ArrayIndexer : Expression {
    private IExpression indexedObject;
    private List`1<IExpression> indices;
    public IExpression IndexedObject { get; public set; }
    public List`1<IExpression> Indices { get; public set; }
    private IEnumerable`1<IExpression> Microsoft.Cci.IArrayIndexer.Indices { get; }
    public ArrayIndexer(IArrayIndexer arrayIndexer);
    private void ObjectInvariant();
    public sealed virtual IExpression get_IndexedObject();
    public void set_IndexedObject(IExpression value);
    public List`1<IExpression> get_Indices();
    public void set_Indices(List`1<IExpression> value);
    public virtual void Dispatch(ICodeVisitor visitor);
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.IArrayIndexer.get_Indices();
}
public abstract class Microsoft.Cci.MutableCodeModel.ArrayTypeReference : TypeReference {
    private ITypeReference elementType;
    private IArrayType resolvedType;
    public ITypeReference ElementType { get; public set; }
    public bool IsVector { get; }
    public List`1<int> LowerBounds { get; public set; }
    public UInt32 Rank { get; public set; }
    public List`1<ulong> Sizes { get; public set; }
    public ITypeDefinition ResolvedType { get; }
    public IArrayType ResolvedArrayType { get; }
    private IEnumerable`1<int> Microsoft.Cci.IArrayTypeReference.LowerBounds { get; }
    private IEnumerable`1<ulong> Microsoft.Cci.IArrayTypeReference.Sizes { get; }
    private void ObjectInvariant();
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_ElementType();
    public void set_ElementType(ITypeReference value);
    public abstract virtual bool get_IsVector();
    public virtual List`1<int> get_LowerBounds();
    public virtual void set_LowerBounds(List`1<int> value);
    public virtual UInt32 get_Rank();
    public virtual void set_Rank(UInt32 value);
    public virtual List`1<ulong> get_Sizes();
    public virtual void set_Sizes(List`1<ulong> value);
    public virtual ITypeDefinition get_ResolvedType();
    public IArrayType get_ResolvedArrayType();
    protected abstract virtual IArrayType Resolve();
    private sealed virtual override IEnumerable`1<int> Microsoft.Cci.IArrayTypeReference.get_LowerBounds();
    private sealed virtual override IEnumerable`1<ulong> Microsoft.Cci.IArrayTypeReference.get_Sizes();
}
public class Microsoft.Cci.MutableCodeModel.Assembly : Module {
    private List`1<ICustomAttribute> assemblyAttributes;
    private string culture;
    private List`1<IAliasForType> exportedTypes;
    private UInt32 flags;
    private List`1<IFileReference> files;
    private List`1<IModule> memberModules;
    private IName moduleName;
    private List`1<byte> publicKey;
    private List`1<IResourceReference> resources;
    private List`1<ISecurityAttribute> securityAttributes;
    private Version version;
    private AssemblyIdentity assemblyIdentity;
    private IEnumerable`1<byte> hashValue;
    private IEnumerable`1<byte> publicKeyToken;
    public List`1<ICustomAttribute> AssemblyAttributes { get; public set; }
    public IAssembly ContainingAssembly { get; }
    public string Culture { get; public set; }
    public List`1<IAliasForType> ExportedTypes { get; public set; }
    public UInt32 Flags { get; public set; }
    public List`1<IFileReference> Files { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool ContainsForeignTypes { get; public set; }
    public string Location { get; public set; }
    public List`1<IModule> MemberModules { get; public set; }
    public IName ModuleName { get; public set; }
    public ModuleIdentity ModuleIdentity { get; }
    public IName Name { get; public set; }
    public List`1<byte> PublicKey { get; public set; }
    public List`1<IResourceReference> Resources { get; public set; }
    public List`1<ISecurityAttribute> SecurityAttributes { get; public set; }
    public Version Version { get; public set; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IAssembly.AssemblyAttributes { get; }
    private IEnumerable`1<IAliasForType> Microsoft.Cci.IAssembly.ExportedTypes { get; }
    private IEnumerable`1<IResourceReference> Microsoft.Cci.IAssembly.Resources { get; }
    private IEnumerable`1<IFileReference> Microsoft.Cci.IAssembly.Files { get; }
    private IEnumerable`1<IModule> Microsoft.Cci.IAssembly.MemberModules { get; }
    private IEnumerable`1<ISecurityAttribute> Microsoft.Cci.IAssembly.SecurityAttributes { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public AssemblyIdentity AssemblyIdentity { get; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    public IEnumerable`1<IName> Aliases { get; }
    public IAssembly ResolvedAssembly { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.PublicKey { get; }
    public IEnumerable`1<byte> HashValue { get; public set; }
    public IEnumerable`1<byte> PublicKeyToken { get; }
    public sealed virtual void Copy(IAssembly assembly, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_AssemblyAttributes();
    public void set_AssemblyAttributes(List`1<ICustomAttribute> value);
    public virtual IAssembly get_ContainingAssembly();
    public sealed virtual string get_Culture();
    public void set_Culture(string value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<IAliasForType> get_ExportedTypes();
    public void set_ExportedTypes(List`1<IAliasForType> value);
    public sealed virtual UInt32 get_Flags();
    public void set_Flags(UInt32 value);
    public List`1<IFileReference> get_Files();
    public void set_Files(List`1<IFileReference> value);
    public sealed virtual bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public sealed virtual bool get_ContainsForeignTypes();
    public void set_ContainsForeignTypes(bool value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public List`1<IModule> get_MemberModules();
    public void set_MemberModules(List`1<IModule> value);
    public virtual IName get_ModuleName();
    public virtual void set_ModuleName(IName value);
    public virtual ModuleIdentity get_ModuleIdentity();
    public virtual IName get_Name();
    public virtual void set_Name(IName value);
    public List`1<byte> get_PublicKey();
    public void set_PublicKey(List`1<byte> value);
    public List`1<IResourceReference> get_Resources();
    public void set_Resources(List`1<IResourceReference> value);
    public List`1<ISecurityAttribute> get_SecurityAttributes();
    public void set_SecurityAttributes(List`1<ISecurityAttribute> value);
    public sealed virtual Version get_Version();
    public void set_Version(Version value);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IAssembly.get_AssemblyAttributes();
    private sealed virtual override IEnumerable`1<IAliasForType> Microsoft.Cci.IAssembly.get_ExportedTypes();
    private sealed virtual override IEnumerable`1<IResourceReference> Microsoft.Cci.IAssembly.get_Resources();
    private sealed virtual override IEnumerable`1<IFileReference> Microsoft.Cci.IAssembly.get_Files();
    private sealed virtual override IEnumerable`1<IModule> Microsoft.Cci.IAssembly.get_MemberModules();
    private sealed virtual override IEnumerable`1<ISecurityAttribute> Microsoft.Cci.IAssembly.get_SecurityAttributes();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
    public sealed virtual IEnumerable`1<IName> get_Aliases();
    public sealed virtual IAssembly get_ResolvedAssembly();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_PublicKey();
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public void set_HashValue(IEnumerable`1<byte> value);
    public sealed virtual IEnumerable`1<byte> get_PublicKeyToken();
}
public class Microsoft.Cci.MutableCodeModel.AssemblyReference : ModuleReference {
    private List`1<IName> aliases;
    private IAssembly resolvedAssembly;
    private string culture;
    private bool isRetargetable;
    private bool containsForeignTypes;
    private IEnumerable`1<byte> hashValue;
    private IEnumerable`1<byte> publicKey;
    private List`1<byte> publicKeyToken;
    private Version version;
    private string location;
    private AssemblyIdentity assemblyIdentity;
    private AssemblyIdentity unifiedAssemblyIdentity;
    public List`1<IName> Aliases { get; public set; }
    public IAssembly ResolvedAssembly { get; public set; }
    public string Culture { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool ContainsForeignTypes { get; public set; }
    public IEnumerable`1<byte> HashValue { get; public set; }
    public IEnumerable`1<byte> PublicKey { get; public set; }
    public List`1<byte> PublicKeyToken { get; public set; }
    public Version Version { get; public set; }
    public string Location { get; public set; }
    public AssemblyIdentity AssemblyIdentity { get; public set; }
    public AssemblyIdentity UnifiedAssemblyIdentity { get; }
    private IEnumerable`1<IName> Microsoft.Cci.IAssemblyReference.Aliases { get; }
    private IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.PublicKeyToken { get; }
    public sealed virtual void Copy(IAssemblyReference assemblyReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<IName> get_Aliases();
    public void set_Aliases(List`1<IName> value);
    protected virtual IModule Resolve();
    private IAssembly ResolveAssembly();
    public sealed virtual IAssembly get_ResolvedAssembly();
    public void set_ResolvedAssembly(IAssembly value);
    public sealed virtual string get_Culture();
    public void set_Culture(string value);
    public sealed virtual bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public sealed virtual bool get_ContainsForeignTypes();
    public void set_ContainsForeignTypes(bool value);
    public sealed virtual IEnumerable`1<byte> get_HashValue();
    public void set_HashValue(IEnumerable`1<byte> value);
    public sealed virtual IEnumerable`1<byte> get_PublicKey();
    public void set_PublicKey(IEnumerable`1<byte> value);
    public List`1<byte> get_PublicKeyToken();
    public void set_PublicKeyToken(List`1<byte> value);
    public sealed virtual Version get_Version();
    public void set_Version(Version value);
    public string get_Location();
    public void set_Location(string value);
    public sealed virtual AssemblyIdentity get_AssemblyIdentity();
    public void set_AssemblyIdentity(AssemblyIdentity value);
    public sealed virtual AssemblyIdentity get_UnifiedAssemblyIdentity();
    private sealed virtual override IEnumerable`1<IName> Microsoft.Cci.IAssemblyReference.get_Aliases();
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IAssemblyReference.get_PublicKeyToken();
}
public class Microsoft.Cci.MutableCodeModel.AssertStatement : Statement {
    private IExpression condition;
    private bool hasBeenVerified;
    private IExpression description;
    private string conditionAsText;
    public IExpression Condition { get; public set; }
    public bool HasBeenVerified { get; public set; }
    public IExpression Description { get; public set; }
    public string OriginalSource { get; public set; }
    public AssertStatement(IAssertStatement assertStatement);
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_HasBeenVerified();
    public void set_HasBeenVerified(bool value);
    public sealed virtual IExpression get_Description();
    public void set_Description(IExpression value);
    public sealed virtual string get_OriginalSource();
    public void set_OriginalSource(string value);
}
public class Microsoft.Cci.MutableCodeModel.Assignment : Expression {
    private IExpression source;
    private ITargetExpression target;
    public IExpression Source { get; public set; }
    public ITargetExpression Target { get; public set; }
    public Assignment(IAssignment assignment);
    private void ObjectInvariant();
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Source();
    public void set_Source(IExpression value);
    public sealed virtual ITargetExpression get_Target();
    public void set_Target(ITargetExpression value);
}
public class Microsoft.Cci.MutableCodeModel.AssumeStatement : Statement {
    private IExpression condition;
    private IExpression description;
    private string conditionAsText;
    public IExpression Condition { get; public set; }
    public IExpression Description { get; public set; }
    public string OriginalSource { get; public set; }
    public AssumeStatement(IAssumeStatement assumeStatement);
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Description();
    public void set_Description(IExpression value);
    public sealed virtual string get_OriginalSource();
    public void set_OriginalSource(string value);
}
public abstract class Microsoft.Cci.MutableCodeModel.BinaryOperation : Expression {
    private IExpression leftOperand;
    private IExpression rightOperand;
    private bool resultIsUnmodifiedLeftOperand;
    public IExpression LeftOperand { get; public set; }
    public IExpression RightOperand { get; public set; }
    public bool ResultIsUnmodifiedLeftOperand { get; public set; }
    internal BinaryOperation(IBinaryOperation binaryOperation);
    private void ObjectInvariant();
    public sealed virtual IExpression get_LeftOperand();
    public void set_LeftOperand(IExpression value);
    public sealed virtual IExpression get_RightOperand();
    public void set_RightOperand(IExpression value);
    public sealed virtual bool get_ResultIsUnmodifiedLeftOperand();
    public void set_ResultIsUnmodifiedLeftOperand(bool value);
}
public class Microsoft.Cci.MutableCodeModel.BitwiseAnd : BinaryOperation {
    public BitwiseAnd(IBitwiseAnd bitwiseAnd);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.BitwiseOr : BinaryOperation {
    public BitwiseOr(IBitwiseOr bitwiseOr);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.BlockExpression : Expression {
    private IBlockStatement blockStatement;
    private IExpression expression;
    public IBlockStatement BlockStatement { get; public set; }
    public IExpression Expression { get; public set; }
    public BlockExpression(IBlockExpression blockExpression);
    public sealed virtual IBlockStatement get_BlockStatement();
    public void set_BlockStatement(IBlockStatement value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Expression();
    public void set_Expression(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.BlockStatement : Statement {
    private List`1<IStatement> statements;
    private bool useCheckedArithmetic;
    public List`1<IStatement> Statements { get; public set; }
    public bool UseCheckedArithmetic { get; public set; }
    private IEnumerable`1<IStatement> Microsoft.Cci.IBlockStatement.Statements { get; }
    public BlockStatement(IBlockStatement blockStatement);
    private void ObjectInvariant();
    public virtual void Dispatch(ICodeVisitor visitor);
    public List`1<IStatement> get_Statements();
    public void set_Statements(List`1<IStatement> value);
    public sealed virtual bool get_UseCheckedArithmetic();
    public void set_UseCheckedArithmetic(bool value);
    private sealed virtual override IEnumerable`1<IStatement> Microsoft.Cci.IBlockStatement.get_Statements();
}
public class Microsoft.Cci.MutableCodeModel.BoundExpression : Expression {
    private byte alignment;
    private object definition;
    private IExpression instance;
    private bool isVolatile;
    public byte Alignment { get; public set; }
    public object Definition { get; public set; }
    public IExpression Instance { get; public set; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; public set; }
    public BoundExpression(IBoundExpression boundExpression);
    public sealed virtual byte get_Alignment();
    public void set_Alignment(byte value);
    public sealed virtual object get_Definition();
    public void set_Definition(object value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Instance();
    public void set_Instance(IExpression value);
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public void set_IsVolatile(bool value);
}
internal class Microsoft.Cci.MutableCodeModel.BoundField : Expression {
    private FieldDefinition field;
    public byte Alignment { get; }
    public object Definition { get; }
    public FieldDefinition Field { get; }
    public IExpression Instance { get; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; }
    public BoundField(FieldDefinition field, ITypeReference type);
    public sealed virtual byte get_Alignment();
    public sealed virtual object get_Definition();
    public FieldDefinition get_Field();
    public sealed virtual IExpression get_Instance();
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.BreakStatement : Statement {
    public BreakStatement(IBreakStatement breakStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
}
internal class Microsoft.Cci.MutableCodeModel.CapturedParameterAndLocalFinder : CodeTraverser {
    internal Dictionary`2<object, IFieldReference> captures;
    internal Dictionary`2<IAnonymousDelegate, bool> anonymousDelegatesThatCaptureThis;
    internal Dictionary`2<IAnonymousDelegate, bool> anonymousDelegatesThatCaptureLocalsOrParameters;
    private IAnonymousDelegate currentAnonymousDelegate;
    private Dictionary`2<object, bool> definitionsToIgnore;
    public virtual void TraverseChildren(IAnonymousDelegate anonymousDelegate);
    public virtual void TraverseChildren(IAddressableExpression addressableExpression);
    public virtual void TraverseChildren(IBoundExpression boundExpression);
    public virtual void TraverseChildren(ICatchClause catchClause);
    public virtual void TraverseChildren(IForEachStatement forEachStatement);
    public virtual void TraverseChildren(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void TraverseChildren(ITargetExpression targetExpression);
    public virtual void TraverseChildren(IThisReference thisReference);
    private void LookForCapturedDefinition(object definition);
}
public class Microsoft.Cci.MutableCodeModel.CastIfPossible : Expression {
    private ITypeReference targetType;
    private IExpression valueToCast;
    public ITypeReference TargetType { get; public set; }
    public IExpression ValueToCast { get; public set; }
    public CastIfPossible(ICastIfPossible castIfPossible);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_TargetType();
    public void set_TargetType(ITypeReference value);
    public sealed virtual IExpression get_ValueToCast();
    public void set_ValueToCast(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.CatchClause : object {
    private IBlockStatement body;
    private ILocalDefinition exceptionContainer;
    private ITypeReference exceptionType;
    private IExpression filterCondition;
    private List`1<ILocation> locations;
    public IBlockStatement Body { get; public set; }
    public ILocalDefinition ExceptionContainer { get; public set; }
    public ITypeReference ExceptionType { get; public set; }
    public IExpression FilterCondition { get; public set; }
    public IList`1<ILocation> Locations { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public CatchClause(ICatchClause catchClause);
    public sealed virtual IBlockStatement get_Body();
    public void set_Body(IBlockStatement value);
    public void Dispatch(ICodeVisitor visitor);
    public sealed virtual ILocalDefinition get_ExceptionContainer();
    public void set_ExceptionContainer(ILocalDefinition value);
    public sealed virtual ITypeReference get_ExceptionType();
    public void set_ExceptionType(ITypeReference value);
    public sealed virtual IExpression get_FilterCondition();
    public void set_FilterCondition(IExpression value);
    public IList`1<ILocation> get_Locations();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.CheckIfInstance : Expression {
    private IExpression operand;
    private ITypeReference type;
    public IExpression Operand { get; public set; }
    public ITypeReference TypeToCheck { get; public set; }
    public CheckIfInstance(ICheckIfInstance checkIfInstance);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Operand();
    public void set_Operand(IExpression value);
    public sealed virtual ITypeReference get_TypeToCheck();
    public void set_TypeToCheck(ITypeReference value);
}
internal class Microsoft.Cci.MutableCodeModel.ClosureFinder : CodeTraverser {
    internal Dictionary`2<IAnonymousDelegate, MethodDefinition> lambda2method;
    internal Dictionary`2<object, BoundField> fieldForCapturedLocalOrParameter;
    private Dictionary`2<INamedEntity, NestedTypeDefinition> localOrParameter2ClosureClass;
    private Dictionary`2<INamedEntity, bool> localsOrParametersInScope;
    internal List`1<INamedTypeDefinition> classList;
    internal List`1<FieldDefinition> outerClosures;
    private IMethodDefinition method;
    private IMetadataHost host;
    private INameTable nameTable;
    internal bool foundYield;
    internal NestedTypeDefinition generatedclosureClass;
    internal Dictionary`2<UInt32, IGenericTypeParameter> genericTypeParameterMapping;
    private CopyTypeFromIteratorToClosure copyTypeToClosure;
    private int counter;
    private IMethodReference compilerGeneratedCtor;
    private IMethodReference CompilerGeneratedCtor { get; }
    internal ClosureFinder(IMethodDefinition method, IMetadataHost host);
    private IMethodReference get_CompilerGeneratedCtor();
    private void CaptureDefinition(object definition);
    private NestedTypeDefinition CreateClosureClass(bool makeGeneric);
    public virtual void TraverseChildren(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void TraverseChildren(IYieldBreakStatement yieldBreakStatement);
    public virtual void TraverseChildren(IYieldReturnStatement yieldReturnStatement);
}
[ObsoleteAttribute("Please use CodeDeepCopier or CodeShallowCopier")]
public class Microsoft.Cci.MutableCodeModel.CodeCopier : MetadataCopier {
    private CreateMutableType createMutableType;
    protected ISourceLocationProvider sourceLocationProvider;
    public CodeCopier(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public CodeCopier(IMetadataHost host, ISourceLocationProvider sourceLocationProvider, IDefinition rootOfCone, List`1& newTypes);
    protected virtual void VisitPrivateHelperMembers(List`1<INamedTypeDefinition> typeDefinitions);
    public virtual IExpression Substitute(IExpression expression);
    public virtual IStatement Substitute(IStatement statement);
    public virtual IMethodBody Substitute(IMethodBody methodBody);
    public virtual List`1<IStatement> Substitute(List`1<IStatement> statements);
    protected virtual List`1<IStatement> DeepCopy(List`1<IStatement> statements);
    protected virtual IExpression DeepCopy(Addition addition);
    protected virtual IAddressableExpression DeepCopy(AddressableExpression addressableExpression);
    protected virtual IExpression DeepCopy(AddressDereference addressDereference);
    protected virtual IExpression DeepCopy(AddressOf addressOf);
    protected virtual IExpression DeepCopy(AnonymousDelegate anonymousDelegate);
    private ParameterDefinition GetMutableCopyParamAnonymDeleg(IParameterDefinition parameterDefinition);
    protected virtual IExpression DeepCopy(ArrayIndexer arrayIndexer);
    protected virtual IStatement DeepCopy(AssertStatement assertStatement);
    protected virtual IExpression DeepCopy(Assignment assignment);
    protected virtual IStatement DeepCopy(AssumeStatement assumeStatement);
    protected virtual IExpression DeepCopy(BitwiseAnd bitwiseAnd);
    protected virtual IExpression DeepCopy(BitwiseOr bitwiseOr);
    protected virtual IExpression DeepCopy(BinaryOperation binaryOperation);
    protected virtual IExpression DeepCopy(BlockExpression blockExpression);
    protected virtual IBlockStatement DeepCopy(BlockStatement blockStatement);
    protected virtual IExpression DeepCopy(BoundExpression boundExpression);
    protected virtual IStatement DeepCopy(BreakStatement breakStatement);
    protected virtual IExpression DeepCopy(CastIfPossible castIfPossible);
    protected virtual ICatchClause DeepCopy(CatchClause catchClause);
    protected virtual IExpression DeepCopy(CheckIfInstance checkIfInstance);
    protected virtual ICompileTimeConstant DeepCopy(CompileTimeConstant constant);
    protected virtual IExpression DeepCopy(Conversion conversion);
    protected virtual IExpression DeepCopy(Conditional conditional);
    protected virtual IStatement DeepCopy(ConditionalStatement conditionalStatement);
    protected virtual IStatement DeepCopy(ContinueStatement continueStatement);
    protected virtual IStatement DeepCopy(CopyMemoryStatement copyMemoryStatement);
    protected virtual IExpression DeepCopy(CreateArray createArray);
    protected virtual IExpression DeepCopy(CreateObjectInstance createObjectInstance);
    protected virtual IExpression DeepCopy(CreateDelegateInstance createDelegateInstance);
    protected virtual IExpression DeepCopy(DefaultValue defaultValue);
    protected virtual IStatement DeepCopy(DebuggerBreakStatement debuggerBreakStatement);
    protected virtual IExpression DeepCopy(Division division);
    protected virtual IStatement DeepCopy(DoUntilStatement doUntilStatement);
    protected virtual IExpression DeepCopy(DupValue dupValue);
    protected virtual IStatement DeepCopy(EmptyStatement emptyStatement);
    protected virtual IExpression DeepCopy(Equality equality);
    protected virtual IExpression DeepCopy(ExclusiveOr exclusiveOr);
    protected virtual List`1<IExpression> DeepCopy(List`1<IExpression> expressions);
    protected virtual IStatement DeepCopy(ExpressionStatement expressionStatement);
    protected virtual IStatement DeepCopy(FillMemoryStatement fillMemoryStatement);
    protected virtual IStatement DeepCopy(ForEachStatement forEachStatement);
    protected virtual IStatement DeepCopy(ForStatement forStatement);
    protected virtual IExpression DeepCopy(GetTypeOfTypedReference getTypeOfTypedReference);
    protected virtual IExpression DeepCopy(GetValueOfTypedReference getValueOfTypedReference);
    protected virtual IStatement DeepCopy(GotoStatement gotoStatement);
    protected virtual IStatement DeepCopy(GotoSwitchCaseStatement gotoSwitchCaseStatement);
    protected virtual IExpression DeepCopy(GreaterThan greaterThan);
    protected virtual IExpression DeepCopy(GreaterThanOrEqual greaterThanOrEqual);
    protected virtual IStatement DeepCopy(LabeledStatement labeledStatement);
    protected virtual IExpression DeepCopy(LeftShift leftShift);
    protected virtual IExpression DeepCopy(LessThan lessThan);
    protected virtual IExpression DeepCopy(LessThanOrEqual lessThanOrEqual);
    protected virtual IStatement DeepCopy(LocalDeclarationStatement localDeclarationStatement);
    public virtual ILocalDefinition Substitute(ILocalDefinition localDefinition);
    protected virtual LocalDefinition DeepCopy(LocalDefinition localDefinition);
    protected virtual LocalDefinition GetMutableCopy(ILocalDefinition localDefinition);
    protected virtual IStatement DeepCopy(LockStatement lockStatement);
    protected virtual IExpression DeepCopy(LogicalNot logicalNot);
    protected virtual IExpression DeepCopy(MakeTypedReference makeTypedReference);
    protected virtual IExpression DeepCopy(MethodCall methodCall);
    protected virtual IExpression DeepCopy(Modulus modulus);
    protected virtual IExpression DeepCopy(Multiplication multiplication);
    protected virtual IExpression DeepCopy(NamedArgument namedArgument);
    protected virtual IExpression DeepCopy(NotEquality notEquality);
    protected virtual IExpression DeepCopy(OldValue oldValue);
    protected virtual IExpression DeepCopy(OnesComplement onesComplement);
    protected virtual IExpression DeepCopy(UnaryOperation unaryOperation);
    protected virtual IExpression DeepCopy(OutArgument outArgument);
    protected virtual IExpression DeepCopy(PointerCall pointerCall);
    protected virtual IExpression DeepCopy(PopValue popValue);
    protected virtual IStatement DeepCopy(PushStatement pushStatement);
    protected virtual IExpression DeepCopy(RefArgument refArgument);
    protected virtual IStatement DeepCopy(ResourceUseStatement resourceUseStatement);
    protected virtual IStatement DeepCopy(RethrowStatement rethrowStatement);
    protected virtual IStatement DeepCopy(ReturnStatement returnStatement);
    protected virtual IExpression DeepCopy(ReturnValue returnValue);
    protected virtual IExpression DeepCopy(RightShift rightShift);
    protected virtual IExpression DeepCopy(RuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    protected virtual IExpression DeepCopy(SizeOf sizeOf);
    protected virtual IExpression DeepCopy(StackArrayCreate stackArrayCreate);
    protected virtual IExpression DeepCopy(Subtraction subtraction);
    protected virtual List`1<ISwitchCase> DeepCopy(List`1<ISwitchCase> switchCases);
    public virtual SwitchCase GetMutableCopy(ISwitchCase swithCase);
    protected virtual ISwitchCase DeepCopy(SwitchCase switchCase);
    protected virtual IStatement DeepCopy(SwitchStatement switchStatement);
    protected virtual ITargetExpression DeepCopy(TargetExpression targetExpression);
    private IPropertyDefinition GetMutableCopyIfExists(IPropertyDefinition propertyDefinition);
    protected virtual IExpression DeepCopy(ThisReference thisReference);
    protected virtual IStatement DeepCopy(ThrowStatement throwStatement);
    protected virtual IStatement DeepCopy(TryCatchFinallyStatement tryCatchFilterFinallyStatement);
    protected List`1<ICatchClause> DeepCopy(List`1<ICatchClause> catchClauses);
    protected virtual CatchClause GetMutableCopy(ICatchClause catchClause);
    protected virtual IExpression DeepCopy(TokenOf tokenOf);
    protected virtual IExpression DeepCopy(TypeOf typeOf);
    protected virtual IExpression DeepCopy(UnaryNegation unaryNegation);
    protected virtual IExpression DeepCopy(UnaryPlus unaryPlus);
    protected virtual IExpression DeepCopy(VectorLength vectorLength);
    protected virtual IStatement DeepCopy(WhileDoStatement whileDoStatement);
    protected virtual IStatement DeepCopy(YieldBreakStatement yieldBreakStatement);
    protected virtual IStatement DeepCopy(YieldReturnStatement yieldReturnStatement);
}
public class Microsoft.Cci.MutableCodeModel.CodeDeepCopier : MetadataDeepCopier {
    private CodeShallowCopier shallowCopier;
    private CodeDispatcher dispatcher;
    private Dictionary`2<ILocalDefinition, ILocalDefinition> localsInsideCone;
    private CodeDispatcher Dispatcher { get; }
    private Dictionary`2<ILocalDefinition, ILocalDefinition> LocalsInsideCone { get; }
    public CodeDeepCopier(IMetadataHost targetHost, ISourceLocationProvider sourceLocationProvider, ILocalScopeProvider localScopeProvider);
    public CodeDeepCopier(IMetadataHost targetHost, IUnit targetUnit, ISourceLocationProvider sourceLocationProvider);
    protected CodeDeepCopier(IMetadataHost targetHost, CodeShallowCopier shallowCopier);
    private CodeDispatcher get_Dispatcher();
    private Dictionary`2<ILocalDefinition, ILocalDefinition> get_LocalsInsideCone();
    private IFieldReference Copy(IFieldReference fieldReference);
    private IMethodReference Copy(IMethodReference methodReference);
    private ITypeReference Copy(ITypeReference typeReference);
    public Addition Copy(IAddition addition);
    public AddressableExpression Copy(IAddressableExpression addressableExpression);
    public AddressDereference Copy(IAddressDereference addressDereference);
    public AddressOf Copy(IAddressOf addressOf);
    public AnonymousDelegate Copy(IAnonymousDelegate anonymousDelegate);
    public ArrayIndexer Copy(IArrayIndexer arrayIndexer);
    public AssertStatement Copy(IAssertStatement assertStatement);
    public Assignment Copy(IAssignment assignment);
    public AssumeStatement Copy(IAssumeStatement assumeStatement);
    public BitwiseAnd Copy(IBitwiseAnd bitwiseAnd);
    public BitwiseOr Copy(IBitwiseOr bitwiseOr);
    public BlockExpression Copy(IBlockExpression blockExpression);
    public BlockStatement Copy(IBlockStatement block);
    public BreakStatement Copy(IBreakStatement breakStatement);
    public BoundExpression Copy(IBoundExpression boundExpression);
    public CastIfPossible Copy(ICastIfPossible castIfPossible);
    public CatchClause Copy(ICatchClause catchClause);
    public CheckIfInstance Copy(ICheckIfInstance checkIfInstance);
    public CompileTimeConstant Copy(ICompileTimeConstant constant);
    public Conversion Copy(IConversion conversion);
    public Conditional Copy(IConditional conditional);
    public ConditionalStatement Copy(IConditionalStatement conditionalStatement);
    public ContinueStatement Copy(IContinueStatement continueStatement);
    public CopyMemoryStatement Copy(ICopyMemoryStatement copyMemoryStatement);
    public CreateArray Copy(ICreateArray createArray);
    public CreateObjectInstance Copy(ICreateObjectInstance createObjectInstance);
    public CreateDelegateInstance Copy(ICreateDelegateInstance createDelegateInstance);
    public DebuggerBreakStatement Copy(IDebuggerBreakStatement debuggerBreakStatement);
    public DefaultValue Copy(IDefaultValue defaultValue);
    public Division Copy(IDivision division);
    public DoUntilStatement Copy(IDoUntilStatement doUntilStatement);
    public DupValue Copy(IDupValue dupValue);
    public EmptyStatement Copy(IEmptyStatement emptyStatement);
    public Equality Copy(IEquality equality);
    public ExclusiveOr Copy(IExclusiveOr exclusiveOr);
    public Expression Copy(IExpression expression);
    public ExpressionStatement Copy(IExpressionStatement expressionStatement);
    public FillMemoryStatement Copy(IFillMemoryStatement fillMemoryStatement);
    public ForEachStatement Copy(IForEachStatement forEachStatement);
    public ForStatement Copy(IForStatement forStatement);
    public GetTypeOfTypedReference Copy(IGetTypeOfTypedReference getTypeOfTypedReference);
    public GetValueOfTypedReference Copy(IGetValueOfTypedReference getValueOfTypedReference);
    public GotoStatement Copy(IGotoStatement gotoStatement);
    public GotoSwitchCaseStatement Copy(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public GreaterThan Copy(IGreaterThan greaterThan);
    public GreaterThanOrEqual Copy(IGreaterThanOrEqual greaterThanOrEqual);
    public LabeledStatement Copy(ILabeledStatement labeledStatement);
    public LeftShift Copy(ILeftShift leftShift);
    public LessThan Copy(ILessThan lessThan);
    public LessThanOrEqual Copy(ILessThanOrEqual lessThanOrEqual);
    public LocalDeclarationStatement Copy(ILocalDeclarationStatement localDeclarationStatement);
    public LockStatement Copy(ILockStatement lockStatement);
    public LogicalNot Copy(ILogicalNot logicalNot);
    public MakeTypedReference Copy(IMakeTypedReference makeTypedReference);
    public MethodCall Copy(IMethodCall methodCall);
    public Modulus Copy(IModulus modulus);
    public Multiplication Copy(IMultiplication multiplication);
    public NamedArgument Copy(INamedArgument namedArgument);
    public NotEquality Copy(INotEquality notEquality);
    public OldValue Copy(IOldValue oldValue);
    public OnesComplement Copy(IOnesComplement onesComplement);
    public OutArgument Copy(IOutArgument outArgument);
    public PointerCall Copy(IPointerCall pointerCall);
    public PopValue Copy(IPopValue popValue);
    public PushStatement Copy(IPushStatement pushStatement);
    public RefArgument Copy(IRefArgument refArgument);
    public ResourceUseStatement Copy(IResourceUseStatement resourceUseStatement);
    public RethrowStatement Copy(IRethrowStatement rethrowStatement);
    public ReturnStatement Copy(IReturnStatement returnStatement);
    public ReturnValue Copy(IReturnValue returnValue);
    public RightShift Copy(IRightShift rightShift);
    public StackArrayCreate Copy(IStackArrayCreate stackArrayCreate);
    public RuntimeArgumentHandleExpression Copy(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public SizeOf Copy(ISizeOf sizeOf);
    public SourceMethodBody Copy(ISourceMethodBody sourceMethodBody);
    private SourceMethodBody Copy(ISourceMethodBody sourceMethodBody, IMethodDefinition method);
    public Statement Copy(IStatement statement);
    public Subtraction Copy(ISubtraction subtraction);
    public SwitchCase Copy(ISwitchCase switchCase);
    public SwitchStatement Copy(ISwitchStatement switchStatement);
    public TargetExpression Copy(ITargetExpression targetExpression);
    public ThisReference Copy(IThisReference thisReference);
    public ThrowStatement Copy(IThrowStatement throwStatement);
    public TryCatchFinallyStatement Copy(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public TokenOf Copy(ITokenOf tokenOf);
    public TypeOf Copy(ITypeOf typeOf);
    public UnaryNegation Copy(IUnaryNegation unaryNegation);
    public UnaryPlus Copy(IUnaryPlus unaryPlus);
    public VectorLength Copy(IVectorLength vectorLength);
    public WhileDoStatement Copy(IWhileDoStatement whileDoStatement);
    public YieldBreakStatement Copy(IYieldBreakStatement yieldBreakStatement);
    public YieldReturnStatement Copy(IYieldReturnStatement yieldReturnStatement);
    public virtual List`1<ICatchClause> Copy(List`1<ICatchClause> catchClauses);
    public virtual List`1<IExpression> Copy(List`1<IExpression> expressions);
    public virtual List`1<ISwitchCase> Copy(List`1<ISwitchCase> switchCases);
    public virtual List`1<IStatement> Copy(List`1<IStatement> statements);
    public virtual List`1<IParameterDefinition> Copy(List`1<IParameterDefinition> parameters);
    public virtual List`1<ICustomModifier> Copy(List`1<ICustomModifier> customModifiers);
    private void CopyChildren(BinaryOperation binaryOperation);
    private void CopyChildren(Expression expression);
    private void CopyChildren(UnaryOperation unaryOperation);
    protected virtual IMethodBody CopyMethodBody(IMethodBody methodBody, IMethodDefinition method);
    public ILocalDefinition GetExistingCopyIfInsideCone(ILocalDefinition local);
}
[ObsoleteAttribute("Please use CodeRewriter")]
public class Microsoft.Cci.MutableCodeModel.CodeMutatingVisitor : MutatingVisitor {
    private CreateMutableType createMutableType;
    protected ISourceLocationProvider sourceLocationProvider;
    public CodeMutatingVisitor(IMetadataHost host);
    public CodeMutatingVisitor(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public virtual IExpression Visit(Addition addition);
    public virtual IAddressableExpression Visit(AddressableExpression addressableExpression);
    public virtual IExpression Visit(AddressDereference addressDereference);
    public virtual IExpression Visit(AddressOf addressOf);
    public virtual IExpression Visit(AnonymousDelegate anonymousDelegate);
    public virtual IExpression Visit(ArrayIndexer arrayIndexer);
    public virtual IStatement Visit(AssertStatement assertStatement);
    public virtual IExpression Visit(Assignment assignment);
    public virtual IStatement Visit(AssumeStatement assumeStatement);
    public virtual IExpression Visit(BitwiseAnd bitwiseAnd);
    public virtual IExpression Visit(BitwiseOr bitwiseOr);
    public virtual IExpression Visit(BinaryOperation binaryOperation);
    public virtual IExpression Visit(BlockExpression blockExpression);
    public virtual IBlockStatement Visit(BlockStatement blockStatement);
    public virtual IExpression Visit(BoundExpression boundExpression);
    public virtual IStatement Visit(BreakStatement breakStatement);
    public virtual IExpression Visit(CastIfPossible castIfPossible);
    public virtual List`1<ICatchClause> Visit(List`1<CatchClause> catchClauses);
    public virtual ICatchClause Visit(CatchClause catchClause);
    public virtual IExpression Visit(CheckIfInstance checkIfInstance);
    public virtual ICompileTimeConstant Visit(CompileTimeConstant constant);
    public virtual IExpression Visit(Conversion conversion);
    public virtual IExpression Visit(Conditional conditional);
    public virtual IStatement Visit(ConditionalStatement conditionalStatement);
    public virtual IStatement Visit(ContinueStatement continueStatement);
    public virtual IStatement Visit(CopyMemoryStatement copyMemoryStatement);
    public virtual IExpression Visit(CreateArray createArray);
    public virtual IExpression Visit(CreateObjectInstance createObjectInstance);
    public virtual IExpression Visit(CreateDelegateInstance createDelegateInstance);
    public virtual IExpression Visit(DefaultValue defaultValue);
    public virtual IStatement Visit(DebuggerBreakStatement debuggerBreakStatement);
    public virtual IExpression Visit(Division division);
    public virtual IStatement Visit(DoUntilStatement doUntilStatement);
    public virtual IExpression Visit(DupValue dupValue);
    public virtual IStatement Visit(EmptyStatement emptyStatement);
    public virtual IExpression Visit(Equality equality);
    public virtual IExpression Visit(ExclusiveOr exclusiveOr);
    public virtual List`1<IExpression> Visit(List`1<IExpression> expressions);
    public virtual IStatement Visit(ExpressionStatement expressionStatement);
    public virtual IStatement Visit(FillMemoryStatement fillMemoryStatement);
    public virtual IStatement Visit(ForEachStatement forEachStatement);
    public virtual IStatement Visit(ForStatement forStatement);
    public virtual IExpression Visit(GetTypeOfTypedReference getTypeOfTypedReference);
    public virtual IExpression Visit(GetValueOfTypedReference getValueOfTypedReference);
    public virtual IStatement Visit(GotoStatement gotoStatement);
    public virtual IStatement Visit(GotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual IExpression Visit(GreaterThan greaterThan);
    public virtual IExpression Visit(GreaterThanOrEqual greaterThanOrEqual);
    public virtual IStatement Visit(LabeledStatement labeledStatement);
    public virtual IExpression Visit(LeftShift leftShift);
    public virtual IExpression Visit(LessThan lessThan);
    public virtual IExpression Visit(LessThanOrEqual lessThanOrEqual);
    public virtual IStatement Visit(LocalDeclarationStatement localDeclarationStatement);
    public virtual IStatement Visit(LockStatement lockStatement);
    public virtual IExpression Visit(LogicalNot logicalNot);
    public virtual IExpression Visit(MakeTypedReference makeTypedReference);
    public virtual IMethodBody Visit(IMethodBody methodBody);
    public virtual IExpression Visit(MethodCall methodCall);
    public virtual IExpression Visit(Modulus modulus);
    public virtual IExpression Visit(Multiplication multiplication);
    public virtual IExpression Visit(NamedArgument namedArgument);
    public virtual IExpression Visit(NotEquality notEquality);
    public virtual IExpression Visit(OldValue oldValue);
    public virtual IExpression Visit(OnesComplement onesComplement);
    public virtual IExpression Visit(UnaryOperation unaryOperation);
    public virtual IExpression Visit(OutArgument outArgument);
    public virtual IExpression Visit(PointerCall pointerCall);
    public virtual IExpression Visit(PopValue popValue);
    public virtual IStatement Visit(PushStatement pushStatement);
    public virtual IExpression Visit(RefArgument refArgument);
    public virtual IStatement Visit(ResourceUseStatement resourceUseStatement);
    public virtual IStatement Visit(RethrowStatement rethrowStatement);
    public virtual IStatement Visit(ReturnStatement returnStatement);
    public virtual IExpression Visit(ReturnValue returnValue);
    public virtual IExpression Visit(RightShift rightShift);
    public virtual IExpression Visit(RuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual IExpression Visit(SizeOf sizeOf);
    public virtual IExpression Visit(StackArrayCreate stackArrayCreate);
    public virtual IExpression Visit(Subtraction subtraction);
    public virtual List`1<ISwitchCase> Visit(List`1<SwitchCase> switchCases);
    public virtual ISwitchCase Visit(SwitchCase switchCase);
    public virtual IStatement Visit(SwitchStatement switchStatement);
    public virtual ITargetExpression Visit(TargetExpression targetExpression);
    public virtual IExpression Visit(ThisReference thisReference);
    public virtual IStatement Visit(ThrowStatement throwStatement);
    public virtual IStatement Visit(TryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual IExpression Visit(TokenOf tokenOf);
    public virtual IExpression Visit(TypeOf typeOf);
    public virtual IExpression Visit(UnaryNegation unaryNegation);
    public virtual IExpression Visit(UnaryPlus unaryPlus);
    public virtual IExpression Visit(VectorLength vectorLength);
    public virtual IStatement Visit(WhileDoStatement whileDoStatement);
    public virtual IStatement Visit(YieldBreakStatement yieldBreakStatement);
    public virtual IStatement Visit(YieldReturnStatement yieldReturnStatement);
    public virtual IAddressableExpression Visit(IAddressableExpression addressableExpression);
    public virtual IBlockStatement Visit(IBlockStatement blockStatement);
    public virtual ICatchClause Visit(ICatchClause catchClause);
    public virtual List`1<ICatchClause> Visit(List`1<ICatchClause> catchClauses);
    public virtual ICompileTimeConstant Visit(ICompileTimeConstant compileTimeConstant);
    public virtual IExpression Visit(IExpression expression);
    public virtual IStatement Visit(IStatement statement);
    public virtual List`1<IStatement> Visit(List`1<IStatement> statements);
    public virtual ISwitchCase Visit(ISwitchCase switchCase);
    public virtual List`1<ISwitchCase> Visit(List`1<ISwitchCase> switchCases);
    public virtual ITargetExpression Visit(ITargetExpression targetExpression);
}
[ObsoleteAttribute("This class has been superceded by CodeDeepCopier and CodeRewriter, used in combination. It will go away in the future.")]
public class Microsoft.Cci.MutableCodeModel.CodeMutator : MetadataMutator {
    private CreateMutableType createMutableType;
    protected ISourceLocationProvider sourceLocationProvider;
    public CodeMutator(IMetadataHost host);
    public CodeMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable);
    public CodeMutator(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public CodeMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable, ISourceLocationProvider sourceLocationProvider);
    public virtual void VisitPrivateHelperMembers(List`1<INamedTypeDefinition> typeDefinitions);
    public virtual IExpression Visit(Addition addition);
    public virtual IAddressableExpression Visit(AddressableExpression addressableExpression);
    public virtual IExpression Visit(AddressDereference addressDereference);
    public virtual IExpression Visit(AddressOf addressOf);
    public virtual IExpression Visit(AnonymousDelegate anonymousDelegate);
    public virtual IExpression Visit(ArrayIndexer arrayIndexer);
    public virtual IStatement Visit(AssertStatement assertStatement);
    public virtual IExpression Visit(Assignment assignment);
    public virtual IStatement Visit(AssumeStatement assumeStatement);
    public virtual IExpression Visit(BitwiseAnd bitwiseAnd);
    public virtual IExpression Visit(BitwiseOr bitwiseOr);
    public virtual IExpression Visit(BinaryOperation binaryOperation);
    public virtual IExpression Visit(BlockExpression blockExpression);
    public virtual IBlockStatement Visit(BlockStatement blockStatement);
    public virtual IExpression Visit(BoundExpression boundExpression);
    public virtual IStatement Visit(BreakStatement breakStatement);
    public virtual IExpression Visit(CastIfPossible castIfPossible);
    public virtual List`1<ICatchClause> Visit(List`1<CatchClause> catchClauses);
    public virtual ICatchClause Visit(CatchClause catchClause);
    public virtual IExpression Visit(CheckIfInstance checkIfInstance);
    public virtual ICompileTimeConstant Visit(CompileTimeConstant constant);
    public virtual IExpression Visit(Conversion conversion);
    public virtual IExpression Visit(Conditional conditional);
    public virtual IStatement Visit(ConditionalStatement conditionalStatement);
    public virtual IStatement Visit(ContinueStatement continueStatement);
    public virtual IExpression Visit(CreateArray createArray);
    public virtual IExpression Visit(CreateObjectInstance createObjectInstance);
    public virtual IExpression Visit(CreateDelegateInstance createDelegateInstance);
    public virtual IExpression Visit(DefaultValue defaultValue);
    public virtual IStatement Visit(DebuggerBreakStatement debuggerBreakStatement);
    public virtual IExpression Visit(Division division);
    public virtual IStatement Visit(DoUntilStatement doUntilStatement);
    public virtual IExpression Visit(DupValue dupValue);
    public virtual IStatement Visit(EmptyStatement emptyStatement);
    public virtual IExpression Visit(Equality equality);
    public virtual IExpression Visit(ExclusiveOr exclusiveOr);
    public virtual List`1<IExpression> Visit(List`1<IExpression> expressions);
    public virtual IStatement Visit(ExpressionStatement expressionStatement);
    public virtual IStatement Visit(ForEachStatement forEachStatement);
    public virtual IStatement Visit(ForStatement forStatement);
    public virtual IExpression Visit(GetTypeOfTypedReference getTypeOfTypedReference);
    public virtual IExpression Visit(GetValueOfTypedReference getValueOfTypedReference);
    public virtual IStatement Visit(GotoStatement gotoStatement);
    public virtual IStatement Visit(GotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual IExpression Visit(GreaterThan greaterThan);
    public virtual IExpression Visit(GreaterThanOrEqual greaterThanOrEqual);
    public virtual IStatement Visit(LabeledStatement labeledStatement);
    public virtual IExpression Visit(LeftShift leftShift);
    public virtual IExpression Visit(LessThan lessThan);
    public virtual IExpression Visit(LessThanOrEqual lessThanOrEqual);
    public virtual IStatement Visit(LocalDeclarationStatement localDeclarationStatement);
    public virtual IStatement Visit(LockStatement lockStatement);
    public virtual IExpression Visit(LogicalNot logicalNot);
    public virtual IExpression Visit(MakeTypedReference makeTypedReference);
    public virtual IMethodBody Visit(IMethodBody methodBody);
    public virtual IExpression Visit(MethodCall methodCall);
    public virtual IExpression Visit(Modulus modulus);
    public virtual IExpression Visit(Multiplication multiplication);
    public virtual IExpression Visit(NamedArgument namedArgument);
    public virtual IExpression Visit(NotEquality notEquality);
    public virtual IExpression Visit(OldValue oldValue);
    public virtual IExpression Visit(OnesComplement onesComplement);
    public virtual IExpression Visit(UnaryOperation unaryOperation);
    public virtual IExpression Visit(OutArgument outArgument);
    public virtual IExpression Visit(PointerCall pointerCall);
    public virtual IExpression Visit(PopValue popValue);
    public virtual IStatement Visit(PushStatement pushStatement);
    public virtual IExpression Visit(RefArgument refArgument);
    public virtual IStatement Visit(ResourceUseStatement resourceUseStatement);
    public virtual IStatement Visit(RethrowStatement rethrowStatement);
    public virtual IStatement Visit(ReturnStatement returnStatement);
    public virtual IExpression Visit(ReturnValue returnValue);
    public virtual IExpression Visit(RightShift rightShift);
    public virtual IExpression Visit(RuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual IExpression Visit(SizeOf sizeOf);
    public virtual IExpression Visit(StackArrayCreate stackArrayCreate);
    public virtual IExpression Visit(Subtraction subtraction);
    public virtual List`1<ISwitchCase> Visit(List`1<SwitchCase> switchCases);
    public virtual ISwitchCase Visit(SwitchCase switchCase);
    public virtual IStatement Visit(SwitchStatement switchStatement);
    public virtual ITargetExpression Visit(TargetExpression targetExpression);
    public virtual IExpression Visit(ThisReference thisReference);
    public virtual IStatement Visit(ThrowStatement throwStatement);
    public virtual IStatement Visit(TryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual IExpression Visit(TokenOf tokenOf);
    public virtual IExpression Visit(TypeOf typeOf);
    public virtual IExpression Visit(UnaryNegation unaryNegation);
    public virtual IExpression Visit(UnaryPlus unaryPlus);
    public virtual IExpression Visit(VectorLength vectorLength);
    public virtual IStatement Visit(WhileDoStatement whileDoStatement);
    public virtual IStatement Visit(YieldBreakStatement yieldBreakStatement);
    public virtual IStatement Visit(YieldReturnStatement yieldReturnStatement);
    public virtual IAddressableExpression Visit(IAddressableExpression addressableExpression);
    public virtual IBlockStatement Visit(IBlockStatement blockStatement);
    public virtual ICatchClause Visit(ICatchClause catchClause);
    public virtual List`1<ICatchClause> Visit(List`1<ICatchClause> catchClauses);
    public virtual ICompileTimeConstant Visit(ICompileTimeConstant compileTimeConstant);
    public virtual IExpression Visit(IExpression expression);
    public virtual IStatement Visit(IStatement statement);
    public virtual List`1<IStatement> Visit(List`1<IStatement> statements);
    public virtual ISwitchCase Visit(ISwitchCase switchCase);
    public virtual List`1<ISwitchCase> Visit(List`1<ISwitchCase> switchCases);
    public virtual ITargetExpression Visit(ITargetExpression targetExpression);
}
public class Microsoft.Cci.MutableCodeModel.CodeRewriter : MetadataRewriter {
    private Dispatcher dispatchingVisitor;
    public CodeRewriter(IMetadataHost host, bool copyAndRewriteImmutableReferences);
    public virtual IExpression Rewrite(IAddition addition);
    public virtual IAddressableExpression Rewrite(IAddressableExpression addressableExpression);
    public virtual IExpression Rewrite(IAddressDereference addressDereference);
    public virtual IExpression Rewrite(IAddressOf addressOf);
    public virtual IExpression Rewrite(IAnonymousDelegate anonymousDelegate);
    public virtual IExpression Rewrite(IArrayIndexer arrayIndexer);
    public virtual IStatement Rewrite(IAssertStatement assertStatement);
    public virtual IExpression Rewrite(IAssignment assignment);
    public virtual IStatement Rewrite(IAssumeStatement assumeStatement);
    public virtual IExpression Rewrite(IBinaryOperation binaryOperation);
    public virtual IExpression Rewrite(IBitwiseAnd bitwiseAnd);
    public virtual IExpression Rewrite(IBitwiseOr bitwiseOr);
    public virtual IExpression Rewrite(IBlockExpression blockExpression);
    public virtual IBlockStatement Rewrite(IBlockStatement block);
    public virtual IExpression Rewrite(IBoundExpression boundExpression);
    public virtual IStatement Rewrite(IBreakStatement breakStatement);
    public virtual IExpression Rewrite(ICastIfPossible castIfPossible);
    public virtual ICatchClause Rewrite(ICatchClause catchClause);
    public virtual IExpression Rewrite(ICheckIfInstance checkIfInstance);
    public virtual ICompileTimeConstant Rewrite(ICompileTimeConstant constant);
    public virtual IExpression Rewrite(IConditional conditional);
    public virtual IStatement Rewrite(IConditionalStatement conditionalStatement);
    public virtual IStatement Rewrite(IContinueStatement continueStatement);
    public virtual IExpression Rewrite(IConversion conversion);
    public virtual IStatement Rewrite(ICopyMemoryStatement copyMemoryStatement);
    public virtual IExpression Rewrite(ICreateArray createArray);
    public virtual IExpression Rewrite(ICreateDelegateInstance createDelegateInstance);
    public virtual IExpression Rewrite(ICreateObjectInstance createObjectInstance);
    public virtual IStatement Rewrite(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual IExpression Rewrite(IDefaultValue defaultValue);
    public virtual IExpression Rewrite(IDivision division);
    public virtual IStatement Rewrite(IDoUntilStatement doUntilStatement);
    public virtual IExpression Rewrite(IDupValue dupValue);
    public virtual IStatement Rewrite(IEmptyStatement emptyStatement);
    public virtual IExpression Rewrite(IEquality equality);
    public virtual IExpression Rewrite(IExclusiveOr exclusiveOr);
    public virtual IExpression Rewrite(IExpression expression);
    public virtual IStatement Rewrite(IExpressionStatement expressionStatement);
    public virtual IStatement Rewrite(IFillMemoryStatement fillMemoryStatement);
    public virtual IStatement Rewrite(IForEachStatement forEachStatement);
    public virtual IStatement Rewrite(IForStatement forStatement);
    public virtual IExpression Rewrite(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual IExpression Rewrite(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual IStatement Rewrite(IGotoStatement gotoStatement);
    public virtual IStatement Rewrite(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual IExpression Rewrite(IGreaterThan greaterThan);
    public virtual IExpression Rewrite(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual IStatement Rewrite(ILabeledStatement labeledStatement);
    public virtual IExpression Rewrite(ILeftShift leftShift);
    public virtual IExpression Rewrite(ILessThan lessThan);
    public virtual IExpression Rewrite(ILessThanOrEqual lessThanOrEqual);
    public virtual IStatement Rewrite(ILocalDeclarationStatement localDeclarationStatement);
    public virtual IStatement Rewrite(ILockStatement lockStatement);
    public virtual IExpression Rewrite(ILogicalNot logicalNot);
    public virtual IExpression Rewrite(IMakeTypedReference makeTypedReference);
    public virtual IMethodBody Rewrite(IMethodBody methodBody);
    public virtual IExpression Rewrite(IMethodCall methodCall);
    public virtual IExpression Rewrite(IModulus modulus);
    public virtual IExpression Rewrite(IMultiplication multiplication);
    public virtual IExpression Rewrite(INamedArgument namedArgument);
    public virtual IExpression Rewrite(INotEquality notEquality);
    public virtual IExpression Rewrite(IOldValue oldValue);
    public virtual IExpression Rewrite(IOnesComplement onesComplement);
    public virtual IExpression Rewrite(IOutArgument outArgument);
    public virtual IExpression Rewrite(IPointerCall pointerCall);
    public virtual IExpression Rewrite(IPopValue popValue);
    public virtual IStatement Rewrite(IPushStatement pushStatement);
    public virtual IExpression Rewrite(IRefArgument refArgument);
    public virtual IStatement Rewrite(IResourceUseStatement resourceUseStatement);
    public virtual IStatement Rewrite(IRethrowStatement rethrowStatement);
    public virtual IStatement Rewrite(IReturnStatement returnStatement);
    public virtual IExpression Rewrite(IReturnValue returnValue);
    public virtual IExpression Rewrite(IRightShift rightShift);
    public virtual IExpression Rewrite(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual IExpression Rewrite(ISizeOf sizeOf);
    public virtual IExpression Rewrite(IStackArrayCreate stackArrayCreate);
    public virtual ISourceMethodBody Rewrite(ISourceMethodBody sourceMethodBody);
    public virtual IStatement Rewrite(IStatement statement);
    public virtual IExpression Rewrite(ISubtraction subtraction);
    public virtual ISwitchCase Rewrite(ISwitchCase switchCase);
    public virtual IStatement Rewrite(ISwitchStatement switchStatement);
    public virtual ITargetExpression Rewrite(ITargetExpression targetExpression);
    public virtual IExpression Rewrite(IThisReference thisReference);
    public virtual IStatement Rewrite(IThrowStatement throwStatement);
    public virtual IExpression Rewrite(ITokenOf tokenOf);
    public virtual IStatement Rewrite(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual IExpression Rewrite(ITypeOf typeOf);
    public virtual IExpression Rewrite(IUnaryNegation unaryNegation);
    public virtual IExpression Rewrite(IUnaryPlus unaryPlus);
    public virtual IExpression Rewrite(IVectorLength vectorLength);
    public virtual IStatement Rewrite(IWhileDoStatement whileDoStatement);
    public virtual IStatement Rewrite(IYieldBreakStatement yieldBreakStatement);
    public virtual IStatement Rewrite(IYieldReturnStatement yieldReturnStatement);
    public virtual List`1<ICatchClause> Rewrite(List`1<ICatchClause> catchClauses);
    public virtual List`1<IExpression> Rewrite(List`1<IExpression> expressions);
    public virtual List`1<ISwitchCase> Rewrite(List`1<ISwitchCase> switchCases);
    public virtual List`1<IStatement> Rewrite(List`1<IStatement> statements);
    public virtual void RewriteChildren(Addition addition);
    public virtual void RewriteChildren(AddressableExpression addressableExpression);
    public virtual void RewriteChildren(AddressDereference addressDereference);
    public virtual void RewriteChildren(AddressOf addressOf);
    public virtual void RewriteChildren(AnonymousDelegate anonymousDelegate);
    public virtual void RewriteChildren(ArrayIndexer arrayIndexer);
    public virtual void RewriteChildren(AssertStatement assertStatement);
    public virtual void RewriteChildren(Assignment assignment);
    public virtual void RewriteChildren(AssumeStatement assumeStatement);
    public virtual void RewriteChildren(BinaryOperation binaryOperation);
    public virtual void RewriteChildren(BitwiseAnd bitwiseAnd);
    public virtual void RewriteChildren(BitwiseOr bitwiseOr);
    public virtual void RewriteChildren(BlockExpression blockExpression);
    public virtual void RewriteChildren(BlockStatement block);
    public virtual void RewriteChildren(BoundExpression boundExpression);
    public virtual void RewriteChildren(BreakStatement breakStatement);
    public virtual void RewriteChildren(CastIfPossible castIfPossible);
    public virtual void RewriteChildren(CatchClause catchClause);
    public virtual void RewriteChildren(CheckIfInstance checkIfInstance);
    public virtual void RewriteChildren(CompileTimeConstant constant);
    public virtual void RewriteChildren(ConstructorOrMethodCall constructorOrMethodCall);
    public virtual void RewriteChildren(Conditional conditional);
    public virtual void RewriteChildren(ConditionalStatement conditionalStatement);
    public virtual void RewriteChildren(ContinueStatement continueStatement);
    public virtual void RewriteChildren(Conversion conversion);
    public virtual void RewriteChildren(CopyMemoryStatement copyMemoryStatement);
    public virtual void RewriteChildren(CreateArray createArray);
    public virtual void RewriteChildren(CreateDelegateInstance createDelegateInstance);
    public virtual void RewriteChildren(CreateObjectInstance createObjectInstance);
    public virtual void RewriteChildren(DebuggerBreakStatement debuggerBreakStatement);
    public virtual void RewriteChildren(DefaultValue defaultValue);
    public virtual void RewriteChildren(Division division);
    public virtual void RewriteChildren(DoUntilStatement doUntilStatement);
    public virtual void RewriteChildren(DupValue dupValue);
    public virtual void RewriteChildren(EmptyStatement emptyStatement);
    public virtual void RewriteChildren(Equality equality);
    public virtual void RewriteChildren(ExclusiveOr exclusiveOr);
    public virtual void RewriteChildren(Expression expression);
    public virtual void RewriteChildren(ExpressionStatement expressionStatement);
    public virtual void RewriteChildren(FillMemoryStatement fillMemoryStatement);
    public virtual void RewriteChildren(ForEachStatement forEachStatement);
    public virtual void RewriteChildren(ForStatement forStatement);
    public virtual void RewriteChildren(GetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void RewriteChildren(GetValueOfTypedReference getValueOfTypedReference);
    public virtual void RewriteChildren(GotoStatement gotoStatement);
    public virtual void RewriteChildren(GotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void RewriteChildren(GreaterThan greaterThan);
    public virtual void RewriteChildren(GreaterThanOrEqual greaterThanOrEqual);
    public virtual void RewriteChildren(LabeledStatement labeledStatement);
    public virtual void RewriteChildren(LeftShift leftShift);
    public virtual void RewriteChildren(LessThan lessThan);
    public virtual void RewriteChildren(LessThanOrEqual lessThanOrEqual);
    public virtual void RewriteChildren(LocalDeclarationStatement localDeclarationStatement);
    public virtual void RewriteChildren(LockStatement lockStatement);
    public virtual void RewriteChildren(LogicalNot logicalNot);
    public virtual void RewriteChildren(MakeTypedReference makeTypedReference);
    public virtual void RewriteChildren(MethodCall methodCall);
    public virtual void RewriteChildren(Modulus modulus);
    public virtual void RewriteChildren(Multiplication multiplication);
    public virtual void RewriteChildren(NamedArgument namedArgument);
    public virtual void RewriteChildren(NotEquality notEquality);
    public virtual void RewriteChildren(OldValue oldValue);
    public virtual void RewriteChildren(OnesComplement onesComplement);
    public virtual void RewriteChildren(OutArgument outArgument);
    public virtual void RewriteChildren(PointerCall pointerCall);
    public virtual void RewriteChildren(PopValue popValue);
    public virtual void RewriteChildren(PushStatement pushStatement);
    public virtual void RewriteChildren(RefArgument refArgument);
    public virtual void RewriteChildren(ResourceUseStatement resourceUseStatement);
    public virtual void RewriteChildren(RethrowStatement rethrowStatement);
    public virtual void RewriteChildren(ReturnStatement returnStatement);
    public virtual void RewriteChildren(ReturnValue returnValue);
    public virtual void RewriteChildren(RightShift rightShift);
    public virtual void RewriteChildren(RuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void RewriteChildren(SizeOf sizeOf);
    public virtual void RewriteChildren(SourceMethodBody sourceMethodBody);
    public virtual void RewriteChildren(StackArrayCreate stackArrayCreate);
    public virtual void RewriteChildren(Statement statement);
    public virtual void RewriteChildren(Subtraction subtraction);
    public virtual void RewriteChildren(SwitchCase switchCase);
    public virtual void RewriteChildren(SwitchStatement switchStatement);
    public virtual void RewriteChildren(TargetExpression targetExpression);
    public virtual void RewriteChildren(ThisReference thisReference);
    public virtual void RewriteChildren(ThrowStatement throwStatement);
    public virtual void RewriteChildren(TokenOf tokenOf);
    public virtual void RewriteChildren(TryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public virtual void RewriteChildren(TypeOf typeOf);
    public virtual void RewriteChildren(UnaryNegation unaryNegation);
    public virtual void RewriteChildren(UnaryOperation unaryOperation);
    public virtual void RewriteChildren(UnaryPlus unaryPlus);
    public virtual void RewriteChildren(VectorLength vectorLength);
    public virtual void RewriteChildren(WhileDoStatement whileDoStatement);
    public virtual void RewriteChildren(YieldBreakStatement yieldBreakStatement);
    public virtual void RewriteChildren(YieldReturnStatement yieldReturnStatement);
}
public class Microsoft.Cci.MutableCodeModel.CodeShallowCopier : MetadataShallowCopier {
    private ISourceLocationProvider sourceLocationProvider;
    private ILocalScopeProvider localScopeProvider;
    private CodeDispatcher dispatcher;
    private CodeDispatcher Dispatcher { get; }
    public CodeShallowCopier(IMetadataHost targetHost, ISourceLocationProvider sourceLocationProvider, ILocalScopeProvider localScopeProvider);
    public CodeShallowCopier(IMetadataHost targetHost, IUnit targetUnit, ISourceLocationProvider sourceLocationProvider);
    private CodeDispatcher get_Dispatcher();
    public Addition Copy(IAddition addition);
    public AddressableExpression Copy(IAddressableExpression addressableExpression);
    public AddressDereference Copy(IAddressDereference addressDereference);
    public AddressOf Copy(IAddressOf addressOf);
    public AnonymousDelegate Copy(IAnonymousDelegate anonymousDelegate);
    public ArrayIndexer Copy(IArrayIndexer arrayIndexer);
    public AssertStatement Copy(IAssertStatement assertStatement);
    public Assignment Copy(IAssignment assignment);
    public AssumeStatement Copy(IAssumeStatement assumeStatement);
    public BitwiseAnd Copy(IBitwiseAnd bitwiseAnd);
    public BitwiseOr Copy(IBitwiseOr bitwiseOr);
    public BlockExpression Copy(IBlockExpression blockExpression);
    public BlockStatement Copy(IBlockStatement block);
    public BreakStatement Copy(IBreakStatement breakStatement);
    public CastIfPossible Copy(ICastIfPossible castIfPossible);
    public CatchClause Copy(ICatchClause catchClause);
    public CheckIfInstance Copy(ICheckIfInstance checkIfInstance);
    public CompileTimeConstant Copy(ICompileTimeConstant constant);
    public Conversion Copy(IConversion conversion);
    public Conditional Copy(IConditional conditional);
    public ConditionalStatement Copy(IConditionalStatement conditionalStatement);
    public ContinueStatement Copy(IContinueStatement continueStatement);
    public CopyMemoryStatement Copy(ICopyMemoryStatement copyMemoryStatement);
    public CreateArray Copy(ICreateArray createArray);
    public CreateObjectInstance Copy(ICreateObjectInstance createObjectInstance);
    public CreateDelegateInstance Copy(ICreateDelegateInstance createDelegateInstance);
    public DefaultValue Copy(IDefaultValue defaultValue);
    public Division Copy(IDivision division);
    public DoUntilStatement Copy(IDoUntilStatement doUntilStatement);
    public DupValue Copy(IDupValue dupValue);
    public EmptyStatement Copy(IEmptyStatement emptyStatement);
    public Equality Copy(IEquality equality);
    public ExclusiveOr Copy(IExclusiveOr exclusiveOr);
    public BoundExpression Copy(IBoundExpression boundExpression);
    public DebuggerBreakStatement Copy(IDebuggerBreakStatement debuggerBreakStatement);
    public Expression Copy(IExpression expression);
    public ExpressionStatement Copy(IExpressionStatement expressionStatement);
    public FillMemoryStatement Copy(IFillMemoryStatement fillMemoryStatement);
    public ForEachStatement Copy(IForEachStatement forEachStatement);
    public ForStatement Copy(IForStatement forStatement);
    public GetTypeOfTypedReference Copy(IGetTypeOfTypedReference getTypeOfTypedReference);
    public GetValueOfTypedReference Copy(IGetValueOfTypedReference getValueOfTypedReference);
    public GotoStatement Copy(IGotoStatement gotoStatement);
    public GotoSwitchCaseStatement Copy(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public GreaterThan Copy(IGreaterThan greaterThan);
    public GreaterThanOrEqual Copy(IGreaterThanOrEqual greaterThanOrEqual);
    public LabeledStatement Copy(ILabeledStatement labeledStatement);
    public LeftShift Copy(ILeftShift leftShift);
    public LessThan Copy(ILessThan lessThan);
    public LessThanOrEqual Copy(ILessThanOrEqual lessThanOrEqual);
    public LocalDeclarationStatement Copy(ILocalDeclarationStatement localDeclarationStatement);
    public LockStatement Copy(ILockStatement lockStatement);
    public LogicalNot Copy(ILogicalNot logicalNot);
    public MakeTypedReference Copy(IMakeTypedReference makeTypedReference);
    public MethodCall Copy(IMethodCall methodCall);
    public Modulus Copy(IModulus modulus);
    public Multiplication Copy(IMultiplication multiplication);
    public virtual void Visit(IEnumerable`1<INamedArgument> namedArguments);
    public NamedArgument Copy(INamedArgument namedArgument);
    public NotEquality Copy(INotEquality notEquality);
    public OldValue Copy(IOldValue oldValue);
    public OnesComplement Copy(IOnesComplement onesComplement);
    public OutArgument Copy(IOutArgument outArgument);
    public PointerCall Copy(IPointerCall pointerCall);
    public PopValue Copy(IPopValue popValue);
    public PushStatement Copy(IPushStatement pushStatement);
    public RefArgument Copy(IRefArgument refArgument);
    public ResourceUseStatement Copy(IResourceUseStatement resourceUseStatement);
    public RethrowStatement Copy(IRethrowStatement rethrowStatement);
    public ReturnStatement Copy(IReturnStatement returnStatement);
    public ReturnValue Copy(IReturnValue returnValue);
    public RightShift Copy(IRightShift rightShift);
    public StackArrayCreate Copy(IStackArrayCreate stackArrayCreate);
    public RuntimeArgumentHandleExpression Copy(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public SizeOf Copy(ISizeOf sizeOf);
    public SourceMethodBody Copy(ISourceMethodBody sourceMethodBody);
    public virtual void Visit(IEnumerable`1<IStatement> statements);
    public Statement Copy(IStatement statement);
    public Subtraction Copy(ISubtraction subtraction);
    public virtual void Visit(IEnumerable`1<ISwitchCase> switchCases);
    public SwitchCase Copy(ISwitchCase switchCase);
    public SwitchStatement Copy(ISwitchStatement switchStatement);
    public TargetExpression Copy(ITargetExpression targetExpression);
    public ThisReference Copy(IThisReference thisReference);
    public ThrowStatement Copy(IThrowStatement throwStatement);
    public TryCatchFinallyStatement Copy(ITryCatchFinallyStatement tryCatchFilterFinallyStatement);
    public TokenOf Copy(ITokenOf tokenOf);
    public TypeOf Copy(ITypeOf typeOf);
    public UnaryNegation Copy(IUnaryNegation unaryNegation);
    public UnaryPlus Copy(IUnaryPlus unaryPlus);
    public VectorLength Copy(IVectorLength vectorLength);
    public WhileDoStatement Copy(IWhileDoStatement whileDoStatement);
    public YieldBreakStatement Copy(IYieldBreakStatement yieldBreakStatement);
    public YieldReturnStatement Copy(IYieldReturnStatement yieldReturnStatement);
}
internal class Microsoft.Cci.MutableCodeModel.CollectAndShallowCopyDefinitions : MetadataVisitor {
    private MetadataCopier copier;
    private List`1<INamedTypeDefinition> newTypes;
    internal CollectAndShallowCopyDefinitions(MetadataCopier copier, List`1<INamedTypeDefinition> newTypes);
    public virtual void Visit(IFieldDefinition fieldDefinition);
    public virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual void Visit(IMethodDefinition method);
    public virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public virtual void Visit(IEventDefinition eventDefinition);
    public virtual void Visit(ILocalDefinition localDefinition);
    public virtual void Visit(IRootUnitNamespace rootUnitNamespace);
    public virtual void Visit(INestedUnitNamespace nestedUnitNamespace);
    public virtual void Visit(IParameterDefinition parameterDefinition);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
}
public class Microsoft.Cci.MutableCodeModel.CompileTimeConstant : Expression {
    private object value;
    public object Value { get; public set; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public CompileTimeConstant(ICompileTimeConstant compileTimeConstant);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual object get_Value();
    public void set_Value(object value);
    public virtual string ToString();
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
public class Microsoft.Cci.MutableCodeModel.Conditional : Expression {
    private IExpression condition;
    private IExpression resultIfFalse;
    private IExpression resultIfTrue;
    public IExpression Condition { get; public set; }
    public IExpression ResultIfFalse { get; public set; }
    public IExpression ResultIfTrue { get; public set; }
    public Conditional(IConditional conditional);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public sealed virtual IExpression get_ResultIfFalse();
    public void set_ResultIfFalse(IExpression value);
    public sealed virtual IExpression get_ResultIfTrue();
    public void set_ResultIfTrue(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.ConditionalStatement : Statement {
    private IExpression condition;
    private IStatement falseBranch;
    private IStatement trueBranch;
    public IExpression Condition { get; public set; }
    public IStatement FalseBranch { get; public set; }
    public IStatement TrueBranch { get; public set; }
    public ConditionalStatement(IConditionalStatement conditionalStatement);
    public virtual ConditionalStatement Clone();
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IStatement get_FalseBranch();
    public void set_FalseBranch(IStatement value);
    public sealed virtual IStatement get_TrueBranch();
    public void set_TrueBranch(IStatement value);
}
public abstract class Microsoft.Cci.MutableCodeModel.ConstructorOrMethodCall : Expression {
    internal List`1<IExpression> arguments;
    private IMethodReference methodToCall;
    public List`1<IExpression> Arguments { get; public set; }
    public IMethodReference MethodToCall { get; public set; }
    internal ConstructorOrMethodCall(ICreateObjectInstance createObjectInstance);
    internal ConstructorOrMethodCall(IMethodCall methodCall);
    private void ObjectInvariant();
    public List`1<IExpression> get_Arguments();
    public void set_Arguments(List`1<IExpression> value);
    public IMethodReference get_MethodToCall();
    public void set_MethodToCall(IMethodReference value);
}
public class Microsoft.Cci.MutableCodeModel.ContinueStatement : Statement {
    public ContinueStatement(IContinueStatement continueStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
}
[ObsoleteAttribute("Please use CodeAndContractDeepCopier or CodeAndContractShallowCopier")]
public class Microsoft.Cci.MutableCodeModel.Contracts.CodeAndContractCopier : CodeCopier {
    public CodeAndContractCopier(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public CodeAndContractCopier(IMetadataHost host, ISourceLocationProvider sourceLocationProvider, IDefinition rootOfCone, List`1& newTypes);
    public virtual LoopInvariant GetMutableCopy(ILoopInvariant loopInvariant);
    public virtual Postcondition GetMutableCopy(IPostcondition postcondition);
    public virtual Precondition GetMutableCopy(IPrecondition precondition);
    public virtual ThrownException GetMutableCopy(IThrownException thrownException);
    public virtual TypeInvariant GetMutableCopy(ITypeInvariant typeInvariant);
    public static MethodContract DeepCopy(IMetadataHost host, IMethodContract methodContract);
    public static TypeContract DeepCopy(IMetadataHost host, ITypeContract typeContract);
    protected virtual List`1<IAddressableExpression> DeepCopy(List`1<IAddressableExpression> addressableExpressions);
    protected virtual ILoopContract DeepCopy(LoopContract loopContract);
    protected virtual List`1<ILoopInvariant> DeepCopy(List`1<ILoopInvariant> loopInvariants);
    protected virtual ILoopInvariant DeepCopy(LoopInvariant loopInvariant);
    protected virtual IMethodContract DeepCopy(MethodContract methodContract);
    protected virtual List`1<IPostcondition> DeepCopy(List`1<IPostcondition> postConditions);
    protected virtual IPostcondition DeepCopy(Postcondition postCondition);
    protected virtual List`1<IPrecondition> DeepCopy(List`1<IPrecondition> preconditions);
    protected virtual IPrecondition DeepCopy(Precondition precondition);
    protected virtual List`1<IThrownException> DeepCopy(List`1<IThrownException> thrownExceptions);
    protected virtual IThrownException DeepCopy(ThrownException thrownException);
    protected virtual ITypeContract DeepCopy(TypeContract typeContract);
    protected virtual List`1<ITypeInvariant> DeepCopy(List`1<ITypeInvariant> typeInvariants);
    protected virtual ITypeInvariant DeepCopy(TypeInvariant typeInvariant);
    public virtual IPrecondition Substitute(IPrecondition precondition);
    public virtual IPostcondition Substitute(IPostcondition postcondition);
    public virtual IThrownException Substitute(IThrownException thrownException);
    public virtual IMethodContract Substitute(IMethodContract methodContract);
    public virtual ITypeInvariant Substitute(ITypeInvariant typeInvariant);
    public virtual ITypeContract Substitute(ITypeContract typeContract);
}
public class Microsoft.Cci.MutableCodeModel.Contracts.CodeAndContractDeepCopier : CodeDeepCopier {
    private ContractElementDispatcher dispatcher;
    private CodeAndContractShallowCopier shallowCopier;
    private ContractElementDispatcher Dispatcher { get; }
    public CodeAndContractDeepCopier(IMetadataHost targetHost);
    public CodeAndContractDeepCopier(IMetadataHost targetHost, IUnit targetUnit);
    private CodeAndContractDeepCopier(IMetadataHost targetHost, CodeAndContractShallowCopier shallowCopier);
    private ContractElementDispatcher get_Dispatcher();
    private void Copy(ContractElement contractElement);
    private List`1<IAddressableExpression> Copy(List`1<IAddressableExpression> addressableExpressions);
    private List`1<IFieldDefinition> Copy(List`1<IFieldDefinition> fields);
    private IEnumerable`1<IEnumerable`1<IExpression>> Copy(IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    private List`1<ILoopInvariant> Copy(List`1<ILoopInvariant> loopInvariants);
    private List`1<IMethodDefinition> Copy(List`1<IMethodDefinition> methods);
    private List`1<IPostcondition> Copy(List`1<IPostcondition> postConditions);
    private List`1<IPrecondition> Copy(List`1<IPrecondition> preconditions);
    private List`1<IThrownException> Copy(List`1<IThrownException> thrownExceptions);
    private List`1<ITypeInvariant> Copy(List`1<ITypeInvariant> typeInvariants);
    public ContractElement Copy(IContractElement contractElement);
    public LoopContract Copy(ILoopContract loopContract);
    public LoopInvariant Copy(ILoopInvariant loopInvariant);
    public MethodContract Copy(IMethodContract methodContract);
    public Postcondition Copy(IPostcondition postCondition);
    public Precondition Copy(IPrecondition precondition);
    public ThrownException Copy(IThrownException thrownException);
    public TypeContract Copy(ITypeContract typeContract);
    public TypeInvariant Copy(ITypeInvariant typeInvariant);
}
[ObsoleteAttribute("Please use CodeAndContractRewriter")]
public class Microsoft.Cci.MutableCodeModel.Contracts.CodeAndContractMutatingVisitor : CodeMutatingVisitor {
    protected ContractProvider contractProvider;
    public CodeAndContractMutatingVisitor(IMetadataHost host);
    public CodeAndContractMutatingVisitor(IMetadataHost host, ISourceLocationProvider sourceLocationProvider, ContractProvider contractProvider);
    protected CodeAndContractMutatingVisitor(CodeAndContractMutatingVisitor template);
    public virtual List`1<IAddressableExpression> Visit(List`1<IAddressableExpression> addressableExpressions);
    public virtual IEnumerable`1<IEnumerable`1<IExpression>> Visit(IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    public virtual IExpression Visit(IExpression expression);
    public virtual ILoopContract Visit(ILoopContract loopContract);
    public virtual List`1<ILoopInvariant> Visit(List`1<ILoopInvariant> loopInvariants);
    public virtual ILoopInvariant Visit(ILoopInvariant loopInvariant);
    public virtual IMethodDefinition Visit(IMethodDefinition methodDefinition);
    public virtual IMethodContract Visit(IMethodContract methodContract);
    public virtual List`1<IPostcondition> Visit(List`1<IPostcondition> postConditions);
    public virtual IPostcondition Visit(IPostcondition postCondition);
    public virtual List`1<IPrecondition> Visit(List`1<IPrecondition> preconditions);
    public virtual IPrecondition Visit(IPrecondition precondition);
    public virtual IStatement Visit(IStatement statement);
    public virtual List`1<IThrownException> Visit(List`1<IThrownException> thrownExceptions);
    public virtual IThrownException Visit(IThrownException thrownException);
    public virtual ITypeContract Visit(ITypeContract typeContract);
    public virtual List`1<IFieldDefinition> Visit(List`1<IFieldDefinition> fieldInvariants);
    public virtual List`1<IMethodDefinition> Visit(List`1<IMethodDefinition> contractMethods);
    public virtual List`1<ITypeInvariant> Visit(List`1<ITypeInvariant> typeInvariants);
    public virtual ITypeInvariant Visit(ITypeInvariant typeInvariant);
    public virtual INamespaceTypeDefinition Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual INestedTypeDefinition Visit(INestedTypeDefinition nestedTypeDefinition);
}
[ObsoleteAttribute("This class has been superceded by CodeAndContractDeepCopier and CodeAndContractRewriter, used in combination. It will go away after April 2011")]
public class Microsoft.Cci.MutableCodeModel.Contracts.CodeAndContractMutator : CodeMutator {
    protected ContractProvider contractProvider;
    public CodeAndContractMutator(IMetadataHost host);
    public CodeAndContractMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable);
    public CodeAndContractMutator(IMetadataHost host, ISourceLocationProvider sourceLocationProvider, ContractProvider contractProvider);
    public CodeAndContractMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable, ISourceLocationProvider sourceLocationProvider, ContractProvider contractProvider);
    protected CodeAndContractMutator(CodeAndContractMutator template);
    public virtual List`1<IAddressableExpression> Visit(List`1<IAddressableExpression> addressableExpressions);
    public virtual IEnumerable`1<IEnumerable`1<IExpression>> Visit(IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    public virtual IExpression Visit(IExpression expression);
    public virtual ILoopContract Visit(ILoopContract loopContract);
    public virtual ILoopContract Visit(LoopContract loopContract);
    public virtual List`1<ILoopInvariant> Visit(List`1<ILoopInvariant> loopInvariants);
    public virtual ILoopInvariant Visit(ILoopInvariant loopInvariant);
    public virtual ILoopInvariant Visit(LoopInvariant loopInvariant);
    public virtual IMethodDefinition Visit(IMethodDefinition methodDefinition);
    public virtual IGlobalMethodDefinition Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual MethodDefinition Visit(MethodDefinition methodDefinition);
    public virtual IMethodBody Visit(IMethodBody methodBody);
    public virtual IMethodContract Visit(IMethodContract methodContract);
    public virtual IMethodContract Visit(MethodContract methodContract);
    public virtual List`1<IPostcondition> Visit(List`1<IPostcondition> postConditions);
    public virtual IPostcondition Visit(IPostcondition postCondition);
    public virtual IPostcondition Visit(Postcondition postCondition);
    public virtual List`1<IPrecondition> Visit(List`1<IPrecondition> preconditions);
    public virtual IPrecondition Visit(IPrecondition precondition);
    public virtual IPrecondition Visit(Precondition precondition);
    public virtual IStatement Visit(IStatement statement);
    public virtual List`1<IThrownException> Visit(List`1<IThrownException> thrownExceptions);
    public virtual IThrownException Visit(IThrownException thrownException);
    public virtual IThrownException Visit(ThrownException thrownException);
    public virtual ITypeContract Visit(ITypeContract typeContract);
    public virtual ITypeContract Visit(TypeContract typeContract);
    public virtual List`1<ITypeInvariant> Visit(List`1<ITypeInvariant> typeInvariants);
    public virtual ITypeInvariant Visit(ITypeInvariant typeInvariant);
    public virtual ITypeInvariant Visit(TypeInvariant typeInvariant);
    public virtual INamespaceTypeDefinition Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual INestedTypeDefinition Visit(INestedTypeDefinition nestedTypeDefinition);
}
public class Microsoft.Cci.MutableCodeModel.Contracts.CodeAndContractRewriter : CodeRewriter {
    protected ContractProvider contractProvider;
    public CodeAndContractRewriter(IMetadataHost host, bool copyAndRewriteImmutableReferences);
    public CodeAndContractRewriter(IMetadataHost host, ContractProvider contractProvider, bool copyAndRewriteImmutableReferences);
    public virtual IEnumerable`1<IEnumerable`1<IExpression>> Rewrite(IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    public virtual ILoopContract Rewrite(ILoopContract loopContract);
    public virtual ILoopInvariant Rewrite(ILoopInvariant loopInvariant);
    public virtual IMethodContract Rewrite(IMethodContract methodContract);
    public virtual IPostcondition Rewrite(IPostcondition postCondition);
    public virtual IPrecondition Rewrite(IPrecondition precondition);
    public virtual IStatement Rewrite(IStatement statement);
    public virtual IThrownException Rewrite(IThrownException thrownException);
    public virtual ITypeContract Rewrite(ITypeContract typeContract);
    public virtual ITypeInvariant Rewrite(ITypeInvariant typeInvariant);
    public virtual IExpression Rewrite(IMethodCall methodCall);
    public virtual IMethodDefinition Rewrite(IMethodDefinition method);
    public virtual ITypeDefinition Rewrite(ITypeDefinition typeDefinition);
    public virtual List`1<IAddressableExpression> Rewrite(List`1<IAddressableExpression> addressableExpressions);
    public virtual List`1<ILoopInvariant> Rewrite(List`1<ILoopInvariant> loopInvariants);
    public virtual List`1<IPostcondition> Rewrite(List`1<IPostcondition> postConditions);
    public virtual List`1<IPrecondition> Rewrite(List`1<IPrecondition> preconditions);
    public virtual List`1<IThrownException> Rewrite(List`1<IThrownException> thrownExceptions);
    public virtual List`1<ITypeInvariant> Rewrite(List`1<ITypeInvariant> typeInvariants);
    public virtual void RewriteChildren(ContractElement contractElement);
    public virtual void RewriteChildren(LoopContract loopContract);
    public virtual void RewriteChildren(LoopInvariant loopInvariant);
    public virtual void RewriteChildren(MethodContract methodContract);
    public virtual void RewriteChildren(Precondition precondition);
    public virtual void RewriteChildren(ThrownException thrownException);
    public virtual void RewriteChildren(TypeContract typeContract);
    public virtual void RewriteChildren(TypeInvariant typeInvariant);
}
public class Microsoft.Cci.MutableCodeModel.Contracts.CodeAndContractShallowCopier : CodeShallowCopier {
    private ContractElementDispatcher dispatchingVisitor;
    public CodeAndContractShallowCopier(IMetadataHost targetHost);
    public CodeAndContractShallowCopier(IMetadataHost targetHost, IUnit targetUnit);
    public virtual ContractElement Copy(IContractElement contractElement);
    public virtual LoopContract Copy(ILoopContract loopContract);
    public virtual LoopInvariant Copy(ILoopInvariant loopInvariant);
    public virtual MethodContract Copy(IMethodContract methodContract);
    public virtual Postcondition Copy(IPostcondition postCondition);
    public virtual Precondition Copy(IPrecondition precondition);
    public virtual ThrownException Copy(IThrownException thrownException);
    public virtual TypeContract Copy(ITypeContract typeContract);
    public virtual TypeInvariant Copy(ITypeInvariant typeInvariant);
}
[ObsoleteAttribute("Please use CodeAndContractRewriter")]
public class Microsoft.Cci.MutableCodeModel.Contracts.MethodBodyCodeAndContractMutator : CodeAndContractMutatingVisitor {
    public MethodBodyCodeAndContractMutator(IMetadataHost host);
    public MethodBodyCodeAndContractMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable);
    public MethodBodyCodeAndContractMutator(IMetadataHost host, ISourceLocationProvider sourceLocationProvider, ContractProvider contractProvider);
    public MethodBodyCodeAndContractMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable, ISourceLocationProvider sourceLocationProvider, ContractProvider contractProvider);
    public virtual IFieldReference Visit(IFieldReference fieldReference);
    public virtual ILocalDefinition VisitReferenceTo(ILocalDefinition localDefinition);
    public virtual IMethodReference Visit(IMethodReference methodReference);
    public virtual IParameterDefinition VisitReferenceTo(IParameterDefinition parameterDefinition);
    public virtual ITypeReference Visit(ITypeReference typeReference);
}
public class Microsoft.Cci.MutableCodeModel.Conversion : Expression {
    private bool checkNumericRange;
    private ITypeReference typeAfterConversion;
    private IExpression valueToConvert;
    public bool CheckNumericRange { get; public set; }
    public ITypeReference TypeAfterConversion { get; public set; }
    public IExpression ValueToConvert { get; public set; }
    public Conversion(IConversion conversion);
    public sealed virtual bool get_CheckNumericRange();
    public void set_CheckNumericRange(bool value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_TypeAfterConversion();
    public void set_TypeAfterConversion(ITypeReference value);
    public sealed virtual IExpression get_ValueToConvert();
    public void set_ValueToConvert(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.CopyMemoryStatement : Statement {
    private IExpression targetAddress;
    private IExpression sourceAddress;
    private IExpression numberOfBytesToCopy;
    public IExpression TargetAddress { get; public set; }
    public IExpression SourceAddress { get; public set; }
    public IExpression NumberOfBytesToCopy { get; public set; }
    public CopyMemoryStatement(ICopyMemoryStatement copyMemoryStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_TargetAddress();
    public void set_TargetAddress(IExpression value);
    public sealed virtual IExpression get_SourceAddress();
    public void set_SourceAddress(IExpression value);
    public sealed virtual IExpression get_NumberOfBytesToCopy();
    public void set_NumberOfBytesToCopy(IExpression value);
}
internal class Microsoft.Cci.MutableCodeModel.CopyTypeFromIteratorToClosure : MethodBodyMappingMutator {
    protected Dictionary`2<UInt32, IGenericTypeParameter> mapping;
    internal CopyTypeFromIteratorToClosure(IMetadataHost host, Dictionary`2<UInt32, IGenericTypeParameter> mapping);
    public virtual ITypeReference Visit(ITypeReference typeReference);
}
public class Microsoft.Cci.MutableCodeModel.CreateArray : Expression {
    private ITypeReference elementType;
    private List`1<IExpression> initializers;
    private List`1<int> lowerBounds;
    private UInt32 rank;
    private List`1<IExpression> sizes;
    public ITypeReference ElementType { get; public set; }
    public List`1<IExpression> Initializers { get; public set; }
    public List`1<int> LowerBounds { get; public set; }
    public UInt32 Rank { get; public set; }
    public List`1<IExpression> Sizes { get; public set; }
    private IEnumerable`1<IExpression> Microsoft.Cci.ICreateArray.Initializers { get; }
    private IEnumerable`1<int> Microsoft.Cci.ICreateArray.LowerBounds { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.ICreateArray.Sizes { get; }
    private IEnumerable`1<IMetadataExpression> Microsoft.Cci.IMetadataCreateArray.Initializers { get; }
    private IEnumerable`1<int> Microsoft.Cci.IMetadataCreateArray.LowerBounds { get; }
    private IEnumerable`1<ulong> Microsoft.Cci.IMetadataCreateArray.Sizes { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public CreateArray(ICreateArray createArray);
    private void ObjectInvariant();
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_ElementType();
    public void set_ElementType(ITypeReference value);
    public List`1<IExpression> get_Initializers();
    public void set_Initializers(List`1<IExpression> value);
    public List`1<int> get_LowerBounds();
    public void set_LowerBounds(List`1<int> value);
    public sealed virtual UInt32 get_Rank();
    public void set_Rank(UInt32 value);
    public List`1<IExpression> get_Sizes();
    public void set_Sizes(List`1<IExpression> value);
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.ICreateArray.get_Initializers();
    private sealed virtual override IEnumerable`1<int> Microsoft.Cci.ICreateArray.get_LowerBounds();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.ICreateArray.get_Sizes();
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.CreateArray/<Microsoft-Cci-IMetadataCreateArray-get_Initializers>d__32")]
private sealed virtual override IEnumerable`1<IMetadataExpression> Microsoft.Cci.IMetadataCreateArray.get_Initializers();
    private sealed virtual override IEnumerable`1<int> Microsoft.Cci.IMetadataCreateArray.get_LowerBounds();
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.CreateArray/<Microsoft-Cci-IMetadataCreateArray-get_Sizes>d__36")]
private sealed virtual override IEnumerable`1<ulong> Microsoft.Cci.IMetadataCreateArray.get_Sizes();
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
public class Microsoft.Cci.MutableCodeModel.CreateDelegateInstance : Expression {
    private IExpression instance;
    private bool isVirtualDelegate;
    private IMethodReference methodToCallViaDelegate;
    public IExpression Instance { get; public set; }
    public bool IsVirtualDelegate { get; public set; }
    public IMethodReference MethodToCallViaDelegate { get; public set; }
    public CreateDelegateInstance(ICreateDelegateInstance createDelegateInstance);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Instance();
    public void set_Instance(IExpression value);
    public sealed virtual bool get_IsVirtualDelegate();
    public void set_IsVirtualDelegate(bool value);
    public sealed virtual IMethodReference get_MethodToCallViaDelegate();
    public void set_MethodToCallViaDelegate(IMethodReference value);
}
public class Microsoft.Cci.MutableCodeModel.CreateObjectInstance : ConstructorOrMethodCall {
    private IEnumerable`1<IExpression> Microsoft.Cci.ICreateObjectInstance.Arguments { get; }
    private IMethodReference Microsoft.Cci.ICreateObjectInstance.MethodToCall { get; }
    public CreateObjectInstance(ICreateObjectInstance createObjectInstance);
    public virtual void Dispatch(ICodeVisitor visitor);
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.ICreateObjectInstance.get_Arguments();
    private sealed virtual override IMethodReference Microsoft.Cci.ICreateObjectInstance.get_MethodToCall();
}
public class Microsoft.Cci.MutableCodeModel.CustomAttribute : object {
    private List`1<IMetadataExpression> arguments;
    private IMethodReference constructor;
    private List`1<IMetadataNamedArgument> namedArguments;
    public List`1<IMetadataExpression> Arguments { get; public set; }
    public IMethodReference Constructor { get; public set; }
    public List`1<IMetadataNamedArgument> NamedArguments { get; public set; }
    public ushort NumberOfNamedArguments { get; }
    public ITypeReference Type { get; }
    private IEnumerable`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.Arguments { get; }
    private IEnumerable`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.NamedArguments { get; }
    public sealed virtual void Copy(ICustomAttribute customAttribute, IInternFactory internFactory);
    public List`1<IMetadataExpression> get_Arguments();
    public void set_Arguments(List`1<IMetadataExpression> value);
    public sealed virtual IMethodReference get_Constructor();
    public void set_Constructor(IMethodReference value);
    public List`1<IMetadataNamedArgument> get_NamedArguments();
    public void set_NamedArguments(List`1<IMetadataNamedArgument> value);
    public sealed virtual ushort get_NumberOfNamedArguments();
    public sealed virtual ITypeReference get_Type();
    private sealed virtual override IEnumerable`1<IMetadataExpression> Microsoft.Cci.ICustomAttribute.get_Arguments();
    private sealed virtual override IEnumerable`1<IMetadataNamedArgument> Microsoft.Cci.ICustomAttribute.get_NamedArguments();
}
public class Microsoft.Cci.MutableCodeModel.CustomModifier : object {
    private bool isOptional;
    private ITypeReference modifier;
    public bool IsOptional { get; public set; }
    public ITypeReference Modifier { get; public set; }
    public sealed virtual void Copy(ICustomModifier customModifier, IInternFactory internFactory);
    public sealed virtual bool get_IsOptional();
    public void set_IsOptional(bool value);
    public sealed virtual ITypeReference get_Modifier();
    public void set_Modifier(ITypeReference value);
}
public class Microsoft.Cci.MutableCodeModel.DebuggerBreakStatement : Statement {
    public DebuggerBreakStatement(IDebuggerBreakStatement debuggerBreakStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.DefaultValue : Expression {
    private ITypeReference defaultValueType;
    public ITypeReference DefaultValueType { get; public set; }
    public DefaultValue(IDefaultValue defaultValue);
    public sealed virtual ITypeReference get_DefaultValueType();
    public void set_DefaultValueType(ITypeReference value);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.Division : BinaryOperation {
    [CompilerGeneratedAttribute]
private bool <TreatOperandsAsUnsignedIntegers>k__BackingField;
    public bool TreatOperandsAsUnsignedIntegers { get; public set; }
    public Division(IDivision division);
    public virtual void Dispatch(ICodeVisitor visitor);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatOperandsAsUnsignedIntegers();
    [CompilerGeneratedAttribute]
public void set_TreatOperandsAsUnsignedIntegers(bool value);
}
public class Microsoft.Cci.MutableCodeModel.DoUntilStatement : Statement {
    private IStatement body;
    private IExpression condition;
    public IStatement Body { get; public set; }
    public IExpression Condition { get; public set; }
    public DoUntilStatement(IDoUntilStatement doUntilStatement);
    public sealed virtual IStatement get_Body();
    public void set_Body(IStatement value);
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.DupValue : Expression {
    public DupValue(IDupValue dupValue);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.EmptyStatement : Statement {
    private bool isSentinel;
    public bool IsSentinel { get; public set; }
    public EmptyStatement(IEmptyStatement emptyStatement);
    public virtual EmptyStatement Clone();
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsSentinel();
    public void set_IsSentinel(bool value);
}
public class Microsoft.Cci.MutableCodeModel.Equality : BinaryOperation {
    public Equality(IEquality equality);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.EventDefinition : TypeDefinitionMember {
    private List`1<IMethodReference> accessors;
    private IMethodReference adder;
    private IMethodReference caller;
    private IMethodReference remover;
    private ITypeReference type;
    public List`1<IMethodReference> Accessors { get; public set; }
    public IMethodReference Adder { get; public set; }
    public IMethodReference Caller { get; public set; }
    public bool IsRuntimeSpecial { get; public set; }
    public bool IsSpecialName { get; public set; }
    public IMethodReference Remover { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<IMethodReference> Microsoft.Cci.IEventDefinition.Accessors { get; }
    public sealed virtual void Copy(IEventDefinition eventDefinition, IInternFactory internFactory);
    public List`1<IMethodReference> get_Accessors();
    public void set_Accessors(List`1<IMethodReference> value);
    public sealed virtual IMethodReference get_Adder();
    public void set_Adder(IMethodReference value);
    public sealed virtual IMethodReference get_Caller();
    public void set_Caller(IMethodReference value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_IsRuntimeSpecial();
    public void set_IsRuntimeSpecial(bool value);
    public sealed virtual bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public sealed virtual IMethodReference get_Remover();
    public void set_Remover(IMethodReference value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<IMethodReference> Microsoft.Cci.IEventDefinition.get_Accessors();
}
public class Microsoft.Cci.MutableCodeModel.ExclusiveOr : BinaryOperation {
    public ExclusiveOr(IExclusiveOr exclusiveOr);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public abstract class Microsoft.Cci.MutableCodeModel.Expression : object {
    private List`1<ILocation> locations;
    private ITypeReference type;
    public List`1<ILocation> Locations { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    protected Expression(IExpression expression);
    private void ObjectInvariant();
    public abstract virtual void Dispatch(ICodeVisitor visitor);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.ExpressionStatement : Statement {
    private IExpression expression;
    public IExpression Expression { get; public set; }
    public ExpressionStatement(IExpressionStatement expressionStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Expression();
    public void set_Expression(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.FieldDefinition : TypeDefinitionMember {
    private int bitLength;
    private IMetadataConstant compileTimeValue;
    private List`1<ICustomModifier> customModifiers;
    private ISectionBlock fieldMapping;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    private IMarshallingInformation marshallingInformation;
    private UInt32 offset;
    private int sequenceNumber;
    private ITypeReference type;
    public UInt32 BitLength { get; public set; }
    public IMetadataConstant CompileTimeValue { get; public set; }
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public ISectionBlock FieldMapping { get; public set; }
    public IInternFactory InternFactory { get; public set; }
    public UInt32 InternedKey { get; }
    public bool IsBitField { get; }
    public bool IsCompileTimeConstant { get; public set; }
    public bool IsMapped { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsNotSerialized { get; public set; }
    public bool IsReadOnly { get; public set; }
    public bool IsRuntimeSpecial { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsStatic { get; public set; }
    public IMarshallingInformation MarshallingInformation { get; public set; }
    public UInt32 Offset { get; public set; }
    public int SequenceNumber { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.IFieldReference.CustomModifiers { get; }
    public IFieldDefinition ResolvedField { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    public sealed virtual void Copy(IFieldDefinition fieldDefinition, IInternFactory internFactory);
    public sealed virtual UInt32 get_BitLength();
    public void set_BitLength(UInt32 value);
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public void set_CompileTimeValue(IMetadataConstant value);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ISectionBlock get_FieldMapping();
    public void set_FieldMapping(ISectionBlock value);
    public IInternFactory get_InternFactory();
    public void set_InternFactory(IInternFactory value);
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsBitField();
    public sealed virtual bool get_IsCompileTimeConstant();
    public void set_IsCompileTimeConstant(bool value);
    public sealed virtual bool get_IsMapped();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public sealed virtual bool get_IsRuntimeSpecial();
    public void set_IsRuntimeSpecial(bool value);
    public sealed virtual bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsStatic();
    public void set_IsStatic(bool value);
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public void set_MarshallingInformation(IMarshallingInformation value);
    public sealed virtual UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public sealed virtual int get_SequenceNumber();
    public void set_SequenceNumber(int value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.IFieldReference.get_CustomModifiers();
    public sealed virtual IFieldDefinition get_ResolvedField();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
public class Microsoft.Cci.MutableCodeModel.FieldReference : object {
    private List`1<ICustomAttribute> attributes;
    private ITypeReference containingType;
    private List`1<ICustomModifier> customModifiers;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    private bool isFrozen;
    private bool isStatic;
    private List`1<ILocation> locations;
    private IName name;
    private IFieldDefinition resolvedField;
    private ITypeReference type;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public ITypeReference ContainingType { get; public set; }
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public IInternFactory InternFactory { get; public set; }
    public UInt32 InternedKey { get; }
    public bool IsFrozen { get; public set; }
    public bool IsModified { get; }
    public bool IsStatic { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public IName Name { get; public set; }
    public IFieldDefinition ResolvedField { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.IFieldReference.CustomModifiers { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public sealed virtual void Copy(IFieldReference fieldReference, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual ITypeReference get_ContainingType();
    public void set_ContainingType(ITypeReference value);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public IInternFactory get_InternFactory();
    public void set_InternFactory(IInternFactory value);
    public sealed virtual UInt32 get_InternedKey();
    public bool get_IsFrozen();
    public void set_IsFrozen(bool value);
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsStatic();
    public void set_IsStatic(bool value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual IFieldDefinition get_ResolvedField();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.IFieldReference.get_CustomModifiers();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.FileReference : object {
    private IAssembly containingAssembly;
    private IName fileName;
    private List`1<byte> hashValue;
    private bool hasMetadata;
    public IAssembly ContainingAssembly { get; public set; }
    public IName FileName { get; public set; }
    public List`1<byte> HashValue { get; public set; }
    public bool HasMetadata { get; public set; }
    private IEnumerable`1<byte> Microsoft.Cci.IFileReference.HashValue { get; }
    public sealed virtual void Copy(IFileReference fileReference, IInternFactory internFactory);
    public sealed virtual IAssembly get_ContainingAssembly();
    public void set_ContainingAssembly(IAssembly value);
    public sealed virtual IName get_FileName();
    public void set_FileName(IName value);
    public List`1<byte> get_HashValue();
    public void set_HashValue(List`1<byte> value);
    public sealed virtual bool get_HasMetadata();
    public void set_HasMetadata(bool value);
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IFileReference.get_HashValue();
}
public class Microsoft.Cci.MutableCodeModel.FillMemoryStatement : Statement {
    private IExpression fillValue;
    private IExpression targetAddress;
    private IExpression numberOfBytesToFill;
    public IExpression FillValue { get; public set; }
    public IExpression TargetAddress { get; public set; }
    public IExpression NumberOfBytesToFill { get; public set; }
    public FillMemoryStatement(IFillMemoryStatement fillMemoryStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_FillValue();
    public void set_FillValue(IExpression value);
    public sealed virtual IExpression get_TargetAddress();
    public void set_TargetAddress(IExpression value);
    public sealed virtual IExpression get_NumberOfBytesToFill();
    public void set_NumberOfBytesToFill(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.ForEachStatement : Statement {
    private IStatement body;
    private IExpression collection;
    private ILocalDefinition variable;
    public IStatement Body { get; public set; }
    public IExpression Collection { get; public set; }
    public ILocalDefinition Variable { get; public set; }
    public ForEachStatement(IForEachStatement forEachStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IStatement get_Body();
    public void set_Body(IStatement value);
    public sealed virtual IExpression get_Collection();
    public void set_Collection(IExpression value);
    public sealed virtual ILocalDefinition get_Variable();
    public void set_Variable(ILocalDefinition value);
}
public class Microsoft.Cci.MutableCodeModel.ForStatement : Statement {
    private IStatement body;
    private IExpression condition;
    private List`1<IStatement> incrementStatements;
    private List`1<IStatement> initStatements;
    public IStatement Body { get; public set; }
    public IExpression Condition { get; public set; }
    public List`1<IStatement> IncrementStatements { get; public set; }
    public List`1<IStatement> InitStatements { get; public set; }
    private IEnumerable`1<IStatement> Microsoft.Cci.IForStatement.IncrementStatements { get; }
    private IEnumerable`1<IStatement> Microsoft.Cci.IForStatement.InitStatements { get; }
    public ForStatement(IForStatement forStatement);
    private void ObjectInvariant();
    public sealed virtual IStatement get_Body();
    public void set_Body(IStatement value);
    public virtual ForStatement Clone();
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public List`1<IStatement> get_IncrementStatements();
    public void set_IncrementStatements(List`1<IStatement> value);
    public List`1<IStatement> get_InitStatements();
    public void set_InitStatements(List`1<IStatement> value);
    private sealed virtual override IEnumerable`1<IStatement> Microsoft.Cci.IForStatement.get_IncrementStatements();
    private sealed virtual override IEnumerable`1<IStatement> Microsoft.Cci.IForStatement.get_InitStatements();
}
public class Microsoft.Cci.MutableCodeModel.FunctionPointerTypeReference : TypeReference {
    private CallingConvention callingConvention;
    private List`1<IParameterTypeInformation> extraArgumentTypes;
    private List`1<IParameterTypeInformation> parameters;
    private IFunctionPointer resolvedFunctionPointer;
    private List`1<ICustomModifier> returnValueCustomModifiers;
    private bool returnValueIsByRef;
    private ITypeReference type;
    public CallingConvention CallingConvention { get; public set; }
    public bool IsStatic { get; }
    public List`1<IParameterTypeInformation> ExtraArgumentTypes { get; public set; }
    public List`1<IParameterTypeInformation> Parameters { get; public set; }
    public ITypeDefinition ResolvedType { get; }
    public IFunctionPointer ResolvedFunctionPointer { get; }
    public List`1<ICustomModifier> ReturnValueCustomModifiers { get; public set; }
    public bool ReturnValueIsByRef { get; public set; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.IFunctionPointerTypeReference.ExtraArgumentTypes { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IFunctionPointerTypeReference functionPointerTypeReference, IInternFactory internFactory);
    public sealed virtual CallingConvention get_CallingConvention();
    public void set_CallingConvention(CallingConvention value);
    public sealed virtual bool get_IsStatic();
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<IParameterTypeInformation> get_ExtraArgumentTypes();
    public void set_ExtraArgumentTypes(List`1<IParameterTypeInformation> value);
    public List`1<IParameterTypeInformation> get_Parameters();
    public void set_Parameters(List`1<IParameterTypeInformation> value);
    public virtual ITypeDefinition get_ResolvedType();
    public IFunctionPointer get_ResolvedFunctionPointer();
    public List`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public void set_ReturnValueCustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_ReturnValueIsByRef();
    public void set_ReturnValueIsByRef(bool value);
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.IFunctionPointerTypeReference.get_ExtraArgumentTypes();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
}
public class Microsoft.Cci.MutableCodeModel.GenericMethodInstanceReference : MethodReference {
    private List`1<ITypeReference> genericArguments;
    private IMethodReference genericMethod;
    public List`1<ITypeReference> GenericArguments { get; public set; }
    public IMethodReference GenericMethod { get; public set; }
    private IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericMethodInstanceReference.GenericArguments { get; }
    public sealed virtual void Copy(IGenericMethodInstanceReference genericMethodInstanceReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<ITypeReference> get_GenericArguments();
    public void set_GenericArguments(List`1<ITypeReference> value);
    public sealed virtual IMethodReference get_GenericMethod();
    public void set_GenericMethod(IMethodReference value);
    protected virtual IMethodDefinition Resolve();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericMethodInstanceReference.get_GenericArguments();
}
public class Microsoft.Cci.MutableCodeModel.GenericMethodParameter : GenericParameter {
    private IMethodDefinition definingMethod;
    public IMethodDefinition DefiningMethod { get; public set; }
    private IMethodReference Microsoft.Cci.IGenericMethodParameterReference.DefiningMethod { get; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    public sealed virtual void Copy(IGenericMethodParameter genericMehodParameter, IInternFactory internFactory);
    public sealed virtual IMethodDefinition get_DefiningMethod();
    public void set_DefiningMethod(IMethodDefinition value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override IMethodReference Microsoft.Cci.IGenericMethodParameterReference.get_DefiningMethod();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
}
public class Microsoft.Cci.MutableCodeModel.GenericMethodParameterReference : TypeReference {
    private IMethodReference definingMethod;
    private IName name;
    private ushort index;
    private IGenericMethodParameter resolvedType;
    public IMethodReference DefiningMethod { get; public set; }
    public IName Name { get; public set; }
    public ushort Index { get; public set; }
    private IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.ResolvedType { get; }
    public ITypeDefinition ResolvedType { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IGenericMethodParameterReference genericMethodParameterReference, IInternFactory internFactory);
    public sealed virtual IMethodReference get_DefiningMethod();
    public void set_DefiningMethod(IMethodReference value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual ushort get_Index();
    public void set_Index(ushort value);
    private void Resolve();
    private sealed virtual override IGenericMethodParameter Microsoft.Cci.IGenericMethodParameterReference.get_ResolvedType();
    public virtual ITypeDefinition get_ResolvedType();
}
public abstract class Microsoft.Cci.MutableCodeModel.GenericParameter : NamedTypeDefinition {
    private List`1<ITypeReference> constraints;
    private ushort index;
    public List`1<ITypeReference> Constraints { get; public set; }
    public ushort Index { get; public set; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool MustBeReferenceType { get; public set; }
    public bool MustBeValueType { get; public set; }
    public bool MustHaveDefaultConstructor { get; public set; }
    public TypeParameterVariance Variance { get; public set; }
    private IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericParameter.Constraints { get; }
    public sealed virtual void Copy(IGenericParameter genericParameter, IInternFactory internFactory);
    public List`1<ITypeReference> get_Constraints();
    public void set_Constraints(List`1<ITypeReference> value);
    private ITypeDefinition GetEffectiveBaseClass();
    public sealed virtual ushort get_Index();
    public void set_Index(ushort value);
    public virtual bool get_IsReferenceType();
    public virtual bool get_IsValueType();
    public sealed virtual bool get_MustBeReferenceType();
    public void set_MustBeReferenceType(bool value);
    public sealed virtual bool get_MustBeValueType();
    public void set_MustBeValueType(bool value);
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public void set_MustHaveDefaultConstructor(bool value);
    public sealed virtual TypeParameterVariance get_Variance();
    public void set_Variance(TypeParameterVariance value);
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericParameter.get_Constraints();
}
public class Microsoft.Cci.MutableCodeModel.GenericTypeInstanceReference : TypeReference {
    private List`1<ITypeReference> genericArguments;
    private INamedTypeReference genericType;
    private IGenericTypeInstance resolvedGenericTypeInstance;
    public List`1<ITypeReference> GenericArguments { get; public set; }
    public INamedTypeReference GenericType { get; public set; }
    public IGenericTypeInstance ResolvedGenericTypeInstance { get; }
    public ITypeDefinition ResolvedType { get; }
    private IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericTypeInstanceReference.GenericArguments { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IGenericTypeInstanceReference genericTypeInstanceReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<ITypeReference> get_GenericArguments();
    public void set_GenericArguments(List`1<ITypeReference> value);
    public sealed virtual INamedTypeReference get_GenericType();
    public void set_GenericType(INamedTypeReference value);
    public IGenericTypeInstance get_ResolvedGenericTypeInstance();
    public virtual ITypeDefinition get_ResolvedType();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IGenericTypeInstanceReference.get_GenericArguments();
}
public class Microsoft.Cci.MutableCodeModel.GenericTypeParameter : GenericParameter {
    private ITypeDefinition definingType;
    public ITypeDefinition DefiningType { get; public set; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    public sealed virtual void Copy(IGenericTypeParameter genericTypeParameter, IInternFactory internFactory);
    public sealed virtual ITypeDefinition get_DefiningType();
    public void set_DefiningType(ITypeDefinition value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
}
public class Microsoft.Cci.MutableCodeModel.GenericTypeParameterReference : TypeReference {
    private ITypeReference definingType;
    private IName name;
    private ushort index;
    private IGenericTypeParameter resolvedType;
    public ITypeReference DefiningType { get; public set; }
    public IName Name { get; public set; }
    public ushort Index { get; public set; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    public ITypeDefinition ResolvedType { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IGenericTypeParameterReference genericTypeParameterReference, IInternFactory internFactory);
    public sealed virtual ITypeReference get_DefiningType();
    public void set_DefiningType(ITypeReference value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual ushort get_Index();
    public void set_Index(ushort value);
    private IGenericTypeParameter Resolve();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
    public virtual ITypeDefinition get_ResolvedType();
}
public class Microsoft.Cci.MutableCodeModel.GetTypeOfTypedReference : Expression {
    private IExpression typedReference;
    public IExpression TypedReference { get; public set; }
    public GetTypeOfTypedReference(IGetTypeOfTypedReference getTypeOfTypedReference);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_TypedReference();
    public void set_TypedReference(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.GetValueOfTypedReference : Expression {
    private ITypeReference targetType;
    private IExpression typedReference;
    public ITypeReference TargetType { get; public set; }
    public IExpression TypedReference { get; public set; }
    public GetValueOfTypedReference(IGetValueOfTypedReference getValueOfTypedReference);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_TargetType();
    public void set_TargetType(ITypeReference value);
    public sealed virtual IExpression get_TypedReference();
    public void set_TypedReference(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.GlobalFieldDefinition : FieldDefinition {
    private INamespaceDefinition containingNamespace;
    public INamespaceDefinition ContainingNamespace { get; public set; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    public sealed virtual void Copy(IGlobalFieldDefinition globalFieldDefinition, IInternFactory internFactory);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public void set_ContainingNamespace(INamespaceDefinition value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
}
public class Microsoft.Cci.MutableCodeModel.GlobalMethodDefinition : MethodDefinition {
    private INamespaceDefinition containingNamespace;
    public INamespaceDefinition ContainingNamespace { get; public set; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    public sealed virtual void Copy(IGlobalMethodDefinition globalMethodDefinition, IInternFactory internFactory);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public void set_ContainingNamespace(INamespaceDefinition value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
}
public class Microsoft.Cci.MutableCodeModel.GotoStatement : Statement {
    private ILabeledStatement targetStatement;
    public ILabeledStatement TargetStatement { get; public set; }
    public GotoStatement(IGotoStatement gotoStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ILabeledStatement get_TargetStatement();
    public void set_TargetStatement(ILabeledStatement value);
}
public class Microsoft.Cci.MutableCodeModel.GotoSwitchCaseStatement : Statement {
    private ISwitchCase targetCase;
    public ISwitchCase TargetCase { get; public set; }
    public GotoSwitchCaseStatement(IGotoSwitchCaseStatement gotoSwitchCaseStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ISwitchCase get_TargetCase();
    public void set_TargetCase(ISwitchCase value);
}
public class Microsoft.Cci.MutableCodeModel.GreaterThan : BinaryOperation {
    private bool unsignedOrUnordered;
    public bool IsUnsignedOrUnordered { get; public set; }
    public GreaterThan(IGreaterThan greaterThan);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsUnsignedOrUnordered();
    public void set_IsUnsignedOrUnordered(bool value);
}
public class Microsoft.Cci.MutableCodeModel.GreaterThanOrEqual : BinaryOperation {
    private bool unsignedOrUnordered;
    public bool IsUnsignedOrUnordered { get; public set; }
    public GreaterThanOrEqual(IGreaterThanOrEqual greaterThanOrEqual);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsUnsignedOrUnordered();
    public void set_IsUnsignedOrUnordered(bool value);
}
public interface Microsoft.Cci.MutableCodeModel.ICopyFrom`1 {
    public abstract virtual void Copy(ImmutableObject objectToCopy, IInternFactory internFactory);
}
internal abstract class Microsoft.Cci.MutableCodeModel.ICopyFromContract`1 : object {
    public sealed virtual void Copy(ImmutableObject objectToCopy, IInternFactory internFactory);
}
internal class Microsoft.Cci.MutableCodeModel.IteratorClosureGenerator : object {
    private IMetadataHost host;
    private ISourceLocationProvider sourceLocationProvider;
    private Dictionary`2<IBlockStatement, UInt32> iteratorLocalCount;
    private IMethodDefinition method;
    private List`1<ITypeDefinition> privateHelperTypes;
    private List`1<ILocalDefinition> allLocals;
    private CopyTypeFromIteratorToClosure copyTypeToClosure;
    private Dictionary`2<UInt32, IGenericTypeParameter> genericTypeParameterMapping;
    private Dictionary`2<object, BoundField> fieldForCapturedLocalOrParameter;
    private bool isEnumerable;
    private IMethodReference compilerGeneratedCtor;
    private IMethodReference objectCtor;
    private IMethodReference debuggerHiddenCtor;
    internal Dictionary`2<object, BoundField> FieldForCapturedLocalOrParameter { get; }
    private IMethodReference CompilerGeneratedCtor { get; }
    private IMethodReference ObjectCtor { get; }
    private IMethodReference DebuggerHiddenCtor { get; }
    private IPropertyDefinition ThreadDotManagedThreadId { get; }
    private MethodCall ThreadDotCurrentThread { get; }
    internal IteratorClosureGenerator(IMethodDefinition method, List`1<ITypeDefinition> privateHelperTypes, IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    internal Dictionary`2<object, BoundField> get_FieldForCapturedLocalOrParameter();
    internal BlockStatement CompileIterator(IBlockStatement block);
    private IMethodReference get_CompilerGeneratedCtor();
    private IMethodReference get_ObjectCtor();
    private IMethodReference get_DebuggerHiddenCtor();
    private BlockStatement CreateNewIteratorMethodBody(IteratorClosureInformation iteratorClosure);
    private ITypeReference GetLocalOrParameterType(object obj);
    private ITypeReference GetClosureTypeReferenceFromIterator(IteratorClosureInformation iteratorClosure);
    private IFieldReference GetFieldReference(IteratorClosureInformation iteratorClosure, IFieldDefinition fieldDefinition);
    private IMethodReference GetMethodReference(IteratorClosureInformation iteratorClosure, IMethodDefinition methodDefinition);
    private IteratorClosureInformation CreateIteratorClosure(BlockStatement blockStatement);
    private void CreateIteratorClosureConstructor(IteratorClosureInformation iteratorClosure);
    private void CreateIteratorClosureMethods(IteratorClosureInformation iteratorClosure, BlockStatement blockStatement);
    private void CreateMoveNextMethod(IteratorClosureInformation iteratorClosure, BlockStatement blockStatement);
    private IBlockStatement TranslateIteratorMethodBodyToMoveNextBody(IteratorClosureInformation iteratorClosure, BlockStatement blockStatement);
    private BlockStatement BuildStateMachine(IteratorClosureInformation iteratorClosure, BlockStatement oldBody, Dictionary`2<int, ILabeledStatement> stateEntries);
    private void CreateResetMethod(IteratorClosureInformation iteratorClosure);
    private void CreateDisposeMethod(IteratorClosureInformation iteratorClosure);
    private IPropertyDefinition get_ThreadDotManagedThreadId();
    private MethodCall get_ThreadDotCurrentThread();
    private void CreateGetEnumeratorMethodGeneric(IteratorClosureInformation iteratorClosure);
    private BlockStatement GetBodyOfGenericGetEnumerator(IteratorClosureInformation iteratorClosure);
    private void CreateGetEnumeratorMethodNonGeneric(IteratorClosureInformation iteratorClosure);
    private void CreateIteratorClosureProperties(IteratorClosureInformation iteratorClosure);
    private void CreateIteratorClosureFields(IteratorClosureInformation iteratorClosure);
    private IEnumerable`1<ITypeReference> GetClosureEnumeratorTypeArguments(ITypeReference methodTypeReference);
}
internal class Microsoft.Cci.MutableCodeModel.IteratorClosureInformation : object {
    private IMetadataHost host;
    internal NestedTypeDefinition ClosureDefinition;
    private ITypeReference closureDefinitionReference;
    private IFieldDefinition currentField;
    private IFieldReference currentFieldReference;
    private IFieldDefinition stateField;
    private IFieldReference stateFieldReference;
    private IFieldDefinition thisField;
    private IFieldReference thisFieldReference;
    private IFieldDefinition initialThreadId;
    private IFieldReference threadIdFieldReference;
    private IMethodDefinition constructor;
    private IMethodReference constructorReference;
    private IMethodDefinition moveNext;
    private IMethodDefinition genericGetEnumerator;
    private IMethodReference genericGetEnumeratorReference;
    private IMethodDefinition genericGetCurrent;
    private IMethodReference genericGetCurrentReference;
    private IMethodDefinition disposeMethod;
    private IMethodDefinition reset;
    private IMethodDefinition nonGenericGetCurrent;
    private IMethodDefinition nonGenericGetEnumerator;
    private ITypeReference nonGenericIEnumeratorInterface;
    private ITypeReference genericIEnumeratorInterface;
    private ITypeReference nonGenericIEnumerableInterface;
    private ITypeReference genericIEnumerableInterface;
    private ITypeReference disposableInterface;
    private ITypeReference elementType;
    private ITypeReference platformIDisposable;
    internal ITypeReference ClosureDefinitionReference { get; }
    internal IFieldDefinition CurrentField { get; internal set; }
    internal IFieldReference CurrentFieldReference { get; }
    internal IFieldDefinition StateField { get; internal set; }
    internal IFieldReference StateFieldReference { get; }
    internal IFieldDefinition ThisField { get; internal set; }
    internal IFieldReference ThisFieldReference { get; }
    internal IFieldDefinition InitialThreadId { get; internal set; }
    internal IFieldReference InitThreadIdFieldReference { get; }
    internal IMethodDefinition Constructor { get; internal set; }
    internal IMethodReference ConstructorReference { get; }
    internal IMethodDefinition MoveNext { get; internal set; }
    internal IMethodDefinition GenericGetEnumerator { get; internal set; }
    internal IMethodReference GenericGetEnumeratorReference { get; }
    internal IMethodDefinition GenericGetCurrent { get; internal set; }
    internal IMethodReference GenericGetCurrentReference { get; }
    internal IMethodDefinition DisposeMethod { get; internal set; }
    internal IMethodDefinition Reset { get; internal set; }
    internal IMethodDefinition NonGenericGetCurrent { get; internal set; }
    internal IMethodDefinition NonGenericGetEnumerator { get; internal set; }
    internal ITypeReference NonGenericIEnumeratorInterface { get; internal set; }
    internal ITypeReference GenericIEnumeratorInterface { get; internal set; }
    internal ITypeReference NonGenericIEnumerableInterface { get; internal set; }
    internal ITypeReference GenericIEnumerableInterface { get; internal set; }
    internal ITypeReference DisposableInterface { get; internal set; }
    internal ITypeReference ElementType { get; internal set; }
    private ITypeReference PlatformIDisposable { get; }
    internal IteratorClosureInformation(IMetadataHost host);
    internal ITypeReference get_ClosureDefinitionReference();
    internal IFieldReference GetReferenceOfFieldUsedByPeers(IFieldDefinition fieldDef);
    internal IFieldDefinition get_CurrentField();
    internal void set_CurrentField(IFieldDefinition value);
    internal IFieldReference get_CurrentFieldReference();
    internal IFieldDefinition get_StateField();
    internal void set_StateField(IFieldDefinition value);
    internal IFieldReference get_StateFieldReference();
    internal IFieldDefinition get_ThisField();
    internal void set_ThisField(IFieldDefinition value);
    internal IFieldReference get_ThisFieldReference();
    internal IFieldDefinition get_InitialThreadId();
    internal void set_InitialThreadId(IFieldDefinition value);
    internal IFieldReference get_InitThreadIdFieldReference();
    internal IMethodDefinition get_Constructor();
    internal void set_Constructor(IMethodDefinition value);
    internal IMethodReference get_ConstructorReference();
    internal IMethodDefinition get_MoveNext();
    internal void set_MoveNext(IMethodDefinition value);
    private IMethodReference GetReferenceOfMethodUsedByPeers(IMethodDefinition method);
    internal IMethodDefinition get_GenericGetEnumerator();
    internal void set_GenericGetEnumerator(IMethodDefinition value);
    internal IMethodReference get_GenericGetEnumeratorReference();
    internal IMethodDefinition get_GenericGetCurrent();
    internal void set_GenericGetCurrent(IMethodDefinition value);
    internal IMethodReference get_GenericGetCurrentReference();
    internal IMethodDefinition get_DisposeMethod();
    internal void set_DisposeMethod(IMethodDefinition value);
    internal IMethodDefinition get_Reset();
    internal void set_Reset(IMethodDefinition value);
    internal IMethodDefinition get_NonGenericGetCurrent();
    internal void set_NonGenericGetCurrent(IMethodDefinition value);
    internal IMethodDefinition get_NonGenericGetEnumerator();
    internal void set_NonGenericGetEnumerator(IMethodDefinition value);
    internal void AddField(IFieldDefinition field);
    internal ITypeReference get_NonGenericIEnumeratorInterface();
    internal void set_NonGenericIEnumeratorInterface(ITypeReference value);
    internal ITypeReference get_GenericIEnumeratorInterface();
    internal void set_GenericIEnumeratorInterface(ITypeReference value);
    internal ITypeReference get_NonGenericIEnumerableInterface();
    internal void set_NonGenericIEnumerableInterface(ITypeReference value);
    internal ITypeReference get_GenericIEnumerableInterface();
    internal void set_GenericIEnumerableInterface(ITypeReference value);
    internal ITypeReference get_DisposableInterface();
    internal void set_DisposableInterface(ITypeReference value);
    internal ITypeReference get_ElementType();
    internal void set_ElementType(ITypeReference value);
    internal void InitializeInterfaces(ITypeReference elementType, bool isEnumerable);
    private ITypeReference get_PlatformIDisposable();
}
public class Microsoft.Cci.MutableCodeModel.LabeledStatement : Statement {
    private IName labelName;
    private IStatement statement;
    public IName Label { get; public set; }
    public IStatement Statement { get; public set; }
    public LabeledStatement(ILabeledStatement labeledStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IName get_Label();
    public void set_Label(IName value);
    public sealed virtual IStatement get_Statement();
    public void set_Statement(IStatement value);
}
public class Microsoft.Cci.MutableCodeModel.LeftShift : BinaryOperation {
    public LeftShift(ILeftShift leftShift);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.LessThan : BinaryOperation {
    private bool unsignedOrUnordered;
    public bool IsUnsignedOrUnordered { get; public set; }
    public LessThan(ILessThan lessThan);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsUnsignedOrUnordered();
    public void set_IsUnsignedOrUnordered(bool value);
}
public class Microsoft.Cci.MutableCodeModel.LessThanOrEqual : BinaryOperation {
    private bool unsignedOrUnordered;
    public bool IsUnsignedOrUnordered { get; public set; }
    public LessThanOrEqual(ILessThanOrEqual lessThanOrEqual);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsUnsignedOrUnordered();
    public void set_IsUnsignedOrUnordered(bool value);
}
public class Microsoft.Cci.MutableCodeModel.LocalDeclarationStatement : Statement {
    private IExpression initialValue;
    private ILocalDefinition localVariable;
    public IExpression InitialValue { get; public set; }
    public ILocalDefinition LocalVariable { get; public set; }
    public LocalDeclarationStatement(ILocalDeclarationStatement localDeclarationStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_InitialValue();
    public void set_InitialValue(IExpression value);
    public sealed virtual ILocalDefinition get_LocalVariable();
    public void set_LocalVariable(ILocalDefinition value);
}
public class Microsoft.Cci.MutableCodeModel.LocalDefinition : object {
    private IMetadataConstant compileTimeValue;
    private List`1<ICustomModifier> customModifiers;
    private bool isModified;
    private bool isPinned;
    private bool isReference;
    private IName name;
    private List`1<ILocation> locations;
    private IMethodDefinition methodDefinition;
    private ITypeReference type;
    public IMetadataConstant CompileTimeValue { get; public set; }
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public bool IsConstant { get; }
    public bool IsModified { get; public set; }
    public bool IsPinned { get; public set; }
    public bool IsReference { get; public set; }
    public IName Name { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public IMethodDefinition MethodDefinition { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ILocalDefinition.CustomModifiers { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(ILocalDefinition localVariableDefinition, IInternFactory internFactory);
    public virtual LocalDefinition Clone();
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public void set_CompileTimeValue(IMetadataConstant value);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public void set_IsModified(bool value);
    public sealed virtual bool get_IsPinned();
    public void set_IsPinned(bool value);
    public sealed virtual bool get_IsReference();
    public void set_IsReference(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public void set_MethodDefinition(IMethodDefinition value);
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ILocalDefinition.get_CustomModifiers();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.LockStatement : Statement {
    private IStatement body;
    private IExpression guard;
    public IStatement Body { get; public set; }
    public IExpression Guard { get; public set; }
    public LockStatement(ILockStatement lockStatement);
    public sealed virtual IStatement get_Body();
    public void set_Body(IStatement value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Guard();
    public void set_Guard(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.LogicalNot : UnaryOperation {
    public LogicalNot(ILogicalNot logicalNot);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.MakeTypedReference : Expression {
    private IExpression operand;
    public IExpression Operand { get; public set; }
    public MakeTypedReference(IMakeTypedReference makeTypedReference);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Operand();
    public void set_Operand(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.ManagedPointerTypeReference : TypeReference {
    private IManagedPointerType resolvedType;
    private ITypeReference targetType;
    private IManagedPointerType ResolvedManagedPointerType { get; }
    public ITypeDefinition ResolvedType { get; }
    public ITypeReference TargetType { get; public set; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IManagedPointerTypeReference managedPointerTypeReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private IManagedPointerType get_ResolvedManagedPointerType();
    public virtual ITypeDefinition get_ResolvedType();
    public sealed virtual ITypeReference get_TargetType();
    public void set_TargetType(ITypeReference value);
}
public class Microsoft.Cci.MutableCodeModel.MarshallingInformation : object {
    private ITypeReference customMarshaller;
    private string customMarshallerRuntimeArgument;
    private UnmanagedType elementType;
    private UInt32 iidParameterIndex;
    private UnmanagedType unmanagedType;
    private UInt32 numberOfElements;
    private Nullable`1<UInt32> paramIndex;
    private VarEnum safeArrayElementSubType;
    private ITypeReference safeArrayElementUserDefinedSubType;
    public ITypeReference CustomMarshaller { get; public set; }
    public string CustomMarshallerRuntimeArgument { get; public set; }
    public UnmanagedType ElementType { get; public set; }
    public UInt32 IidParameterIndex { get; public set; }
    public UnmanagedType UnmanagedType { get; public set; }
    public UInt32 NumberOfElements { get; public set; }
    public Nullable`1<UInt32> ParamIndex { get; public set; }
    public VarEnum SafeArrayElementSubtype { get; public set; }
    public ITypeReference SafeArrayElementUserDefinedSubtype { get; public set; }
    public sealed virtual void Copy(IMarshallingInformation marshallingInformation, IInternFactory internFactory);
    public sealed virtual ITypeReference get_CustomMarshaller();
    public void set_CustomMarshaller(ITypeReference value);
    public sealed virtual string get_CustomMarshallerRuntimeArgument();
    public void set_CustomMarshallerRuntimeArgument(string value);
    public sealed virtual UnmanagedType get_ElementType();
    public void set_ElementType(UnmanagedType value);
    public sealed virtual UInt32 get_IidParameterIndex();
    public void set_IidParameterIndex(UInt32 value);
    public sealed virtual UnmanagedType get_UnmanagedType();
    public void set_UnmanagedType(UnmanagedType value);
    public sealed virtual UInt32 get_NumberOfElements();
    public void set_NumberOfElements(UInt32 value);
    public sealed virtual Nullable`1<UInt32> get_ParamIndex();
    public void set_ParamIndex(Nullable`1<UInt32> value);
    public sealed virtual VarEnum get_SafeArrayElementSubtype();
    public void set_SafeArrayElementSubtype(VarEnum value);
    public sealed virtual ITypeReference get_SafeArrayElementUserDefinedSubtype();
    public void set_SafeArrayElementUserDefinedSubtype(ITypeReference value);
}
public class Microsoft.Cci.MutableCodeModel.MatrixTypeReference : ArrayTypeReference {
    private List`1<int> lowerBounds;
    private UInt32 rank;
    private List`1<ulong> sizes;
    public bool IsVector { get; }
    public List`1<int> LowerBounds { get; public set; }
    public UInt32 Rank { get; public set; }
    public List`1<ulong> Sizes { get; public set; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IArrayTypeReference matrixTypeReference, IInternFactory internFactory);
    public virtual bool get_IsVector();
    public virtual List`1<int> get_LowerBounds();
    public virtual void set_LowerBounds(List`1<int> value);
    public virtual UInt32 get_Rank();
    public virtual void set_Rank(UInt32 value);
    public virtual List`1<ulong> get_Sizes();
    public virtual void set_Sizes(List`1<ulong> value);
    protected virtual IArrayType Resolve();
}
public class Microsoft.Cci.MutableCodeModel.MetadataConstant : MetadataExpression {
    private object value;
    public object Value { get; public set; }
    public sealed virtual void Copy(IMetadataConstant metadataConstant, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual object get_Value();
    public void set_Value(object value);
}
public class Microsoft.Cci.MutableCodeModel.MetadataCopier : object {
    private MetadataTraverser definitionCollector;
    protected internal Dictionary`2<object, object> cache;
    protected internal List`1<INamedTypeDefinition> flatListOfTypes;
    protected internal IMetadataHost host;
    protected IMethodReference currentMethodReference;
    protected bool coneAlreadyFixed;
    public MetadataCopier(IMetadataHost host);
    public MetadataCopier(IMetadataHost host, IDefinition rootOfCone, List`1& newTypes);
    public void AddDefinition(IDefinition rootOfCone, List`1& newTypes);
    private AliasForType GetMutableShallowCopy(IAliasForType aliasForType);
    private AssemblyReference GetMutableShallowCopy(IAssemblyReference assemblyReference);
    private CustomAttribute GetMutableShallowCopy(ICustomAttribute customAttribute);
    private CustomModifier GetMutableShallowCopy(ICustomModifier customModifier);
    private EventDefinition GetMutableShallowCopy(IEventDefinition eventDefinition);
    private FieldDefinition GetMutableShallowCopy(IFieldDefinition fieldDefinition);
    private FieldReference GetMutableShallowCopy(IFieldReference fieldReference);
    private FileReference GetMutableShallowCopy(IFileReference fileReference);
    private FunctionPointerTypeReference GetMutableShallowCopy(IFunctionPointerTypeReference functionPointerTypeReference);
    private GenericMethodInstanceReference GetMutableShallowCopy(IGenericMethodInstanceReference genericMethodInstanceReference);
    private GenericMethodParameter GetMutableShallowCopy(IGenericMethodParameter genericMethodParameter);
    private GenericMethodParameterReference GetMutableShallowCopy(IGenericMethodParameterReference genericMethodParameterReference);
    private GenericTypeInstanceReference GetMutableShallowCopy(IGenericTypeInstanceReference genericTypeInstanceReference);
    private GenericTypeParameter GetMutableShallowCopy(IGenericTypeParameter genericTypeParameter);
    private GenericTypeParameterReference GetMutableShallowCopy(IGenericTypeParameterReference genericTypeParameterReference);
    private GlobalFieldDefinition GetMutableShallowCopy(IGlobalFieldDefinition globalFieldDefinition);
    private GlobalMethodDefinition GetMutableShallowCopy(IGlobalMethodDefinition globalMethodDefinition);
    private LocalDefinition GetMutableShallowCopy(ILocalDefinition localDefinition);
    private ManagedPointerTypeReference GetMutableShallowCopy(IManagedPointerTypeReference managedPointerTypeReference);
    private MarshallingInformation GetMutableShallowCopy(IMarshallingInformation marshallingInformation);
    private MetadataConstant GetMutableShallowCopy(IMetadataConstant metadataConstant);
    private MetadataCreateArray GetMutableShallowCopy(IMetadataCreateArray metadataCreateArray);
    private MetadataNamedArgument GetMutableShallowCopy(IMetadataNamedArgument metadataNamedArgument);
    private MetadataTypeOf GetMutableShallowCopy(IMetadataTypeOf metadataTypeOf);
    private MethodDefinition GetMutableShallowCopy(IMethodDefinition methodDefinition);
    private MethodBody GetMutableShallowCopy(IMethodBody methodBody);
    private MethodImplementation GetMutableShallowCopy(IMethodImplementation methodImplementation);
    private MethodReference GetMutableShallowCopy(IMethodReference methodReference);
    private ModifiedTypeReference GetMutableShallowCopy(IModifiedTypeReference modifiedTypeReference);
    private Module GetMutableShallowCopy(IModule module);
    private ModuleReference GetMutableShallowCopy(IModuleReference moduleReference);
    private NamespaceAliasForType GetMutableShallowCopy(INamespaceAliasForType namespaceAliasForType);
    private NamespaceTypeDefinition GetMutableShallowCopy(INamespaceTypeDefinition namespaceTypeDefinition);
    private NamespaceTypeReference GetMutableShallowCopy(INamespaceTypeReference namespaceTypeReference);
    private NestedAliasForType GetMutableShallowCopy(INestedAliasForType nestedAliasForType);
    private NestedTypeDefinition GetMutableShallowCopy(INestedTypeDefinition nestedTypeDefinition);
    private NestedTypeReference GetMutableShallowCopy(INestedTypeReference nestedTypeReference);
    private NestedUnitNamespace GetMutableShallowCopy(INestedUnitNamespace nestedUnitNamespace);
    private NestedUnitNamespaceReference GetMutableShallowCopy(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    private Operation GetMutableShallowCopy(IOperation operation);
    private OperationExceptionInformation GetMutableShallowCopy(IOperationExceptionInformation operationExceptionInformation);
    private ParameterDefinition GetMutableShallowCopy(IParameterDefinition parameterDefinition);
    private ParameterTypeInformation GetMutableShallowCopy(IParameterTypeInformation parameterTypeInformation);
    private PESection GetMutableShallowCopy(IPESection peSection);
    private PlatformInvokeInformation GetMutableShallowCopy(IPlatformInvokeInformation platformInvokeInformation);
    private PointerTypeReference GetMutableShallowCopy(IPointerTypeReference pointerTypeReference);
    private PropertyDefinition GetMutableShallowCopy(IPropertyDefinition propertyDefinition);
    private ResourceReference GetMutableShallowCopy(IResourceReference resourceReference);
    private RootUnitNamespace GetMutableShallowCopy(IRootUnitNamespace rootUnitNamespace);
    private RootUnitNamespaceReference GetMutableShallowCopy(IRootUnitNamespaceReference rootUnitNamespaceReference);
    private SectionBlock GetMutableShallowCopy(ISectionBlock sectionBlock);
    private SecurityAttribute GetMutableShallowCopy(ISecurityAttribute securityAttribute);
    private SpecializedFieldReference GetMutableShallowCopy(ISpecializedFieldReference specializedFieldReference);
    private SpecializedMethodReference GetMutableShallowCopy(ISpecializedMethodReference specializedMethodReference);
    private SpecializedNestedTypeReference GetMutableShallowCopy(ISpecializedNestedTypeReference specializedNestedTypeReference);
    private Win32Resource GetMutableShallowCopy(IWin32Resource win32Resource);
    private MatrixTypeReference GetMutableMatrixShallowCopy(IArrayTypeReference matrixTypeReference);
    private VectorTypeReference GetMutableVectorShallowCopy(IArrayTypeReference vectorTypeReference);
    private IMethodReference GetTypeSpecificMutableShallowCopy(IMethodReference methodReference);
    protected virtual AliasForType DeepCopy(AliasForType aliasForType);
    protected virtual Assembly DeepCopy(Assembly assembly);
    protected virtual AssemblyReference DeepCopy(AssemblyReference assemblyReference);
    protected virtual CustomAttribute DeepCopy(CustomAttribute customAttribute);
    protected virtual CustomModifier DeepCopy(CustomModifier customModifier);
    protected virtual EventDefinition DeepCopy(EventDefinition eventDefinition);
    protected virtual FieldDefinition DeepCopy(FieldDefinition fieldDefinition);
    protected virtual FieldReference DeepCopy(FieldReference fieldReference);
    protected virtual FileReference DeepCopy(FileReference fileReference);
    protected virtual FunctionPointerTypeReference DeepCopy(FunctionPointerTypeReference functionPointerTypeReference);
    protected virtual GenericMethodInstanceReference DeepCopy(GenericMethodInstanceReference genericMethodInstanceReference);
    protected virtual List`1<IGenericMethodParameter> DeepCopy(List`1<IGenericMethodParameter> genericMethodParameters, IMethodDefinition declaringMethod);
    protected virtual GenericMethodParameter DeepCopy(GenericMethodParameter genericMethodParameter);
    protected virtual GenericMethodParameterReference DeepCopy(GenericMethodParameterReference genericMethodParameterReference);
    protected virtual GenericTypeParameterReference DeepCopy(GenericTypeParameterReference genericTypeParameterReference);
    protected virtual GlobalFieldDefinition DeepCopy(GlobalFieldDefinition globalFieldDefinition);
    protected virtual GlobalMethodDefinition DeepCopy(GlobalMethodDefinition globalMethodDefinition);
    protected virtual GenericTypeInstanceReference DeepCopy(GenericTypeInstanceReference genericTypeInstanceReference);
    protected virtual GenericParameter DeepCopy(GenericParameter genericParameter);
    protected virtual GenericTypeParameter DeepCopy(GenericTypeParameter genericTypeParameter);
    protected virtual IAliasForType DeepCopy(IAliasForType aliasForType);
    protected virtual IAliasMember DeepCopy(IAliasMember aliasMember);
    protected virtual IAssemblyReference DeepCopy(IAssemblyReference assemblyReference);
    protected virtual IArrayTypeReference DeepCopy(IArrayTypeReference arrayTypeReference);
    protected virtual IEventDefinition DeepCopy(IEventDefinition eventDefinition);
    protected virtual IFieldDefinition DeepCopy(IFieldDefinition fieldDefinition);
    protected virtual IFieldReference DeepCopy(IFieldReference fieldReference);
    protected virtual IGenericMethodInstanceReference DeepCopy(IGenericMethodInstanceReference genericMethodInstanceReference);
    protected virtual IGenericMethodParameterReference DeepCopy(IGenericMethodParameterReference genericMethodParameterReference);
    protected virtual IGenericTypeParameterReference DeepCopy(IGenericTypeParameterReference genericTypeParameterReference);
    protected virtual IGenericTypeInstanceReference DeepCopy(IGenericTypeInstanceReference genericTypeInstanceReference);
    protected virtual IGlobalFieldDefinition DeepCopy(IGlobalFieldDefinition globalFieldDefinition);
    protected virtual IGlobalMethodDefinition DeepCopy(IGlobalMethodDefinition globalMethodDefinition);
    protected virtual ILocation DeepCopy(ILocation location);
    protected virtual IMethodDefinition DeepCopy(IMethodDefinition methodDefinition);
    protected virtual IMethodReference DeepCopy(IMethodReference methodReference);
    protected virtual INamespaceAliasForType DeepCopy(INamespaceAliasForType namespaceAliasForType);
    protected virtual INamespaceMember DeepCopy(INamespaceMember namespaceMember);
    protected virtual INamespaceTypeReference DeepCopy(INamespaceTypeReference namespaceTypeReference);
    protected virtual INestedTypeReference DeepCopy(INestedTypeReference nestedTypeReference);
    protected virtual ITypeDefinitionMember DeepCopy(ITypeDefinitionMember typeDefinitionMember);
    protected virtual List`1<IAliasForType> DeepCopy(List`1<IAliasForType> aliasesForTypes);
    protected virtual List`1<IAliasMember> DeepCopy(List`1<IAliasMember> aliasMembers);
    protected virtual List`1<IAssemblyReference> DeepCopy(List`1<IAssemblyReference> assemblyReferences);
    protected virtual List`1<ICustomAttribute> DeepCopy(List`1<ICustomAttribute> customAttributes);
    protected virtual List`1<ICustomModifier> DeepCopy(List`1<ICustomModifier> customModifiers);
    protected virtual List`1<IEventDefinition> DeepCopy(List`1<IEventDefinition> eventDefinitions);
    protected virtual List`1<IFieldDefinition> DeepCopy(List`1<IFieldDefinition> fieldDefinitions);
    protected virtual List`1<IFileReference> DeepCopy(List`1<IFileReference> fileReferences);
    protected virtual List`1<IGenericTypeParameter> DeepCopy(List`1<IGenericTypeParameter> genericTypeParameters);
    protected virtual IMetadataExpression DeepCopy(IMetadataExpression expression);
    protected virtual List`1<IModuleReference> DeepCopy(List`1<IModuleReference> moduleReferences);
    protected virtual List`1<ILocation> DeepCopy(List`1<ILocation> locations);
    protected virtual List`1<ILocalDefinition> DeepCopy(List`1<ILocalDefinition> locals);
    protected virtual List`1<IMetadataExpression> DeepCopy(List`1<IMetadataExpression> metadataExpressions);
    protected virtual List`1<IMetadataNamedArgument> DeepCopy(List`1<IMetadataNamedArgument> namedArguments);
    protected virtual List`1<IMethodDefinition> DeepCopy(List`1<IMethodDefinition> methodDefinitions);
    protected virtual List`1<IMethodImplementation> DeepCopy(List`1<IMethodImplementation> methodImplementations);
    protected virtual List`1<IMethodReference> DeepCopy(List`1<IMethodReference> methodReferences);
    protected virtual List`1<IModule> DeepCopy(List`1<IModule> modules);
    protected virtual void VisitPrivateHelperMembers(List`1<INamedTypeDefinition> typeDefinitions);
    protected virtual List`1<INamespaceMember> DeepCopy(List`1<INamespaceMember> namespaceMembers);
    protected virtual List`1<INestedTypeDefinition> DeepCopy(List`1<INestedTypeDefinition> nestedTypeDefinitions);
    protected virtual List`1<IOperation> DeepCopy(List`1<IOperation> operations);
    protected virtual List`1<IOperationExceptionInformation> DeepCopy(List`1<IOperationExceptionInformation> exceptionInformations);
    protected virtual List`1<ITypeDefinitionMember> DeepCopy(List`1<ITypeDefinitionMember> typeDefinitionMembers);
    protected virtual List`1<IWin32Resource> DeepCopy(List`1<IWin32Resource> win32Resources);
    protected virtual LocalDefinition DeepCopy(LocalDefinition localDefinition);
    protected virtual ManagedPointerTypeReference DeepCopy(ManagedPointerTypeReference managedPointerTypeReference);
    protected virtual MarshallingInformation DeepCopy(MarshallingInformation marshallingInformation);
    protected virtual MetadataConstant DeepCopy(MetadataConstant constant);
    protected virtual MetadataCreateArray DeepCopy(MetadataCreateArray createArray);
    protected virtual MethodDefinition DeepCopy(MethodDefinition methodDefinition);
    protected virtual MetadataNamedArgument DeepCopy(MetadataNamedArgument namedArgument);
    protected virtual MetadataTypeOf DeepCopy(MetadataTypeOf typeOf);
    protected virtual MatrixTypeReference DeepCopy(MatrixTypeReference matrixTypeReference);
    protected virtual MethodBody DeepCopy(MethodBody methodBody);
    protected virtual MethodImplementation DeepCopy(MethodImplementation methodImplementation);
    protected virtual MethodReference DeepCopy(MethodReference methodReference);
    protected virtual ModifiedTypeReference DeepCopy(ModifiedTypeReference modifiedTypeReference);
    protected virtual Module DeepCopy(Module module);
    protected virtual ModuleReference DeepCopy(ModuleReference moduleReference);
    protected virtual NamespaceAliasForType DeepCopy(NamespaceAliasForType namespaceAliasForType);
    protected virtual NamespaceTypeDefinition DeepCopy(NamespaceTypeDefinition namespaceTypeDefinition);
    protected virtual NamespaceTypeReference DeepCopy(NamespaceTypeReference namespaceTypeReference);
    protected virtual NestedAliasForType DeepCopy(NestedAliasForType nestedAliasForType);
    protected virtual OperationExceptionInformation DeepCopy(OperationExceptionInformation operationExceptionInformation);
    protected virtual Operation DeepCopy(Operation operation);
    protected virtual NestedTypeDefinition DeepCopy(NestedTypeDefinition nestedTypeDefinition);
    protected virtual NestedTypeReference DeepCopy(NestedTypeReference nestedTypeReference);
    protected virtual SpecializedFieldReference DeepCopy(SpecializedFieldReference specializedFieldReference);
    protected virtual SpecializedMethodReference DeepCopy(SpecializedMethodReference specializedMethodReference);
    protected virtual SpecializedNestedTypeReference DeepCopy(SpecializedNestedTypeReference specializedNestedTypeReference);
    protected virtual void DeepCopy(NamedTypeDefinition typeDefinition);
    protected virtual List`1<ITypeReference> DeepCopy(List`1<ITypeReference> typeReferences);
    protected virtual IPointerTypeReference DeepCopy(IPointerTypeReference pointerTypeReference);
    protected virtual IFunctionPointerTypeReference DeepCopy(IFunctionPointerTypeReference functionPointerTypeReference);
    protected virtual IManagedPointerTypeReference DeepCopy(IManagedPointerTypeReference managedPointerTypeReference);
    protected virtual IModifiedTypeReference DeepCopy(IModifiedTypeReference modifiedTypeReference);
    protected virtual IModuleReference DeepCopy(IModuleReference moduleReference);
    protected virtual INamespaceTypeDefinition DeepCopy(INamespaceTypeDefinition namespaceTypeDefinition);
    protected virtual INestedTypeDefinition DeepCopy(INestedTypeDefinition nestedTypeDefinition);
    protected virtual ITypeReference DeepCopy(ITypeReference typeReference);
    protected virtual IUnitNamespaceReference DeepCopy(IUnitNamespaceReference unitNamespaceReference);
    protected virtual INestedUnitNamespace DeepCopy(INestedUnitNamespace nestedUnitNamespace);
    protected virtual INestedUnitNamespaceReference DeepCopy(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    protected virtual NestedUnitNamespace DeepCopy(NestedUnitNamespace nestedUnitNamespace);
    protected virtual NestedUnitNamespaceReference DeepCopy(NestedUnitNamespaceReference nestedUnitNamespaceReference);
    protected virtual IUnitReference DeepCopy(IUnitReference unitReference);
    protected virtual List`1<IParameterDefinition> DeepCopy(List`1<IParameterDefinition> parameterDefinitions);
    protected virtual ParameterDefinition DeepCopy(ParameterDefinition parameterDefinition);
    protected virtual List`1<IParameterTypeInformation> DeepCopy(List`1<IParameterTypeInformation> parameterTypeInformationList);
    protected virtual ParameterTypeInformation DeepCopy(ParameterTypeInformation parameterTypeInformation);
    protected virtual PlatformInvokeInformation DeepCopy(PlatformInvokeInformation platformInvokeInformation);
    protected virtual List`1<IPropertyDefinition> DeepCopy(List`1<IPropertyDefinition> propertyDefinitions);
    protected virtual IPropertyDefinition DeepCopy(IPropertyDefinition propertyDefinition);
    protected virtual PropertyDefinition DeepCopy(PropertyDefinition propertyDefinition);
    protected virtual PointerTypeReference DeepCopy(PointerTypeReference pointerTypeReference);
    protected virtual List`1<IResourceReference> DeepCopy(List`1<IResourceReference> resourceReferences);
    protected virtual ResourceReference DeepCopy(ResourceReference resourceReference);
    protected virtual List`1<ISecurityAttribute> DeepCopy(List`1<ISecurityAttribute> securityAttributes);
    protected virtual IRootUnitNamespaceReference DeepCopy(IRootUnitNamespaceReference rootUnitNamespaceReference);
    protected virtual RootUnitNamespace DeepCopy(RootUnitNamespace rootUnitNamespace);
    protected virtual RootUnitNamespaceReference DeepCopy(RootUnitNamespaceReference rootUnitNamespaceReference);
    protected virtual SecurityAttribute DeepCopy(SecurityAttribute securityAttribute);
    protected virtual SectionBlock DeepCopy(SectionBlock sectionBlock);
    protected virtual ITypeDefinitionMember DeepCopy(TypeDefinitionMember typeDefinitionMember);
    protected virtual TypeReference DeepCopy(TypeReference typeReference);
    protected virtual Unit DeepCopy(Unit unit);
    protected virtual UnitNamespace DeepCopy(UnitNamespace unitNamespace);
    protected virtual UnitNamespaceReference DeepCopy(UnitNamespaceReference unitNamespaceReference);
    protected virtual VectorTypeReference DeepCopy(VectorTypeReference vectorTypeReference);
    protected virtual Win32Resource DeepCopy(Win32Resource win32Resource);
    protected virtual ILocalDefinition GetMutableCopyIfItExists(ILocalDefinition localDefinition);
    protected virtual IMethodDefinition GetMutableCopyIfItExists(IMethodDefinition methodDefinition);
    protected virtual INamespaceDefinition GetMutableCopyIfItExists(INamespaceDefinition namespaceDefinition);
    protected virtual IParameterDefinition GetMutableCopyIfItExists(IParameterDefinition parameterDefinition);
    protected virtual ISignature GetMutableCopyIfItExists(ISignature signature);
    protected ITypeDefinition GetMutableCopyIfItExists(ITypeDefinition typeDefinition);
    protected virtual IUnit GetMutableCopyIfItExists(IUnit unitNamespace);
    protected virtual IUnitNamespace GetMutableCopyIfItExists(IUnitNamespace unitNamespace);
    protected List`1<ICustomAttribute> DeepCopyMethodReturnValueAttributes(List`1<ICustomAttribute> customAttributes);
    protected List`1<ICustomModifier> DeepCopyMethodReturnValueCustomModifiers(List`1<ICustomModifier> customModifers);
    protected IMarshallingInformation DeepCopyMethodReturnValueMarshallingInformation(MarshallingInformation marshallingInformation);
    public static Assembly DeepCopy(IMetadataHost host, IAssembly assembly);
    public static MethodReference DeepCopy(IMetadataHost host, IMethodReference methodReference);
    public static Module DeepCopy(IMetadataHost host, IModule module);
    public static TypeReference DeepCopy(IMetadataHost host, ITypeReference typeReference);
    public virtual IAliasForType Substitute(IAliasForType aliasForType);
    public virtual IArrayTypeReference Substitute(IArrayTypeReference arrayTypeReference);
    private void AddDefinition(IAssembly assembly);
    public virtual IAssembly Substitute(IAssembly assembly);
    public virtual IAssemblyReference Substitute(IAssemblyReference assemblyReference);
    public virtual ICustomAttribute Substitute(ICustomAttribute customAttribute);
    public virtual ICustomModifier Substitute(ICustomModifier customModifier);
    public virtual IEventDefinition Substitute(IEventDefinition eventDefinition);
    public virtual IFieldDefinition Substitute(IFieldDefinition fieldDefinition);
    public virtual IFieldReference Substitute(IFieldReference fieldReference);
    public virtual IFileReference Substitute(IFileReference fileReference);
    public virtual IFunctionPointerTypeReference Substitute(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual IGenericMethodInstanceReference Substitute(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual IGenericMethodParameter Substitute(IGenericMethodParameter genericMethodParameter);
    public virtual IGenericMethodParameterReference Substitute(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual IGlobalFieldDefinition Substitute(IGlobalFieldDefinition globalFieldDefinition);
    public virtual IGlobalMethodDefinition Substitute(IGlobalMethodDefinition globalMethodDefinition);
    public virtual IGenericTypeInstanceReference Substitute(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual IGenericTypeParameter Substitute(IGenericTypeParameter genericTypeParameter);
    public virtual IGenericTypeParameterReference Substitute(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual IManagedPointerTypeReference Substitute(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual IMarshallingInformation Substitute(IMarshallingInformation marshallingInformation);
    public virtual IMetadataConstant Substitute(IMetadataConstant constant);
    public virtual IMetadataCreateArray Substitute(IMetadataCreateArray createArray);
    public virtual IMetadataNamedArgument Substitute(IMetadataNamedArgument namedArgument);
    public virtual IMetadataTypeOf Substitute(IMetadataTypeOf typeOf);
    public virtual IMethodBody Substitute(IMethodBody methodBody);
    public virtual IMethodDefinition Substitute(IMethodDefinition method);
    public virtual IMethodImplementation Substitute(IMethodImplementation methodImplementation);
    public virtual IMethodReference Substitute(IMethodReference methodReference);
    public virtual IModifiedTypeReference Substitute(IModifiedTypeReference modifiedTypeReference);
    private void AddDefinition(IModule module);
    public virtual IModule Substitute(IModule module);
    public virtual IModuleReference Substitute(IModuleReference moduleReference);
    public virtual INamespaceAliasForType Substitute(INamespaceAliasForType namespaceAliasForType);
    public virtual INamespaceTypeDefinition Substitute(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual INamespaceTypeReference Substitute(INamespaceTypeReference namespaceTypeReference);
    public virtual INestedAliasForType Substitute(INestedAliasForType nestedAliasForType);
    public virtual INestedTypeDefinition Substitute(INestedTypeDefinition nestedTypeDefinition);
    public virtual INestedTypeReference Substitute(INestedTypeReference nestedTypeReference);
    public virtual INestedUnitNamespace Substitute(INestedUnitNamespace nestedUnitNamespace);
    public virtual INestedUnitNamespaceReference Substitute(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual INestedUnitSetNamespace Substitute(INestedUnitSetNamespace nestedUnitSetNamespace);
    public virtual IParameterDefinition Substitute(IParameterDefinition parameterDefinition);
    public virtual IParameterTypeInformation Substitute(IParameterTypeInformation parameterTypeInformation);
    public virtual IPointerTypeReference Substitute(IPointerTypeReference pointerTypeReference);
    public virtual IPropertyDefinition Substitute(IPropertyDefinition propertyDefinition);
    public virtual IResourceReference Substitute(IResourceReference resourceReference);
    public virtual IRootUnitNamespace Substitute(IRootUnitNamespace rootUnitNamespace);
    public virtual IRootUnitNamespaceReference Substitute(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual IRootUnitSetNamespace Substitute(IRootUnitSetNamespace rootUnitSetNamespace);
    public virtual ISecurityAttribute Substitute(ISecurityAttribute securityAttribute);
    public virtual ITypeReference Substitute(ITypeReference typeReference);
    public virtual IUnitSet Substitute(IUnitSet unitSet);
    public virtual IWin32Resource Substitute(IWin32Resource win32Resource);
}
public class Microsoft.Cci.MutableCodeModel.MetadataCreateArray : MetadataExpression {
    private ITypeReference elementType;
    private List`1<IMetadataExpression> initializers;
    private List`1<int> lowerBounds;
    private UInt32 rank;
    private List`1<ulong> sizes;
    public ITypeReference ElementType { get; public set; }
    public List`1<IMetadataExpression> Initializers { get; public set; }
    public List`1<int> LowerBounds { get; public set; }
    public UInt32 Rank { get; public set; }
    public List`1<ulong> Sizes { get; public set; }
    private IEnumerable`1<IMetadataExpression> Microsoft.Cci.IMetadataCreateArray.Initializers { get; }
    private IEnumerable`1<int> Microsoft.Cci.IMetadataCreateArray.LowerBounds { get; }
    private IEnumerable`1<ulong> Microsoft.Cci.IMetadataCreateArray.Sizes { get; }
    public sealed virtual void Copy(IMetadataCreateArray createArray, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_ElementType();
    public void set_ElementType(ITypeReference value);
    public List`1<IMetadataExpression> get_Initializers();
    public void set_Initializers(List`1<IMetadataExpression> value);
    public List`1<int> get_LowerBounds();
    public void set_LowerBounds(List`1<int> value);
    public sealed virtual UInt32 get_Rank();
    public void set_Rank(UInt32 value);
    public List`1<ulong> get_Sizes();
    public void set_Sizes(List`1<ulong> value);
    private sealed virtual override IEnumerable`1<IMetadataExpression> Microsoft.Cci.IMetadataCreateArray.get_Initializers();
    private sealed virtual override IEnumerable`1<int> Microsoft.Cci.IMetadataCreateArray.get_LowerBounds();
    private sealed virtual override IEnumerable`1<ulong> Microsoft.Cci.IMetadataCreateArray.get_Sizes();
}
public class Microsoft.Cci.MutableCodeModel.MetadataDeepCopier : object {
    private IMetadataHost targetHost;
    private MetadataShallowCopier shallowCopier;
    private IInternFactory internFactory;
    private Hashtable`2<object, object> originalFor;
    private Substitutor substituteCopiesForOriginals;
    private MetadataTraverser traverseAndPopulateDefinitionCacheWithCopies;
    private MetadataDispatcher dispatcher;
    public Hashtable`2<object, object> CopyFor { get; }
    public Hashtable`2<object, object> OriginalFor { get; }
    private Substitutor SubstituteCopiesForOriginals { get; }
    private MetadataTraverser TraverseAndPopulateDefinitionCacheWithCopies { get; }
    private MetadataDispatcher Dispatcher { get; }
    public MetadataDeepCopier(IMetadataHost targetHost);
    public MetadataDeepCopier(IMetadataHost targetHost, IUnit targetUnit);
    protected MetadataDeepCopier(IMetadataHost targetHost, MetadataShallowCopier shallowCopier);
    private void ObjectInvariant();
    public Hashtable`2<object, object> get_CopyFor();
    public Hashtable`2<object, object> get_OriginalFor();
    private Substitutor get_SubstituteCopiesForOriginals();
    private MetadataTraverser get_TraverseAndPopulateDefinitionCacheWithCopies();
    public sealed virtual void Dispose();
    private MetadataDispatcher get_Dispatcher();
    public AliasForType Copy(IAliasForType aliasForType);
    public ArrayTypeReference Copy(IArrayTypeReference arrayTypeReference);
    public Assembly Copy(IAssembly assembly);
    public AssemblyReference Copy(IAssemblyReference assemblyReference);
    public CustomAttribute Copy(ICustomAttribute customAttribute);
    public CustomModifier Copy(ICustomModifier customModifier);
    public EventDefinition Copy(IEventDefinition eventDefinition);
    private EventDefinition CopyUnspecialized(IEventDefinition eventDefinition);
    protected virtual IMethodBody CopyMethodBody(IMethodBody methodBody, IMethodDefinition method);
    public FieldDefinition Copy(IFieldDefinition fieldDefinition);
    private FieldDefinition CopyUnspecialized(IFieldDefinition fieldDefinition);
    public FieldReference Copy(IFieldReference fieldReference);
    private FieldReference CopyUnspecialized(IFieldReference fieldReference);
    public FileReference Copy(IFileReference fileReference);
    public FunctionPointerTypeReference Copy(IFunctionPointerTypeReference functionPointerTypeReference);
    public GenericMethodInstanceReference Copy(IGenericMethodInstanceReference genericMethodInstanceReference);
    public GenericMethodParameter Copy(IGenericMethodParameter genericMethodParameter);
    public GenericMethodParameterReference Copy(IGenericMethodParameterReference genericMethodParameterReference);
    public GenericTypeParameter Copy(IGenericTypeParameter genericTypeParameter);
    public GenericTypeInstanceReference Copy(IGenericTypeInstanceReference genericTypeInstanceReference);
    public GenericTypeParameterReference Copy(IGenericTypeParameterReference genericTypeParameterReference);
    public GlobalFieldDefinition Copy(IGlobalFieldDefinition globalFieldDefinition);
    public GlobalMethodDefinition Copy(IGlobalMethodDefinition globalMethodDefinition);
    public LocalDefinition Copy(ILocalDefinition localDefinition);
    public ManagedPointerTypeReference Copy(IManagedPointerTypeReference managedPointerTypeReference);
    public MarshallingInformation Copy(IMarshallingInformation marshallingInformation);
    public MetadataConstant Copy(IMetadataConstant constant);
    public MetadataCreateArray Copy(IMetadataCreateArray createArray);
    public MetadataExpression Copy(IMetadataExpression expression);
    public MetadataNamedArgument Copy(IMetadataNamedArgument namedArgument);
    public MetadataTypeOf Copy(IMetadataTypeOf typeOf);
    public MethodBody Copy(IMethodBody methodBody);
    public MethodDefinition Copy(IMethodDefinition method);
    private MethodDefinition CopyUnspecialized(IMethodDefinition method);
    public MethodImplementation Copy(IMethodImplementation methodImplementation);
    public MethodReference Copy(IMethodReference methodReference);
    private MethodReference CopyUnspecialized(IMethodReference methodReference);
    public ModifiedTypeReference Copy(IModifiedTypeReference modifiedTypeReference);
    public Module Copy(IModule module);
    public ModuleReference Copy(IModuleReference moduleReference);
    public NamedTypeDefinition Copy(INamedTypeDefinition namedTypeDefinition);
    public NamespaceAliasForType Copy(INamespaceAliasForType namespaceAliasForType);
    public NamespaceTypeDefinition Copy(INamespaceTypeDefinition namespaceTypeDefinition);
    public NamespaceTypeReference Copy(INamespaceTypeReference namespaceTypeReference);
    public NestedAliasForType Copy(INestedAliasForType nestedAliasForType);
    public NestedTypeDefinition Copy(INestedTypeDefinition nestedTypeDefinition);
    private NestedTypeDefinition CopyUnspecialized(INestedTypeDefinition nestedTypeDefinition);
    public NestedTypeReference Copy(INestedTypeReference nestedTypeReference);
    private NestedTypeReference CopyUnspecialized(INestedTypeReference nestedTypeReference);
    public NestedUnitNamespace Copy(INestedUnitNamespace nestedUnitNamespace);
    public NestedUnitNamespaceReference Copy(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public Operation Copy(IOperation operation);
    public OperationExceptionInformation Copy(IOperationExceptionInformation operationExceptionInformation);
    public ParameterDefinition Copy(IParameterDefinition parameterDefinition);
    public ParameterTypeInformation Copy(IParameterTypeInformation parameterTypeInformation);
    public PESection Copy(IPESection peSection);
    public PlatformInvokeInformation Copy(IPlatformInvokeInformation platformInvokeInformation);
    public PointerTypeReference Copy(IPointerTypeReference pointerTypeReference);
    public PropertyDefinition Copy(IPropertyDefinition propertyDefinition);
    private PropertyDefinition CopyUnspecialized(IPropertyDefinition propertyDefinition);
    public ResourceReference Copy(IResourceReference resourceReference);
    public RootUnitNamespace Copy(IRootUnitNamespace rootUnitNamespace);
    public RootUnitNamespaceReference Copy(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public SecurityAttribute Copy(ISecurityAttribute securityAttribute);
    public SpecializedEventDefinition Copy(ISpecializedEventDefinition specializedEventDefinition);
    private SpecializedEventDefinition CopySpecialized(ISpecializedEventDefinition specializedEventDefinition);
    public SpecializedFieldDefinition Copy(ISpecializedFieldDefinition specializedFieldDefinition);
    private SpecializedFieldDefinition CopySpecialized(ISpecializedFieldDefinition specializedFieldDefinition);
    public SpecializedFieldReference Copy(ISpecializedFieldReference specializedFieldReference);
    public SpecializedMethodDefinition Copy(ISpecializedMethodDefinition specializedMethodDefinition);
    private SpecializedMethodDefinition CopySpecialized(ISpecializedMethodDefinition specializedMethodDefinition);
    public SpecializedMethodReference Copy(ISpecializedMethodReference specializedMethodReference);
    public SpecializedNestedTypeDefinition Copy(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    private SpecializedNestedTypeDefinition CopySpecialized(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public SpecializedNestedTypeReference Copy(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public SpecializedPropertyDefinition Copy(ISpecializedPropertyDefinition specializedPropertyDefinition);
    private SpecializedPropertyDefinition CopySpecialized(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public ITypeDefinition Copy(ITypeDefinition typeDefinition);
    public TypeDefinitionMember Copy(ITypeDefinitionMember typeMember);
    public TypeReference Copy(ITypeReference typeReference);
    public UnitNamespace Copy(IUnitNamespace unitNamespace);
    public UnitNamespaceReference Copy(IUnitNamespaceReference unitNamespace);
    public Win32Resource Copy(IWin32Resource win32Resource);
    public void Copy(List`1<IDefinition> definitions);
    protected IParameterDefinition GetExistingCopyIfInsideCone(IParameterDefinition parameter);
    protected IPropertyDefinition GetExistingCopyIfInsideCone(IPropertyDefinition propertyDefinition);
}
public abstract class Microsoft.Cci.MutableCodeModel.MetadataExpression : object {
    private List`1<ILocation> locations;
    private ITypeReference type;
    public List`1<ILocation> Locations { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public sealed virtual void Copy(IMetadataExpression metadataExpression, IInternFactory internFactory);
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
[ObsoleteAttribute("This class has been superceded by MetadataDeepCopier and MetadataRewriter, used in combination. It will go away in the future.")]
public class Microsoft.Cci.MutableCodeModel.MetadataMutator : object {
    protected Dictionary`2<object, object> cache;
    protected bool copyOnlyIfNotAlreadyMutable;
    protected Dictionary`2<object, object> referenceCache;
    protected List`1<INamedTypeDefinition> flatListOfTypes;
    protected IMetadataHost host;
    protected Stack path;
    protected bool stopTraversal;
    public MetadataMutator(IMetadataHost host);
    public MetadataMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable);
    public IMethodDefinition GetCurrentMethod();
    public IUnitNamespace GetCurrentNamespace();
    public ISignature GetCurrentSignature();
    public ITypeDefinition GetCurrentType();
    public IUnit GetCurrentUnit();
    public virtual Assembly GetMutableCopy(IAssembly assembly);
    public virtual AssemblyReference GetMutableCopy(IAssemblyReference assemblyReference);
    public virtual CustomAttribute GetMutableCopy(ICustomAttribute customAttribute);
    public virtual CustomModifier GetMutableCopy(ICustomModifier customModifier);
    public virtual EventDefinition GetMutableCopy(IEventDefinition eventDefinition);
    public virtual FieldDefinition GetMutableCopy(IFieldDefinition fieldDefinition);
    public virtual SectionBlock GetMutableCopy(ISectionBlock sectionBlock);
    public virtual FieldReference GetMutableCopy(IFieldReference fieldReference);
    public virtual FileReference GetMutableCopy(IFileReference fileReference);
    public virtual FunctionPointerTypeReference GetMutableCopy(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual GenericMethodInstanceReference GetMutableCopy(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual GenericMethodParameter GetMutableCopy(IGenericMethodParameter genericMethodParameter);
    public virtual GenericMethodParameterReference GetMutableCopy(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual GenericTypeInstanceReference GetMutableCopy(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual GenericTypeParameter GetMutableCopy(IGenericTypeParameter genericTypeParameter);
    public virtual GenericTypeParameterReference GetMutableCopy(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual GlobalFieldDefinition GetMutableCopy(IGlobalFieldDefinition globalFieldDefinition);
    public virtual GlobalMethodDefinition GetMutableCopy(IGlobalMethodDefinition globalMethodDefinition);
    public virtual LocalDefinition GetMutableCopy(ILocalDefinition localDefinition);
    public virtual ManagedPointerTypeReference GetMutableCopy(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual MarshallingInformation GetMutableCopy(IMarshallingInformation marshallingInformation);
    public virtual MetadataConstant GetMutableCopy(IMetadataConstant metadataConstant);
    public virtual MetadataCreateArray GetMutableCopy(IMetadataCreateArray metadataCreateArray);
    public virtual MetadataNamedArgument GetMutableCopy(IMetadataNamedArgument metadataNamedArgument);
    public virtual MetadataTypeOf GetMutableCopy(IMetadataTypeOf metadataTypeOf);
    public virtual MethodDefinition GetMutableCopy(IMethodDefinition methodDefinition);
    public virtual MethodBody GetMutableCopy(IMethodBody methodBody);
    public virtual MethodImplementation GetMutableCopy(IMethodImplementation methodImplementation);
    public virtual MethodReference GetMutableCopy(IMethodReference methodReference);
    public virtual ModifiedTypeReference GetMutableCopy(IModifiedTypeReference modifiedTypeReference);
    public virtual Module GetMutableCopy(IModule module);
    public virtual ModuleReference GetMutableCopy(IModuleReference moduleReference);
    public virtual NamespaceAliasForType GetMutableCopy(INamespaceAliasForType namespaceAliasForType);
    public virtual NamespaceTypeDefinition GetMutableCopy(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual NamespaceTypeReference GetMutableCopy(INamespaceTypeReference namespaceTypeReference);
    public virtual NestedAliasForType GetMutableCopy(INestedAliasForType nestedAliasForType);
    public virtual NestedTypeDefinition GetMutableCopy(INestedTypeDefinition nestedTypeDefinition);
    public virtual NestedTypeReference GetMutableCopy(INestedTypeReference nestedTypeReference);
    public virtual NestedUnitNamespace GetMutableCopy(INestedUnitNamespace nestedUnitNamespace);
    public virtual NestedUnitNamespaceReference GetMutableCopy(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual Operation GetMutableCopy(IOperation operation);
    public virtual OperationExceptionInformation GetMutableCopy(IOperationExceptionInformation operationExceptionInformation);
    public virtual ParameterDefinition GetMutableCopy(IParameterDefinition parameterDefinition);
    public virtual ParameterTypeInformation GetMutableCopy(IParameterTypeInformation parameterTypeInformation);
    public virtual PESection GetMutableCopy(IPESection peSection);
    public virtual PlatformInvokeInformation GetMutableCopy(IPlatformInvokeInformation platformInvokeInformation);
    public virtual PointerTypeReference GetMutableCopy(IPointerTypeReference pointerTypeReference);
    public virtual PropertyDefinition GetMutableCopy(IPropertyDefinition propertyDefinition);
    public virtual ResourceReference GetMutableCopy(IResourceReference resourceReference);
    public virtual RootUnitNamespace GetMutableCopy(IRootUnitNamespace rootUnitNamespace);
    public virtual RootUnitNamespaceReference GetMutableCopy(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual SecurityAttribute GetMutableCopy(ISecurityAttribute securityAttribute);
    public virtual SpecializedFieldReference GetMutableCopy(ISpecializedFieldReference specializedFieldReference);
    public virtual SpecializedMethodReference GetMutableCopy(ISpecializedMethodReference specializedMethodReference);
    public virtual SpecializedNestedTypeReference GetMutableCopy(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual Win32Resource GetMutableCopy(IWin32Resource win32Resource);
    public virtual MatrixTypeReference GetMutableMatrixCopy(IArrayTypeReference matrixTypeReference);
    public virtual VectorTypeReference GetMutableVectorCopy(IArrayTypeReference vectorTypeReference);
    public virtual IMethodReference GetTypeSpecificMutableCopy(IMethodReference methodReference);
    public virtual List`1<IAliasForType> Visit(List`1<IAliasForType> aliasesForTypes);
    public virtual IAliasForType Visit(IAliasForType aliasForType);
    public virtual Assembly Visit(IAssembly assembly);
    public virtual Assembly Visit(Assembly assembly);
    public virtual List`1<IAssemblyReference> Visit(List`1<IAssemblyReference> assemblyReferences);
    public virtual IAssemblyReference Visit(IAssemblyReference assemblyReference);
    public virtual AssemblyReference Visit(AssemblyReference assemblyReference);
    public virtual List`1<ICustomAttribute> Visit(List`1<ICustomAttribute> customAttributes);
    public virtual CustomAttribute Visit(CustomAttribute customAttribute);
    public virtual List`1<ICustomModifier> Visit(List`1<ICustomModifier> customModifiers);
    public virtual CustomModifier Visit(CustomModifier customModifier);
    public virtual List`1<IEventDefinition> Visit(List`1<IEventDefinition> eventDefinitions);
    public virtual IEventDefinition Visit(IEventDefinition eventDefinition);
    public virtual EventDefinition Visit(EventDefinition eventDefinition);
    public virtual List`1<IFieldDefinition> Visit(List`1<IFieldDefinition> fieldDefinitions);
    public virtual FieldDefinition Visit(FieldDefinition fieldDefinition);
    public virtual IFieldDefinition Visit(IFieldDefinition fieldDefinition);
    public virtual IFieldReference Visit(IFieldReference fieldReference);
    public virtual FieldReference Visit(FieldReference fieldReference);
    public virtual List`1<IFileReference> Visit(List`1<IFileReference> fileReferences);
    public virtual FileReference Visit(FileReference fileReference);
    public virtual FunctionPointerTypeReference Visit(FunctionPointerTypeReference functionPointerTypeReference);
    public virtual GenericMethodInstanceReference Visit(GenericMethodInstanceReference genericMethodInstanceReference);
    public virtual List`1<IGenericMethodParameter> Visit(List`1<IGenericMethodParameter> genericMethodParameters, IMethodDefinition declaringMethod);
    public virtual GenericMethodParameter Visit(GenericMethodParameter genericMethodParameter);
    public virtual GenericMethodParameterReference Visit(GenericMethodParameterReference genericMethodParameterReference);
    public virtual GenericTypeParameterReference Visit(GenericTypeParameterReference genericTypeParameterReference);
    public virtual GlobalFieldDefinition Visit(GlobalFieldDefinition globalFieldDefinition);
    public virtual GlobalMethodDefinition Visit(GlobalMethodDefinition globalMethodDefinition);
    public virtual GenericTypeInstanceReference Visit(GenericTypeInstanceReference genericTypeInstanceReference);
    public virtual GenericParameter Visit(GenericParameter genericParameter);
    public virtual List`1<IGenericTypeParameter> Visit(List`1<IGenericTypeParameter> genericTypeParameters);
    public virtual GenericTypeParameter Visit(GenericTypeParameter genericTypeParameter);
    public virtual List`1<ILocation> Visit(List`1<ILocation> locations);
    public virtual ILocalDefinition Visit(ILocalDefinition localDefinition);
    public virtual ILocalDefinition VisitReferenceTo(ILocalDefinition localDefinition);
    public virtual ILocation Visit(ILocation location);
    public virtual LocalDefinition Visit(LocalDefinition localDefinition);
    public virtual ManagedPointerTypeReference Visit(ManagedPointerTypeReference managedPointerTypeReference);
    public virtual MarshallingInformation Visit(MarshallingInformation marshallingInformation);
    public virtual MetadataConstant Visit(MetadataConstant constant);
    public virtual MetadataCreateArray Visit(MetadataCreateArray createArray);
    public virtual List`1<IMetadataExpression> Visit(List`1<IMetadataExpression> metadataExpressions);
    public virtual IMetadataExpression Visit(IMetadataExpression expression);
    public virtual List`1<IMetadataNamedArgument> Visit(List`1<IMetadataNamedArgument> namedArguments);
    public virtual MetadataNamedArgument Visit(MetadataNamedArgument namedArgument);
    public virtual MetadataTypeOf Visit(MetadataTypeOf typeOf);
    public virtual MatrixTypeReference Visit(MatrixTypeReference matrixTypeReference);
    public virtual MethodBody Visit(MethodBody methodBody);
    public virtual List`1<IOperationExceptionInformation> Visit(List`1<IOperationExceptionInformation> exceptionInformations);
    public virtual OperationExceptionInformation Visit(OperationExceptionInformation operationExceptionInformation);
    public virtual List`1<IOperation> Visit(List`1<IOperation> operations);
    public virtual Operation Visit(Operation operation);
    public virtual List`1<ILocalDefinition> Visit(List`1<ILocalDefinition> locals);
    public virtual List`1<IMethodDefinition> Visit(List`1<IMethodDefinition> methodDefinitions);
    public virtual IGlobalFieldDefinition Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual IGlobalMethodDefinition Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual IMethodDefinition Visit(IMethodDefinition methodDefinition);
    public virtual MethodDefinition Visit(MethodDefinition methodDefinition);
    public virtual List`1<IMethodImplementation> Visit(List`1<IMethodImplementation> methodImplementations);
    public virtual MethodImplementation Visit(MethodImplementation methodImplementation);
    public virtual List`1<IMethodReference> Visit(List`1<IMethodReference> methodReferences);
    public virtual IMethodBody Visit(IMethodBody methodBody);
    public virtual IMethodReference Visit(IMethodReference methodReference);
    public virtual MethodReference Visit(MethodReference methodReference);
    public virtual List`1<IModule> Visit(List`1<IModule> modules);
    public virtual ModifiedTypeReference Visit(ModifiedTypeReference modifiedTypeReference);
    public virtual Module Visit(IModule module);
    public virtual Module Visit(Module module);
    public virtual List`1<IModuleReference> Visit(List`1<IModuleReference> moduleReferences);
    public virtual ModuleReference Visit(ModuleReference moduleReference);
    public virtual List`1<INamespaceMember> Visit(List`1<INamespaceMember> namespaceMembers);
    public virtual INamespaceMember Visit(INamespaceMember namespaceMember);
    public virtual NamespaceAliasForType Visit(NamespaceAliasForType namespaceAliasForType);
    public virtual NamespaceTypeDefinition Visit(NamespaceTypeDefinition namespaceTypeDefinition);
    public virtual NamespaceTypeReference Visit(NamespaceTypeReference namespaceTypeReference);
    public virtual NestedAliasForType Visit(NestedAliasForType nestedAliasForType);
    public virtual List`1<INestedTypeDefinition> Visit(List`1<INestedTypeDefinition> nestedTypeDefinitions);
    public virtual NestedTypeDefinition Visit(NestedTypeDefinition nestedTypeDefinition);
    public virtual NestedTypeReference Visit(NestedTypeReference nestedTypeReference);
    public virtual SpecializedFieldReference Visit(SpecializedFieldReference specializedFieldReference);
    public virtual SpecializedMethodReference Visit(SpecializedMethodReference specializedMethodReference);
    public virtual SpecializedNestedTypeReference Visit(SpecializedNestedTypeReference specializedNestedTypeReference);
    protected virtual void Visit(NamedTypeDefinition typeDefinition);
    public virtual void VisitPrivateHelperMembers(List`1<INamedTypeDefinition> typeDefinitions);
    public virtual List`1<ITypeDefinitionMember> Visit(List`1<ITypeDefinitionMember> typeDefinitionMembers);
    public virtual ITypeDefinitionMember Visit(ITypeDefinitionMember typeDefinitionMember);
    public virtual List`1<ITypeReference> Visit(List`1<ITypeReference> typeReferences);
    public virtual INamespaceTypeReference Visit(INamespaceTypeReference namespaceTypeReference);
    public virtual INestedTypeReference Visit(INestedTypeReference nestedTypeReference);
    public virtual IGenericMethodParameterReference Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual IArrayTypeReference Visit(IArrayTypeReference arrayTypeReference);
    public virtual IGenericTypeParameterReference Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual IGenericTypeInstanceReference Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual IParameterDefinition Visit(IParameterDefinition parameterDefinition);
    public virtual IParameterDefinition VisitReferenceTo(IParameterDefinition parameterDefinition);
    public virtual IPointerTypeReference Visit(IPointerTypeReference pointerTypeReference);
    public virtual IFunctionPointerTypeReference Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual IManagedPointerTypeReference Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual IModifiedTypeReference Visit(IModifiedTypeReference modifiedTypeReference);
    public virtual IModuleReference Visit(IModuleReference moduleReference);
    public virtual INamespaceTypeDefinition Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual INestedTypeDefinition Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual ITypeReference Visit(ITypeReference typeReference);
    public virtual IUnitNamespaceReference Visit(IUnitNamespaceReference unitNamespaceReference);
    public virtual INestedUnitNamespace Visit(INestedUnitNamespace nestedUnitNamespace);
    public virtual INestedUnitNamespaceReference Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual NestedUnitNamespace Visit(NestedUnitNamespace nestedUnitNamespace);
    public virtual NestedUnitNamespaceReference Visit(NestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual IUnitReference Visit(IUnitReference unitReference);
    public virtual List`1<IParameterDefinition> Visit(List`1<IParameterDefinition> parameterDefinitions);
    public virtual ParameterDefinition Visit(ParameterDefinition parameterDefinition);
    public virtual List`1<IParameterTypeInformation> Visit(List`1<IParameterTypeInformation> parameterTypeInformationList);
    public virtual ParameterTypeInformation Visit(ParameterTypeInformation parameterTypeInformation);
    public virtual PlatformInvokeInformation Visit(PlatformInvokeInformation platformInvokeInformation);
    public virtual List`1<IPropertyDefinition> Visit(List`1<IPropertyDefinition> propertyDefinitions);
    public virtual IPropertyDefinition Visit(IPropertyDefinition propertyDefinition);
    public virtual PropertyDefinition Visit(PropertyDefinition propertyDefinition);
    public virtual PointerTypeReference Visit(PointerTypeReference pointerTypeReference);
    public virtual List`1<IResourceReference> Visit(List`1<IResourceReference> resourceReferences);
    public virtual IResourceReference Visit(ResourceReference resourceReference);
    public virtual List`1<ISecurityAttribute> Visit(List`1<ISecurityAttribute> securityAttributes);
    public virtual IRootUnitNamespaceReference Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual RootUnitNamespace Visit(RootUnitNamespace rootUnitNamespace);
    public virtual RootUnitNamespaceReference Visit(RootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual SecurityAttribute Visit(SecurityAttribute securityAttribute);
    public virtual SectionBlock Visit(SectionBlock sectionBlock);
    public virtual ITypeDefinitionMember Visit(TypeDefinitionMember typeDefinitionMember);
    public virtual TypeReference Visit(TypeReference typeReference);
    public virtual List`1<IPESection> Visit(List`1<IPESection> peSections);
    public virtual PESection Visit(PESection peSection);
    public virtual Unit Visit(Unit unit);
    public virtual UnitNamespace Visit(UnitNamespace unitNamespace);
    public virtual UnitNamespaceReference Visit(UnitNamespaceReference unitNamespaceReference);
    public virtual VectorTypeReference Visit(VectorTypeReference vectorTypeReference);
    public virtual List`1<IWin32Resource> Visit(List`1<IWin32Resource> win32Resources);
    public virtual Win32Resource Visit(Win32Resource win32Resource);
    public virtual List`1<ICustomAttribute> VisitMethodReturnValueAttributes(List`1<ICustomAttribute> customAttributes);
    public virtual List`1<ICustomModifier> VisitMethodReturnValueCustomModifiers(List`1<ICustomModifier> customModifers);
    public virtual IMarshallingInformation VisitMethodReturnValueMarshallingInformation(MarshallingInformation marshallingInformation);
}
public class Microsoft.Cci.MutableCodeModel.MetadataNamedArgument : MetadataExpression {
    private IName argumentName;
    private IMetadataExpression argumentValue;
    private bool isField;
    private object resolvedDefinition;
    public IName ArgumentName { get; public set; }
    public IMetadataExpression ArgumentValue { get; public set; }
    public bool IsField { get; public set; }
    public object ResolvedDefinition { get; public set; }
    public sealed virtual void Copy(IMetadataNamedArgument namedArgument, IInternFactory internFactory);
    public sealed virtual IName get_ArgumentName();
    public void set_ArgumentName(IName value);
    public sealed virtual IMetadataExpression get_ArgumentValue();
    public void set_ArgumentValue(IMetadataExpression value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual bool get_IsField();
    public void set_IsField(bool value);
    public sealed virtual object get_ResolvedDefinition();
    public void set_ResolvedDefinition(object value);
}
public class Microsoft.Cci.MutableCodeModel.MetadataRewriter : object {
    protected IMetadataHost host;
    private IInternFactory internFactory;
    private MetadataShallowCopier shallowCopier;
    private Dispatcher dispatchingVisitor;
    protected Hashtable`2<IReference, object> referenceRewrites;
    public MetadataRewriter(IMetadataHost host, bool copyAndRewriteImmutableReferences);
    private void ObjectInvariant();
    public sealed virtual void Dispose();
    public virtual IAliasForType Rewrite(IAliasForType aliasForType);
    public virtual IAliasMember Rewrite(IAliasMember aliasMember);
    public virtual IArrayTypeReference Rewrite(IArrayTypeReference arrayTypeReference);
    public virtual IAssembly Rewrite(IAssembly assembly);
    public virtual IAssemblyReference Rewrite(IAssemblyReference assemblyReference);
    public virtual ICustomAttribute Rewrite(ICustomAttribute customAttribute);
    public virtual ICustomModifier Rewrite(ICustomModifier customModifier);
    public virtual IEventDefinition Rewrite(IEventDefinition eventDefinition);
    protected virtual IEventDefinition RewriteUnspecialized(IEventDefinition eventDefinition);
    public virtual IFieldDefinition Rewrite(IFieldDefinition fieldDefinition);
    protected virtual IFieldDefinition RewriteUnspecialized(IFieldDefinition fieldDefinition);
    public virtual IFieldReference Rewrite(IFieldReference fieldReference);
    protected virtual IFieldReference RewriteUnspecialized(IFieldReference fieldReference);
    public virtual object RewriteReference(ILocalDefinition localDefinition);
    public virtual object RewriteReference(IParameterDefinition parameterDefinition);
    public virtual IFileReference Rewrite(IFileReference fileReference);
    public virtual IFunctionPointerTypeReference Rewrite(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual IGenericMethodInstanceReference Rewrite(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual IGenericMethodParameter Rewrite(IGenericMethodParameter genericMethodParameter);
    public virtual ITypeReference Rewrite(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual ITypeReference Rewrite(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual IGenericTypeParameter Rewrite(IGenericTypeParameter genericTypeParameter);
    public virtual ITypeReference Rewrite(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual IGlobalFieldDefinition Rewrite(IGlobalFieldDefinition globalFieldDefinition);
    public virtual IGlobalMethodDefinition Rewrite(IGlobalMethodDefinition globalMethodDefinition);
    public virtual ILocalDefinition Rewrite(ILocalDefinition localDefinition);
    public virtual IManagedPointerTypeReference Rewrite(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual IMarshallingInformation Rewrite(IMarshallingInformation marshallingInformation);
    public virtual IMetadataConstant Rewrite(IMetadataConstant constant);
    public virtual IMetadataCreateArray Rewrite(IMetadataCreateArray metadataCreateArray);
    public virtual IMetadataExpression Rewrite(IMetadataExpression metadataExpression);
    public virtual IMetadataNamedArgument Rewrite(IMetadataNamedArgument namedArgument);
    public virtual IMetadataTypeOf Rewrite(IMetadataTypeOf metadataTypeOf);
    public virtual IMethodBody Rewrite(IMethodBody methodBody);
    public virtual IMethodDefinition Rewrite(IMethodDefinition methodDefinition);
    protected virtual IMethodDefinition RewriteUnspecialized(IMethodDefinition methodDefinition);
    public virtual IMethodImplementation Rewrite(IMethodImplementation methodImplementation);
    public virtual IMethodReference Rewrite(IMethodReference methodReference);
    public virtual IMethodReference RewriteUnspecialized(IMethodReference methodReference);
    public virtual IModifiedTypeReference Rewrite(IModifiedTypeReference modifiedTypeReference);
    public virtual IModule Rewrite(IModule module);
    public virtual IModuleReference Rewrite(IModuleReference moduleReference);
    public virtual INamedTypeDefinition Rewrite(INamedTypeDefinition namedTypeDefinition);
    public virtual INamedTypeReference Rewrite(INamedTypeReference typeReference);
    public virtual INamespaceAliasForType Rewrite(INamespaceAliasForType namespaceAliasForType);
    public virtual INamespaceDefinition Rewrite(INamespaceDefinition namespaceDefinition);
    public virtual INamespaceMember Rewrite(INamespaceMember namespaceMember);
    public virtual INamespaceTypeDefinition Rewrite(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual INamespaceTypeReference Rewrite(INamespaceTypeReference namespaceTypeReference);
    public virtual INestedAliasForType Rewrite(INestedAliasForType nestedAliasForType);
    public virtual INestedTypeDefinition Rewrite(INestedTypeDefinition nestedTypeDefinition);
    protected virtual INestedTypeDefinition RewriteUnspecialized(INestedTypeDefinition nestedTypeDefinition);
    public virtual INestedTypeReference Rewrite(INestedTypeReference nestedTypeReference);
    public virtual INestedTypeReference RewriteUnspecialized(INestedTypeReference nestedTypeReference);
    public virtual INestedUnitNamespace Rewrite(INestedUnitNamespace nestedUnitNamespace);
    public virtual INestedUnitNamespaceReference Rewrite(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual IOperation Rewrite(IOperation operation);
    public virtual IOperationExceptionInformation Rewrite(IOperationExceptionInformation operationExceptionInformation);
    public virtual IParameterDefinition Rewrite(IParameterDefinition parameterDefinition);
    public virtual IParameterTypeInformation Rewrite(IParameterTypeInformation parameterTypeInformation);
    public virtual IPESection Rewrite(IPESection peSection);
    public virtual IPlatformInvokeInformation Rewrite(IPlatformInvokeInformation platformInvokeInformation);
    public virtual IPointerTypeReference Rewrite(IPointerTypeReference pointerTypeReference);
    public virtual IPropertyDefinition Rewrite(IPropertyDefinition propertyDefinition);
    protected virtual IPropertyDefinition RewriteUnspecialized(IPropertyDefinition propertyDefinition);
    public virtual IResourceReference Rewrite(IResourceReference resourceReference);
    public virtual IRootUnitNamespace Rewrite(IRootUnitNamespace rootUnitNamespace);
    public virtual IRootUnitNamespaceReference Rewrite(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual ISecurityAttribute Rewrite(ISecurityAttribute securityAttribute);
    public virtual IEventDefinition Rewrite(ISpecializedEventDefinition specializedEventDefinition);
    public virtual IFieldDefinition Rewrite(ISpecializedFieldDefinition specializedFieldDefinition);
    public virtual IFieldReference Rewrite(ISpecializedFieldReference specializedFieldReference);
    public virtual IMethodDefinition Rewrite(ISpecializedMethodDefinition specializedMethodDefinition);
    public virtual IMethodReference Rewrite(ISpecializedMethodReference specializedMethodReference);
    public virtual INestedTypeDefinition Rewrite(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public virtual INestedTypeReference Rewrite(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual IPropertyDefinition Rewrite(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public virtual ITypeDefinition Rewrite(ITypeDefinition typeDefinition);
    public virtual ITypeDefinitionMember Rewrite(ITypeDefinitionMember typeMember);
    public virtual ITypeReference Rewrite(ITypeReference typeReference);
    public virtual IUnit Rewrite(IUnit unit);
    public virtual IUnitNamespace Rewrite(IUnitNamespace unitNamespace);
    public virtual IUnitNamespaceReference Rewrite(IUnitNamespaceReference unitNamespaceReference);
    public virtual IUnitReference Rewrite(IUnitReference unitReference);
    public virtual IWin32Resource Rewrite(IWin32Resource win32Resource);
    public virtual List`1<IAliasForType> Rewrite(List`1<IAliasForType> aliasesForTypes);
    public virtual List`1<IAliasMember> Rewrite(List`1<IAliasMember> aliasMembers);
    public virtual List`1<IAssemblyReference> Rewrite(List`1<IAssemblyReference> assemblyReferences);
    public virtual List`1<ICustomAttribute> Rewrite(List`1<ICustomAttribute> customAttributes);
    public virtual List`1<ICustomModifier> Rewrite(List`1<ICustomModifier> customModifiers);
    public virtual List`1<IEventDefinition> Rewrite(List`1<IEventDefinition> events);
    public virtual List`1<IFieldDefinition> Rewrite(List`1<IFieldDefinition> fields);
    public virtual List`1<IFileReference> Rewrite(List`1<IFileReference> fileReferences);
    public virtual List`1<IGenericMethodParameter> Rewrite(List`1<IGenericMethodParameter> genericParameters);
    public virtual List`1<IGenericTypeParameter> Rewrite(List`1<IGenericTypeParameter> genericParameters);
    public virtual List`1<ILocalDefinition> Rewrite(List`1<ILocalDefinition> localDefinitions);
    public virtual List`1<IMetadataExpression> Rewrite(List`1<IMetadataExpression> expressions);
    public virtual List`1<IMetadataNamedArgument> Rewrite(List`1<IMetadataNamedArgument> namedArguments);
    public virtual List`1<IMethodDefinition> Rewrite(List`1<IMethodDefinition> methods);
    public virtual List`1<IMethodImplementation> Rewrite(List`1<IMethodImplementation> methodImplementations);
    public virtual List`1<IMethodReference> Rewrite(List`1<IMethodReference> methodReferences);
    public virtual List`1<IModule> Rewrite(List`1<IModule> modules);
    public virtual List`1<IModuleReference> Rewrite(List`1<IModuleReference> moduleReferences);
    public virtual List`1<INamedTypeDefinition> Rewrite(List`1<INamedTypeDefinition> types);
    public virtual List`1<INamespaceMember> Rewrite(List`1<INamespaceMember> namespaceMembers);
    public virtual List`1<INestedTypeDefinition> Rewrite(List`1<INestedTypeDefinition> nestedTypes);
    public virtual List`1<IOperation> Rewrite(List`1<IOperation> operations);
    public virtual List`1<IOperationExceptionInformation> Rewrite(List`1<IOperationExceptionInformation> operationExceptionInformations);
    public virtual List`1<IParameterDefinition> Rewrite(List`1<IParameterDefinition> parameters);
    public virtual List`1<IParameterTypeInformation> Rewrite(List`1<IParameterTypeInformation> parameterTypeInformations);
    public virtual List`1<IPESection> Rewrite(List`1<IPESection> peSections);
    public virtual List`1<IPropertyDefinition> Rewrite(List`1<IPropertyDefinition> properties);
    public virtual List`1<IResourceReference> Rewrite(List`1<IResourceReference> resourceReferences);
    public virtual List`1<ISecurityAttribute> Rewrite(List`1<ISecurityAttribute> securityAttributes);
    public virtual List`1<ITypeDefinitionMember> Rewrite(List`1<ITypeDefinitionMember> typeMembers);
    public virtual List`1<ITypeReference> Rewrite(List`1<ITypeReference> typeReferences);
    public virtual List`1<IWin32Resource> Rewrite(List`1<IWin32Resource> win32Resources);
    public virtual void RewriteChildren(AliasForType aliasForType);
    public virtual void RewriteChildren(ArrayTypeReference arrayTypeReference);
    public virtual void RewriteChildren(Assembly assembly);
    public virtual void RewriteChildren(AssemblyReference assemblyReference);
    public virtual void RewriteChildren(CustomAttribute customAttribute);
    public virtual void RewriteChildren(CustomModifier customModifier);
    public virtual void RewriteChildren(EventDefinition eventDefinition);
    public virtual void RewriteChildren(FieldDefinition fieldDefinition);
    public virtual void RewriteChildren(FieldReference fieldReference);
    public virtual void RewriteChildren(FileReference fileReference);
    public virtual void RewriteChildren(FunctionPointerTypeReference functionPointerTypeReference);
    public virtual void RewriteChildren(GenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void RewriteChildren(GenericMethodParameter genericMethodParameter);
    public virtual void RewriteChildren(GenericMethodParameterReference genericMethodParameterReference);
    public virtual void RewriteChildren(GenericParameter genericParameter);
    public virtual void RewriteChildren(GenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void RewriteChildren(GenericTypeParameter genericTypeParameter);
    public virtual void RewriteChildren(GenericTypeParameterReference genericTypeParameterReference);
    public virtual void RewriteChildren(GlobalFieldDefinition globalFieldDefinition);
    public virtual void RewriteChildren(GlobalMethodDefinition globalMethodDefinition);
    public virtual void RewriteChildren(LocalDefinition localDefinition);
    public virtual void RewriteChildren(ManagedPointerTypeReference managedPointerTypeReference);
    public virtual void RewriteChildren(MarshallingInformation marshallingInformation);
    public virtual void RewriteChildren(MetadataConstant constant);
    public virtual void RewriteChildren(MetadataCreateArray createArray);
    public virtual void RewriteChildren(MetadataExpression expression);
    public virtual void RewriteChildren(MetadataNamedArgument namedArgument);
    public virtual void RewriteChildren(MetadataTypeOf metadataTypeOf);
    public virtual void RewriteChildren(MethodBody methodBody);
    public virtual void RewriteChildren(MethodDefinition method);
    public virtual void RewriteChildren(MethodImplementation methodImplementation);
    public virtual void RewriteChildren(MethodReference methodReference);
    public virtual void RewriteChildren(ModifiedTypeReference modifiedTypeReference);
    public virtual void RewriteChildren(Module module);
    public virtual void RewriteChildren(ModuleReference moduleReference);
    public virtual void RewriteChildren(NamespaceAliasForType namespaceAliasForType);
    public virtual void RewriteChildren(NamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void RewriteChildren(NamespaceTypeReference namespaceTypeReference);
    public virtual void RewriteChildren(NestedAliasForType nestedAliasForType);
    public virtual void RewriteChildren(NestedTypeDefinition nestedTypeDefinition);
    public virtual void RewriteChildren(NestedTypeReference nestedTypeReference);
    public virtual void RewriteChildren(NestedUnitNamespace nestedUnitNamespace);
    public virtual void RewriteChildren(NestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual void RewriteChildren(Operation operation);
    public virtual void RewriteChildren(OperationExceptionInformation operationExceptionInformation);
    public virtual void RewriteChildren(ParameterDefinition parameterDefinition);
    public virtual void RewriteChildren(ParameterTypeInformation parameterTypeInformation);
    public virtual void RewriteChildren(PESection peSection);
    public virtual void RewriteChildren(PlatformInvokeInformation platformInvokeInformation);
    public virtual void RewriteChildren(PointerTypeReference pointerTypeReference);
    public virtual void RewriteChildren(PropertyDefinition propertyDefinition);
    public virtual void RewriteChildren(ResourceReference resourceReference);
    public virtual void RewriteChildren(RootUnitNamespace rootUnitNamespace);
    public virtual void RewriteChildren(RootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual void RewriteChildren(SecurityAttribute securityAttribute);
    public virtual void RewriteChildren(SpecializedEventDefinition specializedEventDefinition);
    public virtual void RewriteChildren(SpecializedFieldDefinition specializedFieldDefinition);
    public virtual void RewriteChildren(SpecializedFieldReference specializedFieldReference);
    public virtual void RewriteChildren(SpecializedMethodDefinition specializedMethodDefinition);
    public virtual void RewriteChildren(SpecializedMethodReference specializedMethodReference);
    public virtual void RewriteChildren(SpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public virtual void RewriteChildren(SpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual void RewriteChildren(SpecializedPropertyDefinition specializedPropertyDefinition);
    public virtual void RewriteChildren(NamedTypeDefinition typeDefinition);
    public virtual void RewriteChildren(TypeDefinitionMember typeDefinitionMember);
    public virtual void RewriteChildren(TypeReference typeReference);
    public virtual void RewriteChildren(Unit unit);
    public virtual void RewriteChildren(UnitReference unitReference);
    public virtual void RewriteChildren(UnitNamespace unitNamespace);
    public virtual void RewriteChildren(UnitNamespaceReference unitNamespaceReference);
    public virtual void RewriteChildren(Win32Resource win32Resource);
}
public class Microsoft.Cci.MutableCodeModel.MetadataShallowCopier : object {
    protected IMetadataHost targetHost;
    private IUnit targetUnit;
    private IInternFactory internFactory;
    private MetadataDispatcher dispatcher;
    private MetadataDispatcher Dispatcher { get; }
    public MetadataShallowCopier(IMetadataHost targetHost);
    public MetadataShallowCopier(IMetadataHost targetHost, IUnit targetUnit);
    private MetadataDispatcher get_Dispatcher();
    public AliasForType Copy(IAliasForType aliasForType);
    public ArrayTypeReference Copy(IArrayTypeReference arrayTypeReference);
    public Assembly Copy(IAssembly assembly);
    public AssemblyReference Copy(IAssemblyReference assemblyReference);
    public CustomAttribute Copy(ICustomAttribute customAttribute);
    public CustomModifier Copy(ICustomModifier customModifier);
    public EventDefinition Copy(IEventDefinition eventDefinition);
    public EventDefinition CopyUnspecialized(IEventDefinition eventDefinition);
    public FieldDefinition Copy(IFieldDefinition fieldDefinition);
    private FieldDefinition CopyUnspecialized(IFieldDefinition fieldDefinition);
    public FieldReference Copy(IFieldReference fieldReference);
    private FieldReference CopyUnspecialized(IFieldReference fieldReference);
    public FileReference Copy(IFileReference fileReference);
    public FunctionPointerTypeReference Copy(IFunctionPointerTypeReference functionPointerTypeReference);
    public GenericMethodInstanceReference Copy(IGenericMethodInstanceReference genericMethodInstanceReference);
    public GenericMethodParameter Copy(IGenericMethodParameter genericMethodParameter);
    public GenericMethodParameterReference Copy(IGenericMethodParameterReference genericMethodParameterReference);
    public GenericTypeInstanceReference Copy(IGenericTypeInstanceReference genericTypeInstanceReference);
    public GenericTypeParameter Copy(IGenericTypeParameter genericTypeParameter);
    public GenericTypeParameterReference Copy(IGenericTypeParameterReference genericTypeParameterReference);
    public GlobalFieldDefinition Copy(IGlobalFieldDefinition globalFieldDefinition);
    public GlobalMethodDefinition Copy(IGlobalMethodDefinition globalMethodDefinition);
    public LocalDefinition Copy(ILocalDefinition localDefinition);
    public ManagedPointerTypeReference Copy(IManagedPointerTypeReference managedPointerTypeReference);
    public MarshallingInformation Copy(IMarshallingInformation marshallingInformation);
    public MetadataConstant Copy(IMetadataConstant constant);
    public MetadataCreateArray Copy(IMetadataCreateArray createArray);
    public MetadataExpression Copy(IMetadataExpression expression);
    public MetadataNamedArgument Copy(IMetadataNamedArgument namedArgument);
    public MetadataTypeOf Copy(IMetadataTypeOf typeOf);
    public MethodBody Copy(IMethodBody methodBody);
    internal MethodBody PartialCopy(IMethodBody methodBody);
    public MethodDefinition Copy(IMethodDefinition method);
    private MethodDefinition CopyUnspecialized(IMethodDefinition method);
    public MethodImplementation Copy(IMethodImplementation methodImplementation);
    public MethodReference Copy(IMethodReference methodReference);
    private MethodReference CopyUnspecialized(IMethodReference methodReference);
    public ModifiedTypeReference Copy(IModifiedTypeReference modifiedTypeReference);
    public Module Copy(IModule module);
    public ModuleReference Copy(IModuleReference moduleReference);
    public NamedTypeDefinition Copy(INamedTypeDefinition typeDefinition);
    public NamespaceAliasForType Copy(INamespaceAliasForType namespaceAliasForType);
    public UnitNamespace Copy(IUnitNamespace unitNamespace);
    public UnitNamespaceReference Copy(IUnitNamespaceReference unitNamespace);
    public NamespaceTypeDefinition Copy(INamespaceTypeDefinition namespaceTypeDefinition);
    public NamespaceTypeReference Copy(INamespaceTypeReference namespaceTypeReference);
    public NestedAliasForType Copy(INestedAliasForType nestedAliasForType);
    public NestedTypeDefinition Copy(INestedTypeDefinition nestedTypeDefinition);
    private NestedTypeDefinition CopyUnspecialized(INestedTypeDefinition nestedTypeDefinition);
    public NestedTypeReference Copy(INestedTypeReference nestedTypeReference);
    private NestedTypeReference CopyUnspecialized(INestedTypeReference nestedTypeReference);
    public NestedUnitNamespace Copy(INestedUnitNamespace nestedUnitNamespace);
    public NestedUnitNamespaceReference Copy(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public Operation Copy(IOperation operation);
    public OperationExceptionInformation Copy(IOperationExceptionInformation operationExceptionInformation);
    public ParameterDefinition Copy(IParameterDefinition parameterDefinition);
    public ParameterTypeInformation Copy(IParameterTypeInformation parameterTypeInformation);
    public PESection Copy(IPESection peSection);
    public PlatformInvokeInformation Copy(IPlatformInvokeInformation platformInvokeInformation);
    public PointerTypeReference Copy(IPointerTypeReference pointerTypeReference);
    public PropertyDefinition Copy(IPropertyDefinition propertyDefinition);
    private PropertyDefinition CopyUnspecialized(IPropertyDefinition propertyDefinition);
    public RootUnitNamespace Copy(IRootUnitNamespace rootUnitNamespace);
    public RootUnitNamespaceReference Copy(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public ResourceReference Copy(IResourceReference resourceReference);
    public SecurityAttribute Copy(ISecurityAttribute securityAttribute);
    public SpecializedEventDefinition Copy(ISpecializedEventDefinition specializedEventDefinition);
    public SpecializedFieldDefinition Copy(ISpecializedFieldDefinition specializedFieldDefinition);
    public SpecializedFieldReference Copy(ISpecializedFieldReference fieldReference);
    public SpecializedMethodDefinition Copy(ISpecializedMethodDefinition specializedMethodDefinition);
    public SpecializedMethodReference Copy(ISpecializedMethodReference specializedMethodReference);
    public SpecializedNestedTypeDefinition Copy(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition);
    public SpecializedNestedTypeReference Copy(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public SpecializedPropertyDefinition Copy(ISpecializedPropertyDefinition specializedPropertyDefinition);
    public ITypeDefinition Copy(ITypeDefinition typeDefinition);
    public TypeDefinitionMember Copy(ITypeDefinitionMember typeMember);
    public TypeReference Copy(ITypeReference typeReference);
    public UnitReference Copy(IUnitReference unitReference);
    public Win32Resource Copy(IWin32Resource win32Resource);
}
public class Microsoft.Cci.MutableCodeModel.MetadataTypeOf : MetadataExpression {
    private ITypeReference typeToGet;
    public ITypeReference TypeToGet { get; public set; }
    public sealed virtual void Copy(IMetadataTypeOf typeOf, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual ITypeReference get_TypeToGet();
    public void set_TypeToGet(ITypeReference value);
}
public class Microsoft.Cci.MutableCodeModel.MethodBody : object {
    private bool localsAreZeroed;
    private List`1<ILocalDefinition> localVariables;
    private ushort maxStack;
    private IMethodDefinition methodDefinition;
    private List`1<IOperation> operations;
    private List`1<IOperationExceptionInformation> operationExceptionInformation;
    private List`1<ITypeDefinition> privateHelperTypes;
    private UInt32 size;
    public bool LocalsAreZeroed { get; public set; }
    public List`1<ILocalDefinition> LocalVariables { get; public set; }
    public ushort MaxStack { get; public set; }
    public IMethodDefinition MethodDefinition { get; public set; }
    public List`1<IOperation> Operations { get; public set; }
    public List`1<IOperationExceptionInformation> OperationExceptionInformation { get; public set; }
    public List`1<ITypeDefinition> PrivateHelperTypes { get; public set; }
    public UInt32 Size { get; public set; }
    private IEnumerable`1<IOperationExceptionInformation> Microsoft.Cci.IMethodBody.OperationExceptionInformation { get; }
    private IEnumerable`1<ILocalDefinition> Microsoft.Cci.IMethodBody.LocalVariables { get; }
    private IEnumerable`1<IOperation> Microsoft.Cci.IMethodBody.Operations { get; }
    private IEnumerable`1<ITypeDefinition> Microsoft.Cci.IMethodBody.PrivateHelperTypes { get; }
    public sealed virtual void Copy(IMethodBody methodBody, IInternFactory internFactory);
    internal void PartialCopy(IMethodBody methodBody, IInternFactory internFactory);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual bool get_LocalsAreZeroed();
    public void set_LocalsAreZeroed(bool value);
    public List`1<ILocalDefinition> get_LocalVariables();
    public void set_LocalVariables(List`1<ILocalDefinition> value);
    public sealed virtual ushort get_MaxStack();
    public void set_MaxStack(ushort value);
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public void set_MethodDefinition(IMethodDefinition value);
    public List`1<IOperation> get_Operations();
    public void set_Operations(List`1<IOperation> value);
    public List`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public void set_OperationExceptionInformation(List`1<IOperationExceptionInformation> value);
    public List`1<ITypeDefinition> get_PrivateHelperTypes();
    public void set_PrivateHelperTypes(List`1<ITypeDefinition> value);
    public sealed virtual UInt32 get_Size();
    public void set_Size(UInt32 value);
    private sealed virtual override IEnumerable`1<IOperationExceptionInformation> Microsoft.Cci.IMethodBody.get_OperationExceptionInformation();
    private sealed virtual override IEnumerable`1<ILocalDefinition> Microsoft.Cci.IMethodBody.get_LocalVariables();
    private sealed virtual override IEnumerable`1<IOperation> Microsoft.Cci.IMethodBody.get_Operations();
    private sealed virtual override IEnumerable`1<ITypeDefinition> Microsoft.Cci.IMethodBody.get_PrivateHelperTypes();
}
[ObsoleteAttribute("Please use CodeRewriter")]
public class Microsoft.Cci.MutableCodeModel.MethodBodyCodeMutator : CodeMutatingVisitor {
    public MethodBodyCodeMutator(IMetadataHost host);
    public MethodBodyCodeMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable);
    public MethodBodyCodeMutator(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public MethodBodyCodeMutator(IMetadataHost host, bool copyOnlyIfNotAlreadyMutable, ISourceLocationProvider sourceLocationProvider);
    public virtual IFieldReference Visit(IFieldReference fieldReference);
    public virtual ILocalDefinition VisitReferenceTo(ILocalDefinition localDefinition);
    public virtual IMethodReference Visit(IMethodReference methodReference);
    public virtual IParameterDefinition VisitReferenceTo(IParameterDefinition parameterDefinition);
    public virtual ITypeReference Visit(ITypeReference typeReference);
}
[ObsoleteAttribute("Please use CodeRewriter")]
public class Microsoft.Cci.MutableCodeModel.MethodBodyMappingMutator : CodeMutatingVisitor {
    public MethodBodyMappingMutator(IMetadataHost host);
    public virtual INamespaceTypeReference Visit(INamespaceTypeReference namespaceTypeReference);
    public virtual INestedTypeReference Visit(INestedTypeReference nestedTypeReference);
    public virtual IGenericTypeParameterReference Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual IGenericMethodParameterReference Visit(IGenericMethodParameterReference genericMethodParameterReference);
}
public class Microsoft.Cci.MutableCodeModel.MethodBodyNormalizer : object {
    private IMetadataHost host;
    private ISourceLocationProvider sourceLocationProvider;
    private bool isIteratorBody;
    public bool IsIteratorBody { get; }
    public MethodBodyNormalizer(IMetadataHost host, ISourceLocationProvider sourceLocationProvider);
    public SourceMethodBody GetNormalizedSourceMethodBodyFor(IMethodDefinition method, IBlockStatement body);
    private BlockStatement GetNormalizedIteratorBody(IBlockStatement body, IMethodDefinition method, List`1<ITypeDefinition> privateHelperTypes);
    public bool get_IsIteratorBody();
}
public class Microsoft.Cci.MutableCodeModel.MethodCall : ConstructorOrMethodCall {
    private bool isJumpCall;
    private bool isVirtualCall;
    private bool isStaticCall;
    private bool isTailCall;
    private IExpression thisArgument;
    public bool IsJumpCall { get; public set; }
    public bool IsVirtualCall { get; public set; }
    public bool IsStaticCall { get; public set; }
    public bool IsTailCall { get; public set; }
    public IExpression ThisArgument { get; public set; }
    private IEnumerable`1<IExpression> Microsoft.Cci.IMethodCall.Arguments { get; }
    private IMethodReference Microsoft.Cci.IMethodCall.MethodToCall { get; }
    public MethodCall(IMethodCall methodCall);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual bool get_IsJumpCall();
    public void set_IsJumpCall(bool value);
    public sealed virtual bool get_IsVirtualCall();
    public void set_IsVirtualCall(bool value);
    public sealed virtual bool get_IsStaticCall();
    public void set_IsStaticCall(bool value);
    public sealed virtual bool get_IsTailCall();
    public void set_IsTailCall(bool value);
    public sealed virtual IExpression get_ThisArgument();
    public void set_ThisArgument(IExpression value);
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.IMethodCall.get_Arguments();
    private sealed virtual override IMethodReference Microsoft.Cci.IMethodCall.get_MethodToCall();
}
public class Microsoft.Cci.MutableCodeModel.MethodDefinition : TypeDefinitionMember {
    private IMethodBody body;
    private CallingConvention callingConvention;
    private List`1<IGenericMethodParameter> genericParameters;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    private List`1<IParameterDefinition> parameters;
    private IPlatformInvokeInformation platformInvokeData;
    private List`1<ICustomAttribute> returnValueAttributes;
    private List`1<ICustomModifier> returnValueCustomModifiers;
    private IMarshallingInformation returnValueMarshallingInformation;
    private IName returnValueName;
    private List`1<ISecurityAttribute> securityAttributes;
    private ITypeReference type;
    public bool AcceptsExtraArguments { get; public set; }
    public IMethodBody Body { get; public set; }
    public CallingConvention CallingConvention { get; public set; }
    public List`1<IGenericMethodParameter> GenericParameters { get; public set; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; public set; }
    public bool HasExplicitThisParameter { get; public set; }
    public IInternFactory InternFactory { get; public set; }
    public UInt32 InternedKey { get; }
    public bool IsAbstract { get; public set; }
    public bool IsAccessCheckedOnOverride { get; public set; }
    public bool IsAggressivelyInlined { get; public set; }
    public bool IsCil { get; public set; }
    public bool IsConstructor { get; }
    public bool IsExternal { get; public set; }
    public bool IsForwardReference { get; public set; }
    public bool IsGeneric { get; }
    public bool IsHiddenBySignature { get; public set; }
    public bool IsNativeCode { get; public set; }
    public bool IsNewSlot { get; public set; }
    public bool IsNeverInlined { get; public set; }
    public bool IsNeverOptimized { get; public set; }
    public bool IsPlatformInvoke { get; public set; }
    public bool IsRuntimeImplemented { get; public set; }
    public bool IsRuntimeInternal { get; public set; }
    public bool IsRuntimeSpecial { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsStaticConstructor { get; }
    public bool IsSynchronized { get; public set; }
    public bool IsUnmanaged { get; public set; }
    public bool IsVirtual { get; public set; }
    public List`1<IParameterDefinition> Parameters { get; public set; }
    public ushort ParameterCount { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; public set; }
    public bool PreserveSignature { get; public set; }
    public bool RequiresSecurityObject { get; public set; }
    public List`1<ICustomAttribute> ReturnValueAttributes { get; public set; }
    public List`1<ICustomModifier> ReturnValueCustomModifiers { get; public set; }
    public bool ReturnValueIsByRef { get; public set; }
    public bool ReturnValueIsMarshalledExplicitly { get; public set; }
    public bool ReturnValueIsModified { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; public set; }
    public IName ReturnValueName { get; public set; }
    public List`1<ISecurityAttribute> SecurityAttributes { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.GenericParameters { get; }
    private IEnumerable`1<ISecurityAttribute> Microsoft.Cci.IMethodDefinition.SecurityAttributes { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private IEnumerable`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.Parameters { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.ReturnValueAttributes { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public IEnumerable`1<IParameterTypeInformation> ExtraParameters { get; }
    public sealed virtual void Copy(IMethodDefinition methodDefinition, IInternFactory internFactory);
    public sealed virtual bool get_AcceptsExtraArguments();
    public void set_AcceptsExtraArguments(bool value);
    public sealed virtual IMethodBody get_Body();
    public void set_Body(IMethodBody value);
    public sealed virtual CallingConvention get_CallingConvention();
    public void set_CallingConvention(CallingConvention value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<IGenericMethodParameter> get_GenericParameters();
    public void set_GenericParameters(List`1<IGenericMethodParameter> value);
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public void set_HasDeclarativeSecurity(bool value);
    public sealed virtual bool get_HasExplicitThisParameter();
    public void set_HasExplicitThisParameter(bool value);
    public IInternFactory get_InternFactory();
    public void set_InternFactory(IInternFactory value);
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsAccessCheckedOnOverride();
    public void set_IsAccessCheckedOnOverride(bool value);
    public sealed virtual bool get_IsAggressivelyInlined();
    public void set_IsAggressivelyInlined(bool value);
    public sealed virtual bool get_IsCil();
    public void set_IsCil(bool value);
    public sealed virtual bool get_IsConstructor();
    public sealed virtual bool get_IsExternal();
    public void set_IsExternal(bool value);
    public sealed virtual bool get_IsForwardReference();
    public void set_IsForwardReference(bool value);
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsHiddenBySignature();
    public void set_IsHiddenBySignature(bool value);
    public sealed virtual bool get_IsNativeCode();
    public void set_IsNativeCode(bool value);
    public sealed virtual bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public sealed virtual bool get_IsNeverInlined();
    public void set_IsNeverInlined(bool value);
    public sealed virtual bool get_IsNeverOptimized();
    public void set_IsNeverOptimized(bool value);
    public sealed virtual bool get_IsPlatformInvoke();
    public void set_IsPlatformInvoke(bool value);
    public sealed virtual bool get_IsRuntimeImplemented();
    public void set_IsRuntimeImplemented(bool value);
    public sealed virtual bool get_IsRuntimeInternal();
    public void set_IsRuntimeInternal(bool value);
    public sealed virtual bool get_IsRuntimeSpecial();
    public void set_IsRuntimeSpecial(bool value);
    public sealed virtual bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsStatic();
    public void set_IsStatic(bool value);
    public sealed virtual bool get_IsStaticConstructor();
    public sealed virtual bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public sealed virtual bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public sealed virtual bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public List`1<IParameterDefinition> get_Parameters();
    public void set_Parameters(List`1<IParameterDefinition> value);
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public void set_PlatformInvokeData(IPlatformInvokeInformation value);
    public sealed virtual bool get_PreserveSignature();
    public void set_PreserveSignature(bool value);
    public sealed virtual bool get_RequiresSecurityObject();
    public void set_RequiresSecurityObject(bool value);
    public List`1<ICustomAttribute> get_ReturnValueAttributes();
    public void set_ReturnValueAttributes(List`1<ICustomAttribute> value);
    public List`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public void set_ReturnValueCustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_ReturnValueIsByRef();
    public void set_ReturnValueIsByRef(bool value);
    public sealed virtual bool get_ReturnValueIsMarshalledExplicitly();
    public void set_ReturnValueIsMarshalledExplicitly(bool value);
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public void set_ReturnValueMarshallingInformation(IMarshallingInformation value);
    public sealed virtual IName get_ReturnValueName();
    public void set_ReturnValueName(IName value);
    public List`1<ISecurityAttribute> get_SecurityAttributes();
    public void set_SecurityAttributes(List`1<ISecurityAttribute> value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.get_GenericParameters();
    private sealed virtual override IEnumerable`1<ISecurityAttribute> Microsoft.Cci.IMethodDefinition.get_SecurityAttributes();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override IEnumerable`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.get_ReturnValueAttributes();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    public sealed virtual IEnumerable`1<IParameterTypeInformation> get_ExtraParameters();
}
public class Microsoft.Cci.MutableCodeModel.MethodImplementation : object {
    private ITypeDefinition containingType;
    private IMethodReference implementedMethod;
    private IMethodReference implementingMethod;
    public ITypeDefinition ContainingType { get; public set; }
    public IMethodReference ImplementedMethod { get; public set; }
    public IMethodReference ImplementingMethod { get; public set; }
    public sealed virtual void Copy(IMethodImplementation methodImplementation, IInternFactory internFactory);
    public sealed virtual ITypeDefinition get_ContainingType();
    public void set_ContainingType(ITypeDefinition value);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_ImplementedMethod();
    public void set_ImplementedMethod(IMethodReference value);
    public sealed virtual IMethodReference get_ImplementingMethod();
    public void set_ImplementingMethod(IMethodReference value);
}
public class Microsoft.Cci.MutableCodeModel.MethodReference : object {
    private List`1<ICustomAttribute> attributes;
    private CallingConvention callingConvention;
    private ITypeReference containingType;
    private List`1<IParameterTypeInformation> extraParameters;
    private ushort genericParameterCount;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    private bool isFrozen;
    private List`1<ILocation> locations;
    private IName name;
    private List`1<IParameterTypeInformation> parameters;
    private IMethodDefinition resolvedMethod;
    private List`1<ICustomModifier> returnValueCustomModifiers;
    private bool returnValueIsByRef;
    private bool returnValueIsModified;
    private ITypeReference type;
    public bool AcceptsExtraArguments { get; }
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public CallingConvention CallingConvention { get; public set; }
    public ITypeReference ContainingType { get; public set; }
    public List`1<IParameterTypeInformation> ExtraParameters { get; public set; }
    public ushort GenericParameterCount { get; public set; }
    public IInternFactory InternFactory { get; public set; }
    public UInt32 InternedKey { get; }
    public bool IsFrozen { get; public set; }
    public bool IsGeneric { get; }
    public bool IsStatic { get; }
    public List`1<ILocation> Locations { get; public set; }
    public IName Name { get; public set; }
    public List`1<IParameterTypeInformation> Parameters { get; public set; }
    public ushort ParameterCount { get; }
    public IMethodDefinition ResolvedMethod { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public List`1<ICustomModifier> ReturnValueCustomModifiers { get; public set; }
    public bool ReturnValueIsByRef { get; public set; }
    public bool ReturnValueIsModified { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.ExtraParameters { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public sealed virtual void Copy(IMethodReference methodReference, IInternFactory internFactory);
    public sealed virtual bool get_AcceptsExtraArguments();
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual CallingConvention get_CallingConvention();
    public void set_CallingConvention(CallingConvention value);
    public sealed virtual ITypeReference get_ContainingType();
    public void set_ContainingType(ITypeReference value);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<IParameterTypeInformation> get_ExtraParameters();
    public void set_ExtraParameters(List`1<IParameterTypeInformation> value);
    public sealed virtual ushort get_GenericParameterCount();
    public void set_GenericParameterCount(ushort value);
    public IInternFactory get_InternFactory();
    public void set_InternFactory(IInternFactory value);
    public sealed virtual UInt32 get_InternedKey();
    public bool get_IsFrozen();
    public void set_IsFrozen(bool value);
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsStatic();
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public List`1<IParameterTypeInformation> get_Parameters();
    public void set_Parameters(List`1<IParameterTypeInformation> value);
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual IMethodDefinition get_ResolvedMethod();
    protected virtual IMethodDefinition Resolve();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    public List`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public void set_ReturnValueCustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_ReturnValueIsByRef();
    public void set_ReturnValueIsByRef(bool value);
    public sealed virtual bool get_ReturnValueIsModified();
    public void set_ReturnValueIsModified(bool value);
    public virtual string ToString();
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.get_ExtraParameters();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.ModifiedTypeReference : TypeReference {
    private List`1<ICustomModifier> customModifiers;
    private ITypeReference unmodifiedType;
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public ITypeDefinition ResolvedType { get; }
    public ITypeReference UnmodifiedType { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.IModifiedTypeReference.CustomModifiers { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IModifiedTypeReference modifiedTypeReference, IInternFactory internFactory);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public virtual ITypeDefinition get_ResolvedType();
    public sealed virtual ITypeReference get_UnmodifiedType();
    public void set_UnmodifiedType(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.IModifiedTypeReference.get_CustomModifiers();
}
public class Microsoft.Cci.MutableCodeModel.Module : Unit {
    private List`1<INamedTypeDefinition> allTypes;
    private List`1<IAssemblyReference> assemblyReferences;
    private ulong baseAddress;
    private IAssembly containingAssembly;
    private string debugInformationLocation;
    private string debugInformationVersion;
    private ushort dllCharacteristics;
    private IMethodReference entryPoint;
    private UInt32 fileAlignment;
    private List`1<IGenericMethodInstanceReference> genericMethodInstances;
    private bool ilOnly;
    private bool strongNameSigned;
    private List`1<ITypeReference> structuralTypeInstances;
    private List`1<ITypeMemberReference> structuralTypeInstanceMembers;
    private bool prefers32bits;
    private ModuleKind kind;
    private byte linkerMajorVersion;
    private byte linkerMinorVersion;
    private byte metadataFormatMajorVersion;
    private byte metadataFormatMinorVersion;
    private List`1<ICustomAttribute> moduleAttributes;
    private List`1<IModuleReference> moduleReferences;
    private Guid persistentIdentifier;
    private Machine machine;
    private bool requiresAmdInstructionSet;
    private bool requiresStartupStub;
    private bool requires32bits;
    private bool requires64bits;
    private ulong sizeOfHeapCommit;
    private ulong sizeOfHeapReserve;
    private ulong sizeOfStackCommit;
    private ulong sizeOfStackReserve;
    private List`1<string> strings;
    private ushort subsystemMajorVersion;
    private ushort subsystemMinorVersion;
    private string targetRuntimeVersion;
    private bool trackDebugData;
    private List`1<ITypeReference> typeReferences;
    private List`1<ITypeMemberReference> typeMemberReferences;
    private bool usePublicKeyTokensForAssemblyReferences;
    private List`1<IWin32Resource> win32Resources;
    private ModuleIdentity moduleIdentity;
    public List`1<INamedTypeDefinition> AllTypes { get; public set; }
    public List`1<IAssemblyReference> AssemblyReferences { get; public set; }
    public ulong BaseAddress { get; public set; }
    public IAssembly ContainingAssembly { get; public set; }
    public string DebugInformationLocation { get; public set; }
    public string DebugInformationVersion { get; public set; }
    public ushort DllCharacteristics { get; public set; }
    public IMethodReference EntryPoint { get; public set; }
    public UInt32 FileAlignment { get; public set; }
    public List`1<IGenericMethodInstanceReference> GenericMethodInstances { get; public set; }
    public bool ILOnly { get; public set; }
    public bool StrongNameSigned { get; public set; }
    public List`1<ITypeReference> StructuralTypeInstances { get; public set; }
    public List`1<ITypeMemberReference> StructuralTypeInstanceMembers { get; public set; }
    public bool Prefers32bits { get; public set; }
    public ModuleKind Kind { get; public set; }
    public byte LinkerMajorVersion { get; public set; }
    public byte LinkerMinorVersion { get; public set; }
    public string Location { get; public set; }
    public byte MetadataFormatMajorVersion { get; public set; }
    public byte MetadataFormatMinorVersion { get; public set; }
    public List`1<ICustomAttribute> ModuleAttributes { get; public set; }
    public IName ModuleName { get; public set; }
    public List`1<IModuleReference> ModuleReferences { get; public set; }
    public IName Name { get; public set; }
    public Guid PersistentIdentifier { get; public set; }
    public Machine Machine { get; public set; }
    public bool RequiresAmdInstructionSet { get; public set; }
    public bool RequiresStartupStub { get; public set; }
    public bool Requires32bits { get; public set; }
    public bool Requires64bits { get; public set; }
    public ulong SizeOfHeapCommit { get; public set; }
    public ulong SizeOfHeapReserve { get; public set; }
    public ulong SizeOfStackCommit { get; public set; }
    public ulong SizeOfStackReserve { get; public set; }
    public List`1<string> Strings { get; public set; }
    public ushort SubsystemMajorVersion { get; public set; }
    public ushort SubsystemMinorVersion { get; public set; }
    public string TargetRuntimeVersion { get; public set; }
    public bool TrackDebugData { get; public set; }
    public List`1<ITypeReference> TypeReferences { get; public set; }
    public List`1<ITypeMemberReference> TypeMemberReferences { get; public set; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    public bool UsePublicKeyTokensForAssemblyReferences { get; public set; }
    public List`1<IWin32Resource> Win32Resources { get; public set; }
    private IEnumerable`1<IAssemblyReference> Microsoft.Cci.IModule.AssemblyReferences { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.ModuleAttributes { get; }
    private IEnumerable`1<IModuleReference> Microsoft.Cci.IModule.ModuleReferences { get; }
    private IEnumerable`1<IWin32Resource> Microsoft.Cci.IModule.Win32Resources { get; }
    public UnitIdentity UnitIdentity { get; }
    public ModuleIdentity ModuleIdentity { get; }
    private IAssemblyReference Microsoft.Cci.IModuleReference.ContainingAssembly { get; }
    public IModule ResolvedModule { get; }
    public IUnit ResolvedUnit { get; }
    public sealed virtual void Copy(IModule module, IInternFactory internFactory);
    public List`1<INamedTypeDefinition> get_AllTypes();
    public void set_AllTypes(List`1<INamedTypeDefinition> value);
    public List`1<IAssemblyReference> get_AssemblyReferences();
    public void set_AssemblyReferences(List`1<IAssemblyReference> value);
    public sealed virtual ulong get_BaseAddress();
    public void set_BaseAddress(ulong value);
    public virtual IAssembly get_ContainingAssembly();
    public virtual void set_ContainingAssembly(IAssembly value);
    public virtual string get_DebugInformationLocation();
    public virtual void set_DebugInformationLocation(string value);
    public virtual string get_DebugInformationVersion();
    public virtual void set_DebugInformationVersion(string value);
    public virtual ushort get_DllCharacteristics();
    public virtual void set_DllCharacteristics(ushort value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_EntryPoint();
    public void set_EntryPoint(IMethodReference value);
    public sealed virtual UInt32 get_FileAlignment();
    public void set_FileAlignment(UInt32 value);
    public List`1<IGenericMethodInstanceReference> get_GenericMethodInstances();
    public void set_GenericMethodInstances(List`1<IGenericMethodInstanceReference> value);
    public sealed virtual bool get_ILOnly();
    public void set_ILOnly(bool value);
    public sealed virtual bool get_StrongNameSigned();
    public void set_StrongNameSigned(bool value);
    public List`1<ITypeReference> get_StructuralTypeInstances();
    public void set_StructuralTypeInstances(List`1<ITypeReference> value);
    public List`1<ITypeMemberReference> get_StructuralTypeInstanceMembers();
    public void set_StructuralTypeInstanceMembers(List`1<ITypeMemberReference> value);
    public sealed virtual bool get_Prefers32bits();
    public void set_Prefers32bits(bool value);
    public sealed virtual ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public sealed virtual byte get_LinkerMajorVersion();
    public void set_LinkerMajorVersion(byte value);
    public sealed virtual byte get_LinkerMinorVersion();
    public void set_LinkerMinorVersion(byte value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public sealed virtual byte get_MetadataFormatMajorVersion();
    public void set_MetadataFormatMajorVersion(byte value);
    public sealed virtual byte get_MetadataFormatMinorVersion();
    public void set_MetadataFormatMinorVersion(byte value);
    public List`1<ICustomAttribute> get_ModuleAttributes();
    public void set_ModuleAttributes(List`1<ICustomAttribute> value);
    public virtual IName get_ModuleName();
    public virtual void set_ModuleName(IName value);
    public List`1<IModuleReference> get_ModuleReferences();
    public void set_ModuleReferences(List`1<IModuleReference> value);
    public virtual IName get_Name();
    public virtual void set_Name(IName value);
    public sealed virtual Guid get_PersistentIdentifier();
    public void set_PersistentIdentifier(Guid value);
    public sealed virtual Machine get_Machine();
    public void set_Machine(Machine value);
    public sealed virtual bool get_RequiresAmdInstructionSet();
    public void set_RequiresAmdInstructionSet(bool value);
    public sealed virtual bool get_RequiresStartupStub();
    public void set_RequiresStartupStub(bool value);
    public sealed virtual bool get_Requires32bits();
    public void set_Requires32bits(bool value);
    public sealed virtual bool get_Requires64bits();
    public void set_Requires64bits(bool value);
    public sealed virtual ulong get_SizeOfHeapCommit();
    public void set_SizeOfHeapCommit(ulong value);
    public sealed virtual ulong get_SizeOfHeapReserve();
    public void set_SizeOfHeapReserve(ulong value);
    public sealed virtual ulong get_SizeOfStackCommit();
    public void set_SizeOfStackCommit(ulong value);
    public sealed virtual ulong get_SizeOfStackReserve();
    public void set_SizeOfStackReserve(ulong value);
    public List`1<string> get_Strings();
    public void set_Strings(List`1<string> value);
    public sealed virtual ushort get_SubsystemMajorVersion();
    public void set_SubsystemMajorVersion(ushort value);
    public sealed virtual ushort get_SubsystemMinorVersion();
    public void set_SubsystemMinorVersion(ushort value);
    public sealed virtual string get_TargetRuntimeVersion();
    public void set_TargetRuntimeVersion(string value);
    public sealed virtual bool get_TrackDebugData();
    public void set_TrackDebugData(bool value);
    public List`1<ITypeReference> get_TypeReferences();
    public void set_TypeReferences(List`1<ITypeReference> value);
    public List`1<ITypeMemberReference> get_TypeMemberReferences();
    public void set_TypeMemberReferences(List`1<ITypeMemberReference> value);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.Module/<get_UnitReferences>d__170")]
public virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    public sealed virtual bool get_UsePublicKeyTokensForAssemblyReferences();
    public void set_UsePublicKeyTokensForAssemblyReferences(bool value);
    public List`1<IWin32Resource> get_Win32Resources();
    public void set_Win32Resources(List`1<IWin32Resource> value);
    private sealed virtual override IEnumerable`1<IAssemblyReference> Microsoft.Cci.IModule.get_AssemblyReferences();
    private sealed virtual override IEnumerable`1<string> Microsoft.Cci.IModule.GetStrings();
    private sealed virtual override IEnumerable`1<INamedTypeDefinition> Microsoft.Cci.IModule.GetAllTypes();
    private sealed virtual override IEnumerable`1<IGenericMethodInstanceReference> Microsoft.Cci.IModule.GetGenericMethodInstances();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IModule.GetStructuralTypeInstances();
    private sealed virtual override IEnumerable`1<ITypeMemberReference> Microsoft.Cci.IModule.GetStructuralTypeInstanceMembers();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.IModule.GetTypeReferences();
    private sealed virtual override IEnumerable`1<ITypeMemberReference> Microsoft.Cci.IModule.GetTypeMemberReferences();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IModule.get_ModuleAttributes();
    private sealed virtual override IEnumerable`1<IModuleReference> Microsoft.Cci.IModule.get_ModuleReferences();
    private sealed virtual override IEnumerable`1<IWin32Resource> Microsoft.Cci.IModule.get_Win32Resources();
    public virtual UnitIdentity get_UnitIdentity();
    public virtual ModuleIdentity get_ModuleIdentity();
    private sealed virtual override IAssemblyReference Microsoft.Cci.IModuleReference.get_ContainingAssembly();
    public sealed virtual IModule get_ResolvedModule();
    public virtual IUnit get_ResolvedUnit();
}
public class Microsoft.Cci.MutableCodeModel.ModuleReference : UnitReference {
    private IAssemblyReference containingAssembly;
    private IMetadataHost host;
    private ModuleIdentity moduleIdentity;
    private IUnit referringUnit;
    private IModule resolvedModule;
    public IAssemblyReference ContainingAssembly { get; public set; }
    public IMetadataHost Host { get; public set; }
    public ModuleIdentity ModuleIdentity { get; public set; }
    public IUnit ReferringUnit { get; public set; }
    public IModule ResolvedModule { get; public set; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    public sealed virtual void Copy(IModuleReference moduleReference, IInternFactory internFactory);
    public sealed virtual IAssemblyReference get_ContainingAssembly();
    public void set_ContainingAssembly(IAssemblyReference value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public IMetadataHost get_Host();
    public void set_Host(IMetadataHost value);
    public sealed virtual ModuleIdentity get_ModuleIdentity();
    public void set_ModuleIdentity(ModuleIdentity value);
    public IUnit get_ReferringUnit();
    public void set_ReferringUnit(IUnit value);
    protected virtual IModule Resolve();
    public sealed virtual IModule get_ResolvedModule();
    public void set_ResolvedModule(IModule value);
    public virtual IUnit get_ResolvedUnit();
    public virtual UnitIdentity get_UnitIdentity();
}
public class Microsoft.Cci.MutableCodeModel.Modulus : BinaryOperation {
    [CompilerGeneratedAttribute]
private bool <TreatOperandsAsUnsignedIntegers>k__BackingField;
    public bool TreatOperandsAsUnsignedIntegers { get; public set; }
    public Modulus(IModulus modulus);
    public virtual void Dispatch(ICodeVisitor visitor);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatOperandsAsUnsignedIntegers();
    [CompilerGeneratedAttribute]
public void set_TreatOperandsAsUnsignedIntegers(bool value);
}
public class Microsoft.Cci.MutableCodeModel.Multiplication : BinaryOperation {
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatOperandsAsUnsignedIntegers>k__BackingField;
    public bool CheckOverflow { get; public set; }
    public bool TreatOperandsAsUnsignedIntegers { get; public set; }
    public Multiplication(IMultiplication multiplication);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
public void set_CheckOverflow(bool value);
    public virtual void Dispatch(ICodeVisitor visitor);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatOperandsAsUnsignedIntegers();
    [CompilerGeneratedAttribute]
public void set_TreatOperandsAsUnsignedIntegers(bool value);
}
public class Microsoft.Cci.MutableCodeModel.MutableModelHelper : object {
    public static IGenericTypeInstanceReference GetGenericTypeInstanceReference(IEnumerable`1<ITypeReference> genericArgs, INamedTypeReference genericType, IInternFactory internFactory, ITypeReference original);
    public static IGenericTypeParameterReference GetGenericTypeParameterReference(ITypeReference definingType, IName name, ushort index, IInternFactory internFactory, ITypeReference original);
    public static INestedTypeReference GetNestedTypeReference(ITypeReference containingType, ushort genericParameterCount, bool mangleName, IName name, IInternFactory internFactory, ITypeReference original);
    public static INamespaceTypeReference GetNamespaceTypeReference(IUnitNamespaceReference containingUnitNamespace, ushort genericParameterCount, bool mangleName, IName name, IInternFactory internFactory, ITypeReference original);
    public static ISpecializedNestedTypeReference GetSpecializedNestedTypeReference(ITypeReference containingType, ushort genericParameterCount, bool mangleName, IName name, INestedTypeReference unspecializedVersion, IInternFactory internFactory, ITypeReference original);
    public static IPointerTypeReference GetPointerTypeReference(ITypeReference targetType, IInternFactory internFactory, ITypeReference original);
    public static IFunctionPointerTypeReference GetFunctionPointerTypeReference(CallingConvention callingConvention, IEnumerable`1<IParameterTypeInformation> parameters, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, bool returnValueIsModified, IEnumerable`1<ICustomModifier> returnValueCustomModifiers, bool returnValueIsByRef, ITypeReference type, IInternFactory internFactory, ITypeReference original);
    public static IModifiedTypeReference GetModifiedTypeReference(ITypeReference unmodifiedType, IEnumerable`1<ICustomModifier> modifiers, IInternFactory internFactory, ITypeReference original);
    public static IManagedPointerTypeReference GetManagedPointerTypeReference(ITypeReference pointeeType, IInternFactory internFactory, ITypeReference original);
}
[ObsoleteAttribute("Please use MetadataRewriter")]
public class Microsoft.Cci.MutableCodeModel.MutatingVisitor : object {
    protected bool visitImmutableNodes;
    protected IMetadataHost host;
    protected Stack path;
    protected bool stopTraversal;
    protected Dictionary`2<IReference, IReference> referenceCache;
    public MutatingVisitor(IMetadataHost host);
    public MutatingVisitor(IMetadataHost host, bool visitImmutableNodes);
    public IMethodDefinition GetCurrentMethod();
    public IUnitNamespace GetCurrentNamespace();
    public ISignature GetCurrentSignature();
    public ITypeDefinition GetCurrentType();
    public IUnit GetCurrentUnit();
    private void Visit(IEnumerable`1<ICustomAttribute> attributes);
    private void Visit(IEnumerable`1<ILocation> locations);
    private void Visit(IEnumerable`1<IMetadataExpression> metadataExpressions);
    private void Visit(IEnumerable`1<IMetadataNamedArgument> namedArguments);
    private void Visit(IEnumerable`1<IAliasForType> aliasForTypes);
    private void Visit(IEnumerable`1<ICustomModifier> modifiers);
    private void Visit(IEnumerable`1<IEventDefinition> events);
    private void Visit(IEnumerable`1<IFieldDefinition> fields);
    private void Visit(IEnumerable`1<IGenericTypeParameter> genericTypeParameters);
    private void Visit(IEnumerable`1<IFileReference> files);
    private void Visit(IEnumerable`1<IMethodDefinition> methods);
    private void Visit(IEnumerable`1<IMethodImplementation> methodImpls);
    private void Visit(IEnumerable`1<IMethodReference> methods);
    private void Visit(IEnumerable`1<IModule> modules);
    private void Visit(IEnumerable`1<INamespaceMember> members);
    private void Visit(IEnumerable`1<INestedTypeDefinition> nestedTypes);
    private void Visit(IEnumerable`1<IParameterDefinition> parameters);
    private void Visit(IEnumerable`1<IParameterTypeInformation> parameterTypes);
    private void Visit(IEnumerable`1<IPropertyDefinition> properties);
    private void Visit(IEnumerable`1<IResourceReference> resources);
    private void Visit(IEnumerable`1<ISecurityAttribute> securityAttributes);
    private void Visit(IEnumerable`1<ITypeReference> typeReferences);
    public virtual ICustomAttribute Visit(ICustomAttribute customAttribute);
    public virtual ICustomModifier Visit(ICustomModifier customModifier);
    public virtual List`1<IAliasForType> Mutate(List`1<IAliasForType> aliasesForTypes);
    public virtual INamespaceAliasForType Visit(INamespaceAliasForType namespaceAliasForType);
    public virtual INestedAliasForType Visit(INestedAliasForType nestedAliasForType);
    public virtual IAliasForType Visit(IAliasForType aliasForType);
    public virtual IAssembly Visit(IAssembly assembly);
    public virtual Assembly Mutate(Assembly assembly);
    public virtual List`1<IAssemblyReference> Mutate(List`1<IAssemblyReference> assemblyReferences);
    public virtual IAssemblyReference Visit(IAssemblyReference assemblyReference);
    public virtual IAssemblyReference Mutate(IAssemblyReference assemblyReference);
    public virtual List`1<ICustomAttribute> Mutate(List`1<ICustomAttribute> customAttributes);
    public virtual CustomAttribute Mutate(CustomAttribute customAttribute);
    public virtual List`1<ICustomModifier> Mutate(List`1<ICustomModifier> customModifiers);
    public virtual CustomModifier Mutate(CustomModifier customModifier);
    public virtual List`1<IEventDefinition> Mutate(List`1<IEventDefinition> eventDefinitions);
    public virtual IEventDefinition Visit(IEventDefinition eventDefinition);
    public virtual EventDefinition Mutate(EventDefinition eventDefinition);
    public virtual List`1<IFieldDefinition> Mutate(List`1<IFieldDefinition> fieldDefinitions);
    public virtual FieldDefinition Mutate(FieldDefinition fieldDefinition);
    public virtual IFieldDefinition Visit(IFieldDefinition fieldDefinition);
    public virtual IFieldReference Visit(IFieldReference fieldReference);
    public virtual FieldReference Mutate(FieldReference fieldReference);
    public virtual List`1<IFileReference> Mutate(List`1<IFileReference> fileReferences);
    public virtual IFileReference Visit(IFileReference fileReference);
    public virtual IGenericMethodInstanceReference Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual GenericMethodInstanceReference Mutate(GenericMethodInstanceReference genericMethodInstanceReference);
    public virtual List`1<IGenericMethodParameter> Mutate(List`1<IGenericMethodParameter> genericMethodParameters);
    public virtual IGenericMethodParameter Visit(IGenericMethodParameter genericMethodParameter);
    public virtual GenericMethodParameter Mutate(GenericMethodParameter genericMethodParameter);
    public virtual GlobalFieldDefinition Mutate(GlobalFieldDefinition globalFieldDefinition);
    public virtual GlobalMethodDefinition Mutate(GlobalMethodDefinition globalMethodDefinition);
    public virtual GenericParameter VisitGenericParameter(GenericParameter genericParameter);
    public virtual List`1<IGenericTypeParameter> Mutate(List`1<IGenericTypeParameter> genericTypeParameters);
    public virtual IGenericTypeParameter Visit(IGenericTypeParameter genericTypeParameter);
    public virtual GenericTypeParameter Mutate(GenericTypeParameter genericTypeParameter);
    public virtual List`1<ILocation> Mutate(List`1<ILocation> locations);
    public virtual ILocation Visit(ILocation location);
    public virtual ILocalDefinition Visit(ILocalDefinition localDefinition);
    public virtual LocalDefinition Mutate(LocalDefinition localDefinition);
    public virtual ILocalDefinition VisitReferenceTo(ILocalDefinition localDefinition);
    public virtual IMarshallingInformation Visit(IMarshallingInformation marshallingInformation);
    public virtual MarshallingInformation Mutate(MarshallingInformation marshallingInformation);
    public virtual MetadataConstant Mutate(MetadataConstant constant);
    public virtual MetadataCreateArray Mutate(MetadataCreateArray createArray);
    public virtual List`1<IMetadataExpression> Mutate(List`1<IMetadataExpression> metadataExpressions);
    public virtual IMetadataConstant Visit(IMetadataConstant constant);
    public virtual IMetadataCreateArray Visit(IMetadataCreateArray createArray);
    public virtual IMetadataTypeOf Visit(IMetadataTypeOf typeOf);
    public virtual IMetadataNamedArgument Visit(IMetadataNamedArgument namedArgument);
    public virtual IMetadataExpression Dispatch(IMetadataExpression expression);
    public virtual List`1<IMetadataNamedArgument> Mutate(List`1<IMetadataNamedArgument> namedArguments);
    public virtual MetadataNamedArgument Mutate(MetadataNamedArgument namedArgument);
    public virtual MetadataTypeOf Mutate(MetadataTypeOf typeOf);
    public virtual MethodBody Mutate(MethodBody methodBody);
    public virtual List`1<IOperationExceptionInformation> Mutate(List`1<IOperationExceptionInformation> exceptionInformations);
    public virtual IOperationExceptionInformation Visit(IOperationExceptionInformation operationExceptionInformation);
    public virtual OperationExceptionInformation Mutate(OperationExceptionInformation operationExceptionInformation);
    public virtual List`1<IOperation> Mutate(List`1<IOperation> operations);
    public virtual IOperation Visit(IOperation operation);
    public virtual Operation Mutate(Operation operation);
    public virtual List`1<ILocalDefinition> Mutate(List`1<ILocalDefinition> locals);
    public virtual List`1<IMethodDefinition> Mutate(List`1<IMethodDefinition> methodDefinitions);
    public virtual IGlobalFieldDefinition Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual IGlobalMethodDefinition Visit(IGlobalMethodDefinition globalMethodDefinition);
    public virtual IMethodDefinition Visit(IMethodDefinition methodDefinition);
    public virtual MethodDefinition Mutate(MethodDefinition methodDefinition);
    public virtual List`1<IMethodImplementation> Mutate(List`1<IMethodImplementation> methodImplementations);
    public virtual IMethodImplementation Visit(IMethodImplementation methodImplementation);
    public virtual MethodImplementation Mutate(MethodImplementation methodImplementation);
    public virtual List`1<IMethodReference> Mutate(List`1<IMethodReference> methodReferences);
    public virtual IMethodBody Visit(IMethodBody methodBody);
    public virtual IMethodReference Visit(IMethodReference methodReference);
    public virtual MethodReference Mutate(MethodReference methodReference);
    public virtual List`1<IModule> Mutate(List`1<IModule> modules);
    public virtual IModule Visit(IModule module);
    public virtual Module Mutate(Module module);
    public virtual List`1<IModuleReference> Mutate(List`1<IModuleReference> moduleReferences);
    public virtual ModuleReference Mutate(ModuleReference moduleReference);
    public virtual List`1<INamespaceMember> Mutate(List`1<INamespaceMember> namespaceMembers);
    public INamespaceMember Dispatch(INamespaceMember namespaceMember);
    public virtual NamespaceAliasForType Mutate(NamespaceAliasForType namespaceAliasForType);
    public virtual NamespaceTypeDefinition Mutate(NamespaceTypeDefinition namespaceTypeDefinition);
    public virtual NestedAliasForType Mutate(NestedAliasForType nestedAliasForType);
    public virtual List`1<INestedTypeDefinition> Mutate(List`1<INestedTypeDefinition> nestedTypeDefinitions);
    public virtual NestedTypeDefinition Mutate(NestedTypeDefinition nestedTypeDefinition);
    public virtual NestedTypeReference VisitNestedTypeReference(NestedTypeReference nestedTypeReference);
    public virtual ISpecializedFieldReference Visit(ISpecializedFieldReference specializedFieldReference);
    public virtual SpecializedFieldReference Mutate(SpecializedFieldReference specializedFieldReference);
    public virtual ISpecializedMethodReference Visit(ISpecializedMethodReference specializedMethodReference);
    public virtual SpecializedMethodReference Mutate(SpecializedMethodReference specializedMethodReference);
    public virtual ISpecializedNestedTypeReference Visit(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual ISpecializedNestedTypeReference Mutate(ISpecializedNestedTypeReference specializedNestedTypeReference);
    private INestedTypeReference SubstituteNestedTypeReference(INestedTypeReference nestedTypeReference);
    public virtual SpecializedNestedTypeReference Visit(SpecializedNestedTypeReference specializedNestedTypeReference);
    protected virtual void VisitTypeDefinition(NamedTypeDefinition typeDefinition);
    public virtual void VisitPrivateHelperMembers(List`1<INamedTypeDefinition> typeDefinitions);
    public virtual List`1<IPESection> Mutate(List`1<IPESection> peSections);
    public virtual List`1<ITypeDefinitionMember> Mutate(List`1<ITypeDefinitionMember> typeDefinitionMembers);
    public ITypeDefinitionMember Dispatch(ITypeDefinitionMember typeDefinitionMember);
    public ITypeDefinitionMember VisitITypeDefinitionMember(ITypeDefinitionMember typeDefinitionMember);
    public virtual List`1<ITypeReference> Mutate(List`1<ITypeReference> typeReferences);
    public virtual INamespaceMember Visit(INamespaceMember namespaceMember);
    public virtual INamespaceTypeReference Visit(INamespaceTypeReference namespaceTypeReference);
    public virtual INamespaceTypeReference Mutate(INamespaceTypeReference namespaceTypeReference);
    public virtual INestedTypeReference Visit(INestedTypeReference nestedTypeReference);
    public virtual INestedTypeReference Mutate(INestedTypeReference nestedTypeReference);
    public virtual IGenericMethodParameterReference Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual GenericMethodParameterReference Mutate(GenericMethodParameterReference genericMethodParameterReference);
    private IMethodReference GetTypeSpecificReferenceCopy(IMethodReference methodReference);
    public virtual IArrayTypeReference Visit(IArrayTypeReference arrayTypeReference);
    public virtual IArrayTypeReference Mutate(VectorTypeReference vectorType);
    public virtual IArrayTypeReference Mutate(MatrixTypeReference matrixType);
    public virtual IGenericTypeParameterReference Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual IGenericTypeParameterReference Mutate(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual IGenericTypeInstanceReference Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual IGenericTypeInstanceReference Mutate(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual IEnumerable`1<ITypeReference> Mutate(IEnumerable`1<ITypeReference> types);
    public virtual IPointerTypeReference Visit(IPointerTypeReference pointerTypeReference);
    public virtual IPointerTypeReference Mutate(IPointerTypeReference pointerTypeReference);
    public virtual IFunctionPointerTypeReference Visit(IFunctionPointerTypeReference functionPointerTypeReference);
    public IEnumerable`1<ICustomModifier> Mutate(IEnumerable`1<ICustomModifier> modifiers);
    public virtual IFunctionPointerTypeReference Mutate(IFunctionPointerTypeReference functionPointerTypeReference);
    public virtual IEnumerable`1<IParameterTypeInformation> Mutate(IEnumerable`1<IParameterTypeInformation> parameters);
    public virtual IManagedPointerTypeReference Visit(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual IManagedPointerTypeReference Mutate(IManagedPointerTypeReference managedPointerTypeReference);
    public virtual IModifiedTypeReference Visit(IModifiedTypeReference modifiedTypeReference);
    public virtual IModifiedTypeReference Mutate(IModifiedTypeReference modifiedTypeReference);
    public virtual IModuleReference Visit(IModuleReference moduleReference);
    public virtual INamespaceTypeDefinition Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual INestedTypeDefinition Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual ITypeReference Visit(ITypeReference typeReference);
    public virtual IUnitNamespaceReference Visit(IUnitNamespaceReference unitNamespaceReference);
    public virtual INestedUnitNamespace Visit(INestedUnitNamespace nestedUnitNamespace);
    public virtual INestedUnitNamespaceReference Visit(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual INestedUnitNamespaceReference Mutate(INestedUnitNamespaceReference nestedUnitNamespaceReference);
    public virtual NestedUnitNamespace Mutate(NestedUnitNamespace nestedUnitNamespace);
    public virtual IUnitReference Visit(IUnitReference unitReference);
    public virtual List`1<IParameterDefinition> Mutate(List`1<IParameterDefinition> parameterDefinitions);
    public virtual IParameterDefinition Visit(IParameterDefinition parameterDefinition);
    public virtual ParameterDefinition Mutate(ParameterDefinition parameterDefinition);
    public virtual IParameterDefinition VisitReferenceTo(IParameterDefinition parameterDefinition);
    public virtual List`1<IParameterTypeInformation> Mutate(List`1<IParameterTypeInformation> parameterTypeInformationList);
    public virtual IParameterTypeInformation Visit(IParameterTypeInformation parameterTypeInformation);
    public virtual ParameterTypeInformation Mutate(ParameterTypeInformation parameterTypeInformation);
    public virtual IPESection Visit(IPESection peSection);
    public virtual PESection Mutate(PESection peSection);
    public virtual IPlatformInvokeInformation Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual PlatformInvokeInformation Mutate(PlatformInvokeInformation platformInvokeInformation);
    public virtual List`1<IPropertyDefinition> Mutate(List`1<IPropertyDefinition> propertyDefinitions);
    public virtual IPropertyDefinition Visit(IPropertyDefinition propertyDefinition);
    public virtual PropertyDefinition Mutate(PropertyDefinition propertyDefinition);
    public virtual List`1<IResourceReference> Mutate(List`1<IResourceReference> resourceReferences);
    public virtual IResourceReference Visit(IResourceReference resourceReference);
    public virtual ResourceReference Mutate(ResourceReference resourceReference);
    public virtual List`1<ISecurityAttribute> Mutate(List`1<ISecurityAttribute> securityAttributes);
    public virtual IRootUnitNamespaceReference Visit(IRootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual IRootUnitNamespace Visit(IRootUnitNamespace rootUnitNamespace);
    public virtual RootUnitNamespace Mutate(RootUnitNamespace rootUnitNamespace);
    public virtual RootUnitNamespaceReference Mutate(RootUnitNamespaceReference rootUnitNamespaceReference);
    public virtual ISecurityAttribute Visit(ISecurityAttribute securityAttribute);
    public virtual SecurityAttribute Mutate(SecurityAttribute securityAttribute);
    public virtual ISectionBlock Visit(ISectionBlock sectionBlock);
    public virtual TypeDefinitionMember VisitTypeDefinitionMember(TypeDefinitionMember typeDefinitionMember);
    public virtual TypeReference VisitTypeReference(TypeReference typeReference);
    public virtual void VisitTypeReference(ITypeReference typeReference);
    public virtual Unit Mutate(Unit unit);
    public virtual UnitNamespace Mutate(UnitNamespace unitNamespace);
    public virtual UnitNamespaceReference VisitUnitNamespaceReference(UnitNamespaceReference unitNamespaceReference);
    public virtual List`1<IWin32Resource> Mutate(List`1<IWin32Resource> win32Resources);
    public virtual IWin32Resource Visit(IWin32Resource win32Resource);
    public virtual List`1<ICustomAttribute> VisitMethodReturnValueAttributes(List`1<ICustomAttribute> customAttributes);
    public virtual List`1<ICustomModifier> VisitMethodReturnValueCustomModifiers(List`1<ICustomModifier> customModifers);
    public virtual IMarshallingInformation VisitMethodReturnValueMarshallingInformation(MarshallingInformation marshallingInformation);
    private FieldReference GetReferenceCopy(IFieldReference fieldReference);
    private MethodReference GetReferenceCopy(IMethodReference methodReference);
    private RootUnitNamespaceReference GetReferenceCopy(IRootUnitNamespaceReference rootUnitNamespaceReference);
    private SpecializedFieldReference GetReferenceCopy(ISpecializedFieldReference specializedFieldReference);
    private SpecializedMethodReference GetReferenceCopy(ISpecializedMethodReference specializedMethodReference);
    private GenericMethodInstanceReference GetReferenceCopy(IGenericMethodInstanceReference genericMethodInstanceReference);
}
public class Microsoft.Cci.MutableCodeModel.NamedArgument : Expression {
    private IName argumentName;
    private IExpression argumentValue;
    private object resolvedDefinition;
    private bool getterIsVirtual;
    private bool setterIsVirtual;
    public IName ArgumentName { get; public set; }
    public IExpression ArgumentValue { get; public set; }
    public object ResolvedDefinition { get; public set; }
    public bool GetterIsVirtual { get; public set; }
    public bool SetterIsVirtual { get; public set; }
    private IMetadataExpression Microsoft.Cci.IMetadataNamedArgument.ArgumentValue { get; }
    private bool Microsoft.Cci.IMetadataNamedArgument.IsField { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public NamedArgument(INamedArgument namedArgument);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IName get_ArgumentName();
    public void set_ArgumentName(IName value);
    public sealed virtual IExpression get_ArgumentValue();
    public void set_ArgumentValue(IExpression value);
    public sealed virtual object get_ResolvedDefinition();
    public void set_ResolvedDefinition(object value);
    public sealed virtual bool get_GetterIsVirtual();
    public void set_GetterIsVirtual(bool value);
    public sealed virtual bool get_SetterIsVirtual();
    public void set_SetterIsVirtual(bool value);
    private sealed virtual override IMetadataExpression Microsoft.Cci.IMetadataNamedArgument.get_ArgumentValue();
    private sealed virtual override bool Microsoft.Cci.IMetadataNamedArgument.get_IsField();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(IMetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
public abstract class Microsoft.Cci.MutableCodeModel.NamedTypeDefinition : object {
    private ushort alignment;
    private List`1<ICustomAttribute> attributes;
    private List`1<ITypeReference> baseClasses;
    private List`1<IEventDefinition> events;
    private List`1<IMethodImplementation> explicitImplementationOverrides;
    private List`1<IFieldDefinition> fields;
    internal Flags flags;
    private List`1<IGenericTypeParameter> genericParameters;
    private IGenericTypeInstanceReference instanceType;
    private List`1<ITypeReference> interfaces;
    private LayoutKind layout;
    private List`1<ILocation> locations;
    private List`1<IMethodDefinition> methods;
    private IName name;
    private List`1<INestedTypeDefinition> nestedTypes;
    private IPlatformType platformType;
    private List`1<ITypeDefinitionMember> privateHelperMembers;
    private ITypeDefinition template;
    private List`1<IPropertyDefinition> properties;
    private List`1<ISecurityAttribute> securityAttributes;
    private UInt32 sizeOf;
    private StringFormatKind stringFormat;
    private PrimitiveTypeCode typeCode;
    private ITypeReference underlyingType;
    private UInt32 internedKey;
    private IInternFactory internFactory;
    public ushort Alignment { get; public set; }
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public List`1<ITypeReference> BaseClasses { get; public set; }
    public List`1<IEventDefinition> Events { get; public set; }
    public List`1<IMethodImplementation> ExplicitImplementationOverrides { get; public set; }
    public List`1<IFieldDefinition> Fields { get; public set; }
    public List`1<IGenericTypeParameter> GenericParameters { get; public set; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; public set; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public List`1<ITypeReference> Interfaces { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsDelegate { get; public set; }
    public bool IsEnum { get; public set; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; public set; }
    public bool IsReferenceType { get; }
    public bool IsSealed { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsValueType { get; public set; }
    public bool IsRuntimeSpecial { get; public set; }
    public bool IsStruct { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsComObject { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public LayoutKind Layout { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public bool MangleName { get; public set; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public List`1<IMethodDefinition> Methods { get; public set; }
    public IName Name { get; public set; }
    public List`1<INestedTypeDefinition> NestedTypes { get; public set; }
    public IPlatformType PlatformType { get; public set; }
    public List`1<ITypeDefinitionMember> PrivateHelperMembers { get; public set; }
    public List`1<IPropertyDefinition> Properties { get; public set; }
    public List`1<ISecurityAttribute> SecurityAttributes { get; public set; }
    public UInt32 SizeOf { get; public set; }
    public StringFormatKind StringFormat { get; public set; }
    public PrimitiveTypeCode TypeCode { get; public set; }
    public ITypeReference UnderlyingType { get; public set; }
    private IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.GenericParameters { get; }
    private IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.BaseClasses { get; }
    private IEnumerable`1<IEventDefinition> Microsoft.Cci.ITypeDefinition.Events { get; }
    private IEnumerable`1<IMethodImplementation> Microsoft.Cci.ITypeDefinition.ExplicitImplementationOverrides { get; }
    private IEnumerable`1<IFieldDefinition> Microsoft.Cci.ITypeDefinition.Fields { get; }
    private IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.Interfaces { get; }
    private IEnumerable`1<IMethodDefinition> Microsoft.Cci.ITypeDefinition.Methods { get; }
    private IEnumerable`1<INestedTypeDefinition> Microsoft.Cci.ITypeDefinition.NestedTypes { get; }
    private IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.ITypeDefinition.PrivateHelperMembers { get; }
    private IEnumerable`1<IPropertyDefinition> Microsoft.Cci.ITypeDefinition.Properties { get; }
    private IEnumerable`1<ISecurityAttribute> Microsoft.Cci.ITypeDefinition.SecurityAttributes { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public bool IsAlias { get; }
    public IAliasForType AliasForType { get; }
    public INamedTypeDefinition ResolvedType { get; }
    public UInt32 InternedKey { get; }
    private ITypeDefinition Microsoft.Cci.ITypeReference.ResolvedType { get; }
    public IInternFactory InternFactory { get; public set; }
    public sealed virtual void Copy(INamedTypeDefinition typeDefinition, IInternFactory internFactory);
    public virtual ushort get_Alignment();
    public virtual void set_Alignment(ushort value);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public virtual List`1<ITypeReference> get_BaseClasses();
    public virtual void set_BaseClasses(List`1<ITypeReference> value);
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<IEventDefinition> get_Events();
    public void set_Events(List`1<IEventDefinition> value);
    public List`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public void set_ExplicitImplementationOverrides(List`1<IMethodImplementation> value);
    public List`1<IFieldDefinition> get_Fields();
    public void set_Fields(List`1<IFieldDefinition> value);
    public static ITypeDefinition SelfInstance(INamedTypeDefinition typeDefinition, IInternFactory internFactory);
    public virtual List`1<IGenericTypeParameter> get_GenericParameters();
    public virtual void set_GenericParameters(List`1<IGenericTypeParameter> value);
    public sealed virtual ushort get_GenericParameterCount();
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.NamedTypeDefinition/<GetMatchingMembersNamed>d__38")]
public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.NamedTypeDefinition/<GetMatchingMembers>d__39")]
public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.NamedTypeDefinition/<GetMembersNamed>d__40")]
public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    private int FindMethod(IName name, bool ignoreCase, int index);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.NamedTypeDefinition/<GetAllMethods>d__42")]
internal IEnumerable`1<IMethodDefinition> GetAllMethods(IName name, bool ignoreCase, int start);
    internal IEnumerable`1<IMethodDefinition> GetMethodsNamed(IName name, bool ignoreCase);
    public sealed virtual bool get_HasDeclarativeSecurity();
    public void set_HasDeclarativeSecurity(bool value);
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    protected INamedTypeReference GetSpecializedType(INamedTypeDefinition typeDef);
    public virtual List`1<ITypeReference> get_Interfaces();
    public virtual void set_Interfaces(List`1<ITypeReference> value);
    public sealed virtual bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsClass();
    public void set_IsClass(bool value);
    public sealed virtual bool get_IsDelegate();
    public void set_IsDelegate(bool value);
    public sealed virtual bool get_IsEnum();
    public void set_IsEnum(bool value);
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public void set_IsInterface(bool value);
    public virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsStatic();
    public void set_IsStatic(bool value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public sealed virtual bool get_IsRuntimeSpecial();
    public void set_IsRuntimeSpecial(bool value);
    public sealed virtual bool get_IsStruct();
    public void set_IsStruct(bool value);
    public sealed virtual bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsComObject();
    public void set_IsComObject(bool value);
    public sealed virtual bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public sealed virtual bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual LayoutKind get_Layout();
    public void set_Layout(LayoutKind value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual bool get_MangleName();
    public void set_MangleName(bool value);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.NamedTypeDefinition/<get_Members>d__113")]
public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public List`1<IMethodDefinition> get_Methods();
    public void set_Methods(List`1<IMethodDefinition> value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public List`1<INestedTypeDefinition> get_NestedTypes();
    public void set_NestedTypes(List`1<INestedTypeDefinition> value);
    public sealed virtual IPlatformType get_PlatformType();
    public void set_PlatformType(IPlatformType value);
    public List`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public void set_PrivateHelperMembers(List`1<ITypeDefinitionMember> value);
    public List`1<IPropertyDefinition> get_Properties();
    public void set_Properties(List`1<IPropertyDefinition> value);
    public List`1<ISecurityAttribute> get_SecurityAttributes();
    public void set_SecurityAttributes(List`1<ISecurityAttribute> value);
    public virtual UInt32 get_SizeOf();
    public virtual void set_SizeOf(UInt32 value);
    public sealed virtual StringFormatKind get_StringFormat();
    public void set_StringFormat(StringFormatKind value);
    public virtual string ToString();
    public virtual PrimitiveTypeCode get_TypeCode();
    public virtual void set_TypeCode(PrimitiveTypeCode value);
    public sealed virtual ITypeReference get_UnderlyingType();
    public void set_UnderlyingType(ITypeReference value);
    private sealed virtual override IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.get_GenericParameters();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.get_BaseClasses();
    private sealed virtual override IEnumerable`1<IEventDefinition> Microsoft.Cci.ITypeDefinition.get_Events();
    private sealed virtual override IEnumerable`1<IMethodImplementation> Microsoft.Cci.ITypeDefinition.get_ExplicitImplementationOverrides();
    private sealed virtual override IEnumerable`1<IFieldDefinition> Microsoft.Cci.ITypeDefinition.get_Fields();
    private sealed virtual override IEnumerable`1<ITypeReference> Microsoft.Cci.ITypeDefinition.get_Interfaces();
    private sealed virtual override IEnumerable`1<IMethodDefinition> Microsoft.Cci.ITypeDefinition.get_Methods();
    private sealed virtual override IEnumerable`1<INestedTypeDefinition> Microsoft.Cci.ITypeDefinition.get_NestedTypes();
    private sealed virtual override IEnumerable`1<ITypeDefinitionMember> Microsoft.Cci.ITypeDefinition.get_PrivateHelperMembers();
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.NamedTypeDefinition/<EnumerateTolerantly>d__178")]
private static IEnumerable`1<ITypeDefinitionMember> EnumerateTolerantly(List`1<ITypeDefinitionMember> list);
    private sealed virtual override IEnumerable`1<IPropertyDefinition> Microsoft.Cci.ITypeDefinition.get_Properties();
    private sealed virtual override IEnumerable`1<ISecurityAttribute> Microsoft.Cci.ITypeDefinition.get_SecurityAttributes();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
    public sealed virtual bool get_IsAlias();
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual INamedTypeDefinition get_ResolvedType();
    public sealed virtual UInt32 get_InternedKey();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.get_ResolvedType();
    public IInternFactory get_InternFactory();
    public void set_InternFactory(IInternFactory value);
}
public class Microsoft.Cci.MutableCodeModel.NamespaceAliasForType : AliasForType {
    private INamespaceDefinition containingNamespace;
    private bool isPublic;
    private IName name;
    public INamespaceDefinition ContainingNamespace { get; public set; }
    public bool IsPublic { get; public set; }
    public IName Name { get; public set; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    public sealed virtual void Copy(INamespaceAliasForType namespaceAliasForType, IInternFactory internFactory);
    public sealed virtual INamespaceDefinition get_ContainingNamespace();
    public void set_ContainingNamespace(INamespaceDefinition value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual bool get_IsPublic();
    public void set_IsPublic(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
}
public class Microsoft.Cci.MutableCodeModel.NamespaceTypeDefinition : NamedTypeDefinition {
    private Dictionary`2<ITypeReference, IEnumerable`1<ICustomAttribute>> attributesFor;
    private IUnitNamespace containingUnitNamespace;
    public Dictionary`2<ITypeReference, IEnumerable`1<ICustomAttribute>> AttributesFor { get; public set; }
    public IUnitNamespace ContainingUnitNamespace { get; public set; }
    public bool IsPublic { get; public set; }
    public bool KeepDistinctFromDefinition { get; public set; }
    public bool IsForeignObject { get; public set; }
    private INamespaceDefinition Microsoft.Cci.INamespaceMember.ContainingNamespace { get; }
    private INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.ContainingScope { get; }
    private IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.ContainingUnitNamespace { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public sealed virtual void Copy(INamespaceTypeDefinition namespaceTypeDefinition, IInternFactory internFactory);
    public Dictionary`2<ITypeReference, IEnumerable`1<ICustomAttribute>> get_AttributesFor();
    public void set_AttributesFor(Dictionary`2<ITypeReference, IEnumerable`1<ICustomAttribute>> value);
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public void set_ContainingUnitNamespace(IUnitNamespace value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_IsPublic();
    public void set_IsPublic(bool value);
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public void set_KeepDistinctFromDefinition(bool value);
    public sealed virtual bool get_IsForeignObject();
    public void set_IsForeignObject(bool value);
    private sealed virtual override INamespaceDefinition Microsoft.Cci.INamespaceMember.get_ContainingNamespace();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IScope`1<INamespaceMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>>.get_ContainingScope();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INamespaceTypeReference.get_ContainingUnitNamespace();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.INamespaceTypeDefinition.AttributesFor(ITypeReference implementedInterface);
}
public class Microsoft.Cci.MutableCodeModel.NamespaceTypeReference : TypeReference {
    private IAliasForType aliasForType;
    private IUnitNamespaceReference containingUnitNamespace;
    private ushort genericParameterCount;
    private INamespaceTypeDefinition resolvedType;
    private bool mangleName;
    private IName name;
    private bool keepDistinctFromDefinition;
    public IAliasForType AliasForType { get; }
    public IUnitNamespaceReference ContainingUnitNamespace { get; public set; }
    public ushort GenericParameterCount { get; public set; }
    public ITypeDefinition ResolvedType { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    private INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.ResolvedType { get; }
    public bool MangleName { get; public set; }
    public IName Name { get; public set; }
    public bool KeepDistinctFromDefinition { get; public set; }
    private void ObjectInvariant();
    public sealed virtual void Copy(INamespaceTypeReference namespaceTypeReference, IInternFactory internFactory);
    public virtual IAliasForType get_AliasForType();
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public void set_ContainingUnitNamespace(IUnitNamespaceReference value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ushort get_GenericParameterCount();
    public void set_GenericParameterCount(ushort value);
    private INamespaceTypeDefinition Resolve();
    public virtual ITypeDefinition get_ResolvedType();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.INamespaceTypeReference.get_ResolvedType();
    public sealed virtual bool get_MangleName();
    public void set_MangleName(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual bool get_KeepDistinctFromDefinition();
    public void set_KeepDistinctFromDefinition(bool value);
}
public class Microsoft.Cci.MutableCodeModel.NestedAliasForType : AliasForType {
    private IAliasForType containingAlias;
    private IName name;
    private TypeMemberVisibility visibility;
    public IAliasForType ContainingAlias { get; public set; }
    public IName Name { get; public set; }
    public TypeMemberVisibility Visibility { get; public set; }
    private IScope`1<IAliasMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.IAliasMember>>.ContainingScope { get; }
    private IAliasForType Microsoft.Cci.IContainerMember<Microsoft.Cci.IAliasForType>.Container { get; }
    public sealed virtual void Copy(INestedAliasForType nestedAliasForType, IInternFactory internFactory);
    public sealed virtual IAliasForType get_ContainingAlias();
    public void set_ContainingAlias(IAliasForType value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual TypeMemberVisibility get_Visibility();
    public void set_Visibility(TypeMemberVisibility value);
    private sealed virtual override IScope`1<IAliasMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.IAliasMember>>.get_ContainingScope();
    private sealed virtual override IAliasForType Microsoft.Cci.IContainerMember<Microsoft.Cci.IAliasForType>.get_Container();
}
public class Microsoft.Cci.MutableCodeModel.NestedTypeDefinition : NamedTypeDefinition {
    private ITypeDefinition containingTypeDefinition;
    private bool doesNotInheritGenericParameters;
    public ITypeDefinition ContainingTypeDefinition { get; public set; }
    public bool DoesNotInheritGenericParameters { get; public set; }
    public TypeMemberVisibility Visibility { get; public set; }
    private ushort Microsoft.Cci.INamedTypeDefinition.GenericParameterCount { get; }
    private ushort Microsoft.Cci.INestedTypeDefinition.GenericParameterCount { get; }
    private ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Name { get; }
    private IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.ContainingScope { get; }
    private ITypeReference Microsoft.Cci.ITypeMemberReference.ContainingType { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    public sealed virtual void Copy(INestedTypeDefinition nestedTypeDefinition, IInternFactory internFactory);
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public void set_ContainingTypeDefinition(ITypeDefinition value);
    public sealed virtual bool get_DoesNotInheritGenericParameters();
    public void set_DoesNotInheritGenericParameters(bool value);
    public sealed virtual TypeMemberVisibility get_Visibility();
    public void set_Visibility(TypeMemberVisibility value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private sealed virtual override ushort Microsoft.Cci.INamedTypeDefinition.get_GenericParameterCount();
    private sealed virtual override ushort Microsoft.Cci.INestedTypeDefinition.get_GenericParameterCount();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Name();
    private sealed virtual override IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.get_ContainingScope();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.get_ContainingType();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
public class Microsoft.Cci.MutableCodeModel.NestedTypeReference : TypeReference {
    private IAliasForType aliasForType;
    private ITypeReference containingType;
    private ushort genericParameterCount;
    private bool mangleName;
    private IName name;
    private INestedTypeDefinition resolvedType;
    public IAliasForType AliasForType { get; }
    public ITypeReference ContainingType { get; public set; }
    public ushort GenericParameterCount { get; public set; }
    public bool MangleName { get; public set; }
    public IName Name { get; public set; }
    public ITypeDefinition ResolvedType { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    private INestedTypeDefinition Microsoft.Cci.INestedTypeReference.ResolvedType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(INestedTypeReference nestedTypeReference, IInternFactory internFactory);
    public virtual IAliasForType get_AliasForType();
    public sealed virtual ITypeReference get_ContainingType();
    public void set_ContainingType(ITypeReference value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual ushort get_GenericParameterCount();
    public void set_GenericParameterCount(ushort value);
    public sealed virtual bool get_MangleName();
    public void set_MangleName(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    private INestedTypeDefinition Resolve();
    public virtual ITypeDefinition get_ResolvedType();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.INestedTypeReference.get_ResolvedType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
}
public class Microsoft.Cci.MutableCodeModel.NestedUnitNamespace : UnitNamespace {
    private IUnitNamespace containingUnitNamespace;
    public IUnitNamespace ContainingUnitNamespace { get; public set; }
    private INamespaceDefinition Microsoft.Cci.INamespaceMember.ContainingNamespace { get; }
    public IScope`1<INamespaceMember> ContainingScope { get; }
    public INamespaceDefinition Container { get; }
    private IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.Name { get; }
    private IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.ContainingUnitNamespace { get; }
    private INestedUnitNamespace Microsoft.Cci.INestedUnitNamespaceReference.ResolvedNestedUnitNamespace { get; }
    public sealed virtual void Copy(INestedUnitNamespace nestedUnitNamespace, IInternFactory internFactory);
    public sealed virtual IUnitNamespace get_ContainingUnitNamespace();
    public void set_ContainingUnitNamespace(IUnitNamespace value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual IUnit GetUnit();
    private sealed virtual override INamespaceDefinition Microsoft.Cci.INamespaceMember.get_ContainingNamespace();
    public sealed virtual IScope`1<INamespaceMember> get_ContainingScope();
    public sealed virtual INamespaceDefinition get_Container();
    private sealed virtual override IName Microsoft.Cci.IContainerMember<Microsoft.Cci.INamespaceDefinition>.get_Name();
    private sealed virtual override IUnitNamespaceReference Microsoft.Cci.INestedUnitNamespaceReference.get_ContainingUnitNamespace();
    private sealed virtual override INestedUnitNamespace Microsoft.Cci.INestedUnitNamespaceReference.get_ResolvedNestedUnitNamespace();
}
public class Microsoft.Cci.MutableCodeModel.NestedUnitNamespaceReference : UnitNamespaceReference {
    private IUnitNamespaceReference containingUnitNamespace;
    private IName name;
    private INestedUnitNamespace resolvedNestedUnitNamespace;
    public IUnitNamespaceReference ContainingUnitNamespace { get; public set; }
    public IName Name { get; public set; }
    public INestedUnitNamespace ResolvedNestedUnitNamespace { get; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IUnitReference Unit { get; }
    public sealed virtual void Copy(INestedUnitNamespaceReference nestedUnitNamespaceReference, IInternFactory internFactory);
    public sealed virtual IUnitNamespaceReference get_ContainingUnitNamespace();
    public void set_ContainingUnitNamespace(IUnitNamespaceReference value);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual IUnitReference GetUnit();
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    private INestedUnitNamespace Resolve();
    public sealed virtual INestedUnitNamespace get_ResolvedNestedUnitNamespace();
    public virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IUnitReference get_Unit();
}
internal class Microsoft.Cci.MutableCodeModel.NormalizationChecker : CodeTraverser {
    internal bool foundAnonymousDelegate;
    internal bool foundYield;
    public virtual void TraverseChildren(IAnonymousDelegate anonymousDelegate);
    public virtual void TraverseChildren(IYieldBreakStatement yieldBreakStatement);
    public virtual void TraverseChildren(IYieldReturnStatement yieldReturnStatement);
}
public class Microsoft.Cci.MutableCodeModel.NotEquality : BinaryOperation {
    public NotEquality(INotEquality notEquality);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.OldValue : Expression {
    private IExpression expression;
    public IExpression Expression { get; public set; }
    public OldValue(IOldValue oldValue);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Expression();
    public void set_Expression(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.OnesComplement : UnaryOperation {
    public OnesComplement(IOnesComplement onesComplement);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.Operation : object {
    private ILocation location;
    private UInt32 offset;
    private OperationCode operationCode;
    private object value;
    private MethodBodyDocument document;
    public ILocation Location { get; public set; }
    public UInt32 Offset { get; public set; }
    public OperationCode OperationCode { get; public set; }
    public object Value { get; public set; }
    public IMethodDefinition MethodDefinition { get; }
    private UInt32 Microsoft.Cci.IILLocation.Offset { get; }
    public IDocument Document { get; }
    internal Operation(MethodBodyDocument doc, UInt32 offset, OperationCode opCode, object value);
    public sealed virtual void Copy(IOperation operation, IInternFactory internFactory);
    public sealed virtual ILocation get_Location();
    public void set_Location(ILocation value);
    public sealed virtual UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public sealed virtual OperationCode get_OperationCode();
    public void set_OperationCode(OperationCode value);
    public sealed virtual object get_Value();
    public void set_Value(object value);
    public sealed virtual IMethodDefinition get_MethodDefinition();
    private sealed virtual override UInt32 Microsoft.Cci.IILLocation.get_Offset();
    public sealed virtual IDocument get_Document();
}
public class Microsoft.Cci.MutableCodeModel.OperationExceptionInformation : object {
    private ITypeReference exceptionType;
    private UInt32 filterDecisionStartOffset;
    private UInt32 handlerEndOffset;
    private HandlerKind handlerKind;
    private UInt32 handlerStartOffset;
    private UInt32 tryEndOffset;
    private UInt32 tryStartOffset;
    public ITypeReference ExceptionType { get; public set; }
    public UInt32 FilterDecisionStartOffset { get; public set; }
    public UInt32 HandlerEndOffset { get; public set; }
    public HandlerKind HandlerKind { get; public set; }
    public UInt32 HandlerStartOffset { get; public set; }
    public UInt32 TryEndOffset { get; public set; }
    public UInt32 TryStartOffset { get; public set; }
    public sealed virtual void Copy(IOperationExceptionInformation operationExceptionInformation, IInternFactory internFactory);
    public sealed virtual ITypeReference get_ExceptionType();
    public void set_ExceptionType(ITypeReference value);
    public sealed virtual UInt32 get_FilterDecisionStartOffset();
    public void set_FilterDecisionStartOffset(UInt32 value);
    public sealed virtual UInt32 get_HandlerEndOffset();
    public void set_HandlerEndOffset(UInt32 value);
    public sealed virtual HandlerKind get_HandlerKind();
    public void set_HandlerKind(HandlerKind value);
    public sealed virtual UInt32 get_HandlerStartOffset();
    public void set_HandlerStartOffset(UInt32 value);
    public sealed virtual UInt32 get_TryEndOffset();
    public void set_TryEndOffset(UInt32 value);
    public sealed virtual UInt32 get_TryStartOffset();
    public void set_TryStartOffset(UInt32 value);
}
public class Microsoft.Cci.MutableCodeModel.OutArgument : Expression {
    private ITargetExpression expression;
    public ITargetExpression Expression { get; public set; }
    public OutArgument(IOutArgument outArgument);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITargetExpression get_Expression();
    public void set_Expression(ITargetExpression value);
}
public class Microsoft.Cci.MutableCodeModel.ParameterDefinition : object {
    private List`1<ICustomAttribute> attributes;
    private ISignature containingSignature;
    private List`1<ICustomModifier> customModifiers;
    private IMetadataConstant defaultValue;
    private int flags;
    private ushort index;
    private List`1<ILocation> locations;
    private IMarshallingInformation marshallingInformation;
    private ITypeReference paramArrayElementType;
    private IName name;
    private ITypeReference type;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public ISignature ContainingSignature { get; public set; }
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public IMetadataConstant DefaultValue { get; public set; }
    public bool HasDefaultValue { get; }
    public ushort Index { get; public set; }
    public bool IsByReference { get; public set; }
    public bool IsIn { get; public set; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsModified { get; }
    public bool IsOptional { get; public set; }
    public bool IsOut { get; public set; }
    public bool IsParameterArray { get; }
    public List`1<ILocation> Locations { get; public set; }
    public IMarshallingInformation MarshallingInformation { get; public set; }
    public ITypeReference ParamArrayElementType { get; public set; }
    public IName Name { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.CustomModifiers { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    public sealed virtual void Copy(IParameterDefinition parameterDefinition, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual ISignature get_ContainingSignature();
    public void set_ContainingSignature(ISignature value);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual IMetadataConstant get_DefaultValue();
    public void set_DefaultValue(IMetadataConstant value);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual ushort get_Index();
    public void set_Index(ushort value);
    public sealed virtual bool get_IsByReference();
    public void set_IsByReference(bool value);
    public sealed virtual bool get_IsIn();
    public void set_IsIn(bool value);
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsOptional();
    public void set_IsOptional(bool value);
    public sealed virtual bool get_IsOut();
    public void set_IsOut(bool value);
    public sealed virtual bool get_IsParameterArray();
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public void set_MarshallingInformation(IMarshallingInformation value);
    public sealed virtual ITypeReference get_ParamArrayElementType();
    public void set_ParamArrayElementType(ITypeReference value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.get_CustomModifiers();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
    public virtual string ToString();
}
public class Microsoft.Cci.MutableCodeModel.ParameterTypeInformation : object {
    private ISignature containingSignature;
    private List`1<ICustomModifier> customModifiers;
    private ushort index;
    private bool isByReference;
    private ITypeReference type;
    public ISignature ContainingSignature { get; public set; }
    public List`1<ICustomModifier> CustomModifiers { get; public set; }
    public ushort Index { get; public set; }
    public bool IsByReference { get; public set; }
    public bool IsModified { get; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.CustomModifiers { get; }
    public sealed virtual void Copy(IParameterTypeInformation parameterTypeInformation, IInternFactory internFactory);
    public sealed virtual ISignature get_ContainingSignature();
    public void set_ContainingSignature(ISignature value);
    public List`1<ICustomModifier> get_CustomModifiers();
    public void set_CustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual ushort get_Index();
    public void set_Index(ushort value);
    public sealed virtual bool get_IsByReference();
    public void set_IsByReference(bool value);
    public sealed virtual bool get_IsModified();
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.get_CustomModifiers();
}
public class Microsoft.Cci.MutableCodeModel.PESection : object {
    private IName sectionName;
    private PESectionCharacteristics characteristics;
    private int virtualAddress;
    private int virtualSize;
    private int sizeOfRawData;
    private List`1<byte> rawdata;
    public IName SectionName { get; public set; }
    public PESectionCharacteristics Characteristics { get; public set; }
    public int VirtualAddress { get; public set; }
    public int VirtualSize { get; public set; }
    public int SizeOfRawData { get; public set; }
    public List`1<byte> Rawdata { get; public set; }
    private IEnumerable`1<byte> Microsoft.Cci.IPESection.Rawdata { get; }
    public void Copy(IPESection peSection, IInternFactory internFactory);
    public sealed virtual IName get_SectionName();
    public void set_SectionName(IName value);
    public sealed virtual PESectionCharacteristics get_Characteristics();
    public void set_Characteristics(PESectionCharacteristics value);
    public sealed virtual int get_VirtualAddress();
    public void set_VirtualAddress(int value);
    public sealed virtual int get_VirtualSize();
    public void set_VirtualSize(int value);
    public sealed virtual int get_SizeOfRawData();
    public void set_SizeOfRawData(int value);
    public List`1<byte> get_Rawdata();
    public void set_Rawdata(List`1<byte> value);
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IPESection.get_Rawdata();
}
public class Microsoft.Cci.MutableCodeModel.PlatformInvokeInformation : object {
    private IModuleReference importModule;
    private IName importName;
    private bool noMangle;
    private PInvokeCallingConvention pinvokeCallingConvention;
    private StringFormatKind stringFormat;
    private bool supportsLastError;
    private Nullable`1<bool> useBestFit;
    private Nullable`1<bool> throwExceptionForUnmappableChar;
    public IModuleReference ImportModule { get; public set; }
    public IName ImportName { get; public set; }
    public bool NoMangle { get; public set; }
    public PInvokeCallingConvention PInvokeCallingConvention { get; public set; }
    public StringFormatKind StringFormat { get; public set; }
    public bool SupportsLastError { get; public set; }
    public Nullable`1<bool> UseBestFit { get; public set; }
    public Nullable`1<bool> ThrowExceptionForUnmappableChar { get; public set; }
    public sealed virtual void Copy(IPlatformInvokeInformation platformInvokeInformation, IInternFactory internFactory);
    public sealed virtual IModuleReference get_ImportModule();
    public void set_ImportModule(IModuleReference value);
    public sealed virtual IName get_ImportName();
    public void set_ImportName(IName value);
    public sealed virtual bool get_NoMangle();
    public void set_NoMangle(bool value);
    public sealed virtual PInvokeCallingConvention get_PInvokeCallingConvention();
    public void set_PInvokeCallingConvention(PInvokeCallingConvention value);
    public sealed virtual StringFormatKind get_StringFormat();
    public void set_StringFormat(StringFormatKind value);
    public sealed virtual bool get_SupportsLastError();
    public void set_SupportsLastError(bool value);
    public sealed virtual Nullable`1<bool> get_UseBestFit();
    public void set_UseBestFit(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_ThrowExceptionForUnmappableChar();
    public void set_ThrowExceptionForUnmappableChar(Nullable`1<bool> value);
}
public class Microsoft.Cci.MutableCodeModel.PointerCall : Expression {
    internal List`1<IExpression> arguments;
    private IExpression pointer;
    private bool isTailCall;
    public List`1<IExpression> Arguments { get; public set; }
    public IExpression Pointer { get; public set; }
    public bool IsTailCall { get; public set; }
    private IEnumerable`1<IExpression> Microsoft.Cci.IPointerCall.Arguments { get; }
    public PointerCall(IPointerCall pointerCall);
    private void ObjectInvariant();
    public virtual void Dispatch(ICodeVisitor visitor);
    public List`1<IExpression> get_Arguments();
    public void set_Arguments(List`1<IExpression> value);
    public sealed virtual IExpression get_Pointer();
    public void set_Pointer(IExpression value);
    public sealed virtual bool get_IsTailCall();
    public void set_IsTailCall(bool value);
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.IPointerCall.get_Arguments();
}
public class Microsoft.Cci.MutableCodeModel.PointerTypeReference : TypeReference {
    private IPointerType resolvedType;
    private ITypeReference targetType;
    private IPointerType ResolvedPointerType { get; }
    public ITypeDefinition ResolvedType { get; }
    public ITypeReference TargetType { get; public set; }
    private void ObjectInvariant();
    public sealed virtual void Copy(IPointerTypeReference pointerTypeReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    private IPointerType get_ResolvedPointerType();
    public virtual ITypeDefinition get_ResolvedType();
    public sealed virtual ITypeReference get_TargetType();
    public void set_TargetType(ITypeReference value);
}
public class Microsoft.Cci.MutableCodeModel.PopValue : Expression {
    public PopValue(IPopValue popValue);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.PropertyDefinition : TypeDefinitionMember {
    private List`1<IMethodReference> accessors;
    private CallingConvention callingConvention;
    private IMetadataConstant defaultValue;
    private IMethodReference getter;
    private List`1<IParameterDefinition> parameters;
    private List`1<ICustomModifier> returnValueCustomModifiers;
    private IMethodReference setter;
    private ITypeReference type;
    public List`1<IMethodReference> Accessors { get; public set; }
    public CallingConvention CallingConvention { get; public set; }
    public IMetadataConstant DefaultValue { get; public set; }
    public IMethodReference Getter { get; public set; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsStatic { get; }
    public List`1<IParameterDefinition> Parameters { get; public set; }
    public List`1<ICustomModifier> ReturnValueCustomModifiers { get; public set; }
    public bool ReturnValueIsByRef { get; public set; }
    public bool ReturnValueIsModified { get; }
    public IMethodReference Setter { get; public set; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<IMethodReference> Microsoft.Cci.IPropertyDefinition.Accessors { get; }
    private IEnumerable`1<IParameterDefinition> Microsoft.Cci.IPropertyDefinition.Parameters { get; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.Constant { get; }
    public sealed virtual void Copy(IPropertyDefinition propertyDefinition, IInternFactory internFactory);
    public List`1<IMethodReference> get_Accessors();
    public void set_Accessors(List`1<IMethodReference> value);
    public sealed virtual CallingConvention get_CallingConvention();
    public void set_CallingConvention(CallingConvention value);
    public sealed virtual IMetadataConstant get_DefaultValue();
    public void set_DefaultValue(IMetadataConstant value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_Getter();
    public void set_Getter(IMethodReference value);
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual bool get_IsRuntimeSpecial();
    public void set_IsRuntimeSpecial(bool value);
    public sealed virtual bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsStatic();
    public List`1<IParameterDefinition> get_Parameters();
    public void set_Parameters(List`1<IParameterDefinition> value);
    public List`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public void set_ReturnValueCustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_ReturnValueIsByRef();
    public void set_ReturnValueIsByRef(bool value);
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual IMethodReference get_Setter();
    public void set_Setter(IMethodReference value);
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<IMethodReference> Microsoft.Cci.IPropertyDefinition.get_Accessors();
    private sealed virtual override IEnumerable`1<IParameterDefinition> Microsoft.Cci.IPropertyDefinition.get_Parameters();
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override IMetadataConstant Microsoft.Cci.IMetadataConstantContainer.get_Constant();
}
public class Microsoft.Cci.MutableCodeModel.PushStatement : Statement {
    private IExpression valueToPush;
    public IExpression ValueToPush { get; public set; }
    public PushStatement(IPushStatement pushStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_ValueToPush();
    public void set_ValueToPush(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.RefArgument : Expression {
    private IAddressableExpression expression;
    public IAddressableExpression Expression { get; public set; }
    public RefArgument(IRefArgument refArgument);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IAddressableExpression get_Expression();
    public void set_Expression(IAddressableExpression value);
}
public class Microsoft.Cci.MutableCodeModel.Resource : object {
    private List`1<ICustomAttribute> attributes;
    private List`1<byte> data;
    private IAssemblyReference definingAssembly;
    private IFileReference externalFile;
    private bool isInExternalFile;
    private bool isPublic;
    private IName name;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public List`1<byte> Data { get; public set; }
    public IAssemblyReference DefiningAssembly { get; public set; }
    public IFileReference ExternalFile { get; public set; }
    public bool IsInExternalFile { get; public set; }
    public bool IsPublic { get; public set; }
    public IName Name { get; public set; }
    private IEnumerable`1<byte> Microsoft.Cci.IResource.Data { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IResourceReference.Attributes { get; }
    private IResource Microsoft.Cci.IResourceReference.Resource { get; }
    public sealed virtual void Copy(IResource resource, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public List`1<byte> get_Data();
    public void set_Data(List`1<byte> value);
    public sealed virtual IAssemblyReference get_DefiningAssembly();
    public void set_DefiningAssembly(IAssemblyReference value);
    public sealed virtual IFileReference get_ExternalFile();
    public void set_ExternalFile(IFileReference value);
    public sealed virtual bool get_IsInExternalFile();
    public void set_IsInExternalFile(bool value);
    public sealed virtual bool get_IsPublic();
    public void set_IsPublic(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IResource.get_Data();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IResourceReference.get_Attributes();
    private sealed virtual override IResource Microsoft.Cci.IResourceReference.get_Resource();
}
public class Microsoft.Cci.MutableCodeModel.ResourceReference : object {
    private List`1<ICustomAttribute> attributes;
    private IAssemblyReference definingAssembly;
    private bool isPublic;
    private IName name;
    private IResource resource;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public IAssemblyReference DefiningAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public IName Name { get; public set; }
    public IResource Resource { get; public set; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IResourceReference.Attributes { get; }
    public sealed virtual void Copy(IResourceReference resourceReference, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual IAssemblyReference get_DefiningAssembly();
    public void set_DefiningAssembly(IAssemblyReference value);
    public sealed virtual bool get_IsPublic();
    public void set_IsPublic(bool value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public sealed virtual IResource get_Resource();
    public void set_Resource(IResource value);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IResourceReference.get_Attributes();
}
public class Microsoft.Cci.MutableCodeModel.ResourceUseStatement : Statement {
    private IStatement body;
    private IStatement resourceAcquisitions;
    public IStatement Body { get; public set; }
    public IStatement ResourceAcquisitions { get; public set; }
    public ResourceUseStatement(IResourceUseStatement resourceUseStatement);
    public sealed virtual IStatement get_Body();
    public void set_Body(IStatement value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IStatement get_ResourceAcquisitions();
    public void set_ResourceAcquisitions(IStatement value);
}
public class Microsoft.Cci.MutableCodeModel.RethrowStatement : Statement {
    public RethrowStatement(IRethrowStatement rethrowStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.ReturnStatement : Statement {
    private IExpression expression;
    public IExpression Expression { get; public set; }
    public ReturnStatement(IReturnStatement returnStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Expression();
    public void set_Expression(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.ReturnValue : Expression {
    public ReturnValue(IReturnValue returnValue);
    public virtual void Dispatch(ICodeVisitor visitor);
}
internal class Microsoft.Cci.MutableCodeModel.RewriteAsMoveNext : CodeRewriter {
    private Dictionary`2<object, BoundField> fieldForCapturedLocalOrParameter;
    private Dictionary`2<IBlockStatement, UInt32> iteratorLocalCount;
    private Dictionary`2<UInt32, IGenericTypeParameter> genericParameterMapping;
    private IteratorClosureInformation iteratorClosure;
    private BlockStatement currentBlockStatement;
    internal RewriteAsMoveNext(Dictionary`2<object, BoundField> fieldForCapturedLocalOrParameter, Dictionary`2<IBlockStatement, UInt32> iteratorLocalCount, Dictionary`2<UInt32, IGenericTypeParameter> genericParameterMapping, IteratorClosureInformation closure, IMetadataHost host);
    public virtual void RewriteChildren(AddressableExpression addressableExpression);
    public virtual void RewriteChildren(BlockStatement blockStatement);
    public virtual void RewriteChildren(BoundExpression boundExpression);
    public virtual void RewriteChildren(TargetExpression targetExpression);
    public virtual IExpression Rewrite(IThisReference thisReference);
    public virtual IStatement Rewrite(ILocalDeclarationStatement localDeclarationStatement);
    public virtual ITypeReference Rewrite(IGenericMethodParameterReference genericMethodParameterReference);
}
public class Microsoft.Cci.MutableCodeModel.RightShift : BinaryOperation {
    public RightShift(IRightShift rightShift);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.RootUnitNamespace : UnitNamespace {
    private IUnit unit;
    public IUnit Unit { get; public set; }
    public sealed virtual void Copy(IRootUnitNamespace rootUnitNamespace, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual IUnit GetUnit();
    public sealed virtual IUnit get_Unit();
    public void set_Unit(IUnit value);
}
public class Microsoft.Cci.MutableCodeModel.RootUnitNamespaceReference : UnitNamespaceReference {
    private IUnitNamespace resolvedUnitNamespace;
    private IUnitReference unit;
    public IUnitNamespace ResolvedUnitNamespace { get; }
    public IUnitReference Unit { get; public set; }
    public sealed virtual void Copy(IRootUnitNamespaceReference rootUnitNamespaceReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    internal virtual IUnitReference GetUnit();
    public virtual IUnitNamespace get_ResolvedUnitNamespace();
    public sealed virtual IUnitReference get_Unit();
    public void set_Unit(IUnitReference value);
}
public class Microsoft.Cci.MutableCodeModel.RuntimeArgumentHandleExpression : Expression {
    public RuntimeArgumentHandleExpression(IRuntimeArgumentHandleExpression runtimeArgumentHandleExpression);
    public virtual void Dispatch(ICodeVisitor visitor);
}
internal class Microsoft.Cci.MutableCodeModel.ScopesWithCapturedLocalsFinder : CodeTraverser {
    internal Dictionary`2<object, bool> scopesWithCapturedLocals;
    private Dictionary`2<object, IFieldReference> captures;
    private IBlockStatement currentBlock;
    internal ScopesWithCapturedLocalsFinder(Dictionary`2<object, IFieldReference> captures);
    private void ObjectInvariant();
    public virtual void TraverseChildren(IBlockExpression blockExpression);
    public virtual void TraverseChildren(IBlockStatement block);
    public virtual void TraverseChildren(ICatchClause catchClause);
    public virtual void TraverseChildren(IForEachStatement forEachStatement);
    public virtual void TraverseChildren(ILocalDeclarationStatement localDeclarationStatement);
}
public class Microsoft.Cci.MutableCodeModel.SectionBlock : object {
    private List`1<byte> data;
    private UInt32 offset;
    private PESectionKind peSectionKind;
    private UInt32 size;
    public List`1<byte> Data { get; public set; }
    public UInt32 Offset { get; public set; }
    public PESectionKind PESectionKind { get; public set; }
    public UInt32 Size { get; public set; }
    private IEnumerable`1<byte> Microsoft.Cci.ISectionBlock.Data { get; }
    public sealed virtual void Copy(ISectionBlock sectionBlock, IInternFactory internFactory);
    public List`1<byte> get_Data();
    public void set_Data(List`1<byte> value);
    public sealed virtual UInt32 get_Offset();
    public void set_Offset(UInt32 value);
    public sealed virtual PESectionKind get_PESectionKind();
    public void set_PESectionKind(PESectionKind value);
    public sealed virtual UInt32 get_Size();
    public void set_Size(UInt32 value);
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.ISectionBlock.get_Data();
}
public class Microsoft.Cci.MutableCodeModel.SecurityAttribute : object {
    private SecurityAction action;
    private List`1<ICustomAttribute> attributes;
    public SecurityAction Action { get; public set; }
    public List`1<ICustomAttribute> Attributes { get; public set; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.ISecurityAttribute.Attributes { get; }
    public sealed virtual void Copy(ISecurityAttribute securityAttribute, IInternFactory internFactory);
    public sealed virtual SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.ISecurityAttribute.get_Attributes();
}
public class Microsoft.Cci.MutableCodeModel.SignatureDefinition : object {
    private CallingConvention callingConvention;
    private List`1<IParameterTypeInformation> parameters;
    private List`1<ICustomModifier> returnValueCustomModifiers;
    private bool returnValueIsByRef;
    private ITypeReference type;
    public CallingConvention CallingConvention { get; public set; }
    public bool IsStatic { get; }
    public List`1<IParameterTypeInformation> Parameters { get; public set; }
    public List`1<ICustomModifier> ReturnValueCustomModifiers { get; public set; }
    public bool ReturnValueIsByRef { get; public set; }
    public bool ReturnValueIsModified { get; }
    public ITypeReference Type { get; public set; }
    private IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.Parameters { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    public sealed virtual void Copy(ISignature signatureDefinition, IInternFactory internFactory);
    public sealed virtual CallingConvention get_CallingConvention();
    public void set_CallingConvention(CallingConvention value);
    public sealed virtual bool get_IsStatic();
    public List`1<IParameterTypeInformation> get_Parameters();
    public void set_Parameters(List`1<IParameterTypeInformation> value);
    public List`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public void set_ReturnValueCustomModifiers(List`1<ICustomModifier> value);
    public sealed virtual bool get_ReturnValueIsByRef();
    public void set_ReturnValueIsByRef(bool value);
    public sealed virtual bool get_ReturnValueIsModified();
    public sealed virtual ITypeReference get_Type();
    public void set_Type(ITypeReference value);
    private sealed virtual override IEnumerable`1<IParameterTypeInformation> Microsoft.Cci.ISignature.get_Parameters();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
}
public class Microsoft.Cci.MutableCodeModel.SizeOf : Expression {
    private ITypeReference typeToSize;
    public ITypeReference TypeToSize { get; public set; }
    public SizeOf(ISizeOf sizeOf);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_TypeToSize();
    public void set_TypeToSize(ITypeReference value);
}
public class Microsoft.Cci.MutableCodeModel.SourceMethodBody : object {
    private IBlockStatement block;
    private IMetadataHost host;
    private ISourceLocationProvider sourceLocationProvider;
    private ILocalScopeProvider localScopeProvider;
    private bool ilWasGenerated;
    private bool isNormalized;
    private IDictionary`2<IBlockStatement, UInt32> iteratorLocalCount;
    private IEnumerable`1<ILocalScope> iteratorScopes;
    private IEnumerable`1<ILocalScope> localScopes;
    private bool localsAreZeroed;
    private IEnumerable`1<ILocalDefinition> localVariables;
    private ushort maxStack;
    private IMethodDefinition methodDefinition;
    private IEnumerable`1<INamespaceScope> namespaceScopes;
    private IEnumerable`1<IOperation> operations;
    private IEnumerable`1<IOperationExceptionInformation> operationExceptionInformation;
    private List`1<ITypeDefinition> privateHelperTypes;
    private bool trackExpressionSourceLocations;
    private UInt32 size;
    private ISynchronizationInformation synchronizationInformation;
    public IBlockStatement Block { get; public set; }
    public bool IsNormalized { get; public set; }
    public bool IsIterator { get; }
    public IEnumerable`1<ILocalScope> IteratorScopes { get; }
    public IEnumerable`1<ILocalScope> LocalScopes { get; }
    public bool LocalsAreZeroed { get; public set; }
    public IEnumerable`1<ILocalDefinition> LocalVariables { get; }
    public ushort MaxStack { get; }
    public IMethodDefinition MethodDefinition { get; public set; }
    public IEnumerable`1<INamespaceScope> NamespaceScopes { get; }
    public IEnumerable`1<IOperation> Operations { get; }
    public IEnumerable`1<IOperationExceptionInformation> OperationExceptionInformation { get; }
    public List`1<ITypeDefinition> PrivateHelperTypes { get; public set; }
    public ISourceLocationProvider SourceLocationProvider { get; }
    public bool TrackExpressionSourceLocations { get; public set; }
    public UInt32 Size { get; }
    public ISynchronizationInformation SynchronizationInformation { get; }
    private IEnumerable`1<ITypeDefinition> Microsoft.Cci.IMethodBody.PrivateHelperTypes { get; }
    public SourceMethodBody(IMetadataHost host, ISourceLocationProvider sourceLocationProvider, ILocalScopeProvider localScopeProvider, IDictionary`2<IBlockStatement, UInt32> iteratorLocalCount);
    public sealed virtual IBlockStatement get_Block();
    public void set_Block(IBlockStatement value);
    protected virtual IBlockStatement GetBlock();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    private void GenerateIL();
    public bool get_IsNormalized();
    public void set_IsNormalized(bool value);
    public bool get_IsIterator();
    public IEnumerable`1<ILocalScope> get_IteratorScopes();
    public IEnumerable`1<ILocalScope> get_LocalScopes();
    public sealed virtual bool get_LocalsAreZeroed();
    public void set_LocalsAreZeroed(bool value);
    public sealed virtual IEnumerable`1<ILocalDefinition> get_LocalVariables();
    public sealed virtual ushort get_MaxStack();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public void set_MethodDefinition(IMethodDefinition value);
    public IEnumerable`1<INamespaceScope> get_NamespaceScopes();
    public sealed virtual IEnumerable`1<IOperation> get_Operations();
    public sealed virtual IEnumerable`1<IOperationExceptionInformation> get_OperationExceptionInformation();
    public List`1<ITypeDefinition> get_PrivateHelperTypes();
    public void set_PrivateHelperTypes(List`1<ITypeDefinition> value);
    public ISourceLocationProvider get_SourceLocationProvider();
    public bool get_TrackExpressionSourceLocations();
    public void set_TrackExpressionSourceLocations(bool value);
    public sealed virtual UInt32 get_Size();
    public ISynchronizationInformation get_SynchronizationInformation();
    private sealed virtual override IEnumerable`1<ITypeDefinition> Microsoft.Cci.IMethodBody.get_PrivateHelperTypes();
}
public class Microsoft.Cci.MutableCodeModel.SpecializedEventDefinition : EventDefinition {
    private IEventDefinition unspecializedVersion;
    public IEventDefinition UnspecializedVersion { get; public set; }
    public sealed virtual void Copy(ISpecializedEventDefinition specializedEventDefinition, IInternFactory internFactory);
    public sealed virtual IEventDefinition get_UnspecializedVersion();
    public void set_UnspecializedVersion(IEventDefinition value);
}
public class Microsoft.Cci.MutableCodeModel.SpecializedFieldDefinition : FieldDefinition {
    private IFieldDefinition unspecializedVersion;
    public IFieldDefinition UnspecializedVersion { get; public set; }
    private IFieldReference Microsoft.Cci.ISpecializedFieldReference.UnspecializedVersion { get; }
    public sealed virtual void Copy(ISpecializedFieldDefinition specializedFieldDefinition, IInternFactory internFactory);
    public sealed virtual IFieldDefinition get_UnspecializedVersion();
    public void set_UnspecializedVersion(IFieldDefinition value);
    private sealed virtual override IFieldReference Microsoft.Cci.ISpecializedFieldReference.get_UnspecializedVersion();
}
public class Microsoft.Cci.MutableCodeModel.SpecializedFieldReference : FieldReference {
    private IFieldReference unspecializedVersion;
    public IFieldReference UnspecializedVersion { get; public set; }
    public sealed virtual void Copy(ISpecializedFieldReference specializedFieldReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IFieldReference get_UnspecializedVersion();
    public void set_UnspecializedVersion(IFieldReference value);
}
public class Microsoft.Cci.MutableCodeModel.SpecializedMethodDefinition : MethodDefinition {
    private IMethodDefinition unspecializedVersion;
    public IMethodDefinition UnspecializedVersion { get; public set; }
    private IMethodReference Microsoft.Cci.ISpecializedMethodReference.UnspecializedVersion { get; }
    public sealed virtual void Copy(ISpecializedMethodDefinition specializedMethodDefinition, IInternFactory internFactory);
    public sealed virtual IMethodDefinition get_UnspecializedVersion();
    public void set_UnspecializedVersion(IMethodDefinition value);
    private sealed virtual override IMethodReference Microsoft.Cci.ISpecializedMethodReference.get_UnspecializedVersion();
}
public class Microsoft.Cci.MutableCodeModel.SpecializedMethodReference : MethodReference {
    private IMethodReference unspecializedVersion;
    public IMethodReference UnspecializedVersion { get; public set; }
    public sealed virtual void Copy(ISpecializedMethodReference specializedMethodReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IMethodReference get_UnspecializedVersion();
    public void set_UnspecializedVersion(IMethodReference value);
}
public class Microsoft.Cci.MutableCodeModel.SpecializedNestedTypeDefinition : NestedTypeDefinition {
    private INestedTypeDefinition unspecializedVersion;
    public INestedTypeDefinition UnspecializedVersion { get; public set; }
    private INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.UnspecializedVersion { get; }
    public sealed virtual void Copy(ISpecializedNestedTypeDefinition specializedNestedTypeDefinition, IInternFactory internFactory);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INestedTypeDefinition get_UnspecializedVersion();
    public void set_UnspecializedVersion(INestedTypeDefinition value);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ISpecializedNestedTypeReference.get_UnspecializedVersion();
}
public class Microsoft.Cci.MutableCodeModel.SpecializedNestedTypeReference : NestedTypeReference {
    private INestedTypeReference unspecializedVersion;
    public INestedTypeReference UnspecializedVersion { get; public set; }
    public bool IsValueType { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(ISpecializedNestedTypeReference specializedNestedTypeReference, IInternFactory internFactory);
    public virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual INestedTypeReference get_UnspecializedVersion();
    public void set_UnspecializedVersion(INestedTypeReference value);
    public sealed virtual bool get_IsValueType();
}
public class Microsoft.Cci.MutableCodeModel.SpecializedPropertyDefinition : PropertyDefinition {
    private IPropertyDefinition unspecializedVersion;
    public IPropertyDefinition UnspecializedVersion { get; public set; }
    public sealed virtual void Copy(ISpecializedPropertyDefinition specializedPropertyDefinition, IInternFactory internFactory);
    public sealed virtual IPropertyDefinition get_UnspecializedVersion();
    public void set_UnspecializedVersion(IPropertyDefinition value);
}
public class Microsoft.Cci.MutableCodeModel.StackArrayCreate : Expression {
    private ITypeReference elementType;
    private IExpression size;
    public ITypeReference ElementType { get; public set; }
    public IExpression Size { get; public set; }
    public StackArrayCreate(IStackArrayCreate stackArrayCreate);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_ElementType();
    public void set_ElementType(ITypeReference value);
    public sealed virtual IExpression get_Size();
    public void set_Size(IExpression value);
}
public abstract class Microsoft.Cci.MutableCodeModel.Statement : object {
    private List`1<ILocation> locations;
    public List`1<ILocation> Locations { get; public set; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    protected Statement(IStatement statement);
    private void ObjectInvariant();
    public abstract virtual void Dispatch(ICodeVisitor visitor);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.Subtraction : BinaryOperation {
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TreatOperandsAsUnsignedIntegers>k__BackingField;
    public bool CheckOverflow { get; public set; }
    public bool TreatOperandsAsUnsignedIntegers { get; public set; }
    public Subtraction(ISubtraction subtraction);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
public void set_CheckOverflow(bool value);
    public virtual void Dispatch(ICodeVisitor visitor);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_TreatOperandsAsUnsignedIntegers();
    [CompilerGeneratedAttribute]
public void set_TreatOperandsAsUnsignedIntegers(bool value);
}
public class Microsoft.Cci.MutableCodeModel.SwitchCase : object {
    private List`1<IStatement> body;
    private ICompileTimeConstant expression;
    private List`1<ILocation> locations;
    public List`1<IStatement> Body { get; public set; }
    public ICompileTimeConstant Expression { get; public set; }
    public bool IsDefault { get; }
    public IList`1<ILocation> Locations { get; }
    private IEnumerable`1<IStatement> Microsoft.Cci.ISwitchCase.Body { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public SwitchCase(ISwitchCase switchCase);
    public List`1<IStatement> get_Body();
    public void set_Body(List`1<IStatement> value);
    public void Dispatch(ICodeVisitor visitor);
    public sealed virtual ICompileTimeConstant get_Expression();
    public void set_Expression(ICompileTimeConstant value);
    public sealed virtual bool get_IsDefault();
    public IList`1<ILocation> get_Locations();
    private sealed virtual override IEnumerable`1<IStatement> Microsoft.Cci.ISwitchCase.get_Body();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.SwitchStatement : Statement {
    private List`1<ISwitchCase> cases;
    private IExpression expression;
    public List`1<ISwitchCase> Cases { get; public set; }
    public IExpression Expression { get; public set; }
    private IEnumerable`1<ISwitchCase> Microsoft.Cci.ISwitchStatement.Cases { get; }
    public SwitchStatement(ISwitchStatement switchStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public List`1<ISwitchCase> get_Cases();
    public void set_Cases(List`1<ISwitchCase> value);
    public sealed virtual IExpression get_Expression();
    public void set_Expression(IExpression value);
    private sealed virtual override IEnumerable`1<ISwitchCase> Microsoft.Cci.ISwitchStatement.get_Cases();
}
public class Microsoft.Cci.MutableCodeModel.TargetExpression : Expression {
    private byte alignment;
    private object definition;
    private bool getterIsVirtual;
    private bool setterIsVirtual;
    private IExpression instance;
    private bool isVolatile;
    public byte Alignment { get; public set; }
    public object Definition { get; public set; }
    public bool GetterIsVirtual { get; public set; }
    public bool SetterIsVirtual { get; public set; }
    public IExpression Instance { get; public set; }
    public bool IsUnaligned { get; }
    public bool IsVolatile { get; public set; }
    public TargetExpression(ITargetExpression targetExpression);
    private void ObjectInvariant();
    public sealed virtual byte get_Alignment();
    public void set_Alignment(byte value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual object get_Definition();
    public void set_Definition(object value);
    public sealed virtual bool get_GetterIsVirtual();
    public void set_GetterIsVirtual(bool value);
    public sealed virtual bool get_SetterIsVirtual();
    public void set_SetterIsVirtual(bool value);
    public sealed virtual IExpression get_Instance();
    public void set_Instance(IExpression value);
    public sealed virtual bool get_IsUnaligned();
    public sealed virtual bool get_IsVolatile();
    public void set_IsVolatile(bool value);
}
public class Microsoft.Cci.MutableCodeModel.ThisReference : Expression {
    public ThisReference(IThisReference thisReference);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.ThrowStatement : Statement {
    private IExpression exception;
    public IExpression Exception { get; public set; }
    public ThrowStatement(IThrowStatement throwStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Exception();
    public void set_Exception(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.TokenOf : Expression {
    private object definition;
    public object Definition { get; public set; }
    public TokenOf(ITokenOf tokenOf);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual object get_Definition();
    public void set_Definition(object value);
}
public class Microsoft.Cci.MutableCodeModel.TryCatchFinallyStatement : Statement {
    private List`1<ICatchClause> catchClauses;
    private IBlockStatement finallyBody;
    private IBlockStatement faultBody;
    private IBlockStatement tryBody;
    public List`1<ICatchClause> CatchClauses { get; public set; }
    public IBlockStatement FinallyBody { get; public set; }
    public IBlockStatement FaultBody { get; public set; }
    public IBlockStatement TryBody { get; public set; }
    private IEnumerable`1<ICatchClause> Microsoft.Cci.ITryCatchFinallyStatement.CatchClauses { get; }
    public TryCatchFinallyStatement(ITryCatchFinallyStatement tryCatchFinallyStatement);
    private void ObjectInvariant();
    public List`1<ICatchClause> get_CatchClauses();
    public void set_CatchClauses(List`1<ICatchClause> value);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IBlockStatement get_FinallyBody();
    public void set_FinallyBody(IBlockStatement value);
    public sealed virtual IBlockStatement get_FaultBody();
    public void set_FaultBody(IBlockStatement value);
    public sealed virtual IBlockStatement get_TryBody();
    public void set_TryBody(IBlockStatement value);
    private sealed virtual override IEnumerable`1<ICatchClause> Microsoft.Cci.ITryCatchFinallyStatement.get_CatchClauses();
}
public abstract class Microsoft.Cci.MutableCodeModel.TypeDefinitionMember : object {
    private List`1<ICustomAttribute> attributes;
    private ITypeDefinition containingTypeDefinition;
    internal int flags;
    private List`1<ILocation> locations;
    private IName name;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public ITypeDefinition ContainingTypeDefinition { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public IName Name { get; public set; }
    public TypeMemberVisibility Visibility { get; public set; }
    private ITypeReference Microsoft.Cci.ITypeMemberReference.ContainingType { get; }
    public ITypeDefinitionMember ResolvedTypeDefinitionMember { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.Container { get; }
    private IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.ContainingScope { get; }
    public sealed virtual void Copy(ITypeDefinitionMember typeDefinitionMember, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public void set_ContainingTypeDefinition(ITypeDefinition value);
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    public virtual string ToString();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public void set_Visibility(TypeMemberVisibility value);
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.get_ContainingType();
    public sealed virtual ITypeDefinitionMember get_ResolvedTypeDefinitionMember();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
    private sealed virtual override ITypeDefinition Microsoft.Cci.IContainerMember<Microsoft.Cci.ITypeDefinition>.get_Container();
    private sealed virtual override IScope`1<ITypeDefinitionMember> Microsoft.Cci.IScopeMember<Microsoft.Cci.IScope<Microsoft.Cci.ITypeDefinitionMember>>.get_ContainingScope();
}
public class Microsoft.Cci.MutableCodeModel.TypeOf : Expression {
    private ITypeReference typeToGet;
    public ITypeReference TypeToGet { get; public set; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public TypeOf(ITypeOf typeOf);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual ITypeReference get_TypeToGet();
    public void set_TypeToGet(ITypeReference value);
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(IMetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
public abstract class Microsoft.Cci.MutableCodeModel.TypeReference : object {
    private List`1<ICustomAttribute> attributes;
    private IInternFactory internFactory;
    private UInt32 internedKey;
    private bool isEnum;
    protected bool isFrozen;
    private bool isValueType;
    private List`1<ILocation> locations;
    private IPlatformType platformType;
    private PrimitiveTypeCode typeCode;
    public IAliasForType AliasForType { get; }
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public IInternFactory InternFactory { get; public set; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsEnum { get; public set; }
    public bool IsFrozen { get; public set; }
    public bool IsValueType { get; public set; }
    public ITypeDefinition ResolvedType { get; }
    public List`1<ILocation> Locations { get; public set; }
    public IPlatformType PlatformType { get; public set; }
    public PrimitiveTypeCode TypeCode { get; public set; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private void ObjectInvariant();
    public sealed virtual void Copy(ITypeReference typeReference, IInternFactory internFactory);
    public virtual IAliasForType get_AliasForType();
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public IInternFactory get_InternFactory();
    public void set_InternFactory(IInternFactory value);
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsEnum();
    public void set_IsEnum(bool value);
    public bool get_IsFrozen();
    public void set_IsFrozen(bool value);
    public sealed virtual bool get_IsValueType();
    public void set_IsValueType(bool value);
    public abstract virtual ITypeDefinition get_ResolvedType();
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public sealed virtual IPlatformType get_PlatformType();
    public void set_PlatformType(IPlatformType value);
    public virtual string ToString();
    public virtual PrimitiveTypeCode get_TypeCode();
    public virtual void set_TypeCode(PrimitiveTypeCode value);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.UnaryNegation : UnaryOperation {
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    public bool CheckOverflow { get; public set; }
    public UnaryNegation(IUnaryNegation unaryNegation);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
public void set_CheckOverflow(bool value);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public abstract class Microsoft.Cci.MutableCodeModel.UnaryOperation : Expression {
    private IExpression operand;
    public IExpression Operand { get; public set; }
    internal UnaryOperation(IUnaryOperation unaryOperation);
    public sealed virtual IExpression get_Operand();
    public void set_Operand(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.UnaryPlus : UnaryOperation {
    public UnaryPlus(IUnaryPlus unaryPlus);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public abstract class Microsoft.Cci.MutableCodeModel.Unit : UnitReference {
    private AssemblyIdentity contractAssemblySymbolicIdentity;
    private AssemblyIdentity coreAssemblySymbolicIdentity;
    private string location;
    private List`1<IPESection> uninterpretedSections;
    private IPlatformType platformType;
    private IRootUnitNamespace unitNamespaceRoot;
    public AssemblyIdentity ContractAssemblySymbolicIdentity { get; public set; }
    public AssemblyIdentity CoreAssemblySymbolicIdentity { get; public set; }
    public string Location { get; public set; }
    public List`1<IPESection> UninterpretedSections { get; public set; }
    public IPlatformType PlatformType { get; public set; }
    public IRootUnitNamespace UnitNamespaceRoot { get; public set; }
    public IEnumerable`1<IUnitReference> UnitReferences { get; }
    private IEnumerable`1<IPESection> Microsoft.Cci.IUnit.UninterpretedSections { get; }
    public INamespaceDefinition NamespaceRoot { get; }
    public sealed virtual void Copy(IUnit unit, IInternFactory internFactory);
    public sealed virtual AssemblyIdentity get_ContractAssemblySymbolicIdentity();
    public void set_ContractAssemblySymbolicIdentity(AssemblyIdentity value);
    public sealed virtual AssemblyIdentity get_CoreAssemblySymbolicIdentity();
    public void set_CoreAssemblySymbolicIdentity(AssemblyIdentity value);
    public virtual string get_Location();
    public virtual void set_Location(string value);
    public virtual List`1<IPESection> get_UninterpretedSections();
    public virtual void set_UninterpretedSections(List`1<IPESection> value);
    public sealed virtual IPlatformType get_PlatformType();
    public void set_PlatformType(IPlatformType value);
    public sealed virtual IRootUnitNamespace get_UnitNamespaceRoot();
    public void set_UnitNamespaceRoot(IRootUnitNamespace value);
    public abstract virtual IEnumerable`1<IUnitReference> get_UnitReferences();
    private sealed virtual override IEnumerable`1<IPESection> Microsoft.Cci.IUnit.get_UninterpretedSections();
    public sealed virtual INamespaceDefinition get_NamespaceRoot();
}
public abstract class Microsoft.Cci.MutableCodeModel.UnitNamespace : object {
    private List`1<ICustomAttribute> attributes;
    private List`1<ILocation> locations;
    private List`1<INamespaceMember> members;
    private IName name;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public List`1<INamespaceMember> Members { get; public set; }
    public IName Name { get; public set; }
    public IUnit Unit { get; }
    private INamespaceRootOwner Microsoft.Cci.INamespaceDefinition.RootOwner { get; }
    private IEnumerable`1<INamespaceMember> Microsoft.Cci.INamespaceDefinition.Members { get; }
    private IEnumerable`1<INamespaceMember> Microsoft.Cci.IContainer<Microsoft.Cci.INamespaceMember>.Members { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    private IEnumerable`1<INamespaceMember> Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>.Members { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    private IUnitNamespace Microsoft.Cci.IUnitNamespaceReference.ResolvedUnitNamespace { get; }
    public virtual void Copy(IUnitNamespace unitNamespace, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual bool Contains(INamespaceMember member);
    public abstract virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.UnitNamespace/<GetMatchingMembersNamed>d__9")]
public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<INamespaceMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.UnitNamespace/<GetMatchingMembers>d__10")]
public sealed virtual IEnumerable`1<INamespaceMember> GetMatchingMembers(Function`2<INamespaceMember, bool> predicate);
    [IteratorStateMachineAttribute("Microsoft.Cci.MutableCodeModel.UnitNamespace/<GetMembersNamed>d__11")]
public sealed virtual IEnumerable`1<INamespaceMember> GetMembersNamed(IName name, bool ignoreCase);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public List`1<INamespaceMember> get_Members();
    public void set_Members(List`1<INamespaceMember> value);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
    internal abstract virtual IUnit GetUnit();
    public sealed virtual IUnit get_Unit();
    private sealed virtual override INamespaceRootOwner Microsoft.Cci.INamespaceDefinition.get_RootOwner();
    private sealed virtual override IEnumerable`1<INamespaceMember> Microsoft.Cci.INamespaceDefinition.get_Members();
    private sealed virtual override IEnumerable`1<INamespaceMember> Microsoft.Cci.IContainer<Microsoft.Cci.INamespaceMember>.get_Members();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
    private sealed virtual override IEnumerable`1<INamespaceMember> Microsoft.Cci.IScope<Microsoft.Cci.INamespaceMember>.get_Members();
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    private sealed virtual override IUnitNamespace Microsoft.Cci.IUnitNamespaceReference.get_ResolvedUnitNamespace();
    public virtual string ToString();
}
public abstract class Microsoft.Cci.MutableCodeModel.UnitNamespaceReference : object {
    private List`1<ICustomAttribute> attributes;
    protected bool isFrozen;
    private List`1<ILocation> locations;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public bool IsFrozen { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public IUnitNamespace ResolvedUnitNamespace { get; }
    private IUnitReference Microsoft.Cci.IUnitNamespaceReference.Unit { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public virtual void Copy(IUnitNamespaceReference unitNamespaceReference, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public bool get_IsFrozen();
    public void set_IsFrozen(bool value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public abstract virtual IUnitNamespace get_ResolvedUnitNamespace();
    internal abstract virtual IUnitReference GetUnit();
    private sealed virtual override IUnitReference Microsoft.Cci.IUnitNamespaceReference.get_Unit();
    public virtual string ToString();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public abstract class Microsoft.Cci.MutableCodeModel.UnitReference : object {
    private List`1<ICustomAttribute> attributes;
    protected bool isFrozen;
    private List`1<ILocation> locations;
    private IName name;
    public List`1<ICustomAttribute> Attributes { get; public set; }
    public bool IsFrozen { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public IName Name { get; public set; }
    public IUnit ResolvedUnit { get; }
    public UnitIdentity UnitIdentity { get; }
    private IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.Attributes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public sealed virtual void Copy(IUnitReference unitReference, IInternFactory internFactory);
    public List`1<ICustomAttribute> get_Attributes();
    public void set_Attributes(List`1<ICustomAttribute> value);
    public virtual void Dispatch(IMetadataVisitor visitor);
    public abstract virtual void DispatchAsReference(IMetadataVisitor visitor);
    public bool get_IsFrozen();
    public void set_IsFrozen(bool value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public virtual IName get_Name();
    public virtual void set_Name(IName value);
    public abstract virtual IUnit get_ResolvedUnit();
    public abstract virtual UnitIdentity get_UnitIdentity();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.get_Attributes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableCodeModel.VectorLength : Expression {
    private IExpression vector;
    public IExpression Vector { get; public set; }
    public VectorLength(IVectorLength vectorLength);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Vector();
    public void set_Vector(IExpression value);
}
public class Microsoft.Cci.MutableCodeModel.VectorTypeReference : ArrayTypeReference {
    public bool IsVector { get; }
    public sealed virtual void Copy(IArrayTypeReference vectorTypeReference, IInternFactory internFactory);
    public virtual bool get_IsVector();
    protected virtual IArrayType Resolve();
}
public class Microsoft.Cci.MutableCodeModel.WhileDoStatement : Statement {
    private IStatement body;
    private IExpression condition;
    public IStatement Body { get; public set; }
    public IExpression Condition { get; public set; }
    public WhileDoStatement(IWhileDoStatement whileDoStatement);
    private void ObjectInvariant();
    public sealed virtual IStatement get_Body();
    public void set_Body(IStatement value);
    public sealed virtual IExpression get_Condition();
    public void set_Condition(IExpression value);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.Win32Resource : object {
    private UInt32 codePage;
    private List`1<byte> data;
    private int id;
    private UInt32 languageId;
    private string name;
    private int typeId;
    private string typeName;
    public UInt32 CodePage { get; public set; }
    public List`1<byte> Data { get; public set; }
    public int Id { get; public set; }
    public UInt32 LanguageId { get; public set; }
    public string Name { get; public set; }
    public int TypeId { get; public set; }
    public string TypeName { get; public set; }
    private IEnumerable`1<byte> Microsoft.Cci.IWin32Resource.Data { get; }
    public sealed virtual void Copy(IWin32Resource win32Resource, IInternFactory internFactory);
    public sealed virtual UInt32 get_CodePage();
    public void set_CodePage(UInt32 value);
    public List`1<byte> get_Data();
    public void set_Data(List`1<byte> value);
    public sealed virtual int get_Id();
    public void set_Id(int value);
    public sealed virtual UInt32 get_LanguageId();
    public void set_LanguageId(UInt32 value);
    public sealed virtual string get_Name();
    public void set_Name(string value);
    public sealed virtual int get_TypeId();
    public void set_TypeId(int value);
    public sealed virtual string get_TypeName();
    public void set_TypeName(string value);
    private sealed virtual override IEnumerable`1<byte> Microsoft.Cci.IWin32Resource.get_Data();
}
public class Microsoft.Cci.MutableCodeModel.YieldBreakStatement : Statement {
    public YieldBreakStatement(IYieldBreakStatement yieldBreakStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
}
public class Microsoft.Cci.MutableCodeModel.YieldReturnStatement : Statement {
    private IExpression expression;
    public IExpression Expression { get; public set; }
    public YieldReturnStatement(IYieldReturnStatement yieldReturnStatement);
    public virtual void Dispatch(ICodeVisitor visitor);
    public sealed virtual IExpression get_Expression();
    public void set_Expression(IExpression value);
}
internal class Microsoft.Cci.MutableCodeModel.YieldReturnYieldBreakReplacer : CodeRewriter {
    private IteratorClosureInformation iteratorClosure;
    private int stateNumber;
    private Dictionary`2<int, ILabeledStatement> stateEntries;
    internal YieldReturnYieldBreakReplacer(IteratorClosureInformation iteratorClosure, IMetadataHost host);
    internal Dictionary`2<int, ILabeledStatement> GetStateEntries(BlockStatement body);
    public virtual IStatement Rewrite(IYieldReturnStatement yieldReturnStatement);
    public virtual IStatement Rewrite(IYieldBreakStatement yieldBreakStatement);
}
public abstract class Microsoft.Cci.MutableContracts.ContractElement : object {
    private IExpression condition;
    private IExpression description;
    private string conditionAsText;
    private bool isModel;
    private List`1<ILocation> locations;
    public IExpression Condition { get; public set; }
    public IExpression Description { get; public set; }
    public string OriginalSource { get; public set; }
    public bool IsModel { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    protected ContractElement(IContractElement element);
    public virtual IExpression get_Condition();
    public virtual void set_Condition(IExpression value);
    public virtual IExpression get_Description();
    public virtual void set_Description(IExpression value);
    public abstract virtual void Dispatch(ICodeAndContractVisitor visitor);
    public virtual string get_OriginalSource();
    public virtual void set_OriginalSource(string value);
    public sealed virtual bool get_IsModel();
    public void set_IsModel(bool value);
    public virtual List`1<ILocation> get_Locations();
    public virtual void set_Locations(List`1<ILocation> value);
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableContracts.ContractProvider : object {
    private IContractMethods contractMethods;
    private Dictionary`2<object, ILoopContract> loopContractFor;
    private Dictionary`2<object, IMethodContract> methodContractFor;
    private Dictionary`2<object, IEnumerable`1<IEnumerable`1<IExpression>>> triggersFor;
    private Dictionary`2<object, ITypeContract> typeContractFor;
    private IUnit unit;
    public IContractMethods ContractMethods { get; }
    public IUnit Unit { get; }
    public ContractProvider(IContractMethods contractMethods, IUnit unit);
    public void AssociateLoopWithContract(object loop, ILoopContract contract);
    public void UnassociateLoopWithContract(object loop);
    public void AssociateMethodWithContract(object method, IMethodContract contract);
    public void UnassociateMethodWithContract(object method);
    public void AssociateTriggersWithQuantifier(object quantifier, IEnumerable`1<IEnumerable`1<IExpression>> triggers);
    public void UnassociateTriggersWithQuantifier(object quantifier);
    public void AssociateTypeWithContract(object type, ITypeContract contract);
    public void UnassociateTypeWithContract(object type);
    public sealed virtual IContractMethods get_ContractMethods();
    public sealed virtual ILoopContract GetLoopContractFor(object loop);
    public sealed virtual IMethodContract GetMethodContractFor(object method);
    public sealed virtual IEnumerable`1<IEnumerable`1<IExpression>> GetTriggersFor(object quantifier);
    public sealed virtual ITypeContract GetTypeContractFor(object type);
    public sealed virtual IUnit get_Unit();
}
public class Microsoft.Cci.MutableContracts.LoopContract : object {
    private List`1<ILoopInvariant> invariants;
    private List`1<ILocation> locations;
    private List`1<IExpression> variants;
    private List`1<IExpression> writes;
    public List`1<ILoopInvariant> Invariants { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public List`1<IExpression> Variants { get; public set; }
    public List`1<IExpression> Writes { get; public set; }
    private IEnumerable`1<ILoopInvariant> Microsoft.Cci.Contracts.ILoopContract.Invariants { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.ILoopContract.Writes { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.ILoopContract.Variants { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public LoopContract(ILoopContract loopContract);
    public List`1<ILoopInvariant> get_Invariants();
    public void set_Invariants(List`1<ILoopInvariant> value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public List`1<IExpression> get_Variants();
    public void set_Variants(List`1<IExpression> value);
    public List`1<IExpression> get_Writes();
    public void set_Writes(List`1<IExpression> value);
    private sealed virtual override IEnumerable`1<ILoopInvariant> Microsoft.Cci.Contracts.ILoopContract.get_Invariants();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.ILoopContract.get_Writes();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.ILoopContract.get_Variants();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableContracts.LoopInvariant : ContractElement {
    public LoopInvariant(ILoopInvariant loopInvariant);
    public virtual void Dispatch(ICodeAndContractVisitor visitor);
}
public class Microsoft.Cci.MutableContracts.MethodContract : object {
    private List`1<IExpression> allocates;
    private List`1<IExpression> frees;
    private List`1<ILocation> locations;
    private List`1<IAddressableExpression> modifiedVariables;
    private bool mustInline;
    private List`1<IPostcondition> postconditions;
    private List`1<IPrecondition> preconditions;
    private List`1<IExpression> reads;
    private List`1<IThrownException> thrownExceptions;
    private List`1<IExpression> variants;
    private List`1<IExpression> writes;
    private bool isPure;
    public List`1<IExpression> Allocates { get; public set; }
    public List`1<IExpression> Frees { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    public List`1<IAddressableExpression> ModifiedVariables { get; public set; }
    public bool MustInline { get; public set; }
    public List`1<IPostcondition> Postconditions { get; public set; }
    public List`1<IPrecondition> Preconditions { get; public set; }
    public List`1<IExpression> Reads { get; public set; }
    public List`1<IThrownException> ThrownExceptions { get; public set; }
    public List`1<IExpression> Variants { get; public set; }
    public List`1<IExpression> Writes { get; public set; }
    public bool IsPure { get; public set; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.Allocates { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.Frees { get; }
    private IEnumerable`1<IAddressableExpression> Microsoft.Cci.Contracts.IMethodContract.ModifiedVariables { get; }
    private IEnumerable`1<IPostcondition> Microsoft.Cci.Contracts.IMethodContract.Postconditions { get; }
    private IEnumerable`1<IPrecondition> Microsoft.Cci.Contracts.IMethodContract.Preconditions { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.Reads { get; }
    private IEnumerable`1<IThrownException> Microsoft.Cci.Contracts.IMethodContract.ThrownExceptions { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.Variants { get; }
    private IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.Writes { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public MethodContract(IMethodContract methodContract);
    public List`1<IExpression> get_Allocates();
    public void set_Allocates(List`1<IExpression> value);
    public List`1<IExpression> get_Frees();
    public void set_Frees(List`1<IExpression> value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    public List`1<IAddressableExpression> get_ModifiedVariables();
    public void set_ModifiedVariables(List`1<IAddressableExpression> value);
    public sealed virtual bool get_MustInline();
    public void set_MustInline(bool value);
    public List`1<IPostcondition> get_Postconditions();
    public void set_Postconditions(List`1<IPostcondition> value);
    public List`1<IPrecondition> get_Preconditions();
    public void set_Preconditions(List`1<IPrecondition> value);
    public List`1<IExpression> get_Reads();
    public void set_Reads(List`1<IExpression> value);
    public List`1<IThrownException> get_ThrownExceptions();
    public void set_ThrownExceptions(List`1<IThrownException> value);
    public List`1<IExpression> get_Variants();
    public void set_Variants(List`1<IExpression> value);
    public List`1<IExpression> get_Writes();
    public void set_Writes(List`1<IExpression> value);
    public sealed virtual bool get_IsPure();
    public void set_IsPure(bool value);
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.get_Allocates();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.get_Frees();
    private sealed virtual override IEnumerable`1<IAddressableExpression> Microsoft.Cci.Contracts.IMethodContract.get_ModifiedVariables();
    private sealed virtual override IEnumerable`1<IPostcondition> Microsoft.Cci.Contracts.IMethodContract.get_Postconditions();
    private sealed virtual override IEnumerable`1<IPrecondition> Microsoft.Cci.Contracts.IMethodContract.get_Preconditions();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.get_Reads();
    private sealed virtual override IEnumerable`1<IThrownException> Microsoft.Cci.Contracts.IMethodContract.get_ThrownExceptions();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.get_Variants();
    private sealed virtual override IEnumerable`1<IExpression> Microsoft.Cci.Contracts.IMethodContract.get_Writes();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableContracts.Postcondition : ContractElement {
    public Postcondition(IPostcondition postcondition);
    public virtual void Dispatch(ICodeAndContractVisitor visitor);
}
public class Microsoft.Cci.MutableContracts.Precondition : ContractElement {
    private bool alwaysCheckedAtRuntime;
    private IExpression exceptionToThrow;
    public bool AlwaysCheckedAtRuntime { get; public set; }
    public IExpression ExceptionToThrow { get; public set; }
    public Precondition(IPrecondition precondition);
    public sealed virtual bool get_AlwaysCheckedAtRuntime();
    public void set_AlwaysCheckedAtRuntime(bool value);
    public virtual void Dispatch(ICodeAndContractVisitor visitor);
    public sealed virtual IExpression get_ExceptionToThrow();
    public void set_ExceptionToThrow(IExpression value);
}
public class Microsoft.Cci.MutableContracts.ThrownException : object {
    private ITypeReference exceptionType;
    private IPostcondition postcondition;
    private List`1<ILocation> locations;
    public ITypeReference ExceptionType { get; public set; }
    public IPostcondition Postcondition { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public ThrownException(IThrownException thrownException);
    public sealed virtual ITypeReference get_ExceptionType();
    public void set_ExceptionType(ITypeReference value);
    public sealed virtual IPostcondition get_Postcondition();
    public void set_Postcondition(IPostcondition value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableContracts.TypeContract : object {
    private List`1<IFieldDefinition> contractFields;
    private List`1<IMethodDefinition> contractMethods;
    private List`1<ITypeInvariant> invariants;
    private List`1<ILocation> locations;
    public List`1<IFieldDefinition> ContractFields { get; public set; }
    public List`1<IMethodDefinition> ContractMethods { get; public set; }
    public List`1<ITypeInvariant> Invariants { get; public set; }
    public List`1<ILocation> Locations { get; public set; }
    private IEnumerable`1<IFieldDefinition> Microsoft.Cci.Contracts.ITypeContract.ContractFields { get; }
    private IEnumerable`1<IMethodDefinition> Microsoft.Cci.Contracts.ITypeContract.ContractMethods { get; }
    private IEnumerable`1<ITypeInvariant> Microsoft.Cci.Contracts.ITypeContract.Invariants { get; }
    private IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.Locations { get; }
    public TypeContract(ITypeContract typeContract);
    public List`1<IFieldDefinition> get_ContractFields();
    public void set_ContractFields(List`1<IFieldDefinition> value);
    public List`1<IMethodDefinition> get_ContractMethods();
    public void set_ContractMethods(List`1<IMethodDefinition> value);
    public List`1<ITypeInvariant> get_Invariants();
    public void set_Invariants(List`1<ITypeInvariant> value);
    public List`1<ILocation> get_Locations();
    public void set_Locations(List`1<ILocation> value);
    private sealed virtual override IEnumerable`1<IFieldDefinition> Microsoft.Cci.Contracts.ITypeContract.get_ContractFields();
    private sealed virtual override IEnumerable`1<IMethodDefinition> Microsoft.Cci.Contracts.ITypeContract.get_ContractMethods();
    private sealed virtual override IEnumerable`1<ITypeInvariant> Microsoft.Cci.Contracts.ITypeContract.get_Invariants();
    private sealed virtual override IEnumerable`1<ILocation> Microsoft.Cci.IObjectWithLocations.get_Locations();
}
public class Microsoft.Cci.MutableContracts.TypeInvariant : ContractElement {
    private bool isAxiom;
    private IName name;
    public bool IsAxiom { get; public set; }
    public IName Name { get; public set; }
    public TypeInvariant(ITypeInvariant typeInvariant);
    public sealed virtual bool get_IsAxiom();
    public void set_IsAxiom(bool value);
    public virtual void Dispatch(ICodeAndContractVisitor visitor);
    public sealed virtual IName get_Name();
    public void set_Name(IName value);
}
[FlagsAttribute]
public enum Microsoft.Cci.NameFormattingOptions : Enum {
    public int value__;
    public static NameFormattingOptions None;
    public static NameFormattingOptions ContractNullable;
    public static NameFormattingOptions DocumentationId;
    public static NameFormattingOptions DocumentationIdMemberKind;
    public static NameFormattingOptions EmptyTypeParameterList;
    public static NameFormattingOptions EscapeKeyword;
    public static NameFormattingOptions FormattingForDocumentationId;
    public static NameFormattingOptions MemberKind;
    public static NameFormattingOptions MethodConstraints;
    public static NameFormattingOptions Modifiers;
    public static NameFormattingOptions OmitContainingNamespace;
    public static NameFormattingOptions OmitContainingType;
    public static NameFormattingOptions OmitCustomModifiers;
    public static NameFormattingOptions OmitImplementedInterface;
    public static NameFormattingOptions OmitTypeArguments;
    public static NameFormattingOptions OmitWhiteSpaceAfterListDelimiter;
    public static NameFormattingOptions ParameterName;
    public static NameFormattingOptions ParameterModifiers;
    public static NameFormattingOptions PreserveSpecialNames;
    public static NameFormattingOptions ReturnType;
    public static NameFormattingOptions Signature;
    public static NameFormattingOptions SmartTypeName;
    public static NameFormattingOptions SmartNamespaceName;
    public static NameFormattingOptions SupressAttributeSuffix;
    public static NameFormattingOptions TypeConstraints;
    public static NameFormattingOptions TypeParameters;
    public static NameFormattingOptions UseGenericTypeNameSuffix;
    public static NameFormattingOptions UseGlobalPrefix;
    public static NameFormattingOptions UseReflectionStyleForNestedTypeNames;
    public static NameFormattingOptions UseTypeKeywords;
    public static NameFormattingOptions Visibility;
}
public class Microsoft.Cci.NameScope`2 : object {
    private Dictionary`2<TKey, object> m_map;
    public int Count { get; }
    public NameScope`2(int initSize);
    public int get_Count();
    public bool Add(TKey key, TValue value);
    private static IEnumerable`1<TValue> Translate(object values, Int32& count);
    public TValue GetValueArray(TKey key, TValue[]& valueArray);
    public IEnumerable`1<TValue> GetValuesAndCount(TKey key, Int32& count);
    public IEnumerable`1<TValue> GetValues(TKey key);
    public IEnumerator`1<IEnumerable`1<TValue>> GetEnumerator();
}
public class Microsoft.Cci.NameTable : object {
    private Dictionary`2<string, int> caseInsensitiveTable;
    private Dictionary`2<string, IName> caseSensitiveTable;
    private int caseInsensitiveCounter;
    private int caseSensitiveCounter;
    private IName address;
    private IName emptyName;
    private IName get;
    private IName globalCache;
    private IName allowMultiple;
    private IName beginInvoke;
    private IName boolOpBool;
    private IName decimalOpAddition;
    private IName delegateOpAddition;
    private IName endInvoke;
    private IName enumOpEnum;
    private IName enumOpNum;
    private IName equals;
    private IName float32OpAddition;
    private IName float64OpAddition;
    private IName hasValue;
    private IName inherited;
    private IName invoke;
    private IName int16OpInt16;
    private IName int32OpInt32;
    private IName int32OpUInt32;
    private IName int64OpInt32;
    private IName int64OpUInt32;
    private IName int64OpUInt64;
    private IName int64OpInt64;
    private IName int8OpInt8;
    private IName nullCoalescing;
    private IName numOpEnum;
    private IName objectOpObject;
    private IName objectOpString;
    private IName opAddition;
    private IName opBoolean;
    private IName opChar;
    private IName opDecimal;
    private IName opEnum;
    private IName opEquality;
    private IName opExplicit;
    private IName opImplicit;
    private IName opInequality;
    private IName opInt8;
    private IName opInt16;
    private IName opInt32;
    private IName opInt64;
    private IName opBitwiseAnd;
    private IName opBitwiseOr;
    private IName opComma;
    private IName opConcatentation;
    private IName opDivision;
    private IName opExclusiveOr;
    private IName opExponentiation;
    private IName opFalse;
    private IName opFloat32;
    private IName opFloat64;
    private IName opGreaterThan;
    private IName opGreaterThanOrEqual;
    private IName opIntegerDivision;
    private IName opLeftShift;
    private IName opLessThan;
    private IName opLessThanOrEqual;
    private IName opLogicalAnd;
    private IName opLogicalNot;
    private IName opLogicalOr;
    private IName opModulus;
    private IName opMultiplication;
    private IName opOnesComplement;
    private IName opDecrement;
    private IName opIncrement;
    private IName opRightShift;
    private IName opSubtraction;
    private IName opTrue;
    private IName opUInt8;
    private IName opUInt16;
    private IName opUInt32;
    private IName opUInt64;
    private IName opUnaryNegation;
    private IName opUnaryPlus;
    private IName remove;
    private IName result;
    private IName stringOpString;
    private IName stringOpObject;
    private IName uint32OpInt32;
    private IName uint32OpUInt32;
    private IName uint64OpInt32;
    private IName uint64OpUInt32;
    private IName uint64OpUInt64;
    private IName uintPtrOpUIntPtr;
    private IName valueCache;
    private IName voidPtrOpVoidPtr;
    private IName systemCache;
    private IName voidCache;
    private IName booleanCache;
    private IName cctorCache;
    private IName charCache;
    private IName ctorCache;
    private IName byteCache;
    private IName sbyteCache;
    private IName int16Cache;
    private IName uint16Cache;
    private IName int32Cache;
    private IName uint32Cache;
    private IName int64Cache;
    private IName uint64Cache;
    private IName stringCache;
    private IName intPtrCache;
    private IName uintPtrCache;
    private IName objectCache;
    private IName set;
    private IName singleCache;
    private IName doubleCache;
    private IName typedReferenceCache;
    private IName enumCache;
    private IName multicastDelegateCache;
    private IName valueTypeCache;
    private IName type;
    private IName array;
    private IName attributeUsage;
    private IName attribute;
    private IName dateTime;
    private IName debuggerHiddenAttribute;
    private IName decimal;
    private IName delegate;
    private IName diagnostics;
    private IName dbNull;
    private IName length;
    private IName longLength;
    private IName nullable;
    private IName combine;
    private IName concat;
    private IName Microsoft.Cci.INameTable.Address { get; }
    public IName EmptyName { get; }
    private IName Microsoft.Cci.INameTable.Get { get; }
    private IName Microsoft.Cci.INameTable.global { get; }
    private IName Microsoft.Cci.INameTable.AllowMultiple { get; }
    private IName Microsoft.Cci.INameTable.BeginInvoke { get; }
    private IName Microsoft.Cci.INameTable.BoolOpBool { get; }
    private IName Microsoft.Cci.INameTable.DecimalOpDecimal { get; }
    private IName Microsoft.Cci.INameTable.DelegateOpDelegate { get; }
    private IName Microsoft.Cci.INameTable.EndInvoke { get; }
    private IName Microsoft.Cci.INameTable.EnumOpEnum { get; }
    private IName Microsoft.Cci.INameTable.EnumOpNum { get; }
    private IName Microsoft.Cci.INameTable.Equals { get; }
    private IName Microsoft.Cci.INameTable.Float32OpFloat32 { get; }
    private IName Microsoft.Cci.INameTable.Float64OpFloat64 { get; }
    private IName Microsoft.Cci.INameTable.HasValue { get; }
    private IName Microsoft.Cci.INameTable.Inherited { get; }
    private IName Microsoft.Cci.INameTable.Invoke { get; }
    private IName Microsoft.Cci.INameTable.Int16OpInt16 { get; }
    private IName Microsoft.Cci.INameTable.Int32OpInt32 { get; }
    private IName Microsoft.Cci.INameTable.Int32OpUInt32 { get; }
    private IName Microsoft.Cci.INameTable.Int64OpInt32 { get; }
    private IName Microsoft.Cci.INameTable.Int64OpUInt32 { get; }
    private IName Microsoft.Cci.INameTable.Int64OpUInt64 { get; }
    private IName Microsoft.Cci.INameTable.Int64OpInt64 { get; }
    private IName Microsoft.Cci.INameTable.Int8OpInt8 { get; }
    private IName Microsoft.Cci.INameTable.NullCoalescing { get; }
    private IName Microsoft.Cci.INameTable.NumOpEnum { get; }
    private IName Microsoft.Cci.INameTable.ObjectOpObject { get; }
    private IName Microsoft.Cci.INameTable.ObjectOpString { get; }
    private IName Microsoft.Cci.INameTable.OpAddition { get; }
    private IName Microsoft.Cci.INameTable.OpBoolean { get; }
    private IName Microsoft.Cci.INameTable.OpChar { get; }
    private IName Microsoft.Cci.INameTable.OpDecimal { get; }
    private IName Microsoft.Cci.INameTable.OpEnum { get; }
    private IName Microsoft.Cci.INameTable.OpEquality { get; }
    private IName Microsoft.Cci.INameTable.OpExplicit { get; }
    private IName Microsoft.Cci.INameTable.OpImplicit { get; }
    private IName Microsoft.Cci.INameTable.OpInequality { get; }
    private IName Microsoft.Cci.INameTable.OpInt8 { get; }
    private IName Microsoft.Cci.INameTable.OpInt16 { get; }
    private IName Microsoft.Cci.INameTable.OpInt32 { get; }
    private IName Microsoft.Cci.INameTable.OpInt64 { get; }
    private IName Microsoft.Cci.INameTable.OpBitwiseAnd { get; }
    private IName Microsoft.Cci.INameTable.OpBitwiseOr { get; }
    private IName Microsoft.Cci.INameTable.OpComma { get; }
    private IName Microsoft.Cci.INameTable.OpConcatentation { get; }
    private IName Microsoft.Cci.INameTable.OpDivision { get; }
    private IName Microsoft.Cci.INameTable.OpExclusiveOr { get; }
    private IName Microsoft.Cci.INameTable.OpExponentiation { get; }
    private IName Microsoft.Cci.INameTable.OpFalse { get; }
    private IName Microsoft.Cci.INameTable.OpFloat32 { get; }
    private IName Microsoft.Cci.INameTable.OpFloat64 { get; }
    private IName Microsoft.Cci.INameTable.OpGreaterThan { get; }
    private IName Microsoft.Cci.INameTable.OpGreaterThanOrEqual { get; }
    private IName Microsoft.Cci.INameTable.OpIntegerDivision { get; }
    private IName Microsoft.Cci.INameTable.OpLeftShift { get; }
    private IName Microsoft.Cci.INameTable.OpLessThan { get; }
    private IName Microsoft.Cci.INameTable.OpLessThanOrEqual { get; }
    private IName Microsoft.Cci.INameTable.OpLike { get; }
    private IName Microsoft.Cci.INameTable.OpLogicalNot { get; }
    private IName Microsoft.Cci.INameTable.OpLogicalOr { get; }
    private IName Microsoft.Cci.INameTable.OpModulus { get; }
    private IName Microsoft.Cci.INameTable.OpMultiply { get; }
    private IName Microsoft.Cci.INameTable.OpOnesComplement { get; }
    private IName Microsoft.Cci.INameTable.OpDecrement { get; }
    private IName Microsoft.Cci.INameTable.OpIncrement { get; }
    private IName Microsoft.Cci.INameTable.OpRightShift { get; }
    private IName Microsoft.Cci.INameTable.OpSubtraction { get; }
    private IName Microsoft.Cci.INameTable.OpTrue { get; }
    private IName Microsoft.Cci.INameTable.OpUInt8 { get; }
    private IName Microsoft.Cci.INameTable.OpUInt16 { get; }
    private IName Microsoft.Cci.INameTable.OpUInt32 { get; }
    private IName Microsoft.Cci.INameTable.OpUInt64 { get; }
    private IName Microsoft.Cci.INameTable.OpUnaryNegation { get; }
    private IName Microsoft.Cci.INameTable.OpUnaryPlus { get; }
    private IName Microsoft.Cci.INameTable.Remove { get; }
    private IName Microsoft.Cci.INameTable.Result { get; }
    private IName Microsoft.Cci.INameTable.StringOpString { get; }
    private IName Microsoft.Cci.INameTable.StringOpObject { get; }
    private IName Microsoft.Cci.INameTable.UInt32OpInt32 { get; }
    private IName Microsoft.Cci.INameTable.UInt32OpUInt32 { get; }
    private IName Microsoft.Cci.INameTable.UInt64OpInt32 { get; }
    private IName Microsoft.Cci.INameTable.UInt64OpUInt32 { get; }
    private IName Microsoft.Cci.INameTable.UInt64OpUInt64 { get; }
    private IName Microsoft.Cci.INameTable.UIntPtrOpUIntPtr { get; }
    private IName Microsoft.Cci.INameTable.value { get; }
    private IName Microsoft.Cci.INameTable.VoidPtrOpVoidPtr { get; }
    private IName Microsoft.Cci.INameTable.System { get; }
    private IName Microsoft.Cci.INameTable.Void { get; }
    private IName Microsoft.Cci.INameTable.Boolean { get; }
    private IName Microsoft.Cci.INameTable.Cctor { get; }
    private IName Microsoft.Cci.INameTable.Char { get; }
    private IName Microsoft.Cci.INameTable.Ctor { get; }
    private IName Microsoft.Cci.INameTable.Byte { get; }
    private IName Microsoft.Cci.INameTable.SByte { get; }
    private IName Microsoft.Cci.INameTable.Int16 { get; }
    private IName Microsoft.Cci.INameTable.UInt16 { get; }
    private IName Microsoft.Cci.INameTable.Int32 { get; }
    private IName Microsoft.Cci.INameTable.UInt32 { get; }
    private IName Microsoft.Cci.INameTable.Int64 { get; }
    private IName Microsoft.Cci.INameTable.UInt64 { get; }
    private IName Microsoft.Cci.INameTable.String { get; }
    private IName Microsoft.Cci.INameTable.IntPtr { get; }
    private IName Microsoft.Cci.INameTable.UIntPtr { get; }
    private IName Microsoft.Cci.INameTable.Object { get; }
    private IName Microsoft.Cci.INameTable.Set { get; }
    private IName Microsoft.Cci.INameTable.Single { get; }
    private IName Microsoft.Cci.INameTable.Double { get; }
    private IName Microsoft.Cci.INameTable.TypedReference { get; }
    private IName Microsoft.Cci.INameTable.Enum { get; }
    private IName Microsoft.Cci.INameTable.MulticastDelegate { get; }
    private IName Microsoft.Cci.INameTable.ValueType { get; }
    private IName Microsoft.Cci.INameTable.Type { get; }
    private IName Microsoft.Cci.INameTable.Array { get; }
    private IName Microsoft.Cci.INameTable.AttributeUsageAttribute { get; }
    private IName Microsoft.Cci.INameTable.Attribute { get; }
    private IName Microsoft.Cci.INameTable.DateTime { get; }
    private IName Microsoft.Cci.INameTable.DebuggerHiddenAttribute { get; }
    private IName Microsoft.Cci.INameTable.Decimal { get; }
    private IName Microsoft.Cci.INameTable.Delegate { get; }
    private IName Microsoft.Cci.INameTable.Diagnostics { get; }
    private IName Microsoft.Cci.INameTable.DBNull { get; }
    private IName Microsoft.Cci.INameTable.Length { get; }
    private IName Microsoft.Cci.INameTable.LongLength { get; }
    private IName Microsoft.Cci.INameTable.Nullable { get; }
    private IName Microsoft.Cci.INameTable.Combine { get; }
    private IName Microsoft.Cci.INameTable.Concat { get; }
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Address();
    public sealed virtual IName get_EmptyName();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Get();
    public sealed virtual IName GetNameFor(string name);
    private sealed virtual override IName Microsoft.Cci.INameTable.get_global();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_AllowMultiple();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_BeginInvoke();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_BoolOpBool();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_DecimalOpDecimal();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_DelegateOpDelegate();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_EndInvoke();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_EnumOpEnum();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_EnumOpNum();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Equals();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Float32OpFloat32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Float64OpFloat64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_HasValue();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Inherited();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Invoke();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int16OpInt16();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int32OpInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int32OpUInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int64OpInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int64OpUInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int64OpUInt64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int64OpInt64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int8OpInt8();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_NullCoalescing();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_NumOpEnum();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_ObjectOpObject();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_ObjectOpString();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpAddition();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpBoolean();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpChar();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpDecimal();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpEnum();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpEquality();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpExplicit();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpImplicit();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpInequality();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpInt8();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpInt16();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpInt64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpBitwiseAnd();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpBitwiseOr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpComma();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpConcatentation();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpDivision();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpExclusiveOr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpExponentiation();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpFalse();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpFloat32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpFloat64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpGreaterThan();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpGreaterThanOrEqual();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpIntegerDivision();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpLeftShift();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpLessThan();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpLessThanOrEqual();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpLike();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpLogicalNot();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpLogicalOr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpModulus();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpMultiply();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpOnesComplement();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpDecrement();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpIncrement();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpRightShift();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpSubtraction();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpTrue();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpUInt8();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpUInt16();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpUInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpUInt64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpUnaryNegation();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_OpUnaryPlus();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Remove();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Result();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_StringOpString();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_StringOpObject();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt32OpInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt32OpUInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt64OpInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt64OpUInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt64OpUInt64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UIntPtrOpUIntPtr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_value();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_VoidPtrOpVoidPtr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_System();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Void();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Boolean();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Cctor();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Char();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Ctor();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Byte();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_SByte();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int16();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt16();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt32();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Int64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UInt64();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_String();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_IntPtr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_UIntPtr();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Object();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Set();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Single();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Double();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_TypedReference();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Enum();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_MulticastDelegate();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_ValueType();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Type();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Array();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_AttributeUsageAttribute();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Attribute();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_DateTime();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_DebuggerHiddenAttribute();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Decimal();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Delegate();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Diagnostics();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_DBNull();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Length();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_LongLength();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Nullable();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Combine();
    private sealed virtual override IName Microsoft.Cci.INameTable.get_Concat();
}
public static class Microsoft.Cci.ObjectModelHelper : object {
    public static int CaseInsensitiveStringHash(string s);
    public static int CaseSensitiveStringHash(string s);
}
[FlagsAttribute]
public enum Microsoft.Cci.OperationCheckFlags : Enum {
    public byte value__;
    public static OperationCheckFlags NoTypeCheck;
    public static OperationCheckFlags NoRangeCheck;
    public static OperationCheckFlags NoNullCheck;
}
public enum Microsoft.Cci.OperationCode : Enum {
    public int value__;
    public static OperationCode Nop;
    public static OperationCode Break;
    public static OperationCode Ldarg_0;
    public static OperationCode Ldarg_1;
    public static OperationCode Ldarg_2;
    public static OperationCode Ldarg_3;
    public static OperationCode Ldloc_0;
    public static OperationCode Ldloc_1;
    public static OperationCode Ldloc_2;
    public static OperationCode Ldloc_3;
    public static OperationCode Stloc_0;
    public static OperationCode Stloc_1;
    public static OperationCode Stloc_2;
    public static OperationCode Stloc_3;
    public static OperationCode Ldarg_S;
    public static OperationCode Ldarga_S;
    public static OperationCode Starg_S;
    public static OperationCode Ldloc_S;
    public static OperationCode Ldloca_S;
    public static OperationCode Stloc_S;
    public static OperationCode Ldnull;
    public static OperationCode Ldc_I4_M1;
    public static OperationCode Ldc_I4_0;
    public static OperationCode Ldc_I4_1;
    public static OperationCode Ldc_I4_2;
    public static OperationCode Ldc_I4_3;
    public static OperationCode Ldc_I4_4;
    public static OperationCode Ldc_I4_5;
    public static OperationCode Ldc_I4_6;
    public static OperationCode Ldc_I4_7;
    public static OperationCode Ldc_I4_8;
    public static OperationCode Ldc_I4_S;
    public static OperationCode Ldc_I4;
    public static OperationCode Ldc_I8;
    public static OperationCode Ldc_R4;
    public static OperationCode Ldc_R8;
    public static OperationCode Dup;
    public static OperationCode Pop;
    public static OperationCode Jmp;
    public static OperationCode Call;
    public static OperationCode Calli;
    public static OperationCode Ret;
    public static OperationCode Br_S;
    public static OperationCode Brfalse_S;
    public static OperationCode Brtrue_S;
    public static OperationCode Beq_S;
    public static OperationCode Bge_S;
    public static OperationCode Bgt_S;
    public static OperationCode Ble_S;
    public static OperationCode Blt_S;
    public static OperationCode Bne_Un_S;
    public static OperationCode Bge_Un_S;
    public static OperationCode Bgt_Un_S;
    public static OperationCode Ble_Un_S;
    public static OperationCode Blt_Un_S;
    public static OperationCode Br;
    public static OperationCode Brfalse;
    public static OperationCode Brtrue;
    public static OperationCode Beq;
    public static OperationCode Bge;
    public static OperationCode Bgt;
    public static OperationCode Ble;
    public static OperationCode Blt;
    public static OperationCode Bne_Un;
    public static OperationCode Bge_Un;
    public static OperationCode Bgt_Un;
    public static OperationCode Ble_Un;
    public static OperationCode Blt_Un;
    public static OperationCode Switch;
    public static OperationCode Ldind_I1;
    public static OperationCode Ldind_U1;
    public static OperationCode Ldind_I2;
    public static OperationCode Ldind_U2;
    public static OperationCode Ldind_I4;
    public static OperationCode Ldind_U4;
    public static OperationCode Ldind_I8;
    public static OperationCode Ldind_I;
    public static OperationCode Ldind_R4;
    public static OperationCode Ldind_R8;
    public static OperationCode Ldind_Ref;
    public static OperationCode Stind_Ref;
    public static OperationCode Stind_I1;
    public static OperationCode Stind_I2;
    public static OperationCode Stind_I4;
    public static OperationCode Stind_I8;
    public static OperationCode Stind_R4;
    public static OperationCode Stind_R8;
    public static OperationCode Add;
    public static OperationCode Sub;
    public static OperationCode Mul;
    public static OperationCode Div;
    public static OperationCode Div_Un;
    public static OperationCode Rem;
    public static OperationCode Rem_Un;
    public static OperationCode And;
    public static OperationCode Or;
    public static OperationCode Xor;
    public static OperationCode Shl;
    public static OperationCode Shr;
    public static OperationCode Shr_Un;
    public static OperationCode Neg;
    public static OperationCode Not;
    public static OperationCode Conv_I1;
    public static OperationCode Conv_I2;
    public static OperationCode Conv_I4;
    public static OperationCode Conv_I8;
    public static OperationCode Conv_R4;
    public static OperationCode Conv_R8;
    public static OperationCode Conv_U4;
    public static OperationCode Conv_U8;
    public static OperationCode Callvirt;
    public static OperationCode Cpobj;
    public static OperationCode Ldobj;
    public static OperationCode Ldstr;
    public static OperationCode Newobj;
    public static OperationCode Castclass;
    public static OperationCode Isinst;
    public static OperationCode Conv_R_Un;
    public static OperationCode Unbox;
    public static OperationCode Throw;
    public static OperationCode Ldfld;
    public static OperationCode Ldflda;
    public static OperationCode Stfld;
    public static OperationCode Ldsfld;
    public static OperationCode Ldsflda;
    public static OperationCode Stsfld;
    public static OperationCode Stobj;
    public static OperationCode Conv_Ovf_I1_Un;
    public static OperationCode Conv_Ovf_I2_Un;
    public static OperationCode Conv_Ovf_I4_Un;
    public static OperationCode Conv_Ovf_I8_Un;
    public static OperationCode Conv_Ovf_U1_Un;
    public static OperationCode Conv_Ovf_U2_Un;
    public static OperationCode Conv_Ovf_U4_Un;
    public static OperationCode Conv_Ovf_U8_Un;
    public static OperationCode Conv_Ovf_I_Un;
    public static OperationCode Conv_Ovf_U_Un;
    public static OperationCode Box;
    public static OperationCode Newarr;
    public static OperationCode Ldlen;
    public static OperationCode Ldelema;
    public static OperationCode Ldelem_I1;
    public static OperationCode Ldelem_U1;
    public static OperationCode Ldelem_I2;
    public static OperationCode Ldelem_U2;
    public static OperationCode Ldelem_I4;
    public static OperationCode Ldelem_U4;
    public static OperationCode Ldelem_I8;
    public static OperationCode Ldelem_I;
    public static OperationCode Ldelem_R4;
    public static OperationCode Ldelem_R8;
    public static OperationCode Ldelem_Ref;
    public static OperationCode Stelem_I;
    public static OperationCode Stelem_I1;
    public static OperationCode Stelem_I2;
    public static OperationCode Stelem_I4;
    public static OperationCode Stelem_I8;
    public static OperationCode Stelem_R4;
    public static OperationCode Stelem_R8;
    public static OperationCode Stelem_Ref;
    public static OperationCode Ldelem;
    public static OperationCode Stelem;
    public static OperationCode Unbox_Any;
    public static OperationCode Conv_Ovf_I1;
    public static OperationCode Conv_Ovf_U1;
    public static OperationCode Conv_Ovf_I2;
    public static OperationCode Conv_Ovf_U2;
    public static OperationCode Conv_Ovf_I4;
    public static OperationCode Conv_Ovf_U4;
    public static OperationCode Conv_Ovf_I8;
    public static OperationCode Conv_Ovf_U8;
    public static OperationCode Refanyval;
    public static OperationCode Ckfinite;
    public static OperationCode Mkrefany;
    public static OperationCode Ldtoken;
    public static OperationCode Conv_U2;
    public static OperationCode Conv_U1;
    public static OperationCode Conv_I;
    public static OperationCode Conv_Ovf_I;
    public static OperationCode Conv_Ovf_U;
    public static OperationCode Add_Ovf;
    public static OperationCode Add_Ovf_Un;
    public static OperationCode Mul_Ovf;
    public static OperationCode Mul_Ovf_Un;
    public static OperationCode Sub_Ovf;
    public static OperationCode Sub_Ovf_Un;
    public static OperationCode Endfinally;
    public static OperationCode Leave;
    public static OperationCode Leave_S;
    public static OperationCode Stind_I;
    public static OperationCode Conv_U;
    public static OperationCode Arglist;
    public static OperationCode Ceq;
    public static OperationCode Cgt;
    public static OperationCode Cgt_Un;
    public static OperationCode Clt;
    public static OperationCode Clt_Un;
    public static OperationCode Ldftn;
    public static OperationCode Ldvirtftn;
    public static OperationCode Ldarg;
    public static OperationCode Ldarga;
    public static OperationCode Starg;
    public static OperationCode Ldloc;
    public static OperationCode Ldloca;
    public static OperationCode Stloc;
    public static OperationCode Localloc;
    public static OperationCode Endfilter;
    public static OperationCode Unaligned_;
    public static OperationCode Volatile_;
    public static OperationCode Tail_;
    public static OperationCode Initobj;
    public static OperationCode Constrained_;
    public static OperationCode Cpblk;
    public static OperationCode Initblk;
    public static OperationCode No_;
    public static OperationCode Rethrow;
    public static OperationCode Sizeof;
    public static OperationCode Refanytype;
    public static OperationCode Readonly_;
    public static OperationCode Array_Create;
    public static OperationCode Array_Create_WithLowerBound;
    public static OperationCode Array_Get;
    public static OperationCode Array_Set;
    public static OperationCode Array_Addr;
    public static OperationCode Invalid;
}
[FlagsAttribute]
internal enum Microsoft.Cci.OperationValueKind : Enum {
    public int value__;
    public static OperationValueKind None;
    public static OperationValueKind Scalar;
    public static OperationValueKind String;
    public static OperationValueKind JumpOffset;
    public static OperationValueKind JumpOffsetArray;
    public static OperationValueKind Parameter;
    public static OperationValueKind Local;
    public static OperationValueKind Field;
    public static OperationValueKind Extra;
    public static OperationValueKind Type;
    public static OperationValueKind Method;
    public static OperationValueKind TypeMember;
    public static OperationValueKind FunctionPointerType;
    public static OperationValueKind RuntimeHandle;
    public static OperationValueKind Any;
}
public class Microsoft.Cci.OriginalSourceLocation : object {
    private IIncludedSourceLocation includedSourceLocation;
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    private int Microsoft.Cci.ISourceLocation.EndIndex { get; }
    private int Microsoft.Cci.ISourceLocation.Length { get; }
    private ISourceDocument Microsoft.Cci.ISourceLocation.SourceDocument { get; }
    private string Microsoft.Cci.ISourceLocation.Source { get; }
    private int Microsoft.Cci.ISourceLocation.StartIndex { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    public OriginalSourceLocation(IIncludedSourceLocation includedSourceLocation);
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartLine();
    private sealed virtual override bool Microsoft.Cci.ISourceLocation.Contains(ISourceLocation location);
    private sealed virtual override int Microsoft.Cci.ISourceLocation.CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_EndIndex();
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_Length();
    private sealed virtual override ISourceDocument Microsoft.Cci.ISourceLocation.get_SourceDocument();
    private sealed virtual override string Microsoft.Cci.ISourceLocation.get_Source();
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_StartIndex();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
public class Microsoft.Cci.ParameterInformationComparer : object {
    private bool resolveTypes;
    public ParameterInformationComparer(bool resolveTypes);
    public sealed virtual bool Equals(IParameterTypeInformation x, IParameterTypeInformation y);
    public sealed virtual int GetHashCode(IParameterTypeInformation parameterTypeInformation);
}
internal class Microsoft.Cci.Pdb.AlignSym : ValueType {
}
internal class Microsoft.Cci.Pdb.AnnotationSym : ValueType {
    internal UInt32 off;
    internal ushort seg;
    internal ushort csz;
    internal String[] rgsz;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal byte count;
    internal Byte[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym2 : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal ushort count;
    internal UInt16[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegRel : ValueType {
    internal UInt32 off;
    internal UInt32 typind;
    internal ushort reg;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegSym : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrSlotSym : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BitAccess : object {
    private Byte[] buffer;
    private int offset;
    internal Byte[] Buffer { get; }
    internal int Position { get; internal set; }
    internal BitAccess(int capacity);
    internal Byte[] get_Buffer();
    internal void FillBuffer(Stream stream, int capacity);
    internal void Append(Stream stream, int count);
    internal int get_Position();
    internal void set_Position(int value);
    internal void MinCapacity(int capacity);
    internal void Align(int alignment);
    internal void ReadInt16(Int16& value);
    internal void ReadInt8(SByte& value);
    internal void ReadInt32(Int32& value);
    internal void ReadInt64(Int64& value);
    internal void ReadUInt16(UInt16& value);
    internal void ReadUInt8(Byte& value);
    internal void ReadUInt32(UInt32& value);
    internal void ReadUInt64(UInt64& value);
    internal void ReadInt32(Int32[] values);
    internal void ReadUInt32(UInt32[] values);
    internal void ReadBytes(Byte[] bytes);
    internal float ReadFloat();
    internal double ReadDouble();
    internal decimal ReadDecimal();
    internal void ReadBString(String& value);
    internal string ReadBString(int len);
    internal void ReadCString(String& value);
    internal void SkipCString(String& value);
    internal void ReadGuid(Guid& guid);
    internal string ReadString();
}
internal class Microsoft.Cci.Pdb.BitSet : ValueType {
    private int size;
    private UInt32[] words;
    internal bool IsEmpty { get; }
    internal BitSet(BitAccess bits);
    internal bool IsSet(int index);
    private static UInt32 GetBit(int index);
    internal bool get_IsEmpty();
}
internal class Microsoft.Cci.Pdb.BlockSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BpRelSym32 : ValueType {
    internal int off;
    internal UInt32 typind;
    internal string name;
}
internal class Microsoft.Cci.Pdb.CallsiteInfo : ValueType {
    internal int off;
    internal ushort ect;
    internal ushort pad0;
    internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.CFlagSym : ValueType {
    internal byte machine;
    internal byte language;
    internal ushort flags;
    internal string ver;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CFLAGSYM_FLAGS : Enum {
    public ushort value__;
    public static CFLAGSYM_FLAGS pcode;
    public static CFLAGSYM_FLAGS floatprec;
    public static CFLAGSYM_FLAGS floatpkg;
    public static CFLAGSYM_FLAGS ambdata;
    public static CFLAGSYM_FLAGS ambcode;
    public static CFLAGSYM_FLAGS mode32;
}
internal class Microsoft.Cci.Pdb.CoffGroupSym : ValueType {
    internal UInt32 cb;
    internal UInt32 characteristics;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.CompileSym : ValueType {
    internal UInt32 flags;
    internal ushort machine;
    internal ushort verFEMajor;
    internal ushort verFEMinor;
    internal ushort verFEBuild;
    internal ushort verMajor;
    internal ushort verMinor;
    internal ushort verBuild;
    internal string verSt;
    internal String[] verArgs;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.COMPILESYM_FLAGS : Enum {
    public UInt32 value__;
    public static COMPILESYM_FLAGS iLanguage;
    public static COMPILESYM_FLAGS fEC;
    public static COMPILESYM_FLAGS fNoDbgInfo;
    public static COMPILESYM_FLAGS fLTCG;
    public static COMPILESYM_FLAGS fNoDataAlign;
    public static COMPILESYM_FLAGS fManagedPresent;
    public static COMPILESYM_FLAGS fSecurityChecks;
    public static COMPILESYM_FLAGS fHotPatch;
    public static COMPILESYM_FLAGS fCVTCIL;
    public static COMPILESYM_FLAGS fMSILModule;
}
internal class Microsoft.Cci.Pdb.ConstSym : ValueType {
    internal UInt32 typind;
    internal ushort value;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_CODE : Enum {
    public int value__;
    public static CV_CFL_CODE CV_CFL_CNEAR;
    public static CV_CFL_CODE CV_CFL_CFAR;
    public static CV_CFL_CODE CV_CFL_CHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_DATA : Enum {
    public int value__;
    public static CV_CFL_DATA CV_CFL_DNEAR;
    public static CV_CFL_DATA CV_CFL_DFAR;
    public static CV_CFL_DATA CV_CFL_DHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_FPKG : Enum {
    public int value__;
    public static CV_CFL_FPKG CV_CFL_NDP;
    public static CV_CFL_FPKG CV_CFL_EMU;
    public static CV_CFL_FPKG CV_CFL_ALT;
}
internal class Microsoft.Cci.Pdb.CV_Column : ValueType {
    internal ushort offColumnStart;
    internal ushort offColumnEnd;
}
internal enum Microsoft.Cci.Pdb.CV_cookietype : Enum {
    public int value__;
    public static CV_cookietype CV_COOKIETYPE_COPY;
    public static CV_cookietype CV_COOKIETYPE_XOR_SP;
    public static CV_cookietype CV_COOKIETYPE_XOR_BP;
    public static CV_cookietype CV_COOKIETYPE_XOR_R13;
}
internal enum Microsoft.Cci.Pdb.CV_DISCARDED : Enum {
    public UInt32 value__;
    public static CV_DISCARDED CV_DISCARDED_UNKNOWN;
    public static CV_DISCARDED CV_DISCARDED_NOT_SELECTED;
    public static CV_DISCARDED CV_DISCARDED_NOT_REFERENCED;
}
internal class Microsoft.Cci.Pdb.CV_EXPROCFLAGS : ValueType {
    internal byte flags;
    internal byte reserved;
}
internal enum Microsoft.Cci.Pdb.CV_FILE_CHECKSUM_TYPE : Enum {
    public byte value__;
    public static CV_FILE_CHECKSUM_TYPE None;
    public static CV_FILE_CHECKSUM_TYPE MD5;
}
internal class Microsoft.Cci.Pdb.CV_FileCheckSum : ValueType {
    internal UInt32 name;
    internal byte len;
    internal byte type;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_fldattr : Enum {
    public int value__;
    public static CV_fldattr access;
    public static CV_fldattr mprop;
    public static CV_fldattr pseudo;
    public static CV_fldattr noinherit;
    public static CV_fldattr noconstruct;
    public static CV_fldattr compgenx;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_GENERIC_FLAG : Enum {
    public ushort value__;
    public static CV_GENERIC_FLAG cstyle;
    public static CV_GENERIC_FLAG rsclean;
}
internal enum Microsoft.Cci.Pdb.CV_GENERIC_STYLE : Enum {
    public int value__;
    public static CV_GENERIC_STYLE CV_GENERIC_VOID;
    public static CV_GENERIC_STYLE CV_GENERIC_REG;
    public static CV_GENERIC_STYLE CV_GENERIC_ICAN;
    public static CV_GENERIC_STYLE CV_GENERIC_ICAF;
    public static CV_GENERIC_STYLE CV_GENERIC_IRAN;
    public static CV_GENERIC_STYLE CV_GENERIC_IRAF;
    public static CV_GENERIC_STYLE CV_GENERIC_UNUSED;
}
internal enum Microsoft.Cci.Pdb.CV_int : Enum {
    public int value__;
    public static CV_int CV_RI_CHAR;
    public static CV_int CV_RI_INT1;
    public static CV_int CV_RI_WCHAR;
    public static CV_int CV_RI_UINT1;
    public static CV_int CV_RI_INT2;
    public static CV_int CV_RI_UINT2;
    public static CV_int CV_RI_INT4;
    public static CV_int CV_RI_UINT4;
    public static CV_int CV_RI_INT8;
    public static CV_int CV_RI_UINT8;
    public static CV_int CV_RI_INT16;
    public static CV_int CV_RI_UINT16;
}
internal enum Microsoft.Cci.Pdb.CV_integral : Enum {
    public int value__;
    public static CV_integral CV_IN_1BYTE;
    public static CV_integral CV_IN_2BYTE;
    public static CV_integral CV_IN_4BYTE;
    public static CV_integral CV_IN_8BYTE;
    public static CV_integral CV_IN_16BYTE;
}
internal enum Microsoft.Cci.Pdb.CV_LABEL_TYPE : Enum {
    public int value__;
    public static CV_LABEL_TYPE CV_LABEL_NEAR;
    public static CV_LABEL_TYPE CV_LABEL_FAR;
}
internal class Microsoft.Cci.Pdb.CV_Line : ValueType {
    internal UInt32 offset;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_Line_Flags : Enum {
    public UInt32 value__;
    public static CV_Line_Flags linenumStart;
    public static CV_Line_Flags deltaLineEnd;
    public static CV_Line_Flags fStatement;
}
internal enum Microsoft.Cci.Pdb.CV_LINE_SUBSECTION_FLAGS : Enum {
    public ushort value__;
    public static CV_LINE_SUBSECTION_FLAGS CV_LINES_HAVE_COLUMNS;
}
internal class Microsoft.Cci.Pdb.CV_LineSection : ValueType {
    internal UInt32 off;
    internal ushort sec;
    internal ushort flags;
    internal UInt32 cod;
}
internal class Microsoft.Cci.Pdb.CV_lvar_addr_range : ValueType {
    internal UInt32 offStart;
    internal ushort isectStart;
    internal UInt32 cbRange;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_LVARFLAGS : Enum {
    public ushort value__;
    public static CV_LVARFLAGS fIsParam;
    public static CV_LVARFLAGS fAddrTaken;
    public static CV_LVARFLAGS fCompGenx;
    public static CV_LVARFLAGS fIsAggregate;
    public static CV_LVARFLAGS fIsAggregated;
    public static CV_LVARFLAGS fIsAliased;
    public static CV_LVARFLAGS fIsAlias;
}
internal enum Microsoft.Cci.Pdb.CV_methodprop : Enum {
    public int value__;
    public static CV_methodprop CV_MTvanilla;
    public static CV_methodprop CV_MTvirtual;
    public static CV_methodprop CV_MTstatic;
    public static CV_methodprop CV_MTfriend;
    public static CV_methodprop CV_MTintro;
    public static CV_methodprop CV_MTpurevirt;
    public static CV_methodprop CV_MTpureintro;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_modifier : Enum {
    public ushort value__;
    public static CV_modifier MOD_const;
    public static CV_modifier MOD_volatile;
    public static CV_modifier MOD_unaligned;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_NVVFCN : ValueType {
    internal int mdisp;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_VBASE : ValueType {
    internal int mdisp;
    internal int pdisp;
    internal int vdisp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVMA : ValueType {
    internal UInt32 off;
    internal int disp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVSA : ValueType {
    internal UInt32 off;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_VBASE : ValueType {
    internal UInt32 off;
    internal int mdisp;
    internal int pdisp;
    internal int vdisp;
}
internal enum Microsoft.Cci.Pdb.CV_pmtype : Enum {
    public int value__;
    public static CV_pmtype CV_PMTYPE_Undef;
    public static CV_pmtype CV_PMTYPE_D_Single;
    public static CV_pmtype CV_PMTYPE_D_Multiple;
    public static CV_pmtype CV_PMTYPE_D_Virtual;
    public static CV_pmtype CV_PMTYPE_D_General;
    public static CV_pmtype CV_PMTYPE_F_Single;
    public static CV_pmtype CV_PMTYPE_F_Multiple;
    public static CV_pmtype CV_PMTYPE_F_Virtual;
    public static CV_pmtype CV_PMTYPE_F_General;
}
internal class Microsoft.Cci.Pdb.CV_PRIMITIVE_TYPE : ValueType {
    private static UInt32 CV_MMASK;
    private static UInt32 CV_TMASK;
    private static UInt32 CV_SMASK;
    private static int CV_MSHIFT;
    private static int CV_TSHIFT;
    private static int CV_SSHIFT;
    private static UInt32 CV_FIRST_NONPRIM;
}
internal enum Microsoft.Cci.Pdb.CV_prmode : Enum {
    public int value__;
    public static CV_prmode CV_TM_DIRECT;
    public static CV_prmode CV_TM_NPTR32;
    public static CV_prmode CV_TM_NPTR64;
    public static CV_prmode CV_TM_NPTR128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PROCFLAGS : Enum {
    public byte value__;
    public static CV_PROCFLAGS CV_PFLAG_NOFPO;
    public static CV_PROCFLAGS CV_PFLAG_INT;
    public static CV_PROCFLAGS CV_PFLAG_FAR;
    public static CV_PROCFLAGS CV_PFLAG_NEVER;
    public static CV_PROCFLAGS CV_PFLAG_NOTREACHED;
    public static CV_PROCFLAGS CV_PFLAG_CUST_CALL;
    public static CV_PROCFLAGS CV_PFLAG_NOINLINE;
    public static CV_PROCFLAGS CV_PFLAG_OPTDBGINFO;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_prop : Enum {
    public ushort value__;
    public static CV_prop packed;
    public static CV_prop ctor;
    public static CV_prop ovlops;
    public static CV_prop isnested;
    public static CV_prop cnested;
    public static CV_prop opassign;
    public static CV_prop opcast;
    public static CV_prop fwdref;
    public static CV_prop scoped;
}
internal enum Microsoft.Cci.Pdb.CV_ptrmode : Enum {
    public int value__;
    public static CV_ptrmode CV_PTR_MODE_PTR;
    public static CV_ptrmode CV_PTR_MODE_REF;
    public static CV_ptrmode CV_PTR_MODE_PMEM;
    public static CV_ptrmode CV_PTR_MODE_PMFUNC;
    public static CV_ptrmode CV_PTR_MODE_RESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_ptrtype : Enum {
    public int value__;
    public static CV_ptrtype CV_PTR_BASE_SEG;
    public static CV_ptrtype CV_PTR_BASE_VAL;
    public static CV_ptrtype CV_PTR_BASE_SEGVAL;
    public static CV_ptrtype CV_PTR_BASE_ADDR;
    public static CV_ptrtype CV_PTR_BASE_SEGADDR;
    public static CV_ptrtype CV_PTR_BASE_TYPE;
    public static CV_ptrtype CV_PTR_BASE_SELF;
    public static CV_ptrtype CV_PTR_NEAR32;
    public static CV_ptrtype CV_PTR_64;
    public static CV_ptrtype CV_PTR_UNUSEDPTR;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PUBSYMFLAGS : Enum {
    public UInt32 value__;
    public static CV_PUBSYMFLAGS fNone;
    public static CV_PUBSYMFLAGS fCode;
    public static CV_PUBSYMFLAGS fFunction;
    public static CV_PUBSYMFLAGS fManaged;
    public static CV_PUBSYMFLAGS fMSIL;
}
internal enum Microsoft.Cci.Pdb.CV_real : Enum {
    public int value__;
    public static CV_real CV_RC_REAL32;
    public static CV_real CV_RC_REAL64;
    public static CV_real CV_RC_REAL80;
    public static CV_real CV_RC_REAL128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_SEPCODEFLAGS : Enum {
    public UInt32 value__;
    public static CV_SEPCODEFLAGS fIsLexicalScope;
    public static CV_SEPCODEFLAGS fReturnsToParent;
}
internal enum Microsoft.Cci.Pdb.CV_SIGNATURE : Enum {
    public int value__;
    public static CV_SIGNATURE C6;
    public static CV_SIGNATURE C7;
    public static CV_SIGNATURE C11;
    public static CV_SIGNATURE C13;
    public static CV_SIGNATURE RESERVERD;
}
internal class Microsoft.Cci.Pdb.CV_SourceFile : ValueType {
    internal UInt32 index;
    internal UInt32 count;
    internal UInt32 linsiz;
}
internal enum Microsoft.Cci.Pdb.CV_special : Enum {
    public int value__;
    public static CV_special CV_SP_NOTYPE;
    public static CV_special CV_SP_ABS;
    public static CV_special CV_SP_SEGMENT;
    public static CV_special CV_SP_VOID;
    public static CV_special CV_SP_CURRENCY;
    public static CV_special CV_SP_NBASICSTR;
    public static CV_special CV_SP_FBASICSTR;
    public static CV_special CV_SP_NOTTRANS;
    public static CV_special CV_SP_HRESULT;
}
internal enum Microsoft.Cci.Pdb.CV_special2 : Enum {
    public int value__;
    public static CV_special2 CV_S2_BIT;
    public static CV_special2 CV_S2_PASCHAR;
}
internal enum Microsoft.Cci.Pdb.CV_type : Enum {
    public int value__;
    public static CV_type CV_SPECIAL;
    public static CV_type CV_SIGNED;
    public static CV_type CV_UNSIGNED;
    public static CV_type CV_BOOLEAN;
    public static CV_type CV_REAL;
    public static CV_type CV_COMPLEX;
    public static CV_type CV_SPECIAL2;
    public static CV_type CV_INT;
    public static CV_type CV_CVRESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_VTS_desc : Enum {
    public int value__;
    public static CV_VTS_desc CV_VTS_near;
    public static CV_VTS_desc CV_VTS_far;
    public static CV_VTS_desc CV_VTS_thin;
    public static CV_VTS_desc CV_VTS_outer;
    public static CV_VTS_desc CV_VTS_meta;
    public static CV_VTS_desc CV_VTS_near32;
    public static CV_VTS_desc CV_VTS_far32;
    public static CV_VTS_desc CV_VTS_unused;
}
internal class Microsoft.Cci.Pdb.DatasSym32 : ValueType {
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.DataStream : object {
    internal int contentSize;
    internal Int32[] pages;
    internal int Length { get; }
    internal DataStream(int contentSize, BitAccess bits, int count);
    internal void Read(PdbReader reader, BitAccess bits);
    internal void Read(PdbReader reader, int position, Byte[] bytes, int offset, int data);
    internal int get_Length();
}
internal class Microsoft.Cci.Pdb.DbiDbgHdr : ValueType {
    internal ushort snFPO;
    internal ushort snException;
    internal ushort snFixup;
    internal ushort snOmapToSrc;
    internal ushort snOmapFromSrc;
    internal ushort snSectionHdr;
    internal ushort snTokenRidMap;
    internal ushort snXdata;
    internal ushort snPdata;
    internal ushort snNewFPO;
    internal ushort snSectionHdrOrig;
    internal DbiDbgHdr(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiHeader : ValueType {
    internal int sig;
    internal int ver;
    internal int age;
    internal short gssymStream;
    internal ushort vers;
    internal short pssymStream;
    internal ushort pdbver;
    internal short symrecStream;
    internal ushort pdbver2;
    internal int gpmodiSize;
    internal int secconSize;
    internal int secmapSize;
    internal int filinfSize;
    internal int tsmapSize;
    internal int mfcIndex;
    internal int dbghdrSize;
    internal int ecinfoSize;
    internal ushort flags;
    internal ushort machine;
    internal int reserved;
    internal DbiHeader(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiModuleInfo : object {
    internal int opened;
    internal ushort flags;
    internal short stream;
    internal int cbSyms;
    internal int cbOldLines;
    internal int cbLines;
    internal short files;
    internal short pad1;
    internal UInt32 offsets;
    internal int niSource;
    internal int niCompiler;
    internal string moduleName;
    internal string objectName;
    internal DbiModuleInfo(BitAccess bits, bool readStrings);
}
internal class Microsoft.Cci.Pdb.DbiSecCon : ValueType {
    internal short section;
    internal short pad1;
    internal int offset;
    internal int size;
    internal UInt32 flags;
    internal short module;
    internal short pad2;
    internal UInt32 dataCrc;
    internal UInt32 relocCrc;
    internal DbiSecCon(BitAccess bits);
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION : Enum {
    public int value__;
    public static DEBUG_S_SUBSECTION SYMBOLS;
    public static DEBUG_S_SUBSECTION LINES;
    public static DEBUG_S_SUBSECTION STRINGTABLE;
    public static DEBUG_S_SUBSECTION FILECHKSMS;
    public static DEBUG_S_SUBSECTION FRAMEDATA;
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION_TYPE : Enum {
    public UInt32 value__;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_IGNORE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_SYMBOLS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_LINES;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_STRINGTABLE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FILECHKSMS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FRAMEDATA;
}
internal class Microsoft.Cci.Pdb.DefRangeSym : ValueType {
    internal UInt32 id;
    internal UInt32 program;
    internal CV_lvar_addr_range range;
}
internal class Microsoft.Cci.Pdb.DefRangeSym2 : ValueType {
    internal UInt32 id;
    internal UInt32 program;
    internal ushort count;
    internal CV_lvar_addr_range[] range;
}
internal class Microsoft.Cci.Pdb.DiscardedSym : ValueType {
    internal CV_DISCARDED iscarded;
    internal UInt32 fileid;
    internal UInt32 linenum;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.EndArgSym : ValueType {
}
internal class Microsoft.Cci.Pdb.EntryThisSym : ValueType {
    internal byte thissym;
}
internal class Microsoft.Cci.Pdb.ExportSym : ValueType {
    internal ushort ordinal;
    internal ushort flags;
    internal string name;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.EXPORTSYM_FLAGS : Enum {
    public ushort value__;
    public static EXPORTSYM_FLAGS fConstant;
    public static EXPORTSYM_FLAGS fData;
    public static EXPORTSYM_FLAGS fPrivate;
    public static EXPORTSYM_FLAGS fNoName;
    public static EXPORTSYM_FLAGS fOrdinal;
    public static EXPORTSYM_FLAGS fForwarder;
}
internal class Microsoft.Cci.Pdb.FLOAT10 : ValueType {
    internal byte Data_0;
    internal byte Data_1;
    internal byte Data_2;
    internal byte Data_3;
    internal byte Data_4;
    internal byte Data_5;
    internal byte Data_6;
    internal byte Data_7;
    internal byte Data_8;
    internal byte Data_9;
}
internal class Microsoft.Cci.Pdb.FrameCookie : ValueType {
    internal int off;
    internal ushort reg;
    internal int cookietype;
    internal byte flags;
}
internal class Microsoft.Cci.Pdb.FrameData : ValueType {
    internal UInt32 ulRvaStart;
    internal UInt32 cbBlock;
    internal UInt32 cbLocals;
    internal UInt32 cbParams;
    internal UInt32 cbStkMax;
    internal UInt32 frameFunc;
    internal ushort cbProlog;
    internal ushort cbSavedRegs;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEDATA_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEDATA_FLAGS fHasSEH;
    public static FRAMEDATA_FLAGS fHasEH;
    public static FRAMEDATA_FLAGS fIsFunctionStart;
}
internal class Microsoft.Cci.Pdb.FrameProcSym : ValueType {
    internal UInt32 cbFrame;
    internal UInt32 cbPad;
    internal UInt32 offPad;
    internal UInt32 cbSaveRegs;
    internal UInt32 offExHdlr;
    internal ushort secExHdlr;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEPROCSYM_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEPROCSYM_FLAGS fHasAlloca;
    public static FRAMEPROCSYM_FLAGS fHasSetJmp;
    public static FRAMEPROCSYM_FLAGS fHasLongJmp;
    public static FRAMEPROCSYM_FLAGS fHasInlAsm;
    public static FRAMEPROCSYM_FLAGS fHasEH;
    public static FRAMEPROCSYM_FLAGS fInlSpec;
    public static FRAMEPROCSYM_FLAGS fHasSEH;
    public static FRAMEPROCSYM_FLAGS fNaked;
    public static FRAMEPROCSYM_FLAGS fSecurityChecks;
    public static FRAMEPROCSYM_FLAGS fAsyncEH;
    public static FRAMEPROCSYM_FLAGS fGSNoStackOrdering;
    public static FRAMEPROCSYM_FLAGS fWasInlined;
}
internal class Microsoft.Cci.Pdb.FrameRelSym : ValueType {
    internal int off;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.Pdb.IntHashTable : object {
    private static Int32[] primes;
    private bucket[] buckets;
    private int count;
    private int occupancy;
    private int loadsize;
    private int loadFactorPerc;
    private int version;
    internal object Item { get; }
    internal IntHashTable(int capacity, int loadFactorPerc);
    private static IntHashTable();
    private static int GetPrime(int minSize);
    private static UInt32 InitHash(int key, int hashsize, UInt32& seed, UInt32& incr);
    internal void Add(int key, object value);
    internal object get_Item(int key);
    private void expand();
    private void rehash();
    private void rehash(int newsize);
    private void Insert(int key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode);
}
internal class Microsoft.Cci.Pdb.LabelSym32 : ValueType {
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.LEAF : Enum {
    public int value__;
    public static LEAF LF_VTSHAPE;
    public static LEAF LF_COBOL1;
    public static LEAF LF_LABEL;
    public static LEAF LF_NULL;
    public static LEAF LF_NOTTRAN;
    public static LEAF LF_ENDPRECOMP;
    public static LEAF LF_TYPESERVER_ST;
    public static LEAF LF_LIST;
    public static LEAF LF_REFSYM;
    public static LEAF LF_ENUMERATE_ST;
    public static LEAF LF_TI16_MAX;
    public static LEAF LF_MODIFIER;
    public static LEAF LF_POINTER;
    public static LEAF LF_ARRAY_ST;
    public static LEAF LF_CLASS_ST;
    public static LEAF LF_STRUCTURE_ST;
    public static LEAF LF_UNION_ST;
    public static LEAF LF_ENUM_ST;
    public static LEAF LF_PROCEDURE;
    public static LEAF LF_MFUNCTION;
    public static LEAF LF_COBOL0;
    public static LEAF LF_BARRAY;
    public static LEAF LF_DIMARRAY_ST;
    public static LEAF LF_VFTPATH;
    public static LEAF LF_PRECOMP_ST;
    public static LEAF LF_OEM;
    public static LEAF LF_ALIAS_ST;
    public static LEAF LF_OEM2;
    public static LEAF LF_SKIP;
    public static LEAF LF_ARGLIST;
    public static LEAF LF_DEFARG_ST;
    public static LEAF LF_FIELDLIST;
    public static LEAF LF_DERIVED;
    public static LEAF LF_BITFIELD;
    public static LEAF LF_METHODLIST;
    public static LEAF LF_DIMCONU;
    public static LEAF LF_DIMCONLU;
    public static LEAF LF_DIMVARU;
    public static LEAF LF_DIMVARLU;
    public static LEAF LF_BCLASS;
    public static LEAF LF_VBCLASS;
    public static LEAF LF_IVBCLASS;
    public static LEAF LF_FRIENDFCN_ST;
    public static LEAF LF_INDEX;
    public static LEAF LF_MEMBER_ST;
    public static LEAF LF_STMEMBER_ST;
    public static LEAF LF_METHOD_ST;
    public static LEAF LF_NESTTYPE_ST;
    public static LEAF LF_VFUNCTAB;
    public static LEAF LF_FRIENDCLS;
    public static LEAF LF_ONEMETHOD_ST;
    public static LEAF LF_VFUNCOFF;
    public static LEAF LF_NESTTYPEEX_ST;
    public static LEAF LF_MEMBERMODIFY_ST;
    public static LEAF LF_MANAGED_ST;
    public static LEAF LF_ST_MAX;
    public static LEAF LF_TYPESERVER;
    public static LEAF LF_ENUMERATE;
    public static LEAF LF_ARRAY;
    public static LEAF LF_CLASS;
    public static LEAF LF_STRUCTURE;
    public static LEAF LF_UNION;
    public static LEAF LF_ENUM;
    public static LEAF LF_DIMARRAY;
    public static LEAF LF_PRECOMP;
    public static LEAF LF_ALIAS;
    public static LEAF LF_DEFARG;
    public static LEAF LF_FRIENDFCN;
    public static LEAF LF_MEMBER;
    public static LEAF LF_STMEMBER;
    public static LEAF LF_METHOD;
    public static LEAF LF_NESTTYPE;
    public static LEAF LF_ONEMETHOD;
    public static LEAF LF_NESTTYPEEX;
    public static LEAF LF_MEMBERMODIFY;
    public static LEAF LF_MANAGED;
    public static LEAF LF_TYPESERVER2;
    public static LEAF LF_NUMERIC;
    public static LEAF LF_CHAR;
    public static LEAF LF_SHORT;
    public static LEAF LF_USHORT;
    public static LEAF LF_LONG;
    public static LEAF LF_ULONG;
    public static LEAF LF_REAL32;
    public static LEAF LF_REAL64;
    public static LEAF LF_REAL80;
    public static LEAF LF_REAL128;
    public static LEAF LF_QUADWORD;
    public static LEAF LF_UQUADWORD;
    public static LEAF LF_COMPLEX32;
    public static LEAF LF_COMPLEX64;
    public static LEAF LF_COMPLEX80;
    public static LEAF LF_COMPLEX128;
    public static LEAF LF_VARSTRING;
    public static LEAF LF_OCTWORD;
    public static LEAF LF_UOCTWORD;
    public static LEAF LF_DECIMAL;
    public static LEAF LF_DATE;
    public static LEAF LF_UTF8STRING;
    public static LEAF LF_PAD0;
    public static LEAF LF_PAD1;
    public static LEAF LF_PAD2;
    public static LEAF LF_PAD3;
    public static LEAF LF_PAD4;
    public static LEAF LF_PAD5;
    public static LEAF LF_PAD6;
    public static LEAF LF_PAD7;
    public static LEAF LF_PAD8;
    public static LEAF LF_PAD9;
    public static LEAF LF_PAD10;
    public static LEAF LF_PAD11;
    public static LEAF LF_PAD12;
    public static LEAF LF_PAD13;
    public static LEAF LF_PAD14;
    public static LEAF LF_PAD15;
}
internal class Microsoft.Cci.Pdb.LeafAlias : ValueType {
    internal UInt32 utype;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafArgList : ValueType {
    internal UInt32 count;
    internal UInt32[] arg;
}
internal class Microsoft.Cci.Pdb.LeafArray : ValueType {
    internal UInt32 elemtype;
    internal UInt32 idxtype;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafBArray : ValueType {
    internal UInt32 utype;
}
internal class Microsoft.Cci.Pdb.LeafBClass : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal Byte[] offset;
}
internal class Microsoft.Cci.Pdb.LeafBitfield : ValueType {
    internal UInt32 type;
    internal byte length;
    internal byte position;
}
internal class Microsoft.Cci.Pdb.LeafChar : ValueType {
    internal sbyte val;
}
internal class Microsoft.Cci.Pdb.LeafClass : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 field;
    internal UInt32 derived;
    internal UInt32 vshape;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafCmplx128 : ValueType {
    internal ulong val0_real;
    internal ulong val1_real;
    internal ulong val0_imag;
    internal ulong val1_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx32 : ValueType {
    internal float val_real;
    internal float val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx64 : ValueType {
    internal double val_real;
    internal double val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx80 : ValueType {
    internal FLOAT10 val_real;
    internal FLOAT10 val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCobol0 : ValueType {
    internal UInt32 type;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafCobol1 : ValueType {
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafDefArg : ValueType {
    internal UInt32 type;
    internal Byte[] expr;
}
internal class Microsoft.Cci.Pdb.LeafDerived : ValueType {
    internal UInt32 count;
    internal UInt32[] drvdcls;
}
internal class Microsoft.Cci.Pdb.LeafDimArray : ValueType {
    internal UInt32 utype;
    internal UInt32 diminfo;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafDimCon : ValueType {
    internal UInt32 typ;
    internal ushort rank;
    internal Byte[] dim;
}
internal class Microsoft.Cci.Pdb.LeafDimVar : ValueType {
    internal UInt32 rank;
    internal UInt32 typ;
    internal UInt32[] dim;
}
internal class Microsoft.Cci.Pdb.LeafEndPreComp : ValueType {
    internal UInt32 signature;
}
internal class Microsoft.Cci.Pdb.LeafEnum : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 utype;
    internal UInt32 field;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafEnumerate : ValueType {
    internal ushort attr;
    internal Byte[] value;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafFieldList : ValueType {
    internal Char[] data;
}
internal class Microsoft.Cci.Pdb.LeafFriendCls : ValueType {
    internal ushort pad0;
    internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafFriendFcn : ValueType {
    internal ushort pad0;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafIndex : ValueType {
    internal ushort pad0;
    internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafLabel : ValueType {
    internal ushort mode;
}
internal class Microsoft.Cci.Pdb.LeafList : ValueType {
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafLong : ValueType {
    internal int val;
}
internal class Microsoft.Cci.Pdb.LeafManaged : ValueType {
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMember : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal Byte[] offset;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMemberModify : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethod : ValueType {
    internal ushort count;
    internal UInt32 mList;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethodList : ValueType {
    internal Byte[] mList;
}
internal class Microsoft.Cci.Pdb.LeafMFunc : ValueType {
    internal UInt32 rvtype;
    internal UInt32 classtype;
    internal UInt32 thistype;
    internal byte calltype;
    internal byte reserved;
    internal ushort parmcount;
    internal UInt32 arglist;
    internal int thisadjust;
}
internal class Microsoft.Cci.Pdb.LeafModifier : ValueType {
    internal UInt32 type;
    internal CV_modifier attr;
}
internal class Microsoft.Cci.Pdb.LeafNestType : ValueType {
    internal ushort pad0;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafNestTypeEx : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafOct : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafOEM : ValueType {
    internal ushort cvOEM;
    internal ushort recOEM;
    internal UInt32 count;
    internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOEM2 : ValueType {
    internal Guid idOem;
    internal UInt32 count;
    internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOneMethod : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal UInt32[] vbaseoff;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafPad : ValueType {
    internal byte leaf;
}
internal class Microsoft.Cci.Pdb.LeafPointer : ValueType {
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.LeafPointerAttr : Enum {
    public UInt32 value__;
    public static LeafPointerAttr ptrtype;
    public static LeafPointerAttr ptrmode;
    public static LeafPointerAttr isflat32;
    public static LeafPointerAttr isvolatile;
    public static LeafPointerAttr isconst;
    public static LeafPointerAttr isunaligned;
    public static LeafPointerAttr isrestrict;
}
internal class Microsoft.Cci.Pdb.LeafPreComp : ValueType {
    internal UInt32 start;
    internal UInt32 count;
    internal UInt32 signature;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafProc : ValueType {
    internal UInt32 rvtype;
    internal byte calltype;
    internal byte reserved;
    internal ushort parmcount;
    internal UInt32 arglist;
}
internal class Microsoft.Cci.Pdb.LeafQuad : ValueType {
    internal long val;
}
internal class Microsoft.Cci.Pdb.LeafReal128 : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafReal32 : ValueType {
    internal float val;
}
internal class Microsoft.Cci.Pdb.LeafReal64 : ValueType {
    internal double val;
}
internal class Microsoft.Cci.Pdb.LeafReal80 : ValueType {
    internal FLOAT10 val;
}
internal class Microsoft.Cci.Pdb.LeafRefSym : ValueType {
    internal Byte[] Sym;
}
internal class Microsoft.Cci.Pdb.LeafShort : ValueType {
    internal short val;
}
internal class Microsoft.Cci.Pdb.LeafSkip : ValueType {
    internal UInt32 type;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafSTMember : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer : ValueType {
    internal UInt32 signature;
    internal UInt32 age;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer2 : ValueType {
    internal Guid sig70;
    internal UInt32 age;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafULong : ValueType {
    internal UInt32 val;
}
internal class Microsoft.Cci.Pdb.LeafUnion : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 field;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafUOct : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafUQuad : ValueType {
    internal ulong val;
}
internal class Microsoft.Cci.Pdb.LeafUShort : ValueType {
    internal ushort val;
}
internal class Microsoft.Cci.Pdb.LeafVarString : ValueType {
    internal ushort len;
    internal Byte[] value;
}
internal class Microsoft.Cci.Pdb.LeafVBClass : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal UInt32 vbptr;
    internal Byte[] vbpoff;
}
internal class Microsoft.Cci.Pdb.LeafVFTPath : ValueType {
    internal UInt32 count;
    internal UInt32[] bases;
}
internal class Microsoft.Cci.Pdb.LeafVFuncOff : ValueType {
    internal ushort pad0;
    internal UInt32 type;
    internal int offset;
}
internal class Microsoft.Cci.Pdb.LeafVFuncTab : ValueType {
    internal ushort pad0;
    internal UInt32 type;
}
internal class Microsoft.Cci.Pdb.LeafVTShape : ValueType {
    internal ushort count;
    internal Byte[] desc;
}
internal class Microsoft.Cci.Pdb.LocalNameSourceLocation : object {
    private string source;
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public int EndIndex { get; }
    public int Length { get; }
    public ISourceDocument SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    public IDocument Document { get; }
    internal LocalNameSourceLocation(string source);
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartLine();
    public sealed virtual bool Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    public sealed virtual ISourceDocument get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    public sealed virtual IDocument get_Document();
}
internal class Microsoft.Cci.Pdb.LocalSym : ValueType {
    internal UInt32 id;
    internal UInt32 typind;
    internal ushort flags;
    internal UInt32 idParent;
    internal UInt32 offParent;
    internal UInt32 expr;
    internal UInt32 pad0;
    internal UInt32 pad1;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal ushort retReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSymMips : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 regSave;
    internal UInt32 fpSave;
    internal UInt32 intOff;
    internal UInt32 fpOff;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte retReg;
    internal byte frameReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym : ValueType {
    internal UInt32 typind;
    internal byte count;
    internal Byte[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym2 : ValueType {
    internal UInt32 typind;
    internal ushort count;
    internal UInt16[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyTypRef : ValueType {
    internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.mlMethod : ValueType {
    internal ushort attr;
    internal ushort pad0;
    internal UInt32 index;
    internal UInt32[] vbaseoff;
}
internal class Microsoft.Cci.Pdb.MsfDirectory : object {
    internal DataStream[] streams;
    internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.NamespaceScope : object {
    private IEnumerable`1<IUsedNamespace> usedNamespaces;
    public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    internal NamespaceScope(IEnumerable`1<IUsedNamespace> usedNamespaces);
    public sealed virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
internal class Microsoft.Cci.Pdb.ObjNameSym : ValueType {
    internal UInt32 signature;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.OEM_ID : Enum {
    public int value__;
    public static OEM_ID OEM_MS_FORTRAN90;
    public static OEM_ID OEM_ODI;
    public static OEM_ID OEM_THOMSON_SOFTWARE;
    public static OEM_ID OEM_ODI_REC_BASELIST;
}
internal class Microsoft.Cci.Pdb.OemSymbol : ValueType {
    internal Guid idOem;
    internal UInt32 typind;
    internal Byte[] rgl;
}
public class Microsoft.Cci.Pdb.PdbConstant : object {
    internal string name;
    internal UInt32 token;
    internal object value;
    internal PdbConstant(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbDebugException : IOException {
    internal PdbDebugException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbException : IOException {
    internal PdbException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbFile : object {
    private static PdbFunction match;
    private static PdbFile();
    private static void LoadInjectedSourceInformation(BitAccess bits, Guid& doctype, Guid& language, Guid& vendor, Guid& checksumAlgo, Byte[]& checksum);
    private static Dictionary`2<string, int> LoadNameIndex(BitAccess bits, Int32& age, Guid& guid);
    private static IntHashTable LoadNameStream(BitAccess bits);
    private static int FindFunction(PdbFunction[] funcs, ushort sec, UInt32 off);
    private static void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, UInt32 limit);
    private static void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, List`1<PdbFunction> funcList, bool readStrings, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader);
    private static void LoadDbiStream(BitAccess bits, DbiModuleInfo[]& modules, DbiDbgHdr& header, bool readStrings);
    internal static PdbFunction[] LoadFunctions(Stream read, Dictionary`2& tokenToSourceMapping, String& sourceServerData, Int32& age, Guid& guid);
    private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping);
    private static IntHashTable ReadSourceFileInfo(BitAccess bits, UInt32 limit, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader);
}
internal class Microsoft.Cci.Pdb.PdbFileHeader : object {
    internal Byte[] magic;
    internal int pageSize;
    internal int freePageMap;
    internal int pagesUsed;
    internal int directorySize;
    internal int zero;
    internal Int32[] directoryRoot;
    internal PdbFileHeader(Stream reader, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbFunction : object {
    internal static Guid msilMetaData;
    internal static IComparer byAddress;
    internal static IComparer byAddressAndToken;
    internal UInt32 token;
    internal UInt32 slotToken;
    internal UInt32 tokenOfMethodWhoseUsingInfoAppliesToThisMethod;
    internal UInt32 segment;
    internal UInt32 address;
    internal PdbScope[] scopes;
    internal PdbSlot[] slots;
    internal PdbConstant[] constants;
    internal String[] usedNamespaces;
    internal PdbLines[] lines;
    internal UInt16[] usingCounts;
    internal IEnumerable`1<INamespaceScope> namespaceScopes;
    internal string iteratorClass;
    internal List`1<ILocalScope> iteratorScopes;
    internal PdbSynchronizationInformation synchronizationInformation;
    internal PdbFunction(ManProcSym proc, BitAccess bits);
    private static PdbFunction();
    private static string StripNamespace(string module);
    internal static PdbFunction[] LoadManagedFunctions(BitAccess bits, UInt32 limit, bool readStrings);
    internal static void CountScopesAndSlots(BitAccess bits, UInt32 limit, Int32& constants, Int32& scopes, Int32& slots, Int32& usedNamespaces);
    private void ReadCustomMetadata(BitAccess bits);
    private void ReadForwardIterator(BitAccess bits);
    private void ReadIteratorLocals(BitAccess bits);
    private void ReadForwardInfo(BitAccess bits);
    private void ReadUsingInfo(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbIteratorScope : object {
    private UInt32 offset;
    private UInt32 length;
    private IMethodDefinition methodDefinition;
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public IMethodDefinition MethodDefinition { get; public set; }
    internal PdbIteratorScope(UInt32 offset, UInt32 length);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public void set_MethodDefinition(IMethodDefinition value);
}
internal class Microsoft.Cci.Pdb.PdbLine : ValueType {
    internal UInt32 offset;
    internal UInt32 lineBegin;
    internal UInt32 lineEnd;
    internal ushort colBegin;
    internal ushort colEnd;
    internal PdbLine(UInt32 offset, UInt32 lineBegin, ushort colBegin, UInt32 lineEnd, ushort colEnd);
}
internal class Microsoft.Cci.Pdb.PdbLines : object {
    internal PdbSource file;
    internal PdbLine[] lines;
    internal PdbLines(PdbSource file, UInt32 count);
}
public class Microsoft.Cci.Pdb.PdbLocalConstant : object {
    private PdbConstant pdbConstant;
    private IMetadataHost host;
    private IMethodDefinition methodDefinition;
    private IMetadataConstant compileTimeValue;
    private ITypeReference type;
    public IMetadataConstant CompileTimeValue { get; }
    public IMetadataHost Host { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    public PdbLocalConstant(PdbConstant pdbConstant, IMetadataHost host, IMethodDefinition methodDefinition);
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public PdbConstant GetPdbConstant();
    public IMetadataHost get_Host();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    protected virtual ITypeReference GetTypeForConstant();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.Pdb.PdbLocalScope : object {
    internal IMethodBody methodBody;
    internal PdbScope pdbScope;
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public IMethodDefinition MethodDefinition { get; }
    internal PdbLocalScope(IMethodBody methodBody, PdbScope pdbScope);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
    public sealed virtual IMethodDefinition get_MethodDefinition();
}
internal class Microsoft.Cci.Pdb.PdbLocalVariable : object {
    private PdbSlot pdbSlot;
    private IMetadataHost host;
    private IMethodDefinition methodDefinition;
    private ITypeReference type;
    public IMetadataConstant CompileTimeValue { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMethodDefinition MethodDefinition { get; }
    public ITypeReference Type { get; }
    public IName Name { get; }
    internal PdbLocalVariable(PdbSlot pdbSlot, IMetadataHost host, IMethodDefinition methodDefinition);
    public sealed virtual IMetadataConstant get_CompileTimeValue();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    private ITypeReference GetTypeForVariable();
    public sealed virtual bool get_IsConstant();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMethodDefinition get_MethodDefinition();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual IName get_Name();
}
internal class Microsoft.Cci.Pdb.PdbMetadataConstant : object {
    private object value;
    private ITypeReference type;
    public object Value { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public ITypeReference Type { get; }
    internal PdbMetadataConstant(object value, ITypeReference type);
    public sealed virtual object get_Value();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual ITypeReference get_Type();
}
internal class Microsoft.Cci.Pdb.PdbReader : object {
    internal int pageSize;
    internal Stream reader;
    internal PdbReader(Stream reader, int pageSize);
    internal void Seek(int page, int offset);
    internal void Read(Byte[] bytes, int offset, int count);
    internal int PagesFromSize(int size);
}
internal class Microsoft.Cci.Pdb.PdbScope : object {
    internal PdbConstant[] constants;
    internal PdbSlot[] slots;
    internal PdbScope[] scopes;
    internal String[] usedNamespaces;
    internal UInt32 address;
    internal UInt32 offset;
    internal UInt32 length;
    internal PdbScope(UInt32 address, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 funcOffset, BlockSym32 block, BitAccess bits, UInt32& typind);
}
internal class Microsoft.Cci.Pdb.PdbSlot : object {
    internal UInt32 slot;
    internal UInt32 typeToken;
    internal string name;
    internal ushort flags;
    internal PdbSlot(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbSource : object {
    internal string name;
    internal Guid doctype;
    internal Guid language;
    internal Guid vendor;
    internal Guid checksumAlgorithm;
    internal Byte[] checksum;
    internal PdbSource(string name, Guid doctype, Guid language, Guid vendor, Guid checksumAlgorithm, Byte[] checksum);
}
internal class Microsoft.Cci.Pdb.PdbSourceDocument : PrimarySourceDocument {
    private PdbSource pdbSourceFile;
    public string SourceLanguage { get; }
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid ChecksumAlgorithm { get; }
    public Byte[] Checksum { get; }
    internal PdbSourceDocument(IName name, PdbSource pdbSourceFile, StreamReader streamReader);
    internal PdbSourceDocument(IName name, PdbSource pdbSourceFile);
    public virtual string get_SourceLanguage();
    public virtual Guid get_DocumentType();
    public virtual Guid get_Language();
    public virtual Guid get_LanguageVendor();
    public virtual Guid get_ChecksumAlgorithm();
    public virtual Byte[] get_Checksum();
}
internal class Microsoft.Cci.Pdb.PdbSourceLineLocation : object {
    private int endColumn;
    private int endLine;
    private PdbSourceDocument primarySourceDocument;
    private int startColumn;
    private int startLine;
    private int endIndex;
    private int startIndex;
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public int EndIndex { get; }
    public int Length { get; }
    private ISourceDocument Microsoft.Cci.ISourceLocation.SourceDocument { get; }
    public string Source { get; }
    public int StartIndex { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    internal PdbSourceLineLocation(PdbSourceDocument primarySourceDocument, int startLine, int startColumn, int endLine, int endColumn);
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartLine();
    private sealed virtual override bool Microsoft.Cci.ISourceLocation.Contains(ISourceLocation location);
    public sealed virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public sealed virtual int get_Length();
    private sealed virtual override ISourceDocument Microsoft.Cci.ISourceLocation.get_SourceDocument();
    public sealed virtual string get_Source();
    public sealed virtual int get_StartIndex();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationInformation : object {
    internal UInt32 kickoffMethodToken;
    internal IMethodDefinition asyncMethod;
    internal IMethodDefinition moveNextMethod;
    internal UInt32 generatedCatchHandlerIlOffset;
    internal PdbSynchronizationPoint[] synchronizationPoints;
    public IMethodDefinition AsyncMethod { get; }
    public IMethodDefinition MoveNextMethod { get; }
    public UInt32 GeneratedCatchHandlerOffset { get; }
    public IEnumerable`1<ISynchronizationPoint> SynchronizationPoints { get; }
    internal PdbSynchronizationInformation(BitAccess bits);
    public sealed virtual IMethodDefinition get_AsyncMethod();
    public sealed virtual IMethodDefinition get_MoveNextMethod();
    public sealed virtual UInt32 get_GeneratedCatchHandlerOffset();
    public sealed virtual IEnumerable`1<ISynchronizationPoint> get_SynchronizationPoints();
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationPoint : object {
    internal UInt32 synchronizeOffset;
    internal UInt32 continuationMethodToken;
    internal IMethodDefinition continuationMethod;
    internal UInt32 continuationOffset;
    public UInt32 SynchronizeOffset { get; }
    public IMethodDefinition ContinuationMethod { get; }
    public UInt32 ContinuationOffset { get; }
    internal PdbSynchronizationPoint(BitAccess bits);
    public sealed virtual UInt32 get_SynchronizeOffset();
    public sealed virtual IMethodDefinition get_ContinuationMethod();
    public sealed virtual UInt32 get_ContinuationOffset();
}
internal class Microsoft.Cci.Pdb.PdbTokenLine : object {
    internal UInt32 token;
    internal UInt32 file_id;
    internal UInt32 line;
    internal UInt32 column;
    internal UInt32 endLine;
    internal UInt32 endColumn;
    internal PdbSource sourceFile;
    internal PdbTokenLine nextLine;
    internal PdbTokenLine(UInt32 token, UInt32 file_id, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn);
}
internal class Microsoft.Cci.Pdb.ProcSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymIa64 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal ushort retReg;
    internal byte flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymMips : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 regSave;
    internal UInt32 fpSave;
    internal UInt32 intOff;
    internal UInt32 fpOff;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal byte retReg;
    internal byte frameReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.PubSym32 : ValueType {
    internal UInt32 flags;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RefSym : ValueType {
    internal UInt32 sumName;
    internal UInt32 ibSym;
    internal ushort imod;
    internal ushort usFill;
}
internal class Microsoft.Cci.Pdb.RefSym2 : ValueType {
    internal UInt32 sumName;
    internal UInt32 ibSym;
    internal ushort imod;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RegRel32 : ValueType {
    internal UInt32 off;
    internal UInt32 typind;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RegSym : ValueType {
    internal UInt32 typind;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ReturnSym : ValueType {
    internal CV_GENERIC_FLAG flags;
    internal byte style;
}
internal class Microsoft.Cci.Pdb.SearchSym : ValueType {
    internal UInt32 startsym;
    internal ushort seg;
}
internal class Microsoft.Cci.Pdb.SectionSym : ValueType {
    internal ushort isec;
    internal byte align;
    internal byte bReserved;
    internal UInt32 rva;
    internal UInt32 cb;
    internal UInt32 characteristics;
    internal string name;
}
internal class Microsoft.Cci.Pdb.SepCodSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 length;
    internal UInt32 scf;
    internal UInt32 off;
    internal UInt32 offParent;
    internal ushort sec;
    internal ushort secParent;
}
internal class Microsoft.Cci.Pdb.Slink32 : ValueType {
    internal UInt32 framesize;
    internal int off;
    internal ushort reg;
}
internal class Microsoft.Cci.Pdb.SlotSym32 : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.SYM : Enum {
    public int value__;
    public static SYM S_END;
    public static SYM S_OEM;
    public static SYM S_REGISTER_ST;
    public static SYM S_CONSTANT_ST;
    public static SYM S_UDT_ST;
    public static SYM S_COBOLUDT_ST;
    public static SYM S_MANYREG_ST;
    public static SYM S_BPREL32_ST;
    public static SYM S_LDATA32_ST;
    public static SYM S_GDATA32_ST;
    public static SYM S_PUB32_ST;
    public static SYM S_LPROC32_ST;
    public static SYM S_GPROC32_ST;
    public static SYM S_VFTABLE32;
    public static SYM S_REGREL32_ST;
    public static SYM S_LTHREAD32_ST;
    public static SYM S_GTHREAD32_ST;
    public static SYM S_LPROCMIPS_ST;
    public static SYM S_GPROCMIPS_ST;
    public static SYM S_FRAMEPROC;
    public static SYM S_COMPILE2_ST;
    public static SYM S_MANYREG2_ST;
    public static SYM S_LPROCIA64_ST;
    public static SYM S_GPROCIA64_ST;
    public static SYM S_LOCALSLOT_ST;
    public static SYM S_PARAMSLOT_ST;
    public static SYM S_ANNOTATION;
    public static SYM S_GMANPROC_ST;
    public static SYM S_LMANPROC_ST;
    public static SYM S_RESERVED1;
    public static SYM S_RESERVED2;
    public static SYM S_RESERVED3;
    public static SYM S_RESERVED4;
    public static SYM S_LMANDATA_ST;
    public static SYM S_GMANDATA_ST;
    public static SYM S_MANFRAMEREL_ST;
    public static SYM S_MANREGISTER_ST;
    public static SYM S_MANSLOT_ST;
    public static SYM S_MANMANYREG_ST;
    public static SYM S_MANREGREL_ST;
    public static SYM S_MANMANYREG2_ST;
    public static SYM S_MANTYPREF;
    public static SYM S_UNAMESPACE_ST;
    public static SYM S_ST_MAX;
    public static SYM S_OBJNAME;
    public static SYM S_THUNK32;
    public static SYM S_BLOCK32;
    public static SYM S_WITH32;
    public static SYM S_LABEL32;
    public static SYM S_REGISTER;
    public static SYM S_CONSTANT;
    public static SYM S_UDT;
    public static SYM S_COBOLUDT;
    public static SYM S_MANYREG;
    public static SYM S_BPREL32;
    public static SYM S_LDATA32;
    public static SYM S_GDATA32;
    public static SYM S_PUB32;
    public static SYM S_LPROC32;
    public static SYM S_GPROC32;
    public static SYM S_REGREL32;
    public static SYM S_LTHREAD32;
    public static SYM S_GTHREAD32;
    public static SYM S_LPROCMIPS;
    public static SYM S_GPROCMIPS;
    public static SYM S_COMPILE2;
    public static SYM S_MANYREG2;
    public static SYM S_LPROCIA64;
    public static SYM S_GPROCIA64;
    public static SYM S_LOCALSLOT;
    public static SYM S_SLOT;
    public static SYM S_PARAMSLOT;
    public static SYM S_LMANDATA;
    public static SYM S_GMANDATA;
    public static SYM S_MANFRAMEREL;
    public static SYM S_MANREGISTER;
    public static SYM S_MANSLOT;
    public static SYM S_MANMANYREG;
    public static SYM S_MANREGREL;
    public static SYM S_MANMANYREG2;
    public static SYM S_UNAMESPACE;
    public static SYM S_PROCREF;
    public static SYM S_DATAREF;
    public static SYM S_LPROCREF;
    public static SYM S_ANNOTATIONREF;
    public static SYM S_TOKENREF;
    public static SYM S_GMANPROC;
    public static SYM S_LMANPROC;
    public static SYM S_TRAMPOLINE;
    public static SYM S_MANCONSTANT;
    public static SYM S_ATTR_FRAMEREL;
    public static SYM S_ATTR_REGISTER;
    public static SYM S_ATTR_REGREL;
    public static SYM S_ATTR_MANYREG;
    public static SYM S_SEPCODE;
    public static SYM S_LOCAL;
    public static SYM S_DEFRANGE;
    public static SYM S_DEFRANGE2;
    public static SYM S_SECTION;
    public static SYM S_COFFGROUP;
    public static SYM S_EXPORT;
    public static SYM S_CALLSITEINFO;
    public static SYM S_FRAMECOOKIE;
    public static SYM S_DISCARDED;
    public static SYM S_RECTYPE_MAX;
    public static SYM S_RECTYPE_LAST;
}
internal class Microsoft.Cci.Pdb.SYMTYPE : ValueType {
    internal ushort reclen;
    internal ushort rectyp;
}
internal class Microsoft.Cci.Pdb.ThreadSym32 : ValueType {
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ThunkSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 off;
    internal ushort seg;
    internal ushort len;
    internal byte ord;
    internal string name;
    internal Byte[] variant;
}
internal enum Microsoft.Cci.Pdb.TRAMP : Enum {
    public int value__;
    public static TRAMP trampIncremental;
    public static TRAMP trampBranchIsland;
}
internal class Microsoft.Cci.Pdb.TrampolineSym : ValueType {
    internal ushort trampType;
    internal ushort cbThunk;
    internal UInt32 offThunk;
    internal UInt32 offTarget;
    internal ushort sectThunk;
    internal ushort sectTarget;
}
internal enum Microsoft.Cci.Pdb.TYPE_ENUM : Enum {
    public int value__;
    public static TYPE_ENUM T_NOTYPE;
    public static TYPE_ENUM T_ABS;
    public static TYPE_ENUM T_SEGMENT;
    public static TYPE_ENUM T_VOID;
    public static TYPE_ENUM T_HRESULT;
    public static TYPE_ENUM T_32PHRESULT;
    public static TYPE_ENUM T_64PHRESULT;
    public static TYPE_ENUM T_PVOID;
    public static TYPE_ENUM T_PFVOID;
    public static TYPE_ENUM T_PHVOID;
    public static TYPE_ENUM T_32PVOID;
    public static TYPE_ENUM T_64PVOID;
    public static TYPE_ENUM T_CURRENCY;
    public static TYPE_ENUM T_NOTTRANS;
    public static TYPE_ENUM T_BIT;
    public static TYPE_ENUM T_PASCHAR;
    public static TYPE_ENUM T_CHAR;
    public static TYPE_ENUM T_32PCHAR;
    public static TYPE_ENUM T_64PCHAR;
    public static TYPE_ENUM T_UCHAR;
    public static TYPE_ENUM T_32PUCHAR;
    public static TYPE_ENUM T_64PUCHAR;
    public static TYPE_ENUM T_RCHAR;
    public static TYPE_ENUM T_32PRCHAR;
    public static TYPE_ENUM T_64PRCHAR;
    public static TYPE_ENUM T_WCHAR;
    public static TYPE_ENUM T_32PWCHAR;
    public static TYPE_ENUM T_64PWCHAR;
    public static TYPE_ENUM T_INT1;
    public static TYPE_ENUM T_32PINT1;
    public static TYPE_ENUM T_64PINT1;
    public static TYPE_ENUM T_UINT1;
    public static TYPE_ENUM T_32PUINT1;
    public static TYPE_ENUM T_64PUINT1;
    public static TYPE_ENUM T_SHORT;
    public static TYPE_ENUM T_32PSHORT;
    public static TYPE_ENUM T_64PSHORT;
    public static TYPE_ENUM T_USHORT;
    public static TYPE_ENUM T_32PUSHORT;
    public static TYPE_ENUM T_64PUSHORT;
    public static TYPE_ENUM T_INT2;
    public static TYPE_ENUM T_32PINT2;
    public static TYPE_ENUM T_64PINT2;
    public static TYPE_ENUM T_UINT2;
    public static TYPE_ENUM T_32PUINT2;
    public static TYPE_ENUM T_64PUINT2;
    public static TYPE_ENUM T_LONG;
    public static TYPE_ENUM T_ULONG;
    public static TYPE_ENUM T_32PLONG;
    public static TYPE_ENUM T_32PULONG;
    public static TYPE_ENUM T_64PLONG;
    public static TYPE_ENUM T_64PULONG;
    public static TYPE_ENUM T_INT4;
    public static TYPE_ENUM T_32PINT4;
    public static TYPE_ENUM T_64PINT4;
    public static TYPE_ENUM T_UINT4;
    public static TYPE_ENUM T_32PUINT4;
    public static TYPE_ENUM T_64PUINT4;
    public static TYPE_ENUM T_QUAD;
    public static TYPE_ENUM T_32PQUAD;
    public static TYPE_ENUM T_64PQUAD;
    public static TYPE_ENUM T_UQUAD;
    public static TYPE_ENUM T_32PUQUAD;
    public static TYPE_ENUM T_64PUQUAD;
    public static TYPE_ENUM T_INT8;
    public static TYPE_ENUM T_32PINT8;
    public static TYPE_ENUM T_64PINT8;
    public static TYPE_ENUM T_UINT8;
    public static TYPE_ENUM T_32PUINT8;
    public static TYPE_ENUM T_64PUINT8;
    public static TYPE_ENUM T_OCT;
    public static TYPE_ENUM T_32POCT;
    public static TYPE_ENUM T_64POCT;
    public static TYPE_ENUM T_UOCT;
    public static TYPE_ENUM T_32PUOCT;
    public static TYPE_ENUM T_64PUOCT;
    public static TYPE_ENUM T_INT16;
    public static TYPE_ENUM T_32PINT16;
    public static TYPE_ENUM T_64PINT16;
    public static TYPE_ENUM T_UINT16;
    public static TYPE_ENUM T_32PUINT16;
    public static TYPE_ENUM T_64PUINT16;
    public static TYPE_ENUM T_REAL32;
    public static TYPE_ENUM T_32PREAL32;
    public static TYPE_ENUM T_64PREAL32;
    public static TYPE_ENUM T_REAL64;
    public static TYPE_ENUM T_32PREAL64;
    public static TYPE_ENUM T_64PREAL64;
    public static TYPE_ENUM T_REAL80;
    public static TYPE_ENUM T_32PREAL80;
    public static TYPE_ENUM T_64PREAL80;
    public static TYPE_ENUM T_REAL128;
    public static TYPE_ENUM T_32PREAL128;
    public static TYPE_ENUM T_64PREAL128;
    public static TYPE_ENUM T_CPLX32;
    public static TYPE_ENUM T_32PCPLX32;
    public static TYPE_ENUM T_64PCPLX32;
    public static TYPE_ENUM T_CPLX64;
    public static TYPE_ENUM T_32PCPLX64;
    public static TYPE_ENUM T_64PCPLX64;
    public static TYPE_ENUM T_CPLX80;
    public static TYPE_ENUM T_32PCPLX80;
    public static TYPE_ENUM T_64PCPLX80;
    public static TYPE_ENUM T_CPLX128;
    public static TYPE_ENUM T_32PCPLX128;
    public static TYPE_ENUM T_64PCPLX128;
    public static TYPE_ENUM T_BOOL08;
    public static TYPE_ENUM T_32PBOOL08;
    public static TYPE_ENUM T_64PBOOL08;
    public static TYPE_ENUM T_BOOL16;
    public static TYPE_ENUM T_32PBOOL16;
    public static TYPE_ENUM T_64PBOOL16;
    public static TYPE_ENUM T_BOOL32;
    public static TYPE_ENUM T_32PBOOL32;
    public static TYPE_ENUM T_64PBOOL32;
    public static TYPE_ENUM T_BOOL64;
    public static TYPE_ENUM T_32PBOOL64;
    public static TYPE_ENUM T_64PBOOL64;
}
internal class Microsoft.Cci.Pdb.TYPTYPE : ValueType {
    internal ushort len;
    internal ushort leaf;
}
internal class Microsoft.Cci.Pdb.UdtSym : ValueType {
    internal UInt32 typind;
    internal string name;
}
internal class Microsoft.Cci.Pdb.UnamespaceSym : ValueType {
    internal string name;
}
internal class Microsoft.Cci.Pdb.UsedNamespace : object {
    private IName alias;
    private IName namespaceName;
    public IName Alias { get; }
    public IName NamespaceName { get; }
    internal UsedNamespace(IName alias, IName namespaceName);
    public sealed virtual IName get_Alias();
    public sealed virtual IName get_NamespaceName();
}
internal class Microsoft.Cci.Pdb.VpathSym32 : ValueType {
    internal UInt32 root;
    internal UInt32 path;
    internal UInt32 off;
    internal ushort seg;
}
internal class Microsoft.Cci.Pdb.WithSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string expr;
}
internal class Microsoft.Cci.Pdb.XFixupData : ValueType {
    internal ushort wType;
    internal ushort wExtra;
    internal UInt32 rva;
    internal UInt32 rvaTarget;
}
public class Microsoft.Cci.PdbReader : object {
    private Stream pdbStream;
    private IMetadataHost host;
    private Dictionary`2<UInt32, PdbFunction> pdbFunctionMap;
    private List`1<StreamReader> sourceFilesOpenedByReader;
    private Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping;
    private string sourceServerData;
    private bool loadSource;
    private int age;
    private Guid guid;
    private Dictionary`2<PdbSource, PdbSourceDocument> documentCache;
    public string SourceServerData { get; }
    public string DebugInformationVersion { get; }
    public PdbReader(Stream pdbStream, IMetadataHost host, bool loadSource);
    public PdbReader(Stream pdbStream, IMetadataHost host);
    private void ObjectInvariant();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Close();
    [IteratorStateMachineAttribute("Microsoft.Cci.PdbReader/<GetPrimarySourceLocationsFor>d__15")]
public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(IEnumerable`1<ILocation> locations);
    [IteratorStateMachineAttribute("Microsoft.Cci.PdbReader/<GetClosestPrimarySourceLocationsFor>d__16")]
public IEnumerable`1<IPrimarySourceLocation> GetClosestPrimarySourceLocationsFor(IEnumerable`1<ILocation> locations);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsFor(ILocation location);
    [IteratorStateMachineAttribute("Microsoft.Cci.PdbReader/<GetClosestPrimarySourceLocationsFor>d__18")]
public IEnumerable`1<IPrimarySourceLocation> GetClosestPrimarySourceLocationsFor(ILocation location);
    [IteratorStateMachineAttribute("Microsoft.Cci.PdbReader/<GetPrimarySourceLocationsForToken>d__19")]
public IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsForToken(UInt32 token);
    public sealed virtual IEnumerable`1<IPrimarySourceLocation> GetPrimarySourceLocationsForDefinitionOf(ILocalDefinition localDefinition);
    public sealed virtual string GetSourceNameFor(ILocalDefinition localDefinition, Boolean& isCompilerGenerated);
    private PdbSlot GetSlotFor(PdbScope[] pdbScopes, UInt32 index);
    public sealed virtual IEnumerable`1<ILocalScope> GetIteratorScopes(IMethodBody methodBody);
    public sealed virtual IEnumerable`1<ILocalScope> GetLocalScopes(IMethodBody methodBody);
    private PdbFunction GetPdbFunctionFor(IMethodBody methodBody);
    private static UInt32 GetTokenFor(IMethodBody methodBody);
    private static ITokenDecoder GetTokenDecoderFor(IMethodBody methodBody, UInt32& methodToken);
    private PdbFunction GetPdbFunctionFor(ILocalDefinition localDefinition);
    private void FillInScopesAndSubScopes(IMethodBody methodBody, PdbScope[] pdbScopes, List`1<ILocalScope> scopes);
    [IteratorStateMachineAttribute("Microsoft.Cci.PdbReader/<GetConstantsInScope>d__30")]
public virtual IEnumerable`1<ILocalDefinition> GetConstantsInScope(ILocalScope scope);
    [IteratorStateMachineAttribute("Microsoft.Cci.PdbReader/<GetVariablesInScope>d__31")]
public sealed virtual IEnumerable`1<ILocalDefinition> GetVariablesInScope(ILocalScope scope);
    public sealed virtual IEnumerable`1<INamespaceScope> GetNamespaceScopes(IMethodBody methodBody);
    private List`1<INamespaceScope> GetNamespaceScopes(UInt16[] usingCounts, PdbScope pdbScope);
    private IUsedNamespace GetUsedNamespace(string namespaceName);
    public sealed virtual bool IsIterator(IMethodBody methodBody);
    public sealed virtual ISynchronizationInformation GetSynchronizationInformation(IMethodBody methodBody);
    public ILocation LocationWithSmallerOffset(ILocation location1, ILocation location2);
    private IPrimarySourceLocation MapMethodBodyLocationToSourceLocation(IILLocation mbLocation, bool exact);
    private PdbSourceDocument GetPrimarySourceDocumentFor(PdbSource pdbSourceFile);
    public string get_SourceServerData();
    public string get_DebugInformationVersion();
}
public class Microsoft.Cci.PdbWriter : object {
    private string fileName;
    private ISourceLocationProvider sourceLocationProvider;
    private UInt32 currentMethodToken;
    private ISymUnmanagedWriter5 symWriter5;
    private bool emitTokenSourceInfo;
    private IPrimarySourceDocument currentDocument;
    private List`1<UInt32> offsets;
    private List`1<UInt32> startLines;
    private List`1<UInt32> startColumns;
    private List`1<UInt32> endLines;
    private List`1<UInt32> endColumns;
    private Dictionary`2<string, ISymUnmanagedDocumentWriter> documentMap;
    private ISymUnmanagedWriter2 symWriter;
    private ISymUnmanagedWriter2 SymWriter { get; }
    public PdbWriter(string fileName, ISourceLocationProvider sourceLocationProvider, bool emitTokenSourceInfo);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void Close();
    public sealed virtual void CloseMethod(UInt32 offset);
    public sealed virtual void CloseScope(UInt32 offset);
    public sealed virtual void CloseTokenSourceLocationsScope();
    public sealed virtual void DefineTokenSourceLocation(UInt32 token, ILocation location);
    public sealed virtual void OpenTokenSourceLocationsScope();
    public sealed virtual void DefineCustomMetadata(string name, Byte[] metadata);
    public sealed virtual void DefineLocalConstant(string name, object value, UInt32 contantSignatureToken);
    public sealed virtual void DefineLocalVariable(UInt32 index, string name, bool isCompilerGenerated, UInt32 localVariablesSignatureToken);
    public sealed virtual void DefineSequencePoint(ILocation location, UInt32 offset);
    private void DefineSequencePointsForCurrentDocument();
    private ISymUnmanagedDocumentWriter GetDocumentWriterFor(IPrimarySourceDocument document);
    public sealed virtual PeDebugDirectory GetDebugDirectory();
    public sealed virtual void OpenMethod(UInt32 methodToken);
    public sealed virtual void OpenScope(UInt32 offset);
    public sealed virtual void SetEntryPoint(UInt32 entryMethodToken);
    public sealed virtual void SetMetadataEmitter(object metadataEmitter);
    private ISymUnmanagedWriter2 get_SymWriter();
    public sealed virtual void UsingNamespace(string fullName);
}
public class Microsoft.Cci.PeDebugDirectory : object {
    public UInt32 Characteristics;
    public UInt32 TimeDateStamp;
    public ushort MajorVersion;
    public ushort MinorVersion;
    public UInt32 Type;
    public UInt32 SizeOfData;
    public UInt32 AddressOfRawData;
    public UInt32 PointerToRawData;
    public Byte[] Data;
}
public class Microsoft.Cci.PEFileData : object {
    public UInt32 timeStamp;
    public UInt32[] wellKnownTypes;
    public UInt32 offsetToMethodDefTable;
    public UInt32 methodDefRecordSize;
    public UInt32 methodDefCount;
    public UInt32 offsetToFieldRvaTable;
    public UInt32 fieldRvaRecordSize;
    public UInt32 fieldRvaCount;
    public UInt32 ilImageSize;
    public TargetProcessorArchitecture targetProcessorArchitecture;
}
public class Microsoft.Cci.PeReader : object {
    internal MetadataReaderErrorsReporter ErrorsReporter;
    internal IMetadataReaderHost metadataReaderHost;
    private Hashtable`1<Module> InternedIdToModuleMap;
    private Assembly coreAssembly;
    internal IName Value__;
    internal IName AsyncCallback;
    internal IName ParamArrayAttribute;
    internal IName IAsyncResult;
    internal IName ICloneable;
    internal IName RuntimeArgumentHandle;
    internal IName RuntimeFieldHandle;
    internal IName RuntimeMethodHandle;
    internal IName RuntimeTypeHandle;
    internal IName ArgIterator;
    internal IName IList;
    internal IName Mscorlib;
    internal IName System_Runtime;
    internal IName _Deleted_;
    internal Assembly CoreAssembly { get; }
    public IEnumerable`1<IModule> OpenedModules { get; }
    public PeReader(IMetadataReaderHost metadataReaderHost);
    internal void RegisterCoreAssembly(Assembly coreAssembly);
    internal Assembly get_CoreAssembly();
    private void OpenMemberModules(IBinaryDocument binaryDocument, Assembly assembly);
    private void LoadedModule(Module module);
    public IAssembly OpenAssembly(IBinaryDocument binaryDocument, AssemblyIdentity& assemblyIdentity);
    public IModule OpenModule(IBinaryDocument binaryDocument, ModuleIdentity& moduleIdentity);
    public IAssembly OpenAssembly(IBinaryDocument binaryDocument);
    public IModule OpenModule(IBinaryDocument binaryDocument);
    public IModule OpenSnapshot(IBinaryDocument binaryDocument);
    internal Assembly LookupAssembly(IModule referringModule, AssemblyIdentity unifiedAssemblyIdentity);
    internal Module LookupModule(IModule referringModule, ModuleIdentity moduleIdentity);
    public AssemblyIdentity GetAssemblyIdentifier(IBinaryDocument binaryDocument);
    internal AssemblyIdentity GetAssemblyIdentifier(PEFileReader peFileReader);
    internal ModuleIdentity GetModuleIdentifier(PEFileReader peFileReader);
    internal ModuleIdentity GetModuleIdentifier(PEFileReader peFileReader, AssemblyIdentity containingAssemblyIdentity);
    [IteratorStateMachineAttribute("Microsoft.Cci.PeReader/<get_OpenedModules>d__36")]
public IEnumerable`1<IModule> get_OpenedModules();
    public IModule FindModule(ModuleIdentity moduleIdentity);
    public IAssembly FindAssembly(AssemblyIdentity unifiedAssemblyIdentity);
    public ITypeDefinition ResolveSerializedTypeName(string typeName, IAssembly assembly);
}
[FlagsAttribute]
public enum Microsoft.Cci.PESectionCharacteristics : Enum {
    public int value__;
    public static PESectionCharacteristics ContainsExecutableCode;
    public static PESectionCharacteristics ContainsInitializedData;
    public static PESectionCharacteristics ContainsUninitializedData;
    public static PESectionCharacteristics IsExecutable;
    public static PESectionCharacteristics IsReadable;
    public static PESectionCharacteristics IsWritable;
}
public enum Microsoft.Cci.PESectionKind : Enum {
    public int value__;
    public static PESectionKind Illegal;
    public static PESectionKind ConstantData;
    public static PESectionKind CoverageData;
    public static PESectionKind ExtendedData;
    public static PESectionKind StaticData;
    public static PESectionKind Text;
    public static PESectionKind ThreadLocalStorage;
}
public class Microsoft.Cci.PeWriter : object {
    private Dictionary`2<AssemblyIdentity, UInt32> assemblyRefIndex;
    private List`1<IAssemblyReference> assemblyRefList;
    private Dictionary`2<Byte[], UInt32> blobIndex;
    private BinaryWriter blobWriter;
    private ClrHeader clrHeader;
    private BinaryWriter coverageDataWriter;
    private SectionHeader coverSection;
    private HashtableForUintValues`1<ICustomAttribute> customAtributeSignatureIndex;
    private CustomSectionProvider[] customSectionProviders;
    private PeDebugDirectory debugDirectory;
    private bool emitRuntimeStartupStub;
    private BinaryWriter extendedDataWriter;
    private SectionHeader extendedDataSection;
    private List`1<IEventDefinition> eventDefList;
    private MemoryStream emptyStream;
    private Hashtable exportedTypeIndex;
    private List`1<ITypeReference> exportedTypeList;
    private Hashtable fieldDefIndex;
    private List`1<IFieldDefinition> fieldDefList;
    private HashtableForUintValues`1<IFieldReference> fieldSignatureIndex;
    private Hashtable fileRefIndex;
    private List`1<IFileReference> fileRefList;
    private UInt32 offsetToMethodDefTable;
    private UInt32 offsetToFieldRvaTable;
    private List`1<IGenericParameter> genericParameterList;
    private MemoryStream headerStream;
    private IMetadataHost host;
    private UInt32 localDefSignatureToken;
    private HashtableForUintValues`1<ILocalDefinition> localDefIndex;
    private ILocalScopeProvider localScopeProvider;
    private HashtableForUintValues`1<IMarshallingInformation> marshallingDescriptorIndex;
    private HashtableForUintValues`1<ITypeMemberReference> memberRefInstanceIndex;
    private Dictionary`2<ITypeMemberReference, UInt32> memberRefStructuralIndex;
    internal List`1<ITypeMemberReference> memberRefList;
    private MemoryStream metadataHeaderStream;
    private HashtableForUintValues`1<IMethodDefinition> methodBodyIndex;
    private Hashtable methodDefIndex;
    internal List`1<IMethodDefinition> methodDefList;
    private List`1<IMethodImplementation> methodImplList;
    private HashtableForUintValues`1<IGenericMethodInstanceReference> methodInstanceSignatureIndex;
    private HashtableForUintValues`1<IGenericMethodInstanceReference> methodSpecInstanceIndex;
    private Dictionary`2<IGenericMethodInstanceReference, UInt32> methodSpecStructuralIndex;
    private List`1<IGenericMethodInstanceReference> methodSpecList;
    private MemoryStreamList methodStream;
    private IModule module;
    private HashtableForUintValues`1<ModuleIdentity> moduleRefIndex;
    private List`1<ModuleIdentity> moduleRefList;
    private NtHeader ntHeader;
    private HashtableForUintValues`1<ISignature> parameterListIndex;
    private List`1<IParameterDefinition> parameterDefList;
    private IPdbWriter pdbWriter;
    private Stream peStream;
    private List`1<IPropertyDefinition> propertyDefList;
    private BinaryWriter rdataWriter;
    private SectionHeader relocSection;
    private SectionHeader resourceSection;
    private BinaryWriter resourceWriter;
    private BinaryWriter sdataWriter;
    private SectionHeader rdataSection;
    private SectionHeader sdataSection;
    private SectionHeader[] customSectionHeaders;
    private SectionHeader[] uninterpretedSectionHeaders;
    private UInt32 sizeOfImage;
    private HashtableForUintValues`1<ISignature> signatureIndex;
    private Hashtable signatureStructuralIndex;
    private UInt32 sizeOfImportAddressTable;
    private ISourceLocationProvider sourceLocationProvider;
    private List`1<UInt32> standAloneSignatureList;
    private bool streamsAreComplete;
    private Dictionary`2<string, UInt32> stringIndex;
    private Hashtable stringIndexMap;
    private BinaryWriter stringWriter;
    private bool tableIndicesAreComplete;
    private UInt32[] tableSizes;
    private MemoryStream tableStream;
    private BinaryWriter textDataWriter;
    private SectionHeader textSection;
    private SectionHeader textDataSection;
    private SectionHeader textMethodBodySection;
    private SectionHeader tlsSection;
    private BinaryWriter tlsDataWriter;
    private UInt32 tokenOfFirstMethodWithDebugInfo;
    private IEnumerable`1<INamespaceScope> lastUsingInfo;
    private UInt32 tokenOfLastMethodWithUsingInfo;
    private Hashtable typeDefIndex;
    internal List`1<ITypeDefinition> typeDefList;
    private Hashtable typeRefIndex;
    private List`1<ITypeReference> typeRefList;
    private HashtableForUintValues`1<ITypeReference> typeSpecSignatureIndex;
    private HashtableForUintValues`1<ITypeReference> typeSpecInstanceIndex;
    private Dictionary`2<ITypeReference, UInt32> typeSpecStructuralIndex;
    internal List`1<ITypeReference> typeSpecList;
    private Dictionary`2<string, UInt32> userStringIndex;
    private BinaryWriter userStringWriter;
    private BinaryWriter win32ResourceWriter;
    private static Byte[] dosHeader;
    private static string needsEscaping;
    private MultiHashtable`1<INamespaceTypeDefinition> namespaceTypesByName;
    private byte blobIndexSize;
    private byte customAttributeTypeCodedIndexSize;
    private byte declSecurityCodedIndexSize;
    private byte eventDefIndexSize;
    private byte fieldDefIndexSize;
    private byte genericParamIndexSize;
    private byte hasConstantCodedIndexSize;
    private byte hasCustomAttributeCodedIndexSize;
    private byte hasFieldMarshallCodedIndexSize;
    private byte hasSemanticsCodedIndexSize;
    private byte implementationCodedIndexSize;
    private byte memberForwardedCodedIndexSize;
    private byte memberRefParentCodedIndexSize;
    private byte methodDefIndexSize;
    private byte methodDefOrRefCodedIndexSize;
    private byte moduleRefIndexSize;
    private byte parameterIndexSize;
    private byte propertyDefIndexSize;
    private byte resolutionScopeCodedIndexSize;
    private byte stringIndexSize;
    private byte typeDefIndexSize;
    private byte typeDefOrRefCodedIndexSize;
    private byte typeOrMethodDefCodedIndexSize;
    private List`1<AssemblyRefTableRow> assemblyRefTable;
    private UInt32 assemblyKey;
    private StringIdx assemblyName;
    private StringIdx assemblyCulture;
    private List`1<ClassLayoutRow> classLayoutTable;
    private List`1<ConstantRow> constantTable;
    private List`1<CustomAttributeRow> customAttributeTable;
    private List`1<DeclSecurityRow> declSecurityTable;
    private List`1<EventMapRow> eventMapTable;
    private List`1<EventRow> eventTable;
    private Hashtable`2<object, Hashtable> moduleToMap;
    private List`1<ExportedTypeRow> exportedTypeTable;
    private List`1<FieldLayoutRow> fieldLayoutTable;
    private List`1<FieldMarshalRow> fieldMarshalTable;
    private List`1<FieldRvaRow> fieldRvaTable;
    private List`1<FieldDefRow> fieldDefTable;
    private List`1<FileTableRow> fileTable;
    private List`1<GenericParamConstraintRow> genericParamConstraintTable;
    private List`1<GenericParamRow> genericParamTable;
    private List`1<ImplMapRow> implMapTable;
    private List`1<InterfaceImplRow> interfaceImplTable;
    private List`1<ManifestResourceRow> manifestResourceTable;
    private List`1<MemberRefRow> memberRefTable;
    private List`1<MethodImplRow> methodImplTable;
    private List`1<MethodSemanticsRow> methodSemanticsTable;
    private List`1<MethodSpecRow> methodSpecTable;
    private List`1<MethodRow> methodTable;
    private List`1<ModuleRefRow> moduleRefTable;
    private StringIdx moduleName;
    private List`1<NestedClassRow> nestedClassTable;
    private List`1<ParamRow> paramTable;
    private List`1<PropertyMapRow> propertyMapTable;
    private List`1<PropertyRow> propertyTable;
    private List`1<TypeDefRow> typeDefTable;
    private List`1<TypeRefRow> typeRefTable;
    private List`1<TypeSpecRow> typeSpecTable;
    private List`1<Byte[]> customDebugMetadataForCurrentMethod;
    private IEnumerator`1<ILocalScope> scopeEnumerator;
    private bool scopeEnumeratorIsValid;
    private Stack`1<ILocalScope> scopeStack;
    private static DateTime NineteenSeventy;
    private PeWriter(IModule module, IMetadataHost host, Stream peStream, ISourceLocationProvider sourceLocationProvider, ILocalScopeProvider localScopeProvider, IPdbWriter pdbWriter, CustomSectionProvider[] customSectionProviders);
    private static PeWriter();
    private void FoldStrings();
    public static void WritePeToStream(IModule module, IMetadataHost host, Stream stream);
    public static void WritePeToStream(IModule module, IMetadataHost host, Stream stream, ISourceLocationProvider sourceLocationProvider, ILocalScopeProvider localScopeProvider, IPdbWriter pdbWriter, CustomSectionProvider[] customSectionProviders);
    private static UInt32 Aligned(UInt32 position, UInt32 alignment);
    private UInt32 ComputeStrongNameSignatureSize();
    private UInt32 ComputeOffsetToDebugTable();
    private UInt32 ComputeOffsetToImportTable();
    private UInt32 ComputeOffsetToMetadata();
    private UInt32 ComputeSizeOfDebugTable(UInt32 offsetToMetadata);
    private UInt32 ComputeSizeOfMetadata();
    private UInt32 ComputeSizeOfVersionString();
    private static UInt32 ComputeSizeOfVersionString(Byte[] versionStringData);
    private UInt32 ComputeSizeOfMetadataTablesStream();
    private UInt32 ComputeSizeOfPeHeaders(ushort numberOfSections);
    private UInt32 ComputeSizeOfTextSection();
    private UInt32 ComputeSizeOfWin32Resources();
    private void CreateIndices();
    private void CreateUserStringIndices();
    private void CreateIndicesFor(ITypeDefinition typeDef);
    private void CreateIndicesFor(IMethodDefinition methodDef);
    private IEnumerable`1<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef);
    private List`1<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef, ITypeDefinition owner);
    private void CreateInitialAssemblyRefIndex();
    private void CreateInitialExportedTypeIndex();
    private void CreateInitialFileRefIndex();
    private void CreateInitialTypeRefIndex();
    private void FillInClrHeader();
    private void FillInNtHeader();
    private void FillInSectionHeaders();
    private PEFileData GetPEFileData();
    internal UInt32 GetAssemblyRefIndex(IAssemblyReference assemblyReference);
    internal UInt32 GetModuleRefIndex(IModuleReference moduleReference);
    private UInt32 GetBlobIndex(Byte[] blob);
    private UInt32 GetBlobIndex(object value);
    private UInt32 GetBlobIndex(string str);
    private UInt32 GetClrHeaderFlags();
    private UInt32 GetCustomAttributeSignatureIndex(ICustomAttribute customAttribute);
    private UInt32 GetCustomAttributeTypeCodedIndex(IMethodReference methodReference);
    private UInt32 GetDataOffset(ISectionBlock sectionBlock);
    internal static IUnitReference GetDefiningUnitReference(ITypeReference typeReference);
    private static ushort GetEventFlags(IEventDefinition eventDef);
    private UInt32 GetExportedTypeIndex(ITypeReference typeReference);
    private UInt32 GetFieldDefIndex(IFieldReference field);
    private static ushort GetFieldFlags(IFieldDefinition fieldDef);
    internal UInt32 GetFieldSignatureIndex(IFieldReference fieldReference);
    internal UInt32 GetFieldToken(IFieldReference fieldReference);
    internal UInt32 GetFileRefIndex(IFileReference fileReference);
    private UInt32 GetFileRefIndex(IModuleReference mref);
    public static ushort GetGenericParamFlags(IGenericParameter genPar);
    private UInt32 GetImplementationCodedIndex(INamespaceTypeReference nsRef);
    private UInt32 GetManagedResourceOffset(IResourceReference resourceReference);
    private static string GetMangledName(INamedTypeReference namedType);
    private static void AppendMangledAndEscapedName(StringBuilder mangledName, INamedTypeReference namedType);
    private static string GetMangledAndEscapedName(INamedTypeReference namedType);
    private static ushort GetMappingFlags(IPlatformInvokeInformation platformInvokeInformation);
    internal UInt32 GetMemberRefIndex(ITypeMemberReference memberRef);
    internal UInt32 GetMemberRefParentCodedIndex(ITypeMemberReference memberRef);
    private UInt32 GetMethodDefIndex(IMethodReference method);
    private static bool IsTypeSpecification(ITypeReference typeReference);
    internal UInt32 GetMethodDefOrRefCodedIndex(IMethodReference methodReference);
    public static ushort GetMethodFlags(IMethodDefinition methodDef);
    public static ushort GetMethodImplementationFlags(IMethodDefinition methodDef);
    internal UInt32 GetMethodInstanceSignatureIndex(IGenericMethodInstanceReference methodInstanceReference);
    private UInt32 GetMethodRefTokenFor(IArrayTypeReference arrayTypeReference, OperationCode operationCode);
    private static ushort GetParameterIndex(IParameterDefinition parameterDefinition);
    private UInt32 GetMarshallingDescriptorIndex(IMarshallingInformation marshallingInformation);
    private UInt32 GetMemberRefSignatureIndex(ITypeMemberReference memberRef);
    internal UInt32 GetMethodSignatureIndex(IMethodReference methodReference);
    private UInt32 GetGenericMethodInstanceIndex(IGenericMethodInstanceReference genericMethodInstanceReference);
    private UInt32 GetMethodSpecIndex(IGenericMethodInstanceReference methodSpec);
    private UInt32 GetCorrespondingMethodToken(IMethodDefinition methodDefinition);
    private ITypeDefinition GetCorrespondingType(ITypeDefinition typeDefinition);
    private bool NamespaceNamesAreTheSame(IUnitNamespace namespaceDefinition1, IUnitNamespace namespaceDefinition2);
    private KeyedValuesEnumerable<INamespaceTypeDefinition> GetNamespaceTypesNamed(IName name);
    internal UInt32 GetMethodToken(IMethodReference methodReference);
    private static ushort GetParameterFlags(IParameterDefinition parDef);
    private UInt32 GetPermissionSetIndex(IEnumerable`1<ICustomAttribute> permissionSet);
    private static ushort GetPropertyFlags(IPropertyDefinition propertyDef);
    private UInt32 GetPropertySignatureIndex(IPropertyDefinition propertyDef);
    private UInt32 GetResolutionScopeCodedIndex(ITypeReference typeReference);
    private UInt32 GetResolutionScopeCodedIndex(IUnitReference unitReference);
    private static UInt32 GetRva(SectionHeader sectionHeader, UInt32 offset);
    private SectionHeader GetSection(PESectionKind section);
    private UInt32 GetStandaloneSignatureToken(ILocalDefinition localConstant);
    private UInt32 GetStandaloneSignatureToken(IFunctionPointerTypeReference functionPointerTypeReference);
    private StringIdx GetStringIndex(string str);
    private static byte GetTypeCodeByteFor(object val);
    public static UInt32 GetTypeDefFlags(ITypeDefinition typeDef);
    private UInt32 GetTypeDefOrRefCodedIndex(ITypeReference typeReference);
    private static ushort GetTypeMemberVisibilityFlags(ITypeDefinitionMember member);
    private UInt32 GetTypeOrMethodDefCodedIndex(IGenericParameter genPar);
    private UInt32 GetTypeRefIndex(ITypeReference typeReference);
    private UInt32 GetTypeSpecIndex(ITypeReference typeReference);
    internal UInt32 GetTypeSpecSignatureIndex(ITypeReference typeReference);
    internal void RecordTypeReference(ITypeReference typeReference);
    internal UInt32 GetTypeToken(ITypeReference typeReference);
    private UInt32 GetUserStringToken(string str);
    private void SerializeCustomModifier(ICustomModifier customModifier, BinaryWriter writer);
    private void SerializeGeneralMetadataHeader(BinaryWriter writer);
    private static void SerializeStreamHeader(UInt32& offsetFromStartOfMetadata, UInt32 sizeOfStreamHeap, string streamName, BinaryWriter writer);
    private UInt32 SerializeLocalVariableSignatureAndReturnToken(IMethodBody methodBody);
    private void SerializeMetadata();
    private void SerializeMetadataTables();
    private void ComputeColumnSizes();
    private bool IndexDoesNotFit(byte numberOfBits, TableIndices[] tables);
    private void PopulateTableRows();
    private void PopulateAssemblyRefTableRows();
    private void PopulateAssemblyTableRows();
    private void PopulateClassLayoutTableRows();
    private void PopulateConstantTableRows();
    private void PopulateCustomAttributeTableRows();
    private void AddAssemblyAttributesToTable(IAssembly assembly, UInt32 tag);
    private void AddModuleAttributesToTable(IModule module, UInt32 tag);
    private void AddCustomAttributesToTable(List`1<ParentType> parentList, UInt32 tag);
    private void PopulateDeclSecurityTableRows();
    private void PopulateDeclSecurityTableRowsFor(UInt32 parent, IEnumerable`1<ISecurityAttribute> attributes);
    private void PopulateEventMapTableRows();
    private void PopulateEventTableRows();
    private void PopulateExportedTypeTableRows();
    private UInt32 GetExternalTypeToken(ITypeDefinition typeDefinition);
    private Hashtable GetTypeTokenMapFor(IModule module);
    private void PopulateFieldLayoutTableRows();
    private void PopulateFieldMarshalTableRows();
    private void PopulateFieldRvaTableRows();
    private void PopulateFieldTableRows();
    private void PopulateFileTableRows();
    private void PopulateGenericParamConstraintTableRows();
    private void PopulateGenericParamTableRows();
    private void PopulateImplMapTableRows();
    private void PopulateInterfaceImplTableRows();
    private void PopulateManifestResourceTableRows();
    private void PopulateMemberRefTableRows();
    private void PopulateMethodImplTableRows();
    private void PopulateMethodSemanticsTableRows();
    private void PopulateMethodSpecTableRows();
    private void PopulateMethodTableRows();
    private void PopulateModuleRefTableRows();
    private void PopulateModuleTableRows();
    private void PopulateNestedClassTableRows();
    private void PopulateParamTableRows();
    private void PopulatePropertyMapTableRows();
    private void PopulatePropertyTableRows();
    private void PopulateStandAloneSigTableRows();
    private void PopulateTypeDefTableRows();
    private void PopulateTypeRefTableRows();
    private void PopulateTypeSpecTableRows();
    private void SerializeTablesHeader(BinaryWriter writer);
    private UInt32 ComputeSizeOfTablesHeader();
    private void ComputeValidAndSortedMasks(UInt64& validTables, UInt64& sortedTables);
    private void SerializeTableSizes(BinaryWriter writer);
    private static void SerializeMetadataConstantValue(object value, BinaryWriter writer);
    private void SerializeModuleTable(BinaryWriter writer);
    private void SerializeTypeRefTable(BinaryWriter writer);
    private void SerializeTypeDefTable(BinaryWriter writer);
    private void SerializeFieldTable(BinaryWriter writer);
    private void SerializeIndex(BinaryWriter writer, StringIdx index, byte indexSize);
    private static void SerializeIndex(BinaryWriter writer, UInt32 index, byte indexSize);
    private void SerializeMethodTable(BinaryWriter writer);
    private void SerializeParamTable(BinaryWriter writer);
    private void SerializeInterfaceImplTable(BinaryWriter writer);
    private void SerializeMemberRefTable(BinaryWriter writer);
    private void SerializeConstantTable(BinaryWriter writer);
    private void SerializeCustomAttributeTable(BinaryWriter writer);
    private void SerializeFieldMarshalTable(BinaryWriter writer);
    private void SerializeDeclSecurityTable(BinaryWriter writer);
    private void SerializeClassLayoutTable(BinaryWriter writer);
    private void SerializeFieldLayoutTable(BinaryWriter writer);
    private void SerializeStandAloneSigTable(BinaryWriter writer);
    private void SerializeEventMapTable(BinaryWriter writer);
    private void SerializeEventTable(BinaryWriter writer);
    private void SerializePropertyMapTable(BinaryWriter writer);
    private void SerializePropertyTable(BinaryWriter writer);
    private void SerializeMethodSemanticsTable(BinaryWriter writer);
    private void SerializeMethodImplTable(BinaryWriter writer);
    private void SerializeModuleRefTable(BinaryWriter writer);
    private void SerializeTypeSpecTable(BinaryWriter writer);
    private void SerializeImplMapTable(BinaryWriter writer);
    private void SerializeFieldRvaTable(BinaryWriter writer);
    private void SerializeAssemblyTable(BinaryWriter writer);
    private void SerializeAssemblyRefTable(BinaryWriter writer);
    private void SerializeFileTable(BinaryWriter writer);
    private void SerializeExportedTypeTable(BinaryWriter writer);
    private void SerializeManifestResourceTable(BinaryWriter writer);
    private void SerializeNestedClassTable(BinaryWriter writer);
    private void SerializeGenericParamTable(BinaryWriter writer);
    private void SerializeMethodSpecTable(BinaryWriter writer);
    private void SerializeGenericParamConstraintTable(BinaryWriter writer);
    private void SerializeMethodBodies();
    private void SerializeMethodBody(IMethodBody methodBody, BinaryWriter writer);
    private void SerializeReferenceToFirstMethod(IMethodBody methodBody);
    private void SerializeReferenceToLastMethodWithUsingInfo();
    private bool DebuggerShouldHideMethod(IMethodBody methodBody);
    private void SerializeNamespaceScopes(IMethodBody methodBody);
    private void SerializeIteratorLocalScopes(IMethodBody methodBody);
    private void SerializeCustomDebugMetadata();
    private void SerializeSynchronizationInformation(IMethodBody methodBody);
    private void SerializeNamespaceScopeMetadata(IMethodBody methodBody);
    private void SerializeReferenceToIteratorClass(IMethodBody methodBody);
    private BinaryWriter SerializeMethodBodyIL(IMethodBody methodBody);
    private void EmitPdbInformationFor(IOperation operation);
    private void Initialize(ILocalScope currentScope);
    private void SerializeMethodBodyExceptionHandlerTable(IMethodBody methodBody, UInt32 numberOfExceptionHandlers, BinaryWriter writer);
    private void SerializeExceptionInformation(IOperationExceptionInformation exceptionInfo, bool useSmallExceptionHeaders, BinaryWriter writer);
    private static bool MayUseSmallExceptionHeaders(UInt32 numberOfExceptionHandlers, IEnumerable`1<IOperationExceptionInformation> exceptionInfos);
    private void SerializeParameterInformation(IParameterTypeInformation parameterTypeInformation, BinaryWriter writer);
    private void SerializeFieldSignature(IFieldReference fieldReference, BinaryWriter writer);
    private void SerializeGenericMethodInstanceSignature(BinaryWriter writer, IGenericMethodInstanceReference genericMethodInstanceReference);
    private void SerializeCustomAttributeSignature(ICustomAttribute customAttribute, bool writeOnlyNamedArguments, BinaryWriter writer);
    private void SerializeMetadataExpression(BinaryWriter writer, IMetadataExpression expression);
    private void SerializeMarshallingDescriptor(IMarshallingInformation marshallingInformation, BinaryWriter writer);
    private void SerializeTypeName(ITypeReference typeReference, BinaryWriter writer);
    private string GetSerializedTypeName(ITypeReference typeReference, bool omitTypeArguments);
    private void AppendGetSerializedTypeName(StringBuilder sb, ITypeReference typeReference, bool omitTypeArguments);
    private string GetSerializedTypeName(ITypeReference typeReference, Boolean& isAssemblyQualified, bool omitTypeArguments);
    private void GetSerializedTypeNameWorker(StringBuilder sb, ITypeReference typeReference, Boolean& isAssemblyQualified, bool omitTypeArguments);
    private void AppendSerializedTypeArguments(StringBuilder sb, IGenericTypeInstanceReference instance);
    private void AppendAssemblyQualifierIfNecessary(StringBuilder sb, ITypeReference typeReference, Boolean& isAssemQualified);
    private void AppendSerializedTypeName(StringBuilder sb, ITypeReference type, Boolean& isAssemQualified);
    private void SerializePermissionSet(IEnumerable`1<ICustomAttribute> permissionSet, BinaryWriter writer);
    private void SerializeSignature(ISignature signature, ushort genericParameterCount, IEnumerable`1<IParameterTypeInformation> extraArgumentTypes, BinaryWriter writer);
    private void SerializeTypeReference(ITypeReference typeReference, BinaryWriter writer);
    private void SerializeTypeReference(ITypeReference typeReference, BinaryWriter writer, bool noTokens);
    private static UInt32 GetNumberOfInheritedTypeParameters(ITypeReference type);
    private void GetConsolidatedTypeArguments(List`1& consolidatedTypeArguments, ITypeReference typeReference);
    private static ITypeReference GetUninstantiatedGenericType(ITypeReference typeReference);
    private void SerializeWin32Resources();
    private void WriteDirectory(Directory directory, BinaryWriter writer, UInt32 offset, UInt32 level, UInt32 sizeOfDirectoryTree, UInt32 virtualAddressBase, BinaryWriter dataWriter);
    private static UInt32 SizeOfDirectory(Directory directory);
    private void WriteHeaders();
    private static void WriteSectionHeader(SectionHeader sectionHeader, BinaryWriter writer);
    private void WriteTextSection();
    private void WriteImportAddressTable();
    private void WriteImportTable();
    private void WriteNameTable();
    private void WriteClrHeader();
    private void WriteIL();
    private void WriteTextData();
    private void WriteSpaceForHash();
    private void WriteMetadata();
    private void WriteManagedResources();
    private void WriteDebugTable();
    private void WriteRuntimeStartupStub();
    private void WriteCoverSection();
    private void WriteExtendedDataSection();
    private void WriteRdataSection();
    private void WriteSdataSection();
    private void WriteRelocSection();
    private void WriteResourceSection();
    private void WriteTlsSection();
    private void WriteCustomSections();
    private void WriteUninterpretedSections();
    public sealed virtual UInt32 GetTokenFor(ITypeReference typeReference);
    public sealed virtual UInt32 GetTokenFor(IFieldReference field);
    public sealed virtual UInt32 GetTokenFor(IMethodReference method);
    public sealed virtual UInt32 GetTokenFor(string str);
}
internal class Microsoft.Cci.PeWriterInternal.ByteArrayComparer : object {
    public sealed virtual bool Equals(Byte[] x, Byte[] y);
    public sealed virtual int GetHashCode(Byte[] x);
}
internal class Microsoft.Cci.PeWriterInternal.ClrHeader : object {
    internal ushort majorRuntimeVersion;
    internal ushort minorRuntimeVersion;
    internal DirectoryEntry metaData;
    internal UInt32 flags;
    internal UInt32 entryPointToken;
    internal DirectoryEntry resources;
    internal DirectoryEntry strongNameSignature;
    internal DirectoryEntry codeManagerTable;
    internal DirectoryEntry vtableFixups;
    internal DirectoryEntry exportAddressTableJumps;
}
internal class Microsoft.Cci.PeWriterInternal.COR_FIELD_OFFSET : ValueType {
    public UInt32 ridOfField;
    public UInt32 ulOffset;
    internal COR_FIELD_OFFSET(object dummy);
}
internal class Microsoft.Cci.PeWriterInternal.DirectoryEntry : ValueType {
    internal UInt32 RelativeVirtualAddress;
    internal UInt32 Size;
}
internal class Microsoft.Cci.PeWriterInternal.DummyReturnValueParameter : object {
    private IMethodDefinition containingMethod;
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public ISignature ContainingSignature { get; }
    public IMetadataConstant Constant { get; }
    public IEnumerable`1<ICustomModifier> CustomModifiers { get; }
    public IMetadataConstant DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public ushort Index { get; }
    public bool IsIn { get; }
    public bool IsByReference { get; }
    public bool IsModified { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsParameterArray { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public IName Name { get; }
    public ITypeReference ParamArrayElementType { get; }
    public ITypeReference Type { get; }
    internal DummyReturnValueParameter(IMethodDefinition containingMethod);
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual IMetadataConstant get_Constant();
    public sealed virtual IEnumerable`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual IMetadataConstant get_DefaultValue();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual ushort get_Index();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsModified();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
    public sealed virtual bool get_IsParameterArray();
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual IName get_Name();
    public sealed virtual ITypeReference get_ParamArrayElementType();
    public sealed virtual ITypeReference get_Type();
}
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
internal interface Microsoft.Cci.PeWriterInternal.IMetaDataEmit {
    public abstract virtual void SetModuleProps(string szName);
    public abstract virtual void Save(string szFile, UInt32 dwSaveFlags);
    public abstract virtual void SaveToStream(Void* pIStream, UInt32 dwSaveFlags);
    public abstract virtual UInt32 GetSaveSize(UInt32 fSave);
    public abstract virtual UInt32 DefineTypeDef(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    public abstract virtual UInt32 DefineNestedType(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements, UInt32 tdEncloser);
    public abstract virtual void SetHandler(object pUnk);
    public abstract virtual UInt32 DefineMethod(UInt32 td, Char* zName, UInt32 dwMethodFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public abstract virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, Char* szName);
    public abstract virtual UInt32 DefineImportType(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public abstract virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, Byte* pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 DefineImportMember(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public abstract virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    public abstract virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, COR_FIELD_OFFSET* rFieldOffsets, UInt32 ulClassSize);
    public abstract virtual void DeleteClassLayout(UInt32 td);
    public abstract virtual void SetFieldMarshal(UInt32 tk, Byte* pvNativeType, UInt32 cbNativeType);
    public abstract virtual void DeleteFieldMarshal(UInt32 tk);
    public abstract virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    public abstract virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public abstract virtual UInt32 GetTokenFromSig(Byte* pvSig, UInt32 cbSig);
    public abstract virtual UInt32 DefineModuleRef(string szName);
    public abstract virtual void SetParent(UInt32 mr, UInt32 tk);
    public abstract virtual UInt32 GetTokenFromTypeSpec(Byte* pvSig, UInt32 cbSig);
    public abstract virtual void SaveToMemory(Void* pbData, UInt32 cbData);
    public abstract virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public abstract virtual void DeleteToken(UInt32 tkObj);
    public abstract virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    public abstract virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    public abstract virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    public abstract virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void DeletePinvokeMap(UInt32 tk);
    public abstract virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual void SetCustomAttributeValue(UInt32 pcv, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, Byte* pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    public abstract virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    public abstract virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public abstract virtual void ApplyEditAndContinue(object pImport);
    public abstract virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport import, Byte* pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, Byte* pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public abstract virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public abstract virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public abstract virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public abstract virtual void MergeEnd();
}
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
internal interface Microsoft.Cci.PeWriterInternal.IMetaDataImport {
    public abstract virtual void CloseEnum(UInt32 hEnum);
    public abstract virtual UInt32 CountEnum(UInt32 hEnum);
    public abstract virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public abstract virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public abstract virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public abstract virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public abstract virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public abstract virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public abstract virtual UInt32 GetModuleFromScope();
    public abstract virtual UInt32 GetTypeDefProps(UInt32 td, IntPtr szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    public abstract virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public abstract virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public abstract virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, UInt32* rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, UInt32* rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public abstract virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public abstract virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public abstract virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 GetMethodProps(UInt32 mb, UInt32& pClass, IntPtr szMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    public abstract virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, Byte*& ppvSigBlob);
    public abstract virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, UInt32* rProperties, UInt32 cMax);
    public abstract virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, UInt32* rEvents, UInt32 cMax);
    public abstract virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public abstract virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public abstract virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, COR_FIELD_OFFSET[] rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public abstract virtual UInt32 GetFieldMarshal(UInt32 tk, Byte*& ppvNativeType);
    public abstract virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public abstract virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, Void*& ppvPermission);
    public abstract virtual UInt32 GetSigFromToken(UInt32 mdSig, Byte*& ppvSig);
    public abstract virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public abstract virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, Byte*& ppvSig);
    public abstract virtual UInt32 GetNameFromToken(UInt32 tk);
    public abstract virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public abstract virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public abstract virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public abstract virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public abstract virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public abstract virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public abstract virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public abstract virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, Void*& ppBlob);
    public abstract virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public abstract virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, Void*& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    public abstract virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, Void*& ppData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass);
    public abstract virtual UInt32 GetNativeCallConvFromSig(Void* pvSig, UInt32 cbSig);
    public abstract virtual int IsGlobal(UInt32 pd);
}
internal class Microsoft.Cci.PeWriterInternal.InheritedTypeParameter : object {
    private ushort index;
    private ITypeDefinition inheritingType;
    private IGenericTypeParameter parentParameter;
    public ITypeDefinition DefiningType { get; }
    public IEnumerable`1<ITypeReference> Constraints { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public IEnumerable`1<ITypeReference> BaseClasses { get; }
    public IEnumerable`1<IEventDefinition> Events { get; }
    public IEnumerable`1<IMethodImplementation> ExplicitImplementationOverrides { get; }
    public IEnumerable`1<IFieldDefinition> Fields { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public IEnumerable`1<ITypeReference> Interfaces { get; }
    public IGenericTypeInstanceReference InstanceType { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsClass { get; }
    public bool IsComObject { get; }
    public bool IsDelegate { get; }
    public bool IsEnum { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsReferenceType { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsStruct { get; }
    public bool IsSealed { get; }
    public bool IsStatic { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<ITypeDefinitionMember> Members { get; }
    public IEnumerable`1<IMethodDefinition> Methods { get; }
    public IEnumerable`1<INestedTypeDefinition> NestedTypes { get; }
    public IEnumerable`1<ITypeDefinitionMember> PrivateHelperMembers { get; }
    public IEnumerable`1<IPropertyDefinition> Properties { get; }
    public IEnumerable`1<ISecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public StringFormatKind StringFormat { get; }
    public ITypeReference UnderlyingType { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public IEnumerable`1<ILocation> Locations { get; }
    public IAliasForType AliasForType { get; }
    public UInt32 InternedKey { get; }
    public bool IsAlias { get; }
    public bool IsValueType { get; }
    public IPlatformType PlatformType { get; }
    public ITypeDefinition ResolvedType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public ushort Index { get; }
    public IName Name { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    private IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.ResolvedType { get; }
    public bool MangleName { get; }
    private INamedTypeDefinition Microsoft.Cci.INamedTypeReference.ResolvedType { get; }
    internal InheritedTypeParameter(ushort index, ITypeDefinition inheritingType, IGenericTypeParameter parentParameter);
    public sealed virtual ITypeDefinition get_DefiningType();
    public sealed virtual IEnumerable`1<ITypeReference> get_Constraints();
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public sealed virtual ushort get_Alignment();
    public sealed virtual IEnumerable`1<ITypeReference> get_BaseClasses();
    public sealed virtual IEnumerable`1<IEventDefinition> get_Events();
    public sealed virtual IEnumerable`1<IMethodImplementation> get_ExplicitImplementationOverrides();
    public sealed virtual IEnumerable`1<IFieldDefinition> get_Fields();
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<ITypeReference> get_Interfaces();
    public sealed virtual IGenericTypeInstanceReference get_InstanceType();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsClass();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsDelegate();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStruct();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsStatic();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_Members();
    public sealed virtual IEnumerable`1<IMethodDefinition> get_Methods();
    public sealed virtual IEnumerable`1<INestedTypeDefinition> get_NestedTypes();
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> get_PrivateHelperMembers();
    public sealed virtual IEnumerable`1<IPropertyDefinition> get_Properties();
    public sealed virtual IEnumerable`1<ISecurityAttribute> get_SecurityAttributes();
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual StringFormatKind get_StringFormat();
    public sealed virtual ITypeReference get_UnderlyingType();
    public sealed virtual IEnumerable`1<ICustomAttribute> get_Attributes();
    public sealed virtual void Dispatch(IMetadataVisitor visitor);
    public sealed virtual void DispatchAsReference(IMetadataVisitor visitor);
    public sealed virtual IEnumerable`1<ILocation> get_Locations();
    public sealed virtual bool Contains(ITypeDefinitionMember member);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembersNamed(IName name, bool ignoreCase, Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMatchingMembers(Function`2<ITypeDefinitionMember, bool> predicate);
    public sealed virtual IEnumerable`1<ITypeDefinitionMember> GetMembersNamed(IName name, bool ignoreCase);
    public sealed virtual IAliasForType get_AliasForType();
    public sealed virtual UInt32 get_InternedKey();
    public sealed virtual bool get_IsAlias();
    public sealed virtual bool get_IsValueType();
    public sealed virtual IPlatformType get_PlatformType();
    public sealed virtual ITypeDefinition get_ResolvedType();
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual ushort get_Index();
    public sealed virtual IName get_Name();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    private sealed virtual override IGenericTypeParameter Microsoft.Cci.IGenericTypeParameterReference.get_ResolvedType();
    public sealed virtual bool get_MangleName();
    private sealed virtual override INamedTypeDefinition Microsoft.Cci.INamedTypeReference.get_ResolvedType();
}
internal class Microsoft.Cci.PeWriterInternal.MemberRefComparer : object {
    private PeWriter peWriter;
    internal MemberRefComparer(PeWriter peWriter);
    public sealed virtual bool Equals(ITypeMemberReference x, ITypeMemberReference y);
    public sealed virtual int GetHashCode(ITypeMemberReference memberRef);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal class Microsoft.Cci.PeWriterInternal.MetadataWrapper : object {
    private PeWriter writer;
    private UInt32 lastTd;
    private string lastTName;
    private UInt32 lastParentToken;
    internal MetadataWrapper(PeWriter writer);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetModuleProps(string szName);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.Save(string szFile, UInt32 dwSaveFlags);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SaveToStream(Void* pIStream, UInt32 dwSaveFlags);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.GetSaveSize(UInt32 fSave);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineTypeDef(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineNestedType(Char* szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements, UInt32 tdEncloser);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetHandler(object pUnk);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineMethod(UInt32 td, Char* zName, UInt32 dwMethodFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineTypeRefByName(UInt32 tkResolutionScope, Char* szName);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineImportType(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineMemberRef(UInt32 tkImport, string szName, Byte* pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineImportMember(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetClassLayout(UInt32 td, UInt32 dwPackSize, COR_FIELD_OFFSET* rFieldOffsets, UInt32 ulClassSize);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DeleteClassLayout(UInt32 td);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetFieldMarshal(UInt32 tk, Byte* pvNativeType, UInt32 cbNativeType);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DeleteFieldMarshal(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefinePermissionSet(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetRVA(UInt32 md, UInt32 ulRVA);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.GetTokenFromSig(Byte* pvSig, UInt32 cbSig);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineModuleRef(string szName);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetParent(UInt32 mr, UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.GetTokenFromTypeSpec(Byte* pvSig, UInt32 cbSig);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SaveToMemory(Void* pbData, UInt32 cbData);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineUserString(string szString, UInt32 cchString);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DeleteToken(UInt32 tkObj);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, UInt32* rtkImplements);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, UInt32* rmdOtherMethods);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetPermissionSetProps(UInt32 tk, UInt32 dwAction, Void* pvPermission, UInt32 cbPermission);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DeletePinvokeMap(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetCustomAttributeValue(UInt32 pcv, Void* pCustomAttribute, UInt32 cbCustomAttribute);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, Byte* pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, Byte* pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, UInt32* rmdOtherMethods);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, Void* pValue, UInt32 cchValue);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.ApplyEditAndContinue(object pImport);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataEmit.TranslateSigWithScope(IntPtr pAssemImport, Void* pbHashValue, UInt32 cbHashValue, IMetaDataImport import, Byte* pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, Byte* pvTranslatedSig, UInt32 cbTranslatedSigMax);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataEmit.MergeEnd();
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataImport.CloseEnum(UInt32 hEnum);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.CountEnum(UInt32 hEnum);
    private sealed virtual override void Microsoft.Cci.PeWriterInternal.IMetaDataImport.ResetEnum(UInt32 hEnum, UInt32 ulPos);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    private sealed virtual override Guid Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetModuleFromScope();
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetTypeDefProps(UInt32 td, IntPtr szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMethods(UInt32& phEnum, UInt32 cl, UInt32* rMethods, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumFields(UInt32& phEnum, UInt32 cl, UInt32* rFields, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetMethodProps(UInt32 mb, UInt32& pClass, IntPtr szMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, Byte*& ppvSigBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumProperties(UInt32& phEnum, UInt32 td, UInt32* rProperties, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumEvents(UInt32& phEnum, UInt32 td, UInt32* rEvents, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetClassLayout(UInt32 td, UInt32& pdwPackSize, COR_FIELD_OFFSET[] rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetFieldMarshal(UInt32 tk, Byte*& ppvNativeType);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, Void*& ppvPermission);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetSigFromToken(UInt32 mdSig, Byte*& ppvSig);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetTypeSpecFromToken(UInt32 typespec, Byte*& ppvSig);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetNameFromToken(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    private sealed virtual override int Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, Void*& ppBlob);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.FindTypeRef(UInt32 tkResolutionScope, string szName);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, Byte*& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, Byte*& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, Void*& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, Void*& ppValue);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetCustomAttributeByName(UInt32 tkObj, string szName, Void*& ppData);
    private sealed virtual override bool Microsoft.Cci.PeWriterInternal.IMetaDataImport.IsValidToken(UInt32 tk);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetNestedClassProps(UInt32 tdNestedClass);
    private sealed virtual override UInt32 Microsoft.Cci.PeWriterInternal.IMetaDataImport.GetNativeCallConvFromSig(Void* pvSig, UInt32 cbSig);
    private sealed virtual override int Microsoft.Cci.PeWriterInternal.IMetaDataImport.IsGlobal(UInt32 pd);
}
internal class Microsoft.Cci.PeWriterInternal.MethodSpecComparer : object {
    private PeWriter peWriter;
    internal MethodSpecComparer(PeWriter peWriter);
    public sealed virtual bool Equals(IGenericMethodInstanceReference x, IGenericMethodInstanceReference y);
    public sealed virtual int GetHashCode(IGenericMethodInstanceReference methodInstanceReference);
}
internal class Microsoft.Cci.PeWriterInternal.NtHeader : object {
    internal ushort NumberOfSections;
    internal UInt32 TimeDateStamp;
    internal UInt32 PointerToSymbolTable;
    internal UInt32 SizeOfCode;
    internal UInt32 SizeOfInitializedData;
    internal UInt32 SizeOfUninitializedData;
    internal UInt32 AddressOfEntryPoint;
    internal UInt32 BaseOfCode;
    internal UInt32 BaseOfData;
    internal UInt32 SizeOfImage;
    internal UInt32 SizeOfHeaders;
    internal DirectoryEntry ExportTable;
    internal DirectoryEntry ImportTable;
    internal DirectoryEntry ResourceTable;
    internal DirectoryEntry ExceptionTable;
    internal DirectoryEntry CertificateTable;
    internal DirectoryEntry BaseRelocationTable;
    internal DirectoryEntry DebugTable;
    internal DirectoryEntry CopyrightTable;
    internal DirectoryEntry GlobalPointerTable;
    internal DirectoryEntry ThreadLocalStorageTable;
    internal DirectoryEntry LoadConfigTable;
    internal DirectoryEntry BoundImportTable;
    internal DirectoryEntry ImportAddressTable;
    internal DirectoryEntry DelayImportTable;
    internal DirectoryEntry CliHeaderTable;
    internal DirectoryEntry Reserved;
}
internal class Microsoft.Cci.PeWriterInternal.ReferenceIndexer : MetadataTraverser {
    private SetOfUints alreadyHasToken;
    private SetOfObjects alreadyHasBeenTaversed;
    private PeWriter peWriter;
    private bool traverseAttributes;
    private bool typeReferenceNeedsToken;
    private IModule module;
    internal ReferenceIndexer(PeWriter peWriter, bool traverseAttributes);
    internal static void Traverse(PeWriter peWriter, bool traverseAttributes, IModule module);
    public virtual void TraverseChildren(IAssembly assembly);
    public virtual void TraverseChildren(IAssemblyReference assemblyReference);
    public virtual void TraverseChildren(IAliasForType aliasForType);
    public virtual void TraverseChildren(ICustomModifier customModifier);
    public virtual void TraverseChildren(ICustomAttribute customAttribute);
    public virtual void TraverseChildren(IEventDefinition eventDefinition);
    public virtual void TraverseChildren(IFieldReference fieldReference);
    public virtual void TraverseChildren(IFileReference fileReference);
    public virtual void TraverseChildren(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void TraverseChildren(IGenericMethodParameter genericParameter);
    public virtual void TraverseChildren(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void TraverseChildren(IGenericTypeParameter genericParameter);
    public virtual void TraverseChildren(IMarshallingInformation marshallingInformation);
    public virtual void TraverseChildren(IMethodDefinition method);
    public virtual void TraverseChildren(IMethodReference methodReference);
    public virtual void TraverseChildren(IModule module);
    public virtual void TraverseChildren(IModuleReference moduleReference);
    public virtual void TraverseChildren(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void TraverseChildren(INamespaceTypeReference namespaceTypeReference);
    public virtual void TraverseChildren(INestedTypeReference nestedTypeReference);
    public virtual void TraverseChildren(IOperation operation);
    public virtual void TraverseChildren(IOperationExceptionInformation operationExceptionInformation);
    public virtual void TraverseChildren(IPropertyDefinition propertyDefinition);
    public virtual void TraverseChildren(IResourceReference resourceReference);
    public virtual void TraverseChildren(ISecurityAttribute securityAttribute);
    public virtual void TraverseChildren(ISpecializedMethodReference specializedMethodReference);
    public virtual void TraverseChildren(ISpecializedNestedTypeReference specializedNestedTypeReference);
    public virtual void TraverseChildren(ITypeDefinition typeDefinition);
    private void TraverseTypeReferencesThatNeedTokens(IEnumerable`1<ITypeReference> typeReferences);
    private void TraverseTypeMemberReference(ITypeMemberReference typeMemberReference);
    public virtual void TraverseChildren(ITypeReference typeReference);
}
internal class Microsoft.Cci.PeWriterInternal.SectionHeader : object {
    internal string Name;
    internal UInt32 VirtualSize;
    internal UInt32 RelativeVirtualAddress;
    internal UInt32 SizeOfRawData;
    internal UInt32 PointerToRawData;
    internal UInt32 PointerToRelocations;
    internal UInt32 PointerToLinenumbers;
    internal ushort NumberOfRelocations;
    internal ushort NumberOfLinenumbers;
    internal UInt32 Characteristics;
    internal IEnumerable`1<byte> RawData;
}
internal enum Microsoft.Cci.PeWriterInternal.TableIndices : Enum {
    public byte value__;
    public static TableIndices Module;
    public static TableIndices TypeRef;
    public static TableIndices TypeDef;
    public static TableIndices FieldPtr;
    public static TableIndices Field;
    public static TableIndices MethodPtr;
    public static TableIndices Method;
    public static TableIndices ParamPtr;
    public static TableIndices Param;
    public static TableIndices InterfaceImpl;
    public static TableIndices MemberRef;
    public static TableIndices Constant;
    public static TableIndices CustomAttribute;
    public static TableIndices FieldMarshal;
    public static TableIndices DeclSecurity;
    public static TableIndices ClassLayout;
    public static TableIndices FieldLayout;
    public static TableIndices StandAloneSig;
    public static TableIndices EventMap;
    public static TableIndices EventPtr;
    public static TableIndices Event;
    public static TableIndices PropertyMap;
    public static TableIndices PropertyPtr;
    public static TableIndices Property;
    public static TableIndices MethodSemantics;
    public static TableIndices MethodImpl;
    public static TableIndices ModuleRef;
    public static TableIndices TypeSpec;
    public static TableIndices ImplMap;
    public static TableIndices FieldRva;
    public static TableIndices EnCLog;
    public static TableIndices EnCMap;
    public static TableIndices Assembly;
    public static TableIndices AssemblyProcessor;
    public static TableIndices AssemblyOS;
    public static TableIndices AssemblyRef;
    public static TableIndices AssemblyRefProcessor;
    public static TableIndices AssemblyRefOS;
    public static TableIndices File;
    public static TableIndices ExportedType;
    public static TableIndices ManifestResource;
    public static TableIndices NestedClass;
    public static TableIndices GenericParam;
    public static TableIndices MethodSpec;
    public static TableIndices GenericParamConstraint;
    public static TableIndices Count;
}
internal enum Microsoft.Cci.PeWriterInternal.TypeFlags : Enum {
    public UInt32 value__;
    public static TypeFlags PrivateAccess;
    public static TypeFlags PublicAccess;
    public static TypeFlags NestedPublicAccess;
    public static TypeFlags NestedPrivateAccess;
    public static TypeFlags NestedFamilyAccess;
    public static TypeFlags NestedAssemblyAccess;
    public static TypeFlags NestedFamilyAndAssemblyAccess;
    public static TypeFlags NestedFamilyOrAssemblyAccess;
    public static TypeFlags AccessMask;
    public static TypeFlags NestedMask;
    public static TypeFlags AutoLayout;
    public static TypeFlags SeqentialLayout;
    public static TypeFlags ExplicitLayout;
    public static TypeFlags LayoutMask;
    public static TypeFlags ClassSemantics;
    public static TypeFlags InterfaceSemantics;
    public static TypeFlags AbstractSemantics;
    public static TypeFlags SealedSemantics;
    public static TypeFlags SpecialNameSemantics;
    public static TypeFlags ImportImplementation;
    public static TypeFlags SerializableImplementation;
    public static TypeFlags BeforeFieldInitImplementation;
    public static TypeFlags ForwarderImplementation;
    public static TypeFlags AnsiString;
    public static TypeFlags UnicodeString;
    public static TypeFlags AutoCharString;
    public static TypeFlags CustomFormatString;
    public static TypeFlags StringMask;
    public static TypeFlags RTSpecialNameReserved;
    public static TypeFlags HasSecurityReserved;
}
internal class Microsoft.Cci.PeWriterInternal.TypeSpecComparer : object {
    private PeWriter peWriter;
    internal TypeSpecComparer(PeWriter peWriter);
    public sealed virtual bool Equals(ITypeReference x, ITypeReference y);
    public sealed virtual int GetHashCode(ITypeReference typeReference);
}
public enum Microsoft.Cci.PInvokeCallingConvention : Enum {
    public int value__;
    public static PInvokeCallingConvention WinApi;
    public static PInvokeCallingConvention CDecl;
    public static PInvokeCallingConvention StdCall;
    public static PInvokeCallingConvention ThisCall;
    public static PInvokeCallingConvention FastCall;
}
public abstract class Microsoft.Cci.PrimarySourceDocument : SourceDocument {
    private string text;
    private Nullable`1<int> length;
    private string location;
    private StreamReader streamReader;
    private Char[] buffer;
    private int charsInBuffer;
    private int streamReaderPosition;
    private SourceLocationSpanningEntirePrimaryDocument sourceLocation;
    private Int32[] lineCounters;
    private Int32[] columnCounters;
    private Int32[] lastPositions;
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid ChecksumAlgorithm { get; }
    public Byte[] Checksum { get; }
    public int Length { get; }
    public string Location { get; }
    public SourceLocation SourceLocation { get; }
    private IPrimarySourceLocation Microsoft.Cci.IPrimarySourceDocument.PrimarySourceLocation { get; }
    protected PrimarySourceDocument(IName name, string location, StreamReader streamReader);
    protected PrimarySourceDocument(IName name, string location, string text);
    protected PrimarySourceDocument(string text, SourceDocument previousVersion, int position, int oldLength, int newLength);
    protected PrimarySourceDocument(PrimarySourceDocument template);
    private void GetOwnStreamReaderAndReadAhead(StreamReader streamReader);
    private void ObjectInvariant();
    public virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public abstract virtual Guid get_DocumentType();
    public sealed virtual IPrimarySourceLocation GetPrimarySourceLocation(int position, int length);
    public virtual ISourceLocation GetSourceLocation(int position, int length);
    public virtual string GetText();
    public abstract virtual Guid get_Language();
    public abstract virtual Guid get_LanguageVendor();
    public abstract virtual Guid get_ChecksumAlgorithm();
    public abstract virtual Byte[] get_Checksum();
    public virtual int get_Length();
    public virtual string get_Location();
    private void SetStreamReaderPositionTo(int position);
    public virtual SourceLocation get_SourceLocation();
    public virtual void ToLineColumn(int position, Int32& line, Int32& column);
    public int ToPosition(int line, int column);
    private int FindBestStartPointForPosition(int position);
    private int FindBestStartPointForLine(int line);
    private sealed virtual override IPrimarySourceLocation Microsoft.Cci.IPrimarySourceDocument.get_PrimarySourceLocation();
}
public class Microsoft.Cci.PrimarySourceLocation : SourceLocation {
    private IPrimarySourceDocument primarySourceDocument;
    public int EndColumn { get; }
    public int EndLine { get; }
    public IPrimarySourceDocument PrimarySourceDocument { get; }
    public ISourceDocument SourceDocument { get; }
    public int StartColumn { get; }
    public int StartLine { get; }
    public PrimarySourceLocation(IPrimarySourceDocument primarySourceDocument, int startIndex, int length);
    private void ObjectInvariant();
    public sealed virtual int get_EndColumn();
    public sealed virtual int get_EndLine();
    public sealed virtual IPrimarySourceDocument get_PrimarySourceDocument();
    public virtual ISourceDocument get_SourceDocument();
    public sealed virtual int get_StartColumn();
    public sealed virtual int get_StartLine();
}
public enum Microsoft.Cci.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode Int8;
    public static PrimitiveTypeCode Float32;
    public static PrimitiveTypeCode Float64;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode IntPtr;
    public static PrimitiveTypeCode Pointer;
    public static PrimitiveTypeCode Reference;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode UInt8;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UIntPtr;
    public static PrimitiveTypeCode Void;
    public static PrimitiveTypeCode NotPrimitive;
    public static PrimitiveTypeCode Invalid;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.ReadOnlyList`1 : object {
    private T[] m_data;
    private int m_count;
    public int Count { get; }
    public T Item { get; }
    public ReadOnlyList`1(int capacity);
    public static ReadOnlyList`1<T> Create(UInt32 uCount);
    public static ReadOnlyList`1<T> Create(IEnumerable`1<T> list);
    public static IEnumerable`1<T> Freeze(ReadOnlyList`1<T> list);
    public void Add(T item);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.ReadOnlyListEnumerator`1 : ValueType {
    private IReadOnlyList`1<T> m_list;
    private int m_index;
    public int Count { get; }
    public T Item { get; }
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public ReadOnlyListEnumerator`1(IReadOnlyList`1<T> list);
    public int get_Count();
    public T get_Item(int index);
    public sealed virtual bool MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public enum Microsoft.Cci.SecurityAction : Enum {
    public int value__;
    public static SecurityAction ActionNil;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PrejitGrant;
    public static SecurityAction PrejitDenied;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
public class Microsoft.Cci.SemanticErrorReporter : object {
    public static SemanticErrorReporter Instance;
    private static SemanticErrorReporter();
}
public class Microsoft.Cci.SignatureFormatter : object {
    protected TypeNameFormatter typeNameFormatter;
    public SignatureFormatter(TypeNameFormatter typeNameFormatter);
    public virtual string GetEventSignature(IEventDefinition eventDef, NameFormattingOptions formattingOptions);
    public virtual string GetFieldSignature(IFieldReference field, NameFormattingOptions formattingOptions);
    public virtual string GetMemberSignature(ITypeMemberReference member, NameFormattingOptions formattingOptions);
    public virtual string GetMethodSignature(IMethodReference method, NameFormattingOptions formattingOptions);
    public virtual string GetPropertySignature(IPropertyDefinition property, NameFormattingOptions formattingOptions);
    public virtual string GetVisibility(ITypeDefinitionMember typeDefinitionMember);
    protected virtual void AppendGenericArguments(IGenericMethodInstanceReference method, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendGenericParameters(IMethodReference method, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendMethodParameters(IMethodReference method, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendMethodName(IMethodReference method, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendParameter(IParameterTypeInformation param, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendPropertyName(IPropertyDefinition property, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendPropertyParameters(IEnumerable`1<IParameterDefinition> parameters, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual void AppendReturnTypeSignature(ISignature sig, NameFormattingOptions formattingOptions, StringBuilder sb);
    protected virtual string MapToDocumentationIdName(string name);
}
public class Microsoft.Cci.SimpleParameterTypeInformation : object {
    private ISignature containingSignature;
    private ushort index;
    private bool isByReference;
    private ITypeReference type;
    public ISignature ContainingSignature { get; }
    public ushort Index { get; }
    public bool IsByReference { get; }
    public ITypeReference Type { get; }
    private IEnumerable`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.CustomModifiers { get; }
    private bool Microsoft.Cci.IParameterTypeInformation.IsModified { get; }
    public SimpleParameterTypeInformation(ISignature containingSignature, ushort index, ITypeReference type, bool isByReference);
    public sealed virtual ISignature get_ContainingSignature();
    public sealed virtual ushort get_Index();
    public sealed virtual bool get_IsByReference();
    public sealed virtual ITypeReference get_Type();
    private sealed virtual override IEnumerable`1<ICustomModifier> Microsoft.Cci.IParameterTypeInformation.get_CustomModifiers();
    private sealed virtual override bool Microsoft.Cci.IParameterTypeInformation.get_IsModified();
}
internal class Microsoft.Cci.SingletonList`1 : VirtualReadOnlyList`1<T> {
    private T m_current;
    public SingletonList`1(T value);
    public virtual T GetItem(int index);
}
public abstract class Microsoft.Cci.SourceDocument : object {
    private IName name;
    private WeakReference previousVersion;
    private int editStartIndex;
    private int editNewLength;
    private int editOldLength;
    public int Length { get; }
    public string Location { get; }
    public IName Name { get; }
    public string SourceLanguage { get; }
    public SourceLocation SourceLocation { get; }
    private ISourceLocation Microsoft.Cci.ISourceDocument.SourceLocation { get; }
    protected SourceDocument(IName name);
    protected SourceDocument(SourceDocument previousVersion, int position, int oldLength, int newLength);
    public virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public abstract virtual ISourceLocation GetSourceLocation(int position, int length);
    public virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public abstract virtual int get_Length();
    public abstract virtual string get_Location();
    public virtual IName get_Name();
    public abstract virtual string get_SourceLanguage();
    public abstract virtual SourceLocation get_SourceLocation();
    public abstract virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public abstract virtual string GetText();
    private sealed virtual override ISourceLocation Microsoft.Cci.ISourceDocument.get_SourceLocation();
}
public abstract class Microsoft.Cci.SourceDocumentEdit : object {
    private ISourceLocation sourceLocationBeforeEdit;
    private ISourceDocument sourceDocumentAfterEdit;
    public ISourceLocation SourceLocationBeforeEdit { get; }
    public ISourceDocument SourceDocumentAfterEdit { get; }
    protected SourceDocumentEdit(ISourceLocation sourceLocationBeforeEdit, ISourceDocument sourceDocumentAfterEdit);
    private void ObjectInvariant();
    public sealed virtual ISourceLocation get_SourceLocationBeforeEdit();
    public sealed virtual ISourceDocument get_SourceDocumentAfterEdit();
}
public class Microsoft.Cci.SourceDocumentWithInclusion : object {
    private string originalDocumentName;
    private int originalLineNumber;
    private int startingPositionOfIncludedRegion;
    private IPrimarySourceDocument wrappedDocument;
    private IPrimarySourceLocation primarySourceLocation;
    public string OriginalDocumentName { get; }
    public int OriginalLineNumber { get; }
    public int StartingPositionOfIncludedRegion { get; }
    public IPrimarySourceDocument WrappedDocument { get; }
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public Guid ChecksumAlgorithm { get; }
    public Byte[] Checksum { get; }
    public ISourceLocation SourceLocation { get; }
    public int Length { get; }
    public string SourceLanguage { get; }
    public IPrimarySourceLocation PrimarySourceLocation { get; }
    public string Location { get; }
    public IName Name { get; }
    public SourceDocumentWithInclusion(IPrimarySourceDocument wrappedDocument, int originalLineNumber, string originalDocumentName, int startingPositionOfIncludedRegion);
    private void ObjectInvariant();
    public sealed virtual IPrimarySourceLocation GetPrimarySourceLocation(int position, int length);
    public sealed virtual ISourceLocation GetSourceLocation(int position, int length);
    public string get_OriginalDocumentName();
    public int get_OriginalLineNumber();
    public int get_StartingPositionOfIncludedRegion();
    public IPrimarySourceDocument get_WrappedDocument();
    public sealed virtual Guid get_DocumentType();
    public sealed virtual Guid get_Language();
    public sealed virtual Guid get_LanguageVendor();
    public sealed virtual Guid get_ChecksumAlgorithm();
    public sealed virtual Byte[] get_Checksum();
    public sealed virtual int CopyTo(int position, Char[] destination, int destinationOffset, int length);
    public sealed virtual ISourceLocation GetCorrespondingSourceLocation(ISourceLocation sourceLocationInPreviousVersionOfDocument);
    public sealed virtual ISourceLocation get_SourceLocation();
    public sealed virtual string GetText();
    public sealed virtual bool IsUpdatedVersionOf(ISourceDocument sourceDocument);
    public sealed virtual int get_Length();
    public sealed virtual string get_SourceLanguage();
    public sealed virtual IPrimarySourceLocation get_PrimarySourceLocation();
    public sealed virtual void ToLineColumn(int position, Int32& line, Int32& column);
    public sealed virtual string get_Location();
    public sealed virtual IName get_Name();
}
public static class Microsoft.Cci.SourceDummy : object {
    private static ICompilation compilation;
    private static IPrimarySourceDocument primarySourceDocument;
    private static IPrimarySourceLocation primarySourceLocation;
    private static ISourceDocument sourceDocument;
    private static ISourceDocumentEdit sourceDocumentEdit;
    private static ISourceLocation sourceLocation;
    public static ICompilation Compilation { get; }
    public static IPrimarySourceDocument PrimarySourceDocument { get; }
    public static IPrimarySourceLocation PrimarySourceLocation { get; }
    public static ISourceDocument SourceDocument { get; }
    public static ISourceDocumentEdit SourceDocumentEdit { get; }
    public static ISourceLocation SourceLocation { get; }
    private static SourceDummy();
    public static ICompilation get_Compilation();
    public static IPrimarySourceDocument get_PrimarySourceDocument();
    public static IPrimarySourceLocation get_PrimarySourceLocation();
    public static ISourceDocument get_SourceDocument();
    public static ISourceDocumentEdit get_SourceDocumentEdit();
    public static ISourceLocation get_SourceLocation();
}
public class Microsoft.Cci.SourceEditEventArgs : EventArgs {
    private IEnumerable`1<ISourceDocumentEdit> edits;
    public IEnumerable`1<ISourceDocumentEdit> Edits { get; }
    public SourceEditEventArgs(IEnumerable`1<ISourceDocumentEdit> edits);
    private void ObjectInvariant();
    public IEnumerable`1<ISourceDocumentEdit> get_Edits();
}
public abstract class Microsoft.Cci.SourceEditHostEnvironment : MetadataReaderHost {
    private Dictionary`2<UnitSetIdentity, WeakReference> unitSetCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<EditEventArgs> Edits;
    [CompilerGeneratedAttribute]
private EventHandler`1<EditEventArgs> SymbolTableEdits;
    protected SourceEditHostEnvironment(INameTable nameTable, IInternFactory factory, byte pointerSize, IEnumerable`1<string> searchPaths, bool searchInGAC);
    public IUnitSet GetUnitSetFor(UnitSetIdentity referencedUnitSet);
    private static bool UnitsAreTheSameObjects(List`1<IUnit> unitList, IEnumerable`1<IUnit> unitEnumeration);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Edits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Edits(EventHandler`1<EditEventArgs> value);
    public sealed virtual void RegisterAsLatest(ICompilation compilation);
    public sealed virtual void ReportEdits(EditEventArgs editEventArguments);
    private void ReportEditsUsingDifferentThread(object state);
    public sealed virtual void ReportSymbolTableEdits(EditEventArgs editEventArguments);
    private void ReportSymbolTableEditsUsingDifferentThread(object state);
    [CompilerGeneratedAttribute]
public sealed virtual void add_SymbolTableEdits(EventHandler`1<EditEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_SymbolTableEdits(EventHandler`1<EditEventArgs> value);
}
public abstract class Microsoft.Cci.SourceLocation : object {
    internal int length;
    private int startIndex;
    public int EndIndex { get; }
    public int Length { get; }
    public string Source { get; }
    public ISourceDocument SourceDocument { get; }
    public int StartIndex { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    protected SourceLocation(int startIndex, int length);
    public sealed virtual bool Contains(ISourceLocation location);
    public virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public sealed virtual int get_EndIndex();
    public virtual int get_Length();
    public sealed virtual string get_Source();
    public abstract virtual ISourceDocument get_SourceDocument();
    public sealed virtual int get_StartIndex();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
public class Microsoft.Cci.SourceLocationBuilder : object {
    private int length;
    private int startIndex;
    private ISourceDocument sourceDocument;
    public ISourceDocument SourceDocument { get; }
    private int Microsoft.Cci.ISourceLocation.EndIndex { get; }
    private int Microsoft.Cci.ISourceLocation.Length { get; }
    private ISourceDocument Microsoft.Cci.ISourceLocation.SourceDocument { get; }
    private string Microsoft.Cci.ISourceLocation.Source { get; }
    private int Microsoft.Cci.ISourceLocation.StartIndex { get; }
    private IDocument Microsoft.Cci.ILocation.Document { get; }
    public SourceLocationBuilder(ISourceLocation sourceLocation);
    private void ObjectInvariant();
    public ISourceDocument get_SourceDocument();
    public void UpdateToSpan(ISourceLocation sourceLocation);
    public ISourceLocation GetSourceLocation();
    private sealed virtual override bool Microsoft.Cci.ISourceLocation.Contains(ISourceLocation location);
    private sealed virtual override int Microsoft.Cci.ISourceLocation.CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_EndIndex();
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_Length();
    private sealed virtual override ISourceDocument Microsoft.Cci.ISourceLocation.get_SourceDocument();
    private sealed virtual override string Microsoft.Cci.ISourceLocation.get_Source();
    private sealed virtual override int Microsoft.Cci.ISourceLocation.get_StartIndex();
    private sealed virtual override IDocument Microsoft.Cci.ILocation.get_Document();
}
public class Microsoft.Cci.SourceLocationSpanningEntireDerivedSourceDocument : DerivedSourceLocation {
    public int Length { get; }
    public SourceLocationSpanningEntireDerivedSourceDocument(IDerivedSourceDocument derivedSourceDocument);
    public virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public virtual int get_Length();
}
public class Microsoft.Cci.SourceLocationSpanningEntirePrimaryDocument : PrimarySourceLocation {
    public int Length { get; }
    public SourceLocationSpanningEntirePrimaryDocument(IPrimarySourceDocument primarySourceDocument);
    public virtual int CopyTo(int offset, Char[] destination, int destinationOffset, int length);
    public virtual int get_Length();
}
[ExtensionAttribute]
internal static class Microsoft.Cci.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder[] ts_CachedInstances;
    private static int s_Capacity;
    private static StringBuilderCache();
    private static StringBuilder[] GetList();
    public static StringBuilder Acquire();
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
    [ExtensionAttribute]
public static void FastAppend(StringBuilder sb, int val);
}
public enum Microsoft.Cci.StringFormatKind : Enum {
    public int value__;
    public static StringFormatKind Unspecified;
    public static StringFormatKind Ansi;
    public static StringFormatKind Unicode;
    public static StringFormatKind AutoChar;
}
public class Microsoft.Cci.SynchronizationPointLocation : object {
    private ISynchronizationPoint synchronizationPoint;
    private IDocument document;
    public ISynchronizationPoint SynchronizationPoint { get; }
    public IDocument Document { get; }
    public SynchronizationPointLocation(IDocument document, ISynchronizationPoint synchronizationPoint);
    private void ObjectInvariant();
    public ISynchronizationPoint get_SynchronizationPoint();
    public sealed virtual IDocument get_Document();
}
public enum Microsoft.Cci.TargetProcessorArchitecture : Enum {
    public int value__;
    public static TargetProcessorArchitecture X86;
    public static TargetProcessorArchitecture X64;
    public static TargetProcessorArchitecture IA64;
    public static TargetProcessorArchitecture ARM;
}
[ExtensionAttribute]
internal static class Microsoft.Cci.Toolbox : object {
    internal static string GetString(UInt32 n);
    internal static string GetLocalName(UInt32 n);
    [ExtensionAttribute]
public static EnumerableAdapter`1<T> Adapter(IEnumerable`1<T> en);
    [ExtensionAttribute]
public static void IncreaseCapacity(List`1<T> list, int count);
    [ExtensionAttribute]
internal static bool MaybeType(OperationValueKind kind);
    [ExtensionAttribute]
internal static bool MaybeField(OperationValueKind kind);
    [ExtensionAttribute]
internal static bool MaybeMethod(OperationValueKind kind);
    [ExtensionAttribute]
internal static bool MaybeParameter(OperationValueKind kind);
    [ExtensionAttribute]
internal static bool MaybeLocal(OperationValueKind kind);
    [ExtensionAttribute]
internal static OperationValueKind ValueKind(OperationCode cilOpCode);
}
public static class Microsoft.Cci.TypeHelper : object {
    private static TypeNameFormatter s_defaultTypeNameFormatter;
    private static TypeHelper();
    public static ITypeDefinition BaseClass(ITypeDefinition typeDef);
    public static bool CanAccess(ITypeDefinition typeDefinition, ITypeDefinitionMember member);
    public static bool CanAccess(ITypeDefinition typeDefinition, ITypeDefinition otherTypeDefinition);
    public static ITypeDefinition EffectiveBaseClass(IGenericParameter genericParameter);
    public static bool IsCompilerGenerated(ITypeDefinition type);
    public static bool IsCompileTimeConstantType(ITypeReference type);
    public static bool IsOpen(ITypeReference typeReference);
    public static bool IsPrimitiveInteger(ITypeReference type);
    public static bool IsSignedPrimitiveInteger(ITypeReference type);
    public static bool IsSignedPrimitive(ITypeReference type);
    public static bool IsUnsignedPrimitiveInteger(ITypeReference type);
    public static bool IsUnsignedPrimitive(ITypeReference type);
    public static bool IsVisibleOutsideAssembly(ITypeDefinition typeDefinition);
    public static bool IsVisibleToFriendAssemblies(ITypeDefinition typeDefinition);
    public static ITypeReference MergedType(ITypeReference type1, ITypeReference type2);
    public static ITypeReference MergedType(ITypeDefinition type1, ITypeDefinition type2);
    public static TypeMemberVisibility GenericInstanceVisibilityAsTypeMemberVisibility(TypeMemberVisibility templateVisibility, IEnumerable`1<ITypeReference> typeArguments);
    public static TypeMemberVisibility TypeVisibilityAsTypeMemberVisibility(ITypeDefinition type);
    public static ITypeReference UninstantiateAndUnspecialize(ITypeReference type);
    public static INestedTypeReference Unspecialize(INestedTypeReference nestedType);
    public static TypeMemberVisibility VisibilityIntersection(TypeMemberVisibility visibility1, TypeMemberVisibility visibility2);
    public static IUnitNamespace GetDefiningNamespace(INamedTypeDefinition namedTypeDefinition);
    public static IUnit GetDefiningUnit(ITypeDefinition typeDefinition);
    public static IUnitReference GetDefiningUnitReference(ITypeReference typeReference);
    public static IEventDefinition GetEvent(ITypeDefinition declaringType, IName eventName);
    public static IFieldDefinition GetField(ITypeDefinition declaringType, IName fieldName);
    public static IFieldDefinition GetField(ITypeDefinition declaringType, IFieldReference fieldReference, bool resolveTypes);
    public static IMethodDefinition GetMethod(ITypeDefinition declaringType, IName methodName, ITypeReference[] parameterTypes);
    public static IMethodDefinition GetMethod(IEnumerable`1<ITypeDefinitionMember> members, IName methodName, ITypeReference[] parameterTypes);
    public static IMethodDefinition GetMethod(ITypeDefinition declaringType, IMethodReference methodReference, bool resolveTypes);
    public static IMethodDefinition GetInvokeMethod(ITypeDefinition delegateType, IMetadataHost host);
    public static IMethodDefinition GetMethod(IEnumerable`1<ITypeDefinitionMember> members, IMethodReference methodSignature, bool resolveTypes);
    public static IMethodDefinition GetNamedMethod(IEnumerable`1<IMethodDefinition> members, IName name, IMethodReference methodSignature, bool resolveTypes);
    internal static IMethodDefinition GetNamedMethod(IEnumerable`1<IMethodDefinition> members, IName name, IMethodReference methodSignature, bool resolveTypes, bool requireMatchingSpecialization);
    private static bool SignaturesMatch(Func`4<ISignature, ISignature, bool, bool> matcher, IMethodDefinition method, IMethodReference methodSignature, bool resolveTypes, bool requireMatchingSpecialization);
    public static string GetNamespaceName(IUnitSetNamespace namespaceDefinition, NameFormattingOptions formattingOptions);
    public static string GetNamespaceName(IUnitNamespaceReference namespaceReference, NameFormattingOptions formattingOptions);
    public static INestedTypeDefinition GetNestedType(ITypeDefinition declaringType, IName typeName, int genericParameterCount);
    public static IPropertyDefinition GetProperty(ITypeDefinition declaringType, IName propertyName);
    public static bool TryGetFullyInstantiatedSpecializedTypeReference(ITypeDefinition typeDefinition, ITypeReference& result);
    public static string GetAliasName(IAliasForType alias);
    public static TypeCode GetSytemTypeCodeFor(ITypeDefinition type);
    public static string GetTypeName(ITypeReference type);
    public static string GetTypeName(ITypeReference type, NameFormattingOptions formattingOptions);
    public static ITypeDefinition MostDerivedCommonBaseClass(ITypeDefinition type1, ITypeDefinition type2);
    public static bool ParametersAreEquivalent(IParameterTypeInformation param1, IParameterTypeInformation param2, bool resolveTypes);
    public static bool ParametersAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(IParameterTypeInformation param1, IParameterTypeInformation param2, bool resolveTypes);
    public static bool ParameterListsAreEquivalent(IEnumerable`1<IParameterTypeInformation> paramList1, IEnumerable`1<IParameterTypeInformation> paramList2, bool resolveTypes);
    public static bool ParameterListsAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(IEnumerable`1<IParameterTypeInformation> paramList1, IEnumerable`1<IParameterTypeInformation> paramList2, bool resolveTypes);
    public static bool ParameterListsAreEquivalent(IEnumerable`1<IParameterDefinition> paramList1, IEnumerable`1<IParameterDefinition> paramList2, bool resolveTypes);
    public static ITypeDefinition Resolve(ITypeReference typeReference, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace, ITypeDefinition type, IMethodDefinition method);
    public static ITypeReference SignedEquivalent(ITypeReference typeReference);
    public static UInt32 SizeOfType(ITypeReference type);
    public static UInt32 SizeOfType(ITypeReference type, bool mayUseSizeOfProperty);
    private static UInt32 SizeOfType(ITypeReference type, ITypeReference rootType, bool mayUseSizeOfProperty);
    public static ITypeReference StackType(ITypeReference type);
    public static bool StackTypesAreEquivalent(ITypeReference type1, ITypeReference type2);
    public static ushort TypeAlignment(ITypeReference type);
    public static ushort TypeAlignment(ITypeReference type, bool mayUseAlignmentProperty);
    private static ushort TypeAlignment(ITypeReference type, ITypeReference rootType, bool mayUseAlignmentProperty);
    public static bool ArrayTypesAreEquivalent(IArrayTypeReference arrayTypeRef1, IArrayTypeReference arrayTypeRef2, bool resolveTypes);
    public static bool GenericTypeInstancesAreEquivalent(IGenericTypeInstanceReference genericTypeInstRef1, IGenericTypeInstanceReference genericTypeInstRef2, bool resolveTypes);
    public static ITypeDefinition GetInstanceOrSpecializedNestedType(ITypeDefinition type);
    public static bool HasOwnOrInheritedTypeParameters(ITypeDefinition type);
    public static bool IsAttributeType(ITypeDefinition type);
    public static bool PointerTypesAreEquivalent(IPointerTypeReference pointerTypeRef1, IPointerTypeReference pointerTypeRef2, bool resolveTypes);
    public static bool GenericTypeParametersAreEquivalent(IGenericTypeParameterReference genericTypeParam1, IGenericTypeParameterReference genericTypeParam2, bool resolveTypes);
    public static bool GenericMethodParametersAreEquivalent(IGenericMethodParameterReference genericMethodParam1, IGenericMethodParameterReference genericMethodParam2);
    public static bool FunctionPointerTypesAreEquivalent(IFunctionPointerTypeReference functionPointer1, IFunctionPointerTypeReference functionPointer2, bool resolveTypes);
    public static bool FunctionPointerTypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(IFunctionPointerTypeReference functionPointer1, IFunctionPointerTypeReference functionPointer2, bool resolveTypes);
    [ObsoleteAttribute("Please use TypeHelper.TypesAreEquivalent instead")]
public static bool NamespaceTypesAreEquivalent(INamespaceTypeReference nsType1, INamespaceTypeReference nsType2);
    [ObsoleteAttribute("Please use TypeHelper.TypesAreEquivalent instead")]
public static bool NestedTypesAreEquivalent(INestedTypeReference nstType1, INestedTypeReference nstType2);
    public static ITypeReference SpecializeTypeReference(ITypeReference typeReference, ITypeReference context, IInternFactory internFactory);
    public static ITypeReference SpecializeTypeReference(ITypeReference typeReference, IMethodReference context, IInternFactory internFactory);
    public static bool TypesAreEquivalent(ITypeReference type1, ITypeReference type2, bool resolveTypes);
    internal static bool TypesAreEquivalent(ITypeDefinition type1, ITypeDefinition type2);
    private static bool TypesAreEquivalent_Relaxed(ITypeReference type1, ITypeReference type2, bool resolveTypes, bool useMethodParamIndex);
    private static bool TypesAreEquivalent_Relaxed_Inner(ITypeReference type1, ITypeReference type2, bool resolveTypes, bool useMethodParamIndex);
    public static bool TypesAreEquivalentAssumingGenericMethodParametersAreEquivalentIfTheirIndicesMatch(ITypeReference type1, ITypeReference type2, bool resolveTypes);
    public static bool Type1DerivesFromOrIsTheSameAsType2(ITypeDefinition type1, ITypeReference type2, bool resolveTypes);
    public static bool Type1DerivesFromType2(ITypeDefinition type1, ITypeReference type2, bool resolveTypes);
    public static bool Type1ImplementsType2(ITypeDefinition type1, ITypeReference type2, bool resolveTypes);
    public static bool Type1IsCovariantWithType2(ITypeDefinition type1, ITypeReference type2, bool resolveTypes);
    public static bool TypesAreAssignmentCompatible(ITypeDefinition sourceType, ITypeDefinition targetType, bool resolveTypes);
    public static ITypeReference UnsignedEquivalent(ITypeReference typeReference);
}
public enum Microsoft.Cci.TypeMemberVisibility : Enum {
    public int value__;
    public static TypeMemberVisibility Default;
    public static TypeMemberVisibility Assembly;
    public static TypeMemberVisibility Family;
    public static TypeMemberVisibility FamilyAndAssembly;
    public static TypeMemberVisibility FamilyOrAssembly;
    public static TypeMemberVisibility Other;
    public static TypeMemberVisibility Private;
    public static TypeMemberVisibility Public;
    public static TypeMemberVisibility Mask;
}
public class Microsoft.Cci.TypeNameFormatter : object {
    public virtual string FilterName(string name, Int32& startPos, Int32& length);
    private string FilterName(string name);
    protected virtual string AddGenericParametersIfNeeded(ITypeReference type, ushort genericParameterCount, NameFormattingOptions formattingOptions, string typeName);
    private void AppendGenericParametersIfNeeded(StringBuilder sb, ITypeReference type, ushort genericParameterCount, NameFormattingOptions formattingOptions);
    public string GetAliasName(IAliasForType alias);
    private void AppendAliasName(IAliasForType alias, StringBuilder sb);
    protected virtual string GetArrayTypeName(IArrayTypeReference arrayType, NameFormattingOptions formattingOptions);
    protected virtual void AppendArrayDimensions(IArrayTypeReference arrayType, StringBuilder sb, NameFormattingOptions formattingOptions);
    public virtual string EscapeKeyword(string name);
    protected virtual string GetGenericMethodParameterName(IGenericMethodParameterReference genericMethodParameter, NameFormattingOptions formattingOptions);
    protected virtual string GetGenericTypeParameterName(IGenericTypeParameterReference genericTypeParameter, NameFormattingOptions formattingOptions);
    private ushort GetGenericParameterIndex(IGenericTypeParameterReference parameter);
    private ushort ComputeGenericTypeParameterCount(ITypeReference type);
    private ushort GetGenericParameterCount(ITypeReference type);
    protected virtual string GetManagedPointerTypeName(IManagedPointerTypeReference pointerType, NameFormattingOptions formattingOptions);
    protected virtual string GetModifiedTypeName(IModifiedTypeReference modifiedType, NameFormattingOptions formattingOptions);
    private StringBuilder AppendNamespaceName(StringBuilder sb, IUnitNamespaceReference unitNamespace, NameFormattingOptions formattingOptions);
    private StringBuilder AppendNamespaceTypeName(StringBuilder sb, INamespaceTypeReference nsType, NameFormattingOptions formattingOptions);
    protected virtual string GetNamespaceTypeName(INamespaceTypeReference nsType, NameFormattingOptions formattingOptions);
    public virtual string GetNamespaceName(IUnitSetNamespace namespaceDefinition, NameFormattingOptions formattingOptions);
    public virtual string GetNamespaceName(IUnitNamespaceReference unitNamespace, NameFormattingOptions formattingOptions);
    protected StringBuilder AppendNestedTypeName(StringBuilder sb, INestedTypeReference nestedType, NameFormattingOptions formattingOptions);
    protected virtual string GetNestedTypeName(INestedTypeReference nestedType, NameFormattingOptions formattingOptions);
    protected virtual string GetPointerTypeName(IPointerTypeReference pointerType, NameFormattingOptions formattingOptions);
    private string CheckIfKeyword(ITypeReference type, NameFormattingOptions formattingOptions);
    public virtual StringBuilder AppendTypeName(StringBuilder sb, ITypeReference type, NameFormattingOptions formattingOptions);
    public virtual string GetTypeName(ITypeReference type, NameFormattingOptions formattingOptions);
    protected virtual string GetTypeKind(ITypeReference typeReference);
    public virtual string GetVisibility(INestedTypeDefinition nestedType);
    protected virtual string GetFunctionPointerTypeName(IFunctionPointerTypeReference functionPointerType, NameFormattingOptions formattingOptions);
    protected virtual string GetGenericTypeInstanceName(IGenericTypeInstanceReference genericTypeInstance, NameFormattingOptions formattingOptions);
    public static ITypeReference GetUnsignedEquivalent(ITypeReference type);
}
public enum Microsoft.Cci.TypeParameterVariance : Enum {
    public int value__;
    public static TypeParameterVariance NonVariant;
    public static TypeParameterVariance Covariant;
    public static TypeParameterVariance Contravariant;
    public static TypeParameterVariance Mask;
}
public static class Microsoft.Cci.UnitHelper : object {
    public static bool AssemblyOneAllowsAssemblyTwoToAccessItsInternals(IAssembly assembly1, IAssembly assembly2);
    public static AssemblyIdentity GetAssemblyIdentity(IAssembly assembly);
    public static ModuleIdentity GetModuleIdentity(IModule module);
    public static Byte[] ComputePublicKeyToken(IEnumerable`1<byte> publicKey);
    public static IUnitNamespace Resolve(IUnitNamespaceReference unitNamespaceReference, IMetadataHost host, IUnit unit, IUnitNamespace unitNamespace);
    public static IUnit Resolve(IUnitReference unitReference, IMetadataHost host);
    public static string StrongName(IAssemblyReference assemblyReference);
    public static string StrongName(AssemblyIdentity assemblyIdentity);
    public static INamedTypeDefinition FindType(INameTable nameTable, IUnit unit, string typeName);
    public static INamedTypeDefinition FindType(INameTable nameTable, IUnit unit, string typeName, int genericParameterCount);
    private static INamedTypeDefinition GetType(INameTable nameTable, INamespaceDefinition namespaceDefinition, string typeName, int genericParameterCount, Int32& offset);
    private static INestedUnitNamespace GetNamespace(INameTable nameTable, INamespaceDefinition namespaceDefinition, string typeName, Int32& offset);
    private static INestedTypeDefinition GetNestedType(INameTable nameTable, ITypeDefinition typeDefinition, string typeName, int genericParameterCount, Int32& offset);
    public static IResourceReference FindResourceNamed(IAssembly assembly, IName resourceName);
    public static bool AssembliesAreEquivalent(IAssemblyReference assembly1, IAssemblyReference assembly2);
    public static bool ModulesAreEquivalent(IModuleReference module1, IModuleReference module2);
    public static bool UnitsAreEquivalent(IUnitReference unit1, IUnitReference unit2);
    public static bool UnitsAreContainmentEquivalent(IUnitReference unit1, IUnitReference unit2);
    public static bool UnitNamespacesAreEquivalent(IUnitNamespaceReference unitNamespace1, IUnitNamespaceReference unitNamespace2);
}
public abstract class Microsoft.Cci.UnitIdentity : object {
    private Nullable`1<int> hashCode;
    private string location;
    private IName name;
    public string Location { get; }
    public IName Name { get; }
    internal UnitIdentity(IName name, string location);
    private void ObjectInvariant();
    public abstract virtual bool Equals(object obj);
    internal abstract virtual int ComputeHashCode();
    public virtual int GetHashCode();
    public string get_Location();
    public IName get_Name();
    public abstract virtual string ToString();
}
public class Microsoft.Cci.UnitSetIdentity : object {
    private IEnumerable`1<UnitIdentity> units;
    public IEnumerable`1<UnitIdentity> Units { get; }
    public UnitSetIdentity(IEnumerable`1<UnitIdentity> units);
    public IEnumerable`1<UnitIdentity> get_Units();
}
public class Microsoft.Cci.UnmanagedBinaryMemoryBlock : object {
    private IBinaryDocument binaryDocument;
    private IntPtr Pointer;
    private IBinaryDocument Microsoft.Cci.IBinaryDocumentMemoryBlock.BinaryDocument { get; }
    private Byte* Microsoft.Cci.IBinaryDocumentMemoryBlock.Pointer { get; }
    private UInt32 Microsoft.Cci.IBinaryDocumentMemoryBlock.Length { get; }
    private UnmanagedBinaryMemoryBlock(IBinaryDocument binaryDocument);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Close();
    private sealed virtual override IBinaryDocument Microsoft.Cci.IBinaryDocumentMemoryBlock.get_BinaryDocument();
    private sealed virtual override Byte* Microsoft.Cci.IBinaryDocumentMemoryBlock.get_Pointer();
    private sealed virtual override UInt32 Microsoft.Cci.IBinaryDocumentMemoryBlock.get_Length();
    public static UnmanagedBinaryMemoryBlock CreateUnmanagedBinaryMemoryBlock(string localFileName, IBinaryDocument binaryDocument);
    public static UnmanagedBinaryMemoryBlock CreateUnmanagedBinaryMemoryBlock(Stream stream, IBinaryDocument binaryDocument);
    public static UnmanagedBinaryMemoryBlock CreateUnmanagedBinaryMemoryBlock(IEnumerable`1<byte> stream, IBinaryDocument binaryDocument);
}
public class Microsoft.Cci.UtilityDataStructures.DoubleHashtable : object {
    private Key1Key2ValueTriple[] keysValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public DoubleHashtable(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    private void Expand();
    private bool AddInternal(UInt32 key1, UInt32 key2, UInt32 value);
    public bool Add(UInt32 key1, UInt32 key2, UInt32 value);
    public UInt32 Find(UInt32 key1, UInt32 key2);
}
public class Microsoft.Cci.UtilityDataStructures.DoubleHashtable`1 : object {
    private Key1Key2ValueTriple[] keysValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public DoubleHashtable`1(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    public void Clear();
    private void Expand();
    private void AddInternal(UInt32 key1, UInt32 key2, T value);
    public void Add(UInt32 key1, UInt32 key2, T value);
    public T Find(UInt32 key1, UInt32 key2);
}
internal class Microsoft.Cci.UtilityDataStructures.EnumerableArrayWrapper`2 : object {
    internal T[] RawArray;
    internal U DummyValue;
    internal EnumerableArrayWrapper`2(T[] rawArray, U dummyValue);
    public sealed virtual IEnumerator`1<U> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Cci.UtilityDataStructures.EnumerableBinaryDocumentMemoryBlockWrapper : object {
    internal IBinaryDocumentMemoryBlock BinaryDocumentMemoryBlock;
    internal EnumerableBinaryDocumentMemoryBlockWrapper(IBinaryDocumentMemoryBlock binaryDocumentMemoryBlock);
    public sealed virtual IEnumerator`1<byte> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.Cci.UtilityDataStructures.EnumerableMemoryBlockWrapper : object {
    internal MemoryBlock MemBlock;
    internal EnumerableMemoryBlockWrapper(MemoryBlock memBlock);
    public sealed virtual IEnumerator`1<byte> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class Microsoft.Cci.UtilityDataStructures.HashHelper : object {
    public static UInt32 HashInt1(UInt32 key);
    public static UInt32 HashInt2(UInt32 key);
    public static UInt32 HashDoubleInt1(UInt32 key1, UInt32 key2);
    public static UInt32 HashDoubleInt2(UInt32 key1, UInt32 key2);
    public static UInt32 StartHash(UInt32 key);
    public static UInt32 ContinueHash(UInt32 prevHash, UInt32 key);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Cci.UtilityDataStructures.Hashtable/DebugView")]
public class Microsoft.Cci.UtilityDataStructures.Hashtable : object {
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public UInt32 Item { get; public set; }
    public ValuesEnumerable Values { get; }
    public Hashtable(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(UInt32 key, UInt32 value);
    public void Add(UInt32 key, UInt32 value);
    public bool ContainsKey(UInt32 key);
    public UInt32 Find(UInt32 key);
    public UInt32 get_Item(UInt32 key);
    public void set_Item(UInt32 key, UInt32 value);
    public bool TryGetValue(UInt32 key, UInt32& value);
    public ValuesEnumerable get_Values();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Cci.UtilityDataStructures.Hashtable`1/DebugView")]
public class Microsoft.Cci.UtilityDataStructures.Hashtable`1 : object {
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public InternalT Item { get; public set; }
    public ValuesEnumerable<InternalT> Values { get; }
    public Hashtable`1(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(UInt32 key, InternalT value);
    public void Add(UInt32 key, InternalT value);
    public void Clear();
    public InternalT Find(UInt32 key);
    public InternalT get_Item(UInt32 key);
    public void set_Item(UInt32 key, InternalT value);
    public KeyValuePairEnumerator<InternalT> GetEnumerator();
    public ValuesEnumerable<InternalT> get_Values();
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Cci.UtilityDataStructures.Hashtable`2 : object {
    private static Value dummyObject;
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadFactor;
    public UInt32 Count { get; }
    public Value Item { get; public set; }
    public Hashtable`2(UInt32 expectedEntries);
    public Hashtable`2(Hashtable`2<Key, Value> tableToClone);
    private static Hashtable`2();
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public void Clear();
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(Key key, Value value);
    public void Add(Key key, Value value);
    public bool ContainsKey(Key key);
    public void Remove(Key key);
    public Value get_Item(Key key);
    public void set_Item(Key key, Value value);
    public bool TryGetValue(Key key, Value& value);
    public KeyValuePairEnumerator<Key, Value> GetEnumerator();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Cci.UtilityDataStructures.HashtableForUintValues`1/DebugView")]
public class Microsoft.Cci.UtilityDataStructures.HashtableForUintValues`1 : object {
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public UInt32 Item { get; public set; }
    public HashtableForUintValues`1(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public void Clear();
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(Key key, UInt32 value);
    public void Add(Key key, UInt32 value);
    public bool ContainsKey(Key key);
    public UInt32 get_Item(Key key);
    public void set_Item(Key key, UInt32 value);
    public bool TryGetValue(Key key, UInt32& value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Cci.UtilityDataStructures.HashtableUlong`1 : object {
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public InternalT Item { get; public set; }
    public ValuesEnumerable<InternalT> Values { get; }
    public HashtableUlong`1(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(ulong key, InternalT value);
    public void Add(ulong key, InternalT value);
    public void Clear();
    public InternalT Find(ulong key);
    public InternalT get_Item(ulong key);
    public void set_Item(ulong key, InternalT value);
    public ValuesEnumerable<InternalT> get_Values();
}
[DefaultMemberAttribute("Item")]
public interface Microsoft.Cci.UtilityDataStructures.ISimpleReadonlyList`1 {
    public int Count { get; }
    public T Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int i);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.Cci.UtilityDataStructures.ISimpleReadonlyListContract`1 : object {
    public int Count { get; }
    public T Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int i);
}
internal class Microsoft.Cci.UtilityDataStructures.MemoryBlock : ValueType {
    internal Byte* Buffer;
    internal int Length;
    internal MemoryBlock(Byte* buffer, int length);
    internal MemoryBlock(Byte* buffer, UInt32 length);
}
internal class Microsoft.Cci.UtilityDataStructures.MemoryReader : ValueType {
    private Byte* Buffer;
    private Byte* CurrentPointer;
    internal int Length;
    internal UInt32 Offset { get; }
    internal UInt32 RemainingBytes { get; }
    internal bool NotEndOfBytes { get; }
    internal MemoryBlock RemainingMemoryBlock { get; }
    internal MemoryReader(Byte* buffer, int length, int offset);
    internal MemoryReader(Byte* buffer, int length);
    internal MemoryReader(Byte* buffer, UInt32 length);
    internal MemoryReader(MemoryBlock memBlock);
    internal UInt32 get_Offset();
    internal UInt32 get_RemainingBytes();
    internal bool get_NotEndOfBytes();
    internal bool SeekOffset(int offset);
    internal void SkipBytes(int count);
    internal void Align(UInt32 alignment);
    internal MemoryBlock get_RemainingMemoryBlock();
    internal MemoryBlock GetMemoryBlockAt(UInt32 offset, UInt32 length);
    internal MemoryBlock GetMemoryBlockAt(int offset, int length);
    internal short PeekInt16(int offset);
    internal int PeekInt32(int offset);
    internal byte PeekByte(int offset);
    internal ushort PeekUInt16(int offset);
    internal ushort PeekUInt16(UInt32 offset);
    internal UInt32 PeekUInt32(int offset);
    internal UInt32 PeekUInt32(UInt32 offset);
    internal UInt32 PeekReference(int offset, bool smallRefSize);
    internal UInt32 PeekReference(UInt32 offset, bool smallRefSize);
    internal Guid PeekGuid(int offset);
    internal Byte[] PeekBytes(int offset, int byteCount);
    private static string ScanUTF16WithSize(Byte* bytePtr, int byteCount);
    internal string PeekUTF16WithSize(int offset, int byteCount);
    internal int PeekCompressedInt32(int offset, Int32& numberOfBytesRead);
    internal UInt32 PeekCompressedUInt32(UInt32 offset, UInt32& numberOfBytesRead);
    internal string PeekUTF8NullTerminated(int offset, Int32& numberOfBytesRead);
    internal string PeekUTF16WithShortSize(int offset, Int32& numberOfBytesRead);
    internal int BinarySearchForSlot(UInt32 numberOfRows, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal int BinarySearchReference(UInt32 numberOfRows, int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal int LinearSearchReference(int rowSize, int referenceOffset, UInt32 referenceValue, bool isReferenceSmall);
    internal char ReadChar();
    internal sbyte ReadSByte();
    internal short ReadInt16();
    internal int ReadInt32();
    internal long ReadInt64();
    internal byte ReadByte();
    internal ushort ReadUInt16();
    internal UInt32 ReadUInt32();
    internal ulong ReadUInt64();
    internal float ReadSingle();
    internal double ReadDouble();
    internal OperationCode ReadOpcode();
    internal string ReadASCIIWithSize(int byteCount);
    internal string ReadUTF8WithSize(int byteCount);
    internal string ReadUTF16WithSize(int byteCount);
    internal int ReadCompressedUInt32();
    internal int ReadCompressedInt32();
    internal string ReadASCIINullTerminated();
}
public class Microsoft.Cci.UtilityDataStructures.MultiHashtable`1 : object {
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public ValuesEnumerable<InternalT> Values { get; }
    public MultiHashtable`1(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(UInt32 key, InternalT value);
    public void Add(UInt32 key, InternalT value);
    public void Clear();
    public bool Contains(UInt32 key, InternalT value);
    public bool ContainsKey(UInt32 key);
    public int NumberOfEntries(UInt32 key);
    public void ReplaceEntry(UInt32 key, InternalT oldValue, InternalT newValue);
    public KeyedValuesEnumerable<InternalT> GetValuesFor(UInt32 key);
    public ValuesEnumerable<InternalT> get_Values();
}
public class Microsoft.Cci.UtilityDataStructures.MultiHashtable`2 : object {
    private KeyValuePair[] keyValueTable;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private static int loadPercent;
    public UInt32 Count { get; }
    public ValuesEnumerable<Key, InternalT> Values { get; }
    public MultiHashtable`2(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public UInt32 get_Count();
    private void Expand();
    private void AddInternal(Key key, InternalT value);
    public void Add(Key key, InternalT value);
    public void Clear();
    public bool Contains(Key key, InternalT value);
    public bool ContainsKey(Key key);
    public int NumberOfEntries(Key key);
    public void ReplaceEntry(Key key, InternalT oldValue, InternalT newValue);
    public KeyedValuesEnumerable<Key, InternalT> GetValuesFor(Key key);
    public ValuesEnumerable<Key, InternalT> get_Values();
}
public class Microsoft.Cci.UtilityDataStructures.SetOfObjects : object {
    private Object[] elements;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private UInt32 dummyCount;
    private static int loadPercent;
    private static object dummyObject;
    public UInt32 Count { get; }
    public ValuesEnumerable Values { get; }
    public SetOfObjects(UInt32 expectedEntries);
    public SetOfObjects(SetOfObjects setToClone);
    private static SetOfObjects();
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public void Clear();
    public UInt32 get_Count();
    private void Expand();
    private bool AddInternal(object element);
    public bool Add(object element);
    public bool Contains(object element);
    public void Remove(object element);
    public ValuesEnumerable get_Values();
}
[DebuggerTypeProxyAttribute("Microsoft.Cci.UtilityDataStructures.SetOfUints/DebugView")]
public class Microsoft.Cci.UtilityDataStructures.SetOfUints : object {
    private UInt32[] elements;
    private UInt32 size;
    private UInt32 resizeCount;
    private UInt32 count;
    private UInt32 dummyCount;
    private static int loadPercent;
    public UInt32 Count { get; }
    public ValuesEnumerable Values { get; }
    public SetOfUints(UInt32 expectedEntries);
    private static UInt32 SizeFromExpectedEntries(UInt32 expectedEntries);
    public void Clear();
    public UInt32 get_Count();
    private void Expand();
    private bool AddInternal(UInt32 element);
    public bool Add(UInt32 element);
    public bool Contains(UInt32 element);
    public void Remove(UInt32 element);
    public ValuesEnumerable get_Values();
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.Cci.UtilityDataStructures.Sublist`1/DebugView")]
public class Microsoft.Cci.UtilityDataStructures.Sublist`1 : ValueType {
    private List`1<T> masterList;
    private int offset;
    private int count;
    public int Count { get; }
    public T Item { get; public set; }
    public Sublist`1(List`1<T> masterList, int offset, int count);
    private void ObjectInvariant();
    public sealed virtual int get_Count();
    public int Find(T element);
    public Sublist`1<T> GetSublist(int offset, int count);
    public sealed virtual T get_Item(int i);
    public void set_Item(int i, T value);
    public Enumerator<T> GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.Cci.VirtualReadOnlyList`1 : object {
    private static int GetEnumeratorNotCalled;
    private int m_initialThreadId;
    private int m_count;
    private int m_index;
    public int Count { get; }
    public T Item { get; }
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public VirtualReadOnlyList`1(int count);
    public sealed virtual int get_Count();
    public abstract virtual T GetItem(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual bool MoveNext();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class Microsoft.Cci.WriterUtilities.BinaryWriter : object {
    private MemoryStream baseStream;
    private bool UTF8;
    public MemoryStream BaseStream { get; internal set; }
    public BinaryWriter(MemoryStream output);
    public BinaryWriter(MemoryStream output, bool unicode);
    private void ObjectInvariant();
    public MemoryStream get_BaseStream();
    internal void set_BaseStream(MemoryStream value);
    internal void SetUnicode(bool unicode);
    public void Align(UInt32 alignment);
    public void WriteBool(bool value);
    public void WriteByte(byte value);
    public void WriteSbyte(sbyte value);
    public void WriteBytes(Byte[] buffer);
    internal void WriteBytes(IEnumerable`1<byte> buffer);
    public void WriteChars(Char[] chars);
    public void WriteDouble(double value);
    public void WriteShort(short value);
    public void WriteUshort(ushort value);
    public void WriteInt(int value);
    public void WriteUint(UInt32 value);
    public void WriteLong(long value);
    public void WriteUlong(ulong value);
    public void WriteFloat(float value);
    public void WriteString(string str);
    public void WriteString(string str, bool emitNullTerminator);
    public void WriteCompressedFullInt(int value);
    public void WriteCompressedFullUInt(UInt32 value);
    public void WriteCompressedInt(int val);
    public void WriteCompressedUInt(UInt32 val);
    public static UInt32 GetUTF8ByteCount(string str);
}
[ExtensionAttribute]
internal static class Microsoft.Cci.WriterUtilities.BinaryWriterCache : object {
    [ThreadStaticAttribute]
private static BinaryWriter ts_CachedWriter1;
    [ThreadStaticAttribute]
private static BinaryWriter ts_CachedWriter2;
    private static UInt32 s_Capacity;
    private static BinaryWriterCache();
    public static BinaryWriter Acquire(bool unicode);
    [ExtensionAttribute]
public static void ReleaseToCache(BinaryWriter writer);
    [ExtensionAttribute]
public static Byte[] ToArrayAndRelease(BinaryWriter writer);
}
public class Microsoft.Cci.WriterUtilities.MemoryStream : object {
    public Byte[] Buffer;
    public UInt32 Length;
    private UInt32 position;
    private bool reusable;
    public UInt32 Position { get; public set; }
    public MemoryStream(UInt32 initialSize);
    private void Grow(Byte[] myBuffer, UInt32 n, UInt32 m);
    public UInt32 get_Position();
    public void set_Position(UInt32 value);
    public Byte[] ToArray();
    public void Write(Byte[] buffer, UInt32 index, UInt32 count);
    public void WriteTo(MemoryStream stream);
    public void WriteTo(Stream stream);
    internal bool ClearForReuse();
}
internal class Microsoft.Cci.WriterUtilities.MemoryStreamList : object {
    private static int BlockSize;
    private MemoryStream m_stream;
    private BinaryWriter m_writer;
    private List`1<MemoryStream> m_flushedStreams;
    private UInt32 m_flushedLength;
    public BinaryWriter Writer { get; }
    public UInt32 Length { get; }
    public UInt32 Position { get; }
    public BinaryWriter get_Writer();
    public UInt32 get_Length();
    public UInt32 get_Position();
    public void CheckFlush();
    public void WriteTo(Stream s);
}
[ExtensionAttribute]
internal static class System.Collections.Generic.MyExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> AsReadOnly(List`1<T> This);
}
[ComVisibleAttribute("True")]
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymDocumentType : object {
    public static Guid Text;
    private static SymDocumentType();
}
[ComVisibleAttribute("True")]
public class System.Diagnostics.SymbolStore.SymLanguageType : object {
    public static Guid C;
    public static Guid CPlusPlus;
    public static Guid CSharp;
    public static Guid Basic;
    public static Guid Java;
    public static Guid Cobol;
    public static Guid Pascal;
    public static Guid ILAssembly;
    public static Guid JScript;
    public static Guid SMC;
    public static Guid MCPlusPlus;
    private static SymLanguageType();
}
internal static class System.Runtime.InteropServices.UnmanagedTypeEx : object {
    public static UnmanagedType CustomMarshaler;
}
internal class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
