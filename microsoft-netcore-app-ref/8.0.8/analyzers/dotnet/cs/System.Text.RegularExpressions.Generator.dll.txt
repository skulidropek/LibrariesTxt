internal static class FxResources.System.Text.RegularExpressions.Generator.SR : object {
}
internal static class Microsoft.CodeAnalysis.DotnetRuntime.Extensions.DiagnosticDescriptorHelper : object {
    public static DiagnosticDescriptor Create(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description, String[] customTags);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DotnetRuntime.Extensions.RoslynExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetBestTypeByMetadataName(Compilation compilation, string fullyQualifiedMetadataName);
    [ExtensionAttribute]
public static INamedTypeSymbol GetBestTypeByMetadataName(Compilation compilation, Type type);
    [ExtensionAttribute]
private static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
internal static bool HasAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(ReadOnlySpan`1<T> span);
    [ExtensionAttribute]
public static SimpleNameSyntax GetUnqualifiedName(NameSyntax name);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.CharExtensions : object {
    public static bool IsAsciiLetter(char c);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; public set; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public void set_Length(int value);
    public T& get_Item(int index);
    public void Append(T item);
    public void Append(ReadOnlySpan`1<T> source);
    private void AppendMultiChar(ReadOnlySpan`1<T> source);
    public void Insert(int index, ReadOnlySpan`1<T> source);
    public Span`1<T> AppendSpan(int length);
    private Span`1<T> AppendSpanWithGrow(int length);
    private void AddWithResize(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public bool TryCopyTo(Span`1<T> destination, Int32& itemsWritten);
    public void Dispose();
    private void Grow(int additionalCapacityRequired);
    public T Pop();
}
[ExtensionAttribute]
internal static class System.Collections.HashtableExtensions : object {
    [ExtensionAttribute]
public static bool TryGetValue(Hashtable table, object key, T& value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToBytesBuffer(byte value, Span`1<byte> buffer, int startingIndex, Casing casing);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static int FromUpperChar(int c);
    public static int FromLowerChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal static class System.Numerics.BitOperations : object {
    public static bool IsPow2(int value);
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadResetAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
    internal static string RegexCompileToAssemblyMessage;
    internal static string RegexCompileToAssemblyDiagId;
    internal static string AssemblyNameMembersMessage;
    internal static string AssemblyNameMembersDiagId;
    internal static string SystemDataSerializationFormatBinaryMessage;
    internal static string SystemDataSerializationFormatBinaryDiagId;
    internal static string TlsVersion10and11Message;
    internal static string TlsVersion10and11DiagId;
    internal static string EncryptionPolicyMessage;
    internal static string EncryptionPolicyDiagId;
    internal static string Rfc2898OutdatedCtorMessage;
    internal static string Rfc2898OutdatedCtorDiagId;
    internal static string EccXmlExportImportMessage;
    internal static string EccXmlExportImportDiagId;
    internal static string EcDhPublicKeyBlobMessage;
    internal static string EcDhPublicKeyBlobDiagId;
    internal static string AssemblyNameCodeBaseMessage;
    internal static string AssemblyNameCodeBaseDiagId;
    internal static string CryptoStringFactoryMessage;
    internal static string CryptoStringFactoryDiagId;
    internal static string ControlledExecutionRunMessage;
    internal static string ControlledExecutionRunDiagId;
    internal static string XmlSecureResolverMessage;
    internal static string XmlSecureResolverDiagId;
    internal static string RsaEncryptDecryptValueMessage;
    internal static string RsaEncryptDecryptDiagId;
    internal static string JsonSerializerOptionsAddContextMessage;
    internal static string JsonSerializerOptionsAddContextDiagId;
    internal static string LegacyFormatterMessage;
    internal static string LegacyFormatterDiagId;
    internal static string LegacyFormatterImplMessage;
    internal static string LegacyFormatterImplDiagId;
    internal static string RegexExtensibilityImplMessage;
    internal static string RegexExtensibilityDiagId;
    internal static string AesGcmTagConstructorMessage;
    internal static string AesGcmTagConstructorDiagId;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string InvalidGeneratedRegexAttributeTitle { get; }
    internal static string InvalidGeneratedRegexAttributeMessage { get; }
    internal static string MultipleGeneratedRegexAttributesMessage { get; }
    internal static string InvalidRegexArgumentsMessage { get; }
    internal static string RegexMethodMustHaveValidSignatureMessage { get; }
    internal static string LimitedSourceGenerationTitle { get; }
    internal static string LimitedSourceGenerationMessage { get; }
    internal static string Generic { get; }
    internal static string AlternationHasNamedCapture { get; }
    internal static string AlternationHasComment { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string ShorthandClassInCharacterRange { get; }
    internal static string BeginIndexNotNegative { get; }
    internal static string QuantifierOrCaptureGroupOutOfRange { get; }
    internal static string CaptureGroupOfZero { get; }
    internal static string CountTooSmall { get; }
    internal static string EnumNotStarted { get; }
    internal static string AlternationHasMalformedCondition { get; }
    internal static string IllegalDefaultRegexMatchTimeoutInAppDomain { get; }
    internal static string UnescapedEndingBackslash { get; }
    internal static string ReversedQuantifierRange { get; }
    internal static string InvalidUnicodePropertyEscape { get; }
    internal static string CaptureGroupNameInvalid { get; }
    internal static string LengthNotNegative { get; }
    internal static string MalformedNamedReference { get; }
    internal static string AlternationHasMalformedReference { get; }
    internal static string MalformedUnicodePropertyEscape { get; }
    internal static string MakeException { get; }
    internal static string MissingControlCharacter { get; }
    internal static string NestedQuantifiersNotParenthesized { get; }
    internal static string NoResultOnFailed { get; }
    internal static string InsufficientClosingParentheses { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string PlatformNotSupported_CompileToAssembly { get; }
    internal static string QuantifierAfterNothing { get; }
    internal static string RegexMatchTimeoutException_Occurred { get; }
    internal static string ReversedCharacterRange { get; }
    internal static string ExclusionGroupNotLast { get; }
    internal static string InsufficientOrInvalidHexDigits { get; }
    internal static string AlternationHasTooManyConditions { get; }
    internal static string InsufficientOpeningParentheses { get; }
    internal static string UndefinedNumberedReference { get; }
    internal static string UndefinedNamedReference { get; }
    internal static string AlternationHasUndefinedReference { get; }
    internal static string UnrecognizedUnicodeProperty { get; }
    internal static string UnrecognizedControlCharacter { get; }
    internal static string UnrecognizedEscape { get; }
    internal static string InvalidGroupingConstruct { get; }
    internal static string UnterminatedBracket { get; }
    internal static string UnterminatedComment { get; }
    internal static string UseRegexSourceGeneratorMessage { get; }
    internal static string UseRegexSourceGeneratorTitle { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    private static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_InvalidGeneratedRegexAttributeTitle();
    internal static string get_InvalidGeneratedRegexAttributeMessage();
    internal static string get_MultipleGeneratedRegexAttributesMessage();
    internal static string get_InvalidRegexArgumentsMessage();
    internal static string get_RegexMethodMustHaveValidSignatureMessage();
    internal static string get_LimitedSourceGenerationTitle();
    internal static string get_LimitedSourceGenerationMessage();
    internal static string get_Generic();
    internal static string get_AlternationHasNamedCapture();
    internal static string get_AlternationHasComment();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_ShorthandClassInCharacterRange();
    internal static string get_BeginIndexNotNegative();
    internal static string get_QuantifierOrCaptureGroupOutOfRange();
    internal static string get_CaptureGroupOfZero();
    internal static string get_CountTooSmall();
    internal static string get_EnumNotStarted();
    internal static string get_AlternationHasMalformedCondition();
    internal static string get_IllegalDefaultRegexMatchTimeoutInAppDomain();
    internal static string get_UnescapedEndingBackslash();
    internal static string get_ReversedQuantifierRange();
    internal static string get_InvalidUnicodePropertyEscape();
    internal static string get_CaptureGroupNameInvalid();
    internal static string get_LengthNotNegative();
    internal static string get_MalformedNamedReference();
    internal static string get_AlternationHasMalformedReference();
    internal static string get_MalformedUnicodePropertyEscape();
    internal static string get_MakeException();
    internal static string get_MissingControlCharacter();
    internal static string get_NestedQuantifiersNotParenthesized();
    internal static string get_NoResultOnFailed();
    internal static string get_InsufficientClosingParentheses();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_PlatformNotSupported_CompileToAssembly();
    internal static string get_QuantifierAfterNothing();
    internal static string get_RegexMatchTimeoutException_Occurred();
    internal static string get_ReversedCharacterRange();
    internal static string get_ExclusionGroupNotLast();
    internal static string get_InsufficientOrInvalidHexDigits();
    internal static string get_AlternationHasTooManyConditions();
    internal static string get_InsufficientOpeningParentheses();
    internal static string get_UndefinedNumberedReference();
    internal static string get_UndefinedNamedReference();
    internal static string get_AlternationHasUndefinedReference();
    internal static string get_UnrecognizedUnicodeProperty();
    internal static string get_UnrecognizedControlCharacter();
    internal static string get_UnrecognizedEscape();
    internal static string get_InvalidGroupingConstruct();
    internal static string get_UnterminatedBracket();
    internal static string get_UnterminatedComment();
    internal static string get_UseRegexSourceGeneratorMessage();
    internal static string get_UseRegexSourceGeneratorTitle();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    [ExtensionAttribute]
public static int CommonPrefixLength(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other);
}
internal class System.Text.RegularExpressions.AnalysisResults : object {
    internal bool _complete;
    internal HashSet`1<RegexNode> _isAtomicByAncestor;
    internal HashSet`1<RegexNode> _containsCapture;
    internal HashSet`1<RegexNode> _mayBacktrack;
    internal HashSet`1<RegexNode> _inLoops;
    internal bool _hasIgnoreCase;
    internal bool _hasRightToLeft;
    [CompilerGeneratedAttribute]
private RegexTree <RegexTree>k__BackingField;
    public RegexTree RegexTree { get; }
    public bool HasIgnoreCase { get; }
    public bool HasRightToLeft { get; }
    internal AnalysisResults(RegexTree regexTree);
    [CompilerGeneratedAttribute]
public RegexTree get_RegexTree();
    public bool IsAtomicByAncestor(RegexNode node);
    public bool MayContainCapture(RegexNode node);
    public bool MayBacktrack(RegexNode node);
    public bool IsInLoop(RegexNode node);
    public bool get_HasIgnoreCase();
    public bool get_HasRightToLeft();
}
internal enum System.Text.RegularExpressions.FindNextStartingPositionMode : Enum {
    public int value__;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_Beginning;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_Start;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_EndZ;
    public static FindNextStartingPositionMode LeadingAnchor_LeftToRight_End;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_Beginning;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_Start;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_EndZ;
    public static FindNextStartingPositionMode LeadingAnchor_RightToLeft_End;
    public static FindNextStartingPositionMode TrailingAnchor_FixedLength_LeftToRight_End;
    public static FindNextStartingPositionMode TrailingAnchor_FixedLength_LeftToRight_EndZ;
    public static FindNextStartingPositionMode LeadingString_LeftToRight;
    public static FindNextStartingPositionMode LeadingString_RightToLeft;
    public static FindNextStartingPositionMode LeadingString_OrdinalIgnoreCase_LeftToRight;
    public static FindNextStartingPositionMode LeadingSet_LeftToRight;
    public static FindNextStartingPositionMode LeadingSet_RightToLeft;
    public static FindNextStartingPositionMode LeadingChar_RightToLeft;
    public static FindNextStartingPositionMode FixedDistanceChar_LeftToRight;
    public static FindNextStartingPositionMode FixedDistanceString_LeftToRight;
    public static FindNextStartingPositionMode FixedDistanceSets_LeftToRight;
    public static FindNextStartingPositionMode LiteralAfterLoop_LeftToRight;
    public static FindNextStartingPositionMode NoSearch;
}
internal static class System.Text.RegularExpressions.Generator.DiagnosticDescriptors : object {
    private static string Category;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <InvalidGeneratedRegexAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <MultipleGeneratedRegexAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <InvalidRegexArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <RegexMethodMustHaveValidSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <LimitedSourceGeneration>k__BackingField;
    [CompilerGeneratedAttribute]
private static DiagnosticDescriptor <UseRegexSourceGeneration>k__BackingField;
    public static DiagnosticDescriptor InvalidGeneratedRegexAttribute { get; }
    public static DiagnosticDescriptor MultipleGeneratedRegexAttributes { get; }
    public static DiagnosticDescriptor InvalidRegexArguments { get; }
    public static DiagnosticDescriptor RegexMethodMustHaveValidSignature { get; }
    public static DiagnosticDescriptor LimitedSourceGeneration { get; }
    public static DiagnosticDescriptor UseRegexSourceGeneration { get; }
    private static DiagnosticDescriptors();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_InvalidGeneratedRegexAttribute();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_MultipleGeneratedRegexAttributes();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_InvalidRegexArguments();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_RegexMethodMustHaveValidSignature();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_LimitedSourceGeneration();
    [CompilerGeneratedAttribute]
public static DiagnosticDescriptor get_UseRegexSourceGeneration();
}
[GeneratorAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class System.Text.RegularExpressions.Generator.RegexGenerator : object {
    private static string HelpersTypeName;
    private static string GeneratedNamespace;
    private static string s_generatedCodeAttribute;
    private static String[] s_headers;
    private static string DefaultTimeoutFieldName;
    private static string HasDefaultTimeoutFieldName;
    private static string RegexName;
    private static string GeneratedRegexAttributeName;
    private static RegexGenerator();
    public sealed virtual void Initialize(IncrementalGeneratorInitializationContext context);
    private static bool SupportsCodeGeneration(RegexMethod method, LanguageVersion languageVersion, String& reason);
    private static string EscapeXmlComment(string text);
    private static void EmitRegexPartialMethod(RegexMethod regexMethod, IndentedTextWriter writer);
    private static void EmitRegexLimitedBoilerplate(IndentedTextWriter writer, RegexMethod rm, string reason, LanguageVersion langVer);
    private static void EmitRegexDerivedImplementation(IndentedTextWriter writer, RegexMethod rm, string runnerFactoryImplementation, bool allowUnsafe);
    private static void EmitRegexDerivedTypeRunnerFactory(IndentedTextWriter writer, RegexMethod rm, Dictionary`2<string, String[]> requiredHelpers, bool checkOverflow);
    private static string GetTimeoutExpression(int matchTimeout);
    private static void AddIsWordCharHelper(Dictionary`2<string, String[]> requiredHelpers);
    private static void AddIsBoundaryHelper(Dictionary`2<string, String[]> requiredHelpers, bool checkOverflow);
    private static void AddIsECMABoundaryHelper(Dictionary`2<string, String[]> requiredHelpers, bool checkOverflow);
    private static string EmitSearchValuesOrLiteral(ReadOnlySpan`1<char> chars, Dictionary`2<string, String[]> requiredHelpers);
    private static string EmitSearchValues(Char[] chars, Dictionary`2<string, String[]> requiredHelpers);
    private static string EmitIndexOfAnyCustomHelper(string set, Dictionary`2<string, String[]> requiredHelpers, bool checkOverflow);
    private static ValueTuple`2<bool, bool> EmitScan(IndentedTextWriter writer, RegexMethod rm);
    private static void EmitTryFindNextPossibleStartingPosition(IndentedTextWriter writer, RegexMethod rm, Dictionary`2<string, String[]> requiredHelpers, bool checkOverflow);
    private static void EmitTryMatchAtCurrentPosition(IndentedTextWriter writer, RegexMethod rm, Dictionary`2<string, String[]> requiredHelpers, bool checkOverflow);
    private static void EmitTimeoutCheckIfNeeded(IndentedTextWriter writer, RegexMethod rm, bool appendNewLineIfTimeoutEmitted);
    private static bool TryEmitIndexOf(Dictionary`2<string, String[]> requiredHelpers, RegexNode node, bool useLast, bool negate, Int32& literalLength, String& indexOfExpr);
    private static string MatchCharacterClass(string chExpr, string charClass, bool negate, HashSet`1<string> additionalDeclarations, Dictionary`2<string, String[]> requiredHelpers);
    private static void InsertAdditionalDeclarations(IndentedTextWriter writer, HashSet`1<string> declarations, int position, int indent);
    private static string Literal(char c);
    private static string Literal(string s, bool quote);
    private static string Literal(RegexOptions options);
    private static string DescribeNode(RegexNode node, RegexMethod rm);
    private static string DescribeCapture(int capNum, RegexMethod rm);
    private static string DescribeSet(string charClass);
    private static void DescribeExpressionAsXmlComment(TextWriter writer, RegexNode node, RegexMethod rm, int depth);
    private static string DescribeLoop(RegexNode node, RegexMethod rm);
    private static FinishEmitBlock EmitBlock(IndentedTextWriter writer, string clause, bool faux);
    private static void EmitAdd(IndentedTextWriter writer, string variable, int value);
    private static object GetRegexMethodDataOrFailureDiagnostic(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <SupportsCodeGeneration>g__HasCaseInsensitiveBackReferences|6_0(RegexNode node);
    [CompilerGeneratedAttribute]
internal static void <EmitRegexDerivedImplementation>g__AppendHashtableContents|13_2(IndentedTextWriter writer, IEnumerable`1<DictionaryEntry> contents);
    [CompilerGeneratedAttribute]
internal static void <EmitRegexDerivedTypeRunnerFactory>g__EnterCheckOverflow|14_0(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitRegexDerivedTypeRunnerFactory>g__ExitCheckOverflow|14_1(<>c__DisplayClass14_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitTryFindNextPossibleStartingPosition>g__Goto|23_0(string label, <>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static bool <EmitTryFindNextPossibleStartingPosition>g__EmitAnchors|23_1(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitTryFindNextPossibleStartingPosition>g__EmitIndexOf_LeftToRight|23_2(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitTryFindNextPossibleStartingPosition>g__EmitIndexOf_RightToLeft|23_3(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitTryFindNextPossibleStartingPosition>g__EmitFixedSet_LeftToRight|23_4(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitTryFindNextPossibleStartingPosition>g__EmitFixedSet_RightToLeft|23_5(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static void <EmitTryFindNextPossibleStartingPosition>g__EmitLiteralAfterAtomicLoop|23_6(<>c__DisplayClass23_0& );
    [CompilerGeneratedAttribute]
internal static string <EmitTryMatchAtCurrentPosition>g__Sum|24_6(int constant, string local);
    [CompilerGeneratedAttribute]
internal static RegexNode <EmitTryMatchAtCurrentPosition>g__CloneMultiWithoutFirstChar|24_44(RegexNode node);
    [CompilerGeneratedAttribute]
internal static RegexNode <EmitTryMatchAtCurrentPosition>g__GetSubsequentOrDefault|24_46(int index, RegexNode node, RegexNode defaultNode);
    [CompilerGeneratedAttribute]
internal static string <EmitTryMatchAtCurrentPosition>g__CountIsLessThan|24_34(string count, int exclusiveUpper);
    [CompilerGeneratedAttribute]
internal static string <EmitTryMatchAtCurrentPosition>g__CountIsGreaterThanOrEqualTo|24_35(string count, int exclusiveUpper);
    [CompilerGeneratedAttribute]
internal static string <EmitTryMatchAtCurrentPosition>g__StackPop|24_39();
    [CompilerGeneratedAttribute]
internal static string <EmitTryMatchAtCurrentPosition>g__FormatN|24_40(string format, int count);
    [CompilerGeneratedAttribute]
internal static string <MatchCharacterClass>g__EmitContainsNoAscii|27_1(<>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static string <MatchCharacterClass>g__EmitAllAsciiContained|27_2(<>c__DisplayClass27_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetRegexMethodDataOrFailureDiagnostic>g__IsAllowedKind|42_1(SyntaxKind kind);
    [CompilerGeneratedAttribute]
internal static Location <GetRegexMethodDataOrFailureDiagnostic>g__GetComparableLocation|42_2(MethodDeclarationSyntax method);
}
[DiagnosticAnalyzerAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
public class System.Text.RegularExpressions.Generator.UpgradeToGeneratedRegexAnalyzer : DiagnosticAnalyzer {
    private static string RegexTypeName;
    private static string GeneratedRegexTypeName;
    internal static string PatternArgumentName;
    internal static string OptionsArgumentName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    [NullableContextAttribute("1")]
public virtual void Initialize(AnalysisContext context);
    private static void AnalyzeInvocation(OperationAnalysisContext context, INamedTypeSymbol regexTypeSymbol, HashSet`1<IMethodSymbol> staticMethodsToDetect);
    private static void AnalyzeObjectCreation(OperationAnalysisContext context, INamedTypeSymbol regexTypeSymbol);
    private static bool ValidateParameters(ImmutableArray`1<IArgumentOperation> arguments);
    private static bool ProjectSupportsRegexSourceGenerator(Compilation compilation, INamedTypeSymbol& regexTypeSymbol);
    [CompilerGeneratedAttribute]
internal static HashSet`1<IMethodSymbol> <Initialize>g__GetMethodSymbolHash|6_1(INamedTypeSymbol regexTypeSymbol, HashSet`1<string> methodNames);
}
[ExportCodeFixProviderAttribute("C#", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
public class System.Text.RegularExpressions.Generator.UpgradeToGeneratedRegexCodeFixer : CodeFixProvider {
    private static string RegexTypeName;
    private static string GeneratedRegexTypeName;
    private static string DefaultRegexMethodName;
    private static Char[] s_comma;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    private static UpgradeToGeneratedRegexCodeFixer();
    public virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("System.Text.RegularExpressions.Generator.UpgradeToGeneratedRegexCodeFixer/<RegisterCodeFixesAsync>d__7")]
public virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [AsyncStateMachineAttribute("System.Text.RegularExpressions.Generator.UpgradeToGeneratedRegexCodeFixer/<ConvertToSourceGenerator>d__8")]
private static Task`1<Document> ConvertToSourceGenerator(Document document, SyntaxNode root, SyntaxNode nodeToFix, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("System.Text.RegularExpressions.Generator.UpgradeToGeneratedRegexCodeFixer/<<ConvertToSourceGenerator>g__GetAllMembers|8_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ISymbol> <ConvertToSourceGenerator>g__GetAllMembers|8_1(ITypeSymbol symbol);
    [CompilerGeneratedAttribute]
internal static string <ConvertToSourceGenerator>g__GetRegexPatternFromArgument|8_2(ImmutableArray`1<IArgumentOperation> arguments);
    [CompilerGeneratedAttribute]
internal static RegexOptions <ConvertToSourceGenerator>g__GetRegexOptionsFromArgument|8_3(ImmutableArray`1<IArgumentOperation> arguments);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ConvertToSourceGenerator>g__GetNode|8_4(ImmutableArray`1<IArgumentOperation> arguments, SyntaxGenerator generator, string parameterName);
    [CompilerGeneratedAttribute]
internal static string <ConvertToSourceGenerator>g__Literal|8_5(string stringifiedRegexOptions);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <ConvertToSourceGenerator>g__WithTrivia|8_6(SyntaxNode method, SyntaxNode nodeToFix);
}
internal enum System.Text.RegularExpressions.RegexCaseBehavior : Enum {
    public int value__;
    public static RegexCaseBehavior NotSet;
    public static RegexCaseBehavior Invariant;
    public static RegexCaseBehavior NonTurkish;
    public static RegexCaseBehavior Turkish;
}
internal static class System.Text.RegularExpressions.RegexCaseEquivalences : object {
    public static int CharactersPerRange;
    private static ReadOnlySpan`1<char> EquivalenceCasingValues { get; }
    private static ReadOnlySpan`1<ushort> EquivalenceFirstLevelLookup { get; }
    private static ReadOnlySpan`1<ushort> EquivalenceCasingMap { get; }
    private static ReadOnlySpan`1<char> get_EquivalenceCasingValues();
    private static ReadOnlySpan`1<ushort> get_EquivalenceFirstLevelLookup();
    private static ReadOnlySpan`1<ushort> get_EquivalenceCasingMap();
    public static bool TryFindCaseEquivalencesForCharWithIBehavior(char c, CultureInfo culture, RegexCaseBehavior& mappingBehavior, ReadOnlySpan`1& equivalences);
    public static RegexCaseBehavior GetRegexBehavior(CultureInfo culture);
    private static bool TryFindCaseEquivalencesForChar(char c, ReadOnlySpan`1& equivalences);
    [CompilerGeneratedAttribute]
internal static bool <GetRegexBehavior>g__IsTurkishOrAzeri|8_0(string cultureName);
}
internal class System.Text.RegularExpressions.RegexCharClass : object {
    internal static int FlagsIndex;
    internal static int SetLengthIndex;
    internal static int CategoryLengthIndex;
    internal static int SetStartIndex;
    internal static char LastChar;
    internal static short SpaceConst;
    private static short NotSpaceConst;
    private static string InternalRegexIgnoreCase;
    private static string SpaceCategories;
    private static string NotSpaceCategories;
    private static string WordCategories;
    private static string NotWordCategories;
    internal static string SpaceClass;
    internal static string NotSpaceClass;
    internal static string WordClass;
    internal static string NotWordClass;
    internal static string DigitClass;
    internal static string NotDigitClass;
    internal static string ControlClass;
    internal static string NotControlClass;
    internal static string LetterClass;
    internal static string NotLetterClass;
    internal static string LetterOrDigitClass;
    internal static string NotLetterOrDigitClass;
    internal static string LowerClass;
    internal static string NotLowerClass;
    internal static string UpperClass;
    internal static string NotUpperClass;
    internal static string NumberClass;
    internal static string NotNumberClass;
    internal static string PunctuationClass;
    internal static string NotPunctuationClass;
    internal static string SeparatorClass;
    internal static string NotSeparatorClass;
    internal static string SymbolClass;
    internal static string NotSymbolClass;
    internal static string AsciiLetterClass;
    internal static string NotAsciiLetterClass;
    internal static string AsciiLetterOrDigitClass;
    internal static string NotAsciiLetterOrDigitClass;
    internal static string HexDigitClass;
    internal static string NotHexDigitClass;
    internal static string HexDigitUpperClass;
    internal static string NotHexDigitUpperClass;
    internal static string HexDigitLowerClass;
    internal static string NotHexDigitLowerClass;
    private static string ECMASpaceRanges;
    private static string NotECMASpaceRanges;
    private static string ECMAWordRanges;
    private static string NotECMAWordRanges;
    private static string ECMADigitRanges;
    private static string NotECMADigitRanges;
    internal static string ECMASpaceClass;
    internal static string NotECMASpaceClass;
    internal static string ECMAWordClass;
    internal static string NotECMAWordClass;
    internal static string ECMADigitClass;
    internal static string NotECMADigitClass;
    internal static string NotNewLineClass;
    internal static string AnyClass;
    private static string EmptyClass;
    internal static string WordNotWordClass;
    internal static string NotWordWordClass;
    internal static string DigitNotDigitClass;
    internal static string NotDigitDigitClass;
    internal static string SpaceNotSpaceClass;
    internal static string NotSpaceSpaceClass;
    private static int DefinedCategoriesCapacity;
    private static Dictionary`2<string, string> s_definedCategories;
    private static String[][] s_propTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<char, char>> _rangelist;
    private StringBuilder _categories;
    private RegexCharClass _subtractor;
    private bool _negate;
    private RegexCaseBehavior _caseBehavior;
    private static int WordCategoriesMask;
    private static String[] s_asciiStrings;
    private static String[] s_asciiLetterPairStrings;
    private static String[] CategoryIdToName;
    public bool CanMerge { get; }
    unknown bool Negate {public set; }
    private static ReadOnlySpan`1<byte> WordCharAsciiLookup { get; }
    private RegexCharClass(bool negate, List`1<ValueTuple`2<char, char>> ranges, StringBuilder categories, RegexCharClass subtraction);
    private static RegexCharClass();
    public bool get_CanMerge();
    public void set_Negate(bool value);
    public void AddChar(char c);
    public void AddCharClass(RegexCharClass cc);
    public bool TryAddCharClass(RegexCharClass cc);
    private StringBuilder EnsureCategories();
    private List`1<ValueTuple`2<char, char>> EnsureRangeList();
    private void AddRanges(ReadOnlySpan`1<char> set);
    public void AddSubtraction(RegexCharClass sub);
    public void AddRange(char first, char last);
    public void AddCategoryFromName(string categoryName, bool invert, bool caseInsensitive, string pattern, int currentPos);
    private void AddCategory(string category);
    public void AddCaseEquivalences(CultureInfo culture);
    private void AddCaseEquivalenceRange(char chMin, char chMax, CultureInfo culture);
    public void AddWord(bool ecma, bool negate);
    public void AddSpace(bool ecma, bool negate);
    public void AddDigit(bool ecma, bool negate, string pattern, int currentPos);
    public static string ConvertOldStringsToClass(string set, string category);
    public static char SingletonChar(string set);
    public static bool IsMergeable(string charClass);
    public static bool IsEmpty(string charClass);
    public static bool IsSingleton(string set);
    public static bool IsSingletonInverse(string set);
    public static bool TryGetOnlyCategories(string set, Span`1<UnicodeCategory> categories, Int32& numCategories, Boolean& negated);
    public static bool TryGetSingleRange(string set, Char& lowInclusive, Char& highInclusive);
    public static bool TryGetDoubleRange(string set, ValueTuple`2& range0, ValueTuple`2& range1);
    public static int GetSetChars(string set, Span`1<char> chars);
    public static bool TryGetAsciiSetChars(string set, Char[]& asciiChars);
    public static bool MayOverlap(string set1, string set2);
    public static bool ParticipatesInCaseConversion(int comparison);
    public static bool ParticipatesInCaseConversion(ReadOnlySpan`1<char> s);
    public static bool IsAscii(ReadOnlySpan`1<char> s);
    private static bool CanEasilyEnumerateSetContents(string set);
    private static bool CanEasilyEnumerateSetContents(string set, Boolean& hasSubtraction);
    internal static CharClassAnalysisResults Analyze(string set);
    internal static bool IsSubtraction(string charClass);
    internal static bool IsNegated(string set);
    internal static bool IsNegated(string set, int setOffset);
    public static bool IsECMAWordChar(char ch);
    private static ReadOnlySpan`1<byte> get_WordCharAsciiLookup();
    public static bool IsWordChar(char ch);
    public static bool IsBoundaryWordChar(char ch);
    public static bool DifferByOneBit(char a, char b, Int32& mask);
    public static bool CharInClass(char ch, string set, UInt32[]& asciiLazyCache);
    public static bool CharInClass(char ch, string set);
    private static bool CharInClassRecursive(char ch, string set, int start);
    private static bool CharInClassInternal(char ch, string set, int start, int setLength, int categoryLength);
    private static bool CharInCategory(char ch, ReadOnlySpan`1<char> categorySetSegment);
    private static bool CharInCategoryGroup(UnicodeCategory chcategory, ReadOnlySpan`1<char> category, Int32& i);
    public static RegexCharClass Parse(string charClass);
    private static RegexCharClass ParseRecursive(string charClass, int start);
    public static List`1<ValueTuple`2<char, char>> ComputeRanges(ReadOnlySpan`1<char> set);
    public static string OneToStringClass(char c);
    internal static string CharsToStringClass(ReadOnlySpan`1<char> chars);
    public string ToStringClass();
    private void ToStringClass(ValueStringBuilder& vsb);
    private void Canonicalize();
    private static ReadOnlySpan`1<char> RangesFromProperty(string capname, bool invert, string pattern, int currentPos);
    private static String[] PopulateCategoryIdToName();
    public static string DescribeSet(string set);
    public static string DescribeChar(char ch);
    private static string DescribeCategory(char ch);
    [CompilerGeneratedAttribute]
internal static bool <MayOverlap>g__KnownDistinctSets|107_0(string set1, string set2);
    [CompilerGeneratedAttribute]
internal static bool <MayOverlap>g__MayOverlapByEnumeration|107_1(string set1, string set2);
    [CompilerGeneratedAttribute]
internal static bool <CharInClass>g__InitializeValue|125_0(char ch, string set, UInt32[]& asciiLazyCache);
    [CompilerGeneratedAttribute]
internal static void <DescribeSet>g__RenderRanges|144_0(<>c__DisplayClass144_0& );
}
internal class System.Text.RegularExpressions.RegexFindOptimizations : object {
    private bool _rightToLeft;
    private UInt32[][] _asciiLookups;
    [CompilerGeneratedAttribute]
private FindNextStartingPositionMode <FindMode>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexNodeKind <LeadingAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexNodeKind <TrailingAnchor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinRequiredLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxPossibleLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LeadingPrefix>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`3<char, string, int> <FixedDistanceLiteral>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FixedDistanceSet> <FixedDistanceSets>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> <LiteralAfterLoop>k__BackingField;
    public bool IsUseful { get; }
    public FindNextStartingPositionMode FindMode { get; }
    public RegexNodeKind LeadingAnchor { get; }
    public RegexNodeKind TrailingAnchor { get; }
    public int MinRequiredLength { get; }
    public Nullable`1<int> MaxPossibleLength { get; }
    public string LeadingPrefix { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3<char, string, int> FixedDistanceLiteral { get; }
    public List`1<FixedDistanceSet> FixedDistanceSets { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> LiteralAfterLoop { get; }
    public RegexFindOptimizations(RegexNode root, RegexOptions options);
    public bool get_IsUseful();
    [CompilerGeneratedAttribute]
public FindNextStartingPositionMode get_FindMode();
    [CompilerGeneratedAttribute]
public RegexNodeKind get_LeadingAnchor();
    [CompilerGeneratedAttribute]
public RegexNodeKind get_TrailingAnchor();
    [CompilerGeneratedAttribute]
public int get_MinRequiredLength();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxPossibleLength();
    [CompilerGeneratedAttribute]
public string get_LeadingPrefix();
    [CompilerGeneratedAttribute]
public ValueTuple`3<char, string, int> get_FixedDistanceLiteral();
    [CompilerGeneratedAttribute]
public List`1<FixedDistanceSet> get_FixedDistanceSets();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> get_LiteralAfterLoop();
    private static Nullable`1<ValueTuple`2<string, int>> FindFixedDistanceString(List`1<FixedDistanceSet> fixedDistanceSets);
}
internal class System.Text.RegularExpressions.RegexNode : object {
    internal static int MultiVsRepeaterLimit;
    private object Children;
    [CompilerGeneratedAttribute]
private RegexNodeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Str>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Ch>k__BackingField;
    [CompilerGeneratedAttribute]
private int <M>k__BackingField;
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    public RegexOptions Options;
    public RegexNode Parent;
    public RegexNodeKind Kind { get; private set; }
    public string Str { get; private set; }
    public char Ch { get; private set; }
    public int M { get; private set; }
    public int N { get; private set; }
    [MemberNotNullWhenAttribute("True", "Str")]
public bool IsSetFamily { get; }
    public bool IsOneFamily { get; }
    public bool IsNotoneFamily { get; }
    public RegexNode(RegexNodeKind kind, RegexOptions options);
    public RegexNode(RegexNodeKind kind, RegexOptions options, char ch);
    public RegexNode(RegexNodeKind kind, RegexOptions options, string str);
    public RegexNode(RegexNodeKind kind, RegexOptions options, int m);
    public RegexNode(RegexNodeKind kind, RegexOptions options, int m, int n);
    [CompilerGeneratedAttribute]
public RegexNodeKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(RegexNodeKind value);
    [CompilerGeneratedAttribute]
public string get_Str();
    [CompilerGeneratedAttribute]
private void set_Str(string value);
    [CompilerGeneratedAttribute]
public char get_Ch();
    [CompilerGeneratedAttribute]
private void set_Ch(char value);
    [CompilerGeneratedAttribute]
public int get_M();
    [CompilerGeneratedAttribute]
private void set_M(int value);
    [CompilerGeneratedAttribute]
public int get_N();
    [CompilerGeneratedAttribute]
private void set_N(int value);
    public static RegexNode CreateOneWithCaseConversion(char ch, RegexOptions options, CultureInfo culture, RegexCaseBehavior& caseBehavior);
    public RegexNode ReverseConcatenationIfRightToLeft();
    private void MakeRep(RegexNodeKind kind, int min, int max);
    private void MakeLoopAtomic();
    internal RegexNode FinalOptimize();
    private void EliminateEndingBacktracking();
    internal RegexNode Reduce();
    private RegexNode ReplaceNodeIfUnnecessary();
    private RegexNode ReduceGroup();
    private RegexNode ReduceAtomic();
    private RegexNode ReduceLoops();
    private RegexNode ReduceSet();
    private RegexNode ReduceAlternation();
    public RegexNode FindBranchOneOrMultiStart();
    public RegexNode FindBranchOneMultiOrSetStart();
    public char FirstCharOfOneOrMulti();
    public RegexNode FindStartingLiteralNode();
    public Nullable`1<StartingLiteralData> FindStartingLiteral(int maxSetCharacters);
    private RegexNode ReduceConcatenation();
    private void ReduceConcatenationWithAdjacentStrings();
    private void ReduceConcatenationWithAdjacentLoops();
    private void FindAndMakeLoopsAtomic();
    private RegexNode FindLastExpressionInLoopForAutoAtomic();
    private RegexNode ReduceLookaround();
    private RegexNode ReduceBackreferenceConditional();
    private RegexNode ReduceExpressionConditional();
    private static bool CanBeMadeAtomic(RegexNode node, RegexNode subsequent, bool iterateNullableSubsequent, bool allowLazy);
    public int ComputeMinLength();
    public Nullable`1<int> ComputeMaxLength();
    public bool TryGetOrdinalCaseInsensitiveString(int childIndex, int exclusiveChildBound, Int32& nodesConsumed, String& caseInsensitiveString, bool consumeZeroWidthNodes);
    public bool TryGetJoinableLengthCheckChildRange(int childIndex, Int32& requiredLength, Int32& exclusiveEnd);
    public RegexNode MakeQuantifier(bool lazy, int min, int max);
    public void AddChild(RegexNode newChild);
    public void InsertChild(int index, RegexNode newChild);
    public void ReplaceChild(int index, RegexNode newChild);
    public RegexNode Child(int i);
    public int ChildCount();
    internal bool SupportsCompilation(String& reason);
    [MemberNotNullWhenAttribute("True", "Str")]
public bool get_IsSetFamily();
    public bool get_IsOneFamily();
    public bool get_IsNotoneFamily();
    [CompilerGeneratedAttribute]
private void <ReduceAlternation>g__ReduceSingleLetterAndNestedAlternations|41_0();
    [CompilerGeneratedAttribute]
internal static RegexNode <ReduceAlternation>g__ExtractCommonPrefixOneNotoneSet|41_1(RegexNode alternation);
    [CompilerGeneratedAttribute]
internal static RegexNode <ReduceAlternation>g__RemoveRedundantEmptiesAndNothings|41_2(RegexNode node);
    [CompilerGeneratedAttribute]
internal static RegexNode <ReduceAlternation>g__ExtractCommonPrefixText|41_3(RegexNode alternation);
    [CompilerGeneratedAttribute]
internal static void <ReduceAlternation>g__ProcessOneOrMulti|41_4(RegexNode node, ReadOnlySpan`1<char> startingSpan);
    [CompilerGeneratedAttribute]
internal static bool <ReduceConcatenationWithAdjacentLoops>g__CanCombineCounts|50_0(int nodeMin, int nodeMax, int nextMin, int nextMax);
    [CompilerGeneratedAttribute]
internal static void <FindAndMakeLoopsAtomic>g__ProcessNode|51_0(RegexNode node, RegexNode subsequent);
    [CompilerGeneratedAttribute]
internal static bool <TryGetJoinableLengthCheckChildRange>g__CanJoinLengthCheck|60_0(RegexNode node);
    [CompilerGeneratedAttribute]
internal static bool <SupportsCompilation>g__ExceedsMaxDepthAllowedDepth|67_0(RegexNode node, int allowedDepth);
}
internal enum System.Text.RegularExpressions.RegexNodeKind : Enum {
    public byte value__;
    public static RegexNodeKind Unknown;
    public static RegexNodeKind One;
    public static RegexNodeKind Notone;
    public static RegexNodeKind Set;
    public static RegexNodeKind Multi;
    public static RegexNodeKind Oneloop;
    public static RegexNodeKind Notoneloop;
    public static RegexNodeKind Setloop;
    public static RegexNodeKind Onelazy;
    public static RegexNodeKind Notonelazy;
    public static RegexNodeKind Setlazy;
    public static RegexNodeKind Oneloopatomic;
    public static RegexNodeKind Notoneloopatomic;
    public static RegexNodeKind Setloopatomic;
    public static RegexNodeKind Backreference;
    public static RegexNodeKind Bol;
    public static RegexNodeKind Eol;
    public static RegexNodeKind Boundary;
    public static RegexNodeKind NonBoundary;
    public static RegexNodeKind ECMABoundary;
    public static RegexNodeKind NonECMABoundary;
    public static RegexNodeKind Beginning;
    public static RegexNodeKind Start;
    public static RegexNodeKind EndZ;
    public static RegexNodeKind End;
    public static RegexNodeKind UpdateBumpalong;
    public static RegexNodeKind Nothing;
    public static RegexNodeKind Empty;
    public static RegexNodeKind Alternate;
    public static RegexNodeKind Concatenate;
    public static RegexNodeKind Loop;
    public static RegexNodeKind Lazyloop;
    public static RegexNodeKind Capture;
    public static RegexNodeKind Group;
    public static RegexNodeKind Atomic;
    public static RegexNodeKind PositiveLookaround;
    public static RegexNodeKind NegativeLookaround;
    public static RegexNodeKind BackreferenceConditional;
    public static RegexNodeKind ExpressionConditional;
}
internal enum System.Text.RegularExpressions.RegexOpcode : Enum {
    public int value__;
    public static RegexOpcode Onerep;
    public static RegexOpcode Notonerep;
    public static RegexOpcode Setrep;
    public static RegexOpcode Oneloop;
    public static RegexOpcode Notoneloop;
    public static RegexOpcode Setloop;
    public static RegexOpcode Onelazy;
    public static RegexOpcode Notonelazy;
    public static RegexOpcode Setlazy;
    public static RegexOpcode One;
    public static RegexOpcode Notone;
    public static RegexOpcode Set;
    public static RegexOpcode Multi;
    public static RegexOpcode Backreference;
    public static RegexOpcode Bol;
    public static RegexOpcode Eol;
    public static RegexOpcode Boundary;
    public static RegexOpcode NonBoundary;
    public static RegexOpcode Beginning;
    public static RegexOpcode Start;
    public static RegexOpcode EndZ;
    public static RegexOpcode End;
    public static RegexOpcode Nothing;
    public static RegexOpcode ECMABoundary;
    public static RegexOpcode NonECMABoundary;
    public static RegexOpcode Oneloopatomic;
    public static RegexOpcode Notoneloopatomic;
    public static RegexOpcode Setloopatomic;
    public static RegexOpcode UpdateBumpalong;
    public static RegexOpcode Lazybranch;
    public static RegexOpcode Branchmark;
    public static RegexOpcode Lazybranchmark;
    public static RegexOpcode Nullcount;
    public static RegexOpcode Setcount;
    public static RegexOpcode Branchcount;
    public static RegexOpcode Lazybranchcount;
    public static RegexOpcode Nullmark;
    public static RegexOpcode Setmark;
    public static RegexOpcode Capturemark;
    public static RegexOpcode Getmark;
    public static RegexOpcode Setjump;
    public static RegexOpcode Backjump;
    public static RegexOpcode Forejump;
    public static RegexOpcode TestBackreference;
    public static RegexOpcode Goto;
    public static RegexOpcode Stop;
    public static RegexOpcode OperatorMask;
    public static RegexOpcode RightToLeft;
    public static RegexOpcode Backtracking;
    public static RegexOpcode BacktrackingSecond;
    public static RegexOpcode CaseInsensitive;
}
[FlagsAttribute]
internal enum System.Text.RegularExpressions.RegexOptions : Enum {
    public int value__;
    public static RegexOptions None;
    public static RegexOptions IgnoreCase;
    public static RegexOptions Multiline;
    public static RegexOptions ExplicitCapture;
    public static RegexOptions Compiled;
    public static RegexOptions Singleline;
    public static RegexOptions IgnorePatternWhitespace;
    public static RegexOptions RightToLeft;
    public static RegexOptions ECMAScript;
    public static RegexOptions CultureInvariant;
    public static RegexOptions NonBacktracking;
}
internal enum System.Text.RegularExpressions.RegexParseError : Enum {
    public int value__;
    public static RegexParseError Unknown;
    public static RegexParseError AlternationHasTooManyConditions;
    public static RegexParseError AlternationHasMalformedCondition;
    public static RegexParseError InvalidUnicodePropertyEscape;
    public static RegexParseError MalformedUnicodePropertyEscape;
    public static RegexParseError UnrecognizedEscape;
    public static RegexParseError UnrecognizedControlCharacter;
    public static RegexParseError MissingControlCharacter;
    public static RegexParseError InsufficientOrInvalidHexDigits;
    public static RegexParseError QuantifierOrCaptureGroupOutOfRange;
    public static RegexParseError UndefinedNamedReference;
    public static RegexParseError UndefinedNumberedReference;
    public static RegexParseError MalformedNamedReference;
    public static RegexParseError UnescapedEndingBackslash;
    public static RegexParseError UnterminatedComment;
    public static RegexParseError InvalidGroupingConstruct;
    public static RegexParseError AlternationHasNamedCapture;
    public static RegexParseError AlternationHasComment;
    public static RegexParseError AlternationHasMalformedReference;
    public static RegexParseError AlternationHasUndefinedReference;
    public static RegexParseError CaptureGroupNameInvalid;
    public static RegexParseError CaptureGroupOfZero;
    public static RegexParseError UnterminatedBracket;
    public static RegexParseError ExclusionGroupNotLast;
    public static RegexParseError ReversedCharacterRange;
    public static RegexParseError ShorthandClassInCharacterRange;
    public static RegexParseError InsufficientClosingParentheses;
    public static RegexParseError ReversedQuantifierRange;
    public static RegexParseError NestedQuantifiersNotParenthesized;
    public static RegexParseError QuantifierAfterNothing;
    public static RegexParseError InsufficientOpeningParentheses;
    public static RegexParseError UnrecognizedUnicodeProperty;
}
internal class System.Text.RegularExpressions.RegexParseException : ArgumentException {
    [CompilerGeneratedAttribute]
private RegexParseError <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public RegexParseError Error { get; }
    public int Offset { get; }
    internal RegexParseException(RegexParseError error, int offset, string message);
    [CompilerGeneratedAttribute]
public RegexParseError get_Error();
    [CompilerGeneratedAttribute]
public int get_Offset();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Text.RegularExpressions.RegexParser : ValueType {
    private static int EscapeMaxBufferSize;
    private static int OptionStackDefaultSize;
    private static int MaxValueDiv10;
    private static int MaxValueMod10;
    private RegexNode _stack;
    private RegexNode _group;
    private RegexNode _alternation;
    private RegexNode _concatenation;
    private RegexNode _unit;
    private string _pattern;
    private int _pos;
    private CultureInfo _culture;
    private RegexCaseBehavior _caseBehavior;
    private bool _hasIgnoreCaseBackreferenceNodes;
    private int _autocap;
    private int _capcount;
    private int _captop;
    private int _capsize;
    private Hashtable _caps;
    private Hashtable _capnames;
    private Int32[] _capnumlist;
    private List`1<string> _capnamelist;
    private RegexOptions _options;
    private ValueListBuilder`1<int> _optionsStack;
    private bool _ignoreNextParen;
    private static byte Q;
    private static byte S;
    private static byte Z;
    private static byte W;
    private static ReadOnlySpan`1<byte> Category { get; }
    private RegexParser(string pattern, RegexOptions options, CultureInfo culture, Hashtable caps, int capsize, Hashtable capnames, Span`1<int> optionSpan);
    internal static CultureInfo GetTargetCulture(RegexOptions options);
    public static RegexOptions ParseOptionsInPattern(string pattern, RegexOptions options);
    public static RegexTree Parse(string pattern, RegexOptions options, CultureInfo culture);
    public static RegexReplacement ParseReplacement(string pattern, RegexOptions options, Hashtable caps, int capsize, Hashtable capnames);
    public static string Escape(string input);
    private static string EscapeImpl(ReadOnlySpan`1<char> input, int indexOfMetachar);
    public static string Unescape(string input);
    private static string UnescapeImpl(string input, int i);
    private void Reset(RegexOptions options);
    public void Dispose();
    private RegexNode ScanRegex();
    private RegexNode ScanReplacement();
    private RegexCharClass ScanCharClass(bool caseInsensitive, bool scanOnly);
    private RegexNode ScanGroupOpen();
    private void ScanBlank();
    private RegexNode ScanBackslash(bool scanOnly);
    private RegexNode ScanBasicBackslash(bool scanOnly);
    private RegexNode ScanDollar();
    private string ScanCapname();
    private char ScanOctal();
    private int ScanDecimal();
    private char ScanHex(int c);
    private char ScanControl();
    private void ScanOptions();
    private char ScanCharEscape();
    private string ParseProperty();
    [IsReadOnlyAttribute]
private RegexNodeKind TypeFromCode(char ch);
    private void CountCaptures(RegexOptions& optionsFoundInPattern);
    private void NoteCaptureSlot(int i, int pos);
    private void NoteCaptureName(string name, int pos);
    private void AssignNameSlots();
    [IsReadOnlyAttribute]
private bool IsCaptureSlot(int i);
    internal static int MapCaptureNumber(int capnum, Hashtable caps);
    private static ReadOnlySpan`1<byte> get_Category();
    private static int IndexOfMetachar(ReadOnlySpan`1<char> input);
    private static bool IsSpecial(char ch);
    private static bool IsSpecialOrSpace(char ch);
    private static bool IsQuantifier(char ch);
    private static bool IsSpace(char ch);
    [IsReadOnlyAttribute]
private bool IsTrueQuantifier();
    private void AddToConcatenate(int pos, int cch, bool isReplacement);
    private void PushGroup();
    private void PopGroup();
    private void StartGroup(RegexNode openGroup);
    private void AddAlternate();
    private void AddGroup();
    [IsReadOnlyAttribute]
private RegexParseException MakeException(RegexParseError error, string message);
    internal static string GroupNameFromNumber(Hashtable caps, String[] capslist, int capsize, int i);
}
internal static class System.Text.RegularExpressions.RegexPrefixAnalyzer : object {
    private static ReadOnlySpan`1<float> Frequency { get; }
    public static string FindPrefix(RegexNode node);
    public static string FindPrefixOrdinalCaseInsensitive(RegexNode node);
    public static List`1<FixedDistanceSet> FindFixedDistanceSets(RegexNode root, bool thorough);
    public static void SortFixedDistanceSetsByQuality(List`1<FixedDistanceSet> results);
    public static string FindFirstCharClass(RegexNode root);
    public static Nullable`1<ValueTuple`2<RegexNode, ValueTuple`3<char, string, Char[]>>> FindLiteralFollowingLeadingLoop(RegexNode node);
    public static RegexNodeKind FindLeadingAnchor(RegexNode node);
    public static RegexNodeKind FindTrailingAnchor(RegexNode node);
    private static RegexNodeKind FindLeadingOrTrailingAnchor(RegexNode node, bool leading);
    private static ReadOnlySpan`1<float> get_Frequency();
    [CompilerGeneratedAttribute]
internal static bool <FindPrefix>g__Process|0_0(RegexNode node, ValueStringBuilder& vsb);
    [CompilerGeneratedAttribute]
internal static bool <FindFixedDistanceSets>g__TryFindRawFixedSets|2_0(RegexNode node, List`1<FixedDistanceSet> results, Int32& distance, bool thorough);
    [CompilerGeneratedAttribute]
internal static float <SortFixedDistanceSetsByQuality>g__SumFrequencies|3_2(Char[] chars);
    [CompilerGeneratedAttribute]
internal static int <SortFixedDistanceSetsByQuality>g__GetRangeLength|3_1(ValueTuple`2<char, char> range, bool negated);
    [CompilerGeneratedAttribute]
internal static Nullable`1<bool> <FindFirstCharClass>g__TryFindFirstCharClass|4_0(RegexNode node, RegexCharClass& cc);
}
internal class System.Text.RegularExpressions.RegexReplacement : object {
    public static int LeftPortion;
    public static int RightPortion;
    public static int LastGroup;
    public static int WholeString;
    public RegexReplacement(string rep, RegexNode concat, Hashtable caps);
}
internal class System.Text.RegularExpressions.RegexTree : object {
    public RegexOptions Options;
    public RegexNode Root;
    public RegexFindOptimizations FindOptimizations;
    public int CaptureCount;
    public CultureInfo Culture;
    public String[] CaptureNames;
    public Hashtable CaptureNameToNumberMapping;
    public Hashtable CaptureNumberSparseMapping;
    internal RegexTree(RegexNode root, int captureCount, String[] captureNames, Hashtable captureNameToNumberMapping, Hashtable captureNumberSparseMapping, RegexOptions options, CultureInfo culture);
}
internal static class System.Text.RegularExpressions.RegexTreeAnalyzer : object {
    public static AnalysisResults Analyze(RegexTree regexTree);
    [CompilerGeneratedAttribute]
internal static bool <Analyze>g__TryAnalyze|0_0(RegexNode node, AnalysisResults results, bool isAtomicByAncestor, bool isInLoop);
}
[ExtensionAttribute]
internal static class System.Text.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder stringBuilder, ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlyMemory`1[] GetChunks(StringBuilder stringBuilder);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public int Capacity { get; }
    public Char& Item { get; }
    public Span`1<char> RawChars { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public void set_Length(int value);
    public int get_Capacity();
    public void EnsureCapacity(int capacity);
    public Char& GetPinnableReference();
    public Char& GetPinnableReference(bool terminate);
    public Char& get_Item(int index);
    public virtual string ToString();
    public Span`1<char> get_RawChars();
    public ReadOnlySpan`1<char> AsSpan(bool terminate);
    public ReadOnlySpan`1<char> AsSpan();
    public ReadOnlySpan`1<char> AsSpan(int start);
    public ReadOnlySpan`1<char> AsSpan(int start, int length);
    public bool TryCopyTo(Span`1<char> destination, Int32& charsWritten);
    public void Insert(int index, char value, int count);
    public void Insert(int index, string s);
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(Char* value, int length);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
internal static class System.Threading.InterlockedExtensions : object {
    public static UInt32 Or(UInt32& location1, UInt32 value);
}
internal static class System.Threading.StackHelper : object {
    public static bool TryEnsureSufficientExecutionStack();
    public static void CallOnEmptyStack(Action`1<TArg1> action, TArg1 arg1);
    public static void CallOnEmptyStack(Action`2<TArg1, TArg2> action, TArg1 arg1, TArg2 arg2);
    public static void CallOnEmptyStack(Action`3<TArg1, TArg2, TArg3> action, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static void CallOnEmptyStack(Action`4<TArg1, TArg2, TArg3, TArg4> action, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4);
    public static void CallOnEmptyStack(Action`5<TArg1, TArg2, TArg3, TArg4, TArg5> action, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5);
    public static void CallOnEmptyStack(Action`6<TArg1, TArg2, TArg3, TArg4, TArg5, TArg6> action, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4, TArg5 arg5, TArg6 arg6);
    public static TResult CallOnEmptyStack(Func`1<TResult> func);
    public static TResult CallOnEmptyStack(Func`2<TArg1, TResult> func, TArg1 arg1);
    public static TResult CallOnEmptyStack(Func`3<TArg1, TArg2, TResult> func, TArg1 arg1, TArg2 arg2);
    public static TResult CallOnEmptyStack(Func`4<TArg1, TArg2, TArg3, TResult> func, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static TResult CallOnEmptyStack(Func`5<TArg1, TArg2, TArg3, TArg4, TResult> func, TArg1 arg1, TArg2 arg2, TArg3 arg3, TArg4 arg4);
}
