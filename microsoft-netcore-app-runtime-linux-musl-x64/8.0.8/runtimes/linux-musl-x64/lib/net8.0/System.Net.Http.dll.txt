internal static class FxResources.System.Net.Http.SR : object {
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static int FromUpperChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal abstract class System.IO.DelegatingStream : Stream {
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public bool CanTimeout { get; }
    public int WriteTimeout { get; public set; }
    protected DelegatingStream(Stream innerStream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual bool get_CanTimeout();
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
}
internal class System.IO.ReadOnlyMemoryStream : Stream {
    private ReadOnlyMemory`1<byte> _content;
    private int _position;
    private bool _isOpen;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyMemoryStream(ReadOnlyMemory`1<byte> content);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureNotClosed();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    private int ReadBuffer(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.ArrayBuffer : ValueType {
    private bool _usePool;
    private Byte[] _bytes;
    private int _activeStart;
    private int _availableStart;
    public int ActiveLength { get; }
    public Span`1<byte> ActiveSpan { get; }
    public ReadOnlySpan`1<byte> ActiveReadOnlySpan { get; }
    public Memory`1<byte> ActiveMemory { get; }
    public int AvailableLength { get; }
    public Span`1<byte> AvailableSpan { get; }
    public Memory`1<byte> AvailableMemory { get; }
    public int Capacity { get; }
    public int ActiveStartOffset { get; }
    public ArrayBuffer(int initialSize, bool usePool);
    public ArrayBuffer(Byte[] buffer);
    public sealed virtual void Dispose();
    public void ClearAndReturnBuffer();
    public int get_ActiveLength();
    public Span`1<byte> get_ActiveSpan();
    public ReadOnlySpan`1<byte> get_ActiveReadOnlySpan();
    public Memory`1<byte> get_ActiveMemory();
    public int get_AvailableLength();
    public Span`1<byte> get_AvailableSpan();
    public Memory`1<byte> get_AvailableMemory();
    public Memory`1<byte> AvailableMemorySliced(int length);
    public int get_Capacity();
    public int get_ActiveStartOffset();
    public Byte[] DangerousGetUnderlyingBuffer();
    public void Discard(int byteCount);
    public void Commit(int byteCount);
    public void EnsureAvailableSpace(int byteCount);
    private void EnsureAvailableSpaceCore(int byteCount);
    public void Grow();
    private void ReturnBufferIfPooled(Byte[] buffer);
}
internal static class System.Net.Http.AuthenticationHelper : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_usePortInSpn;
    private static bool UsePortInSpn { get; }
    private static AuthenticationHelper();
    private static bool TryGetChallengeDataForScheme(string scheme, HttpHeaderValueCollection`1<AuthenticationHeaderValue> authenticationHeaderValues, String& challengeData);
    internal static bool IsSessionAuthenticationChallenge(HttpResponseMessage response);
    private static bool TryGetValidAuthenticationChallengeForScheme(string scheme, AuthenticationType authenticationType, Uri uri, ICredentials credentials, HttpHeaderValueCollection`1<AuthenticationHeaderValue> authenticationHeaderValues, AuthenticationChallenge& challenge);
    private static bool TryGetAuthenticationChallenge(HttpResponseMessage response, bool isProxyAuth, Uri authUri, ICredentials credentials, AuthenticationChallenge& challenge);
    private static bool TryGetRepeatedChallenge(HttpResponseMessage response, string scheme, bool isProxyAuth, String& challengeData);
    private static bool IsAuthenticationChallenge(HttpResponseMessage response, bool isProxyAuth);
    private static HttpHeaderValueCollection`1<AuthenticationHeaderValue> GetResponseAuthenticationHeaderValues(HttpResponseMessage response, bool isProxyAuth);
    private static void SetRequestAuthenticationHeaderValue(HttpRequestMessage request, AuthenticationHeaderValue headerValue, bool isProxyAuth);
    private static void SetBasicAuthToken(HttpRequestMessage request, NetworkCredential credential, bool isProxyAuth);
    [AsyncStateMachineAttribute("System.Net.Http.AuthenticationHelper/<TrySetDigestAuthToken>d__15")]
private static ValueTask`1<bool> TrySetDigestAuthToken(HttpRequestMessage request, NetworkCredential credential, DigestResponse digestResponse, bool isProxyAuth);
    private static ValueTask`1<HttpResponseMessage> InnerSendAsync(HttpRequestMessage request, bool async, bool isProxyAuth, bool doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.AuthenticationHelper/<SendWithAuthAsync>d__17")]
private static ValueTask`1<HttpResponseMessage> SendWithAuthAsync(HttpRequestMessage request, Uri authUri, bool async, ICredentials credentials, bool preAuthenticate, bool isProxyAuth, bool doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken);
    public static ValueTask`1<HttpResponseMessage> SendWithProxyAuthAsync(HttpRequestMessage request, Uri proxyUri, bool async, ICredentials proxyCredentials, bool doRequestAuth, HttpConnectionPool pool, CancellationToken cancellationToken);
    public static ValueTask`1<HttpResponseMessage> SendWithRequestAuthAsync(HttpRequestMessage request, bool async, ICredentials credentials, bool preAuthenticate, HttpConnectionPool pool, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.AuthenticationHelper/<GetDigestTokenForCredential>d__40")]
public static Task`1<string> GetDigestTokenForCredential(NetworkCredential credential, HttpRequestMessage request, DigestResponse digestResponse);
    public static bool IsServerNonceStale(DigestResponse digestResponse);
    private static string GetRandomAlphaNumericString();
    private static string ComputeHash(string data, string algorithm);
    private static bool get_UsePortInSpn();
    private static Task`1<HttpResponseMessage> InnerSendAsync(HttpRequestMessage request, bool async, bool isProxyAuth, HttpConnectionPool pool, HttpConnection connection, CancellationToken cancellationToken);
    private static bool ProxySupportsConnectionAuth(HttpResponseMessage response);
    [AsyncStateMachineAttribute("System.Net.Http.AuthenticationHelper/<SendWithNtAuthAsync>d__52")]
private static Task`1<HttpResponseMessage> SendWithNtAuthAsync(HttpRequestMessage request, Uri authUri, bool async, ICredentials credentials, bool isProxyAuth, HttpConnection connection, HttpConnectionPool connectionPool, CancellationToken cancellationToken);
    public static Task`1<HttpResponseMessage> SendWithNtProxyAuthAsync(HttpRequestMessage request, Uri proxyUri, bool async, ICredentials proxyCredentials, HttpConnection connection, HttpConnectionPool connectionPool, CancellationToken cancellationToken);
    public static Task`1<HttpResponseMessage> SendWithNtConnectionAuthAsync(HttpRequestMessage request, bool async, ICredentials credentials, HttpConnection connection, HttpConnectionPool connectionPool, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.ByteArrayContent : HttpContent {
    private Byte[] _content;
    private int _offset;
    private int _count;
    internal bool AllowDuplex { get; }
    public ByteArrayContent(Byte[] content);
    public ByteArrayContent(Byte[] content, int offset, int count);
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    private protected Task SerializeToStreamAsyncCore(Stream stream, CancellationToken cancellationToken);
    protected internal virtual bool TryComputeLength(Int64& length);
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    internal virtual Stream TryCreateContentReadStream();
    internal MemoryStream CreateMemoryStreamForByteArray();
    internal virtual bool get_AllowDuplex();
}
internal static class System.Net.Http.CancellationHelper : object {
    private static string s_cancellationMessage;
    private static CancellationHelper();
    internal static bool ShouldWrapInOperationCanceledException(Exception exception, CancellationToken cancellationToken);
    internal static Exception CreateOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    private static void ThrowOperationCanceledException(Exception innerException, CancellationToken cancellationToken);
    internal static void ThrowIfCancellationRequested(CancellationToken cancellationToken);
}
public enum System.Net.Http.ClientCertificateOption : Enum {
    public int value__;
    public static ClientCertificateOption Manual;
    public static ClientCertificateOption Automatic;
}
internal static class System.Net.Http.ConnectHelper : object {
    private static SslClientAuthenticationOptions SetUpRemoteCertificateValidationCallback(SslClientAuthenticationOptions sslOptions, HttpRequestMessage request);
    [AsyncStateMachineAttribute("System.Net.Http.ConnectHelper/<EstablishSslConnectionAsync>d__2")]
public static ValueTask`1<SslStream> EstablishSslConnectionAsync(SslClientAuthenticationOptions sslOptions, HttpRequestMessage request, bool async, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.ConnectHelper/<ConnectQuicAsync>d__3")]
[SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("macos")]
public static ValueTask`1<QuicConnection> ConnectQuicAsync(HttpRequestMessage request, DnsEndPoint endPoint, TimeSpan idleTimeout, SslClientAuthenticationOptions clientAuthenticationOptions, CancellationToken cancellationToken);
    internal static Exception CreateWrappedException(Exception exception, string host, int port, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static HttpRequestError <CreateWrappedException>g__DeduceError|4_0(Exception exception);
}
internal static class System.Net.Http.CookieHelper : object {
    public static void ProcessReceivedCookies(HttpResponseMessage response, CookieContainer cookieContainer);
}
internal class System.Net.Http.CreditManager : object {
    private IHttpTrace _owner;
    private string _name;
    private int _current;
    private bool _disposed;
    private CreditWaiter _waitersTail;
    public bool IsCreditAvailable { get; }
    private object SyncObject { get; }
    public CreditManager(IHttpTrace owner, string name, int initialCredit);
    public bool get_IsCreditAvailable();
    private object get_SyncObject();
    public ValueTask`1<int> RequestCreditAsync(int amount, CancellationToken cancellationToken);
    public void AdjustCredit(int amount);
    public void Dispose();
    private int TryRequestCreditNoLock(int amount);
}
internal class System.Net.Http.CreditWaiter : object {
    private CancellationToken _cancellationToken;
    private CancellationTokenRegistration _registration;
    private ManualResetValueTaskSourceCore`1<int> _source;
    public int Amount;
    public CreditWaiter Next;
    public CreditWaiter(CancellationToken cancellationToken);
    public void ResetForAwait(CancellationToken cancellationToken);
    private void RegisterCancellation(CancellationToken cancellationToken);
    public ValueTask`1<int> AsValueTask();
    public bool TrySetResult(int result);
    public void Dispose();
    private bool UnregisterAndOwnCompletion();
    private sealed virtual override int System.Threading.Tasks.Sources.IValueTaskSource<System.Int32>.GetResult(short token);
    private sealed virtual override ValueTaskSourceStatus System.Threading.Tasks.Sources.IValueTaskSource<System.Int32>.GetStatus(short token);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource<System.Int32>.OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
}
internal static class System.Net.Http.CurrentUserIdentityProvider : object {
    public static string GetIdentity();
}
internal class System.Net.Http.DecompressionHandler : HttpMessageHandlerStage {
    private HttpMessageHandlerStage _innerHandler;
    private DecompressionMethods _decompressionMethods;
    private static StringWithQualityHeaderValue s_gzipHeaderValue;
    private static StringWithQualityHeaderValue s_deflateHeaderValue;
    private static StringWithQualityHeaderValue s_brotliHeaderValue;
    internal bool GZipEnabled { get; }
    internal bool DeflateEnabled { get; }
    internal bool BrotliEnabled { get; }
    public DecompressionHandler(DecompressionMethods decompressionMethods, HttpMessageHandlerStage innerHandler);
    private static DecompressionHandler();
    internal bool get_GZipEnabled();
    internal bool get_DeflateEnabled();
    internal bool get_BrotliEnabled();
    private static bool EncodingExists(HttpHeaderValueCollection`1<StringWithQualityHeaderValue> acceptEncodingHeader, string encoding);
    [AsyncStateMachineAttribute("System.Net.Http.DecompressionHandler/<SendAsync>d__16")]
internal virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Http.DelegatingHandler : HttpMessageHandler {
    private HttpMessageHandler _innerHandler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _operationStarted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    [NullableAttribute("2")]
public HttpMessageHandler InnerHandler { get; public set; }
    protected DelegatingHandler(HttpMessageHandler innerHandler);
    [NullableContextAttribute("2")]
public HttpMessageHandler get_InnerHandler();
    [NullableContextAttribute("2")]
public void set_InnerHandler(HttpMessageHandler value);
    protected internal virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void CheckDisposedOrStarted();
    private void SetOperationStarted();
}
internal class System.Net.Http.DiagnosticsHandler : HttpMessageHandlerStage {
    private static DiagnosticListener s_diagnosticListener;
    private static ActivitySource s_activitySource;
    private HttpMessageHandler _innerHandler;
    private DistributedContextPropagator _propagator;
    private HeaderDescriptor[] _propagatorFields;
    public DiagnosticsHandler(HttpMessageHandler innerHandler, DistributedContextPropagator propagator, bool autoRedirect);
    private static DiagnosticsHandler();
    private static bool IsEnabled();
    private static Activity CreateActivity(HttpRequestMessage requestMessage);
    internal static bool IsGloballyEnabled();
    internal virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.DiagnosticsHandler/<SendAsyncCore>d__10")]
private ValueTask`1<HttpResponseMessage> SendAsyncCore(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private void InjectHeaders(Activity currentActivity, HttpRequestMessage request);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
private static void Write(DiagnosticSource diagnosticSource, string name, T value);
}
internal class System.Net.Http.EmptyContent : HttpContent {
    internal bool AllowDuplex { get; }
    protected internal virtual bool TryComputeLength(Int64& length);
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual Task`1<Stream> CreateContentReadStreamAsync(CancellationToken cancellationToken);
    internal virtual Stream TryCreateContentReadStream();
    internal virtual bool get_AllowDuplex();
}
internal class System.Net.Http.EmptyReadStream : HttpBaseStream {
    [CompilerGeneratedAttribute]
private static EmptyReadStream <Instance>k__BackingField;
    internal static EmptyReadStream Instance { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    private static EmptyReadStream();
    [CompilerGeneratedAttribute]
internal static EmptyReadStream get_Instance();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    public virtual int Read(Span`1<byte> buffer);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> destination, CancellationToken cancellationToken);
}
internal class System.Net.Http.FailedProxyCache : object {
    private ConcurrentDictionary`2<Uri, long> _failedProxies;
    private long _nextFlushTicks;
    private SpinLock _flushLock;
    public long GetProxyRenewTicks(Uri uri);
    public void SetProxyFailed(Uri uri);
    public bool TryRenewProxy(Uri uri, long renewTicks);
    private void Cleanup();
    private void CleanupHelper();
}
public class System.Net.Http.FormUrlEncodedContent : ByteArrayContent {
    public FormUrlEncodedContent(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static Byte[] GetContentByteArray(IEnumerable`1<KeyValuePair`2<string, string>> nameValueCollection);
    private static string Encode(string data);
    [NullableContextAttribute("1")]
protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    internal virtual Stream TryCreateContentReadStream();
}
internal static class System.Net.Http.GlobalHttpSettings : object {
}
public class System.Net.Http.HeaderEncodingSelector`1 : MulticastDelegate {
    public HeaderEncodingSelector`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Encoding Invoke(string headerName, TContext context);
    public virtual IAsyncResult BeginInvoke(string headerName, TContext context, AsyncCallback callback, object object);
    public virtual Encoding EndInvoke(IAsyncResult result);
}
internal class System.Net.Http.Headers.AltSvcHeaderParser : BaseHeaderParser {
    [CompilerGeneratedAttribute]
private static AltSvcHeaderParser <Parser>k__BackingField;
    public static AltSvcHeaderParser Parser { get; }
    private static AltSvcHeaderParser();
    [CompilerGeneratedAttribute]
public static AltSvcHeaderParser get_Parser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
    private static bool IsOptionalWhiteSpace(char ch);
    private static bool TryReadPercentEncodedAlpnProtocolName(string value, int startIndex, String& result, Int32& readLength);
    private static bool TryReadUnknownPercentEncodedAlpnProtocolName(ReadOnlySpan`1<char> value, String& result);
    private static bool TryReadAlpnHexDigit(char ch, Int32& nibble);
    private static bool TryReadQuotedAltAuthority(string value, int startIndex, String& host, Int32& port, Int32& readLength);
    private static bool TryReadQuotedValue(ReadOnlySpan`1<char> value, String& result);
    private static bool TryReadTokenOrQuotedInt32(string value, int startIndex, Int32& result, Int32& readLength);
    private static bool TryReadQuotedInt32Value(ReadOnlySpan`1<char> value, Int32& result);
    private static bool TrySkipTokenOrQuoted(string value, int startIndex, Int32& readLength);
}
internal class System.Net.Http.Headers.AltSvcHeaderValue : object {
    [CompilerGeneratedAttribute]
private static AltSvcHeaderValue <Clear>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AlpnProtocolName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Persist>k__BackingField;
    public static AltSvcHeaderValue Clear { get; }
    public string AlpnProtocolName { get; }
    public string Host { get; }
    public int Port { get; }
    public TimeSpan MaxAge { get; }
    public bool Persist { get; }
    public AltSvcHeaderValue(string alpnProtocolName, string host, int port, TimeSpan maxAge, bool persist);
    private static AltSvcHeaderValue();
    [CompilerGeneratedAttribute]
public static AltSvcHeaderValue get_Clear();
    [CompilerGeneratedAttribute]
public string get_AlpnProtocolName();
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public TimeSpan get_MaxAge();
    [CompilerGeneratedAttribute]
public bool get_Persist();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.AuthenticationHeaderValue : object {
    private string _scheme;
    private string _parameter;
    public string Scheme { get; }
    [NullableAttribute("2")]
public string Parameter { get; }
    public AuthenticationHeaderValue(string scheme);
    public AuthenticationHeaderValue(string scheme, string parameter);
    private AuthenticationHeaderValue(AuthenticationHeaderValue source);
    public string get_Scheme();
    [NullableContextAttribute("2")]
public string get_Parameter();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static AuthenticationHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, AuthenticationHeaderValue& parsedValue);
    internal static int GetAuthenticationLength(string input, int startIndex, Object& parsedValue);
    private static bool TrySkipFirstBlob(string input, Int32& current, Int32& parameterEndIndex);
    private static bool TryGetParametersEndIndex(string input, Int32& parseEndIndex, Int32& parameterEndIndex);
    private sealed virtual override object System.ICloneable.Clone();
}
internal abstract class System.Net.Http.Headers.BaseHeaderParser : HttpHeaderParser {
    protected BaseHeaderParser(bool supportsMultipleValues);
    protected abstract virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
    public sealed virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
internal class System.Net.Http.Headers.ByteArrayHeaderParser : HttpHeaderParser {
    internal static ByteArrayHeaderParser Parser;
    private static ByteArrayHeaderParser();
    public virtual string ToString(object value);
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
internal class System.Net.Http.Headers.CacheControlHeaderParser : BaseHeaderParser {
    internal static CacheControlHeaderParser Parser;
    private static CacheControlHeaderParser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.CacheControlHeaderValue : object {
    private static GenericHeaderParser s_nameValueListParser;
    private Flags _flags;
    private TokenObjectCollection _noCacheHeaders;
    private TimeSpan _maxAge;
    private TimeSpan _sharedMaxAge;
    private TimeSpan _maxStaleLimit;
    private TimeSpan _minFresh;
    private TokenObjectCollection _privateHeaders;
    private UnvalidatedObjectCollection`1<NameValueHeaderValue> _extensions;
    public bool NoCache { get; public set; }
    public ICollection`1<string> NoCacheHeaders { get; }
    public bool NoStore { get; public set; }
    public Nullable`1<TimeSpan> MaxAge { get; public set; }
    public Nullable`1<TimeSpan> SharedMaxAge { get; public set; }
    public bool MaxStale { get; public set; }
    public Nullable`1<TimeSpan> MaxStaleLimit { get; public set; }
    public Nullable`1<TimeSpan> MinFresh { get; public set; }
    public bool NoTransform { get; public set; }
    public bool OnlyIfCached { get; public set; }
    public bool Public { get; public set; }
    public bool Private { get; public set; }
    public ICollection`1<string> PrivateHeaders { get; }
    public bool MustRevalidate { get; public set; }
    public bool ProxyRevalidate { get; public set; }
    public ICollection`1<NameValueHeaderValue> Extensions { get; }
    private CacheControlHeaderValue(CacheControlHeaderValue source);
    private static CacheControlHeaderValue();
    private void SetTimeSpan(TimeSpan& fieldRef, Flags flag, Nullable`1<TimeSpan> value);
    private void SetFlag(Flags flag, bool value);
    public bool get_NoCache();
    public void set_NoCache(bool value);
    public ICollection`1<string> get_NoCacheHeaders();
    public bool get_NoStore();
    public void set_NoStore(bool value);
    public Nullable`1<TimeSpan> get_MaxAge();
    public void set_MaxAge(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_SharedMaxAge();
    public void set_SharedMaxAge(Nullable`1<TimeSpan> value);
    public bool get_MaxStale();
    public void set_MaxStale(bool value);
    public Nullable`1<TimeSpan> get_MaxStaleLimit();
    public void set_MaxStaleLimit(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_MinFresh();
    public void set_MinFresh(Nullable`1<TimeSpan> value);
    public bool get_NoTransform();
    public void set_NoTransform(bool value);
    public bool get_OnlyIfCached();
    public void set_OnlyIfCached(bool value);
    public bool get_Public();
    public void set_Public(bool value);
    public bool get_Private();
    public void set_Private(bool value);
    public ICollection`1<string> get_PrivateHeaders();
    public bool get_MustRevalidate();
    public void set_MustRevalidate(bool value);
    public bool get_ProxyRevalidate();
    public void set_ProxyRevalidate(bool value);
    public ICollection`1<NameValueHeaderValue> get_Extensions();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static CacheControlHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, CacheControlHeaderValue& parsedValue);
    internal static int GetCacheControlLength(string input, int startIndex, CacheControlHeaderValue storeValue, CacheControlHeaderValue& parsedValue);
    private static bool TrySetCacheControlValues(CacheControlHeaderValue cc, List`1<NameValueHeaderValue> nameValueList);
    private static bool TrySetOptionalTokenList(NameValueHeaderValue nameValue, TokenObjectCollection& destination);
    private static bool TrySetTimeSpan(string value, TimeSpan& timeSpan);
    private static void AppendValueIfRequired(StringBuilder sb, bool appendValue, string value);
    private static void AppendValueWithSeparatorIfRequired(StringBuilder sb, string value);
    private static void AppendValues(StringBuilder sb, TokenObjectCollection values);
    private sealed virtual override object System.ICloneable.Clone();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.ContentDispositionHeaderValue : object {
    private UnvalidatedObjectCollection`1<NameValueHeaderValue> _parameters;
    private string _dispositionType;
    [NullableAttribute("1")]
public string DispositionType { get; public set; }
    [NullableAttribute("1")]
public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public string Name { get; public set; }
    public string FileName { get; public set; }
    public string FileNameStar { get; public set; }
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ReadDate { get; public set; }
    public Nullable`1<long> Size { get; public set; }
    [NullableContextAttribute("1")]
protected ContentDispositionHeaderValue(ContentDispositionHeaderValue source);
    [NullableContextAttribute("1")]
public ContentDispositionHeaderValue(string dispositionType);
    [NullableContextAttribute("1")]
public string get_DispositionType();
    [NullableContextAttribute("1")]
public void set_DispositionType(string value);
    [NullableContextAttribute("1")]
public ICollection`1<NameValueHeaderValue> get_Parameters();
    public string get_Name();
    public void set_Name(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public string get_FileNameStar();
    public void set_FileNameStar(string value);
    public Nullable`1<DateTimeOffset> get_CreationDate();
    public void set_CreationDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ModificationDate();
    public void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ReadDate();
    public void set_ReadDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<long> get_Size();
    public void set_Size(Nullable`1<long> value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
    [NullableContextAttribute("1")]
public static ContentDispositionHeaderValue Parse(string input);
    public static bool TryParse(string input, ContentDispositionHeaderValue& parsedValue);
    internal static int GetDispositionTypeLength(string input, int startIndex, Object& parsedValue);
    private static int GetDispositionTypeExpressionLength(string input, int startIndex, String& dispositionType);
    private static void CheckDispositionTypeFormat(string dispositionType, string parameterName);
    private Nullable`1<DateTimeOffset> GetDate(string parameter);
    private void SetDate(string parameter, Nullable`1<DateTimeOffset> date);
    private string GetName(string parameter);
    private void SetName(string parameter, string value);
    private static string EncodeAndQuoteMime(string input);
    private static bool IsQuoted(ReadOnlySpan`1<char> value);
    private static string EncodeMime(string input);
    private static bool TryDecodeMime(string input, String& output);
    private static bool TryDecode5987(string input, String& output);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.ContentRangeHeaderValue : object {
    private string _unit;
    private long _from;
    private long _to;
    private long _length;
    public string Unit { get; public set; }
    public Nullable`1<long> From { get; }
    public Nullable`1<long> To { get; }
    public Nullable`1<long> Length { get; }
    public bool HasLength { get; }
    public bool HasRange { get; }
    public ContentRangeHeaderValue(long from, long to, long length);
    public ContentRangeHeaderValue(long length);
    public ContentRangeHeaderValue(long from, long to);
    private ContentRangeHeaderValue(ContentRangeHeaderValue source);
    public string get_Unit();
    public void set_Unit(string value);
    public Nullable`1<long> get_From();
    public Nullable`1<long> get_To();
    public Nullable`1<long> get_Length();
    public bool get_HasLength();
    public bool get_HasRange();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ContentRangeHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, ContentRangeHeaderValue& parsedValue);
    internal static int GetContentRangeLength(string input, int startIndex, Object& parsedValue);
    private static bool TryGetLengthLength(string input, Int32& current, Int32& lengthLength);
    private static bool TryGetRangeLength(string input, Int32& current, Int32& fromLength, Int32& toStartIndex, Int32& toLength);
    private static bool TryCreateContentRange(string input, string unit, int fromStartIndex, int fromLength, int toStartIndex, int toLength, int lengthStartIndex, int lengthLength, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.CookieHeaderParser : HttpHeaderParser {
    internal static CookieHeaderParser Parser;
    private static CookieHeaderParser();
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
internal class System.Net.Http.Headers.DateHeaderParser : HttpHeaderParser {
    internal static DateHeaderParser Parser;
    private static DateHeaderParser();
    public virtual string ToString(object value);
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.EntityTagHeaderValue : object {
    private string _tag;
    private bool _isWeak;
    [CompilerGeneratedAttribute]
private static EntityTagHeaderValue <Any>k__BackingField;
    public string Tag { get; }
    public bool IsWeak { get; }
    public static EntityTagHeaderValue Any { get; }
    public EntityTagHeaderValue(string tag);
    public EntityTagHeaderValue(string tag, bool isWeak);
    private EntityTagHeaderValue(EntityTagHeaderValue source);
    private static EntityTagHeaderValue();
    public string get_Tag();
    public bool get_IsWeak();
    [CompilerGeneratedAttribute]
public static EntityTagHeaderValue get_Any();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static EntityTagHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, EntityTagHeaderValue& parsedValue);
    internal static int GetEntityTagLength(string input, int startIndex, EntityTagHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.GenericHeaderParser : BaseHeaderParser {
    internal static GenericHeaderParser HostParser;
    internal static GenericHeaderParser TokenListParser;
    internal static GenericHeaderParser SingleValueNameValueWithParametersParser;
    internal static GenericHeaderParser MultipleValueNameValueWithParametersParser;
    internal static GenericHeaderParser SingleValueNameValueParser;
    internal static GenericHeaderParser MultipleValueNameValueParser;
    internal static GenericHeaderParser SingleValueParserWithoutValidation;
    internal static GenericHeaderParser SingleValueProductParser;
    internal static GenericHeaderParser MultipleValueProductParser;
    internal static GenericHeaderParser RangeConditionParser;
    internal static GenericHeaderParser SingleValueAuthenticationParser;
    internal static GenericHeaderParser MultipleValueAuthenticationParser;
    internal static GenericHeaderParser RangeParser;
    internal static GenericHeaderParser RetryConditionParser;
    internal static GenericHeaderParser ContentRangeParser;
    internal static GenericHeaderParser ContentDispositionParser;
    internal static GenericHeaderParser SingleValueStringWithQualityParser;
    internal static GenericHeaderParser MultipleValueStringWithQualityParser;
    internal static GenericHeaderParser SingleValueEntityTagParser;
    internal static GenericHeaderParser MultipleValueEntityTagParser;
    internal static GenericHeaderParser SingleValueViaParser;
    internal static GenericHeaderParser MultipleValueViaParser;
    internal static GenericHeaderParser SingleValueWarningParser;
    internal static GenericHeaderParser MultipleValueWarningParser;
    private GetParsedValueLengthDelegate _getParsedValueLength;
    private IEqualityComparer _comparer;
    public IEqualityComparer Comparer { get; }
    private GenericHeaderParser(bool supportsMultipleValues, GetParsedValueLengthDelegate getParsedValueLength);
    private GenericHeaderParser(bool supportsMultipleValues, GetParsedValueLengthDelegate getParsedValueLength, IEqualityComparer comparer);
    private static GenericHeaderParser();
    public virtual IEqualityComparer get_Comparer();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
    private static int ParseNameValue(string value, int startIndex, Object& parsedValue);
    private static int ParseProduct(string value, int startIndex, Object& parsedValue);
    private static int ParseSingleEntityTag(string value, int startIndex, Object& parsedValue);
    private static int ParseMultipleEntityTags(string value, int startIndex, Object& parsedValue);
    private static int ParseWithoutValidation(string value, int startIndex, Object& parsedValue);
    private static int ParseHost(string value, int startIndex, Object& parsedValue);
    private static int ParseTokenList(string value, int startIndex, Object& parsedValue);
}
[IsReadOnlyAttribute]
internal class System.Net.Http.Headers.HeaderDescriptor : ValueType {
    private object _descriptor;
    public string Name { get; }
    public HttpHeaderParser Parser { get; }
    public HttpHeaderType HeaderType { get; }
    public KnownHeader KnownHeader { get; }
    public HeaderDescriptor(KnownHeader knownHeader);
    internal HeaderDescriptor(string headerName, bool customHeader);
    public string get_Name();
    public HttpHeaderParser get_Parser();
    public HttpHeaderType get_HeaderType();
    public KnownHeader get_KnownHeader();
    public bool Equals(KnownHeader other);
    public sealed virtual bool Equals(HeaderDescriptor other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool TryGet(string headerName, HeaderDescriptor& descriptor);
    public static bool TryGet(ReadOnlySpan`1<byte> headerName, HeaderDescriptor& descriptor);
    internal static bool TryGetStaticQPackHeader(int index, HeaderDescriptor& descriptor, String& knownValue);
    public HeaderDescriptor AsCustomHeader();
    public string GetHeaderValue(ReadOnlySpan`1<byte> headerValue, Encoding valueEncoding);
    internal static string GetKnownContentType(ReadOnlySpan`1<byte> contentTypeValue);
    private static bool TryDecodeUtf8(ReadOnlySpan`1<byte> input, String& decoded);
}
internal class System.Net.Http.Headers.HeaderEntry : ValueType {
    public HeaderDescriptor Key;
    public object Value;
    public HeaderEntry(HeaderDescriptor key, object value);
}
[IsReadOnlyAttribute]
public class System.Net.Http.Headers.HeaderStringValues : ValueType {
    private HeaderDescriptor _header;
    private object _value;
    public int Count { get; }
    internal HeaderStringValues(HeaderDescriptor descriptor, string value);
    internal HeaderStringValues(HeaderDescriptor descriptor, String[] values);
    public sealed virtual int get_Count();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class System.Net.Http.Headers.HeaderUtilities : object {
    internal static TransferCodingHeaderValue TransferEncodingChunked;
    internal static NameValueWithParametersHeaderValue ExpectContinue;
    private static SearchValues`1<byte> s_rfc5987AttrBytes;
    private static HeaderUtilities();
    internal static void SetQuality(UnvalidatedObjectCollection`1<NameValueHeaderValue> parameters, Nullable`1<double> value);
    internal static string Encode5987(string input);
    private static void AddHexEscaped(byte c, ValueStringBuilder& destination);
    internal static Nullable`1<double> GetQuality(UnvalidatedObjectCollection`1<NameValueHeaderValue> parameters);
    internal static void CheckValidToken(string value, string parameterName);
    internal static void CheckValidComment(string value, string parameterName);
    internal static void CheckValidQuotedString(string value, string parameterName);
    internal static bool AreEqualCollections(ObjectCollection`1<T> x, ObjectCollection`1<T> y);
    internal static bool AreEqualCollections(ObjectCollection`1<T> x, ObjectCollection`1<T> y, IEqualityComparer`1<T> comparer);
    internal static int GetNextNonEmptyOrWhitespaceIndex(string input, int startIndex, bool skipEmptyValues, Boolean& separatorFound);
    internal static Nullable`1<DateTimeOffset> GetDateTimeOffsetValue(HeaderDescriptor descriptor, HttpHeaders store, Nullable`1<DateTimeOffset> defaultValue);
    internal static Nullable`1<TimeSpan> GetTimeSpanValue(HeaderDescriptor descriptor, HttpHeaders store);
    internal static bool TryParseInt32(string value, Int32& result);
    internal static bool TryParseInt32(string value, int offset, int length, Int32& result);
    internal static bool TryParseInt64(string value, int offset, int length, Int64& result);
    internal static void DumpHeaders(StringBuilder sb, HttpHeaders[] headers);
    [ExtensionAttribute]
internal static UnvalidatedObjectCollection`1<NameValueHeaderValue> Clone(UnvalidatedObjectCollection`1<NameValueHeaderValue> source);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.HttpContentHeaders : HttpHeaders {
    private HttpContent _parent;
    private bool _contentLengthSet;
    private HttpHeaderValueCollection`1<string> _allow;
    private HttpHeaderValueCollection`1<string> _contentEncoding;
    private HttpHeaderValueCollection`1<string> _contentLanguage;
    [NullableAttribute("1")]
public ICollection`1<string> Allow { get; }
    public ContentDispositionHeaderValue ContentDisposition { get; public set; }
    [NullableAttribute("1")]
public ICollection`1<string> ContentEncoding { get; }
    [NullableAttribute("1")]
public ICollection`1<string> ContentLanguage { get; }
    public Nullable`1<long> ContentLength { get; public set; }
    public Uri ContentLocation { get; public set; }
    public Byte[] ContentMD5 { get; public set; }
    public ContentRangeHeaderValue ContentRange { get; public set; }
    public MediaTypeHeaderValue ContentType { get; public set; }
    public Nullable`1<DateTimeOffset> Expires { get; public set; }
    public Nullable`1<DateTimeOffset> LastModified { get; public set; }
    internal HttpContentHeaders(HttpContent parent);
    [NullableContextAttribute("1")]
public ICollection`1<string> get_Allow();
    public ContentDispositionHeaderValue get_ContentDisposition();
    public void set_ContentDisposition(ContentDispositionHeaderValue value);
    [NullableContextAttribute("1")]
public ICollection`1<string> get_ContentEncoding();
    [NullableContextAttribute("1")]
public ICollection`1<string> get_ContentLanguage();
    public Nullable`1<long> get_ContentLength();
    public void set_ContentLength(Nullable`1<long> value);
    public Uri get_ContentLocation();
    public void set_ContentLocation(Uri value);
    public Byte[] get_ContentMD5();
    public void set_ContentMD5(Byte[] value);
    public ContentRangeHeaderValue get_ContentRange();
    public void set_ContentRange(ContentRangeHeaderValue value);
    public MediaTypeHeaderValue get_ContentType();
    public void set_ContentType(MediaTypeHeaderValue value);
    public Nullable`1<DateTimeOffset> get_Expires();
    public void set_Expires(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_LastModified();
    public void set_LastModified(Nullable`1<DateTimeOffset> value);
}
internal class System.Net.Http.Headers.HttpGeneralHeaders : object {
    private HttpHeaderValueCollection`1<string> _connection;
    private HttpHeaderValueCollection`1<string> _trailer;
    private HttpHeaderValueCollection`1<TransferCodingHeaderValue> _transferEncoding;
    private HttpHeaderValueCollection`1<ProductHeaderValue> _upgrade;
    private HttpHeaderValueCollection`1<ViaHeaderValue> _via;
    private HttpHeaderValueCollection`1<WarningHeaderValue> _warning;
    private HttpHeaderValueCollection`1<NameValueHeaderValue> _pragma;
    private HttpHeaders _parent;
    private bool _transferEncodingChunkedSet;
    private bool _connectionCloseSet;
    public CacheControlHeaderValue CacheControl { get; public set; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    internal HttpGeneralHeaders(HttpHeaders parent);
    public CacheControlHeaderValue get_CacheControl();
    public void set_CacheControl(CacheControlHeaderValue value);
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    internal static Nullable`1<bool> GetConnectionClose(HttpHeaders parent, HttpGeneralHeaders headers);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    internal static Nullable`1<bool> GetTransferEncodingChunked(HttpHeaders parent, HttpGeneralHeaders headers);
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    public HttpHeaderValueCollection`1<string> get_Connection();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    internal void AddSpecialsFrom(HttpGeneralHeaders sourceHeaders);
}
internal abstract class System.Net.Http.Headers.HttpHeaderParser : object {
    private bool _supportsMultipleValues;
    private string _separator;
    public bool SupportsMultipleValues { get; }
    public string Separator { get; }
    public IEqualityComparer Comparer { get; }
    protected HttpHeaderParser(bool supportsMultipleValues);
    protected HttpHeaderParser(bool supportsMultipleValues, string separator);
    public bool get_SupportsMultipleValues();
    public string get_Separator();
    public virtual IEqualityComparer get_Comparer();
    public abstract virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
    public object ParseValue(string value, object storeValue, Int32& index);
    public virtual string ToString(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Http.Headers.HttpHeaders : object {
    private object _headerStore;
    private int _count;
    private HttpHeaderType _allowedHeaderTypes;
    private HttpHeaderType _treatAsCustomHeaderTypes;
    public HttpHeadersNonValidated NonValidated { get; }
    internal int Count { get; }
    private bool EntriesAreLiveView { get; }
    internal HttpHeaders(HttpHeaderType allowedHeaderTypes, HttpHeaderType treatAsCustomHeaderTypes);
    public HttpHeadersNonValidated get_NonValidated();
    public void Add(string name, string value);
    internal void Add(HeaderDescriptor descriptor, string value);
    public void Add(string name, IEnumerable`1<string> values);
    internal void Add(HeaderDescriptor descriptor, IEnumerable`1<string> values);
    public bool TryAddWithoutValidation(string name, string value);
    internal bool TryAddWithoutValidation(HeaderDescriptor descriptor, string value);
    public bool TryAddWithoutValidation(string name, IEnumerable`1<string> values);
    internal bool TryAddWithoutValidation(HeaderDescriptor descriptor, IEnumerable`1<string> values);
    public IEnumerable`1<string> GetValues(string name);
    internal IEnumerable`1<string> GetValues(HeaderDescriptor descriptor);
    public bool TryGetValues(string name, IEnumerable`1& values);
    internal bool TryGetValues(HeaderDescriptor descriptor, IEnumerable`1& values);
    public bool Contains(string name);
    public virtual string ToString();
    internal string GetHeaderString(HeaderDescriptor descriptor);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeaders/<GetEnumeratorCore>d__24")]
private IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumeratorCore();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void AddParsedValue(HeaderDescriptor descriptor, object value);
    internal void SetParsedValue(HeaderDescriptor descriptor, object value);
    internal void SetOrRemoveParsedValue(HeaderDescriptor descriptor, object value);
    public bool Remove(string name);
    internal bool RemoveParsedValue(HeaderDescriptor descriptor, object value);
    internal bool ContainsParsedValue(HeaderDescriptor descriptor, object value);
    internal virtual void AddHeaders(HttpHeaders sourceHeaders);
    private static HeaderStoreItemInfo CloneHeaderInfo(HeaderDescriptor descriptor, HeaderStoreItemInfo sourceInfo);
    private static void CloneAndAddValue(HeaderStoreItemInfo destinationInfo, object source);
    private static object CloneStringHeaderInfoValues(object source);
    private HeaderStoreItemInfo GetOrCreateHeaderInfo(HeaderDescriptor descriptor);
    private HeaderStoreItemInfo CreateAndAddHeaderToStore(HeaderDescriptor descriptor);
    internal bool TryGetHeaderValue(HeaderDescriptor descriptor, Object& value);
    private bool TryGetAndParseHeaderInfo(HeaderDescriptor key, HeaderStoreItemInfo& info);
    private static void ParseRawHeaderValues(HeaderDescriptor descriptor, HeaderStoreItemInfo info);
    private static void ParseSingleRawHeaderValue(HeaderStoreItemInfo info, HeaderDescriptor descriptor, string rawValue);
    internal bool TryParseAndAddValue(HeaderDescriptor descriptor, string value);
    private static bool TryParseAndAddRawHeaderValue(HeaderDescriptor descriptor, HeaderStoreItemInfo info, string value, bool addWhenInvalid);
    private static void AddParsedValue(HeaderStoreItemInfo info, object value);
    private static void AddInvalidValue(HeaderStoreItemInfo info, string value);
    private static void AddRawValue(HeaderStoreItemInfo info, string value);
    private static void AddValueToStoreValue(T value, Object& currentStoreValue);
    internal object GetSingleParsedValue(HeaderDescriptor descriptor);
    internal object GetParsedAndInvalidValues(HeaderDescriptor descriptor);
    internal virtual bool IsAllowedHeaderName(HeaderDescriptor descriptor);
    private void PrepareHeaderInfoForAdd(HeaderDescriptor descriptor, HeaderStoreItemInfo& info, Boolean& addToStore);
    private static void ParseAndAddValue(HeaderDescriptor descriptor, HeaderStoreItemInfo info, string value);
    private HeaderDescriptor GetHeaderDescriptor(string name);
    internal bool TryGetHeaderDescriptor(string name, HeaderDescriptor& descriptor);
    internal static void CheckContainsNewLine(string value);
    internal static String[] GetStoreValuesAsStringArray(HeaderDescriptor descriptor, HeaderStoreItemInfo info);
    internal static void GetStoreValuesAsStringOrStringArray(HeaderDescriptor descriptor, object sourceValues, String& singleValue, String[]& multiValue);
    internal static int GetStoreValuesIntoStringArray(HeaderDescriptor descriptor, object sourceValues, String[]& values);
    private static int GetValueCount(HeaderStoreItemInfo info);
    private static void ReadStoreValues(Span`1<string> values, object storeValue, HttpHeaderParser parser, Int32& currentIndex);
    private static bool AreEqual(object value, object storeValue, IEqualityComparer comparer);
    internal HeaderEntry[] GetEntriesArray();
    internal ReadOnlySpan`1<HeaderEntry> GetEntries();
    internal int get_Count();
    private bool get_EntriesAreLiveView();
    private Object& GetValueRefOrNullRef(HeaderDescriptor key);
    private Object& GetValueRefOrAddDefault(HeaderDescriptor key);
    private void AddEntryToStore(HeaderEntry entry);
    internal bool Contains(HeaderDescriptor key);
    public void Clear();
    internal bool Remove(HeaderDescriptor key);
    [CompilerGeneratedAttribute]
internal static int <GetValueCount>g__Count|59_0(object valueStore);
    [CompilerGeneratedAttribute]
private HeaderEntry[] <GetEntriesArray>g__GetEntriesFromDictionary|66_0();
    [CompilerGeneratedAttribute]
private Object& <GetValueRefOrAddDefault>g__GrowEntriesAndAddDefault|73_0(HeaderDescriptor key);
    [CompilerGeneratedAttribute]
private Object& <GetValueRefOrAddDefault>g__ConvertToDictionaryAndAddDefault|73_1(HeaderDescriptor key);
    [CompilerGeneratedAttribute]
private Object& <GetValueRefOrAddDefault>g__DictionaryGetValueRefOrAddDefault|73_2(HeaderDescriptor key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Net.Http.Headers.HttpHeadersNonValidated : ValueType {
    private HttpHeaders _headers;
    public int Count { get; }
    public HeaderStringValues Item { get; }
    private IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Net.Http.Headers.HeaderStringValues>.Keys { get; }
    private IEnumerable`1<HeaderStringValues> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Net.Http.Headers.HeaderStringValues>.Values { get; }
    internal HttpHeadersNonValidated(HttpHeaders headers);
    public sealed virtual int get_Count();
    public bool Contains(string headerName);
    public sealed virtual HeaderStringValues get_Item(string headerName);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.Net.Http.Headers.HeaderStringValues>.ContainsKey(string key);
    public bool TryGetValues(string headerName, HeaderStringValues& values);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.Net.Http.Headers.HeaderStringValues>.TryGetValue(string key, HeaderStringValues& value);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, HeaderStringValues>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Net.Http.Headers.HeaderStringValues>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeadersNonValidated/<System-Collections-Generic-IReadOnlyDictionary<System-String,System-Net-Http-Headers-HeaderStringValues>-get_Keys>d__14")]
private sealed virtual override IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Net.Http.Headers.HeaderStringValues>.get_Keys();
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeadersNonValidated/<System-Collections-Generic-IReadOnlyDictionary<System-String,System-Net-Http-Headers-HeaderStringValues>-get_Values>d__16")]
private sealed virtual override IEnumerable`1<HeaderStringValues> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Net.Http.Headers.HeaderStringValues>.get_Values();
}
[FlagsAttribute]
internal enum System.Net.Http.Headers.HttpHeaderType : Enum {
    public byte value__;
    public static HttpHeaderType General;
    public static HttpHeaderType Request;
    public static HttpHeaderType Response;
    public static HttpHeaderType Content;
    public static HttpHeaderType Custom;
    public static HttpHeaderType NonTrailing;
    public static HttpHeaderType All;
    public static HttpHeaderType None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.HttpHeaderValueCollection`1 : object {
    private HeaderDescriptor _descriptor;
    private HttpHeaders _store;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal HttpHeaderValueCollection`1(HeaderDescriptor descriptor, HttpHeaders store);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    [NullableContextAttribute("2")]
public void ParseAdd(string input);
    [NullableContextAttribute("2")]
public bool TryParseAdd(string input);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    private void CheckValue(T item);
    private int GetCount();
    [IteratorStateMachineAttribute("System.Net.Http.Headers.HttpHeaderValueCollection`1/<<GetEnumerator>g__Iterate|14_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerator`1<T> <GetEnumerator>g__Iterate|14_0(object storeValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.HttpRequestHeaders : HttpHeaders {
    private Object[] _specialCollectionsSlots;
    private HttpGeneralHeaders _generalHeaders;
    private bool _expectContinueSet;
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> Accept { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptCharset { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptEncoding { get; }
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> AcceptLanguage { get; }
    [NullableAttribute("2")]
public AuthenticationHeaderValue Authorization { get; public set; }
    public Nullable`1<bool> ExpectContinue { get; public set; }
    [NullableAttribute("2")]
public string From { get; public set; }
    [NullableAttribute("2")]
public string Host { get; public set; }
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfMatch { get; }
    public Nullable`1<DateTimeOffset> IfModifiedSince { get; public set; }
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> IfNoneMatch { get; }
    [NullableAttribute("2")]
public RangeConditionHeaderValue IfRange { get; public set; }
    public Nullable`1<DateTimeOffset> IfUnmodifiedSince { get; public set; }
    public Nullable`1<int> MaxForwards { get; public set; }
    [NullableAttribute("2")]
public string Protocol { get; public set; }
    [NullableAttribute("2")]
public AuthenticationHeaderValue ProxyAuthorization { get; public set; }
    [NullableAttribute("2")]
public RangeHeaderValue Range { get; public set; }
    [NullableAttribute("2")]
public Uri Referrer { get; public set; }
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> TE { get; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> UserAgent { get; }
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> Expect { get; }
    [NullableAttribute("2")]
public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    private HttpGeneralHeaders GeneralHeaders { get; }
    private T GetSpecializedCollection(int slot, Func`2<HttpRequestHeaders, T> creationFunc);
    public HttpHeaderValueCollection`1<MediaTypeWithQualityHeaderValue> get_Accept();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptCharset();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptEncoding();
    public HttpHeaderValueCollection`1<StringWithQualityHeaderValue> get_AcceptLanguage();
    [NullableContextAttribute("2")]
public AuthenticationHeaderValue get_Authorization();
    [NullableContextAttribute("2")]
public void set_Authorization(AuthenticationHeaderValue value);
    public Nullable`1<bool> get_ExpectContinue();
    public void set_ExpectContinue(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
public string get_From();
    [NullableContextAttribute("2")]
public void set_From(string value);
    [NullableContextAttribute("2")]
public string get_Host();
    [NullableContextAttribute("2")]
public void set_Host(string value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfMatch();
    public Nullable`1<DateTimeOffset> get_IfModifiedSince();
    public void set_IfModifiedSince(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<EntityTagHeaderValue> get_IfNoneMatch();
    [NullableContextAttribute("2")]
public RangeConditionHeaderValue get_IfRange();
    [NullableContextAttribute("2")]
public void set_IfRange(RangeConditionHeaderValue value);
    public Nullable`1<DateTimeOffset> get_IfUnmodifiedSince();
    public void set_IfUnmodifiedSince(Nullable`1<DateTimeOffset> value);
    public Nullable`1<int> get_MaxForwards();
    public void set_MaxForwards(Nullable`1<int> value);
    [NullableContextAttribute("2")]
public string get_Protocol();
    [NullableContextAttribute("2")]
public void set_Protocol(string value);
    [NullableContextAttribute("2")]
public AuthenticationHeaderValue get_ProxyAuthorization();
    [NullableContextAttribute("2")]
public void set_ProxyAuthorization(AuthenticationHeaderValue value);
    [NullableContextAttribute("2")]
public RangeHeaderValue get_Range();
    [NullableContextAttribute("2")]
public void set_Range(RangeHeaderValue value);
    [NullableContextAttribute("2")]
public Uri get_Referrer();
    [NullableContextAttribute("2")]
public void set_Referrer(Uri value);
    public HttpHeaderValueCollection`1<TransferCodingWithQualityHeaderValue> get_TE();
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_UserAgent();
    public HttpHeaderValueCollection`1<NameValueWithParametersHeaderValue> get_Expect();
    [NullableContextAttribute("2")]
public CacheControlHeaderValue get_CacheControl();
    [NullableContextAttribute("2")]
public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    internal virtual void AddHeaders(HttpHeaders sourceHeaders);
    private HttpGeneralHeaders get_GeneralHeaders();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.HttpResponseHeaders : HttpHeaders {
    private Object[] _specialCollectionsSlots;
    private HttpGeneralHeaders _generalHeaders;
    private bool _containsTrailingHeaders;
    public HttpHeaderValueCollection`1<string> AcceptRanges { get; }
    public Nullable`1<TimeSpan> Age { get; public set; }
    [NullableAttribute("2")]
public EntityTagHeaderValue ETag { get; public set; }
    [NullableAttribute("2")]
public Uri Location { get; public set; }
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> ProxyAuthenticate { get; }
    [NullableAttribute("2")]
public RetryConditionHeaderValue RetryAfter { get; public set; }
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> Server { get; }
    public HttpHeaderValueCollection`1<string> Vary { get; }
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> WwwAuthenticate { get; }
    [NullableAttribute("2")]
public CacheControlHeaderValue CacheControl { get; public set; }
    public HttpHeaderValueCollection`1<string> Connection { get; }
    public Nullable`1<bool> ConnectionClose { get; public set; }
    public Nullable`1<DateTimeOffset> Date { get; public set; }
    public HttpHeaderValueCollection`1<NameValueHeaderValue> Pragma { get; }
    public HttpHeaderValueCollection`1<string> Trailer { get; }
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> TransferEncoding { get; }
    public Nullable`1<bool> TransferEncodingChunked { get; public set; }
    public HttpHeaderValueCollection`1<ProductHeaderValue> Upgrade { get; }
    public HttpHeaderValueCollection`1<ViaHeaderValue> Via { get; }
    public HttpHeaderValueCollection`1<WarningHeaderValue> Warning { get; }
    private HttpGeneralHeaders GeneralHeaders { get; }
    internal HttpResponseHeaders(bool containsTrailingHeaders);
    private T GetSpecializedCollection(int slot, Func`2<HttpResponseHeaders, T> creationFunc);
    public HttpHeaderValueCollection`1<string> get_AcceptRanges();
    public Nullable`1<TimeSpan> get_Age();
    public void set_Age(Nullable`1<TimeSpan> value);
    [NullableContextAttribute("2")]
public EntityTagHeaderValue get_ETag();
    [NullableContextAttribute("2")]
public void set_ETag(EntityTagHeaderValue value);
    [NullableContextAttribute("2")]
public Uri get_Location();
    [NullableContextAttribute("2")]
public void set_Location(Uri value);
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_ProxyAuthenticate();
    [NullableContextAttribute("2")]
public RetryConditionHeaderValue get_RetryAfter();
    [NullableContextAttribute("2")]
public void set_RetryAfter(RetryConditionHeaderValue value);
    public HttpHeaderValueCollection`1<ProductInfoHeaderValue> get_Server();
    public HttpHeaderValueCollection`1<string> get_Vary();
    public HttpHeaderValueCollection`1<AuthenticationHeaderValue> get_WwwAuthenticate();
    [NullableContextAttribute("2")]
public CacheControlHeaderValue get_CacheControl();
    [NullableContextAttribute("2")]
public void set_CacheControl(CacheControlHeaderValue value);
    public HttpHeaderValueCollection`1<string> get_Connection();
    public Nullable`1<bool> get_ConnectionClose();
    public void set_ConnectionClose(Nullable`1<bool> value);
    public Nullable`1<DateTimeOffset> get_Date();
    public void set_Date(Nullable`1<DateTimeOffset> value);
    public HttpHeaderValueCollection`1<NameValueHeaderValue> get_Pragma();
    public HttpHeaderValueCollection`1<string> get_Trailer();
    public HttpHeaderValueCollection`1<TransferCodingHeaderValue> get_TransferEncoding();
    public Nullable`1<bool> get_TransferEncodingChunked();
    public void set_TransferEncodingChunked(Nullable`1<bool> value);
    public HttpHeaderValueCollection`1<ProductHeaderValue> get_Upgrade();
    public HttpHeaderValueCollection`1<ViaHeaderValue> get_Via();
    public HttpHeaderValueCollection`1<WarningHeaderValue> get_Warning();
    internal virtual void AddHeaders(HttpHeaders sourceHeaders);
    internal virtual bool IsAllowedHeaderName(HeaderDescriptor descriptor);
    private HttpGeneralHeaders get_GeneralHeaders();
}
internal class System.Net.Http.Headers.Int32NumberHeaderParser : BaseHeaderParser {
    internal static Int32NumberHeaderParser Parser;
    private static Int32NumberHeaderParser();
    public virtual string ToString(object value);
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal class System.Net.Http.Headers.Int64NumberHeaderParser : BaseHeaderParser {
    internal static Int64NumberHeaderParser Parser;
    private static Int64NumberHeaderParser();
    public virtual string ToString(object value);
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal class System.Net.Http.Headers.KnownHeader : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpHeaderParser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpHeaderType <HeaderType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <KnownValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AsciiBytesWithColonSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Http2EncodedName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Http3EncodedName>k__BackingField;
    public string Name { get; }
    public HttpHeaderParser Parser { get; }
    public HttpHeaderType HeaderType { get; }
    public String[] KnownValues { get; }
    public Byte[] AsciiBytesWithColonSpace { get; }
    public HeaderDescriptor Descriptor { get; }
    public Byte[] Http2EncodedName { get; private set; }
    public Byte[] Http3EncodedName { get; private set; }
    public KnownHeader(string name, Nullable`1<int> http2StaticTableIndex, Nullable`1<int> http3StaticTableIndex);
    public KnownHeader(string name, HttpHeaderType headerType, HttpHeaderParser parser, String[] knownValues, Nullable`1<int> http2StaticTableIndex, Nullable`1<int> http3StaticTableIndex);
    [MemberNotNullAttribute("Http2EncodedName")]
[MemberNotNullAttribute("Http3EncodedName")]
private void Initialize(Nullable`1<int> http2StaticTableIndex, Nullable`1<int> http3StaticTableIndex);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public HttpHeaderParser get_Parser();
    [CompilerGeneratedAttribute]
public HttpHeaderType get_HeaderType();
    [CompilerGeneratedAttribute]
public String[] get_KnownValues();
    [CompilerGeneratedAttribute]
public Byte[] get_AsciiBytesWithColonSpace();
    public HeaderDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public Byte[] get_Http2EncodedName();
    [CompilerGeneratedAttribute]
private void set_Http2EncodedName(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Http3EncodedName();
    [CompilerGeneratedAttribute]
private void set_Http3EncodedName(Byte[] value);
}
internal static class System.Net.Http.Headers.KnownHeaders : object {
    public static KnownHeader PseudoStatus;
    public static KnownHeader Accept;
    public static KnownHeader AcceptCharset;
    public static KnownHeader AcceptEncoding;
    public static KnownHeader AcceptLanguage;
    public static KnownHeader AcceptPatch;
    public static KnownHeader AcceptRanges;
    public static KnownHeader AccessControlAllowCredentials;
    public static KnownHeader AccessControlAllowHeaders;
    public static KnownHeader AccessControlAllowMethods;
    public static KnownHeader AccessControlAllowOrigin;
    public static KnownHeader AccessControlExposeHeaders;
    public static KnownHeader AccessControlMaxAge;
    public static KnownHeader Age;
    public static KnownHeader Allow;
    public static KnownHeader AltSvc;
    public static KnownHeader AltUsed;
    public static KnownHeader Authorization;
    public static KnownHeader CacheControl;
    public static KnownHeader Connection;
    public static KnownHeader ContentDisposition;
    public static KnownHeader ContentEncoding;
    public static KnownHeader ContentLanguage;
    public static KnownHeader ContentLength;
    public static KnownHeader ContentLocation;
    public static KnownHeader ContentMD5;
    public static KnownHeader ContentRange;
    public static KnownHeader ContentSecurityPolicy;
    public static KnownHeader ContentType;
    public static KnownHeader Cookie;
    public static KnownHeader Cookie2;
    public static KnownHeader Date;
    public static KnownHeader ETag;
    public static KnownHeader Expect;
    public static KnownHeader ExpectCT;
    public static KnownHeader Expires;
    public static KnownHeader From;
    public static KnownHeader GrpcEncoding;
    public static KnownHeader GrpcMessage;
    public static KnownHeader GrpcStatus;
    public static KnownHeader Host;
    public static KnownHeader IfMatch;
    public static KnownHeader IfModifiedSince;
    public static KnownHeader IfNoneMatch;
    public static KnownHeader IfRange;
    public static KnownHeader IfUnmodifiedSince;
    public static KnownHeader KeepAlive;
    public static KnownHeader LastModified;
    public static KnownHeader Link;
    public static KnownHeader Location;
    public static KnownHeader MaxForwards;
    public static KnownHeader Origin;
    public static KnownHeader P3P;
    public static KnownHeader Pragma;
    public static KnownHeader ProxyAuthenticate;
    public static KnownHeader ProxyAuthorization;
    public static KnownHeader ProxyConnection;
    public static KnownHeader ProxySupport;
    public static KnownHeader PublicKeyPins;
    public static KnownHeader Range;
    public static KnownHeader Referer;
    public static KnownHeader ReferrerPolicy;
    public static KnownHeader Refresh;
    public static KnownHeader RetryAfter;
    public static KnownHeader SecWebSocketAccept;
    public static KnownHeader SecWebSocketExtensions;
    public static KnownHeader SecWebSocketKey;
    public static KnownHeader SecWebSocketProtocol;
    public static KnownHeader SecWebSocketVersion;
    public static KnownHeader Server;
    public static KnownHeader ServerTiming;
    public static KnownHeader SetCookie;
    public static KnownHeader SetCookie2;
    public static KnownHeader StrictTransportSecurity;
    public static KnownHeader TE;
    public static KnownHeader TSV;
    public static KnownHeader Trailer;
    public static KnownHeader TransferEncoding;
    public static KnownHeader Upgrade;
    public static KnownHeader UpgradeInsecureRequests;
    public static KnownHeader UserAgent;
    public static KnownHeader Vary;
    public static KnownHeader Via;
    public static KnownHeader WWWAuthenticate;
    public static KnownHeader Warning;
    public static KnownHeader XAspNetVersion;
    public static KnownHeader XCache;
    public static KnownHeader XContentDuration;
    public static KnownHeader XContentTypeOptions;
    public static KnownHeader XFrameOptions;
    public static KnownHeader XMSEdgeRef;
    public static KnownHeader XPoweredBy;
    public static KnownHeader XRequestID;
    public static KnownHeader XUACompatible;
    public static KnownHeader XXssProtection;
    private static KnownHeaders();
    private static AltSvcHeaderParser GetAltSvcHeaderParser();
    private static KnownHeader GetCandidate(T key);
    internal static KnownHeader TryGetKnownHeader(string name);
    internal static KnownHeader TryGetKnownHeader(ReadOnlySpan`1<byte> name);
}
internal class System.Net.Http.Headers.MediaTypeHeaderParser : BaseHeaderParser {
    private Func`1<MediaTypeHeaderValue> _mediaTypeCreator;
    internal static MediaTypeHeaderParser SingleValueParser;
    internal static MediaTypeHeaderParser SingleValueWithQualityParser;
    internal static MediaTypeHeaderParser MultipleValuesParser;
    private MediaTypeHeaderParser(bool supportsMultipleValues, Func`1<MediaTypeHeaderValue> mediaTypeCreator);
    private static MediaTypeHeaderParser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
    private static MediaTypeHeaderValue CreateMediaType();
    private static MediaTypeWithQualityHeaderValue CreateMediaTypeWithQuality();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.MediaTypeHeaderValue : object {
    private UnvalidatedObjectCollection`1<NameValueHeaderValue> _parameters;
    private string _mediaType;
    public string CharSet { get; public set; }
    [NullableAttribute("1")]
public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public string MediaType { get; public set; }
    [NullableContextAttribute("1")]
protected MediaTypeHeaderValue(MediaTypeHeaderValue source);
    [NullableContextAttribute("1")]
public MediaTypeHeaderValue(string mediaType);
    [NullableContextAttribute("1")]
public MediaTypeHeaderValue(string mediaType, string charSet);
    public string get_CharSet();
    public void set_CharSet(string value);
    [NullableContextAttribute("1")]
public ICollection`1<NameValueHeaderValue> get_Parameters();
    public string get_MediaType();
    public void set_MediaType(string value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static MediaTypeHeaderValue Parse(string input);
    public static bool TryParse(string input, MediaTypeHeaderValue& parsedValue);
    internal static int GetMediaTypeLength(string input, int startIndex, Func`1<MediaTypeHeaderValue> mediaTypeCreator, MediaTypeHeaderValue& parsedValue);
    private static int GetMediaTypeExpressionLength(string input, int startIndex, String& mediaType);
    private static void CheckMediaTypeFormat(string mediaType, string parameterName);
    private sealed virtual override object System.ICloneable.Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.MediaTypeWithQualityHeaderValue : MediaTypeHeaderValue {
    public Nullable`1<double> Quality { get; public set; }
    public MediaTypeWithQualityHeaderValue(string mediaType);
    public MediaTypeWithQualityHeaderValue(string mediaType, double quality);
    private MediaTypeWithQualityHeaderValue(MediaTypeWithQualityHeaderValue source);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    private sealed virtual override object System.ICloneable.Clone();
    public static MediaTypeWithQualityHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, MediaTypeWithQualityHeaderValue& parsedValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.NameValueHeaderValue : object {
    private static Func`1<NameValueHeaderValue> s_defaultNameValueCreator;
    private string _name;
    private string _value;
    public string Name { get; }
    [NullableAttribute("2")]
public string Value { get; public set; }
    public NameValueHeaderValue(string name);
    public NameValueHeaderValue(string name, string value);
    protected internal NameValueHeaderValue(NameValueHeaderValue source);
    private static NameValueHeaderValue();
    public string get_Name();
    [NullableContextAttribute("2")]
public string get_Value();
    [NullableContextAttribute("2")]
public void set_Value(string value);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static NameValueHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, NameValueHeaderValue& parsedValue);
    public virtual string ToString();
    private void AddToStringBuilder(StringBuilder sb);
    internal static void ToString(UnvalidatedObjectCollection`1<NameValueHeaderValue> values, char separator, bool leadingSeparator, StringBuilder destination);
    internal static int GetHashCode(UnvalidatedObjectCollection`1<NameValueHeaderValue> values);
    internal static int GetNameValueLength(string input, int startIndex, NameValueHeaderValue& parsedValue);
    internal static int GetNameValueLength(string input, int startIndex, Func`1<NameValueHeaderValue> nameValueCreator, NameValueHeaderValue& parsedValue);
    internal static int GetNameValueListLength(string input, int startIndex, char delimiter, UnvalidatedObjectCollection`1<NameValueHeaderValue> nameValueCollection);
    internal static NameValueHeaderValue Find(UnvalidatedObjectCollection`1<NameValueHeaderValue> values, string name);
    internal static int GetValueLength(string input, int startIndex);
    private static void CheckNameValueFormat(string name, string value);
    private static void CheckValueFormat(string value);
    private static NameValueHeaderValue CreateNameValue();
    private sealed virtual override object System.ICloneable.Clone();
    [CompilerGeneratedAttribute]
internal static void <CheckValueFormat>g__ThrowFormatException|26_0(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.NameValueWithParametersHeaderValue : NameValueHeaderValue {
    private static Func`1<NameValueHeaderValue> s_nameValueCreator;
    private UnvalidatedObjectCollection`1<NameValueHeaderValue> _parameters;
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    public NameValueWithParametersHeaderValue(string name);
    public NameValueWithParametersHeaderValue(string name, string value);
    protected NameValueWithParametersHeaderValue(NameValueWithParametersHeaderValue source);
    private static NameValueWithParametersHeaderValue();
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static NameValueWithParametersHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, NameValueWithParametersHeaderValue& parsedValue);
    internal static int GetNameValueWithParametersLength(string input, int startIndex, Object& parsedValue);
    private static NameValueHeaderValue CreateNameValue();
    private sealed virtual override object System.ICloneable.Clone();
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Net.Http.Headers.ObjectCollection`1/DebugView")]
internal abstract class System.Net.Http.Headers.ObjectCollection`1 : object {
    internal object _items;
    internal int _size;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public abstract virtual void Validate(T item);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.ProductHeaderValue : object {
    private string _name;
    private string _version;
    public string Name { get; }
    [NullableAttribute("2")]
public string Version { get; }
    public ProductHeaderValue(string name);
    public ProductHeaderValue(string name, string version);
    private ProductHeaderValue(ProductHeaderValue source);
    public string get_Name();
    [NullableContextAttribute("2")]
public string get_Version();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, ProductHeaderValue& parsedValue);
    internal static int GetProductLength(string input, int startIndex, ProductHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.ProductInfoHeaderParser : HttpHeaderParser {
    internal static ProductInfoHeaderParser SingleValueParser;
    internal static ProductInfoHeaderParser MultipleValueParser;
    private ProductInfoHeaderParser(bool supportsMultipleValues);
    private static ProductInfoHeaderParser();
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.ProductInfoHeaderValue : object {
    private ProductHeaderValue _product;
    private string _comment;
    [NullableAttribute("2")]
public ProductHeaderValue Product { get; }
    [NullableAttribute("2")]
public string Comment { get; }
    public ProductInfoHeaderValue(string productName, string productVersion);
    public ProductInfoHeaderValue(ProductHeaderValue product);
    public ProductInfoHeaderValue(string comment);
    private ProductInfoHeaderValue(ProductInfoHeaderValue source);
    [NullableContextAttribute("2")]
public ProductHeaderValue get_Product();
    [NullableContextAttribute("2")]
public string get_Comment();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ProductInfoHeaderValue Parse(string input);
    public static bool TryParse(string input, ProductInfoHeaderValue& parsedValue);
    internal static int GetProductInfoLength(string input, int startIndex, ProductInfoHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
internal static class System.Net.Http.Headers.QPackStaticTable : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ValueTuple`2[] <HeaderLookup>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2[] HeaderLookup { get; }
    private static QPackStaticTable();
    [CompilerGeneratedAttribute]
internal static ValueTuple`2[] get_HeaderLookup();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.RangeConditionHeaderValue : object {
    private DateTimeOffset _date;
    private EntityTagHeaderValue _entityTag;
    public Nullable`1<DateTimeOffset> Date { get; }
    [NullableAttribute("2")]
public EntityTagHeaderValue EntityTag { get; }
    public RangeConditionHeaderValue(DateTimeOffset date);
    public RangeConditionHeaderValue(EntityTagHeaderValue entityTag);
    public RangeConditionHeaderValue(string entityTag);
    private RangeConditionHeaderValue(RangeConditionHeaderValue source);
    public Nullable`1<DateTimeOffset> get_Date();
    [NullableContextAttribute("2")]
public EntityTagHeaderValue get_EntityTag();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeConditionHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, RangeConditionHeaderValue& parsedValue);
    internal static int GetRangeConditionLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.RangeHeaderValue : object {
    private string _unit;
    private UnvalidatedObjectCollection`1<RangeItemHeaderValue> _ranges;
    public string Unit { get; public set; }
    public ICollection`1<RangeItemHeaderValue> Ranges { get; }
    public RangeHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    private RangeHeaderValue(RangeHeaderValue source);
    public string get_Unit();
    public void set_Unit(string value);
    public ICollection`1<RangeItemHeaderValue> get_Ranges();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static RangeHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, RangeHeaderValue& parsedValue);
    internal static int GetRangeLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.RangeItemHeaderValue : object {
    private long _from;
    private long _to;
    public Nullable`1<long> From { get; }
    public Nullable`1<long> To { get; }
    public RangeItemHeaderValue(Nullable`1<long> from, Nullable`1<long> to);
    internal RangeItemHeaderValue(RangeItemHeaderValue source);
    public Nullable`1<long> get_From();
    public Nullable`1<long> get_To();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static int GetRangeItemListLength(string input, int startIndex, ICollection`1<RangeItemHeaderValue> rangeCollection);
    internal static int GetRangeItemLength(string input, int startIndex, RangeItemHeaderValue& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
public class System.Net.Http.Headers.RetryConditionHeaderValue : object {
    private DateTimeOffset _date;
    private TimeSpan _delta;
    public Nullable`1<DateTimeOffset> Date { get; }
    public Nullable`1<TimeSpan> Delta { get; }
    public RetryConditionHeaderValue(DateTimeOffset date);
    public RetryConditionHeaderValue(TimeSpan delta);
    private RetryConditionHeaderValue(RetryConditionHeaderValue source);
    public Nullable`1<DateTimeOffset> get_Date();
    public Nullable`1<TimeSpan> get_Delta();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static RetryConditionHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, RetryConditionHeaderValue& parsedValue);
    internal static int GetRetryConditionLength(string input, int startIndex, Object& parsedValue);
    private sealed virtual override object System.ICloneable.Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.StringWithQualityHeaderValue : object {
    private string _value;
    private double _quality;
    public string Value { get; }
    public Nullable`1<double> Quality { get; }
    public StringWithQualityHeaderValue(string value);
    public StringWithQualityHeaderValue(string value, double quality);
    private StringWithQualityHeaderValue(StringWithQualityHeaderValue source);
    public string get_Value();
    public Nullable`1<double> get_Quality();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static StringWithQualityHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, StringWithQualityHeaderValue& parsedValue);
    internal static int GetStringWithQualityLength(string input, int startIndex, Object& parsedValue);
    private static bool TryReadQuality(string input, Double& quality, Int32& index);
    private sealed virtual override object System.ICloneable.Clone();
}
internal class System.Net.Http.Headers.TimeSpanHeaderParser : BaseHeaderParser {
    internal static TimeSpanHeaderParser Parser;
    private static TimeSpanHeaderParser();
    public virtual string ToString(object value);
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
}
internal class System.Net.Http.Headers.TransferCodingHeaderParser : BaseHeaderParser {
    private Func`1<TransferCodingHeaderValue> _transferCodingCreator;
    internal static TransferCodingHeaderParser SingleValueParser;
    internal static TransferCodingHeaderParser MultipleValueParser;
    internal static TransferCodingHeaderParser SingleValueWithQualityParser;
    internal static TransferCodingHeaderParser MultipleValueWithQualityParser;
    private TransferCodingHeaderParser(bool supportsMultipleValues, Func`1<TransferCodingHeaderValue> transferCodingCreator);
    private static TransferCodingHeaderParser();
    protected virtual int GetParsedValueLength(string value, int startIndex, object storeValue, Object& parsedValue);
    private static TransferCodingHeaderValue CreateTransferCoding();
    private static TransferCodingWithQualityHeaderValue CreateTransferCodingWithQuality();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.TransferCodingHeaderValue : object {
    private UnvalidatedObjectCollection`1<NameValueHeaderValue> _parameters;
    private string _value;
    public string Value { get; }
    public ICollection`1<NameValueHeaderValue> Parameters { get; }
    protected TransferCodingHeaderValue(TransferCodingHeaderValue source);
    public TransferCodingHeaderValue(string value);
    public string get_Value();
    public ICollection`1<NameValueHeaderValue> get_Parameters();
    public static TransferCodingHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, TransferCodingHeaderValue& parsedValue);
    internal static int GetTransferCodingLength(string input, int startIndex, Func`1<TransferCodingHeaderValue> transferCodingCreator, TransferCodingHeaderValue& parsedValue);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override object System.ICloneable.Clone();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.TransferCodingWithQualityHeaderValue : TransferCodingHeaderValue {
    public Nullable`1<double> Quality { get; public set; }
    public TransferCodingWithQualityHeaderValue(string value);
    public TransferCodingWithQualityHeaderValue(string value, double quality);
    private TransferCodingWithQualityHeaderValue(TransferCodingWithQualityHeaderValue source);
    public Nullable`1<double> get_Quality();
    public void set_Quality(Nullable`1<double> value);
    private sealed virtual override object System.ICloneable.Clone();
    public static TransferCodingWithQualityHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, TransferCodingWithQualityHeaderValue& parsedValue);
}
internal class System.Net.Http.Headers.UnvalidatedObjectCollection`1 : ObjectCollection`1<T> {
    public virtual void Validate(T item);
}
internal class System.Net.Http.Headers.UriHeaderParser : HttpHeaderParser {
    private UriKind _uriKind;
    internal static UriHeaderParser RelativeOrAbsoluteUriParser;
    private UriHeaderParser(UriKind uriKind);
    private static UriHeaderParser();
    public virtual bool TryParseValue(string value, object storeValue, Int32& index, Object& parsedValue);
    internal static string DecodeUtf8FromString(string input);
    public virtual string ToString(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.ViaHeaderValue : object {
    private string _protocolName;
    private string _protocolVersion;
    private string _receivedBy;
    private string _comment;
    [NullableAttribute("2")]
public string ProtocolName { get; }
    public string ProtocolVersion { get; }
    public string ReceivedBy { get; }
    [NullableAttribute("2")]
public string Comment { get; }
    public ViaHeaderValue(string protocolVersion, string receivedBy);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName);
    public ViaHeaderValue(string protocolVersion, string receivedBy, string protocolName, string comment);
    private ViaHeaderValue(ViaHeaderValue source);
    [NullableContextAttribute("2")]
public string get_ProtocolName();
    public string get_ProtocolVersion();
    public string get_ReceivedBy();
    [NullableContextAttribute("2")]
public string get_Comment();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ViaHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, ViaHeaderValue& parsedValue);
    internal static int GetViaLength(string input, int startIndex, Object& parsedValue);
    private static int GetProtocolEndIndex(string input, int startIndex, String& protocolName, String& protocolVersion);
    private sealed virtual override object System.ICloneable.Clone();
    private static void CheckReceivedBy(string receivedBy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Headers.WarningHeaderValue : object {
    private int _code;
    private string _agent;
    private string _text;
    private DateTimeOffset _date;
    private bool _dateHasValue;
    public int Code { get; }
    public string Agent { get; }
    public string Text { get; }
    public Nullable`1<DateTimeOffset> Date { get; }
    public WarningHeaderValue(int code, string agent, string text);
    public WarningHeaderValue(int code, string agent, string text, DateTimeOffset date);
    private WarningHeaderValue(WarningHeaderValue source);
    public int get_Code();
    public string get_Agent();
    public string get_Text();
    public Nullable`1<DateTimeOffset> get_Date();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static WarningHeaderValue Parse(string input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, WarningHeaderValue& parsedValue);
    internal static int GetWarningLength(string input, int startIndex, Object& parsedValue);
    private static bool TryReadAgent(string input, Int32& current, String& agent);
    private static bool TryReadCode(string input, Int32& current, Int32& code);
    private static bool TryReadDate(string input, Int32& current, Nullable`1& date);
    private sealed virtual override object System.ICloneable.Clone();
    private static void CheckCode(int code);
    private static void CheckAgent(string agent);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.Http.HPack.DynamicTable : object {
    private HeaderField[] _buffer;
    private int _maxSize;
    private int _size;
    private int _count;
    private int _insertIndex;
    private int _removeIndex;
    [IsReadOnlyAttribute]
public HeaderField& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public DynamicTable(int maxSize);
    public HeaderField& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public void Insert(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public void Insert(Nullable`1<int> staticTableIndex, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public void Resize(int maxSize);
    private void EnsureAvailable(int available);
}
internal static class System.Net.Http.HPack.H2StaticTable : object {
    private static HeaderField[] s_staticDecoderTable;
    public static int Count { get; }
    private static H2StaticTable();
    public static int get_Count();
    public static HeaderField& modreq(System.Runtime.InteropServices.InAttribute) Get(int index);
    private static HeaderField CreateHeaderField(int staticTableIndex, string name, string value);
}
[IsReadOnlyAttribute]
internal class System.Net.Http.HPack.HeaderField : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <StaticTableIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    public Nullable`1<int> StaticTableIndex { get; }
    public Byte[] Name { get; }
    public Byte[] Value { get; }
    public int Length { get; }
    public HeaderField(Nullable`1<int> staticTableIndex, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_StaticTableIndex();
    [CompilerGeneratedAttribute]
public Byte[] get_Name();
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    public int get_Length();
    public static int GetLength(int nameLength, int valueLength);
    public virtual string ToString();
}
internal class System.Net.Http.HPack.HPackDecoder : object {
    private int _maxDynamicTableSize;
    private int _maxHeadersLength;
    private DynamicTable _dynamicTable;
    private IntegerDecoder _integerDecoder;
    private Byte[] _stringOctets;
    private Byte[] _headerNameOctets;
    private Byte[] _headerValueOctets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerNameRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerValueRange;
    private State _state;
    private Byte[] _headerName;
    private int _headerStaticIndex;
    private int _stringIndex;
    private int _stringLength;
    private int _headerNameLength;
    private int _headerValueLength;
    private bool _index;
    private bool _huffman;
    private bool _headersObserved;
    public HPackDecoder(int maxDynamicTableSize, int maxHeadersLength);
    internal HPackDecoder(int maxDynamicTableSize, int maxHeadersLength, DynamicTable dynamicTable);
    public void Decode(ReadOnlySpan`1<byte> data, bool endHeaders, IHttpStreamHeadersHandler handler);
    private void DecodeInternal(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    private void ParseDynamicTableSizeUpdate(ReadOnlySpan`1<byte> data, Int32& currentIndex);
    private void ParseHeaderValueLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameLengthContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValueLengthContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderFieldIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void Parse(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseLiteralHeaderField(ReadOnlySpan`1<byte> data, Int32& currentIndex, byte b, byte mask, byte indexPrefix, bool index, IHttpStreamHeadersHandler handler);
    private void ParseHeaderName(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void CheckIncompleteHeaderBlock(bool endHeaders);
    private void ProcessHeaderValue(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    public void CompleteDecode();
    private void OnIndexedHeaderField(int index, IHttpStreamHeadersHandler handler);
    private void OnIndexedHeaderName(int index);
    private void OnStringLength(int length, State nextState);
    private void OnString(State nextState);
    private void EnsureStringCapacity(Byte[]& dst, int stringLength);
    private bool TryDecodeInteger(ReadOnlySpan`1<byte> data, Int32& currentIndex, Int32& result);
    private static bool IsHuffmanEncoded(byte b);
    private HeaderField& modreq(System.Runtime.InteropServices.InAttribute) GetDynamicHeader(int index);
    private void SetDynamicHeaderTableSize(int size);
    [CompilerGeneratedAttribute]
private int <OnString>g__Decode|57_0(Byte[]& dst);
}
internal class System.Net.Http.HPack.HPackDecodingException : Exception {
    public HPackDecodingException(string message);
    public HPackDecodingException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public HPackDecodingException(SerializationInfo info, StreamingContext context);
}
internal static class System.Net.Http.HPack.HPackEncoder : object {
    public static bool EncodeIndexedHeaderField(int index, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexing(int index, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexing(int index, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexingNewName(string name, ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutIndexingNewName(string name, Span`1<byte> destination, Int32& bytesWritten);
    private static bool EncodeLiteralHeaderName(string value, Span`1<byte> destination, Int32& bytesWritten);
    private static void EncodeValueStringPart(string value, Span`1<byte> destination);
    public static bool EncodeStringLiteral(string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeStringLiterals(ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeLiteralHeaderFieldWithoutIndexingToAllocatedArray(int index);
    public static Byte[] EncodeLiteralHeaderFieldWithoutIndexingNewNameToAllocatedArray(string name);
    public static Byte[] EncodeLiteralHeaderFieldWithoutIndexingToAllocatedArray(int index, string value);
}
internal static class System.Net.Http.HPack.Huffman : object {
    private static UInt16[] s_decodingTree;
    private static ReadOnlySpan`1<UInt32> EncodingTableCodes { get; }
    private static ReadOnlySpan`1<byte> EncodingTableBitLengths { get; }
    private static Huffman();
    private static ReadOnlySpan`1<UInt32> get_EncodingTableCodes();
    private static ReadOnlySpan`1<byte> get_EncodingTableBitLengths();
    private static UInt16[] GenerateDecodingLookupTree();
    public static int Decode(ReadOnlySpan`1<byte> src, Byte[]& dstArray);
}
internal class System.Net.Http.HPack.HuffmanDecodingException : Exception {
    public HuffmanDecodingException(string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private HuffmanDecodingException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.Http.HPack.IntegerDecoder : ValueType {
    private int _i;
    private int _m;
    public bool BeginTryDecode(byte b, int prefixLength, Int32& result);
    public bool TryDecode(byte b, Int32& result);
}
internal static class System.Net.Http.HPack.IntegerEncoder : object {
    public static bool Encode(int value, int numBits, Span`1<byte> destination, Int32& bytesWritten);
    private static byte MaskHigh(int n);
}
internal class System.Net.Http.Http2Connection : HttpConnectionBase {
    private static TaskCompletionSourceWithCancellation`1<bool> s_settingsReceivedSingleton;
    private TaskCompletionSourceWithCancellation`1<bool> _initialSettingsReceived;
    private HttpConnectionPool _pool;
    private Stream _stream;
    private ArrayBuffer _incomingBuffer;
    private ArrayBuffer _outgoingBuffer;
    [ThreadStaticAttribute]
private static String[] t_headerValues;
    private HPackDecoder _hpackDecoder;
    private Dictionary`2<int, Http2Stream> _httpStreams;
    private CreditManager _connectionWindow;
    private RttEstimator _rttEstimator;
    private int _nextStream;
    private bool _receivedSettingsAck;
    private int _initialServerStreamWindowSize;
    private int _pendingWindowUpdate;
    private UInt32 _maxConcurrentStreams;
    private UInt32 _streamsInUse;
    private TaskCompletionSource`1<bool> _availableStreamsWaiter;
    private Channel`1<WriteQueueEntry> _writeChannel;
    private bool _lastPendingWriterShouldFlush;
    private UInt32 _maxHeaderListSize;
    private bool _shutdown;
    private Exception _abortException;
    private static UnboundedChannelOptions s_channelOptions;
    private long _keepAlivePingDelay;
    private long _keepAlivePingTimeout;
    private HttpKeepAlivePingPolicy _keepAlivePingPolicy;
    private long _keepAlivePingPayload;
    private long _nextPingRequestTimestamp;
    private long _keepAlivePingTimeoutTimestamp;
    private KeepAliveState modreq(System.Runtime.CompilerServices.IsVolatile) _keepAliveState;
    [CompilerGeneratedAttribute]
private bool <IsConnectEnabled>k__BackingField;
    private static ReadOnlySpan`1<byte> ProtocolLiteralHeaderBytes { get; }
    private static ReadOnlySpan`1<byte> Http2ConnectionPreface { get; }
    private object SyncObject { get; }
    internal TaskCompletionSourceWithCancellation`1<bool> InitialSettingsReceived { get; }
    internal bool IsConnectEnabled { get; private set; }
    public Http2Connection(HttpConnectionPool pool, Stream stream, IPEndPoint remoteEndPoint);
    private static Http2Connection();
    private static ReadOnlySpan`1<byte> get_ProtocolLiteralHeaderBytes();
    private static ReadOnlySpan`1<byte> get_Http2ConnectionPreface();
    protected virtual override void Finalize();
    private object get_SyncObject();
    internal TaskCompletionSourceWithCancellation`1<bool> get_InitialSettingsReceived();
    [CompilerGeneratedAttribute]
internal bool get_IsConnectEnabled();
    [CompilerGeneratedAttribute]
private void set_IsConnectEnabled(bool value);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<SetupAsync>d__54")]
public ValueTask SetupAsync(CancellationToken cancellationToken);
    private void Shutdown();
    public bool TryReserveStream();
    public void ReleaseStream();
    public Task`1<bool> WaitForAvailableStreamsAsync();
    private void SignalAvailableStreamsWaiter(bool result);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<FlushOutgoingBytesAsync>d__60")]
private Task FlushOutgoingBytesAsync();
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<ReadFrameAsync>d__61")]
private ValueTask`1<FrameHeader> ReadFrameAsync(bool initialFrame);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<ProcessIncomingFramesAsync>d__62")]
private Task ProcessIncomingFramesAsync();
    private Http2Stream GetStream(int streamId);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<ProcessHeadersFrame>d__64")]
private ValueTask ProcessHeadersFrame(FrameHeader frameHeader);
    private static ReadOnlySpan`1<byte> GetFrameData(ReadOnlySpan`1<byte> frameData, bool hasPad, bool hasPriority);
    private void ProcessAltSvcFrame(FrameHeader frameHeader);
    private void ProcessDataFrame(FrameHeader frameHeader);
    private void ProcessSettingsFrame(FrameHeader frameHeader, bool initialFrame);
    private void ChangeMaxConcurrentStreams(UInt32 newValue);
    private void ChangeInitialWindowSize(int newSize);
    private void ProcessPriorityFrame(FrameHeader frameHeader);
    private void ProcessPingFrame(FrameHeader frameHeader);
    private void ProcessWindowUpdateFrame(FrameHeader frameHeader);
    private void ProcessRstStreamFrame(FrameHeader frameHeader);
    private void ProcessGoAwayFrame(FrameHeader frameHeader);
    private ValueTuple`2<int, Http2ProtocolErrorCode> ReadGoAwayFrame(FrameHeader frameHeader);
    internal Task FlushAsync(CancellationToken cancellationToken);
    private Task PerformWriteAsync(int writeBytes, T state, Func`3<T, Memory`1<byte>, bool> writeAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<ProcessOutgoingFramesAsync>d__82")]
private Task ProcessOutgoingFramesAsync();
    private Task SendSettingsAckAsync();
    private Task SendPingAsync(long pingContent, bool isAck);
    private Task SendRstStreamAsync(int streamId, Http2ProtocolErrorCode errorCode);
    internal void HeartBeat();
    private static ValueTuple`2<ReadOnlyMemory`1<byte>, ReadOnlyMemory`1<byte>> SplitBuffer(ReadOnlyMemory`1<byte> buffer, int maxSize);
    private void WriteIndexedHeader(int index, ArrayBuffer& headerBuffer);
    private void WriteIndexedHeader(int index, string value, ArrayBuffer& headerBuffer);
    private void WriteLiteralHeader(string name, ReadOnlySpan`1<string> values, Encoding valueEncoding, ArrayBuffer& headerBuffer);
    private void WriteLiteralHeaderValues(ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, ArrayBuffer& headerBuffer);
    private void WriteLiteralHeaderValue(string value, Encoding valueEncoding, ArrayBuffer& headerBuffer);
    private void WriteBytes(ReadOnlySpan`1<byte> bytes, ArrayBuffer& headerBuffer);
    private int WriteHeaderCollection(HttpRequestMessage request, HttpHeaders headers, ArrayBuffer& headerBuffer);
    private void WriteHeaders(HttpRequestMessage request, ArrayBuffer& headerBuffer);
    private void AddStream(Http2Stream http2Stream);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<SendHeadersAsync>d__97")]
private ValueTask`1<Http2Stream> SendHeadersAsync(HttpRequestMessage request, CancellationToken cancellationToken, bool mustFlush);
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<SendStreamDataAsync>d__98")]
private Task SendStreamDataAsync(int streamId, ReadOnlyMemory`1<byte> buffer, bool finalFlush, CancellationToken cancellationToken);
    private Task SendEndStreamAsync(int streamId);
    private Task SendWindowUpdateAsync(int streamId, int amount);
    private void ExtendWindow(int amount);
    public virtual long GetIdleTicks(long nowTicks);
    private void Abort(Exception abortException);
    private void FinalTeardown();
    public virtual void Dispose();
    private static TaskCompletionSourceWithCancellation`1<bool> CreateSuccessfullyCompletedTcs();
    [AsyncStateMachineAttribute("System.Net.Http.Http2Connection/<SendAsync>d__111")]
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    private void RemoveStream(Http2Stream http2Stream);
    private void RefreshPingTimestamp();
    private void ProcessPingAck(long payload);
    private void VerifyKeepAlive();
    public sealed virtual string ToString();
    public virtual void Trace(string message, string memberName);
    internal void Trace(int streamId, string message, string memberName);
    [DoesNotReturnAttribute]
private static void ThrowRetry(string message, Exception innerException);
    private static Exception GetRequestAbortedException(Exception innerException);
    [DoesNotReturnAttribute]
private static void ThrowRequestAborted(Exception innerException);
    [DoesNotReturnAttribute]
private static void ThrowProtocolError();
    [DoesNotReturnAttribute]
private static void ThrowProtocolError(Http2ProtocolErrorCode errorCode, string message);
    [CompilerGeneratedAttribute]
internal static long <.ctor>g__TimeSpanToMs|44_0(TimeSpan value);
    [CompilerGeneratedAttribute]
private void <ReadFrameAsync>g__ThrowPrematureEOF|61_0(int requiredBytes);
    [CompilerGeneratedAttribute]
internal static void <ReadFrameAsync>g__ThrowMissingFrame|61_1();
}
internal enum System.Net.Http.Http2ProtocolErrorCode : Enum {
    public int value__;
    public static Http2ProtocolErrorCode NoError;
    public static Http2ProtocolErrorCode ProtocolError;
    public static Http2ProtocolErrorCode InternalError;
    public static Http2ProtocolErrorCode FlowControlError;
    public static Http2ProtocolErrorCode SettingsTimeout;
    public static Http2ProtocolErrorCode StreamClosed;
    public static Http2ProtocolErrorCode FrameSizeError;
    public static Http2ProtocolErrorCode RefusedStream;
    public static Http2ProtocolErrorCode Cancel;
    public static Http2ProtocolErrorCode CompressionError;
    public static Http2ProtocolErrorCode ConnectError;
    public static Http2ProtocolErrorCode EnhanceYourCalm;
    public static Http2ProtocolErrorCode InadequateSecurity;
    public static Http2ProtocolErrorCode Http11Required;
}
[SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("macos")]
internal class System.Net.Http.Http3Connection : HttpConnectionBase {
    private HttpConnectionPool _pool;
    private HttpAuthority _authority;
    private Byte[] _altUsedEncodedHeader;
    private QuicConnection _connection;
    private Task _connectionClosedTask;
    private Dictionary`2<QuicStream, Http3RequestStream> _activeRequests;
    private long _firstRejectedStreamId;
    private QuicStream _clientControl;
    private UInt32 _maxHeaderListSize;
    private int _haveServerControlStream;
    private int _haveServerQpackDecodeStream;
    private int _haveServerQpackEncodeStream;
    private Exception _abortException;
    public HttpAuthority Authority { get; }
    public HttpConnectionPool Pool { get; }
    public UInt32 MaxHeaderListSize { get; }
    public Byte[] AltUsedEncodedHeaderBytes { get; }
    public Exception AbortException { get; }
    private object SyncObj { get; }
    private bool ShuttingDown { get; }
    public Http3Connection(HttpConnectionPool pool, HttpAuthority authority, QuicConnection connection, bool includeAltUsedHeader);
    public HttpAuthority get_Authority();
    public HttpConnectionPool get_Pool();
    public UInt32 get_MaxHeaderListSize();
    public Byte[] get_AltUsedEncodedHeaderBytes();
    public Exception get_AbortException();
    private object get_SyncObj();
    private bool get_ShuttingDown();
    public virtual void Dispose();
    private void CheckForShutdown();
    [AsyncStateMachineAttribute("System.Net.Http.Http3Connection/<SendAsync>d__30")]
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, long queueStartingTimestamp, CancellationToken cancellationToken);
    internal Exception Abort(Exception abortException);
    private void OnServerGoAway(long firstRejectedStreamId);
    public void RemoveStream(QuicStream stream);
    public virtual long GetIdleTicks(long nowTicks);
    public virtual void Trace(string message, string memberName);
    internal void Trace(long streamId, string message, string memberName);
    [AsyncStateMachineAttribute("System.Net.Http.Http3Connection/<SendSettingsAsync>d__37")]
private Task SendSettingsAsync();
    public static Byte[] BuildSettingsFrame(HttpConnectionSettings settings);
    [AsyncStateMachineAttribute("System.Net.Http.Http3Connection/<AcceptStreamsAsync>d__39")]
private Task AcceptStreamsAsync();
    [AsyncStateMachineAttribute("System.Net.Http.Http3Connection/<ProcessServerStreamAsync>d__40")]
private Task ProcessServerStreamAsync(QuicStream stream);
    [AsyncStateMachineAttribute("System.Net.Http.Http3Connection/<ProcessServerControlStreamAsync>d__41")]
private Task ProcessServerControlStreamAsync(QuicStream stream, ArrayBuffer buffer);
    [CompilerGeneratedAttribute]
private void <SendSettingsAsync>b__37_0(Task t);
}
internal enum System.Net.Http.Http3ErrorCode : Enum {
    public long value__;
    public static Http3ErrorCode NoError;
    public static Http3ErrorCode ProtocolError;
    public static Http3ErrorCode InternalError;
    public static Http3ErrorCode StreamCreationError;
    public static Http3ErrorCode ClosedCriticalStream;
    public static Http3ErrorCode UnexpectedFrame;
    public static Http3ErrorCode FrameError;
    public static Http3ErrorCode ExcessiveLoad;
    public static Http3ErrorCode IdError;
    public static Http3ErrorCode SettingsError;
    public static Http3ErrorCode MissingSettings;
    public static Http3ErrorCode RequestRejected;
    public static Http3ErrorCode RequestCancelled;
    public static Http3ErrorCode RequestIncomplete;
    public static Http3ErrorCode MessageError;
    public static Http3ErrorCode ConnectError;
    public static Http3ErrorCode VersionFallback;
}
internal static class System.Net.Http.Http3Frame : object {
    public static bool TryReadIntegerPair(ReadOnlySpan`1<byte> buffer, Int64& a, Int64& b, Int32& bytesRead);
    public static bool TryWriteFrameEnvelope(Http3FrameType frameType, long payloadLength, Span`1<byte> buffer, Int32& bytesWritten);
}
internal enum System.Net.Http.Http3FrameType : Enum {
    public long value__;
    public static Http3FrameType Data;
    public static Http3FrameType Headers;
    public static Http3FrameType ReservedHttp2Priority;
    public static Http3FrameType CancelPush;
    public static Http3FrameType Settings;
    public static Http3FrameType PushPromise;
    public static Http3FrameType ReservedHttp2Ping;
    public static Http3FrameType GoAway;
    public static Http3FrameType ReservedHttp2WindowUpdate;
    public static Http3FrameType ReservedHttp2Continuation;
    public static Http3FrameType MaxPushId;
}
[SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("macos")]
internal class System.Net.Http.Http3RequestStream : object {
    private HttpRequestMessage _request;
    private Http3Connection _connection;
    private long _streamId;
    private QuicStream _stream;
    private ArrayBuffer _sendBuffer;
    private ArrayBuffer _recvBuffer;
    private TaskCompletionSource`1<bool> _expect100ContinueCompletionSource;
    private bool _disposed;
    private CancellationTokenSource _requestBodyCancellationSource;
    private HttpResponseMessage _response;
    private QPackDecoder _headerDecoder;
    private HeaderState _headerState;
    private int _headerBudgetRemaining;
    private String[] _headerValues;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<HeaderDescriptor, string>> _trailingHeaders;
    private long _responseDataPayloadRemaining;
    private long _requestContentLengthRemaining;
    private bool _singleDataFrameWritten;
    private bool _requestSendCompleted;
    private bool _responseRecvCompleted;
    public long StreamId { get; public set; }
    public Http3RequestStream(HttpRequestMessage request, Http3Connection connection, QuicStream stream);
    public long get_StreamId();
    public void set_StreamId(long value);
    public sealed virtual void Dispose();
    private void RemoveFromConnectionIfDone();
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<DisposeAsync>d__26")]
public sealed virtual ValueTask DisposeAsync();
    private void DisposeSyncHelper();
    public void GoAway();
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<SendAsync>d__29")]
public Task`1<HttpResponseMessage> SendAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<ReadResponseAsync>d__30")]
private Task ReadResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<SendContentAsync>d__31")]
private Task SendContentAsync(HttpContent content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<WriteRequestContentAsync>d__32")]
private ValueTask WriteRequestContentAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<FlushSendBufferAsync>d__33")]
private ValueTask FlushSendBufferAsync(bool endStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<DrainContentLength0Frames>d__34")]
private ValueTask DrainContentLength0Frames(CancellationToken cancellationToken);
    private void CopyTrailersToResponseMessage(HttpResponseMessage responseMessage);
    private void BufferHeaders(HttpRequestMessage request);
    private int BufferHeaderCollection(HttpHeaders headers);
    private void BufferIndexedHeader(int index);
    private void BufferLiteralHeaderWithStaticNameReference(int nameIndex, string value, Encoding valueEncoding);
    private void BufferLiteralHeaderWithoutNameReference(string name, ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding);
    private void BufferLiteralHeaderWithoutNameReference(string name, string value, Encoding valueEncoding);
    private void BufferLiteralHeaderValues(ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding);
    private void BufferFrameEnvelope(Http3FrameType frameType, long payloadLength);
    private void BufferBytes(ReadOnlySpan`1<byte> span);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<ReadFrameEnvelopeAsync>d__45")]
private ValueTask`1<ValueTuple`2<Nullable`1<Http3FrameType>, long>> ReadFrameEnvelopeAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<ReadHeadersAsync>d__46")]
private ValueTask ReadHeadersAsync(long headersLength, CancellationToken cancellationToken);
    private sealed virtual override void System.Net.Http.IHttpStreamHeadersHandler.OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private sealed virtual override void System.Net.Http.IHttpStreamHeadersHandler.OnStaticIndexedHeader(int index);
    private sealed virtual override void System.Net.Http.IHttpStreamHeadersHandler.OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
    private sealed virtual override void System.Net.Http.IHttpStreamHeadersHandler.OnDynamicIndexedHeader(Nullable`1<int> index, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    private void GetStaticQPackHeader(int index, HeaderDescriptor& descriptor, String& knownValue);
    private void OnHeader(Nullable`1<int> staticIndex, HeaderDescriptor descriptor, string staticValue, ReadOnlySpan`1<byte> literalValue);
    private sealed virtual override void System.Net.Http.IHttpStreamHeadersHandler.OnHeadersComplete(bool endStream);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<SkipUnknownPayloadAsync>d__54")]
private ValueTask SkipUnknownPayloadAsync(long payloadLength, CancellationToken cancellationToken);
    private int ReadResponseContent(HttpResponseMessage response, Span`1<byte> buffer);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<ReadResponseContentAsync>d__56")]
private ValueTask`1<int> ReadResponseContentAsync(HttpResponseMessage response, Memory`1<byte> buffer, CancellationToken cancellationToken);
    [DoesNotReturnAttribute]
private void HandleReadResponseContentException(Exception ex, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Http3RequestStream/<ReadNextDataFrameAsync>d__58")]
private ValueTask`1<bool> ReadNextDataFrameAsync(HttpResponseMessage response, CancellationToken cancellationToken);
    public void Trace(string message, string memberName);
    private void AbortStream();
    [CompilerGeneratedAttribute]
private int <OnHeader>g__ParseStatusCode|52_0(Nullable`1<int> index, string value);
}
internal enum System.Net.Http.Http3SettingType : Enum {
    public long value__;
    public static Http3SettingType QPackMaxTableCapacity;
    public static Http3SettingType ReservedHttp2EnablePush;
    public static Http3SettingType ReservedHttp2MaxConcurrentStreams;
    public static Http3SettingType ReservedHttp2InitialWindowSize;
    public static Http3SettingType ReservedHttp2MaxFrameSize;
    public static Http3SettingType MaxHeaderListSize;
    public static Http3SettingType QPackBlockedStreams;
    public static Http3SettingType EnableWebTransport;
    public static Http3SettingType H3Datagram;
}
internal class System.Net.Http.HttpAuthenticatedConnectionHandler : HttpMessageHandlerStage {
    private HttpConnectionPoolManager _poolManager;
    public HttpAuthenticatedConnectionHandler(HttpConnectionPoolManager poolManager);
    internal virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal class System.Net.Http.HttpAuthority : object {
    [CompilerGeneratedAttribute]
private string <IdnHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostValue>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    public string IdnHost { get; }
    public string HostValue { get; }
    public int Port { get; }
    public HttpAuthority(string host, int port);
    [CompilerGeneratedAttribute]
public string get_IdnHost();
    [CompilerGeneratedAttribute]
public string get_HostValue();
    [CompilerGeneratedAttribute]
public int get_Port();
    public sealed virtual bool Equals(HttpAuthority other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal abstract class System.Net.Http.HttpBaseStream : Stream {
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanSeek();
    public sealed virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public sealed virtual int EndRead(IAsyncResult asyncResult);
    public sealed virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public sealed virtual void EndWrite(IAsyncResult asyncResult);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public sealed virtual int ReadByte();
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public sealed virtual void WriteByte(byte value);
    public sealed virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected static Task NopAsync(CancellationToken cancellationToken);
    public abstract virtual int Read(Span`1<byte> buffer);
    public abstract virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public abstract virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpClient : HttpMessageInvoker {
    private static IWebProxy s_defaultProxy;
    private static TimeSpan s_defaultTimeout;
    private static TimeSpan s_maxTimeout;
    private static TimeSpan s_infiniteTimeout;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _operationStarted;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private CancellationTokenSource _pendingRequestsCts;
    private HttpRequestHeaders _defaultRequestHeaders;
    private Version _defaultRequestVersion;
    private HttpVersionPolicy _defaultVersionPolicy;
    private Uri _baseAddress;
    private TimeSpan _timeout;
    private int _maxResponseContentBufferSize;
    public static IWebProxy DefaultProxy { get; public set; }
    public HttpRequestHeaders DefaultRequestHeaders { get; }
    public Version DefaultRequestVersion { get; public set; }
    public HttpVersionPolicy DefaultVersionPolicy { get; public set; }
    [NullableAttribute("2")]
public Uri BaseAddress { get; public set; }
    public TimeSpan Timeout { get; public set; }
    public long MaxResponseContentBufferSize { get; public set; }
    public HttpClient(HttpMessageHandler handler);
    public HttpClient(HttpMessageHandler handler, bool disposeHandler);
    private static HttpClient();
    public static IWebProxy get_DefaultProxy();
    public static void set_DefaultProxy(IWebProxy value);
    public HttpRequestHeaders get_DefaultRequestHeaders();
    public Version get_DefaultRequestVersion();
    public void set_DefaultRequestVersion(Version value);
    public HttpVersionPolicy get_DefaultVersionPolicy();
    public void set_DefaultVersionPolicy(HttpVersionPolicy value);
    [NullableContextAttribute("2")]
public Uri get_BaseAddress();
    [NullableContextAttribute("2")]
public void set_BaseAddress(Uri value);
    public TimeSpan get_Timeout();
    public void set_Timeout(TimeSpan value);
    public long get_MaxResponseContentBufferSize();
    public void set_MaxResponseContentBufferSize(long value);
    public Task`1<string> GetStringAsync(string requestUri);
    public Task`1<string> GetStringAsync(Uri requestUri);
    public Task`1<string> GetStringAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<string> GetStringAsync(Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetStringAsyncCore>d__41")]
private Task`1<string> GetStringAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken);
    public Task`1<Byte[]> GetByteArrayAsync(string requestUri);
    public Task`1<Byte[]> GetByteArrayAsync(Uri requestUri);
    public Task`1<Byte[]> GetByteArrayAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<Byte[]> GetByteArrayAsync(Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetByteArrayAsyncCore>d__46")]
private Task`1<Byte[]> GetByteArrayAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken);
    public Task`1<Stream> GetStreamAsync(string requestUri);
    public Task`1<Stream> GetStreamAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<Stream> GetStreamAsync(Uri requestUri);
    public Task`1<Stream> GetStreamAsync(Uri requestUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<GetStreamAsyncCore>d__51")]
private Task`1<Stream> GetStreamAsyncCore(HttpRequestMessage request, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(string requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> GetAsync(Uri requestUri, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PostAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PostAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PutAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PutAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PatchAsync(string requestUri, HttpContent content, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<HttpResponseMessage> PatchAsync(Uri requestUri, HttpContent content, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri);
    public Task`1<HttpResponseMessage> DeleteAsync(string requestUri, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> DeleteAsync(Uri requestUri, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public HttpResponseMessage Send(HttpRequestMessage request);
    [UnsupportedOSPlatformAttribute("browser")]
public HttpResponseMessage Send(HttpRequestMessage request, HttpCompletionOption completionOption);
    [UnsupportedOSPlatformAttribute("browser")]
public virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public HttpResponseMessage Send(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption);
    public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationToken cancellationToken);
    private void CheckRequestBeforeSend(HttpRequestMessage request);
    private static void ThrowForNullResponse(HttpResponseMessage response);
    private static bool ShouldBufferResponse(HttpCompletionOption completionOption, HttpRequestMessage request);
    private void HandleFailure(Exception e, bool telemetryStarted, HttpResponseMessage response, CancellationTokenSource cts, CancellationToken cancellationToken, CancellationTokenSource pendingRequestsCts);
    private static bool StartSend(HttpRequestMessage request);
    private static void FinishSend(HttpResponseMessage response, CancellationTokenSource cts, bool disposeCts, bool telemetryStarted, bool responseContentTelemetryStarted);
    public void CancelPendingRequests();
    protected virtual void Dispose(bool disposing);
    private void SetOperationStarted();
    private void CheckDisposedOrStarted();
    private static void CheckRequestMessage(HttpRequestMessage request);
    private void PrepareRequestMessage(HttpRequestMessage request);
    private ValueTuple`3<CancellationTokenSource, bool, CancellationTokenSource> PrepareCancellationTokenSource(CancellationToken cancellationToken);
    private static Uri CreateUri(string uri);
    private HttpRequestMessage CreateRequestMessage(HttpMethod method, Uri uri);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<HttpResponseMessage> <>n__0(HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpClient/<<SendAsync>g__Core|83_0>d")]
[CompilerGeneratedAttribute]
private Task`1<HttpResponseMessage> <SendAsync>g__Core|83_0(HttpRequestMessage request, HttpCompletionOption completionOption, CancellationTokenSource cts, bool disposeCts, CancellationTokenSource pendingRequestsCts, CancellationToken originalCancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Http.HttpClientHandler : HttpMessageHandler {
    private SocketsHttpHandler _underlyingHandler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> s_dangerousAcceptAnyServerCertificateValidator;
    [NullableAttribute("1")]
private SocketsHttpHandler Handler { get; }
    public bool SupportsAutomaticDecompression { get; }
    public bool SupportsProxy { get; }
    public bool SupportsRedirectConfiguration { get; }
    [CLSCompliantAttribute("False")]
public IMeterFactory MeterFactory { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public bool UseCookies { get; public set; }
    [NullableAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public CookieContainer CookieContainer { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public DecompressionMethods AutomaticDecompression { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public bool UseProxy { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public IWebProxy Proxy { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public ICredentials DefaultProxyCredentials { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public bool PreAuthenticate { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public bool UseDefaultCredentials { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public ICredentials Credentials { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public int MaxAutomaticRedirections { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public int MaxConnectionsPerServer { get; public set; }
    public long MaxRequestContentBufferSize { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public int MaxResponseHeadersLength { get; public set; }
    public ClientCertificateOption ClientCertificateOptions { get; public set; }
    [NullableAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
public X509CertificateCollection ClientCertificates { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[UnsupportedOSPlatformAttribute("browser")]
public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> ServerCertificateCustomValidationCallback { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public bool CheckCertificateRevocationList { get; public set; }
    [UnsupportedOSPlatformAttribute("browser")]
public SslProtocols SslProtocols { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> Properties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[UnsupportedOSPlatformAttribute("browser")]
public static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> DangerousAcceptAnyServerCertificateValidator { get; }
    private SocketsHttpHandler get_Handler();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_SupportsAutomaticDecompression();
    public virtual bool get_SupportsProxy();
    public virtual bool get_SupportsRedirectConfiguration();
    public IMeterFactory get_MeterFactory();
    public void set_MeterFactory(IMeterFactory value);
    public bool get_UseCookies();
    public void set_UseCookies(bool value);
    [NullableContextAttribute("1")]
public CookieContainer get_CookieContainer();
    [NullableContextAttribute("1")]
public void set_CookieContainer(CookieContainer value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public bool get_UseProxy();
    public void set_UseProxy(bool value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public ICredentials get_DefaultProxyCredentials();
    public void set_DefaultProxyCredentials(ICredentials value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public int get_MaxAutomaticRedirections();
    public void set_MaxAutomaticRedirections(int value);
    public int get_MaxConnectionsPerServer();
    public void set_MaxConnectionsPerServer(int value);
    public long get_MaxRequestContentBufferSize();
    public void set_MaxRequestContentBufferSize(long value);
    public int get_MaxResponseHeadersLength();
    public void set_MaxResponseHeadersLength(int value);
    public ClientCertificateOption get_ClientCertificateOptions();
    public void set_ClientCertificateOptions(ClientCertificateOption value);
    [NullableContextAttribute("1")]
public X509CertificateCollection get_ClientCertificates();
    public Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_ServerCertificateCustomValidationCallback();
    public void set_ServerCertificateCustomValidationCallback(Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> value);
    public bool get_CheckCertificateRevocationList();
    public void set_CheckCertificateRevocationList(bool value);
    public SslProtocols get_SslProtocols();
    public void set_SslProtocols(SslProtocols value);
    public IDictionary`2<string, object> get_Properties();
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("browser")]
protected internal virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    public static Func`5<HttpRequestMessage, X509Certificate2, X509Chain, SslPolicyErrors, bool> get_DangerousAcceptAnyServerCertificateValidator();
    private void ThrowForModifiedManagedSslOptionsIfStarted();
    [CompilerGeneratedAttribute]
private X509Certificate <set_ClientCertificateOptions>b__59_0(object sender, string targetHost, X509CertificateCollection localCertificates, X509Certificate remoteCertificate, String[] acceptableIssuers);
}
public enum System.Net.Http.HttpCompletionOption : Enum {
    public int value__;
    public static HttpCompletionOption ResponseContentRead;
    public static HttpCompletionOption ResponseHeadersRead;
}
internal class System.Net.Http.HttpConnection : HttpConnectionBase {
    private static ulong s_http10Bytes;
    private static ulong s_http11Bytes;
    private HttpConnectionPool _pool;
    internal Stream _stream;
    private TransportContext _transportContext;
    private HttpRequestMessage _currentRequest;
    private ArrayBuffer _writeBuffer;
    private int _allowedReadLineBytes;
    [ThreadStaticAttribute]
private static String[] t_headerValues;
    private int _readAheadTaskStatus;
    private ValueTask`1<int> _readAheadTask;
    private ArrayBuffer _readBuffer;
    private int _keepAliveTimeoutSeconds;
    private bool _inUse;
    private bool _detachedFromPool;
    private bool _canRetry;
    private bool _connectionClose;
    private int _disposed;
    private bool ReadAheadTaskHasStarted { get; }
    public TransportContext TransportContext { get; }
    public HttpConnectionKind Kind { get; }
    private int ReadBufferSize { get; }
    private ReadOnlyMemory`1<byte> RemainingBuffer { get; }
    public HttpConnection(HttpConnectionPool pool, Stream stream, TransportContext transportContext, IPEndPoint remoteEndPoint);
    private static HttpConnection();
    protected virtual override void Finalize();
    public virtual void Dispose();
    private void Dispose(bool disposing);
    public bool PrepareForReuse(bool async);
    public virtual bool CheckUsabilityOnScavenge();
    private bool get_ReadAheadTaskHasStarted();
    private bool TryOwnReadAheadTaskCompletion();
    private void EnsureReadAheadTaskHasStarted();
    private bool CheckKeepAliveTimeoutExceeded();
    public TransportContext get_TransportContext();
    public HttpConnectionKind get_Kind();
    private int get_ReadBufferSize();
    private ReadOnlyMemory`1<byte> get_RemainingBuffer();
    private void ConsumeFromRemainingBuffer(int bytesToConsume);
    private void WriteHeaders(HttpRequestMessage request, HttpMethod normalizedMethod);
    private void WriteHeaderCollection(HttpHeaders headers, string cookiesFromContainer);
    private void WriteCRLF();
    private void WriteBytes(ReadOnlySpan`1<byte> bytes);
    private void WriteAsciiString(string s);
    private void WriteString(string s, Encoding encoding);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<SendAsync>d__57")]
public Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    private bool MapSendException(Exception exception, CancellationToken cancellationToken, Exception& mappedException);
    private HttpContentWriteStream CreateRequestContentStream(HttpRequestMessage request);
    private CancellationTokenRegistration RegisterCancellation(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<SendRequestContentAsync>d__61")]
private ValueTask SendRequestContentAsync(HttpRequestMessage request, HttpContentWriteStream stream, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<SendRequestContentWithExpect100ContinueAsync>d__62")]
private Task SendRequestContentWithExpect100ContinueAsync(HttpRequestMessage request, Task`1<bool> allowExpect100ToContinueTask, HttpContentWriteStream stream, Timer expect100Timer, bool async, CancellationToken cancellationToken);
    private bool ParseStatusLine(HttpResponseMessage response);
    private static void ParseStatusLineCore(Span`1<byte> line, HttpResponseMessage response);
    private bool ParseHeaders(HttpResponseMessage response, bool isFromTrailer);
    private ValueTuple`2<bool, int> ParseHeadersCore(Span`1<byte> buffer, HttpResponseMessage response, bool isFromTrailer);
    private void AddResponseHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value, HttpResponseMessage response, bool isFromTrailer);
    private void ThrowExceededAllowedReadLineBytes();
    private void ProcessKeepAliveHeader(string keepAlive);
    private void WriteToBuffer(ReadOnlySpan`1<byte> source);
    private void Write(ReadOnlySpan`1<byte> source);
    private ValueTask WriteAsync(ReadOnlyMemory`1<byte> source);
    private void WriteWithoutBuffering(ReadOnlySpan`1<byte> source);
    private ValueTask WriteWithoutBufferingAsync(ReadOnlyMemory`1<byte> source, bool async);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<FlushThenWriteWithoutBufferingAsync>d__75")]
private ValueTask FlushThenWriteWithoutBufferingAsync(ReadOnlyMemory`1<byte> source, bool async);
    private ValueTask WriteHexInt32Async(int value, bool async);
    private void Flush();
    private ValueTask FlushAsync(bool async);
    private void WriteToStream(ReadOnlySpan`1<byte> source);
    private ValueTask WriteToStreamAsync(ReadOnlyMemory`1<byte> source, bool async);
    private bool TryReadNextChunkedLine(ReadOnlySpan`1& line);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<InitialFillAsync>d__82")]
private ValueTask InitialFillAsync(bool async);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<FillAsync>d__83")]
private ValueTask FillAsync(bool async);
    private ValueTask FillForHeadersAsync(bool async);
    private int ReadFromBuffer(Span`1<byte> buffer);
    private int Read(Span`1<byte> destination);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<ReadAsync>d__87")]
private ValueTask`1<int> ReadAsync(Memory`1<byte> destination);
    private int ReadBuffered(Span`1<byte> destination);
    private ValueTask`1<int> ReadBufferedAsync(Memory`1<byte> destination);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<ReadBufferedAsyncCore>d__90")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> ReadBufferedAsyncCore(Memory`1<byte> destination);
    private ValueTask CopyFromBufferAsync(Stream destination, bool async, int count, CancellationToken cancellationToken);
    private Task CopyToUntilEofAsync(Stream destination, bool async, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<CopyToUntilEofWithExistingBufferedDataAsync>d__93")]
private Task CopyToUntilEofWithExistingBufferedDataAsync(Stream destination, bool async, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<CopyToContentLengthAsync>d__94")]
private Task CopyToContentLengthAsync(Stream destination, bool async, ulong length, int bufferSize, CancellationToken cancellationToken);
    internal void Acquire();
    internal void Release();
    internal void DetachFromPool();
    private void CompleteResponse();
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<DrainResponseAsync>d__99")]
public ValueTask DrainResponseAsync(HttpResponseMessage response, CancellationToken cancellationToken);
    private void ReturnConnectionToPool();
    public sealed virtual string ToString();
    public sealed virtual void Trace(string message, string memberName);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<<EnsureReadAheadTaskHasStarted>g__ReadAheadWithZeroByteReadAsync|40_0>d")]
[CompilerGeneratedAttribute]
private ValueTask`1<int> <EnsureReadAheadTaskHasStarted>g__ReadAheadWithZeroByteReadAsync|40_0();
    [CompilerGeneratedAttribute]
private void <WriteHeaders>g__WriteHost|51_0(Uri requestUri);
    [CompilerGeneratedAttribute]
internal static void <WriteString>g__ThrowForInvalidCharEncoding|56_0();
    [CompilerGeneratedAttribute]
internal static void <ParseHeadersCore>g__ThrowForInvalidHeaderLine|66_0(ReadOnlySpan`1<byte> buffer, int newLineIndex);
    [CompilerGeneratedAttribute]
internal static void <AddResponseHeader>g__ThrowForEmptyHeaderName|67_0();
    [CompilerGeneratedAttribute]
internal static void <AddResponseHeader>g__ThrowForInvalidHeaderName|67_1(ReadOnlySpan`1<byte> name);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<<WriteAsync>g__AwaitFlushAndWriteAsync|72_0>d")]
[CompilerGeneratedAttribute]
private ValueTask <WriteAsync>g__AwaitFlushAndWriteAsync|72_0(ValueTask flushTask, ReadOnlyMemory`1<byte> source);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnection/<<FillForHeadersAsync>g__ReadUntilEndOfHeaderAsync|84_0>d")]
[CompilerGeneratedAttribute]
private ValueTask <FillForHeadersAsync>g__ReadUntilEndOfHeaderAsync|84_0(bool async);
    [CompilerGeneratedAttribute]
internal static bool <FillForHeadersAsync>g__TryFindEndOfLine|84_1(ReadOnlySpan`1<byte> buffer, Int32& searchOffset);
}
internal abstract class System.Net.Http.HttpConnectionBase : object {
    private static long s_connectionCounter;
    private ConnectionMetrics _connectionMetrics;
    private bool _httpTelemetryMarkedConnectionAsOpened;
    private long _creationTickCount;
    private long _idleSinceTickCount;
    private string _lastDateHeaderValue;
    private string _lastServerHeaderValue;
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    public long Id { get; }
    public HttpConnectionBase(HttpConnectionPool pool, IPEndPoint remoteEndPoint);
    private static HttpConnectionBase();
    [CompilerGeneratedAttribute]
public long get_Id();
    public void MarkConnectionAsClosed();
    public void MarkConnectionAsIdle();
    public void MarkConnectionAsNotIdle();
    public string GetResponseHeaderValueWithCaching(HeaderDescriptor descriptor, ReadOnlySpan`1<byte> value, Encoding valueEncoding);
    public abstract virtual void Trace(string message, string memberName);
    protected void TraceConnection(Stream stream);
    public long GetLifetimeTicks(long nowTicks);
    public virtual long GetIdleTicks(long nowTicks);
    public virtual bool CheckUsabilityOnScavenge();
    internal static bool IsDigit(byte c);
    internal static int ParseStatusCode(ReadOnlySpan`1<byte> value);
    internal void LogExceptions(Task task);
    public abstract virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static string <GetResponseHeaderValueWithCaching>g__GetOrAddCachedValue|14_0(String& cache, HeaderDescriptor descriptor, ReadOnlySpan`1<byte> value, Encoding encoding);
    [CompilerGeneratedAttribute]
internal static void <LogExceptions>g__LogFaulted|23_1(HttpConnectionBase connection, Task task);
}
internal class System.Net.Http.HttpConnectionHandler : HttpMessageHandlerStage {
    private HttpConnectionPoolManager _poolManager;
    public HttpConnectionHandler(HttpConnectionPoolManager poolManager);
    internal virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
internal enum System.Net.Http.HttpConnectionKind : Enum {
    public byte value__;
    public static HttpConnectionKind Http;
    public static HttpConnectionKind Https;
    public static HttpConnectionKind Proxy;
    public static HttpConnectionKind ProxyTunnel;
    public static HttpConnectionKind SslProxyTunnel;
    public static HttpConnectionKind ProxyConnect;
    public static HttpConnectionKind SocksTunnel;
    public static HttpConnectionKind SslSocksTunnel;
}
internal class System.Net.Http.HttpConnectionPool : object {
    private static bool s_isWindows7Or2008R2;
    private HttpConnectionPoolManager _poolManager;
    private HttpConnectionKind _kind;
    private Uri _proxyUri;
    private HttpAuthority _originAuthority;
    private HttpAuthority modreq(System.Runtime.CompilerServices.IsVolatile) _http3Authority;
    private Timer _authorityExpireTimer;
    private bool _persistAuthority;
    private string _connectTunnelUserAgent;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _altSvcBlocklist;
    private CancellationTokenSource _altSvcBlocklistTimerCancellation;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _altSvcEnabled;
    private List`1<HttpConnection> _availableHttp11Connections;
    private int _maxHttp11Connections;
    private int _associatedHttp11ConnectionCount;
    private int _pendingHttp11ConnectionCount;
    private RequestQueue`1<HttpConnection> _http11RequestQueue;
    private List`1<Http2Connection> _availableHttp2Connections;
    private int _associatedHttp2ConnectionCount;
    private bool _pendingHttp2Connection;
    private RequestQueue`1<Http2Connection> _http2RequestQueue;
    private bool _http2Enabled;
    private Byte[] _http2AltSvcOriginUri;
    internal Byte[] _http2EncodedAuthorityHostHeader;
    private bool _http3Enabled;
    private Http3Connection _http3Connection;
    private SemaphoreSlim _http3ConnectionCreateLock;
    internal Byte[] _http3EncodedAuthorityHostHeader;
    internal UInt32 _lastSeenHttp2MaxHeaderListSize;
    internal UInt32 _lastSeenHttp3MaxHeaderListSize;
    private Byte[] _hostHeaderLineBytes;
    private SslClientAuthenticationOptions _sslOptionsHttp11;
    private SslClientAuthenticationOptions _sslOptionsHttp2;
    private SslClientAuthenticationOptions _sslOptionsHttp2Only;
    private SslClientAuthenticationOptions _sslOptionsHttp3;
    private SslClientAuthenticationOptions _sslOptionsProxy;
    private bool _usedSinceLastCleanup;
    private bool _disposed;
    private static List`1<SslApplicationProtocol> s_http3ApplicationProtocols;
    private static List`1<SslApplicationProtocol> s_http2ApplicationProtocols;
    private static List`1<SslApplicationProtocol> s_http2OnlyApplicationProtocols;
    [CompilerGeneratedAttribute]
private CredentialCache <PreAuthCredentials>k__BackingField;
    public HttpAuthority OriginAuthority { get; }
    public HttpConnectionSettings Settings { get; }
    public HttpConnectionKind Kind { get; }
    public bool IsSecure { get; }
    public Uri ProxyUri { get; }
    public ICredentials ProxyCredentials { get; }
    public Byte[] HostHeaderLineBytes { get; }
    public CredentialCache PreAuthCredentials { get; }
    public bool IsDefaultPort { get; }
    public Byte[] Http2AltSvcOriginUri { get; }
    private bool EnableMultipleHttp2Connections { get; }
    private object SyncObj { get; }
    private bool DoProxyAuth { get; }
    public HttpConnectionPool(HttpConnectionPoolManager poolManager, HttpConnectionKind kind, string host, int port, string sslHostName, Uri proxyUri);
    private static HttpConnectionPool();
    [SupportedOSPlatformGuardAttribute("linux")]
[SupportedOSPlatformGuardAttribute("macOS")]
[SupportedOSPlatformGuardAttribute("Windows")]
internal static bool IsHttp3Supported();
    private static SslClientAuthenticationOptions ConstructSslOptions(HttpConnectionPoolManager poolManager, string sslHostName);
    public HttpAuthority get_OriginAuthority();
    public HttpConnectionSettings get_Settings();
    public HttpConnectionKind get_Kind();
    public bool get_IsSecure();
    public Uri get_ProxyUri();
    public ICredentials get_ProxyCredentials();
    public Byte[] get_HostHeaderLineBytes();
    [CompilerGeneratedAttribute]
public CredentialCache get_PreAuthCredentials();
    public bool get_IsDefaultPort();
    public Byte[] get_Http2AltSvcOriginUri();
    private bool get_EnableMultipleHttp2Connections();
    private object get_SyncObj();
    [DoesNotReturnAttribute]
private static void ThrowGetVersionException(HttpRequestMessage request, int desiredVersion, Exception inner);
    private bool CheckExpirationOnGet(HttpConnectionBase connection);
    private static Exception CreateConnectTimeoutException(OperationCanceledException oce);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<AddHttp11ConnectionAsync>d__79")]
private Task AddHttp11ConnectionAsync(QueueItem<HttpConnection> queueItem);
    private void CheckForHttp11ConnectionInjection();
    private bool TryGetPooledHttp11Connection(HttpRequestMessage request, bool async, HttpConnection& connection, HttpConnectionWaiter`1& waiter);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<HandleHttp11Downgrade>d__82")]
private Task HandleHttp11Downgrade(HttpRequestMessage request, Stream stream, TransportContext transportContext, IPEndPoint remoteEndPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<AddHttp2ConnectionAsync>d__83")]
private Task AddHttp2ConnectionAsync(QueueItem<Http2Connection> queueItem);
    private void CheckForHttp2ConnectionInjection();
    private bool TryGetPooledHttp2Connection(HttpRequestMessage request, Http2Connection& connection, HttpConnectionWaiter`1& waiter);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<GetHttp3ConnectionAsync>d__86")]
[SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("macos")]
private ValueTask`1<Http3Connection> GetHttp3ConnectionAsync(HttpRequestMessage request, HttpAuthority authority, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<TrySendUsingHttp3Async>d__87")]
[SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("macos")]
private ValueTask`1<HttpResponseMessage> TrySendUsingHttp3Async(HttpRequestMessage request, CancellationToken cancellationToken);
    private void ProcessAltSvc(HttpResponseMessage response);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<SendWithVersionDetectionAndRetryAsync>d__89")]
public ValueTask`1<HttpResponseMessage> SendWithVersionDetectionAndRetryAsync(HttpRequestMessage request, bool async, bool doRequestAuth, CancellationToken cancellationToken);
    private void CancelIfNecessary(HttpConnectionWaiter`1<T> waiter, bool requestCancelled);
    internal void HandleAltSvc(IEnumerable`1<string> altSvcHeaderValues, Nullable`1<TimeSpan> responseAge);
    private void ExpireAltSvcAuthority();
    private bool IsAltSvcBlocked(HttpAuthority authority, Exception& reasonException);
    internal void BlocklistAuthority(HttpAuthority badAuthority, Exception exception);
    public void OnNetworkChanged();
    public Task`1<HttpResponseMessage> SendWithNtConnectionAuthAsync(HttpConnection connection, HttpRequestMessage request, bool async, bool doRequestAuth, CancellationToken cancellationToken);
    private bool get_DoProxyAuth();
    public Task`1<HttpResponseMessage> SendWithNtProxyAuthAsync(HttpConnection connection, HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    public ValueTask`1<HttpResponseMessage> SendWithProxyAuthAsync(HttpRequestMessage request, bool async, bool doRequestAuth, CancellationToken cancellationToken);
    public ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, bool doRequestAuth, CancellationToken cancellationToken);
    private CancellationTokenSource GetConnectTimeoutCancellationTokenSource();
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<ConnectAsync>d__103")]
private ValueTask`1<ValueTuple`3<Stream, TransportContext, IPEndPoint>> ConnectAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<ConnectToTcpHostAsync>d__104")]
private ValueTask`1<Stream> ConnectToTcpHostAsync(string host, int port, HttpRequestMessage initialRequest, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<CreateHttp11ConnectionAsync>d__105")]
internal ValueTask`1<HttpConnection> CreateHttp11ConnectionAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    private SslClientAuthenticationOptions GetSslOptionsForRequest(HttpRequestMessage request);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<ApplyPlaintextFilterAsync>d__107")]
private ValueTask`1<Stream> ApplyPlaintextFilterAsync(bool async, Stream stream, Version httpVersion, HttpRequestMessage request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<ConstructHttp11ConnectionAsync>d__108")]
private ValueTask`1<HttpConnection> ConstructHttp11ConnectionAsync(bool async, Stream stream, TransportContext transportContext, HttpRequestMessage request, IPEndPoint remoteEndPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<ConstructHttp2ConnectionAsync>d__109")]
private ValueTask`1<Http2Connection> ConstructHttp2ConnectionAsync(Stream stream, HttpRequestMessage request, IPEndPoint remoteEndPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<EstablishProxyTunnelAsync>d__110")]
private ValueTask`1<Stream> EstablishProxyTunnelAsync(bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<EstablishSocksTunnel>d__111")]
private ValueTask`1<Stream> EstablishSocksTunnel(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    private void HandleHttp11ConnectionFailure(HttpConnectionWaiter`1<HttpConnection> requestWaiter, Exception e);
    private void HandleHttp2ConnectionFailure(HttpConnectionWaiter`1<Http2Connection> requestWaiter, Exception e);
    public void InvalidateHttp11Connection(HttpConnection connection, bool disposing);
    public void InvalidateHttp2Connection(Http2Connection connection);
    private bool CheckExpirationOnReturn(HttpConnectionBase connection);
    public void RecycleHttp11Connection(HttpConnection connection);
    private void ReturnHttp11Connection(HttpConnection connection, bool isNewConnection, HttpConnectionWaiter`1<HttpConnection> initialRequestWaiter);
    private void ReturnHttp2Connection(Http2Connection connection, bool isNewConnection, HttpConnectionWaiter`1<Http2Connection> initialRequestWaiter);
    private void DisableHttp2Connection(Http2Connection connection);
    public void InvalidateHttp3Connection(Http3Connection connection);
    public sealed virtual void Dispose();
    public bool CleanCacheAndDisposeIfUnused();
    private static bool GetIsWindows7Or2008R2();
    internal void HeartBeat();
    public virtual string ToString();
    private void Trace(string message, string memberName);
    [CompilerGeneratedAttribute]
internal static IPEndPoint <ConnectAsync>g__GetRemoteEndPoint|103_0(Stream stream);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPool/<<DisableHttp2Connection>g__DisableHttp2ConnectionAsync|120_0>d")]
[CompilerGeneratedAttribute]
private Task <DisableHttp2Connection>g__DisableHttp2ConnectionAsync|120_0(Http2Connection connection);
    [CompilerGeneratedAttribute]
internal static int <CleanCacheAndDisposeIfUnused>g__ScavengeConnectionList|123_1(List`1<T> list, List`1& toDispose, long nowTicks, TimeSpan pooledConnectionLifetime, TimeSpan pooledConnectionIdleTimeout);
    [CompilerGeneratedAttribute]
internal static bool <CleanCacheAndDisposeIfUnused>g__IsUsableConnection|123_2(HttpConnectionBase connection, long nowTicks, TimeSpan pooledConnectionLifetime, TimeSpan pooledConnectionIdleTimeout);
}
internal class System.Net.Http.HttpConnectionPoolManager : object {
    private TimeSpan _cleanPoolTimeout;
    private ConcurrentDictionary`2<HttpConnectionKey, HttpConnectionPool> _pools;
    private Timer _cleaningTimer;
    private Timer _heartBeatTimer;
    private HttpConnectionSettings _settings;
    private IWebProxy _proxy;
    private ICredentials _proxyCredentials;
    private NetworkChangeCleanup _networkChangeCleanup;
    private bool _timerIsRunning;
    private object SyncObj { get; }
    public HttpConnectionSettings Settings { get; }
    public ICredentials ProxyCredentials { get; }
    public HttpConnectionPoolManager(HttpConnectionSettings settings);
    private object get_SyncObj();
    public void StartMonitoringNetworkChanges();
    public HttpConnectionSettings get_Settings();
    public ICredentials get_ProxyCredentials();
    private static string ParseHostNameFromHeader(string hostHeader);
    private HttpConnectionKey GetConnectionKey(HttpRequestMessage request, Uri proxyUri, bool isProxyConnect);
    public ValueTask`1<HttpResponseMessage> SendAsyncCore(HttpRequestMessage request, Uri proxyUri, bool async, bool doRequestAuth, bool isProxyConnect, CancellationToken cancellationToken);
    public ValueTask`1<HttpResponseMessage> SendProxyConnectAsync(HttpRequestMessage request, Uri proxyUri, bool async, CancellationToken cancellationToken);
    public ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, bool doRequestAuth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionPoolManager/<SendAsyncMultiProxy>d__23")]
private ValueTask`1<HttpResponseMessage> SendAsyncMultiProxy(HttpRequestMessage request, bool async, bool doRequestAuth, MultiProxy multiProxy, Uri firstProxy, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void SetCleaningTimer(TimeSpan timeout);
    private void RemoveStalePools();
    private void HeartBeat();
    private static string GetIdentityIfDefaultCredentialsUsed(bool defaultCredentialsUsed);
}
internal class System.Net.Http.HttpConnectionResponseContent : HttpContent {
    private Stream _stream;
    private bool _consumedStream;
    internal bool AllowDuplex { get; }
    public void SetStream(Stream stream);
    private Stream ConsumeStream();
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected sealed virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected sealed virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected internal sealed virtual bool TryComputeLength(Int64& length);
    protected sealed virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected sealed virtual Task`1<Stream> CreateContentReadStreamAsync();
    internal sealed virtual Stream TryCreateContentReadStream();
    internal virtual bool get_AllowDuplex();
    protected sealed virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Http.HttpConnectionResponseContent/<<SerializeToStreamAsync>g__Impl|6_0>d")]
[CompilerGeneratedAttribute]
private Task <SerializeToStreamAsync>g__Impl|6_0(Stream stream, CancellationToken cancellationToken);
}
internal class System.Net.Http.HttpConnectionSettings : object {
    internal DecompressionMethods _automaticDecompression;
    internal bool _useCookies;
    internal CookieContainer _cookieContainer;
    internal bool _useProxy;
    internal IWebProxy _proxy;
    internal ICredentials _defaultProxyCredentials;
    internal bool _defaultCredentialsUsedForProxy;
    internal bool _defaultCredentialsUsedForServer;
    internal bool _preAuthenticate;
    internal ICredentials _credentials;
    internal bool _allowAutoRedirect;
    internal int _maxAutomaticRedirections;
    internal int _maxConnectionsPerServer;
    internal int _maxResponseDrainSize;
    internal TimeSpan _maxResponseDrainTime;
    internal int _maxResponseHeadersLength;
    internal IMeterFactory _meterFactory;
    internal SocketsHttpHandlerMetrics _metrics;
    internal TimeSpan _pooledConnectionLifetime;
    internal TimeSpan _pooledConnectionIdleTimeout;
    internal TimeSpan _expect100ContinueTimeout;
    internal TimeSpan _keepAlivePingTimeout;
    internal TimeSpan _keepAlivePingDelay;
    internal HttpKeepAlivePingPolicy _keepAlivePingPolicy;
    internal TimeSpan _connectTimeout;
    internal HeaderEncodingSelector`1<HttpRequestMessage> _requestHeaderEncodingSelector;
    internal HeaderEncodingSelector`1<HttpRequestMessage> _responseHeaderEncodingSelector;
    internal DistributedContextPropagator _activityHeadersPropagator;
    internal Version _maxHttpVersion;
    internal SslClientAuthenticationOptions _sslOptions;
    internal bool _enableMultipleHttp2Connections;
    internal Func`3<SocketsHttpConnectionContext, CancellationToken, ValueTask`1<Stream>> _connectCallback;
    internal Func`3<SocketsHttpPlaintextStreamFilterContext, CancellationToken, ValueTask`1<Stream>> _plaintextStreamFilter;
    internal IDictionary`2<string, object> _properties;
    internal int _initialHttp2StreamWindowSize;
    internal ClientCertificateOption _clientCertificateOptions;
    private Byte[] _http3SettingsFrame;
    public int MaxResponseHeadersByteLength { get; }
    public bool EnableMultipleHttp2Connections { get; }
    [SupportedOSPlatformAttribute("windows")]
[SupportedOSPlatformAttribute("linux")]
[SupportedOSPlatformAttribute("macos")]
internal Byte[] Http3SettingsFrame { get; }
    public HttpConnectionSettings CloneAndNormalize();
    public int get_MaxResponseHeadersByteLength();
    public bool get_EnableMultipleHttp2Connections();
    internal Byte[] get_Http3SettingsFrame();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Http.HttpContent : object {
    private HttpContentHeaders _headers;
    private MemoryStream _bufferedContent;
    private object _contentReadStream;
    private bool _disposed;
    private bool _canCalculateLength;
    internal static Encoding DefaultStringEncoding;
    public HttpContentHeaders Headers { get; }
    private bool IsBuffered { get; }
    internal bool AllowDuplex { get; }
    private static HttpContent();
    public HttpContentHeaders get_Headers();
    private bool get_IsBuffered();
    internal bool TryGetBuffer(ArraySegment`1& buffer);
    public Task`1<string> ReadAsStringAsync();
    public Task`1<string> ReadAsStringAsync(CancellationToken cancellationToken);
    private string ReadBufferedContentAsString();
    internal static string ReadBufferAsString(ArraySegment`1<byte> buffer, HttpContentHeaders headers);
    public Task`1<Byte[]> ReadAsByteArrayAsync();
    public Task`1<Byte[]> ReadAsByteArrayAsync(CancellationToken cancellationToken);
    internal Byte[] ReadBufferedContentAsByteArray();
    public Stream ReadAsStream();
    public Stream ReadAsStream(CancellationToken cancellationToken);
    public Task`1<Stream> ReadAsStreamAsync();
    public Task`1<Stream> ReadAsStreamAsync(CancellationToken cancellationToken);
    internal Stream TryReadAsStream();
    protected abstract virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    internal virtual bool get_AllowDuplex();
    public void CopyTo(Stream stream, TransportContext context, CancellationToken cancellationToken);
    public Task CopyToAsync(Stream stream);
    public Task CopyToAsync(Stream stream, CancellationToken cancellationToken);
    public Task CopyToAsync(Stream stream, TransportContext context);
    public Task CopyToAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    internal ValueTask InternalCopyToAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    internal void LoadIntoBuffer(long maxBufferSize, CancellationToken cancellationToken);
    public Task LoadIntoBufferAsync();
    public Task LoadIntoBufferAsync(long maxBufferSize);
    internal Task LoadIntoBufferAsync(CancellationToken cancellationToken);
    internal Task LoadIntoBufferAsync(long maxBufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<LoadIntoBufferAsyncCore>d__63")]
private Task LoadIntoBufferAsyncCore(Task serializeToStreamTask, MemoryStream tempBuffer);
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual Task`1<Stream> CreateContentReadStreamAsync(CancellationToken cancellationToken);
    internal virtual Stream TryCreateContentReadStream();
    protected internal abstract virtual bool TryComputeLength(Int64& length);
    internal Nullable`1<long> GetComputedOrBufferLength();
    private bool CreateTemporaryBuffer(long maxBufferSize, MemoryStream& tempBuffer, Exception& error);
    private LimitMemoryStream CreateMemoryStream(long maxBufferSize, Exception& error);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void CheckDisposed();
    private void CheckTaskNotNull(Task task);
    internal static bool StreamCopyExceptionNeedsWrapping(Exception e);
    private static Exception GetStreamCopyException(Exception originalException);
    internal static Exception WrapStreamCopyException(Exception e);
    private static int GetPreambleLength(ArraySegment`1<byte> buffer, Encoding encoding);
    private static bool TryDetectEncoding(ArraySegment`1<byte> buffer, Encoding& encoding, Int32& preambleLength);
    private static bool BufferHasPrefix(ArraySegment`1<byte> buffer, Byte[] prefix);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<WaitAndReturnAsync>d__82`2")]
private static Task`1<TResult> WaitAndReturnAsync(Task waitTask, TState state, Func`2<TState, TResult> returnFunc);
    private static HttpRequestException CreateOverCapacityException(long maxBufferSize);
    [AsyncStateMachineAttribute("System.Net.Http.HttpContent/<<CopyToAsync>g__WaitAsync|56_0>d")]
[CompilerGeneratedAttribute]
internal static Task <CopyToAsync>g__WaitAsync|56_0(ValueTask copyTask);
}
internal abstract class System.Net.Http.HttpContentStream : HttpBaseStream {
    protected internal HttpConnection _connection;
    public HttpContentStream(HttpConnection connection);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    protected HttpConnection GetConnectionOrThrow();
}
internal class System.Net.Http.HttpEnvironmentProxy : object {
    private Uri _httpProxyUri;
    private Uri _httpsProxyUri;
    private String[] _bypass;
    private ICredentials _credentials;
    public ICredentials Credentials { get; public set; }
    private HttpEnvironmentProxy(Uri httpProxy, Uri httpsProxy, string bypassList);
    private static Uri GetUriFromString(string value);
    private bool IsMatchInBypassList(Uri input);
    public sealed virtual Uri GetProxy(Uri uri);
    public sealed virtual bool IsBypassed(Uri uri);
    public sealed virtual ICredentials get_Credentials();
    public sealed virtual void set_Credentials(ICredentials value);
    public static bool TryCreate(IWebProxy& proxy);
}
internal class System.Net.Http.HttpEnvironmentProxyCredentials : object {
    private NetworkCredential _httpCred;
    private NetworkCredential _httpsCred;
    private Uri _httpProxy;
    private Uri _httpsProxy;
    public HttpEnvironmentProxyCredentials(Uri httpProxy, NetworkCredential httpCred, Uri httpsProxy, NetworkCredential httpsCred);
    public sealed virtual NetworkCredential GetCredential(Uri uri, string authType);
    public static HttpEnvironmentProxyCredentials TryCreate(Uri httpProxy, Uri httpsProxy);
    private static NetworkCredential GetCredentialsFromString(string value);
}
internal static class System.Net.Http.HttpHandlerDefaults : object {
    public static int DefaultMaxConnectionsPerServer;
    public static TimeSpan DefaultKeepAlivePingTimeout;
    public static TimeSpan DefaultKeepAlivePingDelay;
    public static TimeSpan DefaultResponseDrainTimeout;
    public static TimeSpan DefaultPooledConnectionLifetime;
    public static TimeSpan DefaultPooledConnectionIdleTimeout;
    public static TimeSpan DefaultExpect100ContinueTimeout;
    public static TimeSpan DefaultConnectTimeout;
    private static HttpHandlerDefaults();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpIOException : IOException {
    [CompilerGeneratedAttribute]
private HttpRequestError <HttpRequestError>k__BackingField;
    public HttpRequestError HttpRequestError { get; }
    public string Message { get; }
    [NullableContextAttribute("2")]
public HttpIOException(HttpRequestError httpRequestError, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public HttpRequestError get_HttpRequestError();
    public virtual string get_Message();
}
public enum System.Net.Http.HttpKeepAlivePingPolicy : Enum {
    public int value__;
    public static HttpKeepAlivePingPolicy WithActiveRequests;
    public static HttpKeepAlivePingPolicy Always;
}
public abstract class System.Net.Http.HttpMessageHandler : object {
    [NullableContextAttribute("1")]
protected internal virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected internal abstract virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal abstract class System.Net.Http.HttpMessageHandlerStage : HttpMessageHandler {
    protected internal sealed virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    protected internal sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    internal abstract virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpMessageInvoker : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private bool _disposeHandler;
    private HttpMessageHandler _handler;
    public HttpMessageInvoker(HttpMessageHandler handler);
    public HttpMessageInvoker(HttpMessageHandler handler, bool disposeHandler);
    [UnsupportedOSPlatformAttribute("browser")]
public virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    public virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static bool ShouldSendWithTelemetry(HttpRequestMessage request);
    internal static bool LogRequestFailed(Exception exception, bool telemetryStarted);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.Net.Http.HttpMessageInvoker/<<SendAsync>g__SendAsyncWithTelemetry|6_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<HttpResponseMessage> <SendAsync>g__SendAsyncWithTelemetry|6_0(HttpMessageHandler handler, HttpRequestMessage request, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpMethod : object {
    private string _method;
    private Nullable`1<int> _http3Index;
    private int _hashcode;
    private static HttpMethod s_getMethod;
    private static HttpMethod s_putMethod;
    private static HttpMethod s_postMethod;
    private static HttpMethod s_deleteMethod;
    private static HttpMethod s_headMethod;
    private static HttpMethod s_optionsMethod;
    private static HttpMethod s_traceMethod;
    private static HttpMethod s_patchMethod;
    private static HttpMethod s_connectMethod;
    private Byte[] _http3EncodedBytes;
    public static HttpMethod Get { get; }
    public static HttpMethod Put { get; }
    public static HttpMethod Post { get; }
    public static HttpMethod Delete { get; }
    public static HttpMethod Head { get; }
    public static HttpMethod Options { get; }
    public static HttpMethod Trace { get; }
    public static HttpMethod Patch { get; }
    public static HttpMethod Connect { get; }
    public string Method { get; }
    internal bool MustHaveRequestBody { get; }
    internal Byte[] Http3EncodedBytes { get; }
    public HttpMethod(string method);
    private HttpMethod(string method, int http3StaticTableIndex);
    private static HttpMethod();
    public static HttpMethod get_Get();
    public static HttpMethod get_Put();
    public static HttpMethod get_Post();
    public static HttpMethod get_Delete();
    public static HttpMethod get_Head();
    public static HttpMethod get_Options();
    public static HttpMethod get_Trace();
    public static HttpMethod get_Patch();
    public static HttpMethod get_Connect();
    public string get_Method();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(HttpMethod other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(HttpMethod left, HttpMethod right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(HttpMethod left, HttpMethod right);
    [NullableContextAttribute("0")]
public static HttpMethod Parse(ReadOnlySpan`1<char> method);
    internal static HttpMethod Normalize(HttpMethod method);
    internal static HttpMethod GetKnownMethod(ReadOnlySpan`1<char> method);
    internal bool get_MustHaveRequestBody();
    internal Byte[] get_Http3EncodedBytes();
}
internal class System.Net.Http.HttpNoProxy : object {
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    public ICredentials Credentials { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    public sealed virtual Uri GetProxy(Uri destination);
    public sealed virtual bool IsBypassed(Uri host);
}
internal enum System.Net.Http.HttpParseResult : Enum {
    public int value__;
    public static HttpParseResult Parsed;
    public static HttpParseResult NotParsed;
    public static HttpParseResult InvalidFormat;
}
public class System.Net.Http.HttpProtocolException : HttpIOException {
    [CompilerGeneratedAttribute]
private long <ErrorCode>k__BackingField;
    public long ErrorCode { get; }
    [NullableContextAttribute("1")]
public HttpProtocolException(long errorCode, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public long get_ErrorCode();
    internal static HttpProtocolException CreateHttp2StreamException(Http2ProtocolErrorCode protocolError);
    internal static HttpProtocolException CreateHttp2ConnectionException(Http2ProtocolErrorCode protocolError, string message);
    internal static HttpProtocolException CreateHttp3StreamException(Http3ErrorCode protocolError, QuicException innerException);
    internal static HttpProtocolException CreateHttp3ConnectionException(Http3ErrorCode protocolError, string message);
    private static string GetName(Http2ProtocolErrorCode code);
    private static string GetName(Http3ErrorCode code);
}
public enum System.Net.Http.HttpRequestError : Enum {
    public int value__;
    public static HttpRequestError Unknown;
    public static HttpRequestError NameResolutionError;
    public static HttpRequestError ConnectionError;
    public static HttpRequestError SecureConnectionError;
    public static HttpRequestError HttpProtocolError;
    public static HttpRequestError ExtendedConnectNotSupported;
    public static HttpRequestError VersionNegotiationError;
    public static HttpRequestError UserAuthenticationError;
    public static HttpRequestError ProxyTunnelError;
    public static HttpRequestError InvalidResponse;
    public static HttpRequestError ResponseEnded;
    public static HttpRequestError ConfigurationLimitExceeded;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Http.HttpRequestException : Exception {
    [CompilerGeneratedAttribute]
private RequestRetryType <AllowRetry>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpRequestError <HttpRequestError>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpStatusCode> <StatusCode>k__BackingField;
    internal RequestRetryType AllowRetry { get; }
    public HttpRequestError HttpRequestError { get; }
    public Nullable`1<HttpStatusCode> StatusCode { get; }
    public HttpRequestException(string message);
    public HttpRequestException(string message, Exception inner);
    public HttpRequestException(string message, Exception inner, Nullable`1<HttpStatusCode> statusCode);
    public HttpRequestException(HttpRequestError httpRequestError, string message, Exception inner, Nullable`1<HttpStatusCode> statusCode);
    internal HttpRequestException(HttpRequestError httpRequestError, string message, Exception inner, RequestRetryType allowRetry);
    [CompilerGeneratedAttribute]
internal RequestRetryType get_AllowRetry();
    [CompilerGeneratedAttribute]
public HttpRequestError get_HttpRequestError();
    [CompilerGeneratedAttribute]
public Nullable`1<HttpStatusCode> get_StatusCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpRequestMessage : object {
    private int _sendStatus;
    private HttpMethod _method;
    private Uri _requestUri;
    private HttpRequestHeaders _headers;
    private Version _version;
    private HttpVersionPolicy _versionPolicy;
    private HttpContent _content;
    internal HttpRequestOptions _options;
    internal static Version DefaultRequestVersion { get; }
    public Version Version { get; public set; }
    public HttpVersionPolicy VersionPolicy { get; public set; }
    [NullableAttribute("2")]
public HttpContent Content { get; public set; }
    public HttpMethod Method { get; public set; }
    [NullableAttribute("2")]
public Uri RequestUri { get; public set; }
    public HttpRequestHeaders Headers { get; }
    internal bool HasHeaders { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ObsoleteAttribute("HttpRequestMessage.Properties has been deprecated. Use Options instead.")]
public IDictionary`2<string, object> Properties { get; }
    public HttpRequestOptions Options { get; }
    private bool Disposed { get; private set; }
    internal bool IsExtendedConnectRequest { get; }
    public HttpRequestMessage(HttpMethod method, Uri requestUri);
    public HttpRequestMessage(HttpMethod method, string requestUri);
    internal static Version get_DefaultRequestVersion();
    public Version get_Version();
    public void set_Version(Version value);
    public HttpVersionPolicy get_VersionPolicy();
    public void set_VersionPolicy(HttpVersionPolicy value);
    [NullableContextAttribute("2")]
public HttpContent get_Content();
    [NullableContextAttribute("2")]
public void set_Content(HttpContent value);
    public HttpMethod get_Method();
    public void set_Method(HttpMethod value);
    [NullableContextAttribute("2")]
public Uri get_RequestUri();
    [NullableContextAttribute("2")]
public void set_RequestUri(Uri value);
    public HttpRequestHeaders get_Headers();
    internal bool get_HasHeaders();
    public IDictionary`2<string, object> get_Properties();
    public HttpRequestOptions get_Options();
    public virtual string ToString();
    internal bool MarkAsSent();
    internal bool WasSentByHttpClient();
    internal void MarkAsRedirected();
    internal bool WasRedirected();
    private bool get_Disposed();
    private void set_Disposed(bool value);
    internal bool get_IsExtendedConnectRequest();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void CheckDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpRequestOptions : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> Options { get; }
    [NullableAttribute("2")]
private object System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.Item { get; }
    private IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<object> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.Generic.IDictionary<System.String,System.Object>.Item { get; private set; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.Values { get; }
    private int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.IsReadOnly { get; }
    private int System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Count { get; }
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> get_Options();
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override IEnumerable`1<string> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override IEnumerable`1<object> System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override object System.Collections.Generic.IDictionary<System.String,System.Object>.get_Item(string key);
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.set_Item(string key, object value);
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Keys();
    private sealed virtual override ICollection`1<object> System.Collections.Generic.IDictionary<System.String,System.Object>.get_Values();
    private sealed virtual override int System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.IDictionary<System.String,System.Object>.Add(string key, object value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Add(KeyValuePair`2<string, object> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Contains(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.Remove(string key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.Remove(KeyValuePair`2<string, object> item);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.get_Count();
    public bool TryGetValue(HttpRequestOptionsKey`1<TValue> key, TValue& value);
    public void Set(HttpRequestOptionsKey`1<TValue> key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Net.Http.HttpRequestOptionsKey`1 : ValueType {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Key { get; }
    public HttpRequestOptionsKey`1(string key);
    [CompilerGeneratedAttribute]
public string get_Key();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.HttpResponseMessage : object {
    private HttpStatusCode _statusCode;
    private HttpResponseHeaders _headers;
    private HttpResponseHeaders _trailingHeaders;
    private string _reasonPhrase;
    private HttpRequestMessage _requestMessage;
    private Version _version;
    private HttpContent _content;
    private bool _disposed;
    private static Version DefaultResponseVersion { get; }
    public Version Version { get; public set; }
    public HttpContent Content { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    [NullableAttribute("2")]
public string ReasonPhrase { get; public set; }
    public HttpResponseHeaders Headers { get; }
    public HttpResponseHeaders TrailingHeaders { get; }
    [NullableAttribute("2")]
public HttpRequestMessage RequestMessage { get; public set; }
    public bool IsSuccessStatusCode { get; }
    public HttpResponseMessage(HttpStatusCode statusCode);
    private static Version get_DefaultResponseVersion();
    public Version get_Version();
    public void set_Version(Version value);
    internal void SetVersionWithoutValidation(Version value);
    public HttpContent get_Content();
    public void set_Content(HttpContent value);
    public HttpStatusCode get_StatusCode();
    public void set_StatusCode(HttpStatusCode value);
    internal void SetStatusCodeWithoutValidation(HttpStatusCode value);
    [NullableContextAttribute("2")]
public string get_ReasonPhrase();
    [NullableContextAttribute("2")]
public void set_ReasonPhrase(string value);
    internal void SetReasonPhraseWithoutValidation(string value);
    public HttpResponseHeaders get_Headers();
    public HttpResponseHeaders get_TrailingHeaders();
    internal void StoreReceivedTrailingHeaders(HttpResponseHeaders headers);
    [NullableContextAttribute("2")]
public HttpRequestMessage get_RequestMessage();
    [NullableContextAttribute("2")]
public void set_RequestMessage(HttpRequestMessage value);
    public bool get_IsSuccessStatusCode();
    public HttpResponseMessage EnsureSuccessStatusCode();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private void CheckDisposed();
}
internal static class System.Net.Http.HttpRuleParser : object {
    private static SearchValues`1<char> s_tokenChars;
    private static SearchValues`1<byte> s_tokenBytes;
    private static SearchValues`1<char> s_hostDelimiterChars;
    internal static Encoding DefaultHttpEncoding { get; }
    private static HttpRuleParser();
    internal static Encoding get_DefaultHttpEncoding();
    internal static int GetTokenLength(string input, int startIndex);
    internal static bool IsToken(ReadOnlySpan`1<char> input);
    internal static bool IsToken(ReadOnlySpan`1<byte> input);
    internal static string GetTokenString(ReadOnlySpan`1<byte> input);
    internal static int GetWhitespaceLength(string input, int startIndex);
    internal static bool ContainsNewLine(string value, int startIndex);
    internal static int GetNumberLength(string input, int startIndex, bool allowDecimal);
    internal static int GetHostLength(string input, int startIndex, bool allowToken);
    internal static HttpParseResult GetCommentLength(string input, int startIndex, Int32& length);
    internal static HttpParseResult GetQuotedStringLength(string input, int startIndex, Int32& length);
    internal static HttpParseResult GetQuotedPairLength(string input, int startIndex, Int32& length);
    private static HttpParseResult GetExpressionLength(string input, int startIndex, char openChar, char closeChar, bool supportsNesting, int nestedCount, Int32& length);
    private static bool IsValidHostName(ReadOnlySpan`1<char> host);
}
[EventSourceAttribute]
internal class System.Net.Http.HttpTelemetry : EventSource {
    public static HttpTelemetry Log;
    private long _startedRequests;
    private long _stoppedRequests;
    private long _failedRequests;
    private long _openedHttp11Connections;
    private long _openedHttp20Connections;
    private long _openedHttp30Connections;
    private IncrementingPollingCounter _startedRequestsPerSecondCounter;
    private IncrementingPollingCounter _failedRequestsPerSecondCounter;
    private PollingCounter _startedRequestsCounter;
    private PollingCounter _currentRequestsCounter;
    private PollingCounter _failedRequestsCounter;
    private PollingCounter _totalHttp11ConnectionsCounter;
    private PollingCounter _totalHttp20ConnectionsCounter;
    private PollingCounter _totalHttp30ConnectionsCounter;
    private EventCounter _http11RequestsQueueDurationCounter;
    private EventCounter _http20RequestsQueueDurationCounter;
    private EventCounter _http30RequestsQueueDurationCounter;
    private static HttpTelemetry();
    [EventAttribute("1")]
private void RequestStart(string scheme, string host, int port, string pathAndQuery, byte versionMajor, byte versionMinor, HttpVersionPolicy versionPolicy);
    [NonEventAttribute]
public void RequestStart(HttpRequestMessage request);
    [NonEventAttribute]
public void RequestStop(HttpResponseMessage response);
    [EventAttribute("2")]
private void RequestStop(int statusCode);
    [NonEventAttribute]
public void RequestFailed(Exception exception);
    [EventAttribute("3")]
private void RequestFailed(string exceptionMessage);
    [NonEventAttribute]
private void ConnectionEstablished(byte versionMajor, byte versionMinor, long connectionId, string scheme, string host, int port, IPEndPoint remoteEndPoint);
    [EventAttribute("4")]
private void ConnectionEstablished(byte versionMajor, byte versionMinor, long connectionId, string scheme, string host, int port, string remoteAddress);
    [EventAttribute("5")]
private void ConnectionClosed(byte versionMajor, byte versionMinor, long connectionId);
    [EventAttribute("6")]
private void RequestLeftQueue(double timeOnQueueMilliseconds, byte versionMajor, byte versionMinor);
    [EventAttribute("7")]
public void RequestHeadersStart(long connectionId);
    [EventAttribute("8")]
public void RequestHeadersStop();
    [EventAttribute("9")]
public void RequestContentStart();
    [EventAttribute("10")]
public void RequestContentStop(long contentLength);
    [EventAttribute("11")]
public void ResponseHeadersStart();
    [EventAttribute("12")]
public void ResponseHeadersStop(int statusCode);
    [EventAttribute("13")]
public void ResponseContentStart();
    [EventAttribute("14")]
public void ResponseContentStop();
    [EventAttribute("15")]
private void RequestFailedDetailed(string exception);
    [EventAttribute("16")]
public void Redirect(string redirectUri);
    [NonEventAttribute]
public void Http11ConnectionEstablished(long connectionId, string scheme, string host, int port, IPEndPoint remoteEndPoint);
    [NonEventAttribute]
public void Http11ConnectionClosed(long connectionId);
    [NonEventAttribute]
public void Http20ConnectionEstablished(long connectionId, string scheme, string host, int port, IPEndPoint remoteEndPoint);
    [NonEventAttribute]
public void Http20ConnectionClosed(long connectionId);
    [NonEventAttribute]
public void Http30ConnectionEstablished(long connectionId, string scheme, string host, int port, IPEndPoint remoteEndPoint);
    [NonEventAttribute]
public void Http30ConnectionClosed(long connectionId);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3, string arg4, byte arg5, byte arg6, HttpVersionPolicy arg7);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[NonEventAttribute]
private void WriteEvent(int eventId, double arg1, byte arg2, byte arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[NonEventAttribute]
private void WriteEvent(int eventId, byte arg1, byte arg2, long arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[NonEventAttribute]
private void WriteEvent(int eventId, byte arg1, byte arg2, long arg3, string arg4, string arg5, int arg6, string arg7);
    [NonEventAttribute]
public void RequestLeftQueue(int versionMajor, TimeSpan duration);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_0();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_1();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_2();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_3();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_4();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_5();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_6();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__50_7();
}
internal static class System.Net.Http.HttpUtilities : object {
    internal static bool IsSupportedScheme(string scheme);
    internal static bool IsSupportedNonSecureScheme(string scheme);
    internal static bool IsSupportedSecureScheme(string scheme);
    internal static bool IsNonSecureWebSocketScheme(string scheme);
    internal static bool IsSecureWebSocketScheme(string scheme);
    internal static bool IsSupportedProxyScheme(string scheme);
    internal static bool IsSocksScheme(string scheme);
}
public enum System.Net.Http.HttpVersionPolicy : Enum {
    public int value__;
    public static HttpVersionPolicy RequestVersionOrLower;
    public static HttpVersionPolicy RequestVersionOrHigher;
    public static HttpVersionPolicy RequestVersionExact;
}
internal interface System.Net.Http.IHttpStreamHeadersHandler {
    public abstract virtual void OnStaticIndexedHeader(int index);
    public abstract virtual void OnStaticIndexedHeader(int index, ReadOnlySpan`1<byte> value);
    public abstract virtual void OnHeader(ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
    public abstract virtual void OnHeadersComplete(bool endStream);
    public abstract virtual void OnDynamicIndexedHeader(Nullable`1<int> index, ReadOnlySpan`1<byte> name, ReadOnlySpan`1<byte> value);
}
internal interface System.Net.Http.IHttpTrace {
    public abstract virtual void Trace(string message, string memberName);
}
internal interface System.Net.Http.IMultiWebProxy {
    public abstract virtual MultiProxy GetMultiProxy(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.Http.MessageProcessingHandler : DelegatingHandler {
    protected MessageProcessingHandler(HttpMessageHandler innerHandler);
    protected abstract virtual HttpRequestMessage ProcessRequest(HttpRequestMessage request, CancellationToken cancellationToken);
    protected abstract virtual HttpResponseMessage ProcessResponse(HttpResponseMessage response, CancellationToken cancellationToken);
    protected internal sealed virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    protected internal sealed virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static void HandleCanceledOperations(CancellationToken cancellationToken, TaskCompletionSource`1<HttpResponseMessage> tcs, OperationCanceledException e);
}
internal class System.Net.Http.Metrics.ConnectionMetrics : object {
    private SocketsHttpHandlerMetrics _metrics;
    private bool _openConnectionsEnabled;
    private object _protocolVersionTag;
    private object _schemeTag;
    private object _hostTag;
    private object _portTag;
    private object _peerAddressTag;
    private bool _currentlyIdle;
    public ConnectionMetrics(SocketsHttpHandlerMetrics metrics, string protocolVersion, string scheme, string host, Nullable`1<int> port, string peerAddress);
    private TagList GetTags();
    private static KeyValuePair`2<string, object> GetStateTag(bool idle);
    public void ConnectionEstablished();
    public void ConnectionClosed(long durationMs);
    public void IdleStateChanged(bool idle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.Metrics.HttpMetricsEnrichmentContext : object {
    private static HttpRequestOptionsKey`1<HttpMetricsEnrichmentContext> s_optionsKeyForContext;
    private static ConcurrentQueue`1<HttpMetricsEnrichmentContext> s_pool;
    private static int s_poolItemCount;
    private List`1<Action`1<HttpMetricsEnrichmentContext>> _callbacks;
    private HttpRequestMessage _request;
    private HttpResponseMessage _response;
    private Exception _exception;
    private List`1<KeyValuePair`2<string, object>> _tags;
    public HttpRequestMessage Request { get; }
    [NullableAttribute("2")]
public HttpResponseMessage Response { get; }
    [NullableAttribute("2")]
public Exception Exception { get; }
    private static HttpMetricsEnrichmentContext();
    public HttpRequestMessage get_Request();
    [NullableContextAttribute("2")]
public HttpResponseMessage get_Response();
    [NullableContextAttribute("2")]
public Exception get_Exception();
    public void AddCustomTag(string name, object value);
    public static void AddCallback(HttpRequestMessage request, Action`1<HttpMetricsEnrichmentContext> callback);
    internal static HttpMetricsEnrichmentContext GetEnrichmentContextForRequest(HttpRequestMessage request);
    internal void RecordDurationWithEnrichment(HttpRequestMessage request, HttpResponseMessage response, Exception exception, TimeSpan durationTime, TagList& commonTags, Histogram`1<double> requestDuration);
}
internal class System.Net.Http.Metrics.MetricsHandler : HttpMessageHandlerStage {
    private HttpMessageHandler _innerHandler;
    private UpDownCounter`1<long> _activeRequests;
    private Histogram`1<double> _requestsDuration;
    private static Object[] s_boxedStatusCodes;
    private static String[] s_statusCodeStrings;
    public MetricsHandler(HttpMessageHandler innerHandler, IMeterFactory meterFactory, Meter& meter);
    internal virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.Metrics.MetricsHandler/<SendAsyncWithMetrics>d__5")]
private ValueTask`1<HttpResponseMessage> SendAsyncWithMetrics(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    private ValueTuple`2<long, bool> RequestStart(HttpRequestMessage request);
    private void RequestStop(HttpRequestMessage request, HttpResponseMessage response, Exception exception, long startTimestamp, bool recordCurrentRequests);
    private static bool TryGetErrorType(HttpResponseMessage response, Exception exception, String& errorType);
    private static string GetProtocolVersionString(Version httpVersion);
    private static TagList InitializeCommonTags(HttpRequestMessage request);
    internal static KeyValuePair`2<string, object> GetMethodTag(HttpMethod method);
    private static object GetBoxedStatusCode(int statusCode);
    private static string GetErrorStatusCodeString(int statusCode);
}
internal class System.Net.Http.Metrics.SocketsHttpHandlerMetrics : object {
    public UpDownCounter`1<long> OpenConnections;
    public Histogram`1<double> ConnectionDuration;
    public Histogram`1<double> RequestsQueueDuration;
    public SocketsHttpHandlerMetrics(Meter meter);
    public void RequestLeftQueue(HttpRequestMessage request, HttpConnectionPool pool, TimeSpan duration, int versionMajor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.MultipartContent : HttpContent {
    private static SearchValues`1<char> s_allowedBoundaryChars;
    private List`1<HttpContent> _nestedContent;
    private string _boundary;
    [CompilerGeneratedAttribute]
private HeaderEncodingSelector`1<HttpContent> <HeaderEncodingSelector>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HeaderEncodingSelector`1<HttpContent> HeaderEncodingSelector { get; public set; }
    internal bool AllowDuplex { get; }
    public MultipartContent(string subtype);
    public MultipartContent(string subtype, string boundary);
    private static MultipartContent();
    private static void ValidateBoundary(string boundary);
    private static string GetDefaultBoundary();
    public virtual void Add(HttpContent content);
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<HttpContent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public HeaderEncodingSelector`1<HttpContent> get_HeaderEncodingSelector();
    [CompilerGeneratedAttribute]
public void set_HeaderEncodingSelector(HeaderEncodingSelector`1<HttpContent> value);
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.MultipartContent/<SerializeToStreamAsyncCore>d__24")]
private protected Task SerializeToStreamAsyncCore(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    protected virtual Task`1<Stream> CreateContentReadStreamAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.MultipartContent/<CreateContentReadStreamAsyncCore>d__28")]
private ValueTask`1<Stream> CreateContentReadStreamAsyncCore(bool async, CancellationToken cancellationToken);
    private void SerializeHeadersToStream(Stream stream, HttpContent content, bool writeDivider);
    private static ValueTask EncodeStringToStreamAsync(Stream stream, string input, CancellationToken cancellationToken);
    private static MemoryStream EncodeStringToNewStream(string input);
    private MemoryStream EncodeHeadersToNewStream(HttpContent content, bool writeDivider);
    internal virtual bool get_AllowDuplex();
    protected internal virtual bool TryComputeLength(Int64& length);
    private static void WriteToStream(Stream stream, string content);
    private static void WriteToStream(Stream stream, string content, Encoding encoding);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<Stream> <>n__0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Stream <>n__1(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.MultipartFormDataContent : MultipartContent {
    public MultipartFormDataContent(string boundary);
    public virtual void Add(HttpContent content);
    public void Add(HttpContent content, string name);
    public void Add(HttpContent content, string name, string fileName);
    private void AddInternal(HttpContent content, string name, string fileName);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
}
internal class System.Net.Http.MultiProxy : ValueType {
    private FailedProxyCache _failedProxyCache;
    private Uri[] _uris;
    private string _proxyConfig;
    private bool _secure;
    private int _currentIndex;
    private Uri _currentUri;
    public bool ReadNext(Uri& uri, Boolean& isFinalProxy);
    private bool ReadNextHelper(Uri& uri, Boolean& isFinalProxy);
    private static bool TryParseProxyConfigPart(ReadOnlySpan`1<char> proxyString, bool secure, Uri& uri, Int32& charactersConsumed);
}
internal class System.Net.Http.QPack.QPackDecoder : object {
    private int _maxHeadersLength;
    private State _state;
    private bool _huffman;
    private Byte[] _headerName;
    private int _headerStaticIndex;
    private int _headerNameLength;
    private int _headerValueLength;
    private int _stringLength;
    private int _stringIndex;
    private IntegerDecoder _integerDecoder;
    private Byte[] _stringOctets;
    private Byte[] _headerNameOctets;
    private Byte[] _headerValueOctets;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerNameRange;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<int, int>> _headerValueRange;
    private static ArrayPool`1<byte> Pool { get; }
    public QPackDecoder(int maxHeadersLength);
    private static ArrayPool`1<byte> get_Pool();
    public sealed virtual void Dispose();
    public void Reset();
    public void Decode(ReadOnlySpan`1<byte> data, bool endHeaders, IHttpStreamHeadersHandler handler);
    private void DecodeInternal(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameIndexPostBase(ReadOnlySpan`1<byte> data, Int32& currentIndex);
    private void ParsePostBaseIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex);
    private void ParseHeaderNameLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderName(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderFieldIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderNameIndex(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValueLength(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseHeaderValueLengthContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseCompressedHeaders(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseRequiredInsertCountContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseBase(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseBaseContinue(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void ParseRequiredInsertCount(ReadOnlySpan`1<byte> data, Int32& currentIndex, IHttpStreamHeadersHandler handler);
    private void CheckIncompleteHeaderBlock(bool endHeaders);
    private void ProcessHeaderValue(ReadOnlySpan`1<byte> data, IHttpStreamHeadersHandler handler);
    private void OnStringLength(int length, State nextState);
    private void OnString(State nextState);
    private static void EnsureStringCapacity(Byte[]& buffer, int requiredLength, int existingLength);
    private bool TryDecodeInteger(ReadOnlySpan`1<byte> data, Int32& currentIndex, Int32& result);
    private static bool IsHuffmanEncoded(byte b);
    private void OnIndexedHeaderName(int index);
    private static void OnIndexedHeaderNamePostBase(int _);
    private static void OnPostBaseIndex();
    private void OnBase(int deltaBase);
    private void OnRequiredInsertCount(int requiredInsertCount);
    private void OnIndexedHeaderField(int index, IHttpStreamHeadersHandler handler);
    private static void ThrowDynamicTableNotSupported();
    [CompilerGeneratedAttribute]
private int <OnString>g__Decode|61_0(Byte[]& dst);
}
internal class System.Net.Http.QPack.QPackDecodingException : Exception {
    public QPackDecodingException(string message);
    public QPackDecodingException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private QPackDecodingException(SerializationInfo info, StreamingContext context);
}
internal static class System.Net.Http.QPack.QPackEncoder : object {
    public static bool EncodeStaticIndexedHeaderField(int index, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeStaticIndexedHeaderFieldToArray(int index);
    public static bool EncodeLiteralHeaderFieldWithStaticNameReference(int index, string value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithStaticNameReference(int index, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeLiteralHeaderFieldWithStaticNameReferenceToArray(int index);
    public static Byte[] EncodeLiteralHeaderFieldWithStaticNameReferenceToArray(int index, string value);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, string value, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, string value, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static bool EncodeLiteralHeaderFieldWithoutNameReference(string name, ReadOnlySpan`1<string> values, string valueSeparator, Encoding valueEncoding, Span`1<byte> destination, Int32& bytesWritten);
    public static Byte[] EncodeLiteralHeaderFieldWithoutNameReferenceToArray(string name);
    public static Byte[] EncodeLiteralHeaderFieldWithoutNameReferenceToArray(string name, string value);
    private static bool EncodeValueString(string s, Encoding valueEncoding, Span`1<byte> buffer, Int32& length);
    public static bool EncodeValueString(ReadOnlySpan`1<string> values, string separator, Encoding valueEncoding, Span`1<byte> buffer, Int32& length);
    private static void EncodeValueStringPart(string s, Span`1<byte> buffer);
    private static bool EncodeNameString(string s, Span`1<byte> buffer, Int32& length);
}
internal class System.Net.Http.QPack.QPackEncodingException : Exception {
    public QPackEncodingException(string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private QPackEncodingException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.ReadOnlyMemoryContent : HttpContent {
    private ReadOnlyMemory`1<byte> _content;
    internal bool AllowDuplex { get; }
    [NullableContextAttribute("0")]
public ReadOnlyMemoryContent(ReadOnlyMemory`1<byte> content);
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected internal virtual bool TryComputeLength(Int64& length);
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    internal virtual Stream TryCreateContentReadStream();
    internal virtual bool get_AllowDuplex();
}
internal class System.Net.Http.RedirectHandler : HttpMessageHandlerStage {
    private HttpMessageHandlerStage _initialInnerHandler;
    private HttpMessageHandlerStage _redirectInnerHandler;
    private int _maxAutomaticRedirections;
    public RedirectHandler(int maxAutomaticRedirections, HttpMessageHandlerStage initialInnerHandler, HttpMessageHandlerStage redirectInnerHandler);
    [AsyncStateMachineAttribute("System.Net.Http.RedirectHandler/<SendAsync>d__4")]
internal virtual ValueTask`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, bool async, CancellationToken cancellationToken);
    private Uri GetUriForRedirect(Uri requestUri, HttpResponseMessage response);
    private static bool RequestRequiresForceGet(HttpStatusCode statusCode, HttpMethod requestMethod);
    protected virtual void Dispose(bool disposing);
    internal void Trace(string message, int requestId, string memberName);
    internal void TraceError(string message, int requestId, string memberName);
}
internal enum System.Net.Http.RequestRetryType : Enum {
    public int value__;
    public static RequestRetryType NoRetry;
    public static RequestRetryType RetryOnConnectionFailure;
    public static RequestRetryType RetryOnLowerHttpVersion;
    public static RequestRetryType RetryOnNextProxy;
    public static RequestRetryType RetryOnStreamLimitReached;
}
internal static class System.Net.Http.RuntimeSettingParser : object {
    public static bool QueryRuntimeSettingSwitch(string appCtxSettingName, string environmentVariableSettingName, bool defaultValue);
    public static int QueryRuntimeSettingInt32(string appCtxSettingName, string environmentVariableSettingName, int defaultValue);
    public static int ParseInt32EnvironmentVariableValue(string environmentVariableSettingName, int defaultValue);
    public static double ParseDoubleEnvironmentVariableValue(string environmentVariableSettingName, double defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.SocketsHttpConnectionContext : object {
    private DnsEndPoint _dnsEndPoint;
    private HttpRequestMessage _initialRequestMessage;
    public DnsEndPoint DnsEndPoint { get; }
    public HttpRequestMessage InitialRequestMessage { get; }
    internal SocketsHttpConnectionContext(DnsEndPoint dnsEndPoint, HttpRequestMessage initialRequestMessage);
    public DnsEndPoint get_DnsEndPoint();
    public HttpRequestMessage get_InitialRequestMessage();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Net.Http.SocketsHttpHandler : HttpMessageHandler {
    private HttpConnectionSettings _settings;
    private HttpMessageHandlerStage _handler;
    private Func`3<HttpConnectionSettings, HttpMessageHandlerStage, HttpMessageHandlerStage> _decompressionHandlerFactory;
    private bool _disposed;
    [UnsupportedOSPlatformGuardAttribute("browser")]
public static bool IsSupported { get; }
    public bool UseCookies { get; public set; }
    [NullableAttribute("1")]
public CookieContainer CookieContainer { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public bool UseProxy { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public ICredentials DefaultProxyCredentials { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public int MaxAutomaticRedirections { get; public set; }
    public int MaxConnectionsPerServer { get; public set; }
    public int MaxResponseDrainSize { get; public set; }
    public TimeSpan ResponseDrainTimeout { get; public set; }
    public int MaxResponseHeadersLength { get; public set; }
    [NullableAttribute("1")]
public SslClientAuthenticationOptions SslOptions { get; public set; }
    public TimeSpan PooledConnectionLifetime { get; public set; }
    public TimeSpan PooledConnectionIdleTimeout { get; public set; }
    public TimeSpan ConnectTimeout { get; public set; }
    public TimeSpan Expect100ContinueTimeout { get; public set; }
    public int InitialHttp2StreamWindowSize { get; public set; }
    public TimeSpan KeepAlivePingDelay { get; public set; }
    public TimeSpan KeepAlivePingTimeout { get; public set; }
    public HttpKeepAlivePingPolicy KeepAlivePingPolicy { get; public set; }
    public bool EnableMultipleHttp2Connections { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<SocketsHttpConnectionContext, CancellationToken, ValueTask`1<Stream>> ConnectCallback { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<SocketsHttpPlaintextStreamFilterContext, CancellationToken, ValueTask`1<Stream>> PlaintextStreamFilter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, object> Properties { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HeaderEncodingSelector`1<HttpRequestMessage> RequestHeaderEncodingSelector { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HeaderEncodingSelector`1<HttpRequestMessage> ResponseHeaderEncodingSelector { get; public set; }
    [CLSCompliantAttribute("False")]
public DistributedContextPropagator ActivityHeadersPropagator { get; public set; }
    [CLSCompliantAttribute("False")]
public IMeterFactory MeterFactory { get; public set; }
    internal ClientCertificateOption ClientCertificateOptions { get; internal set; }
    private void CheckDisposedOrStarted();
    public static bool get_IsSupported();
    public bool get_UseCookies();
    public void set_UseCookies(bool value);
    [NullableContextAttribute("1")]
public CookieContainer get_CookieContainer();
    [NullableContextAttribute("1")]
public void set_CookieContainer(CookieContainer value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public bool get_UseProxy();
    public void set_UseProxy(bool value);
    public IWebProxy get_Proxy();
    public void set_Proxy(IWebProxy value);
    public ICredentials get_DefaultProxyCredentials();
    public void set_DefaultProxyCredentials(ICredentials value);
    public bool get_PreAuthenticate();
    public void set_PreAuthenticate(bool value);
    public ICredentials get_Credentials();
    public void set_Credentials(ICredentials value);
    public bool get_AllowAutoRedirect();
    public void set_AllowAutoRedirect(bool value);
    public int get_MaxAutomaticRedirections();
    public void set_MaxAutomaticRedirections(int value);
    public int get_MaxConnectionsPerServer();
    public void set_MaxConnectionsPerServer(int value);
    public int get_MaxResponseDrainSize();
    public void set_MaxResponseDrainSize(int value);
    public TimeSpan get_ResponseDrainTimeout();
    public void set_ResponseDrainTimeout(TimeSpan value);
    public int get_MaxResponseHeadersLength();
    public void set_MaxResponseHeadersLength(int value);
    [NullableContextAttribute("1")]
public SslClientAuthenticationOptions get_SslOptions();
    [NullableContextAttribute("1")]
public void set_SslOptions(SslClientAuthenticationOptions value);
    public TimeSpan get_PooledConnectionLifetime();
    public void set_PooledConnectionLifetime(TimeSpan value);
    public TimeSpan get_PooledConnectionIdleTimeout();
    public void set_PooledConnectionIdleTimeout(TimeSpan value);
    public TimeSpan get_ConnectTimeout();
    public void set_ConnectTimeout(TimeSpan value);
    public TimeSpan get_Expect100ContinueTimeout();
    public void set_Expect100ContinueTimeout(TimeSpan value);
    public int get_InitialHttp2StreamWindowSize();
    public void set_InitialHttp2StreamWindowSize(int value);
    public TimeSpan get_KeepAlivePingDelay();
    public void set_KeepAlivePingDelay(TimeSpan value);
    public TimeSpan get_KeepAlivePingTimeout();
    public void set_KeepAlivePingTimeout(TimeSpan value);
    public HttpKeepAlivePingPolicy get_KeepAlivePingPolicy();
    public void set_KeepAlivePingPolicy(HttpKeepAlivePingPolicy value);
    public bool get_EnableMultipleHttp2Connections();
    public void set_EnableMultipleHttp2Connections(bool value);
    public Func`3<SocketsHttpConnectionContext, CancellationToken, ValueTask`1<Stream>> get_ConnectCallback();
    public void set_ConnectCallback(Func`3<SocketsHttpConnectionContext, CancellationToken, ValueTask`1<Stream>> value);
    public Func`3<SocketsHttpPlaintextStreamFilterContext, CancellationToken, ValueTask`1<Stream>> get_PlaintextStreamFilter();
    public void set_PlaintextStreamFilter(Func`3<SocketsHttpPlaintextStreamFilterContext, CancellationToken, ValueTask`1<Stream>> value);
    public IDictionary`2<string, object> get_Properties();
    public HeaderEncodingSelector`1<HttpRequestMessage> get_RequestHeaderEncodingSelector();
    public void set_RequestHeaderEncodingSelector(HeaderEncodingSelector`1<HttpRequestMessage> value);
    public HeaderEncodingSelector`1<HttpRequestMessage> get_ResponseHeaderEncodingSelector();
    public void set_ResponseHeaderEncodingSelector(HeaderEncodingSelector`1<HttpRequestMessage> value);
    public DistributedContextPropagator get_ActivityHeadersPropagator();
    public void set_ActivityHeadersPropagator(DistributedContextPropagator value);
    public IMeterFactory get_MeterFactory();
    public void set_MeterFactory(IMeterFactory value);
    internal ClientCertificateOption get_ClientCertificateOptions();
    internal void set_ClientCertificateOptions(ClientCertificateOption value);
    protected virtual void Dispose(bool disposing);
    private HttpMessageHandlerStage SetupHandlerChain();
    private void EnsureDecompressionHandlerFactory();
    [NullableContextAttribute("1")]
protected internal virtual HttpResponseMessage Send(HttpRequestMessage request, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected internal virtual Task`1<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken);
    private static Exception ValidateAndNormalizeRequest(HttpRequestMessage request);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.SocketsHttpPlaintextStreamFilterContext : object {
    private Stream _plaintextStream;
    private Version _negotiatedHttpVersion;
    private HttpRequestMessage _initialRequestMessage;
    public Stream PlaintextStream { get; }
    public Version NegotiatedHttpVersion { get; }
    public HttpRequestMessage InitialRequestMessage { get; }
    internal SocketsHttpPlaintextStreamFilterContext(Stream plaintextStream, Version negotiatedHttpVersion, HttpRequestMessage initialRequestMessage);
    public Stream get_PlaintextStream();
    public Version get_NegotiatedHttpVersion();
    public HttpRequestMessage get_InitialRequestMessage();
}
internal class System.Net.Http.SocksException : IOException {
    public SocksException(string message);
    public SocksException(string message, Exception innerException);
}
internal static class System.Net.Http.SocksHelper : object {
    [AsyncStateMachineAttribute("System.Net.Http.SocksHelper/<EstablishSocksTunnelAsync>d__13")]
public static ValueTask EstablishSocksTunnelAsync(Stream stream, string host, int port, Uri proxyUri, ICredentials proxyCredentials, bool async, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Http.SocksHelper/<EstablishSocks5TunnelAsync>d__14")]
private static ValueTask EstablishSocks5TunnelAsync(Stream stream, string host, int port, NetworkCredential credentials, bool async);
    [AsyncStateMachineAttribute("System.Net.Http.SocksHelper/<EstablishSocks4TunnelAsync>d__15")]
private static ValueTask EstablishSocks4TunnelAsync(Stream stream, bool isVersion4a, string host, int port, NetworkCredential credentials, bool async, CancellationToken cancellationToken);
    private static byte EncodeString(ReadOnlySpan`1<char> chars, Span`1<byte> buffer, string parameterName);
    private static void VerifyProtocolVersion(byte expected, byte version);
    private static ValueTask WriteAsync(Stream stream, Memory`1<byte> buffer, bool async);
    [AsyncStateMachineAttribute("System.Net.Http.SocksHelper/<ReadToFillAsync>d__19")]
private static ValueTask ReadToFillAsync(Stream stream, Memory`1<byte> buffer, bool async);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.StreamContent : HttpContent {
    private Stream _content;
    private int _bufferSize;
    private bool _contentConsumed;
    private long _start;
    internal bool AllowDuplex { get; }
    public StreamContent(Stream content);
    public StreamContent(Stream content, int bufferSize);
    [MemberNotNullAttribute("_content")]
private void InitializeContent(Stream content, int bufferSize);
    protected virtual void SerializeToStream(Stream stream, TransportContext context, CancellationToken cancellationToken);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    private Task SerializeToStreamAsyncCore(Stream stream, CancellationToken cancellationToken);
    protected internal virtual bool TryComputeLength(Int64& length);
    protected virtual void Dispose(bool disposing);
    protected virtual Stream CreateContentReadStream(CancellationToken cancellationToken);
    protected virtual Task`1<Stream> CreateContentReadStreamAsync();
    internal virtual Stream TryCreateContentReadStream();
    internal virtual bool get_AllowDuplex();
    private void PrepareContent();
}
internal static class System.Net.Http.StreamToStreamCopy : object {
    public static void Copy(Stream source, Stream destination, int bufferSize, bool disposeSource);
    public static Task CopyAsync(Stream source, Stream destination, int bufferSize, bool disposeSource, CancellationToken cancellationToken);
    private static void DisposeSource(Stream source);
    [AsyncStateMachineAttribute("System.Net.Http.StreamToStreamCopy/<<CopyAsync>g__DisposeSourceAsync|1_0>d")]
[CompilerGeneratedAttribute]
internal static Task <CopyAsync>g__DisposeSourceAsync|1_0(Task copyTask, Stream source);
}
[ExtensionAttribute]
internal static class System.Net.Http.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendKeyValue(StringBuilder sb, string key, string value, bool includeQuotes, bool includeComma);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Http.StringContent : ByteArrayContent {
    public StringContent(string content);
    public StringContent(string content, MediaTypeHeaderValue mediaType);
    public StringContent(string content, Encoding encoding);
    public StringContent(string content, Encoding encoding, string mediaType);
    public StringContent(string content, Encoding encoding, MediaTypeHeaderValue mediaType);
    private static Byte[] GetContentByteArray(string content, Encoding encoding);
    protected virtual Task SerializeToStreamAsync(Stream stream, TransportContext context, CancellationToken cancellationToken);
    internal virtual Stream TryCreateContentReadStream();
}
internal static class System.Net.Http.SystemProxyInfo : object {
    private static Lazy`1<IWebProxy> s_proxy;
    public static IWebProxy Proxy { get; }
    private static SystemProxyInfo();
    public static IWebProxy get_Proxy();
    public static IWebProxy ConstructSystemProxy();
}
internal static class System.Net.Http.VariableLengthIntegerHelper : object {
    public static bool TryRead(ReadOnlySpan`1<byte> buffer, Int64& value, Int32& bytesRead);
    public static bool TryWrite(Span`1<byte> buffer, long longToEncode, Int32& bytesWritten);
    public static int WriteInteger(Span`1<byte> buffer, long longToEncode);
    public static int GetByteCount(long value);
}
internal static class System.Net.HttpDateParser : object {
    private static String[] s_dateFormats;
    private static HttpDateParser();
    internal static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
}
internal static class System.Net.HttpStatusDescription : object {
    internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal class System.Net.MultiArrayBuffer : ValueType {
    private Byte[][] _blocks;
    private UInt32 _allocatedEnd;
    private UInt32 _activeStart;
    private UInt32 _availableStart;
    public bool IsEmpty { get; }
    public MultiMemory ActiveMemory { get; }
    public MultiMemory AvailableMemory { get; }
    public MultiArrayBuffer(int initialBufferSize);
    public sealed virtual void Dispose();
    public bool get_IsEmpty();
    public MultiMemory get_ActiveMemory();
    public MultiMemory get_AvailableMemory();
    public void Discard(int byteCount);
    public void DiscardAll();
    private void FreeBlocks(UInt32 startBlock, UInt32 endBlock);
    public void Commit(int byteCount);
    public void EnsureAvailableSpace(int byteCount);
    public void GrowAvailableSpace(int byteCount);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class System.Net.MultiMemory : ValueType {
    private Byte[][] _blocks;
    private UInt32 _start;
    private UInt32 _length;
    public int Length { get; }
    public int BlockCount { get; }
    internal MultiMemory(Byte[][] blocks, UInt32 start, UInt32 length);
    private static UInt32 GetBlockIndex(UInt32 offset);
    private static UInt32 GetOffsetInBlock(UInt32 offset);
    public int get_Length();
    public int get_BlockCount();
    public Memory`1<byte> GetBlock(int blockIndex);
    public MultiMemory Slice(int start, int length);
    public void CopyTo(Span`1<byte> destination);
    public void CopyFrom(ReadOnlySpan`1<byte> source);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void UriBaseAddress(object obj, Uri baseAddress);
    [EventAttribute("5")]
private void UriBaseAddress(string uriBaseAddress, string objName);
    [NonEventAttribute]
public static void ContentNull(object obj);
    [EventAttribute("6")]
private void ContentNull(string objName, int objHash);
    [EventAttribute("7")]
public void HeadersInvalidValue(string name, string rawValue);
    [EventAttribute("8")]
public void HandlerMessage(int poolId, int workerId, int requestId, string memberName, string message);
    [EventAttribute("11")]
public void HandlerMessageError(int poolId, int workerId, int requestId, string memberName, string message);
    [NonEventAttribute]
public static void AuthenticationInfo(Uri uri, string message);
    [EventAttribute("9")]
public void AuthenticationInfo(string uri, string message);
    [NonEventAttribute]
public static void AuthenticationError(Uri uri, string message);
    [EventAttribute("10")]
public void AuthenticationError(string uri, string message);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, int arg1, int arg2, int arg3, string arg4, string arg5);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
}
internal static class System.Net.Security.CertificateHelper : object {
    internal static X509Certificate2 GetEligibleClientCertificate(X509CertificateCollection candidateCerts);
    internal static X509Certificate2 GetEligibleClientCertificate(X509Certificate2Collection candidateCerts);
    private static bool IsValidClientCertificate(X509Certificate2 cert);
    private static bool IsValidForClientAuthenticationEKU(X509EnhancedKeyUsageExtension eku);
    private static bool IsValidForDigitalSignatureUsage(X509KeyUsageExtension ku);
    internal static X509Certificate2 GetEligibleClientCertificate();
}
[ExtensionAttribute]
internal static class System.Net.Security.SslClientAuthenticationOptionsExtensions : object {
    [ExtensionAttribute]
public static SslClientAuthenticationOptions ShallowClone(SslClientAuthenticationOptions options);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_http_httpmethod_format_error { get; }
    internal static string net_http_reasonphrase_format_error { get; }
    internal static string net_http_copyto_array_too_small { get; }
    internal static string net_http_headers_not_found { get; }
    internal static string net_http_headers_single_value_header { get; }
    internal static string net_http_headers_invalid_header_name { get; }
    internal static string net_http_headers_invalid_value { get; }
    internal static string net_http_headers_not_allowed_header_name { get; }
    internal static string net_http_headers_invalid_host_header { get; }
    internal static string net_http_headers_invalid_etag_name { get; }
    internal static string net_http_headers_invalid_range { get; }
    internal static string net_http_headers_no_newlines { get; }
    internal static string net_http_content_buffersize_exceeded { get; }
    internal static string net_http_content_no_task_returned { get; }
    internal static string net_http_content_stream_already_read { get; }
    internal static string net_http_content_readonly_stream { get; }
    internal static string net_http_content_writeonly_stream { get; }
    internal static string net_http_content_invalid_charset { get; }
    internal static string net_http_content_stream_copy_error { get; }
    internal static string net_http_content_read_as_stream_has_task { get; }
    internal static string net_http_client_request_already_sent { get; }
    internal static string net_http_operation_started { get; }
    internal static string net_http_client_execution_error { get; }
    internal static string net_http_client_absolute_baseaddress_required { get; }
    internal static string net_http_client_invalid_requesturi { get; }
    internal static string net_http_unsupported_requesturi_scheme { get; }
    internal static string net_http_parser_invalid_base64_string { get; }
    internal static string net_http_handler_noresponse { get; }
    internal static string net_http_message_not_success_statuscode { get; }
    internal static string net_http_message_not_success_statuscode_reason { get; }
    internal static string net_http_content_field_too_long { get; }
    internal static string net_http_log_headers_no_newlines { get; }
    internal static string net_http_log_headers_invalid_quality { get; }
    internal static string net_http_handler_not_assigned { get; }
    internal static string net_http_invalid_enable_first { get; }
    internal static string net_http_content_buffersize_limit { get; }
    internal static string net_http_chunked_not_allowed_with_empty_content { get; }
    internal static string net_http_value_must_be_greater_than_or_equal { get; }
    internal static string net_http_invalid_response { get; }
    internal static string net_http_request_content_length_mismatch { get; }
    internal static string net_http_invalid_response_premature_eof { get; }
    internal static string net_http_invalid_response_missing_frame { get; }
    internal static string net_http_invalid_response_premature_eof_bytecount { get; }
    internal static string net_http_invalid_response_chunk_header_invalid { get; }
    internal static string net_http_invalid_response_chunk_extension_invalid { get; }
    internal static string net_http_invalid_response_chunk_terminator_invalid { get; }
    internal static string net_http_invalid_response_status_line { get; }
    internal static string net_http_invalid_response_status_code { get; }
    internal static string net_http_invalid_response_status_reason { get; }
    internal static string net_http_invalid_response_multiple_status_codes { get; }
    internal static string net_http_invalid_response_header_line { get; }
    internal static string net_http_invalid_response_header_name { get; }
    internal static string net_http_request_aborted { get; }
    internal static string net_http_invalid_response_pseudo_header_in_trailer { get; }
    internal static string net_http_request_headers_exceeded_length { get; }
    internal static string net_http_response_headers_exceeded_length { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string net_http_invalid_proxy_scheme { get; }
    internal static string net_http_request_invalid_char_encoding { get; }
    internal static string net_http_ssl_connection_failed { get; }
    internal static string net_http_unsupported_chunking { get; }
    internal static string net_http_unsupported_version { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string net_ssl_http2_requires_tls12 { get; }
    internal static string net_http_request_no_host { get; }
    internal static string net_http_http2_connection_error { get; }
    internal static string net_http_http2_connection_close { get; }
    internal static string net_http_http2_stream_error { get; }
    internal static string net_http_http3_stream_error { get; }
    internal static string net_http_http2_connection_not_established { get; }
    internal static string net_http_http2_invalidinitialstreamwindowsize { get; }
    internal static string net_http_authconnectionfailure { get; }
    internal static string net_http_authvalidationfailure { get; }
    internal static string net_http_hpack_huffman_decode_failed { get; }
    internal static string net_http_hpack_incomplete_header_block { get; }
    internal static string net_http_hpack_late_dynamic_table_size_update { get; }
    internal static string net_http_hpack_bad_integer { get; }
    internal static string net_http_disposed_while_in_use { get; }
    internal static string net_http_hpack_large_table_size_update { get; }
    internal static string net_http_server_shutdown { get; }
    internal static string net_http_hpack_invalid_index { get; }
    internal static string net_http_hpack_unexpected_end { get; }
    internal static string net_http_headers_exceeded_length { get; }
    internal static string net_http_invalid_header_name { get; }
    internal static string net_http_http3_connection_error { get; }
    internal static string net_http_http3_connection_close { get; }
    internal static string net_http_retry_on_older_version { get; }
    internal static string net_http_content_write_larger_than_content_length { get; }
    internal static string net_http_qpack_no_dynamic_table { get; }
    internal static string net_http_request_timedout { get; }
    internal static string net_http_connect_timedout { get; }
    internal static string net_http_missing_sync_implementation { get; }
    internal static string net_http_http2_sync_not_supported { get; }
    internal static string net_http_upgrade_not_enabled_sync { get; }
    internal static string net_http_requested_version_cannot_establish { get; }
    internal static string net_http_requested_version_server_refused { get; }
    internal static string net_http_exception_during_plaintext_filter { get; }
    internal static string net_http_null_from_connect_callback { get; }
    internal static string net_http_null_from_plaintext_filter { get; }
    internal static string net_socks_auth_failed { get; }
    internal static string net_socks_bad_address_type { get; }
    internal static string net_socks_connection_failed { get; }
    internal static string net_socks_ipv6_notsupported { get; }
    internal static string net_socks_no_auth_method { get; }
    internal static string net_socks_no_ipv4_address { get; }
    internal static string net_socks_unexpected_version { get; }
    internal static string net_socks_string_too_long { get; }
    internal static string net_socks_auth_required { get; }
    internal static string net_http_proxy_tunnel_returned_failure_status_code { get; }
    internal static string net_http_proxy_tunnel_error { get; }
    internal static string net_http_chunk_too_large { get; }
    internal static string net_unsupported_extended_connect { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_http_httpmethod_format_error();
    internal static string get_net_http_reasonphrase_format_error();
    internal static string get_net_http_copyto_array_too_small();
    internal static string get_net_http_headers_not_found();
    internal static string get_net_http_headers_single_value_header();
    internal static string get_net_http_headers_invalid_header_name();
    internal static string get_net_http_headers_invalid_value();
    internal static string get_net_http_headers_not_allowed_header_name();
    internal static string get_net_http_headers_invalid_host_header();
    internal static string get_net_http_headers_invalid_etag_name();
    internal static string get_net_http_headers_invalid_range();
    internal static string get_net_http_headers_no_newlines();
    internal static string get_net_http_content_buffersize_exceeded();
    internal static string get_net_http_content_no_task_returned();
    internal static string get_net_http_content_stream_already_read();
    internal static string get_net_http_content_readonly_stream();
    internal static string get_net_http_content_writeonly_stream();
    internal static string get_net_http_content_invalid_charset();
    internal static string get_net_http_content_stream_copy_error();
    internal static string get_net_http_content_read_as_stream_has_task();
    internal static string get_net_http_client_request_already_sent();
    internal static string get_net_http_operation_started();
    internal static string get_net_http_client_execution_error();
    internal static string get_net_http_client_absolute_baseaddress_required();
    internal static string get_net_http_client_invalid_requesturi();
    internal static string get_net_http_unsupported_requesturi_scheme();
    internal static string get_net_http_parser_invalid_base64_string();
    internal static string get_net_http_handler_noresponse();
    internal static string get_net_http_message_not_success_statuscode();
    internal static string get_net_http_message_not_success_statuscode_reason();
    internal static string get_net_http_content_field_too_long();
    internal static string get_net_http_log_headers_no_newlines();
    internal static string get_net_http_log_headers_invalid_quality();
    internal static string get_net_http_handler_not_assigned();
    internal static string get_net_http_invalid_enable_first();
    internal static string get_net_http_content_buffersize_limit();
    internal static string get_net_http_chunked_not_allowed_with_empty_content();
    internal static string get_net_http_value_must_be_greater_than_or_equal();
    internal static string get_net_http_invalid_response();
    internal static string get_net_http_request_content_length_mismatch();
    internal static string get_net_http_invalid_response_premature_eof();
    internal static string get_net_http_invalid_response_missing_frame();
    internal static string get_net_http_invalid_response_premature_eof_bytecount();
    internal static string get_net_http_invalid_response_chunk_header_invalid();
    internal static string get_net_http_invalid_response_chunk_extension_invalid();
    internal static string get_net_http_invalid_response_chunk_terminator_invalid();
    internal static string get_net_http_invalid_response_status_line();
    internal static string get_net_http_invalid_response_status_code();
    internal static string get_net_http_invalid_response_status_reason();
    internal static string get_net_http_invalid_response_multiple_status_codes();
    internal static string get_net_http_invalid_response_header_line();
    internal static string get_net_http_invalid_response_header_name();
    internal static string get_net_http_request_aborted();
    internal static string get_net_http_invalid_response_pseudo_header_in_trailer();
    internal static string get_net_http_request_headers_exceeded_length();
    internal static string get_net_http_response_headers_exceeded_length();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_net_http_invalid_proxy_scheme();
    internal static string get_net_http_request_invalid_char_encoding();
    internal static string get_net_http_ssl_connection_failed();
    internal static string get_net_http_unsupported_chunking();
    internal static string get_net_http_unsupported_version();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_net_ssl_http2_requires_tls12();
    internal static string get_net_http_request_no_host();
    internal static string get_net_http_http2_connection_error();
    internal static string get_net_http_http2_connection_close();
    internal static string get_net_http_http2_stream_error();
    internal static string get_net_http_http3_stream_error();
    internal static string get_net_http_http2_connection_not_established();
    internal static string get_net_http_http2_invalidinitialstreamwindowsize();
    internal static string get_net_http_authconnectionfailure();
    internal static string get_net_http_authvalidationfailure();
    internal static string get_net_http_hpack_huffman_decode_failed();
    internal static string get_net_http_hpack_incomplete_header_block();
    internal static string get_net_http_hpack_late_dynamic_table_size_update();
    internal static string get_net_http_hpack_bad_integer();
    internal static string get_net_http_disposed_while_in_use();
    internal static string get_net_http_hpack_large_table_size_update();
    internal static string get_net_http_server_shutdown();
    internal static string get_net_http_hpack_invalid_index();
    internal static string get_net_http_hpack_unexpected_end();
    internal static string get_net_http_headers_exceeded_length();
    internal static string get_net_http_invalid_header_name();
    internal static string get_net_http_http3_connection_error();
    internal static string get_net_http_http3_connection_close();
    internal static string get_net_http_retry_on_older_version();
    internal static string get_net_http_content_write_larger_than_content_length();
    internal static string get_net_http_qpack_no_dynamic_table();
    internal static string get_net_http_request_timedout();
    internal static string get_net_http_connect_timedout();
    internal static string get_net_http_missing_sync_implementation();
    internal static string get_net_http_http2_sync_not_supported();
    internal static string get_net_http_upgrade_not_enabled_sync();
    internal static string get_net_http_requested_version_cannot_establish();
    internal static string get_net_http_requested_version_server_refused();
    internal static string get_net_http_exception_during_plaintext_filter();
    internal static string get_net_http_null_from_connect_callback();
    internal static string get_net_http_null_from_plaintext_filter();
    internal static string get_net_socks_auth_failed();
    internal static string get_net_socks_bad_address_type();
    internal static string get_net_socks_connection_failed();
    internal static string get_net_socks_ipv6_notsupported();
    internal static string get_net_socks_no_auth_method();
    internal static string get_net_socks_no_ipv4_address();
    internal static string get_net_socks_unexpected_version();
    internal static string get_net_socks_string_too_long();
    internal static string get_net_socks_auth_required();
    internal static string get_net_http_proxy_tunnel_returned_failure_status_code();
    internal static string get_net_http_proxy_tunnel_error();
    internal static string get_net_http_chunk_too_large();
    internal static string get_net_unsupported_extended_connect();
}
internal static class System.Text.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public virtual string ToString();
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
    internal void AppendSpanFormattable(T value, string format, IFormatProvider provider);
}
internal class System.Threading.Tasks.TaskCompletionSourceWithCancellation`1 : TaskCompletionSource`1<T> {
    [AsyncStateMachineAttribute("System.Threading.Tasks.TaskCompletionSourceWithCancellation`1/<WaitWithCancellationAsync>d__1")]
public ValueTask`1<T> WaitWithCancellationAsync(CancellationToken cancellationToken);
    public T WaitWithCancellation(CancellationToken cancellationToken);
    public ValueTask`1<T> WaitWithCancellationAsync(bool async, CancellationToken cancellationToken);
}
