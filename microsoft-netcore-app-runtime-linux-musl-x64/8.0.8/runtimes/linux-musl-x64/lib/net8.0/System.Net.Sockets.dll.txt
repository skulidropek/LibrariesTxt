internal static class FxResources.System.Net.Sockets.SR : object {
}
internal static class Interop : object {
}
[ExtensionAttribute]
internal static class InteropErrorExtensions : object {
    [ExtensionAttribute]
public static ErrorInfo Info(Error error);
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal class System.Net.InternalException : Exception {
    private object _unexpectedValue;
    public string Message { get; }
    internal InternalException(object unexpectedValue);
    public virtual string get_Message();
}
[ExtensionAttribute]
internal static class System.Net.InteropIPAddressExtensions : object {
    [ExtensionAttribute]
public static IPAddress GetNativeIPAddress(IPAddress ipAddress);
    [ExtensionAttribute]
public static IPAddress GetIPAddress(IPAddress nativeIPAddress);
}
internal static class System.Net.IPEndPointStatics : object {
    internal static IPEndPoint Any;
    internal static IPEndPoint IPv6Any;
    private static IPEndPointStatics();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void Accepted(Socket socket, object remoteEp, object localEp);
    [EventAttribute("5")]
private void Accepted(string remoteEp, string localEp, int socketHash);
    [NonEventAttribute]
public static void Connected(Socket socket, object localEp, object remoteEp);
    [EventAttribute("6")]
private void Connected(string localEp, string remoteEp, int socketHash);
    [NonEventAttribute]
public static void ConnectedAsyncDns(Socket socket);
    [EventAttribute("7")]
private void ConnectedAsyncDns(int socketHash);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Memory`1<byte> buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, ReadOnlySpan`1<byte> buffer, string memberName);
    [EventAttribute("4")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
}
internal static class System.Net.RangeValidationHelpers : object {
    public static bool ValidateRange(int actual, int fromAllowed, int toAllowed);
    public static void ValidateSegment(ArraySegment`1<byte> segment);
}
internal static class System.Net.SocketAddressPal : object {
    public static int IPv4AddressSize;
    public static int IPv6AddressSize;
    public static int UdsAddressSize;
    public static int MaxAddressSize;
    private static SocketAddressPal();
    private static void ThrowOnFailure(Error err);
    public static AddressFamily GetAddressFamily(ReadOnlySpan`1<byte> buffer);
    public static void SetAddressFamily(Span`1<byte> buffer, AddressFamily family);
    public static ushort GetPort(ReadOnlySpan`1<byte> buffer);
    public static void SetPort(Span`1<byte> buffer, ushort port);
    public static UInt32 GetIPv4Address(ReadOnlySpan`1<byte> buffer);
    public static void GetIPv6Address(ReadOnlySpan`1<byte> buffer, Span`1<byte> address, UInt32& scope);
    public static void SetIPv4Address(Span`1<byte> buffer, UInt32 address);
    public static void SetIPv6Address(Span`1<byte> buffer, Span`1<byte> address, UInt32 scope);
    public static void SetIPv6Address(Span`1<byte> buffer, Byte* address, int addressLength, UInt32 scope);
    public static void Clear(Span`1<byte> buffer);
}
internal static class System.Net.SocketProtocolSupportPal : object {
    [CompilerGeneratedAttribute]
private static bool <OSSupportsIPv6>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OSSupportsIPv4>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <OSSupportsUnixDomainSockets>k__BackingField;
    public static bool OSSupportsIPv6 { get; }
    public static bool OSSupportsIPv4 { get; }
    public static bool OSSupportsUnixDomainSockets { get; }
    private static SocketProtocolSupportPal();
    [CompilerGeneratedAttribute]
public static bool get_OSSupportsIPv6();
    [CompilerGeneratedAttribute]
public static bool get_OSSupportsIPv4();
    [CompilerGeneratedAttribute]
public static bool get_OSSupportsUnixDomainSockets();
    private static bool IsIPv6Disabled();
    private static bool IsSupported(AddressFamily af);
}
public enum System.Net.Sockets.IOControlCode : Enum {
    public long value__;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AsyncIO;
    public static IOControlCode NonBlockingIO;
    public static IOControlCode DataToRead;
    public static IOControlCode OobDataRead;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AssociateHandle;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode EnableCircularQueuing;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode Flush;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode GetBroadcastAddress;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode GetExtensionFunctionPointer;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode GetQos;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode GetGroupQos;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode MultipointLoopback;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode MulticastScope;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode SetQos;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode SetGroupQos;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode TranslateHandle;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode RoutingInterfaceQuery;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode RoutingInterfaceChange;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AddressListQuery;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AddressListChange;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode QueryTargetPnpHandle;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode NamespaceChange;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AddressListSort;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode ReceiveAll;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode ReceiveAllMulticast;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode ReceiveAllIgmpMulticast;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode KeepAliveValues;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AbsorbRouterAlert;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode UnicastInterface;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode LimitBroadcasts;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode BindToInterface;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode MulticastInterface;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode AddMulticastGroupOnInterface;
    [SupportedOSPlatformAttribute("windows")]
public static IOControlCode DeleteMulticastGroupFromInterface;
}
[ExtensionAttribute]
internal static class System.Net.Sockets.IPEndPointExtensions : object {
    public static IPAddress GetIPAddress(ReadOnlySpan`1<byte> socketAddressBuffer);
    public static void SetIPAddress(Span`1<byte> socketAddressBuffer, IPAddress address);
    public static IPEndPoint CreateIPEndPoint(ReadOnlySpan`1<byte> socketAddressBuffer);
    [ExtensionAttribute]
public static void Serialize(IPEndPoint endPoint, Span`1<byte> destination);
    [ExtensionAttribute]
public static bool Equals(IPEndPoint endPoint, ReadOnlySpan`1<byte> socketAddressBuffer);
}
public class System.Net.Sockets.IPPacketInformation : ValueType {
    private IPAddress _address;
    private int _networkInterface;
    [NullableAttribute("1")]
public IPAddress Address { get; }
    public int Interface { get; }
    internal IPPacketInformation(IPAddress address, int networkInterface);
    [NullableContextAttribute("1")]
public IPAddress get_Address();
    public int get_Interface();
    public static bool op_Equality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    public static bool op_Inequality(IPPacketInformation packetInformation1, IPPacketInformation packetInformation2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object comparand);
    public sealed virtual bool Equals(IPPacketInformation other);
    public virtual int GetHashCode();
}
public enum System.Net.Sockets.IPProtectionLevel : Enum {
    public int value__;
    public static IPProtectionLevel Unspecified;
    public static IPProtectionLevel Unrestricted;
    public static IPProtectionLevel EdgeRestricted;
    public static IPProtectionLevel Restricted;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.IPv6MulticastOption : object {
    private IPAddress _group;
    private long _interface;
    public IPAddress Group { get; public set; }
    public long InterfaceIndex { get; public set; }
    public IPv6MulticastOption(IPAddress group, long ifindex);
    public IPv6MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    public long get_InterfaceIndex();
    public void set_InterfaceIndex(long value);
}
public class System.Net.Sockets.LingerOption : object {
    private bool _enabled;
    private int _lingerTime;
    public bool Enabled { get; public set; }
    public int LingerTime { get; public set; }
    public LingerOption(bool enable, int seconds);
    public bool get_Enabled();
    public void set_Enabled(bool value);
    public int get_LingerTime();
    public void set_LingerTime(int value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object comparand);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.MulticastOption : object {
    private IPAddress _group;
    private IPAddress _localAddress;
    private int _ifIndex;
    public IPAddress Group { get; public set; }
    [NullableAttribute("2")]
public IPAddress LocalAddress { get; public set; }
    public int InterfaceIndex { get; public set; }
    public MulticastOption(IPAddress group, IPAddress mcint);
    public MulticastOption(IPAddress group, int interfaceIndex);
    public MulticastOption(IPAddress group);
    public IPAddress get_Group();
    public void set_Group(IPAddress value);
    [NullableContextAttribute("2")]
public IPAddress get_LocalAddress();
    [NullableContextAttribute("2")]
public void set_LocalAddress(IPAddress value);
    public int get_InterfaceIndex();
    public void set_InterfaceIndex(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.NetworkStream : Stream {
    private Socket _streamSocket;
    private bool _ownsSocket;
    private bool _readable;
    private bool _writeable;
    private int _disposed;
    private int _closeTimeout;
    private int _currentReadTimeout;
    private int _currentWriteTimeout;
    public Socket Socket { get; }
    protected bool Readable { get; protected set; }
    protected bool Writeable { get; protected set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool DataAvailable { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public NetworkStream(Socket socket);
    public NetworkStream(Socket socket, bool ownsSocket);
    public NetworkStream(Socket socket, FileAccess access);
    public NetworkStream(Socket socket, FileAccess access, bool ownsSocket);
    public Socket get_Socket();
    protected bool get_Readable();
    protected void set_Readable(bool value);
    protected bool get_Writeable();
    protected void set_Writeable(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_DataAvailable();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public void Close(int timeout);
    public void Close(TimeSpan timeout);
    private static int ToTimeoutMilliseconds(TimeSpan timeout);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(SocketShutdown mode, int timeout, bool silent);
    private void ThrowIfDisposed();
    private static IOException WrapException(string resourceFormatString, Exception innerException);
}
public enum System.Net.Sockets.ProtocolFamily : Enum {
    public int value__;
    public static ProtocolFamily Unknown;
    public static ProtocolFamily Unspecified;
    public static ProtocolFamily Unix;
    public static ProtocolFamily InterNetwork;
    public static ProtocolFamily ImpLink;
    public static ProtocolFamily Pup;
    public static ProtocolFamily Chaos;
    public static ProtocolFamily NS;
    public static ProtocolFamily Ipx;
    public static ProtocolFamily Iso;
    public static ProtocolFamily Osi;
    public static ProtocolFamily Ecma;
    public static ProtocolFamily DataKit;
    public static ProtocolFamily Ccitt;
    public static ProtocolFamily Sna;
    public static ProtocolFamily DecNet;
    public static ProtocolFamily DataLink;
    public static ProtocolFamily Lat;
    public static ProtocolFamily HyperChannel;
    public static ProtocolFamily AppleTalk;
    public static ProtocolFamily NetBios;
    public static ProtocolFamily VoiceView;
    public static ProtocolFamily FireFox;
    public static ProtocolFamily Banyan;
    public static ProtocolFamily Atm;
    public static ProtocolFamily InterNetworkV6;
    public static ProtocolFamily Cluster;
    public static ProtocolFamily Ieee12844;
    public static ProtocolFamily Irda;
    public static ProtocolFamily NetworkDesigners;
    public static ProtocolFamily Max;
    public static ProtocolFamily Packet;
    public static ProtocolFamily ControllerAreaNetwork;
}
public enum System.Net.Sockets.ProtocolType : Enum {
    public int value__;
    public static ProtocolType IP;
    public static ProtocolType IPv6HopByHopOptions;
    public static ProtocolType Icmp;
    public static ProtocolType Igmp;
    public static ProtocolType Ggp;
    public static ProtocolType IPv4;
    public static ProtocolType Tcp;
    public static ProtocolType Pup;
    public static ProtocolType Udp;
    public static ProtocolType Idp;
    public static ProtocolType IPv6;
    public static ProtocolType IPv6RoutingHeader;
    public static ProtocolType IPv6FragmentHeader;
    public static ProtocolType IPSecEncapsulatingSecurityPayload;
    public static ProtocolType IPSecAuthenticationHeader;
    public static ProtocolType IcmpV6;
    public static ProtocolType IPv6NoNextHeader;
    public static ProtocolType IPv6DestinationOptions;
    public static ProtocolType ND;
    public static ProtocolType Raw;
    public static ProtocolType Unspecified;
    public static ProtocolType Ipx;
    public static ProtocolType Spx;
    public static ProtocolType SpxII;
    public static ProtocolType Unknown;
}
public class System.Net.Sockets.SafeSocketHandle : SafeHandleMinusOneIsInvalid {
    private int _ownClose;
    [CompilerGeneratedAttribute]
private bool <OwnsHandle>k__BackingField;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _released;
    private bool _hasShutdownSend;
    private int _receiveTimeout;
    private int _sendTimeout;
    private bool _nonBlocking;
    private SocketAsyncContext _asyncContext;
    private TrackedSocketOptions _trackedOptions;
    [CompilerGeneratedAttribute]
private bool <LastConnectFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DualMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExposedHandleOrUntrackedConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferInlineCompletions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSocket>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisconnected>k__BackingField;
    internal bool OwnsHandle { get; }
    internal bool HasShutdownSend { get; }
    public bool IsInvalid { get; }
    internal bool LastConnectFailed { get; internal set; }
    internal bool DualMode { get; internal set; }
    internal bool ExposedHandleOrUntrackedConfiguration { get; private set; }
    internal bool PreferInlineCompletions { get; internal set; }
    internal bool IsSocket { get; internal set; }
    [NullableAttribute("1")]
internal SocketAsyncContext AsyncContext { get; }
    internal bool IsNonBlocking { get; internal set; }
    internal bool IsUnderlyingHandleBlocking { get; }
    internal int ReceiveTimeout { get; internal set; }
    internal int SendTimeout { get; internal set; }
    internal bool IsDisconnected { get; private set; }
    public SafeSocketHandle(IntPtr preexistingHandle, bool ownsHandle);
    [CompilerGeneratedAttribute]
internal bool get_OwnsHandle();
    internal bool get_HasShutdownSend();
    private bool TryOwnClose();
    internal void TrackShutdown(SocketShutdown how);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    internal void CloseAsIs(bool abortive);
    private bool CloseHandle(bool abortive, bool canceledOperations);
    private void SetHandleAndValid(IntPtr handle);
    [CompilerGeneratedAttribute]
internal bool get_LastConnectFailed();
    [CompilerGeneratedAttribute]
internal void set_LastConnectFailed(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DualMode();
    [CompilerGeneratedAttribute]
internal void set_DualMode(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ExposedHandleOrUntrackedConfiguration();
    [CompilerGeneratedAttribute]
private void set_ExposedHandleOrUntrackedConfiguration(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PreferInlineCompletions();
    [CompilerGeneratedAttribute]
internal void set_PreferInlineCompletions(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsSocket();
    [CompilerGeneratedAttribute]
internal void set_IsSocket(bool value);
    internal void RegisterConnectResult(SocketError error);
    internal void TransferTrackedState(SafeSocketHandle target);
    internal void SetExposed();
    internal bool IsTrackedOption(TrackedSocketOptions option);
    internal void TrackOption(SocketOptionLevel level, SocketOptionName name);
    internal SocketAsyncContext get_AsyncContext();
    internal bool get_IsNonBlocking();
    internal void set_IsNonBlocking(bool value);
    internal bool get_IsUnderlyingHandleBlocking();
    internal int get_ReceiveTimeout();
    internal void set_ReceiveTimeout(int value);
    internal int get_SendTimeout();
    internal void set_SendTimeout(int value);
    [CompilerGeneratedAttribute]
internal bool get_IsDisconnected();
    [CompilerGeneratedAttribute]
private void set_IsDisconnected(bool value);
    internal void SetToDisconnected();
    private bool OnHandleClose();
    private bool TryUnblockSocket(bool abortive);
    private SocketError DoCloseHandle(bool abortive);
    private Error CloseHandle(IntPtr handle);
}
public enum System.Net.Sockets.SelectMode : Enum {
    public int value__;
    public static SelectMode SelectRead;
    public static SelectMode SelectWrite;
    public static SelectMode SelectError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.SendPacketsElement : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private FileStream <FileStream>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<byte>> <MemoryBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private long <OffsetLong>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EndOfPacket>k__BackingField;
    [NullableAttribute("2")]
public string FilePath { get; private set; }
    [NullableAttribute("2")]
public FileStream FileStream { get; private set; }
    [NullableAttribute("2")]
public Byte[] Buffer { get; private set; }
    public int Count { get; private set; }
    [NullableAttribute("0")]
public Nullable`1<ReadOnlyMemory`1<byte>> MemoryBuffer { get; private set; }
    public int Offset { get; }
    public long OffsetLong { get; private set; }
    public bool EndOfPacket { get; private set; }
    public SendPacketsElement(string filepath);
    public SendPacketsElement(string filepath, int offset, int count);
    public SendPacketsElement(string filepath, int offset, int count, bool endOfPacket);
    public SendPacketsElement(string filepath, long offset, int count);
    public SendPacketsElement(string filepath, long offset, int count, bool endOfPacket);
    public SendPacketsElement(FileStream fileStream);
    public SendPacketsElement(FileStream fileStream, long offset, int count);
    public SendPacketsElement(FileStream fileStream, long offset, int count, bool endOfPacket);
    public SendPacketsElement(Byte[] buffer);
    public SendPacketsElement(Byte[] buffer, int offset, int count);
    public SendPacketsElement(Byte[] buffer, int offset, int count, bool endOfPacket);
    [NullableContextAttribute("0")]
public SendPacketsElement(ReadOnlyMemory`1<byte> buffer);
    [NullableContextAttribute("0")]
public SendPacketsElement(ReadOnlyMemory`1<byte> buffer, bool endOfPacket);
    private void Initialize(string filePath, FileStream fileStream, Byte[] buffer, Nullable`1<ReadOnlyMemory`1<byte>> memoryBuffer, long offset, int count, bool endOfPacket);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FileStream get_FileStream();
    [CompilerGeneratedAttribute]
private void set_FileStream(FileStream value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    [CompilerGeneratedAttribute]
private void set_Buffer(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> get_MemoryBuffer();
    [CompilerGeneratedAttribute]
private void set_MemoryBuffer(Nullable`1<ReadOnlyMemory`1<byte>> value);
    public int get_Offset();
    [CompilerGeneratedAttribute]
public long get_OffsetLong();
    [CompilerGeneratedAttribute]
private void set_OffsetLong(long value);
    [CompilerGeneratedAttribute]
public bool get_EndOfPacket();
    [CompilerGeneratedAttribute]
private void set_EndOfPacket(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.Socket : object {
    private static IPAddress s_IPAddressAnyMapToIPv6;
    private static IPEndPoint s_IPEndPointIPv6;
    private SafeSocketHandle _handle;
    internal EndPoint _rightEndPoint;
    internal EndPoint _remoteEndPoint;
    private EndPoint _localEndPoint;
    private bool _isConnected;
    private bool _isDisconnected;
    private bool _willBlock;
    private bool _willBlockInternal;
    private bool _isListening;
    private bool _nonBlockingConnectInProgress;
    private EndPoint _pendingConnectRightEndPoint;
    private AddressFamily _addressFamily;
    private SocketType _socketType;
    private ProtocolType _protocolType;
    private bool _receivingPacketInformation;
    private int _closeTimeout;
    private int _disposed;
    private AwaitableSocketAsyncEventArgs _singleBufferReceiveEventArgs;
    private AwaitableSocketAsyncEventArgs _singleBufferSendEventArgs;
    private TaskSocketAsyncEventArgs`1<int> _multiBufferReceiveEventArgs;
    private TaskSocketAsyncEventArgs`1<int> _multiBufferSendEventArgs;
    [ObsoleteAttribute("SupportsIPv4 has been deprecated. Use OSSupportsIPv4 instead.")]
public static bool SupportsIPv4 { get; }
    [ObsoleteAttribute("SupportsIPv6 has been deprecated. Use OSSupportsIPv6 instead.")]
public static bool SupportsIPv6 { get; }
    public static bool OSSupportsIPv4 { get; }
    public static bool OSSupportsIPv6 { get; }
    public static bool OSSupportsUnixDomainSockets { get; }
    public int Available { get; }
    [NullableAttribute("2")]
public EndPoint LocalEndPoint { get; }
    [NullableAttribute("2")]
public EndPoint RemoteEndPoint { get; }
    public IntPtr Handle { get; }
    public SafeSocketHandle SafeHandle { get; }
    internal SafeSocketHandle InternalSafeHandle { get; }
    public bool Blocking { get; public set; }
    [ObsoleteAttribute("UseOnlyOverlappedIO has been deprecated and is not supported.")]
[EditorBrowsableAttribute("1")]
public bool UseOnlyOverlappedIO { get; public set; }
    public bool Connected { get; }
    public AddressFamily AddressFamily { get; }
    public SocketType SocketType { get; }
    public ProtocolType ProtocolType { get; }
    public bool IsBound { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    [NullableAttribute("2")]
public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool DualMode { get; public set; }
    private bool IsDualMode { get; }
    internal bool Disposed { get; }
    private bool IsConnectionOriented { get; }
    unknown bool PreferInlineCompletions {internal set; }
    public Socket(SocketType socketType, ProtocolType protocolType);
    public Socket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType);
    public Socket(SafeSocketHandle handle);
    private Socket(SafeSocketHandle handle, bool loadPropertiesFromHandle);
    [SupportedOSPlatformAttribute("windows")]
public Socket(SocketInformation socketInformation);
    private static Socket();
    private static SafeSocketHandle ValidateHandle(SafeSocketHandle handle);
    public static bool get_SupportsIPv4();
    public static bool get_SupportsIPv6();
    public static bool get_OSSupportsIPv4();
    public static bool get_OSSupportsIPv6();
    public static bool get_OSSupportsUnixDomainSockets();
    public int get_Available();
    [NullableContextAttribute("2")]
public EndPoint get_LocalEndPoint();
    [NullableContextAttribute("2")]
public EndPoint get_RemoteEndPoint();
    public IntPtr get_Handle();
    public SafeSocketHandle get_SafeHandle();
    internal SafeSocketHandle get_InternalSafeHandle();
    public bool get_Blocking();
    public void set_Blocking(bool value);
    public bool get_UseOnlyOverlappedIO();
    public void set_UseOnlyOverlappedIO(bool value);
    public bool get_Connected();
    public AddressFamily get_AddressFamily();
    public SocketType get_SocketType();
    public ProtocolType get_ProtocolType();
    public bool get_IsBound();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    [NullableContextAttribute("2")]
public LingerOption get_LingerState();
    [NullableContextAttribute("2")]
public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_DualMode();
    public void set_DualMode(bool value);
    private bool get_IsDualMode();
    internal bool CanTryAddressFamily(AddressFamily family);
    public void Bind(EndPoint localEP);
    private void DoBind(EndPoint endPointSnapshot, SocketAddress socketAddress);
    public void Connect(EndPoint remoteEP);
    public void Connect(IPAddress address, int port);
    public void Connect(string host, int port);
    public void Connect(IPAddress[] addresses, int port);
    public void Close();
    public void Close(int timeout);
    public void Listen();
    public void Listen(int backlog);
    public Socket Accept();
    public int Send(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, SocketFlags socketFlags);
    public int Send(Byte[] buffer);
    public int Send(IList`1<ArraySegment`1<byte>> buffers);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Send(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    [NullableContextAttribute("0")]
public int Send(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags);
    [NullableContextAttribute("0")]
public int Send(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode);
    [NullableContextAttribute("2")]
public void SendFile(string fileName);
    [NullableContextAttribute("2")]
public void SendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags);
    [NullableContextAttribute("0")]
public void SendFile(string fileName, ReadOnlySpan`1<byte> preBuffer, ReadOnlySpan`1<byte> postBuffer, TransmitFileOptions flags);
    public int SendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, SocketFlags socketFlags, EndPoint remoteEP);
    public int SendTo(Byte[] buffer, EndPoint remoteEP);
    [NullableContextAttribute("0")]
public int SendTo(ReadOnlySpan`1<byte> buffer, EndPoint remoteEP);
    [NullableContextAttribute("0")]
public int SendTo(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
    [NullableContextAttribute("0")]
public int SendTo(ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, SocketAddress socketAddress);
    public int Receive(Byte[] buffer, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, SocketFlags socketFlags);
    public int Receive(Byte[] buffer);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags);
    public int Receive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode);
    [NullableContextAttribute("0")]
public int Receive(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public int Receive(Span`1<byte> buffer, SocketFlags socketFlags);
    [NullableContextAttribute("0")]
public int Receive(Span`1<byte> buffer, SocketFlags socketFlags, SocketError& errorCode);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public int Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode);
    public int ReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation);
    [NullableContextAttribute("0")]
public int ReceiveMessageFrom(Span`1<byte> buffer, SocketFlags& socketFlags, EndPoint& remoteEP, IPPacketInformation& ipPacketInformation);
    public int ReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, int size, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, SocketFlags socketFlags, EndPoint& remoteEP);
    public int ReceiveFrom(Byte[] buffer, EndPoint& remoteEP);
    [NullableContextAttribute("0")]
public int ReceiveFrom(Span`1<byte> buffer, EndPoint& remoteEP);
    [NullableContextAttribute("0")]
public int ReceiveFrom(Span`1<byte> buffer, SocketFlags socketFlags, EndPoint& remoteEP);
    [NullableContextAttribute("0")]
public int ReceiveFrom(Span`1<byte> buffer, SocketFlags socketFlags, SocketAddress receivedAddress);
    [NullableContextAttribute("2")]
public int IOControl(int ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    [NullableContextAttribute("2")]
public int IOControl(IOControlCode ioControlCode, Byte[] optionInValue, Byte[] optionOutValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, bool optionValue);
    public void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, object optionValue);
    [NullableContextAttribute("0")]
public void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan`1<byte> optionValue);
    [NullableContextAttribute("2")]
public object GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName);
    public void GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public Byte[] GetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionLength);
    [NullableContextAttribute("0")]
public int GetRawSocketOption(int optionLevel, int optionName, Span`1<byte> optionValue);
    [SupportedOSPlatformAttribute("windows")]
public void SetIPProtectionLevel(IPProtectionLevel level);
    public bool Poll(int microSeconds, SelectMode mode);
    public bool Poll(TimeSpan timeout, SelectMode mode);
    [NullableContextAttribute("2")]
public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
    [NullableContextAttribute("2")]
public static void Select(IList checkRead, IList checkWrite, IList checkError, TimeSpan timeout);
    private static int ToTimeoutMicroseconds(TimeSpan timeout);
    public IAsyncResult BeginConnect(EndPoint remoteEP, AsyncCallback callback, object state);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public void EndConnect(IAsyncResult asyncResult);
    [NullableContextAttribute("2")]
public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state);
    public void Disconnect(bool reuseSocket);
    public void EndDisconnect(IAsyncResult asyncResult);
    public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSend(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSend(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public int EndSend(IAsyncResult asyncResult);
    public int EndSend(IAsyncResult asyncResult, SocketError& errorCode);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSendFile(string fileName, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSendFile(string fileName, Byte[] preBuffer, Byte[] postBuffer, TransmitFileOptions flags, AsyncCallback callback, object state);
    public void EndSendFile(IAsyncResult asyncResult);
    public IAsyncResult BeginSendTo(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint remoteEP, AsyncCallback callback, object state);
    public int EndSendTo(IAsyncResult asyncResult);
    public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginReceive(Byte[] buffer, int offset, int size, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginReceive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, SocketError& errorCode, AsyncCallback callback, object state);
    public int EndReceive(IAsyncResult asyncResult);
    public int EndReceive(IAsyncResult asyncResult, SocketError& errorCode);
    private static int EndSendReceive(IAsyncResult asyncResult, SocketError& errorCode);
    public IAsyncResult BeginReceiveMessageFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public int EndReceiveMessageFrom(IAsyncResult asyncResult, SocketFlags& socketFlags, EndPoint& endPoint, IPPacketInformation& ipPacketInformation);
    public IAsyncResult BeginReceiveFrom(Byte[] buffer, int offset, int size, SocketFlags socketFlags, EndPoint& remoteEP, AsyncCallback callback, object state);
    public int EndReceiveFrom(IAsyncResult asyncResult, EndPoint& endPoint);
    [NullableContextAttribute("2")]
public IAsyncResult BeginAccept(AsyncCallback callback, object state);
    public Socket EndAccept(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Net.Sockets.Socket/<AcceptAndReceiveHelperAsync>d__203")]
private Task`1<ValueTuple`3<Socket, Byte[], int>> AcceptAndReceiveHelperAsync(Socket acceptSocket, int receiveSize);
    [NullableContextAttribute("2")]
public IAsyncResult BeginAccept(int receiveSize, AsyncCallback callback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginAccept(Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);
    public Socket EndAccept(Byte[]& buffer, IAsyncResult asyncResult);
    public Socket EndAccept(Byte[]& buffer, Int32& bytesTransferred, IAsyncResult asyncResult);
    public void Shutdown(SocketShutdown how);
    public bool AcceptAsync(SocketAsyncEventArgs e);
    private bool AcceptAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool ConnectAsync(SocketAsyncEventArgs e);
    internal bool ConnectAsync(SocketAsyncEventArgs e, bool userSocket, bool saeaCancelable);
    public static bool ConnectAsync(SocketType socketType, ProtocolType protocolType, SocketAsyncEventArgs e);
    public static void CancelConnectAsync(SocketAsyncEventArgs e);
    public bool DisconnectAsync(SocketAsyncEventArgs e);
    private bool DisconnectAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool ReceiveAsync(SocketAsyncEventArgs e);
    private bool ReceiveAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool ReceiveFromAsync(SocketAsyncEventArgs e);
    private bool ReceiveFromAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool ReceiveMessageFromAsync(SocketAsyncEventArgs e);
    private bool ReceiveMessageFromAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool SendAsync(SocketAsyncEventArgs e);
    private bool SendAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool SendPacketsAsync(SocketAsyncEventArgs e);
    private bool SendPacketsAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    public bool SendToAsync(SocketAsyncEventArgs e);
    private bool SendToAsync(SocketAsyncEventArgs e, CancellationToken cancellationToken);
    internal bool get_Disposed();
    internal static void GetIPProtocolInformation(AddressFamily addressFamily, SocketAddress socketAddress, Boolean& isIPv4, Boolean& isIPv6);
    internal static int GetAddressSize(EndPoint endPoint);
    private SocketAddress Serialize(EndPoint& remoteEP);
    private void DoConnect(EndPoint endPointSnapshot, SocketAddress socketAddress);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    internal void InternalShutdown(SocketShutdown how);
    internal void SetReceivingPacketInformation();
    internal void SetSocketOption(SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue, bool silent);
    private void SetMulticastOption(SocketOptionName optionName, MulticastOption MR);
    private void SetIPv6MulticastOption(SocketOptionName optionName, IPv6MulticastOption MR);
    private void SetLingerOption(LingerOption lref);
    private LingerOption GetLingerOpt();
    private MulticastOption GetMulticastOpt(SocketOptionName optionName);
    private IPv6MulticastOption GetIPv6MulticastOpt(SocketOptionName optionName);
    private SocketError InternalSetBlocking(bool desired, Boolean& current);
    internal void InternalSetBlocking(bool desired);
    internal Socket CreateAcceptSocket(SafeSocketHandle fd, EndPoint remoteEP);
    internal Socket UpdateAcceptSocket(Socket socket, EndPoint remoteEP);
    internal void SetToConnected();
    private void UpdateLocalEndPointOnConnect();
    private static bool IsWildcardEndPoint(EndPoint endPoint);
    internal void SetToDisconnected();
    private void UpdateStatusAfterSocketOptionErrorAndThrowException(SocketError error, string callerName);
    private void UpdateStatusAfterSocketErrorAndThrowException(SocketError error, bool disconnectOnFailure, string callerName);
    internal void UpdateStatusAfterSocketError(SocketException socketException, bool disconnectOnFailure);
    internal void UpdateStatusAfterSocketError(SocketError errorCode, bool disconnectOnFailure);
    private bool CheckErrorAndUpdateStatus(SocketError errorCode);
    private void ValidateReceiveFromEndpointAndState(EndPoint remoteEndPoint, string remoteEndPointArgumentName);
    private void ValidateBlockingMode();
    private void ValidateForMultiConnect(bool isMultiEndpoint);
    private static SafeFileHandle OpenFileHandle(string name);
    private void UpdateReceiveSocketErrorForDisposed(SocketError& socketError, int bytesTransferred);
    private void UpdateSendSocketErrorForDisposed(SocketError& socketError);
    private void UpdateConnectSocketErrorForDisposed(SocketError& socketError);
    private void UpdateAcceptSocketErrorForDisposed(SocketError& socketError);
    private void ThrowIfDisposed();
    private void ThrowIfConnectedStreamSocket();
    private bool get_IsConnectionOriented();
    internal static void SocketListDangerousReleaseRefs(IList socketList, Int32& refsAdded);
    private static SocketError GetSocketErrorFromFaultedTask(Task t);
    private void CheckNonBlockingConnectCompleted();
    public Task`1<Socket> AcceptAsync();
    public ValueTask`1<Socket> AcceptAsync(CancellationToken cancellationToken);
    public Task`1<Socket> AcceptAsync(Socket acceptSocket);
    [NullableContextAttribute("2")]
public ValueTask`1<Socket> AcceptAsync(Socket acceptSocket, CancellationToken cancellationToken);
    public Task ConnectAsync(EndPoint remoteEP);
    public ValueTask ConnectAsync(EndPoint remoteEP, CancellationToken cancellationToken);
    public Task ConnectAsync(IPAddress address, int port);
    public ValueTask ConnectAsync(IPAddress address, int port, CancellationToken cancellationToken);
    public Task ConnectAsync(IPAddress[] addresses, int port);
    public ValueTask ConnectAsync(IPAddress[] addresses, int port, CancellationToken cancellationToken);
    public Task ConnectAsync(string host, int port);
    public ValueTask ConnectAsync(string host, int port, CancellationToken cancellationToken);
    public ValueTask DisconnectAsync(bool reuseSocket, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Task`1<int> ReceiveAsync(ArraySegment`1<byte> buffer);
    [NullableContextAttribute("0")]
public Task`1<int> ReceiveAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    internal Task`1<int> ReceiveAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream);
    [NullableContextAttribute("0")]
public ValueTask`1<int> ReceiveAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<int> ReceiveAsync(Memory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    internal ValueTask`1<int> ReceiveAsync(Memory`1<byte> buffer, SocketFlags socketFlags, bool fromNetworkStream, CancellationToken cancellationToken);
    public Task`1<int> ReceiveAsync(IList`1<ArraySegment`1<byte>> buffers);
    public Task`1<int> ReceiveAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public Task`1<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment`1<byte> buffer, EndPoint remoteEndPoint);
    public Task`1<SocketReceiveFromResult> ReceiveFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [NullableContextAttribute("0")]
public ValueTask`1<SocketReceiveFromResult> ReceiveFromAsync(Memory`1<byte> buffer, EndPoint remoteEndPoint, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<SocketReceiveFromResult> ReceiveFromAsync(Memory`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<int> ReceiveFromAsync(Memory`1<byte> buffer, SocketFlags socketFlags, SocketAddress receivedAddress, CancellationToken cancellationToken);
    public Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment`1<byte> buffer, EndPoint remoteEndPoint);
    public Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [NullableContextAttribute("0")]
public ValueTask`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Memory`1<byte> buffer, EndPoint remoteEndPoint, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Memory`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Task`1<int> SendAsync(ArraySegment`1<byte> buffer);
    [NullableContextAttribute("0")]
public Task`1<int> SendAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    internal ValueTask SendAsyncForNetworkStream(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    public Task`1<int> SendAsync(IList`1<ArraySegment`1<byte>> buffers);
    public Task`1<int> SendAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    public Task`1<int> SendToAsync(ArraySegment`1<byte> buffer, EndPoint remoteEP);
    public Task`1<int> SendToAsync(ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendToAsync(ReadOnlyMemory`1<byte> buffer, EndPoint remoteEP, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendToAsync(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendToAsync(ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, SocketAddress socketAddress, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public ValueTask SendFileAsync(string fileName, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask SendFileAsync(string fileName, ReadOnlyMemory`1<byte> preBuffer, ReadOnlyMemory`1<byte> postBuffer, TransmitFileOptions flags, CancellationToken cancellationToken);
    private static void ValidateBufferArguments(Byte[] buffer, int offset, int size);
    private static void ValidateBuffer(ArraySegment`1<byte> buffer);
    private static void ValidateBuffersList(IList`1<ArraySegment`1<byte>> buffers);
    private Task`1<int> GetTaskForSendReceive(bool pending, TaskSocketAsyncEventArgs`1<int> saea, bool fromNetworkStream, bool isReceive);
    private static void CompleteSendReceive(Socket s, TaskSocketAsyncEventArgs`1<int> saea, bool isReceive);
    private static Exception GetException(SocketError error, bool wrapExceptionsInIOExceptions);
    private void ReturnSocketAsyncEventArgs(TaskSocketAsyncEventArgs`1<int> saea, bool isReceive);
    private void DisposeCachedTaskSocketAsyncEventArgs();
    [SupportedOSPlatformAttribute("windows")]
public SocketInformation DuplicateAndClose(int targetProcessId);
    internal void set_PreferInlineCompletions(bool value);
    private static void LoadSocketTypeFromHandle(SafeSocketHandle handle, AddressFamily& addressFamily, SocketType& socketType, ProtocolType& protocolType, Boolean& blocking, Boolean& isListening, Boolean& isSocket);
    internal void ReplaceHandleIfNecessaryAfterFailedConnect();
    internal SocketError ReplaceHandle();
    private static void ThrowMultiConnectNotSupported();
    private Socket GetOrCreateAcceptSocket(Socket acceptSocket, bool checkDisconnected, string propertyName, SafeSocketHandle& handle);
    private static void CheckTransmitFileOptions(TransmitFileOptions flags);
    private void SendFileInternal(string fileName, ReadOnlySpan`1<byte> preBuffer, ReadOnlySpan`1<byte> postBuffer, TransmitFileOptions flags);
    internal void DisposeHandle();
    internal void ClearHandle();
    internal Socket CopyStateFromSource(Socket source);
    [AsyncStateMachineAttribute("System.Net.Sockets.Socket/<<ConnectAsync>g__WaitForConnectWithCancellation|285_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask <ConnectAsync>g__WaitForConnectWithCancellation|285_0(AwaitableSocketAsyncEventArgs saea, ValueTask connectTask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Sockets.Socket/<<ConnectAsync>g__Core|289_0>d")]
[CompilerGeneratedAttribute]
private ValueTask <ConnectAsync>g__Core|289_0(IPAddress[] addresses, int port, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class System.Net.Sockets.SocketAddressExtensions : object {
    [ExtensionAttribute]
public static IPAddress GetIPAddress(SocketAddress socketAddress);
    [ExtensionAttribute]
public static int GetPort(SocketAddress socketAddress);
    [ExtensionAttribute]
public static bool Equals(SocketAddress socketAddress, EndPoint endPoint);
}
internal class System.Net.Sockets.SocketAsyncContext : object {
    private AcceptOperation _cachedAcceptOperation;
    private BufferMemoryReceiveOperation _cachedBufferMemoryReceiveOperation;
    private BufferListReceiveOperation _cachedBufferListReceiveOperation;
    private BufferMemorySendOperation _cachedBufferMemorySendOperation;
    private BufferListSendOperation _cachedBufferListSendOperation;
    private SafeSocketHandle _socket;
    private OperationQueue`1<ReadOperation> _receiveQueue;
    private OperationQueue`1<WriteOperation> _sendQueue;
    private SocketAsyncEngine _asyncEngine;
    private bool _isHandleNonBlocking;
    private object _registerLock;
    private bool IsRegistered { get; }
    public bool PreferInlineCompletions { get; }
    public bool IsHandleNonBlocking { get; }
    public SocketAsyncContext(SafeSocketHandle socket);
    private void ReturnOperation(AcceptOperation operation);
    private void ReturnOperation(BufferMemoryReceiveOperation operation);
    private void ReturnOperation(BufferListReceiveOperation operation);
    private void ReturnOperation(BufferMemorySendOperation operation);
    private void ReturnOperation(BufferListSendOperation operation);
    private AcceptOperation RentAcceptOperation();
    private BufferMemoryReceiveOperation RentBufferMemoryReceiveOperation();
    private BufferListReceiveOperation RentBufferListReceiveOperation();
    private BufferMemorySendOperation RentBufferMemorySendOperation();
    private BufferListSendOperation RentBufferListSendOperation();
    private bool get_IsRegistered();
    [DynamicDependencyAttribute("set_PreferInlineCompletions", "System.Net.Sockets.Socket")]
public bool get_PreferInlineCompletions();
    private bool TryRegister(Error& error);
    public bool StopAndAbort();
    public void SetHandleNonBlocking();
    public bool get_IsHandleNonBlocking();
    private void PerformSyncOperation(OperationQueue`1& queue, TOperation operation, int timeout, int observedSequenceNumber);
    private bool ShouldRetrySyncOperation(SocketError& errorCode);
    private void ProcessAsyncReadOperation(ReadOperation op);
    private void ProcessAsyncWriteOperation(WriteOperation op);
    public SocketError Accept(Memory`1<byte> socketAddress, Int32& socketAddressLen, IntPtr& acceptedFd);
    public SocketError AcceptAsync(Memory`1<byte> socketAddress, Int32& socketAddressLen, IntPtr& acceptedFd, Action`3<IntPtr, Memory`1<byte>, SocketError> callback, CancellationToken cancellationToken);
    public SocketError Connect(Memory`1<byte> socketAddress);
    public SocketError ConnectAsync(Memory`1<byte> socketAddress, Action`1<SocketError> callback);
    public SocketError Receive(Memory`1<byte> buffer, SocketFlags flags, int timeout, Int32& bytesReceived);
    public SocketError Receive(Span`1<byte> buffer, SocketFlags flags, int timeout, Int32& bytesReceived);
    public SocketError ReceiveAsync(Memory`1<byte> buffer, SocketFlags flags, Int32& bytesReceived, SocketFlags& receivedFlags, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback, CancellationToken cancellationToken);
    public SocketError ReceiveFrom(Memory`1<byte> buffer, SocketFlags& flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, int timeout, Int32& bytesReceived);
    public SocketError ReceiveFrom(Span`1<byte> buffer, SocketFlags& flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, int timeout, Int32& bytesReceived);
    public SocketError ReceiveAsync(Memory`1<byte> buffer, SocketFlags flags, Int32& bytesReceived, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback, CancellationToken cancellationToken);
    public SocketError ReceiveFromAsync(Memory`1<byte> buffer, SocketFlags flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, Int32& bytesReceived, SocketFlags& receivedFlags, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback, CancellationToken cancellationToken);
    public SocketError Receive(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, int timeout, Int32& bytesReceived);
    public SocketError ReceiveAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Int32& bytesReceived, SocketFlags& receivedFlags, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback);
    public SocketError ReceiveFrom(IList`1<ArraySegment`1<byte>> buffers, SocketFlags& flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, int timeout, Int32& bytesReceived);
    public SocketError ReceiveFromAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, Int32& bytesReceived, SocketFlags& receivedFlags, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback);
    public SocketError ReceiveMessageFrom(Memory`1<byte> buffer, SocketFlags& flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, bool isIPv4, bool isIPv6, int timeout, IPPacketInformation& ipPacketInformation, Int32& bytesReceived);
    public SocketError ReceiveMessageFrom(Span`1<byte> buffer, SocketFlags& flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, bool isIPv4, bool isIPv6, int timeout, IPPacketInformation& ipPacketInformation, Int32& bytesReceived);
    public SocketError ReceiveMessageFromAsync(Memory`1<byte> buffer, IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Memory`1<byte> socketAddress, Int32& socketAddressLen, bool isIPv4, bool isIPv6, Int32& bytesReceived, SocketFlags& receivedFlags, IPPacketInformation& ipPacketInformation, Action`5<int, Memory`1<byte>, SocketFlags, IPPacketInformation, SocketError> callback, CancellationToken cancellationToken);
    public SocketError Send(ReadOnlySpan`1<byte> buffer, SocketFlags flags, int timeout, Int32& bytesSent);
    public SocketError Send(Byte[] buffer, int offset, int count, SocketFlags flags, int timeout, Int32& bytesSent);
    public SocketError SendAsync(Memory`1<byte> buffer, int offset, int count, SocketFlags flags, Int32& bytesSent, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback, CancellationToken cancellationToken);
    public SocketError SendTo(Byte[] buffer, int offset, int count, SocketFlags flags, Memory`1<byte> socketAddress, int timeout, Int32& bytesSent);
    public SocketError SendTo(ReadOnlySpan`1<byte> buffer, SocketFlags flags, Memory`1<byte> socketAddress, int timeout, Int32& bytesSent);
    public SocketError SendToAsync(Memory`1<byte> buffer, int offset, int count, SocketFlags flags, Memory`1<byte> socketAddress, Int32& bytesSent, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback, CancellationToken cancellationToken);
    public SocketError Send(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, int timeout, Int32& bytesSent);
    public SocketError SendAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Int32& bytesSent, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback);
    public SocketError SendTo(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Memory`1<byte> socketAddress, int timeout, Int32& bytesSent);
    public SocketError SendToAsync(IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Memory`1<byte> socketAddress, Int32& bytesSent, Action`4<int, Memory`1<byte>, SocketFlags, SocketError> callback);
    public SocketError SendFile(SafeFileHandle fileHandle, long offset, long count, int timeout, Int64& bytesSent);
    public SocketError SendFileAsync(SafeFileHandle fileHandle, long offset, long count, Int64& bytesSent, Action`2<long, SocketError> callback, CancellationToken cancellationToken);
    public SocketEvents HandleSyncEventsSpeculatively(SocketEvents events);
    public void HandleEventsInline(SocketEvents events);
    public void HandleEvents(SocketEvents events);
}
internal class System.Net.Sockets.SocketAsyncEngine : object {
    internal static bool InlineSocketCompletionsEnabled;
    private static SocketAsyncEngine[] s_engines;
    private static int s_allocateFromEngine;
    private IntPtr _port;
    private SocketEvent* _buffer;
    private ConcurrentDictionary`2<IntPtr, SocketAsyncContextWrapper> _handleToContextMap;
    private ConcurrentQueue`1<SocketIOEvent> _eventQueue;
    private int _eventQueueProcessingRequested;
    private static SocketAsyncEngine();
    private static int GetEngineCount();
    private static SocketAsyncEngine[] CreateEngines();
    public static bool TryRegisterSocket(IntPtr socketHandle, SocketAsyncContext context, SocketAsyncEngine& engine, Error& error);
    private bool TryRegisterCore(IntPtr socketHandle, SocketAsyncContext context, Error& error);
    public void UnregisterSocket(IntPtr socketHandle);
    private void EventLoop();
    private void ScheduleToProcessEvents();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    private void FreeNativeResources();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Sockets.SocketAsyncEventArgs : EventArgs {
    private Socket _acceptSocket;
    private Socket _connectSocket;
    private Memory`1<byte> _buffer;
    private int _offset;
    private int _count;
    private bool _bufferIsExplicitArray;
    private IList`1<ArraySegment`1<byte>> _bufferList;
    private List`1<ArraySegment`1<byte>> _bufferListInternal;
    private int _bytesTransferred;
    private bool _disconnectReuseSocket;
    private SocketAsyncOperation _completedOperation;
    private IPPacketInformation _receiveMessageFromPacketInfo;
    private EndPoint _remoteEndPoint;
    private int _sendPacketsSendSize;
    private SendPacketsElement[] _sendPacketsElements;
    private TransmitFileOptions _sendPacketsFlags;
    private SocketError _socketError;
    private Exception _connectByNameError;
    private SocketFlags _socketFlags;
    private object _userToken;
    private Byte[] _acceptBuffer;
    private int _acceptAddressBufferCount;
    internal SocketAddress _socketAddress;
    private bool _flowExecutionContext;
    private ExecutionContext _context;
    private static ContextCallback s_executionCallback;
    private Socket _currentSocket;
    private bool _userSocket;
    private bool _disposeCalled;
    private int _operating;
    private CancellationTokenSource _multipleConnectCancellation;
    [CompilerGeneratedAttribute]
private EventHandler`1<SocketAsyncEventArgs> Completed;
    private IntPtr _acceptedFileDescriptor;
    private int _socketAddressSize;
    private SocketFlags _receivedFlags;
    private Action`4<int, Memory`1<byte>, SocketFlags, SocketError> _transferCompletionCallback;
    public Socket AcceptSocket { get; public set; }
    public Socket ConnectSocket { get; }
    public Byte[] Buffer { get; }
    [NullableAttribute("0")]
public Memory`1<byte> MemoryBuffer { get; }
    public int Offset { get; }
    public int Count { get; }
    public TransmitFileOptions SendPacketsFlags { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<ArraySegment`1<byte>> BufferList { get; public set; }
    public int BytesTransferred { get; }
    public bool DisconnectReuseSocket { get; public set; }
    public SocketAsyncOperation LastOperation { get; }
    public IPPacketInformation ReceiveMessageFromPacketInfo { get; }
    public EndPoint RemoteEndPoint { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SendPacketsElement[] SendPacketsElements { get; public set; }
    public int SendPacketsSendSize { get; public set; }
    public SocketError SocketError { get; public set; }
    public Exception ConnectByNameError { get; }
    public SocketFlags SocketFlags { get; public set; }
    public object UserToken { get; public set; }
    internal bool HasMultipleBuffers { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`4<int, Memory`1<byte>, SocketFlags, SocketError> TransferCompletionCallback { get; }
    public SocketAsyncEventArgs(bool unsafeSuppressExecutionContextFlow);
    private static SocketAsyncEventArgs();
    public Socket get_AcceptSocket();
    public void set_AcceptSocket(Socket value);
    public Socket get_ConnectSocket();
    public Byte[] get_Buffer();
    [NullableContextAttribute("0")]
public Memory`1<byte> get_MemoryBuffer();
    public int get_Offset();
    public int get_Count();
    public TransmitFileOptions get_SendPacketsFlags();
    public void set_SendPacketsFlags(TransmitFileOptions value);
    public IList`1<ArraySegment`1<byte>> get_BufferList();
    public void set_BufferList(IList`1<ArraySegment`1<byte>> value);
    public int get_BytesTransferred();
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler`1<SocketAsyncEventArgs> value);
    private void OnCompletedInternal();
    [NullableContextAttribute("1")]
protected virtual void OnCompleted(SocketAsyncEventArgs e);
    private void AfterConnectAcceptTelemetry();
    public bool get_DisconnectReuseSocket();
    public void set_DisconnectReuseSocket(bool value);
    public SocketAsyncOperation get_LastOperation();
    public IPPacketInformation get_ReceiveMessageFromPacketInfo();
    public EndPoint get_RemoteEndPoint();
    public void set_RemoteEndPoint(EndPoint value);
    public SendPacketsElement[] get_SendPacketsElements();
    public void set_SendPacketsElements(SendPacketsElement[] value);
    public int get_SendPacketsSendSize();
    public void set_SendPacketsSendSize(int value);
    public SocketError get_SocketError();
    public void set_SocketError(SocketError value);
    public Exception get_ConnectByNameError();
    public SocketFlags get_SocketFlags();
    public void set_SocketFlags(SocketFlags value);
    public object get_UserToken();
    public void set_UserToken(object value);
    public void SetBuffer(int offset, int count);
    internal void CopyBufferFrom(SocketAsyncEventArgs source);
    public void SetBuffer(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public void SetBuffer(Memory`1<byte> buffer);
    internal bool get_HasMultipleBuffers();
    internal void SetResults(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void SetResults(Exception exception, int bytesTransferred, SocketFlags flags);
    private static void ExecutionCallback(object state);
    internal void Complete();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    private void StartConfiguring();
    private void ThrowForNonFreeStatus(int status);
    internal void StartOperationCommon(Socket socket, SocketAsyncOperation operation);
    internal void StartOperationAccept();
    internal void StartOperationConnect(bool saeaMultiConnectCancelable, bool userSocket);
    internal void CancelConnectAsync();
    internal void FinishOperationSyncFailure(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncFailure(SocketError socketError, int bytesTransferred, SocketFlags flags);
    internal bool DnsConnectAsync(DnsEndPoint endPoint, SocketType socketType, ProtocolType protocolType);
    internal void FinishOperationSyncSuccess(int bytesTransferred, SocketFlags flags);
    internal void FinishOperationAsyncSuccess(int bytesTransferred, SocketFlags flags);
    private void FinishOperationSync(SocketError socketError, int bytesTransferred, SocketFlags flags);
    private static void LogBytesTransferEvents(Nullable`1<SocketType> socketType, SocketAsyncOperation operation, int bytesTransferred);
    private void AcceptCompletionCallback(IntPtr acceptedFileDescriptor, Memory`1<byte> socketAddress, SocketError socketError);
    private void CompleteAcceptOperation(IntPtr acceptedFileDescriptor, Memory`1<byte> socketAddress, SocketError socketError);
    internal SocketError DoOperationAccept(Socket _, SafeSocketHandle handle, SafeSocketHandle acceptHandle, CancellationToken cancellationToken);
    private void ConnectCompletionCallback(SocketError socketError);
    internal SocketError DoOperationConnectEx(Socket _, SafeSocketHandle handle);
    internal SocketError DoOperationConnect(SafeSocketHandle handle);
    internal SocketError DoOperationDisconnect(Socket socket, SafeSocketHandle handle, CancellationToken _);
    private Action`4<int, Memory`1<byte>, SocketFlags, SocketError> get_TransferCompletionCallback();
    private void TransferCompletionCallbackCore(int bytesTransferred, Memory`1<byte> socketAddress, SocketFlags receivedFlags, SocketError socketError);
    private void CompleteTransferOperation(Memory`1<byte> _, int socketAddressSize, SocketFlags receivedFlags);
    internal SocketError DoOperationReceive(SafeSocketHandle handle, CancellationToken cancellationToken);
    internal SocketError DoOperationReceiveFrom(SafeSocketHandle handle, CancellationToken cancellationToken);
    private void ReceiveMessageFromCompletionCallback(int bytesTransferred, Memory`1<byte> socketAddress, SocketFlags receivedFlags, IPPacketInformation ipPacketInformation, SocketError errorCode);
    private void CompleteReceiveMessageFromOperation(Memory`1<byte> socketAddress, int socketAddressSize, SocketFlags receivedFlags, IPPacketInformation ipPacketInformation);
    internal SocketError DoOperationReceiveMessageFrom(Socket socket, SafeSocketHandle handle, CancellationToken cancellationToken);
    internal SocketError DoOperationSend(SafeSocketHandle handle, CancellationToken cancellationToken);
    internal SocketError DoOperationSendPackets(Socket socket, SafeSocketHandle _1, CancellationToken cancellationToken);
    internal SocketError DoOperationSendTo(SafeSocketHandle handle, CancellationToken cancellationToken);
    internal void LogBuffer(int size);
    private SocketError FinishOperationAccept(SocketAddress remoteSocketAddress);
    private void UpdateReceivedSocketAddress(SocketAddress socketAddress);
    private void CompletionCallback(int bytesTransferred, SocketFlags flags, SocketError socketError);
    [AsyncStateMachineAttribute("System.Net.Sockets.SocketAsyncEventArgs/<<DnsConnectAsync>g__Core|112_0>d")]
[CompilerGeneratedAttribute]
private Task <DnsConnectAsync>g__Core|112_0(MultiConnectSocketAsyncEventArgs internalArgs, Task`1<IPAddress[]> addressesTask, int port, SocketType socketType, ProtocolType protocolType, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <DoOperationSendPackets>b__143_0(long bytesTransferred, SocketError error);
}
public enum System.Net.Sockets.SocketAsyncOperation : Enum {
    public int value__;
    public static SocketAsyncOperation None;
    public static SocketAsyncOperation Accept;
    public static SocketAsyncOperation Connect;
    public static SocketAsyncOperation Disconnect;
    public static SocketAsyncOperation Receive;
    public static SocketAsyncOperation ReceiveFrom;
    public static SocketAsyncOperation ReceiveMessageFrom;
    public static SocketAsyncOperation Send;
    public static SocketAsyncOperation SendPackets;
    public static SocketAsyncOperation SendTo;
}
internal static class System.Net.Sockets.SocketErrorPal : object {
    private static Dictionary`2<Error, SocketError> s_nativeErrorToSocketError;
    private static Dictionary`2<SocketError, Error> s_socketErrorToNativeError;
    private static SocketErrorPal();
    internal static SocketError GetSocketErrorForNativeError(Error errno);
    internal static bool TryGetNativeErrorForSocketError(SocketError error, Error& errno);
}
internal static class System.Net.Sockets.SocketExceptionFactory : object {
    private static string CreateMessage(int nativeSocketError, EndPoint endPoint);
    public static SocketException CreateSocketException(int socketError, EndPoint endPoint);
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketFlags : Enum {
    public int value__;
    public static SocketFlags None;
    public static SocketFlags OutOfBand;
    public static SocketFlags Peek;
    public static SocketFlags DontRoute;
    public static SocketFlags Truncated;
    public static SocketFlags ControlDataTruncated;
    public static SocketFlags Broadcast;
    public static SocketFlags Multicast;
    public static SocketFlags Partial;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.SocketInformation : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <ProtocolInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketInformationOptions <Options>k__BackingField;
    public Byte[] ProtocolInformation { get; public set; }
    public SocketInformationOptions Options { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_ProtocolInformation();
    [CompilerGeneratedAttribute]
public void set_ProtocolInformation(Byte[] value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public SocketInformationOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(SocketInformationOptions value);
}
[FlagsAttribute]
public enum System.Net.Sockets.SocketInformationOptions : Enum {
    public int value__;
    public static SocketInformationOptions NonBlocking;
    public static SocketInformationOptions Connected;
    public static SocketInformationOptions Listening;
    [ObsoleteAttribute("SocketInformationOptions.UseOnlyOverlappedIO has been deprecated and is not supported.")]
[EditorBrowsableAttribute("1")]
public static SocketInformationOptions UseOnlyOverlappedIO;
}
public enum System.Net.Sockets.SocketOptionLevel : Enum {
    public int value__;
    public static SocketOptionLevel Socket;
    public static SocketOptionLevel IP;
    public static SocketOptionLevel IPv6;
    public static SocketOptionLevel Tcp;
    public static SocketOptionLevel Udp;
}
public enum System.Net.Sockets.SocketOptionName : Enum {
    public int value__;
    public static SocketOptionName Debug;
    public static SocketOptionName AcceptConnection;
    public static SocketOptionName ReuseAddress;
    public static SocketOptionName KeepAlive;
    public static SocketOptionName DontRoute;
    public static SocketOptionName Broadcast;
    public static SocketOptionName UseLoopback;
    public static SocketOptionName Linger;
    public static SocketOptionName OutOfBandInline;
    public static SocketOptionName DontLinger;
    public static SocketOptionName ExclusiveAddressUse;
    public static SocketOptionName SendBuffer;
    public static SocketOptionName ReceiveBuffer;
    public static SocketOptionName SendLowWater;
    public static SocketOptionName ReceiveLowWater;
    public static SocketOptionName SendTimeout;
    public static SocketOptionName ReceiveTimeout;
    public static SocketOptionName Error;
    public static SocketOptionName Type;
    public static SocketOptionName ReuseUnicastPort;
    public static SocketOptionName MaxConnections;
    public static SocketOptionName IPOptions;
    public static SocketOptionName HeaderIncluded;
    public static SocketOptionName TypeOfService;
    public static SocketOptionName IpTimeToLive;
    public static SocketOptionName MulticastInterface;
    public static SocketOptionName MulticastTimeToLive;
    public static SocketOptionName MulticastLoopback;
    public static SocketOptionName AddMembership;
    public static SocketOptionName DropMembership;
    public static SocketOptionName DontFragment;
    public static SocketOptionName AddSourceMembership;
    public static SocketOptionName DropSourceMembership;
    public static SocketOptionName BlockSource;
    public static SocketOptionName UnblockSource;
    public static SocketOptionName PacketInformation;
    public static SocketOptionName HopLimit;
    public static SocketOptionName IPProtectionLevel;
    public static SocketOptionName IPv6Only;
    public static SocketOptionName NoDelay;
    public static SocketOptionName BsdUrgent;
    public static SocketOptionName Expedited;
    public static SocketOptionName TcpKeepAliveRetryCount;
    public static SocketOptionName TcpKeepAliveTime;
    public static SocketOptionName TcpKeepAliveInterval;
    public static SocketOptionName NoChecksum;
    public static SocketOptionName ChecksumCoverage;
    public static SocketOptionName UpdateAcceptContext;
    public static SocketOptionName UpdateConnectContext;
}
internal static class System.Net.Sockets.SocketPal : object {
    public static int MaximumAddressSize;
    private static bool SupportsDualModeIPv4PacketInfo;
    private static SocketPal();
    private static bool GetPlatformSupportsDualModeIPv4PacketInfo();
    public static SocketError GetSocketErrorForErrorCode(Error errorCode);
    public static void CheckDualModePacketInfoSupport(Socket socket);
    private static IPPacketInformation GetIPPacketInformation(MessageHeader* messageHeader, bool isIPv4, bool isIPv6);
    public static SocketError CreateSocket(AddressFamily addressFamily, SocketType socketType, ProtocolType protocolType, SafeSocketHandle& socket);
    private static int SysRead(SafeSocketHandle handle, Span`1<byte> buffer, Error& errno);
    private static int SysReceive(SafeSocketHandle socket, SocketFlags flags, Span`1<byte> buffer, Error& errno);
    private static int SysReceive(SafeSocketHandle socket, SocketFlags flags, Span`1<byte> buffer, Span`1<byte> socketAddress, Int32& socketAddressLen, SocketFlags& receivedFlags, Error& errno);
    private static int SysWrite(SafeSocketHandle handle, ReadOnlySpan`1<byte> buffer, Int32& offset, Int32& count, Error& errno);
    private static ReadOnlySpan`1<byte> AvoidNullReference(ReadOnlySpan`1<byte> buffer);
    private static int SysSend(SafeSocketHandle socket, SocketFlags flags, ReadOnlySpan`1<byte> buffer, Int32& offset, Int32& count, Error& errno);
    private static int SysSend(SafeSocketHandle socket, SocketFlags flags, ReadOnlySpan`1<byte> buffer, Int32& offset, Int32& count, ReadOnlySpan`1<byte> socketAddress, Error& errno);
    private static int SysSend(SafeSocketHandle socket, SocketFlags flags, IList`1<ArraySegment`1<byte>> buffers, Int32& bufferIndex, Int32& offset, ReadOnlySpan`1<byte> socketAddress, Error& errno);
    private static long SendFile(SafeSocketHandle socket, SafeFileHandle fileHandle, Int64& offset, Int64& count, Error& errno);
    private static int SysReceive(SafeSocketHandle socket, SocketFlags flags, IList`1<ArraySegment`1<byte>> buffers, Span`1<byte> socketAddress, Int32& socketAddressLen, SocketFlags& receivedFlags, Error& errno);
    private static int SysReceiveMessageFrom(SafeSocketHandle socket, SocketFlags flags, Span`1<byte> buffer, Span`1<byte> socketAddress, Int32& socketAddressLen, bool isIPv4, bool isIPv6, SocketFlags& receivedFlags, IPPacketInformation& ipPacketInformation, Error& errno);
    private static int SysReceiveMessageFrom(SafeSocketHandle socket, SocketFlags flags, IList`1<ArraySegment`1<byte>> buffers, Span`1<byte> socketAddress, Int32& socketAddressLen, bool isIPv4, bool isIPv6, SocketFlags& receivedFlags, IPPacketInformation& ipPacketInformation, Error& errno);
    public static bool TryCompleteAccept(SafeSocketHandle socket, Memory`1<byte> socketAddress, Int32& socketAddressLen, IntPtr& acceptedFd, SocketError& errorCode);
    public static bool TryStartConnect(SafeSocketHandle socket, Memory`1<byte> socketAddress, SocketError& errorCode);
    public static bool TryCompleteConnect(SafeSocketHandle socket, SocketError& errorCode);
    public static bool TryCompleteReceiveFrom(SafeSocketHandle socket, Span`1<byte> buffer, SocketFlags flags, Span`1<byte> socketAddress, Int32& socketAddressLen, Int32& bytesReceived, SocketFlags& receivedFlags, SocketError& errorCode);
    public static bool TryCompleteReceiveFrom(SafeSocketHandle socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Span`1<byte> socketAddress, Int32& socketAddressLen, Int32& bytesReceived, SocketFlags& receivedFlags, SocketError& errorCode);
    public static bool TryCompleteReceive(SafeSocketHandle socket, Span`1<byte> buffer, SocketFlags flags, Int32& bytesReceived, SocketError& errorCode);
    public static bool TryCompleteReceiveFrom(SafeSocketHandle socket, Span`1<byte> buffer, IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Span`1<byte> socketAddress, Int32& receivedSocketAddressLength, Int32& bytesReceived, SocketFlags& receivedFlags, SocketError& errorCode);
    public static bool TryCompleteReceiveMessageFrom(SafeSocketHandle socket, Span`1<byte> buffer, IList`1<ArraySegment`1<byte>> buffers, SocketFlags flags, Memory`1<byte> socketAddress, Int32& receivedSocketAddressLength, bool isIPv4, bool isIPv6, Int32& bytesReceived, SocketFlags& receivedFlags, IPPacketInformation& ipPacketInformation, SocketError& errorCode);
    public static bool TryCompleteSendTo(SafeSocketHandle socket, Span`1<byte> buffer, Int32& offset, Int32& count, SocketFlags flags, ReadOnlySpan`1<byte> socketAddress, Int32& bytesSent, SocketError& errorCode);
    public static bool TryCompleteSendTo(SafeSocketHandle socket, ReadOnlySpan`1<byte> buffer, SocketFlags flags, ReadOnlySpan`1<byte> socketAddress, Int32& bytesSent, SocketError& errorCode);
    public static bool TryCompleteSendTo(SafeSocketHandle socket, IList`1<ArraySegment`1<byte>> buffers, Int32& bufferIndex, Int32& offset, SocketFlags flags, ReadOnlySpan`1<byte> socketAddress, Int32& bytesSent, SocketError& errorCode);
    public static bool TryCompleteSendTo(SafeSocketHandle socket, ReadOnlySpan`1<byte> buffer, IList`1<ArraySegment`1<byte>> buffers, Int32& bufferIndex, Int32& offset, Int32& count, SocketFlags flags, ReadOnlySpan`1<byte> socketAddress, Int32& bytesSent, SocketError& errorCode);
    public static bool TryCompleteSendFile(SafeSocketHandle socket, SafeFileHandle handle, Int64& offset, Int64& count, Int64& bytesSent, SocketError& errorCode);
    public static SocketError SetBlocking(SafeSocketHandle handle, bool shouldBlock, Boolean& willBlock);
    public static SocketError GetSockName(SafeSocketHandle handle, Byte* buffer, Int32* nameLen);
    public static SocketError GetAvailable(SafeSocketHandle handle, Int32& available);
    public static SocketError GetAtOutOfBandMark(SafeSocketHandle handle, Int32& atOutOfBandMark);
    public static SocketError GetPeerName(SafeSocketHandle handle, Span`1<byte> buffer, Int32& nameLen);
    public static SocketError Bind(SafeSocketHandle handle, ProtocolType socketProtocolType, ReadOnlySpan`1<byte> buffer);
    public static SocketError Listen(SafeSocketHandle handle, int backlog);
    public static SocketError Accept(SafeSocketHandle listenSocket, Memory`1<byte> socketAddress, Int32& socketAddressLen, SafeSocketHandle& socket);
    public static SocketError Connect(SafeSocketHandle handle, Memory`1<byte> socketAddress);
    public static SocketError Send(SafeSocketHandle handle, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError Send(SafeSocketHandle handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError Send(SafeSocketHandle handle, ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError SendFile(SafeSocketHandle handle, SafeFileHandle fileHandle);
    public static SocketError SendTo(SafeSocketHandle handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, Memory`1<byte> socketAddress, Int32& bytesTransferred);
    public static SocketError SendTo(SafeSocketHandle handle, ReadOnlySpan`1<byte> buffer, SocketFlags socketFlags, Memory`1<byte> socketAddress, Int32& bytesTransferred);
    public static SocketError Receive(SafeSocketHandle handle, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError Receive(SafeSocketHandle handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError Receive(SafeSocketHandle handle, Span`1<byte> buffer, SocketFlags socketFlags, Int32& bytesTransferred);
    public static SocketError ReceiveMessageFrom(Socket socket, SafeSocketHandle handle, Byte[] buffer, int offset, int count, SocketFlags& socketFlags, SocketAddress socketAddress, SocketAddress& receiveAddress, IPPacketInformation& ipPacketInformation, Int32& bytesTransferred);
    public static SocketError ReceiveMessageFrom(Socket socket, SafeSocketHandle handle, Span`1<byte> buffer, SocketFlags& socketFlags, SocketAddress socketAddress, SocketAddress& receiveAddress, IPPacketInformation& ipPacketInformation, Int32& bytesTransferred);
    public static SocketError ReceiveFrom(SafeSocketHandle handle, Byte[] buffer, int offset, int count, SocketFlags socketFlags, Memory`1<byte> socketAddress, Int32& socketAddressLen, Int32& bytesTransferred);
    public static SocketError ReceiveFrom(SafeSocketHandle handle, Span`1<byte> buffer, SocketFlags socketFlags, Memory`1<byte> socketAddress, Int32& socketAddressLen, Int32& bytesTransferred);
    public static SocketError WindowsIoctl(SafeSocketHandle handle, int ioControlCode, Byte[] _, Byte[] optionOutValue, Int32& optionLength);
    private static SocketError GetErrorAndTrackSetting(SafeSocketHandle handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Error err);
    public static SocketError SetSockOpt(SafeSocketHandle handle, SocketOptionLevel optionLevel, SocketOptionName optionName, int optionValue);
    public static SocketError SetSockOpt(SafeSocketHandle handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue);
    public static SocketError SetRawSockOpt(SafeSocketHandle handle, int optionLevel, int optionName, ReadOnlySpan`1<byte> optionValue);
    public static SocketError SetMulticastOption(SafeSocketHandle handle, SocketOptionName optionName, MulticastOption optionValue);
    public static SocketError SetIPv6MulticastOption(SafeSocketHandle handle, SocketOptionName optionName, IPv6MulticastOption optionValue);
    public static SocketError SetLingerOption(SafeSocketHandle handle, LingerOption optionValue);
    public static void SetReceivingDualModeIPv4PacketInformation(Socket socket);
    public static void SetIPProtectionLevel(Socket socket, SocketOptionLevel optionLevel, int protectionLevel);
    public static SocketError GetSockOpt(SafeSocketHandle handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Int32& optionValue);
    public static SocketError GetSockOpt(SafeSocketHandle handle, SocketOptionLevel optionLevel, SocketOptionName optionName, Byte[] optionValue, Int32& optionLength);
    public static SocketError GetRawSockOpt(SafeSocketHandle handle, int optionLevel, int optionName, Span`1<byte> optionValue, Int32& optionLength);
    public static SocketError GetMulticastOption(SafeSocketHandle handle, SocketOptionName optionName, MulticastOption& optionValue);
    public static SocketError GetIPv6MulticastOption(SafeSocketHandle handle, SocketOptionName optionName, IPv6MulticastOption& optionValue);
    public static SocketError GetLingerOption(SafeSocketHandle handle, LingerOption& optionValue);
    public static SocketError Poll(SafeSocketHandle handle, int microseconds, SelectMode mode, Boolean& status);
    public static SocketError Select(IList checkRead, IList checkWrite, IList checkError, int microseconds);
    private static SocketError SelectViaPoll(IList checkRead, int checkReadInitialCount, IList checkWrite, int checkWriteInitialCount, IList checkError, int checkErrorInitialCount, PollEvent* events, int eventsLength, int microseconds);
    private static void AddToPollArray(PollEvent* arr, int arrLength, IList socketList, Int32& arrOffset, PollEvents events, Int32& refsAdded);
    private static void FilterPollList(IList socketList, PollEvent* arr, int arrEndOffset, PollEvents desiredEvents, Int32& refsAdded);
    public static SocketError Shutdown(SafeSocketHandle handle, bool isConnected, bool isDisconnected, SocketShutdown how);
    private static SocketError SendFileAsync(SafeSocketHandle handle, SafeFileHandle fileHandle, long offset, long count, CancellationToken cancellationToken, Action`2<long, SocketError> callback);
    [AsyncStateMachineAttribute("System.Net.Sockets.SocketPal/<SendPacketsAsync>d__79")]
public static Task SendPacketsAsync(Socket socket, TransmitFileOptions options, SendPacketsElement[] elements, SafeFileHandle[] fileHandles, CancellationToken cancellationToken, Action`2<long, SocketError> callback);
    internal static SocketError Disconnect(Socket socket, SafeSocketHandle handle, bool reuseSocket);
    internal static SafeSocketHandle CreateSocket(IntPtr fileDescriptor);
    internal static bool HasNonBlockingConnectCompleted(SafeSocketHandle handle, Boolean& success);
}
public class System.Net.Sockets.SocketReceiveFromResult : ValueType {
    public int ReceivedBytes;
    [NullableAttribute("1")]
public EndPoint RemoteEndPoint;
}
public class System.Net.Sockets.SocketReceiveMessageFromResult : ValueType {
    public int ReceivedBytes;
    public SocketFlags SocketFlags;
    [NullableAttribute("1")]
public EndPoint RemoteEndPoint;
    public IPPacketInformation PacketInformation;
}
public enum System.Net.Sockets.SocketShutdown : Enum {
    public int value__;
    public static SocketShutdown Receive;
    public static SocketShutdown Send;
    public static SocketShutdown Both;
}
[EventSourceAttribute]
internal class System.Net.Sockets.SocketsTelemetry : EventSource {
    public static SocketsTelemetry Log;
    private PollingCounter _currentOutgoingConnectAttemptsCounter;
    private PollingCounter _outgoingConnectionsEstablishedCounter;
    private PollingCounter _incomingConnectionsEstablishedCounter;
    private PollingCounter _bytesReceivedCounter;
    private PollingCounter _bytesSentCounter;
    private PollingCounter _datagramsReceivedCounter;
    private PollingCounter _datagramsSentCounter;
    private long _currentOutgoingConnectAttempts;
    private long _outgoingConnectionsEstablished;
    private long _incomingConnectionsEstablished;
    private long _bytesReceived;
    private long _bytesSent;
    private long _datagramsReceived;
    private long _datagramsSent;
    private static SocketsTelemetry();
    [EventAttribute("1")]
private void ConnectStart(string address);
    [EventAttribute("2")]
private void ConnectStop();
    [EventAttribute("3")]
private void ConnectFailed(SocketError error, string exceptionMessage);
    [EventAttribute("4")]
private void AcceptStart(string address);
    [EventAttribute("5")]
private void AcceptStop();
    [EventAttribute("6")]
private void AcceptFailed(SocketError error, string exceptionMessage);
    [NonEventAttribute]
public void ConnectStart(SocketAddress address);
    [NonEventAttribute]
public void AfterConnect(SocketError error, string exceptionMessage);
    [NonEventAttribute]
public void AcceptStart(SocketAddress address);
    [NonEventAttribute]
public void AcceptStart(EndPoint address);
    [NonEventAttribute]
public void AfterAccept(SocketError error, string exceptionMessage);
    [NonEventAttribute]
public void BytesReceived(int count);
    [NonEventAttribute]
public void BytesSent(int count);
    [NonEventAttribute]
public void DatagramReceived();
    [NonEventAttribute]
public void DatagramSent();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_0();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_1();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_2();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_3();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_4();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_5();
    [CompilerGeneratedAttribute]
private double <OnEventCommand>b__30_6();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Net.Sockets.SocketTaskExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<Socket> AcceptAsync(Socket socket);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<Socket> AcceptAsync(Socket socket, Socket acceptSocket);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task ConnectAsync(Socket socket, EndPoint remoteEP);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static ValueTask ConnectAsync(Socket socket, EndPoint remoteEP, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task ConnectAsync(Socket socket, IPAddress address, int port);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static ValueTask ConnectAsync(Socket socket, IPAddress address, int port, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task ConnectAsync(Socket socket, IPAddress[] addresses, int port);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static ValueTask ConnectAsync(Socket socket, IPAddress[] addresses, int port, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task ConnectAsync(Socket socket, string host, int port);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static ValueTask ConnectAsync(Socket socket, string host, int port, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<int> ReceiveAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static ValueTask`1<int> ReceiveAsync(Socket socket, Memory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<int> ReceiveAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<SocketReceiveFromResult> ReceiveFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<SocketReceiveMessageFromResult> ReceiveMessageFromAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEndPoint);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<int> SendAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static ValueTask`1<int> SendAsync(Socket socket, ReadOnlyMemory`1<byte> buffer, SocketFlags socketFlags, CancellationToken cancellationToken);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<int> SendAsync(Socket socket, IList`1<ArraySegment`1<byte>> buffers, SocketFlags socketFlags);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static Task`1<int> SendToAsync(Socket socket, ArraySegment`1<byte> buffer, SocketFlags socketFlags, EndPoint remoteEP);
}
public enum System.Net.Sockets.SocketType : Enum {
    public int value__;
    public static SocketType Stream;
    public static SocketType Dgram;
    public static SocketType Raw;
    public static SocketType Rdm;
    public static SocketType Seqpacket;
    public static SocketType Unknown;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.TcpClient : object {
    private AddressFamily _family;
    private Socket _clientSocket;
    private NetworkStream _dataStream;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _disposed;
    private bool _active;
    private bool Disposed { get; }
    protected bool Active { get; protected set; }
    public int Available { get; }
    public Socket Client { get; public set; }
    public bool Connected { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int SendBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendTimeout { get; public set; }
    [NullableAttribute("2")]
public LingerOption LingerState { get; public set; }
    public bool NoDelay { get; public set; }
    public TcpClient(AddressFamily family);
    public TcpClient(IPEndPoint localEP);
    public TcpClient(string hostname, int port);
    internal TcpClient(Socket acceptedSocket);
    private bool get_Disposed();
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public Socket get_Client();
    public void set_Client(Socket value);
    public bool get_Connected();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    public void Connect(string hostname, int port);
    public void Connect(IPAddress address, int port);
    public void Connect(IPEndPoint remoteEP);
    public void Connect(IPAddress[] ipAddresses, int port);
    public Task ConnectAsync(IPAddress address, int port);
    public Task ConnectAsync(string host, int port);
    public Task ConnectAsync(IPAddress[] addresses, int port);
    public Task ConnectAsync(IPEndPoint remoteEP);
    [AsyncStateMachineAttribute("System.Net.Sockets.TcpClient/<CompleteConnectAsync>d__33")]
private Task CompleteConnectAsync(Task task);
    public ValueTask ConnectAsync(IPAddress address, int port, CancellationToken cancellationToken);
    public ValueTask ConnectAsync(string host, int port, CancellationToken cancellationToken);
    public ValueTask ConnectAsync(IPAddress[] addresses, int port, CancellationToken cancellationToken);
    public ValueTask ConnectAsync(IPEndPoint remoteEP, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Sockets.TcpClient/<CompleteConnectAsync>d__38")]
private ValueTask CompleteConnectAsync(ValueTask task);
    public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state);
    public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);
    public void EndConnect(IAsyncResult asyncResult);
    public NetworkStream GetStream();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    [NullableContextAttribute("2")]
public LingerOption get_LingerState();
    [NullableContextAttribute("2")]
public void set_LingerState(LingerOption value);
    public bool get_NoDelay();
    public void set_NoDelay(bool value);
    private void InitializeClientSocket();
    private void ThrowIfDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.TcpListener : object {
    private IPEndPoint _serverSocketEP;
    private Socket _serverSocket;
    private bool _active;
    private bool _exclusiveAddressUse;
    private Nullable`1<bool> _allowNatTraversal;
    public Socket Server { get; }
    protected bool Active { get; }
    public EndPoint LocalEndpoint { get; }
    public bool ExclusiveAddressUse { get; public set; }
    public TcpListener(IPEndPoint localEP);
    public TcpListener(IPAddress localaddr, int port);
    [ObsoleteAttribute("This constructor has been deprecated. Use TcpListener(IPAddress localaddr, int port) instead.")]
public TcpListener(int port);
    public Socket get_Server();
    protected bool get_Active();
    public EndPoint get_LocalEndpoint();
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    [SupportedOSPlatformAttribute("windows")]
public void AllowNatTraversal(bool allowed);
    public void Start();
    public void Start(int backlog);
    public void Stop();
    public sealed virtual void Dispose();
    public bool Pending();
    public Socket AcceptSocket();
    public TcpClient AcceptTcpClient();
    [NullableContextAttribute("2")]
public IAsyncResult BeginAcceptSocket(AsyncCallback callback, object state);
    public Socket EndAcceptSocket(IAsyncResult asyncResult);
    [NullableContextAttribute("2")]
public IAsyncResult BeginAcceptTcpClient(AsyncCallback callback, object state);
    public TcpClient EndAcceptTcpClient(IAsyncResult asyncResult);
    public Task`1<Socket> AcceptSocketAsync();
    public ValueTask`1<Socket> AcceptSocketAsync(CancellationToken cancellationToken);
    public Task`1<TcpClient> AcceptTcpClientAsync();
    public ValueTask`1<TcpClient> AcceptTcpClientAsync(CancellationToken cancellationToken);
    public static TcpListener Create(int port);
    [SupportedOSPlatformAttribute("windows")]
private void SetIPProtectionLevel(bool allowed);
    private void CreateNewSocketIfNeeded();
    private TResult EndAcceptCore(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Net.Sockets.TcpListener/<<AcceptTcpClientAsync>g__WaitAndWrap|32_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<TcpClient> <AcceptTcpClientAsync>g__WaitAndWrap|32_0(ValueTask`1<Socket> task);
}
[FlagsAttribute]
internal enum System.Net.Sockets.TrackedSocketOptions : Enum {
    public short value__;
    public static TrackedSocketOptions DontFragment;
    public static TrackedSocketOptions DualMode;
    public static TrackedSocketOptions EnableBroadcast;
    public static TrackedSocketOptions LingerState;
    public static TrackedSocketOptions NoDelay;
    public static TrackedSocketOptions ReceiveBufferSize;
    public static TrackedSocketOptions ReceiveTimeout;
    public static TrackedSocketOptions SendBufferSize;
    public static TrackedSocketOptions SendTimeout;
    public static TrackedSocketOptions Ttl;
}
[FlagsAttribute]
public enum System.Net.Sockets.TransmitFileOptions : Enum {
    public int value__;
    public static TransmitFileOptions UseDefaultWorkerThread;
    public static TransmitFileOptions Disconnect;
    public static TransmitFileOptions ReuseSocket;
    [SupportedOSPlatformAttribute("windows")]
public static TransmitFileOptions WriteBehind;
    [SupportedOSPlatformAttribute("windows")]
public static TransmitFileOptions UseSystemThread;
    [SupportedOSPlatformAttribute("windows")]
public static TransmitFileOptions UseKernelApc;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.UdpClient : object {
    private Socket _clientSocket;
    private bool _active;
    private Byte[] _buffer;
    private AddressFamily _family;
    private bool _disposed;
    private bool _isBroadcast;
    protected bool Active { get; protected set; }
    public int Available { get; }
    public Socket Client { get; public set; }
    public short Ttl { get; public set; }
    public bool DontFragment { get; public set; }
    public bool MulticastLoopback { get; public set; }
    public bool EnableBroadcast { get; public set; }
    public bool ExclusiveAddressUse { get; public set; }
    public UdpClient(AddressFamily family);
    public UdpClient(int port);
    public UdpClient(int port, AddressFamily family);
    public UdpClient(IPEndPoint localEP);
    public UdpClient(string hostname, int port);
    protected bool get_Active();
    protected void set_Active(bool value);
    public int get_Available();
    public Socket get_Client();
    public void set_Client(Socket value);
    public short get_Ttl();
    public void set_Ttl(short value);
    public bool get_DontFragment();
    public void set_DontFragment(bool value);
    public bool get_MulticastLoopback();
    public void set_MulticastLoopback(bool value);
    public bool get_EnableBroadcast();
    public void set_EnableBroadcast(bool value);
    public bool get_ExclusiveAddressUse();
    public void set_ExclusiveAddressUse(bool value);
    [SupportedOSPlatformAttribute("windows")]
public void AllowNatTraversal(bool allowed);
    private bool IsAddressFamilyCompatible(AddressFamily family);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void CheckForBroadcast(IPAddress ipAddress);
    private static bool IsBroadcast(IPAddress address);
    public IAsyncResult BeginSend(Byte[] datagram, int bytes, AsyncCallback requestCallback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSend(Byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);
    [NullableContextAttribute("2")]
public IAsyncResult BeginSend(Byte[] datagram, int bytes, IPEndPoint endPoint, AsyncCallback requestCallback, object state);
    public int EndSend(IAsyncResult asyncResult);
    private void ValidateDatagram(Byte[] datagram, int bytes, IPEndPoint endPoint);
    private IPEndPoint GetEndpoint(string hostname, int port);
    [NullableContextAttribute("2")]
public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state);
    public Byte[] EndReceive(IAsyncResult asyncResult, IPEndPoint& remoteEP);
    public void JoinMulticastGroup(IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, IPAddress localAddress);
    public void JoinMulticastGroup(int ifindex, IPAddress multicastAddr);
    public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive);
    public void DropMulticastGroup(IPAddress multicastAddr);
    public void DropMulticastGroup(IPAddress multicastAddr, int ifindex);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> datagram, CancellationToken cancellationToken);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, string hostname, int port);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> datagram, string hostname, int port, CancellationToken cancellationToken);
    public Task`1<int> SendAsync(Byte[] datagram, int bytes, IPEndPoint endPoint);
    [NullableContextAttribute("0")]
public ValueTask`1<int> SendAsync(ReadOnlyMemory`1<byte> datagram, IPEndPoint endPoint, CancellationToken cancellationToken);
    public Task`1<UdpReceiveResult> ReceiveAsync();
    [NullableContextAttribute("0")]
public ValueTask`1<UdpReceiveResult> ReceiveAsync(CancellationToken cancellationToken);
    private void CreateClientSocket();
    public void Close();
    public void Connect(string hostname, int port);
    public void Connect(IPAddress addr, int port);
    public void Connect(IPEndPoint endPoint);
    public Byte[] Receive(IPEndPoint& remoteEP);
    public int Send(Byte[] dgram, int bytes, IPEndPoint endPoint);
    [NullableContextAttribute("0")]
public int Send(ReadOnlySpan`1<byte> datagram, IPEndPoint endPoint);
    public int Send(Byte[] dgram, int bytes, string hostname, int port);
    [NullableContextAttribute("0")]
public int Send(ReadOnlySpan`1<byte> datagram, string hostname, int port);
    public int Send(Byte[] dgram, int bytes);
    [NullableContextAttribute("0")]
public int Send(ReadOnlySpan`1<byte> datagram);
    private void ThrowIfDisposed();
    [AsyncStateMachineAttribute("System.Net.Sockets.UdpClient/<<ReceiveAsync>g__WaitAndWrap|61_0>d")]
[CompilerGeneratedAttribute]
private Task`1<UdpReceiveResult> <ReceiveAsync>g__WaitAndWrap|61_0(Task`1<SocketReceiveFromResult> task);
    [AsyncStateMachineAttribute("System.Net.Sockets.UdpClient/<<ReceiveAsync>g__WaitAndWrap|62_0>d")]
[CompilerGeneratedAttribute]
private ValueTask`1<UdpReceiveResult> <ReceiveAsync>g__WaitAndWrap|62_0(ValueTask`1<SocketReceiveFromResult> task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.UdpReceiveResult : ValueType {
    private Byte[] _buffer;
    private IPEndPoint _remoteEndPoint;
    public Byte[] Buffer { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public UdpReceiveResult(Byte[] buffer, IPEndPoint remoteEndPoint);
    public Byte[] get_Buffer();
    public IPEndPoint get_RemoteEndPoint();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UdpReceiveResult other);
    public static bool op_Equality(UdpReceiveResult left, UdpReceiveResult right);
    public static bool op_Inequality(UdpReceiveResult left, UdpReceiveResult right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Sockets.UnixDomainSocketEndPoint : EndPoint {
    private string _path;
    private Byte[] _encodedPath;
    [CompilerGeneratedAttribute]
private string <BoundFileName>k__BackingField;
    private static int s_nativePathOffset;
    private static int s_nativePathLength;
    private static int s_nativeAddressSize;
    [NullableAttribute("2")]
internal string BoundFileName { get; }
    public AddressFamily AddressFamily { get; }
    public UnixDomainSocketEndPoint(string path);
    private UnixDomainSocketEndPoint(string path, string boundFileName);
    internal UnixDomainSocketEndPoint(ReadOnlySpan`1<byte> socketAddress);
    private static UnixDomainSocketEndPoint();
    [CompilerGeneratedAttribute]
internal string get_BoundFileName();
    public virtual SocketAddress Serialize();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual AddressFamily get_AddressFamily();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal UnixDomainSocketEndPoint CreateBoundEndPoint();
    internal UnixDomainSocketEndPoint CreateUnboundEndPoint();
    private static bool IsAbstract(string path);
    private static bool IsAbstract(Byte[] encodedPath);
    private SocketAddress CreateSocketAddressForSerialize();
}
internal static class System.Net.TcpValidationHelpers : object {
    public static bool ValidatePortNumber(int port);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string net_invalidversion { get; }
    internal static string net_noseek { get; }
    internal static string net_invasync { get; }
    internal static string net_io_timeout_use_gt_zero { get; }
    internal static string net_notconnected { get; }
    internal static string net_notstream { get; }
    internal static string net_stopped { get; }
    internal static string net_udpconnected { get; }
    internal static string net_readonlystream { get; }
    internal static string net_writeonlystream { get; }
    internal static string net_InvalidEndPointAddressFamily { get; }
    internal static string net_invalidAddressList { get; }
    internal static string net_protocol_invalid_family { get; }
    internal static string net_protocol_invalid_multicast_family { get; }
    internal static string net_sockets_zerolist { get; }
    internal static string net_sockets_blocking { get; }
    internal static string net_sockets_useblocking { get; }
    internal static string net_sockets_select { get; }
    internal static string net_sockets_toolarge_select { get; }
    internal static string net_sockets_empty_select { get; }
    internal static string net_sockets_mustbind { get; }
    internal static string net_sockets_mustlisten { get; }
    internal static string net_sockets_mustnotlisten { get; }
    internal static string net_sockets_mustnotbebound { get; }
    internal static string net_sockets_namedmustnotbebound { get; }
    internal static string net_sockets_invalid_ipaddress_length { get; }
    internal static string net_sockets_invalid_optionValue { get; }
    internal static string net_sockets_invalid_optionValue_all { get; }
    internal static string net_sockets_invalid_dnsendpoint { get; }
    internal static string net_sockets_disconnectedConnect { get; }
    internal static string net_sockets_disconnectedAccept { get; }
    internal static string net_tcplistener_mustbestopped { get; }
    internal static string net_socketopinprogress { get; }
    internal static string net_buffercounttoosmall { get; }
    internal static string net_multibuffernotsupported { get; }
    internal static string net_ambiguousbuffers { get; }
    internal static string net_io_writefailure { get; }
    internal static string net_io_readfailure { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper_Named { get; }
    internal static string net_sockets_connect_multiconnect_notsupported { get; }
    internal static string net_sockets_dualmode_receivefrom_notsupported { get; }
    internal static string net_sockets_accept_receive_notsupported { get; }
    internal static string net_sockets_duplicateandclose_notsupported { get; }
    internal static string net_sockets_transmitfileoptions_notsupported { get; }
    internal static string ArgumentOutOfRange_PathLengthInvalid { get; }
    internal static string net_io_readwritefailure { get; }
    internal static string PlatformNotSupported_IOControl { get; }
    internal static string PlatformNotSupported_IPProtectionLevel { get; }
    internal static string InvalidOperation_BufferNotExplicitArray { get; }
    internal static string InvalidOperation_IncorrectToken { get; }
    internal static string net_sockets_sendpackelement_FileStreamMustBeAsync { get; }
    internal static string InvalidNullArgument { get; }
    internal static string net_sockets_handle_already_used { get; }
    internal static string net_sockets_address_small { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_InvalidHandle();
    internal static string get_net_invalidversion();
    internal static string get_net_noseek();
    internal static string get_net_invasync();
    internal static string get_net_io_timeout_use_gt_zero();
    internal static string get_net_notconnected();
    internal static string get_net_notstream();
    internal static string get_net_stopped();
    internal static string get_net_udpconnected();
    internal static string get_net_readonlystream();
    internal static string get_net_writeonlystream();
    internal static string get_net_InvalidEndPointAddressFamily();
    internal static string get_net_invalidAddressList();
    internal static string get_net_protocol_invalid_family();
    internal static string get_net_protocol_invalid_multicast_family();
    internal static string get_net_sockets_zerolist();
    internal static string get_net_sockets_blocking();
    internal static string get_net_sockets_useblocking();
    internal static string get_net_sockets_select();
    internal static string get_net_sockets_toolarge_select();
    internal static string get_net_sockets_empty_select();
    internal static string get_net_sockets_mustbind();
    internal static string get_net_sockets_mustlisten();
    internal static string get_net_sockets_mustnotlisten();
    internal static string get_net_sockets_mustnotbebound();
    internal static string get_net_sockets_namedmustnotbebound();
    internal static string get_net_sockets_invalid_ipaddress_length();
    internal static string get_net_sockets_invalid_optionValue();
    internal static string get_net_sockets_invalid_optionValue_all();
    internal static string get_net_sockets_invalid_dnsendpoint();
    internal static string get_net_sockets_disconnectedConnect();
    internal static string get_net_sockets_disconnectedAccept();
    internal static string get_net_tcplistener_mustbestopped();
    internal static string get_net_socketopinprogress();
    internal static string get_net_buffercounttoosmall();
    internal static string get_net_multibuffernotsupported();
    internal static string get_net_ambiguousbuffers();
    internal static string get_net_io_writefailure();
    internal static string get_net_io_readfailure();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper_Named();
    internal static string get_net_sockets_connect_multiconnect_notsupported();
    internal static string get_net_sockets_dualmode_receivefrom_notsupported();
    internal static string get_net_sockets_accept_receive_notsupported();
    internal static string get_net_sockets_duplicateandclose_notsupported();
    internal static string get_net_sockets_transmitfileoptions_notsupported();
    internal static string get_ArgumentOutOfRange_PathLengthInvalid();
    internal static string get_net_io_readwritefailure();
    internal static string get_PlatformNotSupported_IOControl();
    internal static string get_PlatformNotSupported_IPProtectionLevel();
    internal static string get_InvalidOperation_BufferNotExplicitArray();
    internal static string get_InvalidOperation_IncorrectToken();
    internal static string get_net_sockets_sendpackelement_FileStreamMustBeAsync();
    internal static string get_InvalidNullArgument();
    internal static string get_net_sockets_handle_already_used();
    internal static string get_net_sockets_address_small();
}
