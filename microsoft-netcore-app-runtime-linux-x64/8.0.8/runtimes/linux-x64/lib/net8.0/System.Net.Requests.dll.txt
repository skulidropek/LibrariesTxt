internal static class FxResources.System.Net.Requests.SR : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.AuthenticationManager : object {
    [CompilerGeneratedAttribute]
private static ICredentialPolicy <CredentialPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private static StringDictionary <CustomTargetNameDictionary>k__BackingField;
    [NullableAttribute("2")]
public static ICredentialPolicy CredentialPolicy { get; public set; }
    public static StringDictionary CustomTargetNameDictionary { get; }
    public static IEnumerator RegisteredModules { get; }
    private static AuthenticationManager();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static ICredentialPolicy get_CredentialPolicy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_CredentialPolicy(ICredentialPolicy value);
    [CompilerGeneratedAttribute]
public static StringDictionary get_CustomTargetNameDictionary();
    [ObsoleteAttribute("The AuthenticationManager Authenticate and PreAuthenticate methods are not supported and throw PlatformNotSupportedException.")]
public static Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    [ObsoleteAttribute("The AuthenticationManager Authenticate and PreAuthenticate methods are not supported and throw PlatformNotSupportedException.")]
public static Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public static void Register(IAuthenticationModule authenticationModule);
    public static void Unregister(IAuthenticationModule authenticationModule);
    public static void Unregister(string authenticationScheme);
    public static IEnumerator get_RegisteredModules();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.Authorization : object {
    private String[] _protectionRealm;
    private bool _mutualAuth;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionGroupId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Complete>k__BackingField;
    public string Message { get; }
    public string ConnectionGroupId { get; }
    public bool Complete { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ProtectionRealm { get; public set; }
    public bool MutuallyAuthenticated { get; public set; }
    public Authorization(string token);
    public Authorization(string token, bool finished);
    public Authorization(string token, bool finished, string connectionGroupId);
    internal Authorization(string token, bool finished, string connectionGroupId, bool mutualAuth);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_ConnectionGroupId();
    [CompilerGeneratedAttribute]
public bool get_Complete();
    [CompilerGeneratedAttribute]
internal void set_Complete(bool value);
    public String[] get_ProtectionRealm();
    public void set_ProtectionRealm(String[] value);
    public bool get_MutuallyAuthenticated();
    public void set_MutuallyAuthenticated(bool value);
}
public enum System.Net.Cache.HttpCacheAgeControl : Enum {
    public int value__;
    public static HttpCacheAgeControl None;
    public static HttpCacheAgeControl MinFresh;
    public static HttpCacheAgeControl MaxAge;
    public static HttpCacheAgeControl MaxStale;
    public static HttpCacheAgeControl MaxAgeAndMinFresh;
    public static HttpCacheAgeControl MaxAgeAndMaxStale;
}
public enum System.Net.Cache.HttpRequestCacheLevel : Enum {
    public int value__;
    public static HttpRequestCacheLevel Default;
    public static HttpRequestCacheLevel BypassCache;
    public static HttpRequestCacheLevel CacheOnly;
    public static HttpRequestCacheLevel CacheIfAvailable;
    public static HttpRequestCacheLevel Revalidate;
    public static HttpRequestCacheLevel Reload;
    public static HttpRequestCacheLevel NoCacheNoStore;
    public static HttpRequestCacheLevel CacheOrNextCacheOnly;
    public static HttpRequestCacheLevel Refresh;
}
public class System.Net.Cache.HttpRequestCachePolicy : RequestCachePolicy {
    private DateTime _lastSyncDateUtc;
    private TimeSpan _maxAge;
    private TimeSpan _minFresh;
    private TimeSpan _maxStale;
    [CompilerGeneratedAttribute]
private HttpRequestCacheLevel <Level>k__BackingField;
    public HttpRequestCacheLevel Level { get; }
    public DateTime CacheSyncDate { get; }
    public TimeSpan MaxAge { get; }
    public TimeSpan MinFresh { get; }
    public TimeSpan MaxStale { get; }
    public HttpRequestCachePolicy(HttpRequestCacheLevel level);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan ageOrFreshOrStale);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale);
    public HttpRequestCachePolicy(DateTime cacheSyncDate);
    public HttpRequestCachePolicy(HttpCacheAgeControl cacheAgeControl, TimeSpan maxAge, TimeSpan freshOrStale, DateTime cacheSyncDate);
    [CompilerGeneratedAttribute]
public HttpRequestCacheLevel get_Level();
    public DateTime get_CacheSyncDate();
    public TimeSpan get_MaxAge();
    public TimeSpan get_MinFresh();
    public TimeSpan get_MaxStale();
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static RequestCacheLevel MapLevel(HttpRequestCacheLevel level);
}
[FlagsAttribute]
internal enum System.Net.CloseExState : Enum {
    public int value__;
    public static CloseExState Normal;
    public static CloseExState Abort;
    public static CloseExState Silent;
}
internal class System.Net.CommandStream : NetworkStreamWrapper {
    private static AsyncCallback s_writeCallbackDelegate;
    private static AsyncCallback s_readCallbackDelegate;
    private bool _recoverableFailure;
    protected WebRequest _request;
    protected bool _isAsync;
    private bool _aborted;
    protected PipelineEntry[] _commands;
    protected int _index;
    private bool _doRead;
    private bool _doSend;
    private ResponseDescription _currentResponseDescription;
    protected string _abortReason;
    private string _buffer;
    private Encoding _encoding;
    private Decoder _decoder;
    internal bool RecoverableFailure { get; }
    protected Encoding Encoding { get; protected set; }
    internal CommandStream(NetworkStream client);
    private static CommandStream();
    internal virtual void Abort(Exception e);
    protected virtual void Dispose(bool disposing);
    protected void InvokeRequestCallback(object obj);
    internal bool get_RecoverableFailure();
    protected void MarkAsRecoverableFailure();
    internal Stream SubmitRequest(WebRequest request, bool isAsync, bool readInitalResponseOnConnect);
    protected virtual void ClearState();
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest request);
    protected static Exception GenerateException(string message, WebExceptionStatus status, Exception innerException);
    protected static Exception GenerateException(FtpStatusCode code, string statusDescription, Exception innerException);
    protected void InitCommandPipeline(WebRequest request, PipelineEntry[] commands, bool isAsync);
    internal void CheckContinuePipeline();
    protected Stream ContinueCommandPipeline();
    private bool PostSendCommandProcessing(Stream& stream);
    private bool PostReadCommandProcessing(Stream& stream);
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    private static void ReadCallback(IAsyncResult asyncResult);
    private static void WriteCallback(IAsyncResult asyncResult);
    protected Encoding get_Encoding();
    protected void set_Encoding(Encoding value);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
    private ResponseDescription ReceiveCommandResponse();
    private void ReceiveCommandResponseCallback(ReceiveState state, int bytesRead);
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    internal ContextAwareResult(object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.ExceptionHelper : object {
    internal static NotSupportedException PropertyNotSupportedException { get; }
    internal static WebException RequestAbortedException { get; }
    internal static WebException TimeoutException { get; }
    internal static NotSupportedException get_PropertyNotSupportedException();
    internal static WebException get_RequestAbortedException();
    internal static WebException get_TimeoutException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.FileWebRequest : WebRequest {
    private WebHeaderCollection _headers;
    private string _method;
    private FileAccess _fileAccess;
    private ManualResetEventSlim _blockReaderUntilRequestStreamDisposed;
    private FileWebResponse _response;
    private WebFileStream _stream;
    private Uri _uri;
    private long _contentLength;
    private int _timeout;
    private bool _readPending;
    private bool _writePending;
    private bool _writing;
    private bool _syncHint;
    private int _aborted;
    [CompilerGeneratedAttribute]
private string <ConnectionGroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreAuthenticate>k__BackingField;
    [CompilerGeneratedAttribute]
private IWebProxy <Proxy>k__BackingField;
    internal bool Aborted { get; }
    [NullableAttribute("2")]
public string ConnectionGroupName { get; public set; }
    public long ContentLength { get; public set; }
    [NullableAttribute("2")]
public string ContentType { get; public set; }
    [NullableAttribute("2")]
public ICredentials Credentials { get; public set; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; public set; }
    public bool PreAuthenticate { get; public set; }
    [NullableAttribute("2")]
public IWebProxy Proxy { get; public set; }
    public int Timeout { get; public set; }
    public Uri RequestUri { get; }
    public bool UseDefaultCredentials { get; public set; }
    internal FileWebRequest(Uri uri);
    [ObsoleteAttribute("Serialization has been deprecated for FileWebRequest.")]
[EditorBrowsableAttribute("1")]
protected FileWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for FileWebRequest.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for FileWebRequest.")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal bool get_Aborted();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual string get_ConnectionGroupName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void set_ConnectionGroupName(string value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    [NullableContextAttribute("2")]
public virtual string get_ContentType();
    [NullableContextAttribute("2")]
public virtual void set_ContentType(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual ICredentials get_Credentials();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void set_Credentials(ICredentials value);
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual void set_Method(string value);
    [CompilerGeneratedAttribute]
public virtual bool get_PreAuthenticate();
    [CompilerGeneratedAttribute]
public virtual void set_PreAuthenticate(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual IWebProxy get_Proxy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void set_Proxy(IWebProxy value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual Uri get_RequestUri();
    private static WebException CreateRequestAbortedException();
    private void CheckAndMarkAsyncGetRequestStreamPending();
    private WebFileStream CreateWriteStream();
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Task`1<Stream> GetRequestStreamAsync();
    private void CheckAndMarkAsyncGetResponsePending();
    private WebResponse CreateResponse();
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual Task`1<WebResponse> GetResponseAsync();
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    internal void UnblockReader();
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual void Abort();
    [CompilerGeneratedAttribute]
private WebResponse <GetResponseAsync>b__60_0(object s);
}
internal class System.Net.FileWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.FileWebResponse : WebResponse {
    private long _contentLength;
    private FileAccess _fileAccess;
    private WebHeaderCollection _headers;
    private Uri _uri;
    private Stream _stream;
    private bool _closed;
    public long ContentLength { get; }
    public string ContentType { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    public Uri ResponseUri { get; }
    internal FileWebResponse(FileWebRequest request, Uri uri, FileAccess access, bool useAsync);
    [ObsoleteAttribute("Serialization has been deprecated for FileWebResponse.")]
[EditorBrowsableAttribute("1")]
protected FileWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for FileWebResponse.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for FileWebResponse.")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    public virtual Uri get_ResponseUri();
    private void CheckDisposed();
    public virtual void Close();
    public virtual Stream GetResponseStream();
}
internal class System.Net.FtpControlStream : CommandStream {
    private Socket _dataSocket;
    private IPEndPoint _passiveEndPoint;
    private TlsStream _tlsStream;
    private StringBuilder _bannerMessage;
    private StringBuilder _welcomeMessage;
    private StringBuilder _exitMessage;
    private WeakReference _credentials;
    private string _currentTypeSetting;
    private long _contentLength;
    private DateTime _lastModified;
    private bool _dataHandshakeStarted;
    private string _loginDirectory;
    private string _establishedServerDirectory;
    private string _requestedServerDirectory;
    private Uri _responseUri;
    private FtpLoginState _loginState;
    internal FtpStatusCode StatusCode;
    internal string StatusLine;
    private static AsyncCallback s_acceptCallbackDelegate;
    private static AsyncCallback s_connectCallbackDelegate;
    private static AsyncCallback s_SSLHandshakeCallback;
    private static Char[] s_whitespaceDot;
    private static Char[] s_spaceCommaBrackets;
    internal NetworkCredential Credentials { get; internal set; }
    internal long ContentLength { get; }
    internal DateTime LastModified { get; }
    internal Uri ResponseUri { get; }
    internal string BannerMessage { get; }
    internal string WelcomeMessage { get; }
    internal string ExitMessage { get; }
    internal FtpControlStream(NetworkStream client);
    private static FtpControlStream();
    internal NetworkCredential get_Credentials();
    internal void set_Credentials(NetworkCredential value);
    internal void AbortConnect();
    private static void AcceptCallback(IAsyncResult asyncResult);
    private static void ConnectCallback(IAsyncResult asyncResult);
    private static void SSLHandshakeCallback(IAsyncResult asyncResult);
    private PipelineInstruction QueueOrCreateFtpDataStream(Stream& stream);
    protected virtual void ClearState();
    protected virtual PipelineInstruction PipelineCallback(PipelineEntry entry, ResponseDescription response, bool timeout, Stream& stream);
    protected virtual PipelineEntry[] BuildCommandsList(WebRequest req);
    private PipelineInstruction QueueOrCreateDataConection(PipelineEntry entry, ResponseDescription response, Boolean& isSocketReady);
    private static void GetPathInfo(GetPathOption pathOption, Uri uri, String& path, String& directory, String& filename);
    private static string FormatAddress(IPAddress address, int Port);
    private static string FormatAddressV6(IPAddress address, int port);
    internal long get_ContentLength();
    internal DateTime get_LastModified();
    internal Uri get_ResponseUri();
    internal string get_BannerMessage();
    internal string get_WelcomeMessage();
    internal string get_ExitMessage();
    private static long GetContentLengthFrom213Response(string responseString);
    private DateTime GetLastModifiedFrom213Response(string str);
    private void TryUpdateResponseUri(string str, FtpWebRequest request);
    private void TryUpdateContentLength(string str);
    private static string GetLoginDirectory(string str);
    private static int GetPortV4(string responseString);
    private static int GetPortV6(string responseString);
    private void CreateFtpListenerSocket();
    private string GetPortCommandLine();
    private static string FormatFtpCommand(string command, string parameter);
    private static Socket CreateFtpDataSocket(Socket templateSocket);
    protected virtual bool CheckValid(ResponseDescription response, Int32& validThrough, Int32& completeLength);
    private TriState IsFtpDataStreamWriteable();
}
internal class System.Net.FtpDataStream : Stream {
    private FtpWebRequest _request;
    private NetworkStream _networkStream;
    private bool _writeable;
    private bool _readable;
    private bool _isFullyRead;
    private bool _closing;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    internal FtpDataStream(NetworkStream networkStream, FtpWebRequest request, TriState writeOnly);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override void System.Net.ICloseEx.CloseEx(CloseExState closeState);
    private void CheckError();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    private void AsyncReadCallback(IAsyncResult ar);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual void SetLength(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    internal void SetSocketTimeoutOption(int timeout);
}
internal enum System.Net.FtpLoginState : Enum {
    public byte value__;
    public static FtpLoginState NotLoggedIn;
    public static FtpLoginState LoggedIn;
    public static FtpLoginState LoggedInButNeedsRelogin;
    public static FtpLoginState ReloginFailed;
}
[FlagsAttribute]
internal enum System.Net.FtpMethodFlags : Enum {
    public int value__;
    public static FtpMethodFlags None;
    public static FtpMethodFlags IsDownload;
    public static FtpMethodFlags IsUpload;
    public static FtpMethodFlags TakesParameter;
    public static FtpMethodFlags MayTakeParameter;
    public static FtpMethodFlags DoesNotTakeParameter;
    public static FtpMethodFlags ParameterIsDirectory;
    public static FtpMethodFlags ShouldParseForResponseUri;
    public static FtpMethodFlags HasHttpCommand;
    public static FtpMethodFlags MustChangeWorkingDirectoryToPath;
}
internal class System.Net.FtpMethodInfo : object {
    internal string Method;
    internal FtpOperation Operation;
    internal FtpMethodFlags Flags;
    internal string HttpCommand;
    private static FtpMethodInfo[] s_knownMethodInfo;
    internal bool IsCommandOnly { get; }
    internal bool IsUpload { get; }
    internal bool IsDownload { get; }
    internal bool ShouldParseForResponseUri { get; }
    internal FtpMethodInfo(string method, FtpOperation operation, FtpMethodFlags flags, string httpCommand);
    private static FtpMethodInfo();
    internal bool HasFlag(FtpMethodFlags flags);
    internal bool get_IsCommandOnly();
    internal bool get_IsUpload();
    internal bool get_IsDownload();
    internal bool get_ShouldParseForResponseUri();
    internal static FtpMethodInfo GetMethodInfo(string method);
}
internal enum System.Net.FtpOperation : Enum {
    public int value__;
    public static FtpOperation DownloadFile;
    public static FtpOperation ListDirectory;
    public static FtpOperation ListDirectoryDetails;
    public static FtpOperation UploadFile;
    public static FtpOperation UploadFileUnique;
    public static FtpOperation AppendFile;
    public static FtpOperation DeleteFile;
    public static FtpOperation GetDateTimestamp;
    public static FtpOperation GetFileSize;
    public static FtpOperation Rename;
    public static FtpOperation MakeDirectory;
    public static FtpOperation RemoveDirectory;
    public static FtpOperation PrintWorkingDirectory;
    public static FtpOperation Other;
}
public enum System.Net.FtpStatusCode : Enum {
    public int value__;
    public static FtpStatusCode Undefined;
    public static FtpStatusCode RestartMarker;
    public static FtpStatusCode ServiceTemporarilyNotAvailable;
    public static FtpStatusCode DataAlreadyOpen;
    public static FtpStatusCode OpeningData;
    public static FtpStatusCode CommandOK;
    public static FtpStatusCode CommandExtraneous;
    public static FtpStatusCode DirectoryStatus;
    public static FtpStatusCode FileStatus;
    public static FtpStatusCode SystemType;
    public static FtpStatusCode SendUserCommand;
    public static FtpStatusCode ClosingControl;
    public static FtpStatusCode ClosingData;
    public static FtpStatusCode EnteringPassive;
    public static FtpStatusCode LoggedInProceed;
    public static FtpStatusCode ServerWantsSecureSession;
    public static FtpStatusCode FileActionOK;
    public static FtpStatusCode PathnameCreated;
    public static FtpStatusCode SendPasswordCommand;
    public static FtpStatusCode NeedLoginAccount;
    public static FtpStatusCode FileCommandPending;
    public static FtpStatusCode ServiceNotAvailable;
    public static FtpStatusCode CantOpenData;
    public static FtpStatusCode ConnectionClosed;
    public static FtpStatusCode ActionNotTakenFileUnavailableOrBusy;
    public static FtpStatusCode ActionAbortedLocalProcessingError;
    public static FtpStatusCode ActionNotTakenInsufficientSpace;
    public static FtpStatusCode CommandSyntaxError;
    public static FtpStatusCode ArgumentSyntaxError;
    public static FtpStatusCode CommandNotImplemented;
    public static FtpStatusCode BadCommandSequence;
    public static FtpStatusCode NotLoggedIn;
    public static FtpStatusCode AccountNeeded;
    public static FtpStatusCode ActionNotTakenFileUnavailable;
    public static FtpStatusCode ActionAbortedUnknownPageType;
    public static FtpStatusCode FileActionAborted;
    public static FtpStatusCode ActionNotTakenFilenameNotAllowed;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.FtpWebRequest : WebRequest {
    private object _syncObject;
    private ICredentials _authInfo;
    private Uri _uri;
    private FtpMethodInfo _methodInfo;
    private string _renameTo;
    private bool _getRequestStreamStarted;
    private bool _getResponseStarted;
    private DateTime _startTime;
    private int _timeout;
    private int _remainingTimeout;
    private long _contentLength;
    private long _contentOffset;
    private X509CertificateCollection _clientCertificates;
    private bool _passive;
    private bool _binary;
    private string _connectionGroupName;
    private ServicePoint _servicePoint;
    private bool _async;
    private bool _aborted;
    private bool _timedOut;
    private Exception _exception;
    private Queue _timerQueue;
    private Callback _timerCallback;
    private bool _enableSsl;
    private FtpControlStream _connection;
    private Stream _stream;
    private RequestStage _requestStage;
    private bool _onceFailed;
    private WebHeaderCollection _ftpRequestHeaders;
    private FtpWebResponse _ftpWebResponse;
    private int _readWriteTimeout;
    private ContextAwareResult _writeAsyncResult;
    private LazyAsyncResult _readAsyncResult;
    private LazyAsyncResult _requestCompleteAsyncResult;
    private static NetworkCredential s_defaultFtpNetworkCredential;
    private static Queue s_DefaultTimerQueue;
    [NullableAttribute("1")]
internal FtpMethodInfo MethodInfo { get; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    [NullableAttribute("1")]
public string Method { get; public set; }
    public string RenameTo { get; public set; }
    public ICredentials Credentials { get; public set; }
    [NullableAttribute("1")]
public Uri RequestUri { get; }
    public int Timeout { get; public set; }
    internal int RemainingTimeout { get; }
    public int ReadWriteTimeout { get; public set; }
    public long ContentOffset { get; public set; }
    public long ContentLength { get; public set; }
    public IWebProxy Proxy { get; public set; }
    public string ConnectionGroupName { get; public set; }
    [NullableAttribute("1")]
public ServicePoint ServicePoint { get; }
    internal bool Aborted { get; }
    [NullableAttribute("1")]
private Queue TimerQueue { get; }
    public bool KeepAlive { get; public set; }
    public RequestCachePolicy CachePolicy { get; public set; }
    public bool UseBinary { get; public set; }
    public bool UsePassive { get; public set; }
    [NullableAttribute("1")]
public X509CertificateCollection ClientCertificates { get; public set; }
    public bool EnableSsl { get; public set; }
    [NullableAttribute("1")]
public WebHeaderCollection Headers { get; public set; }
    public string ContentType { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public bool PreAuthenticate { get; public set; }
    private bool InUse { get; }
    internal FtpWebRequest(Uri uri);
    private static FtpWebRequest();
    internal FtpMethodInfo get_MethodInfo();
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    [NullableContextAttribute("1")]
public virtual string get_Method();
    [NullableContextAttribute("1")]
public virtual void set_Method(string value);
    public string get_RenameTo();
    public void set_RenameTo(string value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    [NullableContextAttribute("1")]
public virtual Uri get_RequestUri();
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    internal int get_RemainingTimeout();
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public long get_ContentOffset();
    public void set_ContentOffset(long value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual string get_ConnectionGroupName();
    public virtual void set_ConnectionGroupName(string value);
    [NullableContextAttribute("1")]
public ServicePoint get_ServicePoint();
    internal bool get_Aborted();
    [NullableContextAttribute("1")]
public virtual WebResponse GetResponse();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    [NullableContextAttribute("1")]
public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    [NullableContextAttribute("1")]
public virtual Stream GetRequestStream();
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    [NullableContextAttribute("1")]
public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    private void SubmitRequest(bool isAsync);
    private static Exception TranslateConnectException(Exception e);
    [AsyncStateMachineAttribute("System.Net.FtpWebRequest/<CreateConnectionAsync>d__86")]
private void CreateConnectionAsync();
    private FtpControlStream CreateConnection();
    private Stream TimedSubmitRequestHelper(bool isAsync);
    private void TimerCallback(Timer timer, int timeNoticed, object context);
    private Queue get_TimerQueue();
    private bool AttemptedRecovery(Exception e);
    private void SetException(Exception exception);
    private void CheckError();
    internal void RequestCallback(object obj);
    private void SyncRequestCallback(object obj);
    private void AsyncRequestCallback(object obj);
    private RequestStage FinishRequestStage(RequestStage stage);
    public virtual void Abort();
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public virtual RequestCachePolicy get_CachePolicy();
    public virtual void set_CachePolicy(RequestCachePolicy value);
    public bool get_UseBinary();
    public void set_UseBinary(bool value);
    public bool get_UsePassive();
    public void set_UsePassive(bool value);
    [NullableContextAttribute("1")]
public X509CertificateCollection get_ClientCertificates();
    [NullableContextAttribute("1")]
public void set_ClientCertificates(X509CertificateCollection value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    [NullableContextAttribute("1")]
public virtual WebHeaderCollection get_Headers();
    [NullableContextAttribute("1")]
public virtual void set_Headers(WebHeaderCollection value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    private bool get_InUse();
    private void EnsureFtpWebResponse();
    internal void DataStreamClosed(CloseExState closeState);
}
internal class System.Net.FtpWebRequestCreator : object {
    public sealed virtual WebRequest Create(Uri uri);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.FtpWebResponse : WebResponse {
    internal Stream _responseStream;
    private long _contentLength;
    private Uri _responseUri;
    private FtpStatusCode _statusCode;
    private string _statusLine;
    private WebHeaderCollection _ftpRequestHeaders;
    private DateTime _lastModified;
    private string _bannerMessage;
    private string _welcomeMessage;
    private string _exitMessage;
    public long ContentLength { get; }
    [NullableAttribute("1")]
public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    [NullableAttribute("1")]
public Uri ResponseUri { get; }
    public FtpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    public DateTime LastModified { get; }
    public string BannerMessage { get; }
    public string WelcomeMessage { get; }
    public string ExitMessage { get; }
    internal FtpWebResponse(Stream responseStream, long contentLength, Uri responseUri, FtpStatusCode statusCode, string statusLine, DateTime lastModified, string bannerMessage, string welcomeMessage, string exitMessage);
    internal void UpdateStatus(FtpStatusCode statusCode, string statusLine, string exitMessage);
    [NullableContextAttribute("1")]
public virtual Stream GetResponseStream();
    internal void SetResponseStream(Stream stream);
    public virtual void Close();
    public virtual long get_ContentLength();
    [NullableContextAttribute("1")]
public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
    [NullableContextAttribute("1")]
public virtual Uri get_ResponseUri();
    public FtpStatusCode get_StatusCode();
    public string get_StatusDescription();
    public DateTime get_LastModified();
    public string get_BannerMessage();
    public string get_WelcomeMessage();
    public string get_ExitMessage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("GlobalProxySelection has been deprecated. Use WebRequest.DefaultWebProxy instead to access and set the global default proxy. Use 'null' instead of GetEmptyWebProxy.")]
public class System.Net.GlobalProxySelection : object {
    public static IWebProxy Select { get; public set; }
    public static IWebProxy get_Select();
    public static void set_Select(IWebProxy value);
    public static IWebProxy GetEmptyWebProxy();
}
public class System.Net.HttpContinueDelegate : MulticastDelegate {
    public HttpContinueDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(int StatusCode, WebHeaderCollection httpHeaders);
    public virtual IAsyncResult BeginInvoke(int StatusCode, WebHeaderCollection httpHeaders, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Net.HttpDateParser : object {
    private static String[] s_dateFormats;
    private static HttpDateParser();
    internal static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
}
internal static class System.Net.HttpValidationHelpers : object {
    private static Char[] s_httpTrimCharacters;
    private static HttpValidationHelpers();
    internal static bool ContainsNonAsciiChars(string token);
    internal static bool IsValidToken(string token);
    public static string CheckBadHeaderValueChars(string value);
    public static bool IsInvalidMethodOrHeaderString(string stringValue);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Net.HttpWebRequest : WebRequest {
    private WebHeaderCollection _webHeaderCollection;
    private Uri _requestUri;
    private string _originVerb;
    private int _continueTimeout;
    private bool _allowReadStreamBuffering;
    private CookieContainer _cookieContainer;
    private ICredentials _credentials;
    private IWebProxy _proxy;
    private Task`1<HttpResponseMessage> _sendRequestTask;
    private static int _defaultMaxResponseHeadersLength;
    private int _beginGetRequestStreamCalled;
    private int _beginGetResponseCalled;
    private int _endGetRequestStreamCalled;
    private int _endGetResponseCalled;
    private int _maximumAllowedRedirections;
    private int _maximumResponseHeadersLen;
    private ServicePoint _servicePoint;
    private int _timeout;
    private int _readWriteTimeout;
    private HttpContinueDelegate _continueDelegate;
    private bool _hostHasPort;
    private Uri _hostUri;
    private RequestStream _requestStream;
    private TaskCompletionSource`1<Stream> _requestStreamOperation;
    private TaskCompletionSource`1<WebResponse> _responseOperation;
    private AsyncCallback _requestStreamCallback;
    private AsyncCallback _responseCallback;
    private int _abortCalled;
    private CancellationTokenSource _sendRequestCts;
    private X509CertificateCollection _clientCertificates;
    private Booleans _booleans;
    private bool _pipelined;
    private bool _preAuthenticate;
    private DecompressionMethods _automaticDecompression;
    private static object s_syncRoot;
    private static HttpClient modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedHttpClient;
    private static HttpClientParameters s_cachedHttpClientParameters;
    [CompilerGeneratedAttribute]
private string <MediaType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepAlive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionGroupName>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <DefaultMaximumErrorResponseLength>k__BackingField;
    private static RequestCachePolicy _defaultCachePolicy;
    private static bool _isDefaultCachePolicySet;
    [CompilerGeneratedAttribute]
private RemoteCertificateValidationCallback <ServerCertificateValidationCallback>k__BackingField;
    private static String[] s_wellKnownContentHeaders;
    public string Accept { get; public set; }
    public bool AllowReadStreamBuffering { get; public set; }
    public int MaximumResponseHeadersLength { get; public set; }
    public int MaximumAutomaticRedirections { get; public set; }
    public string ContentType { get; public set; }
    public int ContinueTimeout { get; public set; }
    public int Timeout { get; public set; }
    public long ContentLength { get; public set; }
    [NullableAttribute("1")]
public Uri Address { get; }
    public string UserAgent { get; public set; }
    [NullableAttribute("1")]
public string Host { get; public set; }
    public bool Pipelined { get; public set; }
    public string Referer { get; public set; }
    public string MediaType { get; public set; }
    public string TransferEncoding { get; public set; }
    public bool KeepAlive { get; public set; }
    public bool UnsafeAuthenticatedConnectionSharing { get; public set; }
    public DecompressionMethods AutomaticDecompression { get; public set; }
    public bool AllowWriteStreamBuffering { get; public set; }
    public bool AllowAutoRedirect { get; public set; }
    public string ConnectionGroupName { get; public set; }
    public bool PreAuthenticate { get; public set; }
    public string Connection { get; public set; }
    public string Expect { get; public set; }
    public static int DefaultMaximumResponseHeadersLength { get; public set; }
    public static int DefaultMaximumErrorResponseLength { get; public set; }
    public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    public DateTime IfModifiedSince { get; public set; }
    public DateTime Date { get; public set; }
    public bool SendChunked { get; public set; }
    public HttpContinueDelegate ContinueDelegate { get; public set; }
    [NullableAttribute("1")]
public ServicePoint ServicePoint { get; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; public set; }
    [NullableAttribute("1")]
public X509CertificateCollection ClientCertificates { get; public set; }
    [NullableAttribute("1")]
public Version ProtocolVersion { get; public set; }
    public int ReadWriteTimeout { get; public set; }
    public CookieContainer CookieContainer { get; public set; }
    public ICredentials Credentials { get; public set; }
    public bool HaveResponse { get; }
    [NullableAttribute("1")]
public WebHeaderCollection Headers { get; public set; }
    [NullableAttribute("1")]
public string Method { get; public set; }
    [NullableAttribute("1")]
public Uri RequestUri { get; }
    public bool SupportsCookieContainer { get; }
    public bool UseDefaultCredentials { get; public set; }
    public IWebProxy Proxy { get; public set; }
    private bool IsVersionHttp10 { get; private set; }
    private bool RequestSubmitted { get; }
    [NullableContextAttribute("1")]
[ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
[EditorBrowsableAttribute("1")]
protected HttpWebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal HttpWebRequest(Uri uri);
    private static HttpWebRequest();
    [ObsoleteAttribute("Serialization has been deprecated for HttpWebRequest.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Serialization has been deprecated for HttpWebRequest.")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private void SetSpecialHeaders(string HeaderName, string value);
    public string get_Accept();
    public void set_Accept(string value);
    public virtual bool get_AllowReadStreamBuffering();
    public virtual void set_AllowReadStreamBuffering(bool value);
    public int get_MaximumResponseHeadersLength();
    public void set_MaximumResponseHeadersLength(int value);
    public int get_MaximumAutomaticRedirections();
    public void set_MaximumAutomaticRedirections(int value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public int get_ContinueTimeout();
    public void set_ContinueTimeout(int value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    [NullableContextAttribute("1")]
public Uri get_Address();
    public string get_UserAgent();
    public void set_UserAgent(string value);
    [NullableContextAttribute("1")]
public string get_Host();
    [NullableContextAttribute("1")]
public void set_Host(string value);
    public bool get_Pipelined();
    public void set_Pipelined(bool value);
    public string get_Referer();
    public void set_Referer(string value);
    [CompilerGeneratedAttribute]
public string get_MediaType();
    [CompilerGeneratedAttribute]
public void set_MediaType(string value);
    public string get_TransferEncoding();
    public void set_TransferEncoding(string value);
    [CompilerGeneratedAttribute]
public bool get_KeepAlive();
    [CompilerGeneratedAttribute]
public void set_KeepAlive(bool value);
    public bool get_UnsafeAuthenticatedConnectionSharing();
    public void set_UnsafeAuthenticatedConnectionSharing(bool value);
    public DecompressionMethods get_AutomaticDecompression();
    public void set_AutomaticDecompression(DecompressionMethods value);
    public virtual bool get_AllowWriteStreamBuffering();
    public virtual void set_AllowWriteStreamBuffering(bool value);
    public virtual bool get_AllowAutoRedirect();
    public virtual void set_AllowAutoRedirect(bool value);
    [CompilerGeneratedAttribute]
public virtual string get_ConnectionGroupName();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionGroupName(string value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    public string get_Connection();
    public void set_Connection(string value);
    public string get_Expect();
    public void set_Expect(string value);
    public static int get_DefaultMaximumResponseHeadersLength();
    public static void set_DefaultMaximumResponseHeadersLength(int value);
    [CompilerGeneratedAttribute]
public static int get_DefaultMaximumErrorResponseLength();
    [CompilerGeneratedAttribute]
public static void set_DefaultMaximumErrorResponseLength(int value);
    public static RequestCachePolicy get_DefaultCachePolicy();
    public static void set_DefaultCachePolicy(RequestCachePolicy value);
    public DateTime get_IfModifiedSince();
    public void set_IfModifiedSince(DateTime value);
    public DateTime get_Date();
    public void set_Date(DateTime value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    public HttpContinueDelegate get_ContinueDelegate();
    public void set_ContinueDelegate(HttpContinueDelegate value);
    [NullableContextAttribute("1")]
public ServicePoint get_ServicePoint();
    [CompilerGeneratedAttribute]
public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    [CompilerGeneratedAttribute]
public void set_ServerCertificateValidationCallback(RemoteCertificateValidationCallback value);
    [NullableContextAttribute("1")]
public X509CertificateCollection get_ClientCertificates();
    [NullableContextAttribute("1")]
public void set_ClientCertificates(X509CertificateCollection value);
    [NullableContextAttribute("1")]
public Version get_ProtocolVersion();
    [NullableContextAttribute("1")]
public void set_ProtocolVersion(Version value);
    public int get_ReadWriteTimeout();
    public void set_ReadWriteTimeout(int value);
    public virtual CookieContainer get_CookieContainer();
    public virtual void set_CookieContainer(CookieContainer value);
    public virtual ICredentials get_Credentials();
    public virtual void set_Credentials(ICredentials value);
    public virtual bool get_HaveResponse();
    [NullableContextAttribute("1")]
public virtual WebHeaderCollection get_Headers();
    [NullableContextAttribute("1")]
public virtual void set_Headers(WebHeaderCollection value);
    [NullableContextAttribute("1")]
public virtual string get_Method();
    [NullableContextAttribute("1")]
public virtual void set_Method(string value);
    [NullableContextAttribute("1")]
public virtual Uri get_RequestUri();
    public virtual bool get_SupportsCookieContainer();
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual IWebProxy get_Proxy();
    public virtual void set_Proxy(IWebProxy value);
    public virtual void Abort();
    private bool get_IsVersionHttp10();
    private void set_IsVersionHttp10(bool value);
    [NullableContextAttribute("1")]
public virtual WebResponse GetResponse();
    [NullableContextAttribute("1")]
public virtual Stream GetRequestStream();
    private Task`1<Stream> InternalGetRequestStream();
    [NullableContextAttribute("1")]
public Stream EndGetRequestStream(IAsyncResult asyncResult, TransportContext& context);
    [NullableContextAttribute("1")]
public Stream GetRequestStream(TransportContext& context);
    public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    [NullableContextAttribute("1")]
public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Net.HttpWebRequest/<SendRequest>d__196")]
private Task`1<WebResponse> SendRequest(bool async);
    private void AddCacheControlHeaders(HttpRequestMessage request);
    private RequestCachePolicy GetApplicableCachePolicy();
    public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    [NullableContextAttribute("1")]
public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    public void AddRange(int from, int to);
    public void AddRange(long from, long to);
    public void AddRange(int range);
    public void AddRange(long range);
    [NullableContextAttribute("1")]
public void AddRange(string rangeSpecifier, int from, int to);
    [NullableContextAttribute("1")]
public void AddRange(string rangeSpecifier, long from, long to);
    [NullableContextAttribute("1")]
public void AddRange(string rangeSpecifier, int range);
    [NullableContextAttribute("1")]
public void AddRange(string rangeSpecifier, long range);
    private bool AddRange(string rangeSpecifier, string from, string to);
    private bool get_RequestSubmitted();
    private void CheckAbort();
    private static bool IsWellKnownContentHeader(string header);
    private DateTime GetDateHeaderHelper(string headerName);
    private void SetDateHeaderHelper(string headerName, DateTime dateTime);
    private bool TryGetHostUri(string hostName, Uri& hostUri);
    private HttpClient GetCachedOrCreateHttpClient(bool async, Boolean& disposeRequired);
    private static HttpClient CreateHttpClient(HttpClientParameters parameters, HttpWebRequest request);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.HttpWebResponse : WebResponse {
    private HttpResponseMessage _httpResponseMessage;
    private Uri _requestUri;
    private CookieCollection _cookies;
    private WebHeaderCollection _webHeaderCollection;
    private string _characterSet;
    private bool _isVersionHttp11;
    public bool IsMutuallyAuthenticated { get; }
    public long ContentLength { get; }
    public string ContentType { get; }
    public string ContentEncoding { get; }
    public CookieCollection Cookies { get; public set; }
    public DateTime LastModified { get; }
    public string Server { get; }
    public Version ProtocolVersion { get; }
    public WebHeaderCollection Headers { get; }
    public string Method { get; }
    public Uri ResponseUri { get; }
    public HttpStatusCode StatusCode { get; }
    public string StatusDescription { get; }
    [NullableAttribute("2")]
public string CharacterSet { get; }
    public bool SupportsHeaders { get; }
    [ObsoleteAttribute("Serialization has been deprecated for HttpWebResponse.")]
[EditorBrowsableAttribute("1")]
protected HttpWebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal HttpWebResponse(HttpResponseMessage _message, Uri requestUri, CookieContainer cookieContainer);
    [ObsoleteAttribute("Serialization has been deprecated for HttpWebResponse.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for HttpWebResponse.")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual long get_ContentLength();
    public virtual string get_ContentType();
    public string get_ContentEncoding();
    public virtual CookieCollection get_Cookies();
    public virtual void set_Cookies(CookieCollection value);
    public DateTime get_LastModified();
    public string get_Server();
    public Version get_ProtocolVersion();
    public virtual WebHeaderCollection get_Headers();
    public virtual string get_Method();
    public virtual Uri get_ResponseUri();
    public virtual HttpStatusCode get_StatusCode();
    public virtual string get_StatusDescription();
    [NullableContextAttribute("2")]
public string get_CharacterSet();
    public virtual bool get_SupportsHeaders();
    public virtual Stream GetResponseStream();
    public string GetResponseHeader(string headerName);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    private void CheckDisposed();
    private static string GetHeaderValueAsString(IEnumerable`1<string> values);
}
[NullableContextAttribute("1")]
public interface System.Net.IAuthenticationModule {
    public bool CanPreAuthenticate { get; }
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, WebRequest request, ICredentials credentials);
    public abstract virtual Authorization PreAuthenticate(WebRequest request, ICredentials credentials);
    public abstract virtual bool get_CanPreAuthenticate();
    public abstract virtual string get_AuthenticationType();
}
internal interface System.Net.ICloseEx {
    public abstract virtual void CloseEx(CloseExState closeState);
}
[NullableContextAttribute("1")]
public interface System.Net.ICredentialPolicy {
    public abstract virtual bool ShouldSendCredential(Uri challengeUri, WebRequest request, NetworkCredential credential, IAuthenticationModule authenticationModule);
}
internal class System.Net.InternalException : Exception {
    private object _unexpectedValue;
    public string Message { get; }
    internal InternalException(object unexpectedValue);
    public virtual string get_Message();
}
[NullableContextAttribute("1")]
public interface System.Net.IWebRequestCreate {
    public abstract virtual WebRequest Create(Uri uri);
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal bool EndCalled { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [NonEventAttribute]
public static void Associate(object thisOrContextObject, object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
}
internal static class System.Net.NetRes : object {
    public static string GetWebStatusCodeString(FtpStatusCode statusCode, string statusDescription);
}
internal class System.Net.NetworkStreamWrapper : Stream {
    private NetworkStream _networkStream;
    protected bool UsingSecureStream { get; }
    internal IPAddress ServerAddress { get; }
    internal Socket Socket { get; }
    internal NetworkStream NetworkStream { get; internal set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal NetworkStreamWrapper(NetworkStream stream);
    protected bool get_UsingSecureStream();
    internal IPAddress get_ServerAddress();
    internal Socket get_Socket();
    internal NetworkStream get_NetworkStream();
    internal void set_NetworkStream(NetworkStream value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    protected virtual void Dispose(bool disposing);
    internal void CloseSocket();
    public void Close(int timeout);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    internal void SetSocketTimeoutOption(int timeout);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.ProtocolViolationException : InvalidOperationException {
    [NullableContextAttribute("2")]
public ProtocolViolationException(string message);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ProtocolViolationException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.ReceiveState : object {
    internal ResponseDescription Resp;
    internal int ValidThrough;
    internal Byte[] Buffer;
    internal CommandStream Connection;
    internal ReceiveState(CommandStream connection);
}
internal class System.Net.RequestStream : Stream {
    private MemoryStream _buffer;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback asyncCallback, object asyncState);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public ArraySegment`1<byte> GetBuffer();
}
internal class System.Net.ResponseDescription : object {
    internal bool Multiline;
    internal int Status;
    internal string StatusDescription;
    internal StringBuilder StatusBuffer;
    internal string StatusCodeString;
    internal bool PositiveIntermediate { get; }
    internal bool PositiveCompletion { get; }
    internal bool TransientFailure { get; }
    internal bool PermanentFailure { get; }
    internal bool InvalidStatusCode { get; }
    internal bool get_PositiveIntermediate();
    internal bool get_PositiveCompletion();
    internal bool get_TransientFailure();
    internal bool get_PermanentFailure();
    internal bool get_InvalidStatusCode();
}
[ExtensionAttribute]
internal static class System.Net.TaskExtensions : object {
    [ExtensionAttribute]
public static TaskCompletionSource`1<TResult> ToApm(Task`1<TResult> task, AsyncCallback callback, object state);
}
internal static class System.Net.TimerThread : object {
    private static LinkedList`1<WeakReference> s_queues;
    private static LinkedList`1<WeakReference> s_newQueues;
    private static int s_threadState;
    private static AutoResetEvent s_threadReadyEvent;
    private static ManualResetEvent s_threadShutdownEvent;
    private static WaitHandle[] s_threadEvents;
    private static int s_cacheScanIteration;
    private static Hashtable s_queuesCache;
    private static TimerThread();
    internal static Queue GetOrCreateQueue(int durationMilliseconds);
    private static void Prod();
    private static void ThreadProc();
    private static bool IsTickBetween(int start, int end, int comparand);
}
internal class System.Net.TlsStream : NetworkStream {
    private SslStream _sslStream;
    private string _host;
    private X509CertificateCollection _clientCertificates;
    public TlsStream(NetworkStream stream, Socket socket, string host, X509CertificateCollection clientCertificates);
    public void AuthenticateAsClient();
    public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object state);
    public void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Close();
}
internal enum System.Net.TriState : Enum {
    public int value__;
    public static TriState Unspecified;
    public static TriState False;
    public static TriState True;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.WebException : InvalidOperationException {
    private WebExceptionStatus _status;
    private WebResponse _response;
    public WebExceptionStatus Status { get; }
    public WebResponse Response { get; }
    public WebException(string message);
    public WebException(string message, Exception innerException);
    public WebException(string message, WebExceptionStatus status);
    public WebException(string message, Exception innerException, WebExceptionStatus status, WebResponse response);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected WebException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public WebExceptionStatus get_Status();
    public WebResponse get_Response();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal static Exception CreateCompatibleException(Exception exception);
    private static WebExceptionStatus GetStatusFromExceptionHelper(HttpRequestException ex);
    internal static WebExceptionStatus GetStatusFromException(HttpRequestException ex);
}
public enum System.Net.WebExceptionStatus : Enum {
    public int value__;
    public static WebExceptionStatus Success;
    public static WebExceptionStatus NameResolutionFailure;
    public static WebExceptionStatus ConnectFailure;
    public static WebExceptionStatus ReceiveFailure;
    public static WebExceptionStatus SendFailure;
    public static WebExceptionStatus PipelineFailure;
    public static WebExceptionStatus RequestCanceled;
    public static WebExceptionStatus ProtocolError;
    public static WebExceptionStatus ConnectionClosed;
    public static WebExceptionStatus TrustFailure;
    public static WebExceptionStatus SecureChannelFailure;
    public static WebExceptionStatus ServerProtocolViolation;
    public static WebExceptionStatus KeepAliveFailure;
    public static WebExceptionStatus Pending;
    public static WebExceptionStatus Timeout;
    public static WebExceptionStatus ProxyNameResolutionFailure;
    public static WebExceptionStatus UnknownError;
    public static WebExceptionStatus MessageLengthLimitExceeded;
    public static WebExceptionStatus CacheEntryNotFound;
    public static WebExceptionStatus RequestProhibitedByCachePolicy;
    public static WebExceptionStatus RequestProhibitedByProxy;
}
internal class System.Net.WebFileStream : FileStream {
    private FileWebRequest _request;
    public WebFileStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing);
    public WebFileStream(FileWebRequest request, string path, FileMode mode, FileAccess access, FileShare sharing, int length, bool async);
    protected virtual void Dispose(bool disposing);
    internal void Abort();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult ar);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult ar);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private void CheckAborted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.WebRequest : MarshalByRefObject {
    private static List`1<WebRequestPrefixElement> s_prefixList;
    private static object s_internalSyncObject;
    [CompilerGeneratedAttribute]
private static RequestCachePolicy <DefaultCachePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestCachePolicy <CachePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationLevel <AuthenticationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenImpersonationLevel <ImpersonationLevel>k__BackingField;
    private static IWebProxy s_DefaultWebProxy;
    private static bool s_DefaultWebProxyInitialized;
    internal static List`1<WebRequestPrefixElement> PrefixList { get; internal set; }
    [NullableAttribute("2")]
public static RequestCachePolicy DefaultCachePolicy { get; public set; }
    [NullableAttribute("2")]
public RequestCachePolicy CachePolicy { get; public set; }
    public AuthenticationLevel AuthenticationLevel { get; public set; }
    public TokenImpersonationLevel ImpersonationLevel { get; public set; }
    [NullableAttribute("2")]
public string ConnectionGroupName { get; public set; }
    public string Method { get; public set; }
    public Uri RequestUri { get; }
    public WebHeaderCollection Headers { get; public set; }
    public long ContentLength { get; public set; }
    [NullableAttribute("2")]
public string ContentType { get; public set; }
    [NullableAttribute("2")]
public ICredentials Credentials { get; public set; }
    public int Timeout { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    [NullableAttribute("2")]
public static IWebProxy DefaultWebProxy { get; public set; }
    public bool PreAuthenticate { get; public set; }
    [NullableAttribute("2")]
public IWebProxy Proxy { get; public set; }
    [ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
[EditorBrowsableAttribute("1")]
protected WebRequest(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebRequest();
    [ObsoleteAttribute("Serialization has been deprecated for WebRequest.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for WebRequest.")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    private static WebRequest Create(Uri requestUri, bool useUriBase);
    [ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
public static WebRequest Create(string requestUriString);
    [ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
public static WebRequest Create(Uri requestUri);
    [ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
public static WebRequest CreateDefault(Uri requestUri);
    [ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
public static HttpWebRequest CreateHttp(string requestUriString);
    [ObsoleteAttribute("WebRequest, HttpWebRequest, ServicePoint, and WebClient are obsolete. Use HttpClient instead.")]
public static HttpWebRequest CreateHttp(Uri requestUri);
    public static bool RegisterPrefix(string prefix, IWebRequestCreate creator);
    internal static List`1<WebRequestPrefixElement> get_PrefixList();
    internal static void set_PrefixList(List`1<WebRequestPrefixElement> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static RequestCachePolicy get_DefaultCachePolicy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static void set_DefaultCachePolicy(RequestCachePolicy value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual RequestCachePolicy get_CachePolicy();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void set_CachePolicy(RequestCachePolicy value);
    [CompilerGeneratedAttribute]
public AuthenticationLevel get_AuthenticationLevel();
    [CompilerGeneratedAttribute]
public void set_AuthenticationLevel(AuthenticationLevel value);
    [CompilerGeneratedAttribute]
public TokenImpersonationLevel get_ImpersonationLevel();
    [CompilerGeneratedAttribute]
public void set_ImpersonationLevel(TokenImpersonationLevel value);
    [NullableContextAttribute("2")]
public virtual string get_ConnectionGroupName();
    [NullableContextAttribute("2")]
public virtual void set_ConnectionGroupName(string value);
    public virtual string get_Method();
    public virtual void set_Method(string value);
    public virtual Uri get_RequestUri();
    public virtual WebHeaderCollection get_Headers();
    public virtual void set_Headers(WebHeaderCollection value);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    [NullableContextAttribute("2")]
public virtual string get_ContentType();
    [NullableContextAttribute("2")]
public virtual void set_ContentType(string value);
    [NullableContextAttribute("2")]
public virtual ICredentials get_Credentials();
    [NullableContextAttribute("2")]
public virtual void set_Credentials(ICredentials value);
    public virtual int get_Timeout();
    public virtual void set_Timeout(int value);
    public virtual bool get_UseDefaultCredentials();
    public virtual void set_UseDefaultCredentials(bool value);
    public virtual Stream GetRequestStream();
    public virtual WebResponse GetResponse();
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginGetResponse(AsyncCallback callback, object state);
    public virtual WebResponse EndGetResponse(IAsyncResult asyncResult);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginGetRequestStream(AsyncCallback callback, object state);
    public virtual Stream EndGetRequestStream(IAsyncResult asyncResult);
    [AsyncStateMachineAttribute("System.Net.WebRequest/<GetRequestStreamAsync>d__67")]
public virtual Task`1<Stream> GetRequestStreamAsync();
    [AsyncStateMachineAttribute("System.Net.WebRequest/<GetResponseAsync>d__68")]
public virtual Task`1<WebResponse> GetResponseAsync();
    public virtual void Abort();
    public static IWebProxy GetSystemWebProxy();
    [NullableContextAttribute("2")]
public static IWebProxy get_DefaultWebProxy();
    [NullableContextAttribute("2")]
public static void set_DefaultWebProxy(IWebProxy value);
    public virtual bool get_PreAuthenticate();
    public virtual void set_PreAuthenticate(bool value);
    [NullableContextAttribute("2")]
public virtual IWebProxy get_Proxy();
    [NullableContextAttribute("2")]
public virtual void set_Proxy(IWebProxy value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Net.WebRequestMethods : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Net.WebResponse : MarshalByRefObject {
    public long ContentLength { get; public set; }
    public string ContentType { get; public set; }
    public bool IsFromCache { get; }
    public bool IsMutuallyAuthenticated { get; }
    public Uri ResponseUri { get; }
    public WebHeaderCollection Headers { get; }
    public bool SupportsHeaders { get; }
    [ObsoleteAttribute("Serialization has been deprecated for WebResponse.")]
[EditorBrowsableAttribute("1")]
protected WebResponse(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for WebResponse.")]
private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [ObsoleteAttribute("Serialization has been deprecated for WebResponse.")]
protected virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual long get_ContentLength();
    public virtual void set_ContentLength(long value);
    public virtual string get_ContentType();
    public virtual void set_ContentType(string value);
    public virtual bool get_IsFromCache();
    public virtual bool get_IsMutuallyAuthenticated();
    public virtual Stream GetResponseStream();
    public virtual Uri get_ResponseUri();
    public virtual WebHeaderCollection get_Headers();
    public virtual bool get_SupportsHeaders();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesignWithMessage(string message);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_unknown_prefix { get; }
    internal static string net_reqsubmitted { get; }
    internal static string net_io_timeout_use_ge_zero { get; }
    internal static string net_writestarted { get; }
    internal static string net_badmethod { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_servererror { get; }
    internal static string net_reqaborted { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string net_PropertyNotImplementedException { get; }
    internal static string net_nouploadonget { get; }
    internal static string net_repcall { get; }
    internal static string net_invalid_enum { get; }
    internal static string net_requestaborted { get; }
    internal static string net_webstatus_Timeout { get; }
    internal static string net_baddate { get; }
    internal static string net_connarg { get; }
    internal static string net_fromto { get; }
    internal static string net_needchunked { get; }
    internal static string net_no100 { get; }
    internal static string net_nochunked { get; }
    internal static string net_nottoken { get; }
    internal static string net_rangetoosmall { get; }
    internal static string net_rangetype { get; }
    internal static string net_wrongversion { get; }
    internal static string net_WebHeaderInvalidControlChars { get; }
    internal static string net_WebHeaderInvalidCRLFChars { get; }
    internal static string net_timeout { get; }
    internal static string net_PropertyNotSupportedException { get; }
    internal static string net_InvalidStatusCode { get; }
    internal static string net_io_timeout_use_gt_zero { get; }
    internal static string net_ftp_servererror { get; }
    internal static string net_ftp_active_address_different { get; }
    internal static string net_ftp_invalid_response_filename { get; }
    internal static string net_ftp_invalid_status_response { get; }
    internal static string net_ftp_invalid_uri { get; }
    internal static string net_ftp_no_defaultcreds { get; }
    internal static string net_ftp_response_invalid_format { get; }
    internal static string net_ftp_server_failed_passive { get; }
    internal static string net_ftp_unsupported_method { get; }
    internal static string net_ftp_protocolerror { get; }
    internal static string net_ftp_receivefailure { get; }
    internal static string net_ftp_no_newlines { get; }
    internal static string net_webstatus_NameResolutionFailure { get; }
    internal static string net_webstatus_ConnectFailure { get; }
    internal static string net_ftpstatuscode_ServiceNotAvailable { get; }
    internal static string net_ftpstatuscode_CantOpenData { get; }
    internal static string net_ftpstatuscode_ConnectionClosed { get; }
    internal static string net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy { get; }
    internal static string net_ftpstatuscode_ActionAbortedLocalProcessingError { get; }
    internal static string net_ftpstatuscode_ActionNotTakenInsufficientSpace { get; }
    internal static string net_ftpstatuscode_CommandSyntaxError { get; }
    internal static string net_ftpstatuscode_ArgumentSyntaxError { get; }
    internal static string net_ftpstatuscode_CommandNotImplemented { get; }
    internal static string net_ftpstatuscode_BadCommandSequence { get; }
    internal static string net_ftpstatuscode_NotLoggedIn { get; }
    internal static string net_ftpstatuscode_AccountNeeded { get; }
    internal static string net_ftpstatuscode_ActionNotTakenFileUnavailable { get; }
    internal static string net_ftpstatuscode_ActionAbortedUnknownPageType { get; }
    internal static string net_ftpstatuscode_FileActionAborted { get; }
    internal static string net_ftpstatuscode_ActionNotTakenFilenameNotAllowed { get; }
    internal static string net_invalid_host { get; }
    internal static string CacheEntryNotFound { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_unknown_prefix();
    internal static string get_net_reqsubmitted();
    internal static string get_net_io_timeout_use_ge_zero();
    internal static string get_net_writestarted();
    internal static string get_net_badmethod();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_servererror();
    internal static string get_net_reqaborted();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_net_PropertyNotImplementedException();
    internal static string get_net_nouploadonget();
    internal static string get_net_repcall();
    internal static string get_net_invalid_enum();
    internal static string get_net_requestaborted();
    internal static string get_net_webstatus_Timeout();
    internal static string get_net_baddate();
    internal static string get_net_connarg();
    internal static string get_net_fromto();
    internal static string get_net_needchunked();
    internal static string get_net_no100();
    internal static string get_net_nochunked();
    internal static string get_net_nottoken();
    internal static string get_net_rangetoosmall();
    internal static string get_net_rangetype();
    internal static string get_net_wrongversion();
    internal static string get_net_WebHeaderInvalidControlChars();
    internal static string get_net_WebHeaderInvalidCRLFChars();
    internal static string get_net_timeout();
    internal static string get_net_PropertyNotSupportedException();
    internal static string get_net_InvalidStatusCode();
    internal static string get_net_io_timeout_use_gt_zero();
    internal static string get_net_ftp_servererror();
    internal static string get_net_ftp_active_address_different();
    internal static string get_net_ftp_invalid_response_filename();
    internal static string get_net_ftp_invalid_status_response();
    internal static string get_net_ftp_invalid_uri();
    internal static string get_net_ftp_no_defaultcreds();
    internal static string get_net_ftp_response_invalid_format();
    internal static string get_net_ftp_server_failed_passive();
    internal static string get_net_ftp_unsupported_method();
    internal static string get_net_ftp_protocolerror();
    internal static string get_net_ftp_receivefailure();
    internal static string get_net_ftp_no_newlines();
    internal static string get_net_webstatus_NameResolutionFailure();
    internal static string get_net_webstatus_ConnectFailure();
    internal static string get_net_ftpstatuscode_ServiceNotAvailable();
    internal static string get_net_ftpstatuscode_CantOpenData();
    internal static string get_net_ftpstatuscode_ConnectionClosed();
    internal static string get_net_ftpstatuscode_ActionNotTakenFileUnavailableOrBusy();
    internal static string get_net_ftpstatuscode_ActionAbortedLocalProcessingError();
    internal static string get_net_ftpstatuscode_ActionNotTakenInsufficientSpace();
    internal static string get_net_ftpstatuscode_CommandSyntaxError();
    internal static string get_net_ftpstatuscode_ArgumentSyntaxError();
    internal static string get_net_ftpstatuscode_CommandNotImplemented();
    internal static string get_net_ftpstatuscode_BadCommandSequence();
    internal static string get_net_ftpstatuscode_NotLoggedIn();
    internal static string get_net_ftpstatuscode_AccountNeeded();
    internal static string get_net_ftpstatuscode_ActionNotTakenFileUnavailable();
    internal static string get_net_ftpstatuscode_ActionAbortedUnknownPageType();
    internal static string get_net_ftpstatuscode_FileActionAborted();
    internal static string get_net_ftpstatuscode_ActionNotTakenFilenameNotAllowed();
    internal static string get_net_invalid_host();
    internal static string get_CacheEntryNotFound();
}
