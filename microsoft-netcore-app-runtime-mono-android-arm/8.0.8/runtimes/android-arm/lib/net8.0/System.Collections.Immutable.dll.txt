internal static class FxResources.System.Collections.Immutable.SR : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class System.Collections.Frozen.Constants : object {
    public static int MaxItemsInSmallFrozenCollection;
    public static int MaxItemsInSmallValueTypeFrozenCollection;
    public static bool IsKnownComparable();
    internal static bool KeysAreHashCodes();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.DefaultFrozenDictionary`2 : KeysAndValuesFrozenDictionary`2<TKey, TValue> {
    internal DefaultFrozenDictionary`2(Dictionary`2<TKey, TValue> source);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.DefaultFrozenSet`1 : ItemsFrozenSet`2<T, GSW<T>> {
    internal DefaultFrozenSet`1(HashSet`1<T> source);
    private protected virtual int FindItemIndex(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.EmptyFrozenDictionary`2 : FrozenDictionary`2<TKey, TValue> {
    private protected TKey[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    internal EmptyFrozenDictionary`2(IEqualityComparer`1<TKey> comparer);
    private protected virtual TKey[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual Enumerator<TKey, TValue> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.EmptyFrozenSet`1 : FrozenSet`1<T> {
    private protected T[] ItemsCore { get; }
    private protected int CountCore { get; }
    internal EmptyFrozenSet`1(IEqualityComparer`1<T> comparer);
    private protected virtual T[] get_ItemsCore();
    private protected virtual int get_CountCore();
    private protected virtual int FindItemIndex(T item);
    private protected virtual Enumerator<T> GetEnumeratorCore();
    private protected virtual bool IsProperSubsetOfCore(IEnumerable`1<T> other);
    private protected virtual bool IsProperSupersetOfCore(IEnumerable`1<T> other);
    private protected virtual bool IsSubsetOfCore(IEnumerable`1<T> other);
    private protected virtual bool IsSupersetOfCore(IEnumerable`1<T> other);
    private protected virtual bool OverlapsCore(IEnumerable`1<T> other);
    private protected virtual bool SetEqualsCore(IEnumerable`1<T> other);
    private static bool OtherIsEmpty(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Frozen.FrozenDictionary : object {
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TValue> ToFrozenDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TSource> ToFrozenDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static FrozenDictionary`2<TKey, TElement> ToFrozenDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    private static FrozenDictionary`2<TKey, TValue> GetExistingFrozenOrNewDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> comparer, Dictionary`2& newDictionary);
    private static FrozenDictionary`2<TKey, TValue> CreateFromDictionary(Dictionary`2<TKey, TValue> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
public abstract class System.Collections.Frozen.FrozenDictionary`2 : object {
    [CompilerGeneratedAttribute]
private static FrozenDictionary`2<TKey, TValue> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<TKey> <Comparer>k__BackingField;
    public static FrozenDictionary`2<TKey, TValue> Empty { get; }
    public IEqualityComparer`1<TKey> Comparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TKey> Keys { get; }
    private protected TKey[] KeysCore { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<TValue> Values { get; }
    private protected TValue[] ValuesCore { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public int Count { get; }
    private protected int CountCore { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    [IsReadOnlyAttribute]
public TValue& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private TValue System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Item { get; }
    private protected FrozenDictionary`2(IEqualityComparer`1<TKey> comparer);
    private static FrozenDictionary`2();
    [CompilerGeneratedAttribute]
public static FrozenDictionary`2<TKey, TValue> get_Empty();
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<TKey> get_Comparer();
    public ImmutableArray`1<TKey> get_Keys();
    private protected abstract virtual TKey[] get_KeysCore();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public ImmutableArray`1<TValue> get_Values();
    private protected abstract virtual TValue[] get_ValuesCore();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual int get_Count();
    private protected abstract virtual int get_CountCore();
    public sealed virtual void CopyTo(KeyValuePair`2[] destination, int destinationIndex);
    public void CopyTo(Span`1<KeyValuePair`2<TKey, TValue>> destination);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRef(TKey key);
    private protected abstract virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
    public TValue& modreq(System.Runtime.InteropServices.InAttribute) get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override TValue System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Item(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    [NullableContextAttribute("0")]
private protected abstract virtual Enumerator<TKey, TValue> GetEnumeratorCore();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override void System.Collections.IDictionary.Clear();
}
[IsReadOnlyAttribute]
internal class System.Collections.Frozen.FrozenHashTable : ValueType {
    private Bucket[] _buckets;
    private ulong _fastModMultiplier;
    [CompilerGeneratedAttribute]
private Int32[] <HashCodes>k__BackingField;
    public int Count { get; }
    [NullableAttribute("1")]
internal Int32[] HashCodes { get; }
    private FrozenHashTable(Int32[] hashCodes, Bucket[] buckets, ulong fastModMultiplier);
    public static FrozenHashTable Create(Span`1<int> hashCodes, bool hashCodesAreUnique);
    public void FindMatchingEntries(int hashCode, Int32& startIndex, Int32& endIndex);
    public int get_Count();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal Int32[] get_HashCodes();
    private static int CalcNumBuckets(ReadOnlySpan`1<int> hashCodes, bool hashCodesAreUnique);
    [CompilerGeneratedAttribute]
internal static bool <CalcNumBuckets>g__IsBucketFirstVisit|10_0(int code, <>c__DisplayClass10_0& );
}
[ExtensionAttribute]
public static class System.Collections.Frozen.FrozenSet : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static FrozenSet`1<T> ToFrozenSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    private static FrozenSet`1<T> GetExistingFrozenOrNewSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer, HashSet`1& newSet);
    private static FrozenSet`1<T> CreateFromSet(HashSet`1<T> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
public abstract class System.Collections.Frozen.FrozenSet`1 : object {
    [CompilerGeneratedAttribute]
private static FrozenSet`1<T> <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<T> <Comparer>k__BackingField;
    public static FrozenSet`1<T> Empty { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<T> Items { get; }
    private protected T[] ItemsCore { get; }
    public int Count { get; }
    private protected int CountCore { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private protected FrozenSet`1(IEqualityComparer`1<T> comparer);
    private static FrozenSet`1();
    [CompilerGeneratedAttribute]
public static FrozenSet`1<T> get_Empty();
    [CompilerGeneratedAttribute]
public IEqualityComparer`1<T> get_Comparer();
    public ImmutableArray`1<T> get_Items();
    private protected abstract virtual T[] get_ItemsCore();
    public sealed virtual int get_Count();
    private protected abstract virtual int get_CountCore();
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(Span`1<T> destination);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual bool Contains(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    private protected abstract virtual int FindItemIndex(T item);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("0")]
private protected abstract virtual Enumerator<T> GetEnumeratorCore();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    private protected abstract virtual bool IsProperSubsetOfCore(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    private protected abstract virtual bool IsProperSupersetOfCore(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    private protected abstract virtual bool IsSubsetOfCore(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    private protected abstract virtual bool IsSupersetOfCore(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private protected abstract virtual bool OverlapsCore(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    private protected abstract virtual bool SetEqualsCore(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class System.Collections.Frozen.FrozenSetInternalBase`2 : FrozenSet`1<T> {
    private TThisWrapper _thisSet;
    protected FrozenSetInternalBase`2(IEqualityComparer`1<T> comparer);
    private protected virtual bool IsProperSubsetOfCore(IEnumerable`1<T> other);
    private protected virtual bool IsProperSupersetOfCore(IEnumerable`1<T> other);
    private protected virtual bool IsSubsetOfCore(IEnumerable`1<T> other);
    private protected virtual bool IsSupersetOfCore(IEnumerable`1<T> other);
    private protected virtual bool OverlapsCore(IEnumerable`1<T> other);
    private protected virtual bool SetEqualsCore(IEnumerable`1<T> other);
    private bool ComparersAreCompatible(IReadOnlySet`1<T> other);
    private KeyValuePair`2<int, int> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    private bool ContainsAllElements(IEnumerable`1<T> other);
    private bool IsSubsetOfSetWithCompatibleComparer(IReadOnlySet`1<T> other);
}
internal static class System.Collections.Frozen.Hashing : object {
    public static int GetHashCodeOrdinal(ReadOnlySpan`1<char> s);
    public static int GetHashCodeOrdinalIgnoreCaseAscii(ReadOnlySpan`1<char> s);
    public static int GetHashCodeOrdinalIgnoreCase(ReadOnlySpan`1<char> s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.Int32FrozenDictionary`1 : FrozenDictionary`2<int, TValue> {
    private FrozenHashTable _hashTable;
    private TValue[] _values;
    private protected Int32[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    internal Int32FrozenDictionary`1(Dictionary`2<int, TValue> source);
    private protected virtual Int32[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual Enumerator<int, TValue> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(int key);
}
internal class System.Collections.Frozen.Int32FrozenSet : FrozenSetInternalBase`2<int, GSW> {
    private FrozenHashTable _hashTable;
    [NullableAttribute("1")]
private protected Int32[] ItemsCore { get; }
    private protected int CountCore { get; }
    [NullableContextAttribute("1")]
internal Int32FrozenSet(HashSet`1<int> source);
    [NullableContextAttribute("1")]
private protected virtual Int32[] get_ItemsCore();
    private protected virtual Enumerator<int> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual int FindItemIndex(int item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class System.Collections.Frozen.ItemsFrozenSet`2 : FrozenSetInternalBase`2<T, TThisWrapper> {
    private protected FrozenHashTable _hashTable;
    private protected T[] _items;
    private protected T[] ItemsCore { get; }
    private protected int CountCore { get; }
    protected ItemsFrozenSet`2(HashSet`1<T> source, bool keysAreHashCodes);
    private protected sealed virtual T[] get_ItemsCore();
    private protected sealed virtual Enumerator<T> GetEnumeratorCore();
    private protected sealed virtual int get_CountCore();
}
internal static class System.Collections.Frozen.KeyAnalyzer : object {
    private static SearchValues`1<char> s_asciiLetters;
    private static KeyAnalyzer();
    public static AnalysisResults Analyze(ReadOnlySpan`1<string> uniqueStrings, bool ignoreCase, int minLength, int maxLength);
    private static bool TryUseSubstring(ReadOnlySpan`1<string> uniqueStrings, bool ignoreCase, int minLength, int maxLength, AnalysisResults& results);
    private static AnalysisResults CreateAnalysisResults(ReadOnlySpan`1<string> uniqueStrings, bool ignoreCase, int minLength, int maxLength, int index, int count, bool isSubstring, GetSpan getSubstringSpan);
    internal static bool IsAllAscii(ReadOnlySpan`1<char> s);
    private static bool ContainsAnyLetters(ReadOnlySpan`1<char> s);
    private static bool HasSufficientUniquenessFactor(HashSet`1<string> set, ReadOnlySpan`1<string> uniqueStrings);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class System.Collections.Frozen.KeysAndValuesFrozenDictionary`2 : FrozenDictionary`2<TKey, TValue> {
    private protected FrozenHashTable _hashTable;
    private protected TKey[] _keys;
    private protected TValue[] _values;
    private protected TKey[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    protected KeysAndValuesFrozenDictionary`2(Dictionary`2<TKey, TValue> source, bool keysAreHashCodes);
    private protected sealed virtual TKey[] get_KeysCore();
    private protected sealed virtual TValue[] get_ValuesCore();
    private protected sealed virtual Enumerator<TKey, TValue> GetEnumeratorCore();
    private protected sealed virtual int get_CountCore();
}
internal static class System.Collections.Frozen.LengthBuckets : object {
    internal static int MaxPerLength;
    [NullableContextAttribute("1")]
internal static Int32[] CreateLengthBucketsArrayIfAppropriate(String[] keys, IEqualityComparer`1<string> comparer, int minLength, int maxLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.LengthBucketsFrozenDictionary`1 : FrozenDictionary`2<string, TValue> {
    private Int32[] _lengthBuckets;
    private int _minLength;
    private String[] _keys;
    private TValue[] _values;
    private bool _ignoreCase;
    private protected String[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    private LengthBucketsFrozenDictionary`1(String[] keys, TValue[] values, Int32[] lengthBuckets, int minLength, IEqualityComparer`1<string> comparer);
    internal static LengthBucketsFrozenDictionary`1<TValue> CreateLengthBucketsFrozenDictionaryIfAppropriate(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minLength, int maxLength);
    private protected virtual String[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual Enumerator<string, TValue> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.LengthBucketsFrozenSet : FrozenSetInternalBase`2<string, GSW> {
    private Int32[] _lengthBuckets;
    private int _minLength;
    private String[] _items;
    private bool _ignoreCase;
    private protected String[] ItemsCore { get; }
    private protected int CountCore { get; }
    private LengthBucketsFrozenSet(String[] items, Int32[] lengthBuckets, int minLength, IEqualityComparer`1<string> comparer);
    internal static LengthBucketsFrozenSet CreateLengthBucketsFrozenSetIfAppropriate(String[] items, IEqualityComparer`1<string> comparer, int minLength, int maxLength);
    private protected virtual String[] get_ItemsCore();
    private protected virtual Enumerator<string> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    [NullableContextAttribute("2")]
private protected virtual int FindItemIndex(string item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_Full`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_Full`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_FullCaseInsensitive`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_FullCaseInsensitive`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_FullCaseInsensitiveAscii`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_FullCaseInsensitiveAscii`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_LeftJustifiedCaseInsensitiveAsciiSubstring`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_LeftJustifiedCaseInsensitiveAsciiSubstring`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_LeftJustifiedCaseInsensitiveSubstring`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_LeftJustifiedCaseInsensitiveSubstring`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_LeftJustifiedSingleChar`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_LeftJustifiedSingleChar`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_LeftJustifiedSubstring`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_LeftJustifiedSubstring`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_RightJustifiedCaseInsensitiveAsciiSubstring`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_RightJustifiedCaseInsensitiveAsciiSubstring`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_RightJustifiedCaseInsensitiveSubstring`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_RightJustifiedCaseInsensitiveSubstring`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_RightJustifiedSingleChar`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_RightJustifiedSingleChar`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.OrdinalStringFrozenDictionary_RightJustifiedSubstring`1 : OrdinalStringFrozenDictionary`1<TValue> {
    internal OrdinalStringFrozenDictionary_RightJustifiedSubstring`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class System.Collections.Frozen.OrdinalStringFrozenDictionary`1 : FrozenDictionary`2<string, TValue> {
    private FrozenHashTable _hashTable;
    private String[] _keys;
    private TValue[] _values;
    private int _minimumLength;
    private int _maximumLengthDiff;
    [CompilerGeneratedAttribute]
private int <HashIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashCount>k__BackingField;
    private protected int HashIndex { get; }
    private protected int HashCount { get; }
    private protected String[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    internal OrdinalStringFrozenDictionary`1(String[] keys, TValue[] values, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    [CompilerGeneratedAttribute]
private protected int get_HashIndex();
    [CompilerGeneratedAttribute]
private protected int get_HashCount();
    [NullableContextAttribute("2")]
private protected abstract virtual bool Equals(string x, string y);
    private protected abstract virtual int GetHashCode(string s);
    private protected virtual String[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual Enumerator<string, TValue> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class System.Collections.Frozen.OrdinalStringFrozenSet : FrozenSetInternalBase`2<string, GSW> {
    private FrozenHashTable _hashTable;
    private String[] _items;
    private int _minimumLength;
    private int _maximumLengthDiff;
    [CompilerGeneratedAttribute]
private int <HashIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HashCount>k__BackingField;
    private protected int HashIndex { get; }
    private protected int HashCount { get; }
    private protected String[] ItemsCore { get; }
    private protected int CountCore { get; }
    internal OrdinalStringFrozenSet(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    [CompilerGeneratedAttribute]
private protected int get_HashIndex();
    [CompilerGeneratedAttribute]
private protected int get_HashCount();
    [NullableContextAttribute("2")]
private protected abstract virtual bool Equals(string x, string y);
    private protected abstract virtual int GetHashCode(string s);
    private protected virtual String[] get_ItemsCore();
    private protected virtual Enumerator<string> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual int FindItemIndex(string item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_Full : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_Full(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_FullCaseInsensitive : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_FullCaseInsensitive(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_FullCaseInsensitiveAscii : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_FullCaseInsensitiveAscii(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_LeftJustifiedCaseInsensitiveAsciiSubstring : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_LeftJustifiedCaseInsensitiveAsciiSubstring(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_LeftJustifiedCaseInsensitiveSubstring : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_LeftJustifiedCaseInsensitiveSubstring(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_LeftJustifiedSingleChar : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_LeftJustifiedSingleChar(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_LeftJustifiedSubstring : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_LeftJustifiedSubstring(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_RightJustifiedCaseInsensitiveAsciiSubstring : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_RightJustifiedCaseInsensitiveAsciiSubstring(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_RightJustifiedCaseInsensitiveSubstring : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_RightJustifiedCaseInsensitiveSubstring(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_RightJustifiedSingleChar : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_RightJustifiedSingleChar(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Frozen.OrdinalStringFrozenSet_RightJustifiedSubstring : OrdinalStringFrozenSet {
    internal OrdinalStringFrozenSet_RightJustifiedSubstring(String[] entries, IEqualityComparer`1<string> comparer, int minimumLength, int maximumLengthDiff, int hashIndex, int hashCount);
    private protected virtual int FindItemIndex(string item);
    [NullableContextAttribute("2")]
private protected virtual bool Equals(string x, string y);
    private protected virtual int GetHashCode(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.SmallFrozenDictionary`2 : FrozenDictionary`2<TKey, TValue> {
    private TKey[] _keys;
    private TValue[] _values;
    private protected TKey[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    internal SmallFrozenDictionary`2(Dictionary`2<TKey, TValue> source);
    private protected virtual TKey[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual int get_CountCore();
    private protected sealed virtual Enumerator<TKey, TValue> GetEnumeratorCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.SmallFrozenSet`1 : FrozenSetInternalBase`2<T, GSW<T>> {
    private T[] _items;
    private protected T[] ItemsCore { get; }
    private protected int CountCore { get; }
    internal SmallFrozenSet`1(HashSet`1<T> source);
    private protected virtual T[] get_ItemsCore();
    private protected virtual int get_CountCore();
    private protected virtual int FindItemIndex(T item);
    private protected virtual Enumerator<T> GetEnumeratorCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.SmallValueTypeComparableFrozenDictionary`2 : FrozenDictionary`2<TKey, TValue> {
    private TKey[] _keys;
    private TValue[] _values;
    private TKey _max;
    private protected TKey[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    internal SmallValueTypeComparableFrozenDictionary`2(Dictionary`2<TKey, TValue> source);
    private protected virtual TKey[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual Enumerator<TKey, TValue> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.SmallValueTypeComparableFrozenSet`1 : FrozenSetInternalBase`2<T, GSW<T>> {
    private T[] _items;
    private T _max;
    private protected T[] ItemsCore { get; }
    private protected int CountCore { get; }
    internal SmallValueTypeComparableFrozenSet`1(HashSet`1<T> source);
    private protected virtual T[] get_ItemsCore();
    private protected virtual Enumerator<T> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual int FindItemIndex(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.SmallValueTypeDefaultComparerFrozenDictionary`2 : FrozenDictionary`2<TKey, TValue> {
    private TKey[] _keys;
    private TValue[] _values;
    private protected TKey[] KeysCore { get; }
    private protected TValue[] ValuesCore { get; }
    private protected int CountCore { get; }
    internal SmallValueTypeDefaultComparerFrozenDictionary`2(Dictionary`2<TKey, TValue> source);
    private protected virtual TKey[] get_KeysCore();
    private protected virtual TValue[] get_ValuesCore();
    private protected virtual Enumerator<TKey, TValue> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.SmallValueTypeDefaultComparerFrozenSet`1 : FrozenSetInternalBase`2<T, GSW<T>> {
    private T[] _items;
    private protected T[] ItemsCore { get; }
    private protected int CountCore { get; }
    internal SmallValueTypeDefaultComparerFrozenSet`1(HashSet`1<T> source);
    private protected virtual T[] get_ItemsCore();
    private protected virtual Enumerator<T> GetEnumeratorCore();
    private protected virtual int get_CountCore();
    private protected virtual int FindItemIndex(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.ValueTypeDefaultComparerFrozenDictionary`2 : KeysAndValuesFrozenDictionary`2<TKey, TValue> {
    internal ValueTypeDefaultComparerFrozenDictionary`2(Dictionary`2<TKey, TValue> source);
    private protected virtual TValue& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrNullRefCore(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Frozen.ValueTypeDefaultComparerFrozenSet`1 : ItemsFrozenSet`2<T, GSW<T>> {
    internal ValueTypeDefaultComparerFrozenSet`1(HashSet`1<T> source);
    private protected virtual int FindItemIndex(T item);
}
[NullableContextAttribute("1")]
internal interface System.Collections.Generic.IHashKeyCollection`1 {
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public abstract virtual IEqualityComparer`1<TKey> get_KeyComparer();
}
[NullableContextAttribute("1")]
internal interface System.Collections.Generic.ISortKeyCollection`1 {
    public IComparer`1<TKey> KeyComparer { get; }
    public abstract virtual IComparer`1<TKey> get_KeyComparer();
}
internal static class System.Collections.HashHelpers : object {
    public static UInt32 HashCollisionThreshold;
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    internal static ReadOnlySpan`1<int> Primes { get; }
    internal static ReadOnlySpan`1<int> get_Primes();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Collections.Immutable.AllocFreeConcurrentStack`1 : object {
    [ThreadStaticAttribute]
private static Stack`1<RefAsValueType`1<T>> t_stack;
    public static void TryAdd(T item);
    public static bool TryTake(T& item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.DictionaryEnumerator`2 : object {
    private IEnumerator`1<KeyValuePair`2<TKey, TValue>> _inner;
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public object Current { get; }
    internal DictionaryEnumerator`2(IEnumerator`1<KeyValuePair`2<TKey, TValue>> inner);
    public sealed virtual DictionaryEntry get_Entry();
    public sealed virtual object get_Key();
    [NullableContextAttribute("2")]
public sealed virtual object get_Value();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal class System.Collections.Immutable.DisposableEnumeratorAdapter`2 : ValueType {
    private IEnumerator`1<T> _enumeratorObject;
    private TEnumerator _enumeratorStruct;
    [NullableAttribute("1")]
public T Current { get; }
    internal DisposableEnumeratorAdapter`2(TEnumerator enumerator);
    [NullableContextAttribute("1")]
internal DisposableEnumeratorAdapter`2(IEnumerator`1<T> enumerator);
    [NullableContextAttribute("1")]
public T get_Current();
    public bool MoveNext();
    public sealed virtual void Dispose();
    public DisposableEnumeratorAdapter`2<T, TEnumerator> GetEnumerator();
}
[NullableContextAttribute("2")]
internal interface System.Collections.Immutable.IBinaryTree {
    public int Height { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IBinaryTree Left { get; }
    public IBinaryTree Right { get; }
    public abstract virtual int get_Height();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual IBinaryTree get_Left();
    public abstract virtual IBinaryTree get_Right();
}
[NullableContextAttribute("1")]
internal interface System.Collections.Immutable.IBinaryTree`1 {
    public T Value { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IBinaryTree`1<T> Left { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IBinaryTree`1<T> Right { get; }
    public abstract virtual T get_Value();
    public abstract virtual IBinaryTree`1<T> get_Left();
    public abstract virtual IBinaryTree`1<T> get_Right();
}
[NullableContextAttribute("2")]
internal interface System.Collections.Immutable.IImmutableArray {
    public Array Array { get; }
    public abstract virtual Array get_Array();
}
[NullableContextAttribute("1")]
public interface System.Collections.Immutable.IImmutableDictionary`2 {
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Clear();
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public abstract virtual IImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public abstract virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public abstract virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
}
[NullableContextAttribute("2")]
internal interface System.Collections.Immutable.IImmutableDictionaryInternal`2 {
    [NullableContextAttribute("1")]
public abstract virtual bool ContainsValue(TValue value);
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableList", "Create")]
public interface System.Collections.Immutable.IImmutableList`1 {
    public abstract virtual IImmutableList`1<T> Clear();
    public abstract virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> Add(T value);
    public abstract virtual IImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    public abstract virtual IImmutableList`1<T> Insert(int index, T element);
    public abstract virtual IImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public abstract virtual IImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public abstract virtual IImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public abstract virtual IImmutableList`1<T> RemoveRange(int index, int count);
    public abstract virtual IImmutableList`1<T> RemoveAt(int index);
    public abstract virtual IImmutableList`1<T> SetItem(int index, T value);
    public abstract virtual IImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
}
[NullableContextAttribute("1")]
internal interface System.Collections.Immutable.IImmutableListQueries`1 {
    public abstract virtual ImmutableList`1<TOutput> ConvertAll(Func`2<T, TOutput> converter);
    public abstract virtual void ForEach(Action`1<T> action);
    public abstract virtual ImmutableList`1<T> GetRange(int index, int count);
    public abstract virtual void CopyTo(T[] array);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual void CopyTo(int index, T[] array, int arrayIndex, int count);
    public abstract virtual bool Exists(Predicate`1<T> match);
    public abstract virtual T Find(Predicate`1<T> match);
    public abstract virtual ImmutableList`1<T> FindAll(Predicate`1<T> match);
    public abstract virtual int FindIndex(Predicate`1<T> match);
    public abstract virtual int FindIndex(int startIndex, Predicate`1<T> match);
    public abstract virtual int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public abstract virtual T FindLast(Predicate`1<T> match);
    public abstract virtual int FindLastIndex(Predicate`1<T> match);
    public abstract virtual int FindLastIndex(int startIndex, Predicate`1<T> match);
    public abstract virtual int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public abstract virtual bool TrueForAll(Predicate`1<T> match);
    public abstract virtual int BinarySearch(T item);
    public abstract virtual int BinarySearch(T item, IComparer`1<T> comparer);
    public abstract virtual int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableQueue", "Create")]
public interface System.Collections.Immutable.IImmutableQueue`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IImmutableQueue`1<T> Clear();
    public abstract virtual T Peek();
    public abstract virtual IImmutableQueue`1<T> Enqueue(T value);
    public abstract virtual IImmutableQueue`1<T> Dequeue();
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableHashSet", "Create")]
public interface System.Collections.Immutable.IImmutableSet`1 {
    public abstract virtual IImmutableSet`1<T> Clear();
    public abstract virtual bool Contains(T value);
    public abstract virtual IImmutableSet`1<T> Add(T value);
    public abstract virtual IImmutableSet`1<T> Remove(T value);
    public abstract virtual bool TryGetValue(T equalValue, T& actualValue);
    public abstract virtual IImmutableSet`1<T> Intersect(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> Except(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public abstract virtual IImmutableSet`1<T> Union(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableStack", "Create")]
public interface System.Collections.Immutable.IImmutableStack`1 {
    public bool IsEmpty { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual IImmutableStack`1<T> Clear();
    public abstract virtual IImmutableStack`1<T> Push(T value);
    public abstract virtual IImmutableStack`1<T> Pop();
    public abstract virtual T Peek();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableArray : object {
    internal static Byte[] TwoElementArray;
    private static ImmutableArray();
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create();
    public static ImmutableArray`1<T> Create(T item);
    public static ImmutableArray`1<T> Create(T item1, T item2);
    public static ImmutableArray`1<T> Create(T item1, T item2, T item3);
    public static ImmutableArray`1<T> Create(T item1, T item2, T item3, T item4);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(Span`1<T> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(ReadOnlySpan`1<T> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArray(Span`1<T> items);
    public static ImmutableArray`1<T> CreateRange(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(T[] items);
    public static ImmutableArray`1<T> Create(T[] items, int start, int length);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> Create(ImmutableArray`1<T> items, int start, int length);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, int start, int length, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, Func`3<TSource, TArg, TResult> selector, TArg arg);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<TResult> CreateRange(ImmutableArray`1<TSource> items, int start, int length, Func`3<TSource, TArg, TResult> selector, TArg arg);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(int initialCapacity);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> ToImmutableArray(IEnumerable`1<TSource> items);
    [ExtensionAttribute]
public static ImmutableArray`1<TSource> ToImmutableArray(Builder<TSource> builder);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, T value);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, T value, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, int index, int length, T value);
    [ExtensionAttribute]
public static int BinarySearch(ImmutableArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableArray", "Create")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[NonVersionableAttribute]
public class System.Collections.Immutable.ImmutableArray`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<T> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
internal T[] array;
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.ICollection<T>.Count { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.IList.IsFixedSize { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.IList.IsReadOnly { get; }
    [DebuggerBrowsableAttribute("0")]
private int System.Collections.ICollection.Count { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public T Item { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    [DebuggerBrowsableAttribute("0")]
public int Length { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDefault { get; }
    [DebuggerBrowsableAttribute("0")]
public bool IsDefaultOrEmpty { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("0")]
private Array System.Collections.Immutable.IImmutableArray.Array { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal ImmutableArray`1(T[] items);
    private static ImmutableArray`1();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    public ReadOnlySpan`1<T> AsSpan();
    public ReadOnlyMemory`1<T> AsMemory();
    public sealed virtual int IndexOf(T item);
    public int IndexOf(T item, int startIndex, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex);
    public int IndexOf(T item, int startIndex, int count);
    public sealed virtual int IndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int startIndex);
    public int LastIndexOf(T item, int startIndex, int count);
    public sealed virtual int LastIndexOf(T item, int startIndex, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual bool Contains(T item);
    public bool Contains(T item, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> Insert(int index, T item);
    public ImmutableArray`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public ImmutableArray`1<T> InsertRange(int index, ImmutableArray`1<T> items);
    public ImmutableArray`1<T> Add(T item);
    public ImmutableArray`1<T> AddRange(IEnumerable`1<T> items);
    public ImmutableArray`1<T> AddRange(T[] items, int length);
    public ImmutableArray`1<T> AddRange(TDerived[] items);
    public ImmutableArray`1<T> AddRange(ImmutableArray`1<T> items, int length);
    [NullableContextAttribute("0")]
public ImmutableArray`1<T> AddRange(ImmutableArray`1<TDerived> items);
    public ImmutableArray`1<T> AddRange(ImmutableArray`1<T> items);
    public ImmutableArray`1<T> SetItem(int index, T item);
    public ImmutableArray`1<T> Replace(T oldValue, T newValue);
    public ImmutableArray`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> Remove(T item);
    public ImmutableArray`1<T> Remove(T item, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveAt(int index);
    public ImmutableArray`1<T> RemoveRange(int index, int length);
    public ImmutableArray`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableArray`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveRange(ImmutableArray`1<T> items);
    public ImmutableArray`1<T> RemoveRange(ImmutableArray`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableArray`1<T> Clear();
    public ImmutableArray`1<T> Sort();
    public ImmutableArray`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableArray`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableArray`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public IEnumerable`1<TResult> OfType();
    public ImmutableArray`1<T> AddRange(ReadOnlySpan`1<T> items);
    public ImmutableArray`1<T> AddRange(T[] items);
    public ReadOnlySpan`1<T> AsSpan(int start, int length);
    public void CopyTo(Span`1<T> destination);
    public ImmutableArray`1<T> InsertRange(int index, T[] items);
    public ImmutableArray`1<T> InsertRange(int index, ReadOnlySpan`1<T> items);
    public ImmutableArray`1<T> RemoveRange(ReadOnlySpan`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> RemoveRange(T[] items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableArray`1<T> Slice(int start, int length);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private ImmutableArray`1<T> RemoveAtRange(ICollection`1<int> indicesToRemove);
    private ImmutableArray`1<T> InsertSpanRangeInternal(int index, ReadOnlySpan`1<T> items);
    public ReadOnlySpan`1<T> AsSpan(Range range);
    [NonVersionableAttribute]
public static bool op_Equality(ImmutableArray`1<T> left, ImmutableArray`1<T> right);
    [NonVersionableAttribute]
public static bool op_Inequality(ImmutableArray`1<T> left, ImmutableArray`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableArray`1<T>> left, Nullable`1<ImmutableArray`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableArray`1<T>> left, Nullable`1<ImmutableArray`1<T>> right);
    [NonVersionableAttribute]
public T get_Item(int index);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    [NonVersionableAttribute]
public bool get_IsEmpty();
    [NonVersionableAttribute]
public int get_Length();
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    private sealed virtual override Array System.Collections.Immutable.IImmutableArray.get_Array();
    private string get_DebuggerDisplay();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(int sourceIndex, T[] destination, int destinationIndex, int length);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ImmutableArray`1<T> other);
    [NullableContextAttribute("0")]
public static ImmutableArray`1<T> CastUp(ImmutableArray`1<TDerived> items);
    [NullableContextAttribute("0")]
public ImmutableArray`1<TOther> CastArray();
    [NullableContextAttribute("0")]
public ImmutableArray`1<TOther> As();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void ThrowNullRefIfNotInitialized();
    private void ThrowInvalidOperationIfNotInitialized();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.ImmutableArrayBuilderDebuggerProxy`1 : object {
    private Builder<T> _builder;
    [DebuggerBrowsableAttribute("3")]
public T[] A { get; }
    public ImmutableArrayBuilderDebuggerProxy`1(Builder<T> builder);
    public T[] get_A();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableDictionary : object {
    public static ImmutableDictionary`2<TKey, TValue> Create();
    public static ImmutableDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TSource> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TSource> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
    [ExtensionAttribute]
public static bool Contains(IImmutableDictionary`2<TKey, TValue> map, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IImmutableDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IImmutableDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2")]
public class System.Collections.Immutable.ImmutableDictionary`2 : object {
    public static ImmutableDictionary`2<TKey, TValue> Empty;
    private static Action`1<KeyValuePair`2<int, HashBucket<TKey, TValue>>> s_FreezeBucketAction;
    private int _count;
    private SortedInt32KeyNode`1<HashBucket<TKey, TValue>> _root;
    private Comparers<TKey, TValue> _comparers;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public IEqualityComparer`1<TValue> ValueComparer { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    [NullableAttribute("0")]
private MutationInput<TKey, TValue> Origin { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal SortedInt32KeyNode`1<HashBucket<TKey, TValue>> Root { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    private ImmutableDictionary`2(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, Comparers<TKey, TValue> comparers, int count);
    private ImmutableDictionary`2(Comparers<TKey, TValue> comparers);
    private static ImmutableDictionary`2();
    public ImmutableDictionary`2<TKey, TValue> Clear();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual IEqualityComparer`1<TKey> get_KeyComparer();
    public IEqualityComparer`1<TValue> get_ValueComparer();
    [IteratorStateMachineAttribute("System.Collections.Immutable.ImmutableDictionary`2/<get_Keys>d__25")]
public sealed virtual IEnumerable`1<TKey> get_Keys();
    [IteratorStateMachineAttribute("System.Collections.Immutable.ImmutableDictionary`2/<get_Values>d__27")]
public sealed virtual IEnumerable`1<TValue> get_Values();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private MutationInput<TKey, TValue> get_Origin();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public Builder<TKey, TValue> ToBuilder();
    public ImmutableDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public ImmutableDictionary`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableDictionary`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer);
    public sealed virtual bool ContainsValue(TValue value);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    internal SortedInt32KeyNode`1<HashBucket<TKey, TValue>> get_Root();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static ImmutableDictionary`2<TKey, TValue> EmptyWithComparers(Comparers<TKey, TValue> comparers);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableDictionary`2& other);
    private static bool ContainsKey(TKey key, MutationInput<TKey, TValue> origin);
    private static bool Contains(KeyValuePair`2<TKey, TValue> keyValuePair, MutationInput<TKey, TValue> origin);
    private static bool TryGetValue(TKey key, MutationInput<TKey, TValue> origin, TValue& value);
    private static bool TryGetKey(TKey equalKey, MutationInput<TKey, TValue> origin, TKey& actualKey);
    private static MutationResult<TKey, TValue> Add(TKey key, TValue value, KeyCollisionBehavior<TKey, TValue> behavior, MutationInput<TKey, TValue> origin);
    private static MutationResult<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, MutationInput<TKey, TValue> origin, KeyCollisionBehavior<TKey, TValue> collisionBehavior);
    private static MutationResult<TKey, TValue> Remove(TKey key, MutationInput<TKey, TValue> origin);
    private static SortedInt32KeyNode`1<HashBucket<TKey, TValue>> UpdateRoot(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, int hashCode, HashBucket<TKey, TValue> newBucket, IEqualityComparer`1<HashBucket<TKey, TValue>> hashBucketComparer);
    private static ImmutableDictionary`2<TKey, TValue> Wrap(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, Comparers<TKey, TValue> comparers, int count);
    private ImmutableDictionary`2<TKey, TValue> Wrap(SortedInt32KeyNode`1<HashBucket<TKey, TValue>> root, int adjustedCountIfDifferentRoot);
    private ImmutableDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, bool avoidToHashMap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.ImmutableDictionaryBuilderDebuggerProxy`2 : object {
    private Builder<TKey, TValue> _map;
    private KeyValuePair`2[] _contents;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Contents { get; }
    public ImmutableDictionaryBuilderDebuggerProxy`2(Builder<TKey, TValue> map);
    public KeyValuePair`2[] get_Contents();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2 : ImmutableEnumerableDebuggerProxy`1<KeyValuePair`2<TKey, TValue>> {
    public ImmutableDictionaryDebuggerProxy`2(IReadOnlyDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1 : object {
    private IEnumerable`1<T> _enumerable;
    private T[] _cachedContents;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableEnumerableDebuggerProxy`1(IEnumerable`1<T> enumerable);
    public T[] get_Contents();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Collections.Immutable.ImmutableExtensions : object {
    [NullableContextAttribute("2")]
internal static bool IsValueType();
    [ExtensionAttribute]
internal static IOrderedCollection`1<T> AsOrderedCollection(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
internal static void ClearFastWhenEmpty(Stack`1<T> stack);
    [ExtensionAttribute]
internal static DisposableEnumeratorAdapter`2<T, TEnumerator> GetEnumerableDisposable(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
internal static bool TryGetCount(IEnumerable`1<T> sequence, Int32& count);
    [ExtensionAttribute]
internal static bool TryGetCount(IEnumerable sequence, Int32& count);
    internal static int GetCount(IEnumerable`1& sequence);
    [ExtensionAttribute]
internal static bool TryCopyTo(IEnumerable`1<T> sequence, T[] array, int arrayIndex);
    [ExtensionAttribute]
internal static T[] ToArray(IEnumerable`1<T> sequence, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableHashSet : object {
    public static ImmutableHashSet`1<T> Create();
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableHashSet`1<T> Create(T item);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T item);
    public static ImmutableHashSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableHashSet`1<T> CreateRange(IEqualityComparer`1<T> equalityComparer, IEnumerable`1<T> items);
    public static ImmutableHashSet`1<T> Create(T[] items);
    public static ImmutableHashSet`1<T> Create(ReadOnlySpan`1<T> items);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T[] items);
    public static ImmutableHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, ReadOnlySpan`1<T> items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> equalityComparer);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(Builder<TSource> builder);
    [ExtensionAttribute]
public static ImmutableHashSet`1<TSource> ToImmutableHashSet(IEnumerable`1<TSource> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableHashSet", "Create")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableHashSet`1 : object {
    public static ImmutableHashSet`1<T> Empty;
    private static Action`1<KeyValuePair`2<int, HashBucket<T>>> s_FreezeBucketAction;
    private IEqualityComparer`1<T> _equalityComparer;
    private int _count;
    private SortedInt32KeyNode`1<HashBucket<T>> _root;
    private IEqualityComparer`1<HashBucket<T>> _hashBucketEqualityComparer;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEqualityComparer`1<T> KeyComparer { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    internal IBinaryTree Root { get; }
    [NullableAttribute("0")]
private MutationInput<T> Origin { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    internal ImmutableHashSet`1(IEqualityComparer`1<T> equalityComparer);
    private ImmutableHashSet`1(SortedInt32KeyNode`1<HashBucket<T>> root, IEqualityComparer`1<T> equalityComparer, int count);
    private static ImmutableHashSet`1();
    public ImmutableHashSet`1<T> Clear();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual IEqualityComparer`1<T> get_KeyComparer();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    internal IBinaryTree get_Root();
    private MutationInput<T> get_Origin();
    public Builder<T> ToBuilder();
    public ImmutableHashSet`1<T> Add(T item);
    public ImmutableHashSet`1<T> Remove(T item);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableHashSet`1<T> Union(IEnumerable`1<T> other);
    internal ImmutableHashSet`1<T> Union(ReadOnlySpan`1<T> other);
    public ImmutableHashSet`1<T> Intersect(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> Except(IEnumerable`1<T> other);
    public ImmutableHashSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T item);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T item);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool Contains(T item);
    public ImmutableHashSet`1<T> WithComparer(IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    [NullableContextAttribute("0")]
public sealed virtual Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsSupersetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static MutationResult<T> Add(T item, MutationInput<T> origin);
    private static MutationResult<T> Remove(T item, MutationInput<T> origin);
    private static bool Contains(T item, MutationInput<T> origin);
    private static MutationResult<T> Union(IEnumerable`1<T> other, MutationInput<T> origin);
    private static MutationResult<T> Union(ReadOnlySpan`1<T> other, MutationInput<T> origin);
    private static bool Overlaps(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool SetEquals(IEnumerable`1<T> other, MutationInput<T> origin);
    private static SortedInt32KeyNode`1<HashBucket<T>> UpdateRoot(SortedInt32KeyNode`1<HashBucket<T>> root, int hashCode, IEqualityComparer`1<HashBucket<T>> hashBucketEqualityComparer, HashBucket<T> newBucket);
    private static MutationResult<T> Intersect(IEnumerable`1<T> other, MutationInput<T> origin);
    private static MutationResult<T> Except(IEnumerable`1<T> other, IEqualityComparer`1<T> equalityComparer, IEqualityComparer`1<HashBucket<T>> hashBucketEqualityComparer, SortedInt32KeyNode`1<HashBucket<T>> root);
    private static MutationResult<T> SymmetricExcept(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool IsProperSubsetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool IsProperSupersetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static bool IsSubsetOf(IEnumerable`1<T> other, MutationInput<T> origin);
    private static ImmutableHashSet`1<T> Wrap(SortedInt32KeyNode`1<HashBucket<T>> root, IEqualityComparer`1<T> equalityComparer, int count);
    private static IEqualityComparer`1<HashBucket<T>> GetHashBucketEqualityComparer(IEqualityComparer`1<T> valueComparer);
    private ImmutableHashSet`1<T> Wrap(SortedInt32KeyNode`1<HashBucket<T>> root, int adjustedCountIfDifferentRoot);
    private ImmutableHashSet`1<T> Union(IEnumerable`1<T> items, bool avoidWithComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Collections.Immutable.ImmutableInterlocked : object {
    public static bool Update(T& location, Func`2<T, T> transformer);
    public static bool Update(T& location, Func`3<T, TArg, T> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableArray`1& location, Func`2<ImmutableArray`1<T>, ImmutableArray`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableArray`1& location, Func`3<ImmutableArray`1<T>, TArg, ImmutableArray`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> InterlockedExchange(ImmutableArray`1& location, ImmutableArray`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<T> InterlockedCompareExchange(ImmutableArray`1& location, ImmutableArray`1<T> value, ImmutableArray`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableArray`1& location, ImmutableArray`1<T> value);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableDictionary`2& location, TKey key, TValue value);
    public static TValue AddOrUpdate(ImmutableDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static bool TryAdd(ImmutableDictionary`2& location, TKey key, TValue value);
    public static bool TryUpdate(ImmutableDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool TryRemove(ImmutableDictionary`2& location, TKey key, TValue& value);
    public static bool TryPop(ImmutableStack`1& location, T& value);
    public static void Push(ImmutableStack`1& location, T value);
    public static bool TryDequeue(ImmutableQueue`1& location, T& value);
    public static void Enqueue(ImmutableQueue`1& location, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableList : object {
    public static ImmutableList`1<T> Create();
    public static ImmutableList`1<T> Create(T item);
    public static ImmutableList`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableList`1<T> Create(T[] items);
    public static ImmutableList`1<T> Create(ReadOnlySpan`1<T> items);
    public static Builder<T> CreateBuilder();
    [ExtensionAttribute]
public static ImmutableList`1<TSource> ToImmutableList(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableList`1<TSource> ToImmutableList(Builder<TSource> builder);
    [ExtensionAttribute]
public static IImmutableList`1<T> Replace(IImmutableList`1<T> list, T oldValue, T newValue);
    [ExtensionAttribute]
public static IImmutableList`1<T> Remove(IImmutableList`1<T> list, T value);
    [ExtensionAttribute]
public static IImmutableList`1<T> RemoveRange(IImmutableList`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, int startIndex);
    [ExtensionAttribute]
public static int IndexOf(IImmutableList`1<T> list, T item, int startIndex, int count);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, int startIndex);
    [ExtensionAttribute]
public static int LastIndexOf(IImmutableList`1<T> list, T item, int startIndex, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableList", "Create")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableList`1 : object {
    public static ImmutableList`1<T> Empty;
    private Node<T> _root;
    [DebuggerBrowsableAttribute("0")]
public bool IsEmpty { get; }
    public int Count { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    public T Item { get; }
    private T System.Collections.Immutable.IOrderedCollection<T>.Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Node<T> Root { get; }
    private ImmutableList`1(Node<T> root);
    private static ImmutableList`1();
    public ImmutableList`1<T> Clear();
    public sealed virtual int BinarySearch(T item);
    public sealed virtual int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public bool get_IsEmpty();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    public sealed virtual int get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual T get_Item(int index);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    private sealed virtual override T System.Collections.Immutable.IOrderedCollection<T>.get_Item(int index);
    public Builder<T> ToBuilder();
    public ImmutableList`1<T> Add(T value);
    public ImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    internal ImmutableList`1<T> AddRange(ReadOnlySpan`1<T> items);
    public ImmutableList`1<T> Insert(int index, T item);
    public ImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public ImmutableList`1<T> Remove(T value);
    public ImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> RemoveRange(int index, int count);
    public ImmutableList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> RemoveAt(int index);
    public ImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableList`1<T> SetItem(int index, T value);
    public ImmutableList`1<T> Replace(T oldValue, T newValue);
    public ImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> Reverse();
    public ImmutableList`1<T> Reverse(int index, int count);
    public ImmutableList`1<T> Sort();
    public ImmutableList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public sealed virtual void ForEach(Action`1<T> action);
    public sealed virtual void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual ImmutableList`1<T> GetRange(int index, int count);
    public sealed virtual ImmutableList`1<TOutput> ConvertAll(Func`2<T, TOutput> converter);
    public sealed virtual bool Exists(Predicate`1<T> match);
    public sealed virtual T Find(Predicate`1<T> match);
    public sealed virtual ImmutableList`1<T> FindAll(Predicate`1<T> match);
    public sealed virtual int FindIndex(Predicate`1<T> match);
    public sealed virtual int FindIndex(int startIndex, Predicate`1<T> match);
    public sealed virtual int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public sealed virtual T FindLast(Predicate`1<T> match);
    public sealed virtual int FindLastIndex(Predicate`1<T> match);
    public sealed virtual int FindLastIndex(int startIndex, Predicate`1<T> match);
    public sealed virtual int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual bool TrueForAll(Predicate`1<T> match);
    public sealed virtual bool Contains(T value);
    public sealed virtual int IndexOf(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T item);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    [NullableContextAttribute("0")]
public sealed virtual Enumerator<T> GetEnumerator();
    internal Node<T> get_Root();
    private static ImmutableList`1<T> WrapNode(Node<T> root);
    private static bool TryCastToImmutableList(IEnumerable`1<T> sequence, ImmutableList`1& other);
    private static bool IsCompatibleObject(object value);
    private ImmutableList`1<T> Wrap(Node<T> root);
    private static ImmutableList`1<T> CreateRange(IEnumerable`1<T> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.ImmutableListBuilderDebuggerProxy`1 : object {
    private Builder<T> _list;
    private T[] _cachedContents;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableListBuilderDebuggerProxy`1(Builder<T> builder);
    public T[] get_Contents();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableQueue : object {
    public static ImmutableQueue`1<T> Create();
    public static ImmutableQueue`1<T> Create(T item);
    public static ImmutableQueue`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableQueue`1<T> Create(T[] items);
    public static ImmutableQueue`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static IImmutableQueue`1<T> Dequeue(IImmutableQueue`1<T> queue, T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableQueue", "Create")]
[DebuggerDisplayAttribute("IsEmpty = {IsEmpty}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableQueue`1 : object {
    private static ImmutableQueue`1<T> s_EmptyField;
    private ImmutableStack`1<T> _backwards;
    private ImmutableStack`1<T> _forwards;
    private ImmutableStack`1<T> _backwardsReversed;
    public bool IsEmpty { get; }
    public static ImmutableQueue`1<T> Empty { get; }
    private ImmutableStack`1<T> BackwardsReversed { get; }
    internal ImmutableQueue`1(ImmutableStack`1<T> forwards, ImmutableStack`1<T> backwards);
    private static ImmutableQueue`1();
    public ImmutableQueue`1<T> Clear();
    public sealed virtual bool get_IsEmpty();
    public static ImmutableQueue`1<T> get_Empty();
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Clear();
    private ImmutableStack`1<T> get_BackwardsReversed();
    public sealed virtual T Peek();
    public T& modreq(System.Runtime.InteropServices.InAttribute) PeekRef();
    public ImmutableQueue`1<T> Enqueue(T value);
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Enqueue(T value);
    public ImmutableQueue`1<T> Dequeue();
    public ImmutableQueue`1<T> Dequeue(T& value);
    private sealed virtual override IImmutableQueue`1<T> System.Collections.Immutable.IImmutableQueue<T>.Dequeue();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableSortedDictionary : object {
    public static ImmutableSortedDictionary`2<TKey, TValue> Create();
    public static ImmutableSortedDictionary`2<TKey, TValue> Create(IComparer`1<TKey> keyComparer);
    public static ImmutableSortedDictionary`2<TKey, TValue> Create(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSortedDictionary`2<TKey, TValue> CreateRange(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source, IComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSortedDictionary`2<TKey, TValue> ToImmutableSortedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableDictionaryDebuggerProxy`2")]
public class System.Collections.Immutable.ImmutableSortedDictionary`2 : object {
    public static ImmutableSortedDictionary`2<TKey, TValue> Empty;
    private Node<TKey, TValue> _root;
    private int _count;
    private IComparer`1<TKey> _keyComparer;
    private IEqualityComparer`1<TValue> _valueComparer;
    public IEqualityComparer`1<TValue> ValueComparer { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    public IComparer`1<TKey> KeyComparer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Node<TKey, TValue> Root { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    internal ImmutableSortedDictionary`2(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private ImmutableSortedDictionary`2(Node<TKey, TValue> root, int count, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private static ImmutableSortedDictionary`2();
    public ImmutableSortedDictionary`2<TKey, TValue> Clear();
    public IEqualityComparer`1<TValue> get_ValueComparer();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    public sealed virtual IComparer`1<TKey> get_KeyComparer();
    internal Node<TKey, TValue> get_Root();
    public sealed virtual TValue get_Item(TKey key);
    public TValue& modreq(System.Runtime.InteropServices.InAttribute) ValueRef(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public Builder<TKey, TValue> ToBuilder();
    public ImmutableSortedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSortedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSortedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableSortedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableSortedDictionary`2<TKey, TValue> Remove(TKey value);
    public ImmutableSortedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSortedDictionary`2<TKey, TValue> WithComparers(IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableSortedDictionary`2<TKey, TValue> WithComparers(IComparer`1<TKey> keyComparer);
    public bool ContainsValue(TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private static ImmutableSortedDictionary`2<TKey, TValue> Wrap(Node<TKey, TValue> root, int count, IComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableSortedDictionary`2& other);
    private ImmutableSortedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, bool overwriteOnCollision, bool avoidToSortedMap);
    private ImmutableSortedDictionary`2<TKey, TValue> Wrap(Node<TKey, TValue> root, int adjustedCountIfDifferentRoot);
    private ImmutableSortedDictionary`2<TKey, TValue> FillFromEmpty(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, bool overwriteOnCollision);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.ImmutableSortedDictionaryBuilderDebuggerProxy`2 : object {
    private Builder<TKey, TValue> _map;
    private KeyValuePair`2[] _contents;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Contents { get; }
    public ImmutableSortedDictionaryBuilderDebuggerProxy`2(Builder<TKey, TValue> map);
    public KeyValuePair`2[] get_Contents();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableSortedSet : object {
    public static ImmutableSortedSet`1<T> Create();
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer);
    public static ImmutableSortedSet`1<T> Create(T item);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, T item);
    public static ImmutableSortedSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableSortedSet`1<T> CreateRange(IComparer`1<T> comparer, IEnumerable`1<T> items);
    public static ImmutableSortedSet`1<T> Create(T[] items);
    public static ImmutableSortedSet`1<T> Create(ReadOnlySpan`1<T> items);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, T[] items);
    public static ImmutableSortedSet`1<T> Create(IComparer`1<T> comparer, ReadOnlySpan`1<T> items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(IEnumerable`1<TSource> source, IComparer`1<TSource> comparer);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableSortedSet`1<TSource> ToImmutableSortedSet(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableSortedSet", "Create")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableSortedSet`1 : object {
    public static ImmutableSortedSet`1<T> Empty;
    private Node<T> _root;
    private IComparer`1<T> _comparer;
    [NullableAttribute("2")]
public T Max { get; }
    [NullableAttribute("2")]
public T Min { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public IComparer`1<T> KeyComparer { get; }
    internal IBinaryTree Root { get; }
    public T Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    internal ImmutableSortedSet`1(IComparer`1<T> comparer);
    private ImmutableSortedSet`1(Node<T> root, IComparer`1<T> comparer);
    private static ImmutableSortedSet`1();
    public ImmutableSortedSet`1<T> Clear();
    [NullableContextAttribute("2")]
public T get_Max();
    [NullableContextAttribute("2")]
public T get_Min();
    public bool get_IsEmpty();
    public sealed virtual int get_Count();
    public sealed virtual IComparer`1<T> get_KeyComparer();
    internal IBinaryTree get_Root();
    public sealed virtual T get_Item(int index);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public Builder<T> ToBuilder();
    public ImmutableSortedSet`1<T> Add(T value);
    public ImmutableSortedSet`1<T> Remove(T value);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableSortedSet`1<T> Intersect(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> Except(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public ImmutableSortedSet`1<T> Union(IEnumerable`1<T> other);
    internal ImmutableSortedSet`1<T> Union(ReadOnlySpan`1<T> other);
    public ImmutableSortedSet`1<T> WithComparer(IComparer`1<T> comparer);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public IEnumerable`1<T> Reverse();
    public sealed virtual int IndexOf(T item);
    public sealed virtual bool Contains(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("0")]
public sealed virtual Enumerator<T> GetEnumerator();
    private static bool TryCastToImmutableSortedSet(IEnumerable`1<T> sequence, ImmutableSortedSet`1& other);
    private static ImmutableSortedSet`1<T> Wrap(Node<T> root, IComparer`1<T> comparer);
    private ImmutableSortedSet`1<T> UnionIncremental(IEnumerable`1<T> items);
    private ImmutableSortedSet`1<T> UnionIncremental(ReadOnlySpan`1<T> items);
    private ImmutableSortedSet`1<T> Wrap(Node<T> root);
    private ImmutableSortedSet`1<T> LeafToRootRefill(IEnumerable`1<T> addedItems);
    private ImmutableSortedSet`1<T> LeafToRootRefill(ReadOnlySpan`1<T> addedItems);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Collections.Immutable.ImmutableSortedSetBuilderDebuggerProxy`1 : object {
    private Builder<T> _set;
    [DebuggerBrowsableAttribute("3")]
public T[] Contents { get; }
    public ImmutableSortedSetBuilderDebuggerProxy`1(Builder<T> builder);
    public T[] get_Contents();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Immutable.ImmutableStack : object {
    public static ImmutableStack`1<T> Create();
    public static ImmutableStack`1<T> Create(T item);
    public static ImmutableStack`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableStack`1<T> Create(T[] items);
    public static ImmutableStack`1<T> Create(ReadOnlySpan`1<T> items);
    [ExtensionAttribute]
public static IImmutableStack`1<T> Pop(IImmutableStack`1<T> stack, T& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[CollectionBuilderAttribute("System.Collections.Immutable.ImmutableStack", "Create")]
[DebuggerDisplayAttribute("IsEmpty = {IsEmpty}, Top = {_head}")]
[DebuggerTypeProxyAttribute("System.Collections.Immutable.ImmutableEnumerableDebuggerProxy`1")]
public class System.Collections.Immutable.ImmutableStack`1 : object {
    private static ImmutableStack`1<T> s_EmptyField;
    private T _head;
    private ImmutableStack`1<T> _tail;
    public static ImmutableStack`1<T> Empty { get; }
    public bool IsEmpty { get; }
    private ImmutableStack`1(T head, ImmutableStack`1<T> tail);
    private static ImmutableStack`1();
    public static ImmutableStack`1<T> get_Empty();
    public ImmutableStack`1<T> Clear();
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Clear();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual T Peek();
    public T& modreq(System.Runtime.InteropServices.InAttribute) PeekRef();
    public ImmutableStack`1<T> Push(T value);
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Push(T value);
    public ImmutableStack`1<T> Pop();
    public ImmutableStack`1<T> Pop(T& value);
    private sealed virtual override IImmutableStack`1<T> System.Collections.Immutable.IImmutableStack<T>.Pop();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal ImmutableStack`1<T> Reverse();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
internal interface System.Collections.Immutable.IOrderedCollection`1 {
    public int Count { get; }
    public T Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual T get_Item(int index);
}
internal interface System.Collections.Immutable.ISecurePooledObjectUser {
    public int PoolUserId { get; }
    public abstract virtual int get_PoolUserId();
}
internal interface System.Collections.Immutable.IStrongEnumerable`2 {
    public abstract virtual TEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
internal interface System.Collections.Immutable.IStrongEnumerator`1 {
    public T Current { get; }
    public abstract virtual T get_Current();
    public abstract virtual bool MoveNext();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Immutable.KeysCollectionAccessor`2 : KeysOrValuesCollectionAccessor`3<TKey, TValue, TKey> {
    internal KeysCollectionAccessor`2(IImmutableDictionary`2<TKey, TValue> dictionary);
    public virtual bool Contains(TKey item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Collections.Immutable.KeysOrValuesCollectionAccessor`3 : object {
    private IImmutableDictionary`2<TKey, TValue> _dictionary;
    private IEnumerable`1<T> _keysOrValues;
    public bool IsReadOnly { get; }
    public int Count { get; }
    protected IImmutableDictionary`2<TKey, TValue> Dictionary { get; }
    [DebuggerBrowsableAttribute("0")]
private bool System.Collections.ICollection.IsSynchronized { get; }
    [DebuggerBrowsableAttribute("0")]
private object System.Collections.ICollection.SyncRoot { get; }
    protected KeysOrValuesCollectionAccessor`3(IImmutableDictionary`2<TKey, TValue> dictionary, IEnumerable`1<T> keysOrValues);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    protected IImmutableDictionary`2<TKey, TValue> get_Dictionary();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public abstract virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Value,nq}")]
internal class System.Collections.Immutable.RefAsValueType`1 : ValueType {
    internal T Value;
    internal RefAsValueType`1(T value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class System.Collections.Immutable.Requires : object {
    [NullableContextAttribute("1")]
[DebuggerStepThroughAttribute]
public static void NotNull(T value, string parameterName);
    [NullableContextAttribute("1")]
[DebuggerStepThroughAttribute]
public static T NotNullPassthrough(T value, string parameterName);
    [DebuggerStepThroughAttribute]
public static void NotNullAllowStructs(T value, string parameterName);
    [DoesNotReturnAttribute]
[DebuggerStepThroughAttribute]
public static void FailArgumentNullException(string parameterName);
    [DebuggerStepThroughAttribute]
public static void Range(bool condition, string parameterName, string message);
    [DoesNotReturnAttribute]
[DebuggerStepThroughAttribute]
public static void FailRange(string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void Argument(bool condition);
    [NullableContextAttribute("1")]
[DoesNotReturnAttribute]
[DebuggerStepThroughAttribute]
public static void FailObjectDisposed(TDisposed disposed);
}
internal static class System.Collections.Immutable.SecureObjectPool : object {
    private static int s_poolUserIdCounter;
    internal static int UnassignedId;
    internal static int NewId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Collections.Immutable.SecureObjectPool`2 : object {
    public static void TryAdd(TCaller caller, SecurePooledObject`1<T> item);
    public static bool TryTake(TCaller caller, SecurePooledObject`1& item);
    public static SecurePooledObject`1<T> PrepNew(TCaller caller, T newValue);
}
internal class System.Collections.Immutable.SecurePooledObject`1 : object {
    private T _value;
    private int _owner;
    internal int Owner { get; internal set; }
    [NullableContextAttribute("1")]
internal SecurePooledObject`1(T newValue);
    internal int get_Owner();
    internal void set_Owner(int value);
    internal T Use(TCaller& caller);
    internal bool TryUse(TCaller& caller, T& value);
    internal bool IsOwned(TCaller& caller);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{_key} = {_value}")]
internal class System.Collections.Immutable.SortedInt32KeyNode`1 : object {
    internal static SortedInt32KeyNode`1<TValue> EmptyNode;
    private int _key;
    private TValue _value;
    private bool _frozen;
    private byte _height;
    private SortedInt32KeyNode`1<TValue> _left;
    private SortedInt32KeyNode`1<TValue> _right;
    public bool IsEmpty { get; }
    public int Height { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SortedInt32KeyNode`1<TValue> Left { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SortedInt32KeyNode`1<TValue> Right { get; }
    [NullableAttribute("2")]
private IBinaryTree System.Collections.Immutable.IBinaryTree.Left { get; }
    [NullableAttribute("2")]
private IBinaryTree System.Collections.Immutable.IBinaryTree.Right { get; }
    private int System.Collections.Immutable.IBinaryTree.Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<int, TValue> Value { get; }
    internal IEnumerable`1<TValue> Values { get; }
    private SortedInt32KeyNode`1(int key, TValue value, SortedInt32KeyNode`1<TValue> left, SortedInt32KeyNode`1<TValue> right, bool frozen);
    private static SortedInt32KeyNode`1();
    public sealed virtual bool get_IsEmpty();
    public sealed virtual int get_Height();
    public SortedInt32KeyNode`1<TValue> get_Left();
    public SortedInt32KeyNode`1<TValue> get_Right();
    private sealed virtual override IBinaryTree System.Collections.Immutable.IBinaryTree.get_Left();
    private sealed virtual override IBinaryTree System.Collections.Immutable.IBinaryTree.get_Right();
    private sealed virtual override int System.Collections.Immutable.IBinaryTree.get_Count();
    public KeyValuePair`2<int, TValue> get_Value();
    [IteratorStateMachineAttribute("System.Collections.Immutable.SortedInt32KeyNode`1/<get_Values>d__26")]
internal IEnumerable`1<TValue> get_Values();
    [NullableContextAttribute("0")]
public Enumerator<TValue> GetEnumerator();
    internal SortedInt32KeyNode`1<TValue> SetItem(int key, TValue value, IEqualityComparer`1<TValue> valueComparer, Boolean& replacedExistingValue, Boolean& mutated);
    internal SortedInt32KeyNode`1<TValue> Remove(int key, Boolean& mutated);
    [NullableContextAttribute("2")]
internal TValue GetValueOrDefault(int key);
    internal bool TryGetValue(int key, TValue& value);
    internal void Freeze(Action`1<KeyValuePair`2<int, TValue>> freezeAction);
    private static SortedInt32KeyNode`1<TValue> RotateLeft(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> RotateRight(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> DoubleLeft(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> DoubleRight(SortedInt32KeyNode`1<TValue> tree);
    private static int Balance(SortedInt32KeyNode`1<TValue> tree);
    private static bool IsRightHeavy(SortedInt32KeyNode`1<TValue> tree);
    private static bool IsLeftHeavy(SortedInt32KeyNode`1<TValue> tree);
    private static SortedInt32KeyNode`1<TValue> MakeBalanced(SortedInt32KeyNode`1<TValue> tree);
    private SortedInt32KeyNode`1<TValue> SetOrAdd(int key, TValue value, IEqualityComparer`1<TValue> valueComparer, bool overwriteExistingValue, Boolean& replacedExistingValue, Boolean& mutated);
    private SortedInt32KeyNode`1<TValue> RemoveRecursive(int key, Boolean& mutated);
    private SortedInt32KeyNode`1<TValue> Mutate(SortedInt32KeyNode`1<TValue> left, SortedInt32KeyNode`1<TValue> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class System.Collections.Immutable.ValuesCollectionAccessor`2 : KeysOrValuesCollectionAccessor`3<TKey, TValue, TValue> {
    internal ValuesCollectionAccessor`2(IImmutableDictionary`2<TKey, TValue> dictionary);
    public virtual bool Contains(TValue item);
}
internal static class System.Collections.ThrowHelper : object {
    [NullableContextAttribute("1")]
public static void ThrowIfNull(object arg, string paramName);
    [DoesNotReturnAttribute]
public static void ThrowIfDestinationTooSmall();
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void ThrowArgumentNullException(string paramName);
    [DoesNotReturnAttribute]
public static void ThrowKeyNotFoundException();
    [DoesNotReturnAttribute]
public static void ThrowInvalidOperationException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Linq.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImmutableArray`1<T> immutableArray, Func`2<T, TResult> selector);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> SelectMany(ImmutableArray`1<TSource> immutableArray, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
    [ExtensionAttribute]
public static IEnumerable`1<T> Where(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, ImmutableArray`1<TDerived> items, IEqualityComparer`1<TBase> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, IEnumerable`1<TDerived> items, IEqualityComparer`1<TBase> comparer);
    [ExtensionAttribute]
public static bool SequenceEqual(ImmutableArray`1<TBase> immutableArray, ImmutableArray`1<TDerived> items, Func`3<TBase, TBase, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T Aggregate(ImmutableArray`1<T> immutableArray, Func`3<T, T, T> func);
    [ExtensionAttribute]
public static TAccumulate Aggregate(ImmutableArray`1<T> immutableArray, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func);
    [ExtensionAttribute]
public static TResult Aggregate(ImmutableArray`1<T> immutableArray, TAccumulate seed, Func`3<TAccumulate, T, TAccumulate> func, Func`2<TAccumulate, TResult> resultSelector);
    [ExtensionAttribute]
public static T ElementAt(ImmutableArray`1<T> immutableArray, int index);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T ElementAtOrDefault(ImmutableArray`1<T> immutableArray, int index);
    [ExtensionAttribute]
public static T First(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T First(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Last(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T Last(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T LastOrDefault(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T LastOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Single(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T Single(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T SingleOrDefault(ImmutableArray`1<T> immutableArray);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T SingleOrDefault(ImmutableArray`1<T> immutableArray, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector);
    [ExtensionAttribute]
public static Dictionary`2<TKey, T> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TElement> ToDictionary(ImmutableArray`1<T> immutableArray, Func`2<T, TKey> keySelector, Func`2<T, TElement> elementSelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static T[] ToArray(ImmutableArray`1<T> immutableArray);
    [ExtensionAttribute]
public static T First(Builder<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T FirstOrDefault(Builder<T> builder);
    [ExtensionAttribute]
public static T Last(Builder<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T LastOrDefault(Builder<T> builder);
    [ExtensionAttribute]
public static bool Any(Builder<T> builder);
    [IteratorStateMachineAttribute("System.Linq.ImmutableArrayExtensions/<SelectManyIterator>d__36`3")]
[ExtensionAttribute]
private static IEnumerable`1<TResult> SelectManyIterator(ImmutableArray`1<TSource> immutableArray, Func`2<TSource, IEnumerable`1<TCollection>> collectionSelector, Func`3<TSource, TCollection, TResult> resultSelector);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.ImmutableCollectionsMarshal : object {
    public static ImmutableArray`1<T> AsImmutableArray(T[] array);
    public static T[] AsArray(ImmutableArray`1<T> array);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string ArrayInitializedStateNotEqual { get; }
    internal static string ArrayLengthsNotEqual { get; }
    internal static string CannotFindOldValue { get; }
    internal static string CapacityMustBeGreaterThanOrEqualToCount { get; }
    internal static string CapacityMustEqualCountOnMove { get; }
    internal static string CollectionModifiedDuringEnumeration { get; }
    internal static string DuplicateKey { get; }
    internal static string InvalidEmptyOperation { get; }
    internal static string InvalidOperationOnDefaultArray { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Argument_IncompatibleArrayType { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(string resourceFormat, Object[] args);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    [NullableContextAttribute("2")]
internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    [NullableContextAttribute("1")]
internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_ArrayInitializedStateNotEqual();
    internal static string get_ArrayLengthsNotEqual();
    internal static string get_CannotFindOldValue();
    internal static string get_CapacityMustBeGreaterThanOrEqualToCount();
    internal static string get_CapacityMustEqualCountOnMove();
    internal static string get_CollectionModifiedDuringEnumeration();
    internal static string get_DuplicateKey();
    internal static string get_InvalidEmptyOperation();
    internal static string get_InvalidOperationOnDefaultArray();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Argument_IncompatibleArrayType();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
}
