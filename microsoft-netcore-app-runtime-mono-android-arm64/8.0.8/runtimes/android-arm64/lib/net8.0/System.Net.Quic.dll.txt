internal static class FxResources.System.Net.Quic.SR : object {
}
internal static class Interop : object {
}
internal static class Microsoft.Quic.MsQuic : object {
    public static int QUIC_STATUS_SUCCESS { get; }
    public static int QUIC_STATUS_PENDING { get; }
    public static int QUIC_STATUS_CONTINUE { get; }
    public static int QUIC_STATUS_OUT_OF_MEMORY { get; }
    public static int QUIC_STATUS_INVALID_PARAMETER { get; }
    public static int QUIC_STATUS_INVALID_STATE { get; }
    public static int QUIC_STATUS_NOT_SUPPORTED { get; }
    public static int QUIC_STATUS_NOT_FOUND { get; }
    public static int QUIC_STATUS_BUFFER_TOO_SMALL { get; }
    public static int QUIC_STATUS_HANDSHAKE_FAILURE { get; }
    public static int QUIC_STATUS_ABORTED { get; }
    public static int QUIC_STATUS_ADDRESS_IN_USE { get; }
    public static int QUIC_STATUS_INVALID_ADDRESS { get; }
    public static int QUIC_STATUS_CONNECTION_TIMEOUT { get; }
    public static int QUIC_STATUS_CONNECTION_IDLE { get; }
    public static int QUIC_STATUS_UNREACHABLE { get; }
    public static int QUIC_STATUS_INTERNAL_ERROR { get; }
    public static int QUIC_STATUS_CONNECTION_REFUSED { get; }
    public static int QUIC_STATUS_PROTOCOL_ERROR { get; }
    public static int QUIC_STATUS_VER_NEG_ERROR { get; }
    public static int QUIC_STATUS_TLS_ERROR { get; }
    public static int QUIC_STATUS_USER_CANCELED { get; }
    public static int QUIC_STATUS_ALPN_NEG_FAILURE { get; }
    public static int QUIC_STATUS_STREAM_LIMIT_REACHED { get; }
    public static int QUIC_STATUS_ALPN_IN_USE { get; }
    public static int QUIC_STATUS_CLOSE_NOTIFY { get; }
    public static int QUIC_STATUS_BAD_CERTIFICATE { get; }
    public static int QUIC_STATUS_UNSUPPORTED_CERTIFICATE { get; }
    public static int QUIC_STATUS_REVOKED_CERTIFICATE { get; }
    public static int QUIC_STATUS_EXPIRED_CERTIFICATE { get; }
    public static int QUIC_STATUS_UNKNOWN_CERTIFICATE { get; }
    public static int QUIC_STATUS_REQUIRED_CERTIFICATE { get; }
    public static int QUIC_STATUS_CERT_EXPIRED { get; }
    public static int QUIC_STATUS_CERT_UNTRUSTED_ROOT { get; }
    public static int QUIC_STATUS_CERT_NO_CERT { get; }
    public static int QUIC_STATUS_ADDRESS_NOT_AVAILABLE { get; }
    public static int QUIC_ADDRESS_FAMILY_UNSPEC { get; }
    public static bool StatusSucceeded(int status);
    public static bool StatusFailed(int status);
    public static int get_QUIC_STATUS_SUCCESS();
    public static int get_QUIC_STATUS_PENDING();
    public static int get_QUIC_STATUS_CONTINUE();
    public static int get_QUIC_STATUS_OUT_OF_MEMORY();
    public static int get_QUIC_STATUS_INVALID_PARAMETER();
    public static int get_QUIC_STATUS_INVALID_STATE();
    public static int get_QUIC_STATUS_NOT_SUPPORTED();
    public static int get_QUIC_STATUS_NOT_FOUND();
    public static int get_QUIC_STATUS_BUFFER_TOO_SMALL();
    public static int get_QUIC_STATUS_HANDSHAKE_FAILURE();
    public static int get_QUIC_STATUS_ABORTED();
    public static int get_QUIC_STATUS_ADDRESS_IN_USE();
    public static int get_QUIC_STATUS_INVALID_ADDRESS();
    public static int get_QUIC_STATUS_CONNECTION_TIMEOUT();
    public static int get_QUIC_STATUS_CONNECTION_IDLE();
    public static int get_QUIC_STATUS_UNREACHABLE();
    public static int get_QUIC_STATUS_INTERNAL_ERROR();
    public static int get_QUIC_STATUS_CONNECTION_REFUSED();
    public static int get_QUIC_STATUS_PROTOCOL_ERROR();
    public static int get_QUIC_STATUS_VER_NEG_ERROR();
    public static int get_QUIC_STATUS_TLS_ERROR();
    public static int get_QUIC_STATUS_USER_CANCELED();
    public static int get_QUIC_STATUS_ALPN_NEG_FAILURE();
    public static int get_QUIC_STATUS_STREAM_LIMIT_REACHED();
    public static int get_QUIC_STATUS_ALPN_IN_USE();
    public static int get_QUIC_STATUS_CLOSE_NOTIFY();
    public static int get_QUIC_STATUS_BAD_CERTIFICATE();
    public static int get_QUIC_STATUS_UNSUPPORTED_CERTIFICATE();
    public static int get_QUIC_STATUS_REVOKED_CERTIFICATE();
    public static int get_QUIC_STATUS_EXPIRED_CERTIFICATE();
    public static int get_QUIC_STATUS_UNKNOWN_CERTIFICATE();
    public static int get_QUIC_STATUS_REQUIRED_CERTIFICATE();
    public static int get_QUIC_STATUS_CERT_EXPIRED();
    public static int get_QUIC_STATUS_CERT_UNTRUSTED_ROOT();
    public static int get_QUIC_STATUS_CERT_NO_CERT();
    public static int get_QUIC_STATUS_ADDRESS_NOT_AVAILABLE();
    public static int get_QUIC_ADDRESS_FAMILY_UNSPEC();
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_ALLOWED_CIPHER_SUITE_FLAGS : Enum {
    public int value__;
    public static QUIC_ALLOWED_CIPHER_SUITE_FLAGS NONE;
    public static QUIC_ALLOWED_CIPHER_SUITE_FLAGS AES_128_GCM_SHA256;
    public static QUIC_ALLOWED_CIPHER_SUITE_FLAGS AES_256_GCM_SHA384;
    public static QUIC_ALLOWED_CIPHER_SUITE_FLAGS CHACHA20_POLY1305_SHA256;
}
internal class Microsoft.Quic.QUIC_API_TABLE : ValueType {
    internal method SetContext;
    internal method GetContext;
    internal method SetCallbackHandler;
    internal method SetParam;
    internal method GetParam;
    internal method RegistrationOpen;
    internal method RegistrationClose;
    internal method RegistrationShutdown;
    internal method ConfigurationOpen;
    internal method ConfigurationClose;
    internal method ConfigurationLoadCredential;
    internal method ListenerOpen;
    internal method ListenerClose;
    internal method ListenerStart;
    internal method ListenerStop;
    internal method ConnectionOpen;
    internal method ConnectionClose;
    internal method ConnectionShutdown;
    internal method ConnectionStart;
    internal method ConnectionSetConfiguration;
    internal method ConnectionSendResumptionTicket;
    internal method StreamOpen;
    internal method StreamClose;
    internal method StreamStart;
    internal method StreamShutdown;
    internal method StreamSend;
    internal method StreamReceiveComplete;
    internal method StreamReceiveSetEnabled;
    internal method DatagramSend;
    internal method ConnectionResumptionTicketValidationComplete;
    internal method ConnectionCertificateValidationComplete;
}
internal class Microsoft.Quic.QUIC_BUFFER : ValueType {
    internal UInt32 Length;
    internal Byte* Buffer;
    public Span`1<byte> Span { get; }
    public Span`1<byte> get_Span();
}
internal class Microsoft.Quic.QUIC_CERTIFICATE_FILE : ValueType {
    internal SByte* PrivateKeyFile;
    internal SByte* CertificateFile;
}
internal class Microsoft.Quic.QUIC_CERTIFICATE_FILE_PROTECTED : ValueType {
    internal SByte* PrivateKeyFile;
    internal SByte* CertificateFile;
    internal SByte* PrivateKeyPassword;
}
internal class Microsoft.Quic.QUIC_CERTIFICATE_HASH : ValueType {
    [FixedBufferAttribute("System.Byte", "20")]
internal <ShaHash>e__FixedBuffer ShaHash;
}
internal class Microsoft.Quic.QUIC_CERTIFICATE_HASH_STORE : ValueType {
    internal QUIC_CERTIFICATE_HASH_STORE_FLAGS Flags;
    [FixedBufferAttribute("System.Byte", "20")]
internal <ShaHash>e__FixedBuffer ShaHash;
    [FixedBufferAttribute("System.SByte", "128")]
internal <StoreName>e__FixedBuffer StoreName;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_CERTIFICATE_HASH_STORE_FLAGS : Enum {
    public int value__;
    public static QUIC_CERTIFICATE_HASH_STORE_FLAGS NONE;
    public static QUIC_CERTIFICATE_HASH_STORE_FLAGS MACHINE_STORE;
}
internal class Microsoft.Quic.QUIC_CERTIFICATE_PKCS12 : ValueType {
    internal Byte* Asn1Blob;
    internal UInt32 Asn1BlobLength;
    internal SByte* PrivateKeyPassword;
}
internal class Microsoft.Quic.QUIC_CONNECTION_EVENT : ValueType {
    internal QUIC_CONNECTION_EVENT_TYPE Type;
    internal _Anonymous_e__Union Anonymous;
    internal _CONNECTED_e__Struct& CONNECTED { get; }
    internal _SHUTDOWN_INITIATED_BY_TRANSPORT_e__Struct& SHUTDOWN_INITIATED_BY_TRANSPORT { get; }
    internal _SHUTDOWN_INITIATED_BY_PEER_e__Struct& SHUTDOWN_INITIATED_BY_PEER { get; }
    internal _SHUTDOWN_COMPLETE_e__Struct& SHUTDOWN_COMPLETE { get; }
    internal _LOCAL_ADDRESS_CHANGED_e__Struct& LOCAL_ADDRESS_CHANGED { get; }
    internal _PEER_ADDRESS_CHANGED_e__Struct& PEER_ADDRESS_CHANGED { get; }
    internal _PEER_STREAM_STARTED_e__Struct& PEER_STREAM_STARTED { get; }
    internal _PEER_CERTIFICATE_RECEIVED_e__Struct& PEER_CERTIFICATE_RECEIVED { get; }
    public virtual string ToString();
    internal _CONNECTED_e__Struct& get_CONNECTED();
    internal _SHUTDOWN_INITIATED_BY_TRANSPORT_e__Struct& get_SHUTDOWN_INITIATED_BY_TRANSPORT();
    internal _SHUTDOWN_INITIATED_BY_PEER_e__Struct& get_SHUTDOWN_INITIATED_BY_PEER();
    internal _SHUTDOWN_COMPLETE_e__Struct& get_SHUTDOWN_COMPLETE();
    internal _LOCAL_ADDRESS_CHANGED_e__Struct& get_LOCAL_ADDRESS_CHANGED();
    internal _PEER_ADDRESS_CHANGED_e__Struct& get_PEER_ADDRESS_CHANGED();
    internal _PEER_STREAM_STARTED_e__Struct& get_PEER_STREAM_STARTED();
    internal _PEER_CERTIFICATE_RECEIVED_e__Struct& get_PEER_CERTIFICATE_RECEIVED();
}
internal enum Microsoft.Quic.QUIC_CONNECTION_EVENT_TYPE : Enum {
    public int value__;
    public static QUIC_CONNECTION_EVENT_TYPE CONNECTED;
    public static QUIC_CONNECTION_EVENT_TYPE SHUTDOWN_INITIATED_BY_TRANSPORT;
    public static QUIC_CONNECTION_EVENT_TYPE SHUTDOWN_INITIATED_BY_PEER;
    public static QUIC_CONNECTION_EVENT_TYPE SHUTDOWN_COMPLETE;
    public static QUIC_CONNECTION_EVENT_TYPE LOCAL_ADDRESS_CHANGED;
    public static QUIC_CONNECTION_EVENT_TYPE PEER_ADDRESS_CHANGED;
    public static QUIC_CONNECTION_EVENT_TYPE PEER_STREAM_STARTED;
    public static QUIC_CONNECTION_EVENT_TYPE STREAMS_AVAILABLE;
    public static QUIC_CONNECTION_EVENT_TYPE PEER_NEEDS_STREAMS;
    public static QUIC_CONNECTION_EVENT_TYPE IDEAL_PROCESSOR_CHANGED;
    public static QUIC_CONNECTION_EVENT_TYPE DATAGRAM_STATE_CHANGED;
    public static QUIC_CONNECTION_EVENT_TYPE DATAGRAM_RECEIVED;
    public static QUIC_CONNECTION_EVENT_TYPE DATAGRAM_SEND_STATE_CHANGED;
    public static QUIC_CONNECTION_EVENT_TYPE RESUMED;
    public static QUIC_CONNECTION_EVENT_TYPE RESUMPTION_TICKET_RECEIVED;
    public static QUIC_CONNECTION_EVENT_TYPE PEER_CERTIFICATE_RECEIVED;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_CONNECTION_SHUTDOWN_FLAGS : Enum {
    public int value__;
    public static QUIC_CONNECTION_SHUTDOWN_FLAGS NONE;
    public static QUIC_CONNECTION_SHUTDOWN_FLAGS SILENT;
}
internal class Microsoft.Quic.QUIC_CREDENTIAL_CONFIG : ValueType {
    internal QUIC_CREDENTIAL_TYPE Type;
    internal QUIC_CREDENTIAL_FLAGS Flags;
    internal _Anonymous_e__Union Anonymous;
    internal SByte* Principal;
    internal Void* Reserved;
    internal method AsyncHandler;
    internal QUIC_ALLOWED_CIPHER_SUITE_FLAGS AllowedCipherSuites;
    internal SByte* CaCertificateFile;
    internal Void*& CertificateContext { get; }
    internal QUIC_CERTIFICATE_PKCS12*& CertificatePkcs12 { get; }
    internal Void*& get_CertificateContext();
    internal QUIC_CERTIFICATE_PKCS12*& get_CertificatePkcs12();
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_CREDENTIAL_FLAGS : Enum {
    public int value__;
    public static QUIC_CREDENTIAL_FLAGS NONE;
    public static QUIC_CREDENTIAL_FLAGS CLIENT;
    public static QUIC_CREDENTIAL_FLAGS LOAD_ASYNCHRONOUS;
    public static QUIC_CREDENTIAL_FLAGS NO_CERTIFICATE_VALIDATION;
    public static QUIC_CREDENTIAL_FLAGS ENABLE_OCSP;
    public static QUIC_CREDENTIAL_FLAGS INDICATE_CERTIFICATE_RECEIVED;
    public static QUIC_CREDENTIAL_FLAGS DEFER_CERTIFICATE_VALIDATION;
    public static QUIC_CREDENTIAL_FLAGS REQUIRE_CLIENT_AUTHENTICATION;
    public static QUIC_CREDENTIAL_FLAGS USE_TLS_BUILTIN_CERTIFICATE_VALIDATION;
    public static QUIC_CREDENTIAL_FLAGS REVOCATION_CHECK_END_CERT;
    public static QUIC_CREDENTIAL_FLAGS REVOCATION_CHECK_CHAIN;
    public static QUIC_CREDENTIAL_FLAGS REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    public static QUIC_CREDENTIAL_FLAGS IGNORE_NO_REVOCATION_CHECK;
    public static QUIC_CREDENTIAL_FLAGS IGNORE_REVOCATION_OFFLINE;
    public static QUIC_CREDENTIAL_FLAGS SET_ALLOWED_CIPHER_SUITES;
    public static QUIC_CREDENTIAL_FLAGS USE_PORTABLE_CERTIFICATES;
    public static QUIC_CREDENTIAL_FLAGS USE_SUPPLIED_CREDENTIALS;
    public static QUIC_CREDENTIAL_FLAGS USE_SYSTEM_MAPPER;
    public static QUIC_CREDENTIAL_FLAGS CACHE_ONLY_URL_RETRIEVAL;
    public static QUIC_CREDENTIAL_FLAGS REVOCATION_CHECK_CACHE_ONLY;
    public static QUIC_CREDENTIAL_FLAGS INPROC_PEER_CERTIFICATE;
    public static QUIC_CREDENTIAL_FLAGS SET_CA_CERTIFICATE_FILE;
}
internal enum Microsoft.Quic.QUIC_CREDENTIAL_TYPE : Enum {
    public int value__;
    public static QUIC_CREDENTIAL_TYPE NONE;
    public static QUIC_CREDENTIAL_TYPE CERTIFICATE_HASH;
    public static QUIC_CREDENTIAL_TYPE CERTIFICATE_HASH_STORE;
    public static QUIC_CREDENTIAL_TYPE CERTIFICATE_CONTEXT;
    public static QUIC_CREDENTIAL_TYPE CERTIFICATE_FILE;
    public static QUIC_CREDENTIAL_TYPE CERTIFICATE_FILE_PROTECTED;
    public static QUIC_CREDENTIAL_TYPE CERTIFICATE_PKCS12;
}
internal enum Microsoft.Quic.QUIC_DATAGRAM_SEND_STATE : Enum {
    public int value__;
    public static QUIC_DATAGRAM_SEND_STATE UNKNOWN;
    public static QUIC_DATAGRAM_SEND_STATE SENT;
    public static QUIC_DATAGRAM_SEND_STATE LOST_SUSPECT;
    public static QUIC_DATAGRAM_SEND_STATE LOST_DISCARDED;
    public static QUIC_DATAGRAM_SEND_STATE ACKNOWLEDGED;
    public static QUIC_DATAGRAM_SEND_STATE ACKNOWLEDGED_SPURIOUS;
    public static QUIC_DATAGRAM_SEND_STATE CANCELED;
}
internal enum Microsoft.Quic.QUIC_EXECUTION_PROFILE : Enum {
    public int value__;
    public static QUIC_EXECUTION_PROFILE LOW_LATENCY;
    public static QUIC_EXECUTION_PROFILE MAX_THROUGHPUT;
    public static QUIC_EXECUTION_PROFILE SCAVENGER;
    public static QUIC_EXECUTION_PROFILE REAL_TIME;
}
internal class Microsoft.Quic.QUIC_HANDLE : ValueType {
}
internal class Microsoft.Quic.QUIC_LISTENER_EVENT : ValueType {
    internal QUIC_LISTENER_EVENT_TYPE Type;
    internal _Anonymous_e__Union Anonymous;
    internal _NEW_CONNECTION_e__Struct& NEW_CONNECTION { get; }
    public virtual string ToString();
    internal _NEW_CONNECTION_e__Struct& get_NEW_CONNECTION();
}
internal enum Microsoft.Quic.QUIC_LISTENER_EVENT_TYPE : Enum {
    public int value__;
    public static QUIC_LISTENER_EVENT_TYPE NEW_CONNECTION;
    public static QUIC_LISTENER_EVENT_TYPE STOP_COMPLETE;
}
internal class Microsoft.Quic.QUIC_NEW_CONNECTION_INFO : ValueType {
    internal UInt32 QuicVersion;
    internal QuicAddr* LocalAddress;
    internal QuicAddr* RemoteAddress;
    internal UInt32 CryptoBufferLength;
    internal ushort ClientAlpnListLength;
    internal ushort ServerNameLength;
    internal byte NegotiatedAlpnLength;
    internal Byte* CryptoBuffer;
    internal Byte* ClientAlpnList;
    internal Byte* NegotiatedAlpn;
    internal SByte* ServerName;
    public virtual string ToString();
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_RECEIVE_FLAGS : Enum {
    public int value__;
    public static QUIC_RECEIVE_FLAGS NONE;
    public static QUIC_RECEIVE_FLAGS ZERO_RTT;
    public static QUIC_RECEIVE_FLAGS FIN;
}
internal class Microsoft.Quic.QUIC_REGISTRATION_CONFIG : ValueType {
    internal SByte* AppName;
    internal QUIC_EXECUTION_PROFILE ExecutionProfile;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_SEND_FLAGS : Enum {
    public int value__;
    public static QUIC_SEND_FLAGS NONE;
    public static QUIC_SEND_FLAGS ALLOW_0_RTT;
    public static QUIC_SEND_FLAGS START;
    public static QUIC_SEND_FLAGS FIN;
    public static QUIC_SEND_FLAGS DGRAM_PRIORITY;
    public static QUIC_SEND_FLAGS DELAY_SEND;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_SEND_RESUMPTION_FLAGS : Enum {
    public int value__;
    public static QUIC_SEND_RESUMPTION_FLAGS NONE;
    public static QUIC_SEND_RESUMPTION_FLAGS FINAL;
}
internal class Microsoft.Quic.QUIC_SETTINGS : ValueType {
    internal _Anonymous1_e__Union Anonymous1;
    internal ulong MaxBytesPerKey;
    internal ulong HandshakeIdleTimeoutMs;
    internal ulong IdleTimeoutMs;
    internal ulong MtuDiscoverySearchCompleteTimeoutUs;
    internal UInt32 TlsClientMaxSendBuffer;
    internal UInt32 TlsServerMaxSendBuffer;
    internal UInt32 StreamRecvWindowDefault;
    internal UInt32 StreamRecvBufferDefault;
    internal UInt32 ConnFlowControlWindow;
    internal UInt32 MaxWorkerQueueDelayUs;
    internal UInt32 MaxStatelessOperations;
    internal UInt32 InitialWindowPackets;
    internal UInt32 SendIdleTimeoutMs;
    internal UInt32 InitialRttMs;
    internal UInt32 MaxAckDelayMs;
    internal UInt32 DisconnectTimeoutMs;
    internal UInt32 KeepAliveIntervalMs;
    internal ushort CongestionControlAlgorithm;
    internal ushort PeerBidiStreamCount;
    internal ushort PeerUnidiStreamCount;
    internal ushort MaxBindingStatelessOperations;
    internal ushort StatelessOperationExpirationMs;
    internal ushort MinimumMtu;
    internal ushort MaximumMtu;
    internal byte _bitfield;
    internal byte MaxOperationsPerDrain;
    internal byte MtuDiscoveryMissingProbeCount;
    internal UInt32 DestCidUpdateIdleTimeoutMs;
    internal _Anonymous2_e__Union Anonymous2;
    internal _IsSet_e__Struct& IsSet { get; }
    internal _IsSet_e__Struct& get_IsSet();
}
internal class Microsoft.Quic.QUIC_STREAM_EVENT : ValueType {
    internal QUIC_STREAM_EVENT_TYPE Type;
    internal _Anonymous_e__Union Anonymous;
    internal _START_COMPLETE_e__Struct& START_COMPLETE { get; }
    internal _RECEIVE_e__Struct& RECEIVE { get; }
    internal _SEND_COMPLETE_e__Struct& SEND_COMPLETE { get; }
    internal _PEER_SEND_ABORTED_e__Struct& PEER_SEND_ABORTED { get; }
    internal _PEER_RECEIVE_ABORTED_e__Struct& PEER_RECEIVE_ABORTED { get; }
    internal _SEND_SHUTDOWN_COMPLETE_e__Struct& SEND_SHUTDOWN_COMPLETE { get; }
    internal _SHUTDOWN_COMPLETE_e__Struct& SHUTDOWN_COMPLETE { get; }
    public virtual string ToString();
    internal _START_COMPLETE_e__Struct& get_START_COMPLETE();
    internal _RECEIVE_e__Struct& get_RECEIVE();
    internal _SEND_COMPLETE_e__Struct& get_SEND_COMPLETE();
    internal _PEER_SEND_ABORTED_e__Struct& get_PEER_SEND_ABORTED();
    internal _PEER_RECEIVE_ABORTED_e__Struct& get_PEER_RECEIVE_ABORTED();
    internal _SEND_SHUTDOWN_COMPLETE_e__Struct& get_SEND_SHUTDOWN_COMPLETE();
    internal _SHUTDOWN_COMPLETE_e__Struct& get_SHUTDOWN_COMPLETE();
}
internal enum Microsoft.Quic.QUIC_STREAM_EVENT_TYPE : Enum {
    public int value__;
    public static QUIC_STREAM_EVENT_TYPE START_COMPLETE;
    public static QUIC_STREAM_EVENT_TYPE RECEIVE;
    public static QUIC_STREAM_EVENT_TYPE SEND_COMPLETE;
    public static QUIC_STREAM_EVENT_TYPE PEER_SEND_SHUTDOWN;
    public static QUIC_STREAM_EVENT_TYPE PEER_SEND_ABORTED;
    public static QUIC_STREAM_EVENT_TYPE PEER_RECEIVE_ABORTED;
    public static QUIC_STREAM_EVENT_TYPE SEND_SHUTDOWN_COMPLETE;
    public static QUIC_STREAM_EVENT_TYPE SHUTDOWN_COMPLETE;
    public static QUIC_STREAM_EVENT_TYPE IDEAL_SEND_BUFFER_SIZE;
    public static QUIC_STREAM_EVENT_TYPE PEER_ACCEPTED;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_STREAM_OPEN_FLAGS : Enum {
    public int value__;
    public static QUIC_STREAM_OPEN_FLAGS NONE;
    public static QUIC_STREAM_OPEN_FLAGS UNIDIRECTIONAL;
    public static QUIC_STREAM_OPEN_FLAGS ZERO_RTT;
    public static QUIC_STREAM_OPEN_FLAGS DELAY_FC_UPDATES;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_STREAM_SHUTDOWN_FLAGS : Enum {
    public int value__;
    public static QUIC_STREAM_SHUTDOWN_FLAGS NONE;
    public static QUIC_STREAM_SHUTDOWN_FLAGS GRACEFUL;
    public static QUIC_STREAM_SHUTDOWN_FLAGS ABORT_SEND;
    public static QUIC_STREAM_SHUTDOWN_FLAGS ABORT_RECEIVE;
    public static QUIC_STREAM_SHUTDOWN_FLAGS ABORT;
    public static QUIC_STREAM_SHUTDOWN_FLAGS IMMEDIATE;
    public static QUIC_STREAM_SHUTDOWN_FLAGS INLINE;
}
[FlagsAttribute]
internal enum Microsoft.Quic.QUIC_STREAM_START_FLAGS : Enum {
    public int value__;
    public static QUIC_STREAM_START_FLAGS NONE;
    public static QUIC_STREAM_START_FLAGS IMMEDIATE;
    public static QUIC_STREAM_START_FLAGS FAIL_BLOCKED;
    public static QUIC_STREAM_START_FLAGS SHUTDOWN_ON_FAIL;
    public static QUIC_STREAM_START_FLAGS INDICATE_PEER_ACCEPT;
}
internal enum Microsoft.Quic.QUIC_TLS_ALERT_CODES : Enum {
    public int value__;
    public static QUIC_TLS_ALERT_CODES SUCCESS;
    public static QUIC_TLS_ALERT_CODES UNEXPECTED_MESSAGE;
    public static QUIC_TLS_ALERT_CODES BAD_CERTIFICATE;
    public static QUIC_TLS_ALERT_CODES UNSUPPORTED_CERTIFICATE;
    public static QUIC_TLS_ALERT_CODES CERTIFICATE_REVOKED;
    public static QUIC_TLS_ALERT_CODES CERTIFICATE_EXPIRED;
    public static QUIC_TLS_ALERT_CODES CERTIFICATE_UNKNOWN;
    public static QUIC_TLS_ALERT_CODES ILLEGAL_PARAMETER;
    public static QUIC_TLS_ALERT_CODES UNKNOWN_CA;
    public static QUIC_TLS_ALERT_CODES ACCESS_DENIED;
    public static QUIC_TLS_ALERT_CODES INSUFFICIENT_SECURITY;
    public static QUIC_TLS_ALERT_CODES INTERNAL_ERROR;
    public static QUIC_TLS_ALERT_CODES USER_CANCELED;
    public static QUIC_TLS_ALERT_CODES CERTIFICATE_REQUIRED;
    public static QUIC_TLS_ALERT_CODES MAX;
}
internal enum Microsoft.Quic.QUIC_TLS_PROVIDER : Enum {
    public int value__;
    public static QUIC_TLS_PROVIDER SCHANNEL;
    public static QUIC_TLS_PROVIDER OPENSSL;
}
internal class Microsoft.Quic.QuicAddr : ValueType {
    public QuicAddrIn Ipv4;
    public QuicAddrIn6 Ipv6;
    public QuicAddrFamilyAndLen FamilyLen;
    public static bool SockaddrHasLength { get; }
    public int Family { get; public set; }
    public static bool get_SockaddrHasLength();
    public int get_Family();
    public void set_Family(int value);
}
internal class Microsoft.Quic.QuicAddrFamilyAndLen : ValueType {
    public ushort sin_family;
    public byte sin_len;
    public byte sin_family_bsd;
}
internal class Microsoft.Quic.QuicAddrIn : ValueType {
    public QuicAddrFamilyAndLen sin_family;
    public ushort sin_port;
    [FixedBufferAttribute("System.Byte", "4")]
public <sin_addr>e__FixedBuffer sin_addr;
}
internal class Microsoft.Quic.QuicAddrIn6 : ValueType {
    public QuicAddrFamilyAndLen sin6_family;
    public ushort sin6_port;
    public UInt32 sin6_flowinfo;
    [FixedBufferAttribute("System.Byte", "16")]
public <sin6_addr>e__FixedBuffer sin6_addr;
    public UInt32 sin6_scope_id;
}
internal class Microsoft.Win32.SafeHandles.SafeX509Handle : SafeHandle {
    public bool IsInvalid { get; }
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
}
internal static class System.IPv4AddressHelper : object {
    internal static bool IsValid(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile, bool unknownScheme);
    internal static bool IsValidCanonical(Char* name, int start, Int32& end, bool allowIPv6, bool notImplicitFile);
    internal static long ParseNonCanonical(Char* name, int start, Int32& end, bool notImplicitFile);
}
internal static class System.IPv6AddressHelper : object {
    internal static bool IsValidStrict(Char* name, int start, Int32& end);
}
internal class System.Net.MultiArrayBuffer : ValueType {
    private Byte[][] _blocks;
    private UInt32 _allocatedEnd;
    private UInt32 _activeStart;
    private UInt32 _availableStart;
    public bool IsEmpty { get; }
    public MultiMemory ActiveMemory { get; }
    public MultiMemory AvailableMemory { get; }
    public sealed virtual void Dispose();
    public bool get_IsEmpty();
    public MultiMemory get_ActiveMemory();
    public MultiMemory get_AvailableMemory();
    public void Discard(int byteCount);
    public void DiscardAll();
    private void FreeBlocks(UInt32 startBlock, UInt32 endBlock);
    public void Commit(int byteCount);
    public void EnsureAvailableSpace(int byteCount);
    public void GrowAvailableSpace(int byteCount);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class System.Net.MultiMemory : ValueType {
    private Byte[][] _blocks;
    private UInt32 _start;
    private UInt32 _length;
    public int Length { get; }
    public int BlockCount { get; }
    internal MultiMemory(Byte[][] blocks, UInt32 start, UInt32 length);
    private static UInt32 GetBlockIndex(UInt32 offset);
    private static UInt32 GetOffsetInBlock(UInt32 offset);
    public int get_Length();
    public int get_BlockCount();
    public Memory`1<byte> GetBlock(int blockIndex);
    public MultiMemory Slice(int start, int length);
    public void CopyTo(Span`1<byte> destination);
    public void CopyFrom(ReadOnlySpan`1<byte> source);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    private static NetEventSource();
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("1")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [EventAttribute("2")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static string Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    private static void AdditionalCustomizedToString(object value, String& result);
}
internal class System.Net.Quic.MsQuicApi : object {
    private static Version s_minWindowsVersion;
    private static Version s_minMsQuicVersion;
    private static method MsQuicOpenVersion;
    private static method MsQuicClose;
    [CompilerGeneratedAttribute]
private MsQuicSafeHandle <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private QUIC_API_TABLE* <ApiTable>k__BackingField;
    private static Lazy`1<MsQuicApi> _api;
    [CompilerGeneratedAttribute]
private static bool <IsQuicSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MsQuicLibraryVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NotSupportedReason>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UsesSChannelBackend>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Tls13ServerMayBeDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <Tls13ClientMayBeDisabled>k__BackingField;
    public MsQuicSafeHandle Registration { get; }
    public QUIC_API_TABLE* ApiTable { get; }
    internal static MsQuicApi Api { get; }
    internal static bool IsQuicSupported { get; }
    internal static string MsQuicLibraryVersion { get; }
    internal static string NotSupportedReason { get; }
    internal static bool UsesSChannelBackend { get; }
    [DynamicDependencyAttribute("3", "System.Net.Quic.MsQuicSafeHandle")]
[DynamicDependencyAttribute("3", "System.Net.Quic.MsQuicContextSafeHandle")]
private MsQuicApi(QUIC_API_TABLE* apiTable);
    private static MsQuicApi();
    [CompilerGeneratedAttribute]
public MsQuicSafeHandle get_Registration();
    [CompilerGeneratedAttribute]
public QUIC_API_TABLE* get_ApiTable();
    internal static MsQuicApi get_Api();
    [CompilerGeneratedAttribute]
internal static bool get_IsQuicSupported();
    [CompilerGeneratedAttribute]
internal static string get_MsQuicLibraryVersion();
    [CompilerGeneratedAttribute]
internal static string get_NotSupportedReason();
    [CompilerGeneratedAttribute]
internal static bool get_UsesSChannelBackend();
    private static MsQuicApi AllocateMsQuicApi();
    private static bool TryOpenMsQuic(QUIC_API_TABLE*& apiTable, Int32& openStatus);
    private static bool IsWindowsVersionSupported();
    private static bool IsTls13Disabled(bool isServer);
    public void SetCallbackHandler(MsQuicSafeHandle handle, Void* callback, Void* context);
    public int SetParam(MsQuicSafeHandle handle, UInt32 param, UInt32 bufferLength, Void* buffer);
    public int GetParam(MsQuicSafeHandle handle, UInt32 param, UInt32* bufferLength, Void* buffer);
    public int ConfigurationOpen(MsQuicSafeHandle registration, QUIC_BUFFER* alpnBuffers, UInt32 alpnBuffersCount, QUIC_SETTINGS* settings, UInt32 settingsSize, Void* context, QUIC_HANDLE** configuration);
    public int ConfigurationLoadCredential(MsQuicSafeHandle configuration, QUIC_CREDENTIAL_CONFIG* config);
    public int ListenerOpen(MsQuicSafeHandle registration, method callback, Void* context, QUIC_HANDLE** listener);
    public int ListenerStart(MsQuicSafeHandle listener, QUIC_BUFFER* alpnBuffers, UInt32 alpnBuffersCount, QuicAddr* localAddress);
    public void ListenerStop(MsQuicSafeHandle listener);
    public int ConnectionOpen(MsQuicSafeHandle registration, method callback, Void* context, QUIC_HANDLE** connection);
    public void ConnectionShutdown(MsQuicSafeHandle connection, QUIC_CONNECTION_SHUTDOWN_FLAGS flags, ulong code);
    public int ConnectionStart(MsQuicSafeHandle connection, MsQuicSafeHandle configuration, ushort family, SByte* serverName, ushort serverPort);
    public int ConnectionSetConfiguration(MsQuicSafeHandle connection, MsQuicSafeHandle configuration);
    public int StreamOpen(MsQuicSafeHandle connection, QUIC_STREAM_OPEN_FLAGS flags, method callback, Void* context, QUIC_HANDLE** stream);
    public int StreamStart(MsQuicSafeHandle stream, QUIC_STREAM_START_FLAGS flags);
    public int StreamShutdown(MsQuicSafeHandle stream, QUIC_STREAM_SHUTDOWN_FLAGS flags, ulong code);
    public int StreamSend(MsQuicSafeHandle stream, QUIC_BUFFER* buffers, UInt32 buffersCount, QUIC_SEND_FLAGS flags, Void* context);
    public int StreamReceiveSetEnabled(MsQuicSafeHandle stream, byte enabled);
}
internal class System.Net.Quic.MsQuicBuffers : ValueType {
    private QUIC_BUFFER* _buffers;
    private int _count;
    public QUIC_BUFFER* Buffers { get; }
    public int Count { get; }
    public QUIC_BUFFER* get_Buffers();
    public int get_Count();
    private void FreeNativeMemory();
    private void Reserve(int count);
    private void SetBuffer(int index, ReadOnlyMemory`1<byte> buffer);
    public void Initialize(IList`1<T> inputs, Func`2<T, ReadOnlyMemory`1<byte>> toBuffer);
    public void Initialize(ReadOnlyMemory`1<byte> buffer);
    public void Reset();
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class System.Net.Quic.MsQuicConfiguration : object {
    [ExtensionAttribute]
private static bool HasPrivateKey(X509Certificate certificate);
    public static MsQuicSafeHandle Create(QuicClientConnectionOptions options);
    public static MsQuicSafeHandle Create(QuicServerConnectionOptions options, string targetHost);
    private static MsQuicSafeHandle Create(QuicConnectionOptions options, QUIC_CREDENTIAL_FLAGS flags, X509Certificate certificate, ReadOnlyCollection`1<X509Certificate2> intermediates, List`1<SslApplicationProtocol> alpnProtocols, CipherSuitesPolicy cipherSuitesPolicy, EncryptionPolicy encryptionPolicy);
    private static QUIC_ALLOWED_CIPHER_SUITE_FLAGS CipherSuitePolicyToFlags(CipherSuitesPolicy cipherSuitesPolicy);
}
internal class System.Net.Quic.MsQuicContextSafeHandle : MsQuicSafeHandle {
    private GCHandle _context;
    private MsQuicSafeHandle _parent;
    public MsQuicContextSafeHandle(QUIC_HANDLE* handle, GCHandle context, SafeHandleType safeHandleType, MsQuicSafeHandle parent);
    protected virtual bool ReleaseHandle();
}
[ExtensionAttribute]
internal static class System.Net.Quic.MsQuicHelpers : object {
    [ExtensionAttribute]
internal static bool TryParse(EndPoint endPoint, String& host, IPAddress& address, Int32& port);
    internal static IPEndPoint QuicAddrToIPEndPoint(QuicAddr* quicAddress, Nullable`1<AddressFamily> addressFamilyOverride);
    [ExtensionAttribute]
internal static QuicAddr ToQuicAddr(IPEndPoint ipEndPoint);
    internal static T GetMsQuicParameter(MsQuicSafeHandle handle, UInt32 parameter);
    internal static void SetMsQuicParameter(MsQuicSafeHandle handle, UInt32 parameter, T value);
}
internal class System.Net.Quic.MsQuicSafeHandle : SafeHandle {
    private static String[] s_typeName;
    private method _releaseAction;
    private string _traceId;
    private SafeHandleType _type;
    public bool IsInvalid { get; }
    public QUIC_HANDLE* QuicHandle { get; }
    public MsQuicSafeHandle(QUIC_HANDLE* handle, method releaseAction, SafeHandleType safeHandleType);
    public MsQuicSafeHandle(QUIC_HANDLE* handle, SafeHandleType safeHandleType);
    private static MsQuicSafeHandle();
    public virtual bool get_IsInvalid();
    public QUIC_HANDLE* get_QuicHandle();
    protected virtual bool ReleaseHandle();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Net.Quic.QuicAbortDirection : Enum {
    public int value__;
    public static QuicAbortDirection Read;
    public static QuicAbortDirection Write;
    public static QuicAbortDirection Both;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Quic.QuicClientConnectionOptions : QuicConnectionOptions {
    [CompilerGeneratedAttribute]
private SslClientAuthenticationOptions <ClientAuthenticationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <RemoteEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <LocalEndPoint>k__BackingField;
    public SslClientAuthenticationOptions ClientAuthenticationOptions { get; public set; }
    public EndPoint RemoteEndPoint { get; public set; }
    [NullableAttribute("2")]
public IPEndPoint LocalEndPoint { get; public set; }
    [CompilerGeneratedAttribute]
public SslClientAuthenticationOptions get_ClientAuthenticationOptions();
    [CompilerGeneratedAttribute]
public void set_ClientAuthenticationOptions(SslClientAuthenticationOptions value);
    [CompilerGeneratedAttribute]
public EndPoint get_RemoteEndPoint();
    [CompilerGeneratedAttribute]
public void set_RemoteEndPoint(EndPoint value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IPEndPoint get_LocalEndPoint();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_LocalEndPoint(IPEndPoint value);
    internal virtual void Validate(string argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Quic.QuicConnection : object {
    private MsQuicContextSafeHandle _handle;
    private int _disposed;
    private TaskCompletionSource _connectionCloseTcs;
    private ValueTaskSource _connectedTcs;
    private ValueTaskSource _shutdownTcs;
    private Channel`1<QuicStream> _acceptQueue;
    private SslConnectionOptions _sslConnectionOptions;
    private MsQuicSafeHandle _configuration;
    private bool _canAccept;
    private long _defaultStreamErrorCode;
    private long _defaultCloseErrorCode;
    private IPEndPoint _remoteEndPoint;
    private IPEndPoint _localEndPoint;
    private bool _remoteCertificateExposed;
    private X509Certificate2 _remoteCertificate;
    private SslApplicationProtocol _negotiatedApplicationProtocol;
    public static bool IsSupported { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public IPEndPoint LocalEndPoint { get; }
    public string TargetHostName { get; }
    [NullableAttribute("2")]
public X509Certificate RemoteCertificate { get; }
    public SslApplicationProtocol NegotiatedApplicationProtocol { get; }
    internal QuicConnection(QUIC_HANDLE* handle, QUIC_NEW_CONNECTION_INFO* info);
    public static bool get_IsSupported();
    public static ValueTask`1<QuicConnection> ConnectAsync(QuicClientConnectionOptions options, CancellationToken cancellationToken);
    public IPEndPoint get_RemoteEndPoint();
    public IPEndPoint get_LocalEndPoint();
    public string get_TargetHostName();
    [NullableContextAttribute("2")]
public X509Certificate get_RemoteCertificate();
    public SslApplicationProtocol get_NegotiatedApplicationProtocol();
    public virtual string ToString();
    [AsyncStateMachineAttribute("System.Net.Quic.QuicConnection/<FinishConnectAsync>d__32")]
private ValueTask FinishConnectAsync(QuicClientConnectionOptions options, CancellationToken cancellationToken);
    internal ValueTask FinishHandshakeAsync(QuicServerConnectionOptions options, string targetHost, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Quic.QuicConnection/<OpenOutboundStreamAsync>d__34")]
public ValueTask`1<QuicStream> OpenOutboundStreamAsync(QuicStreamType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Quic.QuicConnection/<AcceptInboundStreamAsync>d__35")]
public ValueTask`1<QuicStream> AcceptInboundStreamAsync(CancellationToken cancellationToken);
    public ValueTask CloseAsync(long errorCode, CancellationToken cancellationToken);
    private int HandleEventConnected(_CONNECTED_e__Struct& data);
    private int HandleEventShutdownInitiatedByTransport(_SHUTDOWN_INITIATED_BY_TRANSPORT_e__Struct& data);
    private int HandleEventShutdownInitiatedByPeer(_SHUTDOWN_INITIATED_BY_PEER_e__Struct& data);
    private int HandleEventShutdownComplete();
    private int HandleEventLocalAddressChanged(_LOCAL_ADDRESS_CHANGED_e__Struct& data);
    private int HandleEventPeerAddressChanged(_PEER_ADDRESS_CHANGED_e__Struct& data);
    private int HandleEventPeerStreamStarted(_PEER_STREAM_STARTED_e__Struct& data);
    private int HandleEventPeerCertificateReceived(_PEER_CERTIFICATE_RECEIVED_e__Struct& data);
    private int HandleConnectionEvent(QUIC_CONNECTION_EVENT& connectionEvent);
    [UnmanagedCallersOnlyAttribute]
private static int NativeCallback(QUIC_HANDLE* connection, Void* context, QUIC_CONNECTION_EVENT* connectionEvent);
    [AsyncStateMachineAttribute("System.Net.Quic.QuicConnection/<DisposeAsync>d__47")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.Net.Quic.QuicConnection/<<ConnectAsync>g__StartConnectAsync|2_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<QuicConnection> <ConnectAsync>g__StartConnectAsync|2_0(QuicClientConnectionOptions options, CancellationToken cancellationToken);
}
public abstract class System.Net.Quic.QuicConnectionOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxInboundBidirectionalStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxInboundUnidirectionalStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <IdleTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DefaultStreamErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DefaultCloseErrorCode>k__BackingField;
    public int MaxInboundBidirectionalStreams { get; public set; }
    public int MaxInboundUnidirectionalStreams { get; public set; }
    public TimeSpan IdleTimeout { get; public set; }
    public long DefaultStreamErrorCode { get; public set; }
    public long DefaultCloseErrorCode { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxInboundBidirectionalStreams();
    [CompilerGeneratedAttribute]
public void set_MaxInboundBidirectionalStreams(int value);
    [CompilerGeneratedAttribute]
public int get_MaxInboundUnidirectionalStreams();
    [CompilerGeneratedAttribute]
public void set_MaxInboundUnidirectionalStreams(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_IdleTimeout();
    [CompilerGeneratedAttribute]
public void set_IdleTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public long get_DefaultStreamErrorCode();
    [CompilerGeneratedAttribute]
public void set_DefaultStreamErrorCode(long value);
    [CompilerGeneratedAttribute]
public long get_DefaultCloseErrorCode();
    [CompilerGeneratedAttribute]
public void set_DefaultCloseErrorCode(long value);
    internal virtual void Validate(string argumentName);
}
internal static class System.Net.Quic.QuicDefaults : object {
    public static TimeSpan HandshakeTimeout;
    private static QuicDefaults();
}
public enum System.Net.Quic.QuicError : Enum {
    public int value__;
    public static QuicError Success;
    public static QuicError InternalError;
    public static QuicError ConnectionAborted;
    public static QuicError StreamAborted;
    public static QuicError ConnectionTimeout;
    public static QuicError ConnectionRefused;
    public static QuicError VersionNegotiationError;
    public static QuicError ConnectionIdle;
    public static QuicError OperationAborted;
    public static QuicError AlpnInUse;
    public static QuicError TransportError;
    public static QuicError CallbackError;
}
public class System.Net.Quic.QuicException : IOException {
    [CompilerGeneratedAttribute]
private QuicError <QuicError>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ApplicationErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <TransportErrorCode>k__BackingField;
    public QuicError QuicError { get; }
    public Nullable`1<long> ApplicationErrorCode { get; }
    public Nullable`1<long> TransportErrorCode { get; }
    [NullableContextAttribute("1")]
public QuicException(QuicError error, Nullable`1<long> applicationErrorCode, string message);
    internal QuicException(QuicError error, Nullable`1<long> applicationErrorCode, Nullable`1<long> transportErrorCode, string message);
    internal QuicException(QuicError error, Nullable`1<long> applicationErrorCode, string message, Exception innerException);
    internal QuicException(QuicError error, Nullable`1<long> applicationErrorCode, Nullable`1<long> transportErrorCode, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public QuicError get_QuicError();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_ApplicationErrorCode();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_TransportErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Quic.QuicListener : object {
    private MsQuicContextSafeHandle _handle;
    private int _disposed;
    private ValueTaskSource _shutdownTcs;
    private CancellationTokenSource _disposeCts;
    private Func`4<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask`1<QuicServerConnectionOptions>> _connectionOptionsCallback;
    private Channel`1<object> _acceptQueue;
    private int _pendingConnectionsCapacity;
    [CompilerGeneratedAttribute]
private IPEndPoint <LocalEndPoint>k__BackingField;
    public static bool IsSupported { get; }
    public IPEndPoint LocalEndPoint { get; }
    private QuicListener(QuicListenerOptions options);
    public static bool get_IsSupported();
    public static ValueTask`1<QuicListener> ListenAsync(QuicListenerOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IPEndPoint get_LocalEndPoint();
    public virtual string ToString();
    [AsyncStateMachineAttribute("System.Net.Quic.QuicListener/<AcceptConnectionAsync>d__15")]
public ValueTask`1<QuicConnection> AcceptConnectionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.Quic.QuicListener/<StartConnectionHandshake>d__16")]
private void StartConnectionHandshake(QuicConnection connection, SslClientHelloInfo clientHello);
    private int HandleEventNewConnection(_NEW_CONNECTION_e__Struct& data);
    private int HandleEventStopComplete();
    private int HandleListenerEvent(QUIC_LISTENER_EVENT& listenerEvent);
    [UnmanagedCallersOnlyAttribute]
private static int NativeCallback(QUIC_HANDLE* listener, Void* context, QUIC_LISTENER_EVENT* listenerEvent);
    [AsyncStateMachineAttribute("System.Net.Quic.QuicListener/<DisposeAsync>d__21")]
public sealed virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Quic.QuicListenerOptions : object {
    [CompilerGeneratedAttribute]
private IPEndPoint <ListenEndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SslApplicationProtocol> <ApplicationProtocols>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ListenBacklog>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask`1<QuicServerConnectionOptions>> <ConnectionOptionsCallback>k__BackingField;
    public IPEndPoint ListenEndPoint { get; public set; }
    public List`1<SslApplicationProtocol> ApplicationProtocols { get; public set; }
    public int ListenBacklog { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`4<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask`1<QuicServerConnectionOptions>> ConnectionOptionsCallback { get; public set; }
    [CompilerGeneratedAttribute]
public IPEndPoint get_ListenEndPoint();
    [CompilerGeneratedAttribute]
public void set_ListenEndPoint(IPEndPoint value);
    [CompilerGeneratedAttribute]
public List`1<SslApplicationProtocol> get_ApplicationProtocols();
    [CompilerGeneratedAttribute]
public void set_ApplicationProtocols(List`1<SslApplicationProtocol> value);
    [CompilerGeneratedAttribute]
public int get_ListenBacklog();
    [CompilerGeneratedAttribute]
public void set_ListenBacklog(int value);
    [CompilerGeneratedAttribute]
public Func`4<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask`1<QuicServerConnectionOptions>> get_ConnectionOptionsCallback();
    [CompilerGeneratedAttribute]
public void set_ConnectionOptionsCallback(Func`4<QuicConnection, SslClientHelloInfo, CancellationToken, ValueTask`1<QuicServerConnectionOptions>> value);
    internal void Validate(string argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Quic.QuicServerConnectionOptions : QuicConnectionOptions {
    [CompilerGeneratedAttribute]
private SslServerAuthenticationOptions <ServerAuthenticationOptions>k__BackingField;
    public SslServerAuthenticationOptions ServerAuthenticationOptions { get; public set; }
    [CompilerGeneratedAttribute]
public SslServerAuthenticationOptions get_ServerAuthenticationOptions();
    [CompilerGeneratedAttribute]
public void set_ServerAuthenticationOptions(SslServerAuthenticationOptions value);
    internal virtual void Validate(string argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Net.Quic.QuicStream : Stream {
    private MsQuicContextSafeHandle _handle;
    private int _disposed;
    private ValueTaskSource _startedTcs;
    private ValueTaskSource _shutdownTcs;
    private ResettableValueTaskSource _receiveTcs;
    private ReceiveBuffers _receiveBuffers;
    private int _receivedNeedsEnable;
    private ResettableValueTaskSource _sendTcs;
    private MsQuicBuffers _sendBuffers;
    private object _sendBuffersLock;
    private long _defaultErrorCode;
    private bool _canRead;
    private bool _canWrite;
    private long _id;
    private QuicStreamType _type;
    private TimeSpan _readTimeout;
    private TimeSpan _writeTimeout;
    public long Id { get; }
    public QuicStreamType Type { get; }
    public Task ReadsClosed { get; }
    public Task WritesClosed { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal QuicStream(MsQuicContextSafeHandle connectionHandle, QuicStreamType type, long defaultErrorCode);
    internal QuicStream(MsQuicContextSafeHandle connectionHandle, QUIC_HANDLE* handle, QUIC_STREAM_OPEN_FLAGS flags, long defaultErrorCode);
    public long get_Id();
    public QuicStreamType get_Type();
    public Task get_ReadsClosed();
    public Task get_WritesClosed();
    public virtual string ToString();
    internal ValueTask StartAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("System.Net.Quic.QuicStream/<ReadAsync>d__27")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, bool completeWrites, CancellationToken cancellationToken);
    public void Abort(QuicAbortDirection abortDirection, long errorCode);
    public void CompleteWrites();
    private int HandleEventStartComplete(_START_COMPLETE_e__Struct& data);
    private int HandleEventReceive(_RECEIVE_e__Struct& data);
    private int HandleEventSendComplete(_SEND_COMPLETE_e__Struct& data);
    private int HandleEventPeerSendShutdown();
    private int HandleEventPeerSendAborted(_PEER_SEND_ABORTED_e__Struct& data);
    private int HandleEventPeerReceiveAborted(_PEER_RECEIVE_ABORTED_e__Struct& data);
    private int HandleEventSendShutdownComplete(_SEND_SHUTDOWN_COMPLETE_e__Struct& data);
    private int HandleEventShutdownComplete(_SHUTDOWN_COMPLETE_e__Struct& data);
    private int HandleEventPeerAccepted();
    private int HandleStreamEvent(QUIC_STREAM_EVENT& streamEvent);
    [UnmanagedCallersOnlyAttribute]
private static int NativeCallback(QUIC_HANDLE* connection, Void* context, QUIC_STREAM_EVENT* streamEvent);
    [AsyncStateMachineAttribute("System.Net.Quic.QuicStream/<DisposeAsync>d__43")]
public virtual ValueTask DisposeAsync();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual bool get_CanRead();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanWrite();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <DisposeAsync>g__StreamShutdown|43_0(QUIC_STREAM_SHUTDOWN_FLAGS flags, long errorCode);
}
public enum System.Net.Quic.QuicStreamType : Enum {
    public int value__;
    public static QuicStreamType Unidirectional;
    public static QuicStreamType Bidirectional;
}
internal class System.Net.Quic.ReceiveBuffers : ValueType {
    private object _syncRoot;
    private MultiArrayBuffer _buffer;
    private bool _final;
    public void SetFinal();
    public bool HasCapacity();
    public int CopyFrom(ReadOnlySpan`1<QUIC_BUFFER> quicBuffers, int totalLength, bool final);
    public int CopyTo(Memory`1<byte> buffer, Boolean& isCompleted, Boolean& isEmpty);
}
internal class System.Net.Quic.ResettableValueTaskSource : object {
    private State _state;
    private ManualResetValueTaskSourceCore`1<bool> _valueTaskSource;
    private CancellationTokenRegistration _cancellationRegistration;
    private Action`1<object> _cancellationAction;
    private GCHandle _keepAlive;
    private TaskCompletionSource _finalTaskSource;
    unknown Action`1<object> CancellationAction {public set; }
    public bool IsCompleted { get; }
    public ResettableValueTaskSource(bool runContinuationsAsynchronously);
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CancellationAction(Action`1<object> value);
    public bool get_IsCompleted();
    public bool TryGetValueTask(ValueTask& valueTask, object keepAlive, CancellationToken cancellationToken);
    public Task GetFinalTask();
    private bool TryComplete(Exception exception, bool final);
    public bool TrySetResult(bool final);
    public bool TrySetException(Exception exception, bool final);
    private sealed virtual override ValueTaskSourceStatus System.Threading.Tasks.Sources.IValueTaskSource.GetStatus(short token);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.GetResult(short token);
}
internal enum System.Net.Quic.SafeHandleType : Enum {
    public int value__;
    public static SafeHandleType Registration;
    public static SafeHandleType Configuration;
    public static SafeHandleType Listener;
    public static SafeHandleType Connection;
    public static SafeHandleType Stream;
}
internal static class System.Net.Quic.ThrowHelper : object {
    internal static QuicException GetConnectionAbortedException(long errorCode);
    internal static QuicException GetStreamAbortedException(long errorCode);
    internal static QuicException GetOperationAbortedException(string message);
    internal static bool TryGetStreamExceptionForMsQuicStatus(int status, Exception& exception, bool streamWasSuccessfullyStarted, string message);
    internal static bool IsConnectionAbortedWhenStartingStreamException(Exception ex);
    internal static Exception GetExceptionForMsQuicStatus(int status, Nullable`1<long> errorCode, string message);
    internal static void ThrowIfMsQuicError(int status, string message);
    internal static void ThrowMsQuicException(int status, string message);
    internal static string GetErrorMessageForStatus(int status, string message);
    internal static string GetErrorMessageForStatus(int status);
    [CompilerGeneratedAttribute]
internal static Exception <GetExceptionForMsQuicStatus>g__GetExceptionInternal|5_0(int status, Nullable`1<long> errorCode, string message);
}
internal class System.Net.Quic.ValueTaskSource : object {
    private State _state;
    private ManualResetValueTaskSourceCore`1<bool> _valueTaskSource;
    private CancellationTokenRegistration _cancellationRegistration;
    private GCHandle _keepAlive;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public ValueTaskSource(bool runContinuationsAsynchronously);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool TryInitialize(ValueTask& valueTask, object keepAlive, CancellationToken cancellationToken);
    private bool TryComplete(Exception exception);
    public bool TrySetResult();
    public bool TrySetException(Exception exception);
    private sealed virtual override ValueTaskSourceStatus System.Threading.Tasks.Sources.IValueTaskSource.GetStatus(short token);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private sealed virtual override void System.Threading.Tasks.Sources.IValueTaskSource.GetResult(short token);
}
internal static class System.Net.Security.CertificateValidation : object {
    private static IdnMapping s_idnMapping;
    private static CertificateValidation();
    internal static SslPolicyErrors BuildChainAndVerifyProperties(X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool isServer, string hostName, IntPtr certificateBuffer, int bufferLength);
    internal static SslPolicyErrors BuildChainAndVerifyProperties(X509Chain chain, X509Certificate2 remoteCertificate, bool checkCertName, bool _, string hostName);
}
internal static class System.Net.Security.TargetHostNameHelper : object {
    private static IdnMapping s_idnMapping;
    private static SearchValues`1<char> s_safeDnsChars;
    private static TargetHostNameHelper();
    private static bool IsSafeDnsString(ReadOnlySpan`1<char> name);
    internal static string NormalizeHostName(string targetHost);
    internal static bool IsValidAddress(string hostname);
}
internal enum System.Net.Security.TlsAlertMessage : Enum {
    public int value__;
    public static TlsAlertMessage CloseNotify;
    public static TlsAlertMessage UnexpectedMessage;
    public static TlsAlertMessage BadRecordMac;
    public static TlsAlertMessage DecryptionFailed;
    public static TlsAlertMessage RecordOverflow;
    public static TlsAlertMessage DecompressionFail;
    public static TlsAlertMessage HandshakeFailure;
    public static TlsAlertMessage BadCertificate;
    public static TlsAlertMessage UnsupportedCert;
    public static TlsAlertMessage CertificateRevoked;
    public static TlsAlertMessage CertificateExpired;
    public static TlsAlertMessage CertificateUnknown;
    public static TlsAlertMessage IllegalParameter;
    public static TlsAlertMessage UnknownCA;
    public static TlsAlertMessage AccessDenied;
    public static TlsAlertMessage DecodeError;
    public static TlsAlertMessage DecryptError;
    public static TlsAlertMessage ExportRestriction;
    public static TlsAlertMessage ProtocolVersion;
    public static TlsAlertMessage InsuffientSecurity;
    public static TlsAlertMessage InternalError;
    public static TlsAlertMessage UserCanceled;
    public static TlsAlertMessage NoRenegotiation;
    public static TlsAlertMessage UnsupportedExt;
}
internal static class System.Net.SocketAddressPal : object {
    public static int IPv4AddressSize;
    public static int IPv6AddressSize;
    public static int UdsAddressSize;
    public static int MaxAddressSize;
    private static SocketAddressPal();
    private static void ThrowOnFailure(Error err);
    public static AddressFamily GetAddressFamily(ReadOnlySpan`1<byte> buffer);
    public static void SetAddressFamily(Span`1<byte> buffer, AddressFamily family);
    public static ushort GetPort(ReadOnlySpan`1<byte> buffer);
    public static void SetPort(Span`1<byte> buffer, ushort port);
    public static UInt32 GetIPv4Address(ReadOnlySpan`1<byte> buffer);
    public static void GetIPv6Address(ReadOnlySpan`1<byte> buffer, Span`1<byte> address, UInt32& scope);
    public static void SetIPv4Address(Span`1<byte> buffer, UInt32 address);
    public static void SetIPv6Address(Span`1<byte> buffer, Span`1<byte> address, UInt32 scope);
    public static void SetIPv6Address(Span`1<byte> buffer, Byte* address, int addressLength, UInt32 scope);
}
[ExtensionAttribute]
internal static class System.Net.Sockets.IPEndPointExtensions : object {
    public static IPAddress GetIPAddress(ReadOnlySpan`1<byte> socketAddressBuffer);
    public static void SetIPAddress(Span`1<byte> socketAddressBuffer, IPAddress address);
    public static IPEndPoint CreateIPEndPoint(ReadOnlySpan`1<byte> socketAddressBuffer);
    [ExtensionAttribute]
public static void Serialize(IPEndPoint endPoint, Span`1<byte> destination);
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_quic_connectionaborted { get; }
    internal static string net_quic_operationaborted { get; }
    internal static string net_quic_reading_notallowed { get; }
    internal static string net_quic_writing_aborted { get; }
    internal static string net_quic_reading_aborted { get; }
    internal static string net_quic_streamaborted { get; }
    internal static string SystemNetQuic_PlatformNotSupported { get; }
    internal static string net_quic_writing_notallowed { get; }
    internal static string net_quic_in_range { get; }
    internal static string net_quic_not_null_listener { get; }
    internal static string net_quic_not_null_not_empty_listener { get; }
    internal static string net_quic_not_null_open_connection { get; }
    internal static string net_quic_not_null_accept_connection { get; }
    internal static string net_quic_timeout_use_gt_zero { get; }
    internal static string net_quic_unsupported_endpoint_type { get; }
    internal static string net_quic_not_null_not_empty_connection { get; }
    internal static string net_quic_not_null_ceritifcate { get; }
    internal static string net_quic_timeout { get; }
    internal static string net_quic_handshake_timeout { get; }
    internal static string net_quic_ssl_option { get; }
    internal static string net_quic_cert_custom_validation { get; }
    internal static string net_quic_cert_chain_validation { get; }
    internal static string net_quic_internal_error { get; }
    internal static string net_quic_empty_cipher_suite { get; }
    internal static string net_quic_accept_not_allowed { get; }
    internal static string net_quic_connection_refused { get; }
    internal static string net_quic_protocol_error { get; }
    internal static string net_quic_ver_neg_error { get; }
    internal static string net_quic_alpn_neg_error { get; }
    internal static string net_quic_connection_idle { get; }
    internal static string net_quic_auth { get; }
    internal static string net_io_invalidnestedcall { get; }
    internal static string net_auth_tls_alert { get; }
    internal static string net_quic_callback_error { get; }
    private static SR();
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_quic_connectionaborted();
    internal static string get_net_quic_operationaborted();
    internal static string get_net_quic_reading_notallowed();
    internal static string get_net_quic_writing_aborted();
    internal static string get_net_quic_reading_aborted();
    internal static string get_net_quic_streamaborted();
    internal static string get_SystemNetQuic_PlatformNotSupported();
    internal static string get_net_quic_writing_notallowed();
    internal static string get_net_quic_in_range();
    internal static string get_net_quic_not_null_listener();
    internal static string get_net_quic_not_null_not_empty_listener();
    internal static string get_net_quic_not_null_open_connection();
    internal static string get_net_quic_not_null_accept_connection();
    internal static string get_net_quic_timeout_use_gt_zero();
    internal static string get_net_quic_unsupported_endpoint_type();
    internal static string get_net_quic_not_null_not_empty_connection();
    internal static string get_net_quic_not_null_ceritifcate();
    internal static string get_net_quic_timeout();
    internal static string get_net_quic_handshake_timeout();
    internal static string get_net_quic_ssl_option();
    internal static string get_net_quic_cert_custom_validation();
    internal static string get_net_quic_cert_chain_validation();
    internal static string get_net_quic_internal_error();
    internal static string get_net_quic_empty_cipher_suite();
    internal static string get_net_quic_accept_not_allowed();
    internal static string get_net_quic_connection_refused();
    internal static string get_net_quic_protocol_error();
    internal static string get_net_quic_ver_neg_error();
    internal static string get_net_quic_alpn_neg_error();
    internal static string get_net_quic_connection_idle();
    internal static string get_net_quic_auth();
    internal static string get_net_io_invalidnestedcall();
    internal static string get_net_auth_tls_alert();
    internal static string get_net_quic_callback_error();
}
