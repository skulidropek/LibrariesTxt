public static class Internal.Console : object {
    [NullableContextAttribute("2")]
public static void WriteLine(string s);
    public static void WriteLine();
    [NullableContextAttribute("1")]
public static void Write(string s);
}
internal class Internal.PaddedReference : ValueType {
    public object Object;
}
[IsReadOnlyAttribute]
internal class Internal.PaddingFor32 : ValueType {
}
internal static class Internal.Runtime.InteropServices.ComponentActivator : object {
    [UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("maccatalyst")]
[UnsupportedOSPlatformAttribute("tvos")]
private static Dictionary`2<string, IsolatedComponentLoadContext> s_assemblyLoadContexts;
    private static Dictionary`2<IntPtr, Delegate> s_delegates;
    private static HashSet`1<string> s_loadedInDefaultContext;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    private static bool IsSupported { get; }
    private static ComponentActivator();
    [CompilerGeneratedAttribute]
private static bool get_IsSupported();
    private static bool InitializeIsSupported();
    private static string MarshalToString(IntPtr arg, string argName);
    [RequiresDynamicCodeAttribute("The native code for the method requested might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("Native hosting is not trim compatible and this warning will be seen if trimming is enabled.")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("maccatalyst")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnmanagedCallersOnlyAttribute]
public static int LoadAssemblyAndGetFunctionPointer(IntPtr assemblyPathNative, IntPtr typeNameNative, IntPtr methodNameNative, IntPtr delegateTypeNative, IntPtr reserved, IntPtr functionHandle);
    [RequiresDynamicCodeAttribute("The native code for the method requested might not be available at runtime.")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("maccatalyst")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnmanagedCallersOnlyAttribute]
public static int LoadAssembly(IntPtr assemblyPathNative, IntPtr loadContext, IntPtr reserved);
    [RequiresUnreferencedCodeAttribute("Native hosting is not trim compatible and this warning will be seen if trimming is enabled.")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("maccatalyst")]
[UnsupportedOSPlatformAttribute("tvos")]
private static void LoadAssemblyImpl(string assemblyPath);
    [RequiresDynamicCodeAttribute("The native code for the method requested might not be available at runtime.")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("maccatalyst")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnmanagedCallersOnlyAttribute]
public static int LoadAssemblyBytes(Byte* assembly, IntPtr assemblyByteLength, Byte* symbols, IntPtr symbolsByteLength, IntPtr loadContext, IntPtr reserved);
    [RequiresDynamicCodeAttribute("The native code for the method requested might not be available at runtime.")]
[UnmanagedCallersOnlyAttribute]
public static int GetFunctionPointer(IntPtr typeNameNative, IntPtr methodNameNative, IntPtr delegateTypeNative, IntPtr loadContext, IntPtr reserved, IntPtr functionHandle);
    [RequiresUnreferencedCodeAttribute("Native hosting is not trim compatible and this warning will be seen if trimming is enabled.")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
private static IsolatedComponentLoadContext GetIsolatedComponentLoadContext(string assemblyPath);
    [RequiresDynamicCodeAttribute("The native code for the method requested might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("Native hosting is not trim compatible and this warning will be seen if trimming is enabled.")]
private static IntPtr InternalGetFunctionPointer(AssemblyLoadContext alc, string typeName, string methodName, IntPtr delegateTypeNative);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal static void <LoadAssembly>g__LoadAssemblyLocal|13_0(string assemblyPath);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal static void <LoadAssemblyBytes>g__LoadAssemblyBytesLocal|15_0(ReadOnlySpan`1<byte> assemblyBytes, ReadOnlySpan`1<byte> symbolsBytes);
}
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("maccatalyst")]
[UnsupportedOSPlatformAttribute("tvos")]
internal class Internal.Runtime.InteropServices.IsolatedComponentLoadContext : AssemblyLoadContext {
    private AssemblyDependencyResolver _resolver;
    [RequiresUnreferencedCodeAttribute("The trimmer might remove assemblies that are loaded by this class")]
public IsolatedComponentLoadContext(string componentAssemblyPath);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
protected virtual Assembly Load(AssemblyName assemblyName);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
}
internal static class Interop : object {
    internal static bool CallStringMethod(SpanFunc`5<char, TArg1, TArg2, TArg3, ResultCode> interopCall, TArg1 arg1, TArg2 arg2, TArg3 arg3, String& result);
    private static void ThrowExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirError);
    internal static void CheckIo(Error error, string path, bool isDirError);
    internal static long CheckIo(long result, string path, bool isDirError);
    internal static void ThrowIOExceptionForLastError();
    internal static int CheckIo(int result, string path, bool isDirError);
    internal static IntPtr CheckIo(IntPtr result, string path, bool isDirError);
    internal static Exception GetExceptionForIoErrno(ErrorInfo errorInfo, string path, bool isDirError);
    internal static Exception GetIOException(ErrorInfo errorInfo, string path);
    internal static void GetRandomBytes(Byte* buffer, int length);
    internal static void GetCryptographicallySecureRandomBytes(Byte* buffer, int length);
    [CompilerGeneratedAttribute]
internal static bool <GetExceptionForIoErrno>g__ParentDirectoryExists|17_0(string fullPath);
}
[ExtensionAttribute]
internal static class InteropErrorExtensions : object {
    [ExtensionAttribute]
public static ErrorInfo Info(Error error);
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private string _path;
    private ThreadPoolValueTaskSource _reusableThreadPoolValueTaskSource;
    [CompilerGeneratedAttribute]
private static bool <DisableFileLocking>k__BackingField;
    private NullableBool modreq(System.Runtime.CompilerServices.IsVolatile) _canSeek;
    private NullableBool modreq(System.Runtime.CompilerServices.IsVolatile) _supportsRandomAccess;
    private bool _deleteOnClose;
    private bool _isLocked;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    [ThreadStaticAttribute]
internal static Nullable`1<ErrorInfo> t_lastCloseErrorInfo;
    internal string Path { get; }
    internal static bool DisableFileLocking { get; }
    public bool IsAsync { get; private set; }
    internal bool CanSeek { get; }
    internal bool SupportsRandomAccess { get; internal set; }
    internal ThreadPoolBoundHandle ThreadPoolBinding { get; }
    public bool IsInvalid { get; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    private SafeFileHandle(bool ownsHandle);
    private static SafeFileHandle();
    internal string get_Path();
    internal ThreadPoolValueTaskSource GetThreadPoolValueTaskSource();
    [CompilerGeneratedAttribute]
internal static bool get_DisableFileLocking();
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
    [CompilerGeneratedAttribute]
private void set_IsAsync(bool value);
    internal bool get_CanSeek();
    internal bool get_SupportsRandomAccess();
    internal void set_SupportsRandomAccess(bool value);
    internal ThreadPoolBoundHandle get_ThreadPoolBinding();
    internal void EnsureThreadPoolBindingInitialized();
    internal bool TryGetCachedLength(Int64& cachedLength);
    private static SafeFileHandle Open(string path, OpenFlags flags, int mode, bool failForSymlink, Boolean& wasSymlink, Func`4<ErrorInfo, OpenFlags, string, Exception> createOpenException);
    protected virtual bool ReleaseHandle();
    public virtual bool get_IsInvalid();
    internal static SafeFileHandle OpenReadOnly(string fullPath, FileOptions options, Int64& fileLength, UnixFileMode& filePermissions);
    internal static SafeFileHandle Open(string fullPath, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize, Nullable`1<UnixFileMode> unixCreateMode, Func`4<ErrorInfo, OpenFlags, string, Exception> createOpenException);
    private static SafeFileHandle Open(string fullPath, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize, UnixFileMode openPermissions, Int64& fileLength, UnixFileMode& filePermissions, bool failForSymlink, Boolean& wasSymlink, Func`4<ErrorInfo, OpenFlags, string, Exception> createOpenException);
    private static OpenFlags PreOpenConfigurationFromOptions(FileMode mode, FileAccess access, FileShare share, FileOptions options, bool failForSymlink);
    private bool Init(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize, Int64& fileLength, UnixFileMode& filePermissions);
    private bool CanLockTheFile(LockOperations lockOperation, FileAccess access);
    private void FStatCheckIO(string path, FileStatus& status, Boolean& statusHasValue);
    private bool GetCanSeek();
    internal long GetFileLength();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
internal class Mono.HotReload.FieldStore : object {
    private object _loc;
    private FieldStore(object loc);
    [RequiresUnreferencedCodeAttribute("Hot reload required untrimmed apps")]
public static FieldStore Create(RuntimeTypeHandle type);
}
internal class Mono.HotReload.InstanceFieldTable : object {
    private static InstanceFieldTable _singleton;
    private ConditionalWeakTable`2<object, InstanceFields> _table;
    private static InstanceFieldTable();
    internal static FieldStore GetInstanceFieldFieldStore(object inst, IntPtr type, UInt32 fielddef_token);
    private InstanceFields GetOrCreateInstanceFields(object key);
}
internal enum Mono.I16Enum : Enum {
    public short value__;
}
internal enum Mono.I32Enum : Enum {
    public int value__;
}
internal enum Mono.I64Enum : Enum {
    public long value__;
}
internal enum Mono.I8Enum : Enum {
    public byte value__;
}
internal class Mono.MonoAssemblyName : ValueType {
    internal IntPtr name;
    internal IntPtr culture;
    internal IntPtr hash_value;
    internal IntPtr public_key;
    [FixedBufferAttribute("System.Byte", "17")]
internal <public_key_token>e__FixedBuffer public_key_token;
    internal UInt32 hash_alg;
    internal UInt32 hash_len;
    internal UInt32 flags;
    internal int major;
    internal int minor;
    internal int build;
    internal int revision;
    internal int arch;
}
internal class Mono.RuntimeClassHandle : ValueType {
    private MonoClass* value;
    internal MonoClass* Value { get; }
    internal RuntimeClassHandle(MonoClass* value);
    internal MonoClass* get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(RuntimeClassHandle handle);
    internal static IntPtr GetTypeFromClass(MonoClass* klass);
    internal RuntimeTypeHandle GetTypeHandle();
}
internal class Mono.RuntimeEventHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeEventHandle(IntPtr v);
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeEventHandle handle);
    public virtual int GetHashCode();
}
internal class Mono.RuntimeGenericParamInfoHandle : ValueType {
    private GenericParamInfo* value;
    internal Type[] Constraints { get; }
    internal GenericParameterAttributes Attributes { get; }
    internal RuntimeGenericParamInfoHandle(IntPtr ptr);
    internal Type[] get_Constraints();
    internal GenericParameterAttributes get_Attributes();
    private Type[] GetConstraints();
    private int GetConstraintsCount();
}
[DefaultMemberAttribute("Item")]
internal class Mono.RuntimeGPtrArrayHandle : ValueType {
    private GPtrArray* value;
    internal int Length { get; }
    internal IntPtr Item { get; }
    internal RuntimeGPtrArrayHandle(IntPtr ptr);
    internal int get_Length();
    internal IntPtr get_Item(int i);
    internal IntPtr Lookup(int i);
    private static void GPtrArrayFree(GPtrArray* value);
    internal static void DestroyAndFree(RuntimeGPtrArrayHandle& h);
}
internal class Mono.RuntimePropertyHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimePropertyHandle(IntPtr v);
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimePropertyHandle handle);
    public virtual int GetHashCode();
}
internal static class Mono.RuntimeStructs : object {
}
[DefaultMemberAttribute("Item")]
internal class Mono.SafeGPtrArrayHandle : ValueType {
    private RuntimeGPtrArrayHandle handle;
    internal int Length { get; }
    internal IntPtr Item { get; }
    internal SafeGPtrArrayHandle(IntPtr ptr);
    public sealed virtual void Dispose();
    internal int get_Length();
    internal IntPtr get_Item(int i);
}
internal class Mono.SafeStringMarshal : ValueType {
    private string str;
    private IntPtr marshaled_string;
    public IntPtr Value { get; }
    public SafeStringMarshal(string str);
    private static IntPtr StringToUtf8_icall(String& str);
    public static IntPtr StringToUtf8(string str);
    public static void GFree(IntPtr ptr);
    public IntPtr get_Value();
    public sealed virtual void Dispose();
}
internal enum Mono.UI16Enum : Enum {
    public ushort value__;
}
internal enum Mono.UI32Enum : Enum {
    public UInt32 value__;
}
internal enum Mono.UI64Enum : Enum {
    public ulong value__;
}
internal enum Mono.UI8Enum : Enum {
    public sbyte value__;
}
internal class Mono.ValueTuple : ValueType {
}
internal class Mono.ValueTuple`1 : ValueType {
    public T1 Item1;
}
internal class Mono.ValueTuple`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
}
internal class Mono.ValueTuple`3 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
}
internal class Mono.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
}
internal class Mono.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
}
internal class Mono.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
}
internal class Mono.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.__DTString : ValueType {
    internal ReadOnlySpan`1<char> Value;
    internal int Index;
    internal char m_current;
    private CompareInfo m_info;
    private bool m_checkDigitToken;
    internal int Length { get; }
    internal CompareInfo CompareInfo { get; }
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi, bool checkDigitToken);
    internal __DTString(ReadOnlySpan`1<char> str, DateTimeFormatInfo dtfi);
    internal int get_Length();
    internal CompareInfo get_CompareInfo();
    internal bool GetNext();
    internal bool AtEnd();
    internal bool Advance(int count);
    internal void GetRegularToken(TokenType& tokenType, Int32& tokenValue, DateTimeFormatInfo dtfi);
    internal TokenType GetSeparatorToken(DateTimeFormatInfo dtfi, Int32& indexBeforeSeparator, Char& charBeforeSeparator);
    internal bool MatchSpecifiedWord(string target);
    internal bool MatchSpecifiedWords(string target, bool checkWordBoundary, Int32& matchLength);
    internal bool Match(string str);
    internal bool Match(char ch);
    private static bool IsSpaceReplacingChar(char c);
    internal int MatchLongestWords(String[] words, Int32& maxMatchStrLen);
    internal int GetRepeatCount();
    internal bool GetNextDigit();
    internal char GetChar();
    internal int GetDigit();
    internal void SkipWhiteSpaces();
    internal bool SkipWhiteSpaceAndRtlMarkCurrent();
    internal void TrimTail();
    internal void RemoveTrailingInQuoteSpaces();
    internal void RemoveLeadingInQuoteSpaces();
    internal DTSubString GetSubString();
    internal void ConsumeSubString(DTSubString sub);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AccessViolationException : SystemException {
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected AccessViolationException(SerializationInfo info, StreamingContext context);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`10 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`10(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`11 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`11(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`12 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`12(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`13 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`13(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`14 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`14(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`15 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`15(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`16 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`16(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`4 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`6 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`6(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`7 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`7(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`8 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`8(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`9 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`9(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Activator : object {
    [NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, Object[] args);
    [NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public static object CreateInstance(Type type);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public static object CreateInstance(Type type, bool nonPublic);
    internal static object CreateInstance(Type type, bool nonPublic, bool wrapExceptions);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2072:UnrecognizedReflectionPattern")]
private static ObjectHandle CreateInstanceInternal(string assemblyString, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark);
    [IntrinsicAttribute]
public static T CreateInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {InnerExceptionCount}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AggregateException : Exception {
    private Exception[] _innerExceptions;
    private ReadOnlyCollection`1<Exception> _rocView;
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    internal int InnerExceptionCount { get; }
    internal Exception[] InternalInnerExceptions { get; }
    [NullableContextAttribute("2")]
public AggregateException(string message);
    public AggregateException(string message, Exception innerException);
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception[] innerExceptions);
    private AggregateException(string message, Exception[] innerExceptions, bool cloneExceptions);
    internal AggregateException(List`1<ExceptionDispatchInfo> innerExceptionInfos);
    internal AggregateException(string message, List`1<ExceptionDispatchInfo> innerExceptionInfos);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected AggregateException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Exception GetBaseException();
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public void Handle(Func`2<Exception, bool> predicate);
    public AggregateException Flatten();
    public virtual string get_Message();
    public virtual string ToString();
    internal int get_InnerExceptionCount();
    internal Exception[] get_InternalInnerExceptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.AppContext : object {
    private static Dictionary`2<string, object> s_dataStore;
    private static Dictionary`2<string, bool> s_switches;
    private static string s_defaultBaseDirectory;
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("3", "System.UnhandledExceptionEventArgs")]
private static UnhandledExceptionEventHandler UnhandledException;
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("3", "System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs")]
private static EventHandler`1<FirstChanceExceptionEventArgs> FirstChanceException;
    [CompilerGeneratedAttribute]
private static EventHandler ProcessExit;
    public static string BaseDirectory { get; }
    [NullableAttribute("2")]
public static string TargetFrameworkName { get; }
    public static string get_BaseDirectory();
    [NullableContextAttribute("2")]
public static string get_TargetFrameworkName();
    public static object GetData(string name);
    public static void SetData(string name, object data);
    [CompilerGeneratedAttribute]
internal static void add_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
internal static void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void add_ProcessExit(EventHandler value);
    [CompilerGeneratedAttribute]
internal static void remove_ProcessExit(EventHandler value);
    internal static void OnProcessExit();
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
    public static void SetSwitch(string switchName, bool isEnabled);
    internal static void Setup(Char** pNames, Char** pValues, int count);
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3000: Avoid accessing Assembly file path when publishing as a single file")]
private static string GetBaseDirectoryCore();
    internal static void LogSwitchValues(RuntimeEventSource ev);
    [CompilerGeneratedAttribute]
internal static void <LogSwitchValues>g__LogDataStore|23_0(RuntimeEventSource ev, Dictionary`2<string, bool> switches);
}
internal static class System.AppContextConfigHelper : object {
    internal static bool GetBooleanConfig(string configName, bool defaultValue);
    internal static bool GetBooleanConfig(string switchName, string envVariable, bool defaultValue);
    internal static int GetInt32Config(string configName, int defaultValue, bool allowNegative);
    internal static int GetInt32Config(string configName, string envVariable, int defaultValue, bool allowNegative);
    internal static short GetInt16Config(string configName, short defaultValue, bool allowNegative);
    internal static short GetInt16Config(string configName, string envVariable, short defaultValue, bool allowNegative);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AppDomain : MarshalByRefObject {
    private static AppDomain s_domain;
    private IPrincipal _defaultPrincipal;
    private PrincipalPolicy _principalPolicy;
    private Func`1<IPrincipal> s_getWindowsPrincipal;
    private Func`1<IPrincipal> s_getUnauthenticatedPrincipal;
    [CompilerGeneratedAttribute]
private EventHandler DomainUnload;
    [CompilerGeneratedAttribute]
private ResolveEventHandler ReflectionOnlyAssemblyResolve;
    public static AppDomain CurrentDomain { get; }
    public string BaseDirectory { get; }
    [NullableAttribute("2")]
public string RelativeSearchPath { get; }
    public AppDomainSetup SetupInformation { get; }
    [ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public PermissionSet PermissionSet { get; }
    [NullableAttribute("2")]
public string DynamicDirectory { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public bool ShadowCopyFiles { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    private static AppDomain();
    public static AppDomain get_CurrentDomain();
    public string get_BaseDirectory();
    [NullableContextAttribute("2")]
public string get_RelativeSearchPath();
    public AppDomainSetup get_SetupInformation();
    public PermissionSet get_PermissionSet();
    [NullableContextAttribute("2")]
public void add_UnhandledException(UnhandledExceptionEventHandler value);
    [NullableContextAttribute("2")]
public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [NullableContextAttribute("2")]
public string get_DynamicDirectory();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated and is not supported.")]
public void SetDynamicBase(string path);
    public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_DomainUnload(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [NullableContextAttribute("2")]
public void add_ProcessExit(EventHandler value);
    [NullableContextAttribute("2")]
public void remove_ProcessExit(EventHandler value);
    public string ApplyPolicy(string assemblyName);
    [ObsoleteAttribute("Creating and unloading AppDomains is not supported and throws an exception.")]
public static AppDomain CreateDomain(string friendlyName);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public int ExecuteAssembly(string assemblyFile);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public int ExecuteAssembly(string assemblyFile, String[] args);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    private static int ExecuteAssembly(Assembly assembly, String[] args);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public int ExecuteAssemblyByName(string assemblyName);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public object GetData(string name);
    public void SetData(string name, object data);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    public virtual string ToString();
    [ObsoleteAttribute("Creating and unloading AppDomains is not supported and throws an exception.")]
public static void Unload(AppDomain domain);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly Load(Byte[] rawAssembly);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public Assembly Load(AssemblyName assemblyRef);
    public Assembly Load(string assemblyString);
    public Assembly[] ReflectionOnlyGetAssemblies();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread instead.")]
public static int GetCurrentThreadId();
    public bool get_ShadowCopyFiles();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated and is not supported.")]
public void AppendPrivatePath(string path);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated and is not supported.")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated and is not supported.")]
public void ClearShadowCopyPath();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.SetCachePath has been deprecated and is not supported.")]
public void SetCachePath(string path);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated and is not supported.")]
public void SetShadowCopyFiles();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated and is not supported.")]
public void SetShadowCopyPath(string path);
    public Assembly[] GetAssemblies();
    [NullableContextAttribute("2")]
public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [NullableContextAttribute("2")]
public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [NullableContextAttribute("2")]
public void add_AssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_AssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void add_TypeResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_TypeResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void add_ResourceResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_ResourceResolve(ResolveEventHandler value);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    public void SetThreadPrincipal(IPrincipal principal);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstance(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, Object[] activationAttributes);
    internal IPrincipal GetThreadPrincipal();
    public TimeSpan get_MonitoringTotalProcessorTime();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.AppDomainSetup : object {
    public string ApplicationBase { get; }
    public string TargetFrameworkName { get; }
    public string get_ApplicationBase();
    public string get_TargetFrameworkName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.AppDomainUnloadedException : SystemException {
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ApplicationException : Exception {
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ApplicationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ApplicationId : object {
    private Byte[] _publicKeyToken;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [NullableAttribute("2")]
public string Culture { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string ProcessorArchitecture { get; }
    public Version Version { get; }
    public Byte[] PublicKeyToken { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
public Version get_Version();
    public Byte[] get_PublicKeyToken();
    public ApplicationId Copy();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
public class System.ArgIterator : ValueType {
    private IntPtr sig;
    private IntPtr args;
    private int next_arg;
    private int num_args;
    public ArgIterator(RuntimeArgumentHandle arglist);
    [CLSCompliantAttribute("False")]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    private void Setup(IntPtr argsp, IntPtr start);
    public void End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    private void IntGetNextArg(Void* res);
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    private void IntGetNextArgWithType(Void* res, IntPtr rth);
    public RuntimeTypeHandle GetNextArgType();
    private IntPtr IntGetNextArgType();
    public int GetRemainingCount();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentException : SystemException {
    private string _paramName;
    [NullableAttribute("1")]
public string Message { get; }
    public string ParamName { get; }
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName, Exception innerException);
    public ArgumentException(string message, string paramName);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ArgumentException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    private void SetMessageField();
    public virtual string get_ParamName();
    public static void ThrowIfNullOrEmpty(string argument, string paramName);
    public static void ThrowIfNullOrWhiteSpace(string argument, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowNullOrEmptyException(string argument, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowNullOrWhiteSpaceException(string argument, string paramName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentNullException : ArgumentException {
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ArgumentNullException(SerializationInfo info, StreamingContext context);
    public static void ThrowIfNull(object argument, string paramName);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void ThrowIfNull(Void* argument, string paramName);
    internal static void ThrowIfNull(IntPtr argument, string paramName);
    [DoesNotReturnAttribute]
internal static void Throw(string paramName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArgumentOutOfRangeException : ArgumentException {
    private object _actualValue;
    public string Message { get; }
    [NullableAttribute("2")]
public object ActualValue { get; }
    [NullableContextAttribute("2")]
public ArgumentOutOfRangeException(string paramName);
    [NullableContextAttribute("2")]
public ArgumentOutOfRangeException(string paramName, string message);
    [NullableContextAttribute("2")]
public ArgumentOutOfRangeException(string message, Exception innerException);
    [NullableContextAttribute("2")]
public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    [NullableContextAttribute("2")]
public virtual object get_ActualValue();
    [DoesNotReturnAttribute]
private static void ThrowZero(T value, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowNegative(T value, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowNegativeOrZero(T value, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowGreater(T value, T other, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowGreaterEqual(T value, T other, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowLess(T value, T other, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowLessEqual(T value, T other, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowEqual(T value, T other, string paramName);
    [DoesNotReturnAttribute]
private static void ThrowNotEqual(T value, T other, string paramName);
    public static void ThrowIfZero(T value, string paramName);
    public static void ThrowIfNegative(T value, string paramName);
    public static void ThrowIfNegativeOrZero(T value, string paramName);
    public static void ThrowIfEqual(T value, T other, string paramName);
    public static void ThrowIfNotEqual(T value, T other, string paramName);
    public static void ThrowIfGreaterThan(T value, T other, string paramName);
    public static void ThrowIfGreaterThanOrEqual(T value, T other, string paramName);
    public static void ThrowIfLessThan(T value, T other, string paramName);
    public static void ThrowIfLessThanOrEqual(T value, T other, string paramName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArithmeticException : SystemException {
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ArithmeticException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Array : object {
    public int Length { get; }
    internal UIntPtr NativeLength { get; }
    public long LongLength { get; }
    public int Rank { get; }
    private int System.Collections.ICollection.Count { get; }
    public object SyncRoot { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public static int MaxLength { get; }
    [IntrinsicAttribute]
public int get_Length();
    internal UIntPtr get_NativeLength();
    public long get_LongLength();
    [IntrinsicAttribute]
public int get_Rank();
    public static void Clear(Array array);
    public static void Clear(Array array, int index, int length);
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    private static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    private static void CopySlow(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length, bool reliable);
    private static ArrayTypeMismatchException CreateArrayTypeMismatchException();
    private static bool CanAssignArrayElement(Type source, Type target);
    private static Array InternalCreate(RuntimeType elementType, int rank, Int32* lengths, Int32* lowerBounds);
    private static void InternalCreate(Array& result, IntPtr elementType, int rank, Int32* lengths, Int32* lowerBounds);
    private IntPtr GetFlattenedIndex(int rawIndex);
    private IntPtr GetFlattenedIndex(ReadOnlySpan`1<int> indices);
    internal object InternalGetValue(IntPtr index);
    internal void InternalSetValue(object value, IntPtr index);
    public void Initialize();
    public int GetUpperBound(int dimension);
    internal CorElementType GetCorElementTypeOfElementType();
    private bool IsValueOfElementType(object value);
    [IntrinsicAttribute]
public int GetLength(int dimension);
    [IntrinsicAttribute]
public int GetLowerBound(int dimension);
    [IntrinsicAttribute]
internal int GetElementSize();
    private static CorElementType GetCorElementTypeOfElementTypeInternal(ObjectHandleOnStack arr);
    private static bool IsValueOfElementTypeInternal(ObjectHandleOnStack arr, ObjectHandleOnStack obj);
    private static bool CanChangePrimitive(ObjectHandleOnStack srcType, ObjectHandleOnStack dstType, bool reliable);
    internal static bool FastCopy(ObjectHandleOnStack source, int source_idx, ObjectHandleOnStack dest, int dest_idx, int length);
    private static int GetLengthInternal(ObjectHandleOnStack arr, int dimension);
    private static int GetLowerBoundInternal(ObjectHandleOnStack arr, int dimension);
    private static void GetGenericValue_icall(ObjectHandleOnStack self, int pos, T& value);
    private static void GetValueImpl(ObjectHandleOnStack arr, ObjectHandleOnStack res, int pos);
    private static void SetGenericValue_icall(ObjectHandleOnStack arr, int pos, T& value);
    [IntrinsicAttribute]
private void GetGenericValueImpl(int pos, T& value);
    [IntrinsicAttribute]
private void SetGenericValueImpl(int pos, T& value);
    private static void SetValueImpl(ObjectHandleOnStack arr, ObjectHandleOnStack value, int pos);
    private static void InitializeInternal(ObjectHandleOnStack arr);
    private static void SetValueRelaxedImpl(ObjectHandleOnStack arr, ObjectHandleOnStack value, int pos);
    internal int InternalArray__ICollection_get_Count();
    internal bool InternalArray__ICollection_get_IsReadOnly();
    internal IEnumerator`1<T> InternalArray__IEnumerable_GetEnumerator();
    internal void InternalArray__ICollection_Clear();
    internal void InternalArray__ICollection_Add(T _);
    internal bool InternalArray__ICollection_Remove(T _);
    internal bool InternalArray__ICollection_Contains(T item);
    internal void InternalArray__ICollection_CopyTo(T[] array, int arrayIndex);
    internal T InternalArray__IReadOnlyList_get_Item(int index);
    internal int InternalArray__IReadOnlyCollection_get_Count();
    internal void InternalArray__Insert(int _, T _1);
    internal void InternalArray__RemoveAt(int _);
    internal int InternalArray__IndexOf(T item);
    internal T InternalArray__get_Item(int index);
    internal void InternalArray__set_Item(int index, T item);
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    [NullableContextAttribute("2")]
public static void Resize(T[]& array, int newSize);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, int length);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
public static Array CreateInstance(Type elementType, int length1, int length2);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, Int32[] lengths);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public object GetValue(Int32[] indices);
    [NullableContextAttribute("2")]
public object GetValue(int index);
    [NullableContextAttribute("2")]
public object GetValue(int index1, int index2);
    [NullableContextAttribute("2")]
public object GetValue(int index1, int index2, int index3);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index1, int index2);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    [NullableContextAttribute("2")]
public object GetValue(long index);
    [NullableContextAttribute("2")]
public object GetValue(long index1, long index2);
    [NullableContextAttribute("2")]
public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index1, long index2);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    private static int GetMedian(int low, int hi);
    public long GetLongLength(int dimension);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    [IntrinsicAttribute]
public sealed virtual object Clone();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static int BinarySearch(Array array, object value);
    public static int BinarySearch(Array array, int index, int length, object value);
    [NullableContextAttribute("2")]
public static int BinarySearch(Array array, object value, IComparer comparer);
    [NullableContextAttribute("2")]
public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T Find(T[] array, Predicate`1<T> match);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array keys, Array items, int index, int length);
    public static void Sort(Array array, IComparer comparer);
    [NullableContextAttribute("2")]
public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    [NullableContextAttribute("2")]
public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items);
    public static void Sort(T[] array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
    public static int get_MaxLength();
    private static Span`1<T> UnsafeArrayAsSpan(Array array, int adjustedIndex, int length);
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
internal static int <BinarySearch>g__GenericBinarySearch|119_0(Array array, int adjustedIndex, int length, object value);
    [CompilerGeneratedAttribute]
internal static int <IndexOf>g__GenericIndexOf|144_0(Array array, object value, int adjustedIndex, int length);
    [CompilerGeneratedAttribute]
internal static int <LastIndexOf>g__GenericLastIndexOf|150_0(Array array, object value, int adjustedIndex, int length);
    [CompilerGeneratedAttribute]
internal static void <Sort>g__GenericSort|165_0(Array keys, Array items, int adjustedIndex, int length);
}
internal class System.ArrayEnumerator : object {
    private Array _array;
    private IntPtr _index;
    public object Current { get; }
    internal ArrayEnumerator(Array array);
    public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArraySegment`1 : ValueType {
    [CompilerGeneratedAttribute]
private static ArraySegment`1<T> <Empty>k__BackingField;
    private T[] _array;
    private int _offset;
    private int _count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySegment`1<T> Empty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public T[] Array { get; }
    public int Offset { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    private static ArraySegment`1();
    [CompilerGeneratedAttribute]
public static ArraySegment`1<T> get_Empty();
    public T[] get_Array();
    public int get_Offset();
    public sealed virtual int get_Count();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public void CopyTo(ArraySegment`1<T> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(ArraySegment`1<T> obj);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    public T[] ToArray();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void ThrowInvalidOperationIfDefault();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ArrayTypeMismatchException : SystemException {
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AssemblyLoadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Assembly <LoadedAssembly>k__BackingField;
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    [CompilerGeneratedAttribute]
public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    private static Attribute GetAttr(ICustomAttributeProvider element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
public virtual bool Equals(object obj);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
public virtual int GetHashCode();
    private static bool AreFieldValuesEqual(object thisValue, object thatValue);
    public virtual object get_TypeId();
    [NullableContextAttribute("2")]
public virtual bool Match(object obj);
    public virtual bool IsDefaultAttribute();
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    private AttributeTargets _attributeTarget;
    private bool _allowMultiple;
    private bool _inherited;
    internal static AttributeUsageAttribute Default;
    public AttributeTargets ValidOn { get; }
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    private static AttributeUsageAttribute();
    public AttributeTargets get_ValidOn();
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.BadImageFormatException : SystemException {
    private string _fileName;
    private string _fusionLog;
    [NullableAttribute("1")]
public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    private void SetMessageField();
    public string get_FileName();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public string get_FusionLog();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.BitConverter : object {
    [IntrinsicAttribute]
public static bool IsLittleEndian;
    private static BitConverter();
    public static Byte[] GetBytes(bool value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    public static Byte[] GetBytes(char value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, char value);
    public static Byte[] GetBytes(short value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, short value);
    public static Byte[] GetBytes(int value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, int value);
    public static Byte[] GetBytes(long value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, long value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
    public static Byte[] GetBytes(Half value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, Half value);
    public static Byte[] GetBytes(float value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, float value);
    public static Byte[] GetBytes(double value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, double value);
    public static char ToChar(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static char ToChar(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static long ToInt64(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    public static Half ToHalf(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static Half ToHalf(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value, int startIndex, int length);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static bool ToBoolean(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    [IntrinsicAttribute]
public static long DoubleToInt64Bits(double value);
    [IntrinsicAttribute]
public static double Int64BitsToDouble(long value);
    [IntrinsicAttribute]
public static int SingleToInt32Bits(float value);
    [IntrinsicAttribute]
public static float Int32BitsToSingle(int value);
    public static short HalfToInt16Bits(Half value);
    public static Half Int16BitsToHalf(short value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static ulong DoubleToUInt64Bits(double value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static double UInt64BitsToDouble(ulong value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static UInt32 SingleToUInt32Bits(float value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static float UInt32BitsToSingle(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort HalfToUInt16Bits(Half value);
    [CLSCompliantAttribute("False")]
public static Half UInt16BitsToHalf(ushort value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Boolean : ValueType {
    private bool m_value;
    [NullableAttribute("1")]
public static string TrueString;
    [NullableAttribute("1")]
public static string FalseString;
    private static Boolean();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(bool obj);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(bool value);
    internal static bool IsTrueStringIgnoreCase(ReadOnlySpan`1<char> value);
    internal static bool IsFalseStringIgnoreCase(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
public static bool Parse(string value);
    public static bool Parse(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("2")]
public static bool TryParse(string value, Boolean& result);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    private static ReadOnlySpan`1<char> TrimWhiteSpaceAndNull(ReadOnlySpan`1<char> value);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override bool System.IParsable<System.Boolean>.Parse(string s, IFormatProvider provider);
    private static override bool System.IParsable<System.Boolean>.TryParse(string s, IFormatProvider provider, Boolean& result);
    private static override bool System.ISpanParsable<System.Boolean>.Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    private static override bool System.ISpanParsable<System.Boolean>.TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Boolean& result);
    [CompilerGeneratedAttribute]
internal static bool <TryParse>g__TryParseUncommon|20_0(ReadOnlySpan`1<char> value, Boolean& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Buffer : object {
    private static UIntPtr MemmoveNativeThreshold { get; }
    private static void __ZeroMemory(Void* b, UIntPtr byteLength);
    private static void __Memmove(Byte* dest, Byte* src, UIntPtr len);
    private static void BulkMoveWithWriteBarrier(Byte& dmem, Byte& smem, UIntPtr len, IntPtr type_handle);
    internal static void Memmove(T& destination, T& source, UIntPtr elementCount);
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    public static void SetByte(Array array, int index, byte value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    [IntrinsicAttribute]
internal static void Memmove(Byte& dest, Byte& src, UIntPtr len);
    private static void _Memmove(Byte& dest, Byte& src, UIntPtr len);
    internal static void _ZeroMemory(Byte& b, UIntPtr byteLength);
    private static UIntPtr get_MemmoveNativeThreshold();
}
internal class System.Buffers.Any2ByteSearchValues : SearchValues`1<byte> {
    private byte _e0;
    private byte _e1;
    public Any2ByteSearchValues(ReadOnlySpan`1<byte> values);
    internal virtual Byte[] GetValues();
    internal virtual bool ContainsCore(byte value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<byte> span);
}
internal class System.Buffers.Any2CharSearchValues`1 : SearchValues`1<char> {
    private char _e0;
    private char _e1;
    public Any2CharSearchValues`1(char value0, char value1);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
}
internal class System.Buffers.Any3ByteSearchValues : SearchValues`1<byte> {
    private byte _e0;
    private byte _e1;
    private byte _e2;
    public Any3ByteSearchValues(ReadOnlySpan`1<byte> values);
    internal virtual Byte[] GetValues();
    internal virtual bool ContainsCore(byte value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<byte> span);
}
internal class System.Buffers.Any3CharSearchValues`1 : SearchValues`1<char> {
    private char _e0;
    private char _e1;
    private char _e2;
    public Any3CharSearchValues`1(char value0, char value1, char value2);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
}
internal class System.Buffers.Any4SearchValues`2 : SearchValues`1<T> {
    private TImpl _e0;
    private TImpl _e1;
    private TImpl _e2;
    private TImpl _e3;
    public Any4SearchValues`2(ReadOnlySpan`1<TImpl> values);
    internal virtual T[] GetValues();
    internal virtual bool ContainsCore(T value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span);
}
internal class System.Buffers.Any5SearchValues`2 : SearchValues`1<T> {
    private TImpl _e0;
    private TImpl _e1;
    private TImpl _e2;
    private TImpl _e3;
    private TImpl _e4;
    public Any5SearchValues`2(ReadOnlySpan`1<TImpl> values);
    internal virtual T[] GetValues();
    internal virtual bool ContainsCore(T value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span);
}
internal class System.Buffers.AnyByteSearchValues : SearchValues`1<byte> {
    private Vector512`1<byte> _bitmaps;
    private BitVector256 _lookup;
    public AnyByteSearchValues(ReadOnlySpan`1<byte> values);
    internal virtual Byte[] GetValues();
    internal virtual bool ContainsCore(byte value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    private int IndexOfAny(Byte& searchSpace, int searchSpaceLength);
    private int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength);
    private int IndexOfAnyScalar(Byte& searchSpace, int searchSpaceLength);
    private int LastIndexOfAnyScalar(Byte& searchSpace, int searchSpaceLength);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Buffers.ArrayPool`1 : object {
    private static SharedArrayPool`1<T> s_shared;
    public static ArrayPool`1<T> Shared { get; }
    private static ArrayPool`1();
    public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
[EventSourceAttribute]
[GeneratedCodeAttribute("System.Private.CoreLib.Generators", "8.0.10.36612")]
internal class System.Buffers.ArrayPoolEventSource : EventSource {
    private static string EventSourceSuppressMessage;
    internal static ArrayPoolEventSource Log;
    internal static int NoBucketId;
    private protected ReadOnlySpan`1<byte> ProviderMetadata { get; }
    private ArrayPoolEventSource(int _);
    private static ArrayPoolEventSource();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("1")]
internal void BufferRented(int bufferId, int bufferSize, int poolId, int bucketId);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("2")]
internal void BufferAllocated(int bufferId, int bufferSize, int poolId, int bucketId, BufferAllocatedReason reason);
    [EventAttribute("3")]
internal void BufferReturned(int bufferId, int bufferSize, int poolId);
    [EventAttribute("4")]
internal void BufferTrimmed(int bufferId, int bufferSize, int poolId);
    [EventAttribute("5")]
internal void BufferTrimPoll(int milliseconds, int pressure);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[EventAttribute("6")]
internal void BufferDropped(int bufferId, int bufferSize, int poolId, int bucketId, BufferDroppedReason reason);
    private protected virtual ReadOnlySpan`1<byte> get_ProviderMetadata();
}
internal class System.Buffers.AsciiByteSearchValues : SearchValues`1<byte> {
    private Vector256`1<byte> _bitmap;
    private BitVector256 _lookup;
    public AsciiByteSearchValues(ReadOnlySpan`1<byte> values);
    internal virtual Byte[] GetValues();
    internal virtual bool ContainsCore(byte value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    private int IndexOfAny(Byte& searchSpace, int searchSpaceLength);
    private int LastIndexOfAny(Byte& searchSpace, int searchSpaceLength);
    private int IndexOfAnyScalar(Byte& searchSpace, int searchSpaceLength);
    private int LastIndexOfAnyScalar(Byte& searchSpace, int searchSpaceLength);
}
internal class System.Buffers.AsciiCharSearchValues`1 : SearchValues`1<char> {
    private Vector256`1<byte> _bitmap;
    private BitVector256 _lookup;
    public AsciiCharSearchValues`1(Vector256`1<byte> bitmap, BitVector256 lookup);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
    private int IndexOfAny(Char& searchSpace, int searchSpaceLength);
    private int LastIndexOfAny(Char& searchSpace, int searchSpaceLength);
    private int IndexOfAnyScalar(Char& searchSpace, int searchSpaceLength);
    private int LastIndexOfAnyScalar(Char& searchSpace, int searchSpaceLength);
}
public static class System.Buffers.Binary.BinaryPrimitives : object {
    public static double ReadDoubleBigEndian(ReadOnlySpan`1<byte> source);
    public static Half ReadHalfBigEndian(ReadOnlySpan`1<byte> source);
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static Int128 ReadInt128BigEndian(ReadOnlySpan`1<byte> source);
    public static IntPtr ReadIntPtrBigEndian(ReadOnlySpan`1<byte> source);
    public static float ReadSingleBigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt128 ReadUInt128BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UIntPtr ReadUIntPtrBigEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadDoubleBigEndian(ReadOnlySpan`1<byte> source, Double& value);
    public static bool TryReadHalfBigEndian(ReadOnlySpan`1<byte> source, Half& value);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    public static bool TryReadInt128BigEndian(ReadOnlySpan`1<byte> source, Int128& value);
    public static bool TryReadIntPtrBigEndian(ReadOnlySpan`1<byte> source, IntPtr& value);
    public static bool TryReadSingleBigEndian(ReadOnlySpan`1<byte> source, Single& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt128BigEndian(ReadOnlySpan`1<byte> source, UInt128& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUIntPtrBigEndian(ReadOnlySpan`1<byte> source, UIntPtr& value);
    public static double ReadDoubleLittleEndian(ReadOnlySpan`1<byte> source);
    public static Half ReadHalfLittleEndian(ReadOnlySpan`1<byte> source);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static Int128 ReadInt128LittleEndian(ReadOnlySpan`1<byte> source);
    public static IntPtr ReadIntPtrLittleEndian(ReadOnlySpan`1<byte> source);
    public static float ReadSingleLittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt128 ReadUInt128LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UIntPtr ReadUIntPtrLittleEndian(ReadOnlySpan`1<byte> source);
    public static bool TryReadDoubleLittleEndian(ReadOnlySpan`1<byte> source, Double& value);
    public static bool TryReadHalfLittleEndian(ReadOnlySpan`1<byte> source, Half& value);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    public static bool TryReadInt128LittleEndian(ReadOnlySpan`1<byte> source, Int128& value);
    public static bool TryReadIntPtrLittleEndian(ReadOnlySpan`1<byte> source, IntPtr& value);
    public static bool TryReadSingleLittleEndian(ReadOnlySpan`1<byte> source, Single& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt128LittleEndian(ReadOnlySpan`1<byte> source, UInt128& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUIntPtrLittleEndian(ReadOnlySpan`1<byte> source, UIntPtr& value);
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    [IntrinsicAttribute]
public static short ReverseEndianness(short value);
    [IntrinsicAttribute]
public static int ReverseEndianness(int value);
    [IntrinsicAttribute]
public static long ReverseEndianness(long value);
    public static IntPtr ReverseEndianness(IntPtr value);
    public static Int128 ReverseEndianness(Int128 value);
    public static byte ReverseEndianness(byte value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static ushort ReverseEndianness(ushort value);
    internal static char ReverseEndianness(char value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static UInt32 ReverseEndianness(UInt32 value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public static ulong ReverseEndianness(ulong value);
    [CLSCompliantAttribute("False")]
public static UIntPtr ReverseEndianness(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt128 ReverseEndianness(UInt128 value);
    [CLSCompliantAttribute("False")]
public static void ReverseEndianness(ReadOnlySpan`1<ushort> source, Span`1<ushort> destination);
    public static void ReverseEndianness(ReadOnlySpan`1<short> source, Span`1<short> destination);
    [CLSCompliantAttribute("False")]
public static void ReverseEndianness(ReadOnlySpan`1<UInt32> source, Span`1<UInt32> destination);
    public static void ReverseEndianness(ReadOnlySpan`1<int> source, Span`1<int> destination);
    [CLSCompliantAttribute("False")]
public static void ReverseEndianness(ReadOnlySpan`1<ulong> source, Span`1<ulong> destination);
    public static void ReverseEndianness(ReadOnlySpan`1<long> source, Span`1<long> destination);
    [CLSCompliantAttribute("False")]
public static void ReverseEndianness(ReadOnlySpan`1<UIntPtr> source, Span`1<UIntPtr> destination);
    public static void ReverseEndianness(ReadOnlySpan`1<IntPtr> source, Span`1<IntPtr> destination);
    private static void ReverseEndianness(ReadOnlySpan`1<T> source, Span`1<T> destination);
    [CLSCompliantAttribute("False")]
public static void ReverseEndianness(ReadOnlySpan`1<UInt128> source, Span`1<UInt128> destination);
    public static void ReverseEndianness(ReadOnlySpan`1<Int128> source, Span`1<Int128> destination);
    [DoesNotReturnAttribute]
private static void ThrowDestinationTooSmall();
    public static void WriteDoubleBigEndian(Span`1<byte> destination, double value);
    public static void WriteHalfBigEndian(Span`1<byte> destination, Half value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    public static void WriteInt128BigEndian(Span`1<byte> destination, Int128 value);
    public static void WriteIntPtrBigEndian(Span`1<byte> destination, IntPtr value);
    public static void WriteSingleBigEndian(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt128BigEndian(Span`1<byte> destination, UInt128 value);
    [CLSCompliantAttribute("False")]
public static void WriteUIntPtrBigEndian(Span`1<byte> destination, UIntPtr value);
    public static bool TryWriteDoubleBigEndian(Span`1<byte> destination, double value);
    public static bool TryWriteHalfBigEndian(Span`1<byte> destination, Half value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    public static bool TryWriteInt128BigEndian(Span`1<byte> destination, Int128 value);
    public static bool TryWriteIntPtrBigEndian(Span`1<byte> destination, IntPtr value);
    public static bool TryWriteSingleBigEndian(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt128BigEndian(Span`1<byte> destination, UInt128 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUIntPtrBigEndian(Span`1<byte> destination, UIntPtr value);
    public static void WriteDoubleLittleEndian(Span`1<byte> destination, double value);
    public static void WriteHalfLittleEndian(Span`1<byte> destination, Half value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    public static void WriteInt128LittleEndian(Span`1<byte> destination, Int128 value);
    public static void WriteIntPtrLittleEndian(Span`1<byte> destination, IntPtr value);
    public static void WriteSingleLittleEndian(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt128LittleEndian(Span`1<byte> destination, UInt128 value);
    [CLSCompliantAttribute("False")]
public static void WriteUIntPtrLittleEndian(Span`1<byte> destination, UIntPtr value);
    public static bool TryWriteDoubleLittleEndian(Span`1<byte> destination, double value);
    public static bool TryWriteHalfLittleEndian(Span`1<byte> destination, Half value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    public static bool TryWriteInt128LittleEndian(Span`1<byte> destination, Int128 value);
    public static bool TryWriteIntPtrLittleEndian(Span`1<byte> destination, IntPtr value);
    public static bool TryWriteSingleLittleEndian(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt128LittleEndian(Span`1<byte> destination, UInt128 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUIntPtrLittleEndian(Span`1<byte> destination, UIntPtr value);
}
internal class System.Buffers.BitVector256 : ValueType {
    [FixedBufferAttribute("System.UInt32", "8")]
private <_values>e__FixedBuffer _values;
    public void Set(int c);
    [IsReadOnlyAttribute]
public bool Contains128(char c);
    [IsReadOnlyAttribute]
public bool Contains256(char c);
    [IsReadOnlyAttribute]
public bool Contains(byte b);
    [IsReadOnlyAttribute]
private bool ContainsUnchecked(int b);
    [IsReadOnlyAttribute]
public Char[] GetCharValues();
    [IsReadOnlyAttribute]
public Byte[] GetByteValues();
}
internal class System.Buffers.ConfigurableArrayPool`1 : ArrayPool`1<T> {
    private Bucket[] _buckets;
    private int Id { get; }
    internal ConfigurableArrayPool`1(int maxArrayLength, int maxArraysPerBucket);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
}
internal class System.Buffers.EmptySearchValues`1 : SearchValues`1<T> {
    internal virtual T[] GetValues();
    internal virtual bool ContainsCore(T value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span);
}
public interface System.Buffers.IMemoryOwner`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
internal static class System.Buffers.IndexOfAnyAsciiSearcher : object {
    internal static bool IsVectorizationSupported { get; }
    internal static bool get_IsVectorizationSupported();
    internal static void ComputeBitmap256(ReadOnlySpan`1<byte> values, Vector256`1& bitmap0, Vector256`1& bitmap1, BitVector256& lookup);
    internal static void ComputeBitmap(ReadOnlySpan`1<T> values, Vector256`1& bitmap, BitVector256& lookup);
    private static bool TryComputeBitmap(ReadOnlySpan`1<char> values, Byte* bitmap, Boolean& needleContainsZero);
    public static bool TryIndexOfAny(Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> asciiValues, Int32& index);
    public static bool TryIndexOfAnyExcept(Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> asciiValues, Int32& index);
    public static bool TryLastIndexOfAny(Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> asciiValues, Int32& index);
    public static bool TryLastIndexOfAnyExcept(Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> asciiValues, Int32& index);
    private static bool TryIndexOfAny(Int16& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> asciiValues, Int32& index);
    private static bool TryLastIndexOfAny(Int16& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> asciiValues, Int32& index);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static int IndexOfAnyVectorized(Int16& searchSpace, int searchSpaceLength, Vector256`1& bitmapRef);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static int LastIndexOfAnyVectorized(Int16& searchSpace, int searchSpaceLength, Vector256`1& bitmapRef);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static int IndexOfAnyVectorized(Byte& searchSpace, int searchSpaceLength, Vector256`1& bitmapRef);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static int LastIndexOfAnyVectorized(Byte& searchSpace, int searchSpaceLength, Vector256`1& bitmapRef);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static int IndexOfAnyVectorizedAnyByte(Byte& searchSpace, int searchSpaceLength, Vector512`1& bitmapsRef);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static int LastIndexOfAnyVectorizedAnyByte(Byte& searchSpace, int searchSpaceLength, Vector512`1& bitmapsRef);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
private static Vector128`1<byte> IndexOfAnyLookup(Vector128`1<short> source0, Vector128`1<short> source1, Vector128`1<byte> bitmapLookup);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
private static Vector128`1<byte> IndexOfAnyLookupCore(Vector128`1<byte> source, Vector128`1<byte> bitmapLookup);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
private static Vector128`1<byte> IndexOfAnyLookup(Vector128`1<byte> source, Vector128`1<byte> bitmapLookup0, Vector128`1<byte> bitmapLookup1);
    private static int ComputeFirstIndex(T& searchSpace, T& current, Vector128`1<byte> result);
    private static int ComputeFirstIndexOverlapped(T& searchSpace, T& current0, T& current1, Vector128`1<byte> result);
    private static int ComputeLastIndex(T& searchSpace, T& current, Vector128`1<byte> result);
    private static int ComputeLastIndexOverlapped(T& searchSpace, T& secondVector, Vector128`1<byte> result);
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
internal class System.Buffers.Latin1CharSearchValues : SearchValues`1<char> {
    private BitVector256 _lookup;
    public Latin1CharSearchValues(ReadOnlySpan`1<char> values);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
    private int IndexOfAny(Char& searchSpace, int searchSpaceLength);
    private int LastIndexOfAny(Char& searchSpace, int searchSpaceLength);
}
public class System.Buffers.MemoryHandle : ValueType {
    private Void* _pointer;
    private GCHandle _handle;
    private IPinnable _pinnable;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    private sealed virtual override void System.IDisposable.Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
public enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Done;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus NeedMoreData;
    public static OperationStatus InvalidData;
}
internal class System.Buffers.ProbabilisticCharSearchValues : SearchValues`1<char> {
    private ProbabilisticMap _map;
    private string _values;
    public ProbabilisticCharSearchValues(ReadOnlySpan`1<char> values);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
}
[IsReadOnlyAttribute]
internal class System.Buffers.ProbabilisticMap : ValueType {
    private UInt32 _e0;
    private UInt32 _e1;
    private UInt32 _e2;
    private UInt32 _e3;
    private UInt32 _e4;
    private UInt32 _e5;
    private UInt32 _e6;
    private UInt32 _e7;
    public ProbabilisticMap(ReadOnlySpan`1<char> values);
    private static void SetCharBit(UInt32& charMap, byte value);
    private static bool IsCharBitSet(UInt32& charMap, byte value);
    internal static bool Contains(UInt32& charMap, ReadOnlySpan`1<char> values, int ch);
    private static bool Contains(ReadOnlySpan`1<char> values, char ch);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
private static Vector128`1<byte> ContainsMask16Chars(Vector128`1<byte> charMapLower, Vector128`1<byte> charMapUpper, Char& searchSpace);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
private static Vector128`1<byte> IsCharBitSet(Vector128`1<byte> charMapLower, Vector128`1<byte> charMapUpper, Vector128`1<byte> values);
    private static bool ShouldUseSimpleLoop(int searchSpaceLength, int valuesLength);
    public static int IndexOfAny(Char& searchSpace, int searchSpaceLength, Char& values, int valuesLength);
    public static int IndexOfAnyExcept(Char& searchSpace, int searchSpaceLength, Char& values, int valuesLength);
    public static int LastIndexOfAny(Char& searchSpace, int searchSpaceLength, Char& values, int valuesLength);
    public static int LastIndexOfAnyExcept(Char& searchSpace, int searchSpaceLength, Char& values, int valuesLength);
    private static int ProbabilisticIndexOfAny(Char& searchSpace, int searchSpaceLength, Char& values, int valuesLength);
    private static int ProbabilisticLastIndexOfAny(Char& searchSpace, int searchSpaceLength, Char& values, int valuesLength);
    internal static int IndexOfAny(UInt32& charMap, Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> values);
    internal static int LastIndexOfAny(UInt32& charMap, Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> values);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse41")]
private static int IndexOfAnyVectorized(UInt32& charMap, Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> values);
    internal static int IndexOfAnySimpleLoop(Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> values);
    internal static int LastIndexOfAnySimpleLoop(Char& searchSpace, int searchSpaceLength, ReadOnlySpan`1<char> values);
}
internal class System.Buffers.ProbabilisticWithAsciiCharSearchValues`1 : SearchValues`1<char> {
    private Vector256`1<byte> _asciiBitmap;
    private Vector256`1<byte> _inverseAsciiBitmap;
    private ProbabilisticMap _map;
    private string _values;
    public ProbabilisticWithAsciiCharSearchValues`1(ReadOnlySpan`1<char> values);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
}
internal class System.Buffers.RangeByteSearchValues : SearchValues`1<byte> {
    private byte _lowInclusive;
    private byte _highInclusive;
    private UInt32 _lowUint;
    private UInt32 _highMinusLow;
    public RangeByteSearchValues(byte lowInclusive, byte highInclusive);
    internal virtual Byte[] GetValues();
    internal virtual bool ContainsCore(byte value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<byte> span);
}
internal class System.Buffers.RangeCharSearchValues`1 : SearchValues`1<char> {
    private char _rangeInclusive;
    private char _lowInclusive;
    private char _highInclusive;
    private UInt32 _lowUint;
    private UInt32 _highMinusLow;
    public RangeCharSearchValues`1(char lowInclusive, char highInclusive);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Buffers.SearchValues : object {
    public static SearchValues`1<byte> Create(ReadOnlySpan`1<byte> values);
    public static SearchValues`1<char> Create(ReadOnlySpan`1<char> values);
    private static bool TryGetSingleRange(ReadOnlySpan`1<T> values, T& minInclusive, T& maxInclusive);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
[DebuggerTypeProxyAttribute("System.Buffers.SearchValuesDebugView`1")]
public class System.Buffers.SearchValues`1 : object {
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    internal virtual T[] GetValues();
    [NullableContextAttribute("1")]
public bool Contains(T value);
    internal virtual bool ContainsCore(T value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<T> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span);
    internal static int IndexOfAny(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    internal static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    internal static int LastIndexOfAny(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    internal static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    private string get_DebuggerDisplay();
}
internal class System.Buffers.SearchValuesDebugView`1 : object {
    private SearchValues`1<T> _values;
    [DebuggerBrowsableAttribute("3")]
public T[] Values { get; }
    public SearchValuesDebugView`1(SearchValues`1<T> values);
    public T[] get_Values();
}
internal class System.Buffers.SharedArrayPool`1 : ArrayPool`1<T> {
    [ThreadStaticAttribute]
private static ThreadLocalArray[] t_tlsBuckets;
    private ConditionalWeakTable`2<ThreadLocalArray[], object> _allTlsBuckets;
    private Partitions[] _buckets;
    private int _trimCallbackCreated;
    private int Id { get; }
    private Partitions<T> CreatePerCorePartitions(int bucketIndex);
    private int get_Id();
    public virtual T[] Rent(int minimumLength);
    public virtual void Return(T[] array, bool clearArray);
    public bool Trim();
    private ThreadLocalArray[] InitializeTlsBucketsAndTrimming();
}
internal static class System.Buffers.SharedArrayPoolStatics : object {
    internal static int s_partitionCount;
    internal static int s_maxArraysPerPartition;
    private static SharedArrayPoolStatics();
    private static int GetPartitionCount();
    private static int GetMaxArraysPerPartition();
    private static bool TryGetInt32EnvironmentVariable(string variable, Int32& result);
}
internal class System.Buffers.SingleByteSearchValues : SearchValues`1<byte> {
    private byte _e0;
    public SingleByteSearchValues(ReadOnlySpan`1<byte> values);
    internal virtual Byte[] GetValues();
    internal virtual bool ContainsCore(byte value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<byte> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<byte> span);
}
internal class System.Buffers.SingleCharSearchValues`1 : SearchValues`1<char> {
    private char _e0;
    public SingleCharSearchValues`1(char value);
    internal virtual Char[] GetValues();
    internal virtual bool ContainsCore(char value);
    internal virtual int IndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int IndexOfAnyExcept(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAny(ReadOnlySpan`1<char> span);
    internal virtual int LastIndexOfAnyExcept(ReadOnlySpan`1<char> span);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Buffers.SpanFunc`5 : MulticastDelegate {
    public SpanFunc`5(object object, IntPtr method);
    public virtual TResult Invoke(Span`1<TSpan> span, T1 arg1, T2 arg2, T3 arg3);
}
[IsReadOnlyAttribute]
public class System.Buffers.StandardFormat : ValueType {
    public static byte NoPrecision;
    public static byte MaxPrecision;
    private byte _format;
    private byte _precision;
    public char Symbol { get; }
    public byte Precision { get; }
    public bool HasPrecision { get; }
    internal byte PrecisionOrZero { get; }
    public bool IsDefault { get; }
    public StandardFormat(char symbol, byte precision);
    public char get_Symbol();
    public byte get_Precision();
    public bool get_HasPrecision();
    internal byte get_PrecisionOrZero();
    public bool get_IsDefault();
    public static StandardFormat op_Implicit(char symbol);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static StandardFormat Parse(string format);
    public static bool TryParse(ReadOnlySpan`1<char> format, StandardFormat& result);
    private static bool ParseHelper(ReadOnlySpan`1<char> format, StandardFormat& standardFormat, bool throws);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(StandardFormat other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    internal Span`1<char> Format(Span`1<char> destination);
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
}
public static class System.Buffers.Text.Base64 : object {
    internal static ReadOnlySpan`1<byte> EncodingMap { get; }
    private static ReadOnlySpan`1<sbyte> DecodingMap { get; }
    public static OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static int GetMaxEncodedToUtf8Length(int length);
    public static OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
private static void Vector128Encode(Byte*& srcBytes, Byte*& destBytes, Byte* srcEnd, int sourceLength, int destLength, Byte* srcStart, Byte* destStart);
    private static UInt32 Encode(Byte* threeBytes, Byte& encodingMap);
    private static UInt32 EncodeAndPadOne(Byte* twoBytes, Byte& encodingMap);
    private static UInt32 EncodeAndPadTwo(Byte* oneByte, Byte& encodingMap);
    internal static ReadOnlySpan`1<byte> get_EncodingMap();
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    private static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock, bool ignoreWhiteSpace);
    public static int GetMaxDecodedFromUtf8Length(int length);
    public static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten);
    private static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten, bool ignoreWhiteSpace);
    private static OperationStatus DecodeWithWhiteSpaceBlockwise(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    private static int GetPaddingCount(Byte& ptrToLastElement);
    private static OperationStatus DecodeWithWhiteSpaceFromUtf8InPlace(Span`1<byte> utf8, Int32& destIndex, UInt32 sourceIndex);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
private static Vector128`1<byte> SimdShuffle(Vector128`1<byte> left, Vector128`1<byte> right, Vector128`1<byte> mask8F);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
private static void Vector128Decode(Byte*& srcBytes, Byte*& destBytes, Byte* srcEnd, int sourceLength, int destLength, Byte* srcStart, Byte* destStart);
    private static int Decode(Byte* encodedBytes, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte* destination, int value);
    private static int IndexOfAnyExceptWhiteSpace(ReadOnlySpan`1<byte> span);
    internal static bool IsWhiteSpace(int value);
    private static ReadOnlySpan`1<sbyte> get_DecodingMap();
    public static bool IsValid(ReadOnlySpan`1<char> base64Text);
    public static bool IsValid(ReadOnlySpan`1<char> base64Text, Int32& decodedLength);
    public static bool IsValid(ReadOnlySpan`1<byte> base64TextUtf8);
    public static bool IsValid(ReadOnlySpan`1<byte> base64TextUtf8, Int32& decodedLength);
    private static bool IsValid(ReadOnlySpan`1<T> base64Text, Int32& decodedLength);
    [CompilerGeneratedAttribute]
internal static OperationStatus <DecodeFromUtf8>g__InvalidDataFallback|15_0(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
}
internal static class System.Buffers.Text.FormattingHelpers : object {
    public static int CountDigits(UInt128 value);
    public static int CountDigits(ulong value);
    public static int CountDigits(UInt32 value);
    public static int CountHexDigits(UInt128 value);
    public static int CountHexDigits(ulong value);
    public static int CountDecimalTrailingZeros(UInt32 value, UInt32& valueWithoutTrailingZeros);
    public static bool TryFormat(T value, Span`1<byte> utf8Destination, Int32& bytesWritten, StandardFormat format);
    public static char GetSymbolOrDefault(StandardFormat& format, char defaultSymbol);
}
internal static class System.Buffers.Text.ParserHelpers : object {
    public static bool IsDigit(int i);
    public static bool TryParseThrowFormatException(Int32& bytesConsumed);
    public static bool TryParseThrowFormatException(T& value, Int32& bytesConsumed);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
public static bool TryParseThrowFormatException(ReadOnlySpan`1<byte> _, T& value, Int32& bytesConsumed);
}
public static class System.Buffers.Text.Utf8Formatter : object {
    private static TimeSpan NullOffset { get; }
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormatDateTimeL(DateTime value, Span`1<byte> destination, Int32& bytesWritten);
    private static TimeSpan get_NullOffset();
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static bool TryFormat(int value, int hexMask, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    private static void ThrowGWithPrecisionNotSupported();
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
public static class System.Buffers.Text.Utf8Parser : object {
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseDateTimeOffsetDefault(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed);
    private static bool TryParseDateTimeG(ReadOnlySpan`1<byte> source, DateTime& value, DateTimeOffset& valueAsOffset, Int32& bytesConsumed);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(int year, int month, int day, int hour, int minute, int second, int fraction, bool offsetNegative, int offsetHours, int offsetMinutes, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeOffset& value);
    private static bool TryCreateDateTime(int year, int month, int day, int hour, int minute, int second, int fraction, DateTimeKind kind, DateTime& value);
    private static bool TryParseDateTimeOffsetO(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, DateTimeKind& kind);
    private static bool TryParseDateTimeOffsetR(ReadOnlySpan`1<byte> source, UInt32 caseFlipXorMask, DateTimeOffset& dateTimeOffset, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseNormalAsFloatingPoint(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseAsSpecialFloatingPoint(ReadOnlySpan`1<byte> source, T positiveInfinity, T negativeInfinity, T nan, T& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseGuidN(ReadOnlySpan`1<byte> text, Guid& value, Int32& bytesConsumed);
    private static bool TryParseGuidCore(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, int ends);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseSByteD(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16D(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32D(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64D(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    private static bool TryParseSByteN(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed);
    private static bool TryParseInt16N(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed);
    private static bool TryParseInt32N(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed);
    private static bool TryParseInt64N(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseByteD(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16D(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32D(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64D(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteN(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16N(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32N(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64N(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseByteX(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed);
    private static bool TryParseUInt16X(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed);
    private static bool TryParseUInt32X(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryParseUInt64X(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed);
    private static bool TryParseNumber(ReadOnlySpan`1<byte> source, NumberBuffer& number, Int32& bytesConsumed, ParseNumberOptions options, Boolean& textUsedExponentNotation);
    private static bool TryParseTimeSpanBigG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    private static bool TryParseTimeSpanC(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    private static bool TryParseTimeSpanFraction(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed);
    private static bool TryCreateTimeSpan(bool isNegative, UInt32 days, UInt32 hours, UInt32 minutes, UInt32 seconds, UInt32 fraction, TimeSpan& timeSpan);
    private static bool TryParseTimeSpanLittleG(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed);
}
internal static class System.Buffers.Utilities : object {
    internal static int SelectBucketIndex(int bufferSize);
    internal static int GetMaxSizeForBucket(int binIndex);
    internal static MemoryPressure GetMemoryPressure();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[NonVersionableAttribute]
internal class System.ByReference : ValueType {
    public Byte& Value;
    public ByReference(Byte& value);
    public static ByReference Create(T& p);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Byte : ValueType {
    private byte m_value;
    public static byte MaxValue;
    public static byte MinValue;
    private static byte System.Numerics.IAdditiveIdentity<System.Byte,System.Byte>.AdditiveIdentity { get; }
    private static byte System.Numerics.IBinaryNumber<System.Byte>.AllBitsSet { get; }
    private static byte System.Numerics.IMinMaxValue<System.Byte>.MinValue { get; }
    private static byte System.Numerics.IMinMaxValue<System.Byte>.MaxValue { get; }
    private static byte System.Numerics.IMultiplicativeIdentity<System.Byte,System.Byte>.MultiplicativeIdentity { get; }
    private static byte System.Numerics.INumberBase<System.Byte>.One { get; }
    private static int System.Numerics.INumberBase<System.Byte>.Radix { get; }
    private static byte System.Numerics.INumberBase<System.Byte>.Zero { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.Byte>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Byte>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Byte>.MaxHexDigitCount { get; }
    private static byte System.IBinaryIntegerParseAndFormatInfo<System.Byte>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.Byte>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(byte value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(byte obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static byte Parse(string s);
    [NullableContextAttribute("1")]
public static byte Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override byte Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override byte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Byte& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override byte System.Numerics.IAdditionOperators<System.Byte,System.Byte,System.Byte>.op_Addition(byte left, byte right);
    private static override byte System.Numerics.IAdditionOperators<System.Byte,System.Byte,System.Byte>.op_CheckedAddition(byte left, byte right);
    private static override byte System.Numerics.IAdditiveIdentity<System.Byte,System.Byte>.get_AdditiveIdentity();
    public static override ValueTuple`2<byte, byte> DivRem(byte left, byte right);
    public static override byte LeadingZeroCount(byte value);
    public static override byte PopCount(byte value);
    public static override byte RotateLeft(byte value, int rotateAmount);
    public static override byte RotateRight(byte value, int rotateAmount);
    public static override byte TrailingZeroCount(byte value);
    private static override bool System.Numerics.IBinaryInteger<System.Byte>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Byte& value);
    private static override bool System.Numerics.IBinaryInteger<System.Byte>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Byte& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Byte>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Byte>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Byte>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Byte>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override byte System.Numerics.IBinaryNumber<System.Byte>.get_AllBitsSet();
    public static override bool IsPow2(byte value);
    public static override byte Log2(byte value);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_BitwiseAnd(byte left, byte right);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_BitwiseOr(byte left, byte right);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_ExclusiveOr(byte left, byte right);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_OnesComplement(byte value);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_LessThan(byte left, byte right);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_LessThanOrEqual(byte left, byte right);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_GreaterThan(byte left, byte right);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_GreaterThanOrEqual(byte left, byte right);
    private static override byte System.Numerics.IDecrementOperators<System.Byte>.op_Decrement(byte value);
    private static override byte System.Numerics.IDecrementOperators<System.Byte>.op_CheckedDecrement(byte value);
    private static override byte System.Numerics.IDivisionOperators<System.Byte,System.Byte,System.Byte>.op_Division(byte left, byte right);
    private static override bool System.Numerics.IEqualityOperators<System.Byte,System.Byte,System.Boolean>.op_Equality(byte left, byte right);
    private static override bool System.Numerics.IEqualityOperators<System.Byte,System.Byte,System.Boolean>.op_Inequality(byte left, byte right);
    private static override byte System.Numerics.IIncrementOperators<System.Byte>.op_Increment(byte value);
    private static override byte System.Numerics.IIncrementOperators<System.Byte>.op_CheckedIncrement(byte value);
    private static override byte System.Numerics.IMinMaxValue<System.Byte>.get_MinValue();
    private static override byte System.Numerics.IMinMaxValue<System.Byte>.get_MaxValue();
    private static override byte System.Numerics.IModulusOperators<System.Byte,System.Byte,System.Byte>.op_Modulus(byte left, byte right);
    private static override byte System.Numerics.IMultiplicativeIdentity<System.Byte,System.Byte>.get_MultiplicativeIdentity();
    private static override byte System.Numerics.IMultiplyOperators<System.Byte,System.Byte,System.Byte>.op_Multiply(byte left, byte right);
    private static override byte System.Numerics.IMultiplyOperators<System.Byte,System.Byte,System.Byte>.op_CheckedMultiply(byte left, byte right);
    public static override byte Clamp(byte value, byte min, byte max);
    private static override byte System.Numerics.INumber<System.Byte>.CopySign(byte value, byte sign);
    public static override byte Max(byte x, byte y);
    private static override byte System.Numerics.INumber<System.Byte>.MaxNumber(byte x, byte y);
    public static override byte Min(byte x, byte y);
    private static override byte System.Numerics.INumber<System.Byte>.MinNumber(byte x, byte y);
    public static override int Sign(byte value);
    private static override byte System.Numerics.INumberBase<System.Byte>.get_One();
    private static override int System.Numerics.INumberBase<System.Byte>.get_Radix();
    private static override byte System.Numerics.INumberBase<System.Byte>.get_Zero();
    private static override byte System.Numerics.INumberBase<System.Byte>.Abs(byte value);
    [NullableContextAttribute("1")]
public static override byte CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override byte CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override byte CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsCanonical(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsComplexNumber(byte value);
    public static override bool IsEvenInteger(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsFinite(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsImaginaryNumber(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsInfinity(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsInteger(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNaN(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNegative(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNegativeInfinity(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNormal(byte value);
    public static override bool IsOddInteger(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsPositive(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsPositiveInfinity(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsRealNumber(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsSubnormal(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsZero(byte value);
    private static override byte System.Numerics.INumberBase<System.Byte>.MaxMagnitude(byte x, byte y);
    private static override byte System.Numerics.INumberBase<System.Byte>.MaxMagnitudeNumber(byte x, byte y);
    private static override byte System.Numerics.INumberBase<System.Byte>.MinMagnitude(byte x, byte y);
    private static override byte System.Numerics.INumberBase<System.Byte>.MinMagnitudeNumber(byte x, byte y);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertFromChecked(TOther value, Byte& result);
    private static bool TryConvertFromChecked(TOther value, Byte& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertFromSaturating(TOther value, Byte& result);
    private static bool TryConvertFromSaturating(TOther value, Byte& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertFromTruncating(TOther value, Byte& result);
    private static bool TryConvertFromTruncating(TOther value, Byte& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertToChecked(byte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertToSaturating(byte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertToTruncating(byte value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Byte& result);
    private static override byte System.Numerics.IShiftOperators<System.Byte,System.Int32,System.Byte>.op_LeftShift(byte value, int shiftAmount);
    private static override byte System.Numerics.IShiftOperators<System.Byte,System.Int32,System.Byte>.op_RightShift(byte value, int shiftAmount);
    private static override byte System.Numerics.IShiftOperators<System.Byte,System.Int32,System.Byte>.op_UnsignedRightShift(byte value, int shiftAmount);
    public static override byte Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Byte& result);
    private static override byte System.Numerics.ISubtractionOperators<System.Byte,System.Byte,System.Byte>.op_Subtraction(byte left, byte right);
    private static override byte System.Numerics.ISubtractionOperators<System.Byte,System.Byte,System.Byte>.op_CheckedSubtraction(byte left, byte right);
    private static override byte System.Numerics.IUnaryNegationOperators<System.Byte,System.Byte>.op_UnaryNegation(byte value);
    private static override byte System.Numerics.IUnaryNegationOperators<System.Byte,System.Byte>.op_CheckedUnaryNegation(byte value);
    private static override byte System.Numerics.IUnaryPlusOperators<System.Byte,System.Byte>.op_UnaryPlus(byte value);
    public static override byte Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Byte& result);
    public static override byte Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Byte& result);
    private static override byte System.IUtfChar<System.Byte>.CastFrom(byte value);
    private static override byte System.IUtfChar<System.Byte>.CastFrom(char value);
    private static override byte System.IUtfChar<System.Byte>.CastFrom(int value);
    private static override byte System.IUtfChar<System.Byte>.CastFrom(UInt32 value);
    private static override byte System.IUtfChar<System.Byte>.CastFrom(ulong value);
    private static override UInt32 System.IUtfChar<System.Byte>.CastToUInt32(byte value);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Byte>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Byte>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Byte>.get_MaxHexDigitCount();
    private static override byte System.IBinaryIntegerParseAndFormatInfo<System.Byte>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.Byte>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Byte>.IsGreaterThanAsUnsigned(byte left, byte right);
    private static override byte System.IBinaryIntegerParseAndFormatInfo<System.Byte>.MultiplyBy10(byte value);
    private static override byte System.IBinaryIntegerParseAndFormatInfo<System.Byte>.MultiplyBy16(byte value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CannotUnloadAppDomainException : SystemException {
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Char : ValueType {
    private char m_value;
    public static char MaxValue;
    public static char MinValue;
    private static ReadOnlySpan`1<byte> Latin1CharInfo { get; }
    private static char System.Numerics.IAdditiveIdentity<System.Char,System.Char>.AdditiveIdentity { get; }
    private static char System.Numerics.IBinaryNumber<System.Char>.AllBitsSet { get; }
    private static char System.Numerics.IMinMaxValue<System.Char>.MinValue { get; }
    private static char System.Numerics.IMinMaxValue<System.Char>.MaxValue { get; }
    private static char System.Numerics.IMultiplicativeIdentity<System.Char,System.Char>.MultiplicativeIdentity { get; }
    private static char System.Numerics.INumberBase<System.Char>.One { get; }
    private static int System.Numerics.INumberBase<System.Char>.Radix { get; }
    private static char System.Numerics.INumberBase<System.Char>.Zero { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.Char>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Char>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Char>.MaxHexDigitCount { get; }
    private static char System.IBinaryIntegerParseAndFormatInfo<System.Char>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.Char>.OverflowMessage { get; }
    private static ReadOnlySpan`1<byte> get_Latin1CharInfo();
    private static bool IsLatin1(char c);
    public static bool IsAscii(char c);
    private static UnicodeCategory GetLatin1UnicodeCategory(char c);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(char obj);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(char value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(char c);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private sealed virtual override bool System.IUtf8SpanFormattable.TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static char Parse(string s);
    internal static char Parse(ReadOnlySpan`1<char> s);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Char& result);
    internal static bool TryParse(ReadOnlySpan`1<char> s, Char& result);
    public static bool IsAsciiLetter(char c);
    public static bool IsAsciiLetterLower(char c);
    public static bool IsAsciiLetterUpper(char c);
    public static bool IsAsciiDigit(char c);
    public static bool IsAsciiLetterOrDigit(char c);
    public static bool IsAsciiHexDigit(char c);
    public static bool IsAsciiHexDigitUpper(char c);
    public static bool IsAsciiHexDigitLower(char c);
    public static bool IsDigit(char c);
    public static bool IsBetween(char c, char minInclusive, char maxInclusive);
    private static bool IsBetween(UnicodeCategory c, UnicodeCategory min, UnicodeCategory max);
    internal static bool CheckLetter(UnicodeCategory uc);
    public static bool IsLetter(char c);
    private static bool IsWhiteSpaceLatin1(char c);
    public static bool IsWhiteSpace(char c);
    public static bool IsUpper(char c);
    public static bool IsLower(char c);
    internal static bool CheckPunctuation(UnicodeCategory uc);
    public static bool IsPunctuation(char c);
    internal static bool CheckLetterOrDigit(UnicodeCategory uc);
    public static bool IsLetterOrDigit(char c);
    [NullableContextAttribute("1")]
public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpper(char c);
    public static char ToUpperInvariant(char c);
    [NullableContextAttribute("1")]
public static char ToLower(char c, CultureInfo culture);
    public static char ToLower(char c);
    public static char ToLowerInvariant(char c);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static bool IsControl(char c);
    [NullableContextAttribute("1")]
public static bool IsControl(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsDigit(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsLetter(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsLetterOrDigit(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsLower(string s, int index);
    internal static bool CheckNumber(UnicodeCategory uc);
    public static bool IsNumber(char c);
    [NullableContextAttribute("1")]
public static bool IsNumber(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsPunctuation(string s, int index);
    internal static bool CheckSeparator(UnicodeCategory uc);
    private static bool IsSeparatorLatin1(char c);
    public static bool IsSeparator(char c);
    [NullableContextAttribute("1")]
public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    [NullableContextAttribute("1")]
public static bool IsSurrogate(string s, int index);
    internal static bool CheckSymbol(UnicodeCategory uc);
    public static bool IsSymbol(char c);
    [NullableContextAttribute("1")]
public static bool IsSymbol(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsUpper(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsWhiteSpace(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char c);
    [NullableContextAttribute("1")]
public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static double GetNumericValue(char c);
    [NullableContextAttribute("1")]
public static double GetNumericValue(string s, int index);
    public static bool IsHighSurrogate(char c);
    [NullableContextAttribute("1")]
public static bool IsHighSurrogate(string s, int index);
    public static bool IsLowSurrogate(char c);
    [NullableContextAttribute("1")]
public static bool IsLowSurrogate(string s, int index);
    [NullableContextAttribute("1")]
public static bool IsSurrogatePair(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    [NullableContextAttribute("1")]
public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    [StackTraceHiddenAttribute]
private static void ConvertToUtf32_ThrowInvalidArgs(UInt32 highSurrogateOffset);
    [NullableContextAttribute("1")]
public static int ConvertToUtf32(string s, int index);
    private static override char System.Numerics.IAdditionOperators<System.Char,System.Char,System.Char>.op_Addition(char left, char right);
    private static override char System.Numerics.IAdditionOperators<System.Char,System.Char,System.Char>.op_CheckedAddition(char left, char right);
    private static override char System.Numerics.IAdditiveIdentity<System.Char,System.Char>.get_AdditiveIdentity();
    private static override char System.Numerics.IBinaryInteger<System.Char>.LeadingZeroCount(char value);
    private static override char System.Numerics.IBinaryInteger<System.Char>.PopCount(char value);
    private static override char System.Numerics.IBinaryInteger<System.Char>.RotateLeft(char value, int rotateAmount);
    private static override char System.Numerics.IBinaryInteger<System.Char>.RotateRight(char value, int rotateAmount);
    private static override char System.Numerics.IBinaryInteger<System.Char>.TrailingZeroCount(char value);
    private static override bool System.Numerics.IBinaryInteger<System.Char>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Char& value);
    private static override bool System.Numerics.IBinaryInteger<System.Char>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Char& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Char>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Char>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Char>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Char>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override char System.Numerics.IBinaryNumber<System.Char>.get_AllBitsSet();
    private static override bool System.Numerics.IBinaryNumber<System.Char>.IsPow2(char value);
    private static override char System.Numerics.IBinaryNumber<System.Char>.Log2(char value);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_BitwiseAnd(char left, char right);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_BitwiseOr(char left, char right);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_ExclusiveOr(char left, char right);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_OnesComplement(char value);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_LessThan(char left, char right);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_LessThanOrEqual(char left, char right);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_GreaterThan(char left, char right);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_GreaterThanOrEqual(char left, char right);
    private static override char System.Numerics.IDecrementOperators<System.Char>.op_Decrement(char value);
    private static override char System.Numerics.IDecrementOperators<System.Char>.op_CheckedDecrement(char value);
    private static override char System.Numerics.IDivisionOperators<System.Char,System.Char,System.Char>.op_Division(char left, char right);
    private static override bool System.Numerics.IEqualityOperators<System.Char,System.Char,System.Boolean>.op_Equality(char left, char right);
    private static override bool System.Numerics.IEqualityOperators<System.Char,System.Char,System.Boolean>.op_Inequality(char left, char right);
    private static override char System.Numerics.IIncrementOperators<System.Char>.op_Increment(char value);
    private static override char System.Numerics.IIncrementOperators<System.Char>.op_CheckedIncrement(char value);
    private static override char System.Numerics.IMinMaxValue<System.Char>.get_MinValue();
    private static override char System.Numerics.IMinMaxValue<System.Char>.get_MaxValue();
    private static override char System.Numerics.IModulusOperators<System.Char,System.Char,System.Char>.op_Modulus(char left, char right);
    private static override char System.Numerics.IMultiplicativeIdentity<System.Char,System.Char>.get_MultiplicativeIdentity();
    private static override char System.Numerics.IMultiplyOperators<System.Char,System.Char,System.Char>.op_Multiply(char left, char right);
    private static override char System.Numerics.IMultiplyOperators<System.Char,System.Char,System.Char>.op_CheckedMultiply(char left, char right);
    private static override char System.Numerics.INumberBase<System.Char>.get_One();
    private static override int System.Numerics.INumberBase<System.Char>.get_Radix();
    private static override char System.Numerics.INumberBase<System.Char>.get_Zero();
    private static override char System.Numerics.INumberBase<System.Char>.Abs(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsCanonical(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsComplexNumber(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsEvenInteger(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsFinite(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsImaginaryNumber(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsInfinity(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsInteger(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNaN(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNegative(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNegativeInfinity(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNormal(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsOddInteger(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsPositive(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsPositiveInfinity(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsRealNumber(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsSubnormal(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsZero(char value);
    private static override char System.Numerics.INumberBase<System.Char>.MaxMagnitude(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.MaxMagnitudeNumber(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.MinMagnitude(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.MinMagnitudeNumber(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.Parse(string s, NumberStyles style, IFormatProvider provider);
    private static override char System.Numerics.INumberBase<System.Char>.Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertFromChecked(TOther value, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertFromSaturating(TOther value, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertFromTruncating(TOther value, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertToChecked(char value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertToSaturating(char value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertToTruncating(char value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryParse(string s, NumberStyles style, IFormatProvider provider, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Char& result);
    private static override char System.IParsable<System.Char>.Parse(string s, IFormatProvider provider);
    private static override bool System.IParsable<System.Char>.TryParse(string s, IFormatProvider provider, Char& result);
    private static override char System.Numerics.IShiftOperators<System.Char,System.Int32,System.Char>.op_LeftShift(char value, int shiftAmount);
    private static override char System.Numerics.IShiftOperators<System.Char,System.Int32,System.Char>.op_RightShift(char value, int shiftAmount);
    private static override char System.Numerics.IShiftOperators<System.Char,System.Int32,System.Char>.op_UnsignedRightShift(char value, int shiftAmount);
    private static override char System.ISpanParsable<System.Char>.Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    private static override bool System.ISpanParsable<System.Char>.TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Char& result);
    private static override char System.Numerics.ISubtractionOperators<System.Char,System.Char,System.Char>.op_Subtraction(char left, char right);
    private static override char System.Numerics.ISubtractionOperators<System.Char,System.Char,System.Char>.op_CheckedSubtraction(char left, char right);
    private static override char System.Numerics.IUnaryNegationOperators<System.Char,System.Char>.op_UnaryNegation(char value);
    private static override char System.Numerics.IUnaryNegationOperators<System.Char,System.Char>.op_CheckedUnaryNegation(char value);
    private static override char System.Numerics.IUnaryPlusOperators<System.Char,System.Char>.op_UnaryPlus(char value);
    private static override char System.IUtfChar<System.Char>.CastFrom(byte value);
    private static override char System.IUtfChar<System.Char>.CastFrom(char value);
    private static override char System.IUtfChar<System.Char>.CastFrom(int value);
    private static override char System.IUtfChar<System.Char>.CastFrom(UInt32 value);
    private static override char System.IUtfChar<System.Char>.CastFrom(ulong value);
    private static override UInt32 System.IUtfChar<System.Char>.CastToUInt32(char value);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Char>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Char>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Char>.get_MaxHexDigitCount();
    private static override char System.IBinaryIntegerParseAndFormatInfo<System.Char>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.Char>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Char>.IsGreaterThanAsUnsigned(char left, char right);
    private static override char System.IBinaryIntegerParseAndFormatInfo<System.Char>.MultiplyBy10(char value);
    private static override char System.IBinaryIntegerParseAndFormatInfo<System.Char>.MultiplyBy16(char value);
}
public class System.CharEnumerator : object {
    private string _str;
    private int _index;
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public char Current { get; }
    internal CharEnumerator(string str);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual char get_Current();
    public sealed virtual void Reset();
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    private bool _compliant;
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
    private string _tool;
    private string _version;
    public string Tool { get; }
    public string Version { get; }
    public GeneratedCodeAttribute(string tool, string version);
    public string get_Tool();
    public string get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    private TextWriter _writer;
    private string _tabString;
    private int _indentLevel;
    private bool _tabsPending;
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    public virtual void Close();
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void OutputTabs();
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<OutputTabsAsync>d__23")]
protected virtual Task OutputTabsAsync();
    [NullableContextAttribute("2")]
public virtual void Write(string s);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(float value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    [NullableContextAttribute("2")]
public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteAsync>d__37")]
public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteAsync>d__38")]
public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteAsync>d__39")]
public virtual Task WriteAsync(string value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteAsync>d__40")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteAsync>d__41")]
public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public void WriteLineNoTabs(string s);
    public Task WriteLineNoTabsAsync(string s);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string s);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteLineAsync>d__59")]
public virtual Task WriteLineAsync();
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteLineAsync>d__60")]
public virtual Task WriteLineAsync(char value);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteLineAsync>d__61")]
public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteLineAsync>d__62")]
public virtual Task WriteLineAsync(string value);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteLineAsync>d__63")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.CodeDom.Compiler.IndentedTextWriter/<WriteLineAsync>d__64")]
public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.ArrayList/ArrayListDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ArrayList : object {
    private Object[] _items;
    private int _size;
    private int _version;
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ArrayList(int capacity);
    public ArrayList(ICollection c);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    [NullableContextAttribute("2")]
public virtual object get_Item(int index);
    [NullableContextAttribute("2")]
public virtual void set_Item(int index, object value);
    public static ArrayList Adapter(IList list);
    [NullableContextAttribute("2")]
public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(object value);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    [NullableContextAttribute("2")]
public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    private void EnsureCapacity(int min);
    public static IList FixedSize(IList list);
    public static ArrayList FixedSize(ArrayList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value, int startIndex);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value, int startIndex, int count);
    [NullableContextAttribute("2")]
public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value, int startIndex);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value, int startIndex, int count);
    public static IList ReadOnly(IList list);
    public static ArrayList ReadOnly(ArrayList list);
    [NullableContextAttribute("2")]
public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual ArrayList GetRange(int index, int count);
    public virtual void Sort();
    [NullableContextAttribute("2")]
public virtual void Sort(IComparer comparer);
    [NullableContextAttribute("2")]
public virtual void Sort(int index, int count, IComparer comparer);
    public static IList Synchronized(IList list);
    public static ArrayList Synchronized(ArrayList list);
    public virtual Object[] ToArray();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Comparer : object {
    private CompareInfo _compareInfo;
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    private Comparer(SerializationInfo info, StreamingContext context);
    private static Comparer();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object a, object b);
}
internal class System.Collections.CompatibleComparer : object {
    private IHashCodeProvider _hcp;
    private IComparer _comparer;
    internal IHashCodeProvider HashCodeProvider { get; }
    internal IComparer Comparer { get; }
    internal CompatibleComparer(IHashCodeProvider hashCodeProvider, IComparer comparer);
    internal IHashCodeProvider get_HashCodeProvider();
    internal IComparer get_Comparer();
    public sealed virtual bool Equals(object a, object b);
    public int Compare(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1")]
public class System.Collections.Concurrent.ConcurrentQueue`1 : object {
    private object _crossSegmentLock;
    private ConcurrentQueueSegment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    private ConcurrentQueueSegment`1 modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public ConcurrentQueue`1(IEnumerable`1<T> collection);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryAdd(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerCollection<T>.TryTake(T& item);
    public bool get_IsEmpty();
    public sealed virtual T[] ToArray();
    public sealed virtual int get_Count();
    private static int GetCount(ConcurrentQueueSegment`1<T> s, int head, int tail);
    private static long GetCount(ConcurrentQueueSegment`1<T> head, int headHead, ConcurrentQueueSegment`1<T> tail, int tailTail);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private void SnapForObservation(ConcurrentQueueSegment`1& head, Int32& headHead, ConcurrentQueueSegment`1& tail, Int32& tailTail);
    private static T GetItemWhenAvailable(ConcurrentQueueSegment`1<T> segment, int i);
    [IteratorStateMachineAttribute("System.Collections.Concurrent.ConcurrentQueue`1/<Enumerate>d__26")]
private static IEnumerator`1<T> Enumerate(ConcurrentQueueSegment`1<T> head, int headHead, ConcurrentQueueSegment`1<T> tail, int tailTail);
    public void Enqueue(T item);
    private void EnqueueSlow(T item);
    public bool TryDequeue(T& result);
    private bool TryDequeueSlow(T& item);
    public bool TryPeek(T& result);
    private bool TryPeek(T& result, bool resultUsed);
    public void Clear();
}
[DebuggerDisplayAttribute("Capacity = {Capacity}")]
internal class System.Collections.Concurrent.ConcurrentQueueSegment`1 : object {
    internal Slot[] _slots;
    internal int _slotsMask;
    internal PaddedHeadAndTail _headAndTail;
    internal bool _preservedForObservation;
    internal bool _frozenForEnqueues;
    internal ConcurrentQueueSegment`1<T> _nextSegment;
    internal int Capacity { get; }
    internal int FreezeOffset { get; }
    internal ConcurrentQueueSegment`1(int boundedLength);
    internal int get_Capacity();
    internal int get_FreezeOffset();
    internal void EnsureFrozenForEnqueues();
    public bool TryDequeue(T& item);
    public bool TryPeek(T& result, bool resultUsed);
    public bool TryEnqueue(T item);
}
[NullableContextAttribute("1")]
public interface System.Collections.Concurrent.IProducerConsumerCollection`1 {
    public abstract virtual void CopyTo(T[] array, int index);
    public abstract virtual bool TryAdd(T item);
    public abstract virtual bool TryTake(T& item);
    public abstract virtual T[] ToArray();
}
internal class System.Collections.Concurrent.IProducerConsumerCollectionDebugView`1 : object {
    private IProducerConsumerCollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public IProducerConsumerCollectionDebugView`1(IProducerConsumerCollection`1<T> collection);
    public T[] get_Items();
}
internal interface System.Collections.Concurrent.IProducerConsumerQueue`1 {
    public bool IsEmpty { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(T item);
    public abstract virtual bool TryDequeue(T& result);
    public abstract virtual bool get_IsEmpty();
    public abstract virtual int get_Count();
    public abstract virtual int GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class System.Collections.Concurrent.MultiProducerMultiConsumerQueue`1 : ConcurrentQueue`1<T> {
    private bool System.Collections.Concurrent.IProducerConsumerQueue<T>.IsEmpty { get; }
    private int System.Collections.Concurrent.IProducerConsumerQueue<T>.Count { get; }
    private sealed virtual override void System.Collections.Concurrent.IProducerConsumerQueue<T>.Enqueue(T item);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerQueue<T>.TryDequeue(T& result);
    private sealed virtual override bool System.Collections.Concurrent.IProducerConsumerQueue<T>.get_IsEmpty();
    private sealed virtual override int System.Collections.Concurrent.IProducerConsumerQueue<T>.get_Count();
    private sealed virtual override int System.Collections.Concurrent.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
[DebuggerDisplayAttribute("Head = {Head}, Tail = {Tail}")]
internal class System.Collections.Concurrent.PaddedHeadAndTail : ValueType {
    public int Head;
    public int Tail;
}
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1/SingleProducerSingleConsumerQueue_DebugView")]
internal class System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1 : object {
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _head;
    private Segment modreq(System.Runtime.CompilerServices.IsVolatile) _tail;
    public bool IsEmpty { get; }
    public int Count { get; }
    public sealed virtual void Enqueue(T item);
    private void EnqueueSlow(T item, Segment& segment);
    public sealed virtual bool TryDequeue(T& result);
    public bool TryPeek(T& result);
    private bool TryDequeueSlow(Segment<T> segment, T[] array, bool peek, T& result);
    public sealed virtual bool get_IsEmpty();
    [IteratorStateMachineAttribute("System.Collections.Concurrent.SingleProducerSingleConsumerQueue`1/<GetEnumerator>d__15")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override int System.Collections.Concurrent.IProducerConsumerQueue<T>.GetCountSafe(object syncObj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.DictionaryEntry : ValueType {
    private object _key;
    private object _value;
    public object Key { get; public set; }
    [NullableAttribute("2")]
public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ArrayBuilder`1 : ValueType {
    private T[] _array;
    private int _count;
    public int Capacity { get; }
    public int Count { get; }
    public int get_Capacity();
    public int get_Count();
    public void Add(T item);
    public T[] ToArray();
    public void UncheckedAdd(T item);
    private void EnsureCapacity(int minimum);
}
internal class System.Collections.Generic.ArraySortHelper`1 : object {
    private static IArraySortHelper`1<T> s_defaultArraySortHelper;
    public static IArraySortHelper`1<T> Default { get; }
    private static ArraySortHelper`1();
    public static IArraySortHelper`1<T> get_Default();
    private static IArraySortHelper`1<T> CreateArraySortHelper();
    public sealed virtual void Sort(Span`1<T> keys, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(Span`1<T> keys, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(Span`1<T> keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(Span`1<T> a, int i, int j);
    internal static void IntrospectiveSort(Span`1<T> keys, Comparison`1<T> comparer);
    private static void IntroSort(Span`1<T> keys, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(Span`1<T> keys, Comparison`1<T> comparer);
    private static void HeapSort(Span`1<T> keys, Comparison`1<T> comparer);
    private static void DownHeap(Span`1<T> keys, int i, int n, Comparison`1<T> comparer);
    private static void InsertionSort(Span`1<T> keys, Comparison`1<T> comparer);
}
internal class System.Collections.Generic.ArraySortHelper`2 : object {
    private static IArraySortHelper`2<TKey, TValue> s_defaultArraySortHelper;
    public static IArraySortHelper`2<TKey, TValue> Default { get; }
    private static ArraySortHelper`2();
    public static IArraySortHelper`2<TKey, TValue> get_Default();
    private static IArraySortHelper`2<TKey, TValue> CreateArraySortHelper();
    public sealed virtual void Sort(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer, int i, int j);
    private static void Swap(Span`1<TKey> keys, Span`1<TValue> values, int i, int j);
    internal static void IntrospectiveSort(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void IntroSort(Span`1<TKey> keys, Span`1<TValue> values, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void HeapSort(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void DownHeap(Span`1<TKey> keys, Span`1<TValue> values, int i, int n, IComparer`1<TKey> comparer);
    private static void InsertionSort(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Collections.Generic.BitHelper : ValueType {
    private Span`1<int> _span;
    internal BitHelper(Span`1<int> span, bool clear);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ByteEqualityComparer : EqualityComparer`1<byte> {
    public virtual bool Equals(byte x, byte y);
    public virtual int GetHashCode(byte b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Collections.Generic.CollectionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static bool Remove(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue& value);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> AsReadOnly(IList`1<T> list);
    [ExtensionAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static void AddRange(List`1<T> list, ReadOnlySpan`1<T> source);
    [ExtensionAttribute]
public static void InsertRange(List`1<T> list, int index, ReadOnlySpan`1<T> source);
    [ExtensionAttribute]
public static void CopyTo(List`1<T> list, Span`1<T> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Collections.Generic.Comparer`1 : object {
    private static Comparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer;
    public static Comparer`1<T> Default { get; }
    public static Comparer`1<T> get_Default();
    private static Comparer`1<T> CreateComparer();
    public static Comparer`1<T> Create(Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
public abstract virtual int Compare(T x, T y);
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class System.Collections.Generic.ComparisonComparer`1 : Comparer`1<T> {
    private Comparison`1<T> _comparison;
    public ComparisonComparer`1(Comparison`1<T> comparison);
    public virtual int Compare(T x, T y);
}
internal class System.Collections.Generic.DelegateEqualityComparer`1 : EqualityComparer`1<T> {
    private Func`3<T, T, bool> _equals;
    private Func`2<T, int> _getHashCode;
    public DelegateEqualityComparer`1(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
    public virtual bool Equals(T x, T y);
    public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.Dictionary`2 : object {
    private Int32[] _buckets;
    private Entry[] _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public Dictionary`2(int capacity);
    public Dictionary`2(IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public Dictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public Dictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected Dictionary`2(SerializationInfo info, StreamingContext context);
    private void AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> enumerable);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal TValue& FindValue(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private void CopyEntries(Entry[] entries, int count);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private Int32& GetBucket(UInt32 hashCode);
}
internal class System.Collections.Generic.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
internal class System.Collections.Generic.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal class System.Collections.Generic.EnumComparer`1 : Comparer`1<T> {
    private EnumComparer`1(SerializationInfo info, StreamingContext context);
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.EnumEqualityComparer`1 : EqualityComparer`1<T> {
    private EnumEqualityComparer`1(SerializationInfo information, StreamingContext context);
    public virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode(T obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class System.Collections.Generic.EnumerableHelpers : object {
    internal static T[] ToArray(IEnumerable`1<T> source, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Collections.Generic.EqualityComparer`1 : object {
    private static EqualityComparer`1 modreq(System.Runtime.CompilerServices.IsVolatile) defaultComparer;
    public static EqualityComparer`1<T> Default { get; }
    public static EqualityComparer`1<T> get_Default();
    private static EqualityComparer`1<T> CreateComparer();
    public static EqualityComparer`1<T> Create(Func`3<T, T, bool> equals, Func`2<T, int> getHashCode);
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(T x, T y);
    public abstract virtual int GetHashCode(T obj);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    internal virtual int IndexOf(T[] array, T value, int startIndex, int count);
    internal virtual int LastIndexOf(T[] array, T value, int startIndex, int count);
}
internal class System.Collections.Generic.GenericArraySortHelper`1 : object {
    public sealed virtual void Sort(Span`1<T> keys, IComparer`1<T> comparer);
    public sealed virtual int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(T[] array, int index, int length, T value);
    private static void SwapIfGreater(T& i, T& j);
    private static void Swap(T& i, T& j);
    private static void IntroSort(Span`1<T> keys, int depthLimit);
    private static int PickPivotAndPartition(Span`1<T> keys);
    private static void HeapSort(Span`1<T> keys);
    private static void DownHeap(Span`1<T> keys, int i, int n);
    private static void InsertionSort(Span`1<T> keys);
    private static bool LessThan(T& left, T& right);
    private static bool GreaterThan(T& left, T& right);
}
internal class System.Collections.Generic.GenericArraySortHelper`2 : object {
    public sealed virtual void Sort(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(Span`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void Swap(Span`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void IntroSort(Span`1<TKey> keys, Span`1<TValue> values, int depthLimit);
    private static int PickPivotAndPartition(Span`1<TKey> keys, Span`1<TValue> values);
    private static void HeapSort(Span`1<TKey> keys, Span`1<TValue> values);
    private static void DownHeap(Span`1<TKey> keys, Span`1<TValue> values, int i, int n);
    private static void InsertionSort(Span`1<TKey> keys, Span`1<TValue> values);
    private static bool LessThan(TKey& left, TKey& right);
    private static bool GreaterThan(TKey& left, TKey& right);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.GenericComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.GenericEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System.Core, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.HashSet`1 : object {
    private Int32[] _buckets;
    private Entry[] _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<T> _comparer;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public HashSet`1(IEqualityComparer`1<T> comparer);
    public HashSet`1(int capacity);
    public HashSet`1(IEnumerable`1<T> collection);
    public HashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public HashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected HashSet`1(SerializationInfo info, StreamingContext context);
    private void ConstructFrom(HashSet`1<T> source);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private int FindItemIndex(T item);
    private Int32& GetBucketRef(int hashCode);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    public sealed virtual bool Add(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_Comparer();
    public int EnsureCapacity(int capacity);
    private void Resize();
    private void Resize(int newSize, bool forceNewHashCodes);
    public void TrimExcess();
    public static IEqualityComparer`1<HashSet`1<T>> CreateSetComparer();
    private int Initialize(int capacity);
    private bool AddIfNotPresent(T value, Int32& location);
    internal bool IsSubsetOfHashSetWithSameComparer(HashSet`1<T> other);
    private void IntersectWithHashSetWithSameComparer(HashSet`1<T> other);
    private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private void SymmetricExceptWithUniqueHashSet(HashSet`1<T> other);
    private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    private ValueTuple`2<int, int> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal static bool EqualityComparersAreEqual(HashSet`1<T> set1, HashSet`1<T> set2);
}
internal class System.Collections.Generic.HashSetEqualityComparer`1 : object {
    public sealed virtual bool Equals(HashSet`1<T> x, HashSet`1<T> y);
    public sealed virtual int GetHashCode(HashSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface System.Collections.Generic.IArraySortHelper`1 {
    public abstract virtual void Sort(Span`1<TKey> keys, IComparer`1<TKey> comparer);
    public abstract virtual int BinarySearch(TKey[] keys, int index, int length, TKey value, IComparer`1<TKey> comparer);
}
internal interface System.Collections.Generic.IArraySortHelper`2 {
    public abstract virtual void Sort(Span`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IAsyncEnumerable`1 {
    public abstract virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public interface System.Collections.Generic.IAsyncEnumerator`1 {
    [NullableAttribute("1")]
public T Current { get; }
    public abstract virtual ValueTask`1<bool> MoveNextAsync();
    [NullableContextAttribute("1")]
public abstract virtual T get_Current();
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    [DynamicDependencyAttribute("InternalArray__ICollection_get_Count", "System.Array")]
public abstract virtual int get_Count();
    [DynamicDependencyAttribute("InternalArray__ICollection_get_IsReadOnly", "System.Array")]
public abstract virtual bool get_IsReadOnly();
    [DynamicDependencyAttribute("InternalArray__ICollection_Add``1", "System.Array")]
public abstract virtual void Add(T item);
    [DynamicDependencyAttribute("InternalArray__ICollection_Clear", "System.Array")]
public abstract virtual void Clear();
    [DynamicDependencyAttribute("InternalArray__ICollection_Contains``1", "System.Array")]
public abstract virtual bool Contains(T item);
    [DynamicDependencyAttribute("InternalArray__ICollection_CopyTo``1", "System.Array")]
public abstract virtual void CopyTo(T[] array, int arrayIndex);
    [DynamicDependencyAttribute("InternalArray__ICollection_Remove``1", "System.Array")]
public abstract virtual bool Remove(T item);
}
internal class System.Collections.Generic.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("2")]
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
internal class System.Collections.Generic.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
public interface System.Collections.Generic.IEnumerable`1 {
    [NullableContextAttribute("1")]
[DynamicDependencyAttribute("InternalArray__IEnumerable_GetEnumerator``1 ", "System.Array")]
public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    [NullableAttribute("1")]
public T Current { get; }
    [NullableContextAttribute("1")]
public abstract virtual T get_Current();
}
[NullableContextAttribute("2")]
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public abstract virtual int GetHashCode(T obj);
}
internal interface System.Collections.Generic.IInternalStringEqualityComparer {
    public abstract virtual IEqualityComparer`1<string> GetUnderlyingEqualityComparer();
    internal static IEqualityComparer`1<string> GetUnderlyingEqualityComparer(IEqualityComparer`1<string> outerComparer);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    [DynamicDependencyAttribute("InternalArray__get_Item``1", "System.Array")]
public abstract virtual T get_Item(int index);
    [DynamicDependencyAttribute("InternalArray__set_Item``1", "System.Array")]
public abstract virtual void set_Item(int index, T value);
    [DynamicDependencyAttribute("InternalArray__IndexOf``1", "System.Array")]
public abstract virtual int IndexOf(T item);
    [DynamicDependencyAttribute("InternalArray__Insert``1", "System.Array")]
public abstract virtual void Insert(int index, T item);
    [DynamicDependencyAttribute("InternalArray__RemoveAt", "System.Array")]
public abstract virtual void RemoveAt(int index);
}
internal enum System.Collections.Generic.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    [DynamicDependencyAttribute("InternalArray__IReadOnlyCollection_get_Count", "System.Array")]
public abstract virtual int get_Count();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    [DynamicDependencyAttribute("InternalArray__IReadOnlyList_get_Item``1", "System.Array")]
public abstract virtual T get_Item(int index);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IReadOnlySet`1 {
    public abstract virtual bool Contains(T item);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public static class System.Collections.Generic.KeyValuePair : object {
    [NullableContextAttribute("1")]
public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
    internal static string PairToString(object key, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    [DebuggerBrowsableAttribute("0")]
private TKey key;
    [DebuggerBrowsableAttribute("0")]
private TValue value;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    public virtual string ToString();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.List`1 : object {
    internal T[] _items;
    internal int _size;
    internal int _version;
    private static T[] s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public List`1(int capacity);
    public List`1(IEnumerable`1<T> collection);
    private static List`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private static bool IsCompatibleObject(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private sealed virtual override bool System.Collections.IList.Contains(object item);
    public List`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public int EnsureCapacity(int capacity);
    internal void Grow(int capacity);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public List`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public List`1<T> GetRange(int index, int count);
    public List`1<T> Slice(int start, int length);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public sealed virtual void Insert(int index, T item);
    private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public sealed virtual bool Remove(T item);
    private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
}
public class System.Collections.Generic.NonRandomizedStringEqualityComparer : object {
    private static NonRandomizedStringEqualityComparer WrappedAroundDefaultComparer;
    private static NonRandomizedStringEqualityComparer WrappedAroundStringComparerOrdinal;
    private static NonRandomizedStringEqualityComparer WrappedAroundStringComparerOrdinalIgnoreCase;
    private IEqualityComparer`1<string> _underlyingComparer;
    private NonRandomizedStringEqualityComparer(IEqualityComparer`1<string> underlyingComparer);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected NonRandomizedStringEqualityComparer(SerializationInfo information, StreamingContext context);
    private static NonRandomizedStringEqualityComparer();
    [NullableContextAttribute("2")]
public virtual bool Equals(string x, string y);
    [NullableContextAttribute("2")]
public virtual int GetHashCode(string obj);
    internal virtual RandomizedStringEqualityComparer GetRandomizedEqualityComparer();
    public virtual IEqualityComparer`1<string> GetUnderlyingEqualityComparer();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public static IEqualityComparer`1<string> GetStringComparer(object comparer);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.NullableComparer`1 : Comparer`1<Nullable`1<T>> {
    private NullableComparer`1(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int Compare(Nullable`1<T> x, Nullable`1<T> y);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.NullableEqualityComparer`1 : EqualityComparer`1<Nullable`1<T>> {
    private NullableEqualityComparer`1(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool Equals(Nullable`1<T> x, Nullable`1<T> y);
    public virtual int GetHashCode(Nullable`1<T> obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ObjectComparer`1 : Comparer`1<T> {
    public virtual int Compare(T x, T y);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.ObjectEqualityComparer`1 : EqualityComparer`1<T> {
    public virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(T obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.QueueDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Generic.Queue`1 : object {
    private T[] _array;
    private int _head;
    private int _tail;
    private int _size;
    private int _version;
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Queue`1(int capacity);
    public Queue`1(IEnumerable`1<T> collection);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public void Clear();
    public void CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void Enqueue(T item);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T Dequeue();
    public bool TryDequeue(T& result);
    public T Peek();
    public bool TryPeek(T& result);
    public bool Contains(T item);
    public T[] ToArray();
    private void SetCapacity(int capacity);
    private void MoveNext(Int32& index);
    private void ThrowForEmptyQueue();
    public void TrimExcess();
    public int EnsureCapacity(int capacity);
    private void Grow(int capacity);
}
internal class System.Collections.Generic.QueueDebugView`1 : object {
    private Queue`1<T> _queue;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public QueueDebugView`1(Queue`1<T> queue);
    public T[] get_Items();
}
internal abstract class System.Collections.Generic.RandomizedStringEqualityComparer : EqualityComparer`1<string> {
    private MarvinSeed _seed;
    private IEqualityComparer`1<string> _underlyingComparer;
    private RandomizedStringEqualityComparer(IEqualityComparer`1<string> underlyingComparer);
    internal static RandomizedStringEqualityComparer Create(IEqualityComparer`1<string> underlyingComparer, bool ignoreCase);
    public sealed virtual IEqualityComparer`1<string> GetUnderlyingEqualityComparer();
}
public class System.Collections.Generic.ReferenceEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static ReferenceEqualityComparer <Instance>k__BackingField;
    [NullableAttribute("1")]
public static ReferenceEqualityComparer Instance { get; }
    private static ReferenceEqualityComparer();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static ReferenceEqualityComparer get_Instance();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(object obj);
}
internal static class System.Collections.Generic.SortUtils : object {
    public static int MoveNansToFront(Span`1<TKey> keys, Span`1<TValue> values);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Collections.Generic.ValueListBuilder`1 : ValueType {
    private Span`1<T> _span;
    private T[] _arrayFromPool;
    private int _pos;
    public int Length { get; public set; }
    public T& Item { get; }
    public ValueListBuilder`1(Span`1<T> initialSpan);
    public int get_Length();
    public void set_Length(int value);
    public T& get_Item(int index);
    public void Append(T item);
    public void Append(ReadOnlySpan`1<T> source);
    private void AppendMultiChar(ReadOnlySpan`1<T> source);
    public void Insert(int index, ReadOnlySpan`1<T> source);
    public Span`1<T> AppendSpan(int length);
    private Span`1<T> AppendSpanWithGrow(int length);
    private void AddWithResize(T item);
    public ReadOnlySpan`1<T> AsSpan();
    public bool TryCopyTo(Span`1<T> destination, Int32& itemsWritten);
    public void Dispose();
    private void Grow(int additionalCapacityRequired);
}
internal static class System.Collections.HashHelpers : object {
    private static ConditionalWeakTable`2<object, SerializationInfo> s_serializationInfoTable;
    internal static ReadOnlySpan`1<int> Primes { get; }
    public static ConditionalWeakTable`2<object, SerializationInfo> SerializationInfoTable { get; }
    internal static ReadOnlySpan`1<int> get_Primes();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
    public static ConditionalWeakTable`2<object, SerializationInfo> get_SerializationInfoTable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Hashtable/HashtableDebugView")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.Hashtable : object {
    private Bucket[] _buckets;
    private int _count;
    private int _occupancy;
    private int _loadsize;
    private float _loadFactor;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _version;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isWriterInProgress;
    private ICollection _keys;
    private ICollection _values;
    private IEqualityComparer _keycomparer;
    [NullableAttribute("2")]
[ObsoleteAttribute("Hashtable.hcp has been deprecated. Use the EqualityComparer property instead.")]
protected IHashCodeProvider hcp { get; protected set; }
    [NullableAttribute("2")]
[ObsoleteAttribute("Hashtable.comparer has been deprecated. Use the KeyComparer properties instead.")]
protected IComparer comparer { get; protected set; }
    [NullableAttribute("2")]
protected IEqualityComparer EqualityComparer { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public object SyncRoot { get; }
    public int Count { get; }
    internal Hashtable(bool _);
    public Hashtable(int capacity);
    public Hashtable(int capacity, float loadFactor);
    [NullableContextAttribute("2")]
public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    [NullableContextAttribute("2")]
public Hashtable(IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    [NullableContextAttribute("2")]
public Hashtable(int capacity, IEqualityComparer equalityComparer);
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, float loadFactor);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected Hashtable(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
protected IHashCodeProvider get_hcp();
    [NullableContextAttribute("2")]
protected void set_hcp(IHashCodeProvider value);
    [NullableContextAttribute("2")]
protected IComparer get_comparer();
    [NullableContextAttribute("2")]
protected void set_comparer(IComparer value);
    [NullableContextAttribute("2")]
protected IEqualityComparer get_EqualityComparer();
    private UInt32 InitHash(object key, int hashsize, UInt32& seed, UInt32& incr);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    [NullableContextAttribute("2")]
public virtual bool ContainsValue(object value);
    private void CopyKeys(Array array, int arrayIndex);
    private void CopyEntries(Array array, int arrayIndex);
    public virtual void CopyTo(Array array, int arrayIndex);
    internal virtual KeyValuePairs[] ToKeyValuePairsArray();
    private void CopyValues(Array array, int arrayIndex);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    private void expand();
    private void rehash();
    private void UpdateVersion();
    private void rehash(int newsize);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsSynchronized();
    protected virtual bool KeyEquals(object item, object key);
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    private void Insert(object key, object nvalue, bool add);
    private void putEntry(Bucket[] newBuckets, object key, object nvalue, int hashcode);
    public virtual void Remove(object key);
    public virtual object get_SyncRoot();
    public virtual int get_Count();
    public static Hashtable Synchronized(Hashtable table);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
}
[NullableContextAttribute("1")]
public interface System.Collections.ICollection {
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public abstract virtual void CopyTo(Array array, int index);
    public abstract virtual int get_Count();
    public abstract virtual object get_SyncRoot();
    public abstract virtual bool get_IsSynchronized();
}
[NullableContextAttribute("2")]
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual bool Contains(object key);
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
[NullableContextAttribute("1")]
public interface System.Collections.IDictionaryEnumerator {
    public object Key { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public DictionaryEntry Entry { get; }
    public abstract virtual object get_Key();
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
    public abstract virtual DictionaryEntry get_Entry();
}
[NullableContextAttribute("1")]
[GuidAttribute("496B0ABE-CDEE-11d3-88E8-00902754C43A")]
[ComVisibleAttribute("True")]
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual bool MoveNext();
    public abstract virtual object get_Current();
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
public interface System.Collections.IEqualityComparer {
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("IHashCodeProvider has been deprecated. Use IEqualityComparer instead.")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual bool Contains(object value);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
[NullableContextAttribute("1")]
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
[NullableContextAttribute("1")]
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[DebuggerDisplayAttribute("{_value}")]
internal class System.Collections.KeyValuePairs : object {
    [DebuggerBrowsableAttribute("0")]
private object _key;
    [DebuggerBrowsableAttribute("0")]
private object _value;
    public KeyValuePairs(object key, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ListDictionaryInternal : object {
    private DictionaryNode head;
    private int version;
    private int count;
    [NullableAttribute("2")]
public object Item { get; public set; }
    public int Count { get; }
    public ICollection Keys { get; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual int get_Count();
    public sealed virtual ICollection get_Keys();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ObjectModel.Collection`1 : object {
    private IList`1<T> items;
    public int Count { get; }
    protected IList`1<T> Items { get; }
    public T Item { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    protected IList`1<T> get_Items();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, T item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private static bool IsCompatibleObject(object value);
}
internal static class System.Collections.ObjectModel.CollectionHelpers : object {
    internal static void ValidateCopyToArguments(int sourceCount, Array array, int index);
    internal static void CopyTo(ICollection`1<T> collection, Array array, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    private IList`1<T> list;
    [CompilerGeneratedAttribute]
private static ReadOnlyCollection`1<T> <Empty>k__BackingField;
    public static ReadOnlyCollection`1<T> Empty { get; }
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    private static ReadOnlyCollection`1();
    [CompilerGeneratedAttribute]
public static ReadOnlyCollection`1<T> get_Empty();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private static bool IsCompatibleObject(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.Collections.Generic.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    private IDictionary`2<TKey, TValue> m_dictionary;
    private KeyCollection<TKey, TValue> _keys;
    private ValueCollection<TKey, TValue> _values;
    [CompilerGeneratedAttribute]
private static ReadOnlyDictionary`2<TKey, TValue> <Empty>k__BackingField;
    public static ReadOnlyDictionary`2<TKey, TValue> Empty { get; }
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    private static ReadOnlyDictionary`2();
    [CompilerGeneratedAttribute]
public static ReadOnlyDictionary`2<TKey, TValue> get_Empty();
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public KeyCollection<TKey, TValue> get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    private object _value;
    private static object s_convertFromInvariantString;
    public object Value { get; }
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Generic TypeConverters may require the generic types to be annotated. For example, NullableConverter requires the underlying type to be DynamicallyAccessedMembers All.")]
public DefaultValueAttribute(Type type, string value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(string value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
    [CompilerGeneratedAttribute]
[RequiresUnreferencedCodeAttribute("Generic TypeConverters may require the generic types to be annotated. For example, NullableConverter requires the underlying type to be DynamicallyAccessedMembers All.")]
internal static bool <.ctor>g__TryConvertFromInvariantString|2_0(Type typeToConvert, string stringValue, Object& conversionResult);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EditorBrowsableState <State>k__BackingField;
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    [CompilerGeneratedAttribute]
public EditorBrowsableState get_State();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ComponentModel.Win32Exception : ExternalException {
    [CompilerGeneratedAttribute]
private int <NativeErrorCode>k__BackingField;
    public int NativeErrorCode { get; }
    public Win32Exception(int error);
    [NullableContextAttribute("2")]
public Win32Exception(int error, string message);
    [NullableContextAttribute("2")]
public Win32Exception(string message);
    [NullableContextAttribute("2")]
public Win32Exception(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected Win32Exception(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public int get_NativeErrorCode();
    public virtual string ToString();
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ContextMarshalException : SystemException {
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ContextMarshalException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("256")]
public class System.ContextStaticAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Convert : object {
    [NullableAttribute("1")]
public static object DBNull;
    [NullableAttribute("0")]
private static ReadOnlySpan`1<sbyte> DecodingMap { get; }
    private static Convert();
    private static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> utf16, Span`1<byte> bytes, Int32& consumed, Int32& written);
    private static int Decode(Char& encodedChars, SByte& decodingMap);
    private static void WriteThreeLowOrderBytes(Byte& destination, int value);
    private static ReadOnlySpan`1<sbyte> get_DecodingMap();
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    internal static object DefaultToType(IConvertible value, Type targetType, IFormatProvider provider);
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    [DoesNotReturnAttribute]
private static void ThrowCharOverflowException();
    [DoesNotReturnAttribute]
private static void ThrowByteOverflowException();
    [DoesNotReturnAttribute]
private static void ThrowSByteOverflowException();
    [DoesNotReturnAttribute]
private static void ThrowInt16OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowUInt16OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowInt32OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowUInt32OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowInt64OverflowException();
    [DoesNotReturnAttribute]
private static void ThrowUInt64OverflowException();
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    public static bool ToBoolean(bool value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(short value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    public static bool ToBoolean(int value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    public static bool ToBoolean(long value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(DateTime value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    public static char ToChar(bool value);
    public static char ToChar(char value);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(byte value);
    public static char ToChar(short value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    public static char ToChar(int value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    public static char ToChar(long value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    [NullableContextAttribute("1")]
public static char ToChar(string value);
    [NullableContextAttribute("1")]
public static char ToChar(string value, IFormatProvider provider);
    public static char ToChar(float value);
    public static char ToChar(double value);
    public static char ToChar(decimal value);
    public static char ToChar(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(short value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    public static byte ToByte(int value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    public static byte ToByte(long value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static byte ToByte(float value);
    public static byte ToByte(double value);
    public static byte ToByte(decimal value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(DateTime value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    public static short ToInt16(bool value);
    public static short ToInt16(char value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(byte value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    public static short ToInt16(int value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    public static short ToInt16(short value);
    public static short ToInt16(long value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static short ToInt16(float value);
    public static short ToInt16(double value);
    public static short ToInt16(decimal value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    public static int ToInt32(bool value);
    public static int ToInt32(char value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(byte value);
    public static int ToInt32(short value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static int ToInt32(float value);
    public static int ToInt32(double value);
    public static int ToInt32(decimal value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    public static long ToInt64(bool value);
    public static long ToInt64(char value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(byte value);
    public static long ToInt64(short value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    public static long ToInt64(int value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    public static long ToInt64(long value);
    public static long ToInt64(float value);
    public static long ToInt64(double value);
    public static long ToInt64(decimal value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(short value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    public static float ToSingle(int value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    public static float ToSingle(long value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    public static float ToSingle(float value);
    public static float ToSingle(double value);
    public static float ToSingle(decimal value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    public static float ToSingle(bool value);
    public static float ToSingle(DateTime value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(byte value);
    public static double ToDouble(short value);
    public static double ToDouble(char value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    public static double ToDouble(int value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    public static double ToDouble(long value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    public static double ToDouble(float value);
    public static double ToDouble(double value);
    public static double ToDouble(decimal value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    public static double ToDouble(bool value);
    public static double ToDouble(DateTime value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(short value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    public static decimal ToDecimal(int value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    public static decimal ToDecimal(long value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(DateTime value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(short value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    public static DateTime ToDateTime(int value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    public static DateTime ToDateTime(long value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(decimal value);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(bool value);
    [NullableContextAttribute("1")]
public static string ToString(bool value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(char value);
    [NullableContextAttribute("1")]
public static string ToString(char value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(byte value);
    [NullableContextAttribute("1")]
public static string ToString(byte value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(short value);
    [NullableContextAttribute("1")]
public static string ToString(short value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(int value);
    [NullableContextAttribute("1")]
public static string ToString(int value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(long value);
    [NullableContextAttribute("1")]
public static string ToString(long value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(float value);
    [NullableContextAttribute("1")]
public static string ToString(float value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(double value);
    [NullableContextAttribute("1")]
public static string ToString(double value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(decimal value);
    [NullableContextAttribute("1")]
public static string ToString(decimal value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(DateTime value);
    [NullableContextAttribute("1")]
public static string ToString(DateTime value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    [NullableContextAttribute("1")]
public static string ToString(byte value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(short value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(int value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(long value, int toBase);
    private static void ThrowInvalidBase();
    private static string ToOctalString(ulong value);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, int offset, int length);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    [NullableContextAttribute("0")]
public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    [NullableContextAttribute("1")]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    [NullableContextAttribute("1")]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    [NullableContextAttribute("0")]
public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
    private static void ToBase64CharsLargeNoLineBreaks(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, int charLengthRequired);
    private static int ConvertToBase64Array(Char* outChars, Byte* inData, int offset, int length, bool insertLineBreaks);
    private static int ToBase64_CalculateAndValidateOutputLength(int inputLength, bool insertLineBreaks);
    [NullableContextAttribute("1")]
public static Byte[] FromBase64String(string s);
    [NullableContextAttribute("0")]
public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private static void CopyToTempBufferWithoutWhiteSpace(ReadOnlySpan`1<char> chars, Span`1<char> tempBuffer, Int32& consumed, Int32& charsWritten);
    [ExtensionAttribute]
private static bool IsSpace(char c);
    [NullableContextAttribute("1")]
public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    private static Byte[] FromBase64CharPtr(Char* inputPtr, int inputLength);
    private static int FromBase64_ComputeResultLength(Char* inputPtr, int inputLength);
    [NullableContextAttribute("1")]
public static Byte[] FromHexString(string s);
    [NullableContextAttribute("0")]
public static Byte[] FromHexString(ReadOnlySpan`1<char> chars);
    [NullableContextAttribute("1")]
public static string ToHexString(Byte[] inArray);
    [NullableContextAttribute("1")]
public static string ToHexString(Byte[] inArray, int offset, int length);
    [NullableContextAttribute("0")]
public static string ToHexString(ReadOnlySpan`1<byte> bytes);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.CultureAwareComparer : StringComparer {
    internal static CultureAwareComparer InvariantCaseSensitiveInstance;
    internal static CultureAwareComparer InvariantIgnoreCaseInstance;
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    internal CultureAwareComparer(CultureInfo culture, CompareOptions options);
    internal CultureAwareComparer(CompareInfo compareInfo, CompareOptions options);
    private CultureAwareComparer(SerializationInfo info, StreamingContext context);
    private static CultureAwareComparer();
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private protected virtual bool IsWellKnownCultureAwareComparerCore(CompareInfo& compareInfo, CompareOptions& compareOptions);
}
[ObsoleteAttribute("System.CurrentSystemTimeZone has been deprecated. Investigate the use of System.TimeZoneInfo.Local instead.")]
internal class System.CurrentSystemTimeZone : TimeZone {
    private long m_ticksOffset;
    private string m_standardName;
    private string m_daylightName;
    private Hashtable m_CachedDaylightChanges;
    public string StandardName { get; }
    public string DaylightName { get; }
    public virtual string get_StandardName();
    public virtual string get_DaylightName();
    internal long GetUtcOffsetFromUniversalTime(DateTime time, Boolean& isAmbiguousLocalDst);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DaylightTime GetDaylightChanges(int year);
    private static DaylightTime CreateDaylightChanges(int year);
    public virtual TimeSpan GetUtcOffset(DateTime time);
    private DaylightTime GetCachedDaylightChanges(int year);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DataMisalignedException : SystemException {
    public DataMisalignedException(string message);
    public DataMisalignedException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
private DataMisalignedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.DateOnly : ValueType {
    private int _dayNumber;
    public static DateOnly MinValue { get; }
    public static DateOnly MaxValue { get; }
    public int Year { get; }
    public int Month { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int DayNumber { get; }
    private DateOnly(int dayNumber);
    public DateOnly(int year, int month, int day);
    [NullableContextAttribute("1")]
public DateOnly(int year, int month, int day, Calendar calendar);
    private static int DayNumberFromDateTime(DateTime dt);
    private DateTime GetEquivalentDateTime();
    public static DateOnly get_MinValue();
    public static DateOnly get_MaxValue();
    public static DateOnly FromDayNumber(int dayNumber);
    public int get_Year();
    public int get_Month();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_DayNumber();
    public DateOnly AddDays(int value);
    public DateOnly AddMonths(int value);
    public DateOnly AddYears(int value);
    public static bool op_Equality(DateOnly left, DateOnly right);
    public static bool op_Inequality(DateOnly left, DateOnly right);
    public static bool op_GreaterThan(DateOnly left, DateOnly right);
    public static bool op_GreaterThanOrEqual(DateOnly left, DateOnly right);
    public static bool op_LessThan(DateOnly left, DateOnly right);
    public static bool op_LessThanOrEqual(DateOnly left, DateOnly right);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& year, Int32& month, Int32& day);
    public DateTime ToDateTime(TimeOnly time);
    public DateTime ToDateTime(TimeOnly time, DateTimeKind kind);
    public static DateOnly FromDateTime(DateTime dateTime);
    public sealed virtual int CompareTo(DateOnly value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(DateOnly value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static DateOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style);
    public static DateOnly ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats);
    public static DateOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateOnly Parse(string s);
    [NullableContextAttribute("1")]
public static DateOnly Parse(string s, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, string format);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, String[] formats);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateOnly& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    private static ParseFailureKind TryParseInternal(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    private static ParseFailureKind TryParseExactInternal(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    private static ParseFailureKind TryParseExactInternal(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    private static void ThrowOnError(ParseFailureKind result, ReadOnlySpan`1<char> s);
    [NullableContextAttribute("1")]
public string ToLongDateString();
    [NullableContextAttribute("1")]
public string ToShortDateString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private bool TryFormatCore(Span`1<TChar> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override DateOnly Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, DateOnly& result);
    public static override DateOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateOnly& result);
    [CompilerGeneratedAttribute]
internal static void <AddDays>g__ThrowOutOfRange|25_0();
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DateTime : ValueType {
    internal static int MicrosecondsPerMillisecond;
    private static long TicksPerMicrosecond;
    private static long TicksPerMillisecond;
    private static int HoursPerDay;
    private static long TicksPerSecond;
    private static long TicksPerMinute;
    private static long TicksPerHour;
    private static long TicksPerDay;
    private static int MillisPerSecond;
    private static int MillisPerMinute;
    private static int MillisPerHour;
    private static int MillisPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1601;
    private static int DaysTo1899;
    internal static int DaysTo1970;
    private static int DaysTo10000;
    internal static long MinTicks;
    internal static long MaxTicks;
    private static long MaxMicroseconds;
    private static long MaxMillis;
    private static long MaxSeconds;
    private static long MaxMinutes;
    private static long MaxHours;
    private static long MaxDays;
    internal static long UnixEpochTicks;
    private static long FileTimeOffset;
    private static long DoubleDateOffset;
    private static long OADateMinAsTicks;
    private static double OADateMinAsDouble;
    private static double OADateMaxAsDouble;
    private static UInt32 EafMultiplier;
    private static UInt32 EafDivider;
    private static ulong TicksPer6Hours;
    private static int March1BasedDayOfNewYear;
    public static DateTime MinValue;
    public static DateTime MaxValue;
    public static DateTime UnixEpoch;
    private static ulong TicksMask;
    private static ulong FlagsMask;
    private static long TicksCeiling;
    private static ulong KindUnspecified;
    private static ulong KindUtc;
    private static ulong KindLocal;
    private static ulong KindLocalAmbiguousDst;
    private static int KindShift;
    private static string TicksField;
    private static string DateDataField;
    private ulong _dateData;
    internal static ReadOnlySpan`1<UInt32> DaysToMonth365 { get; }
    internal static ReadOnlySpan`1<UInt32> DaysToMonth366 { get; }
    private static ReadOnlySpan`1<byte> DaysInMonth365 { get; }
    private static ReadOnlySpan`1<byte> DaysInMonth366 { get; }
    private ulong UTicks { get; }
    private ulong InternalKind { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Millisecond { get; }
    public int Microsecond { get; }
    public int Nanosecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public int Year { get; }
    public static DateTime UtcNow { get; }
    public DateTime(long ticks);
    private DateTime(ulong dateData);
    public DateTime(long ticks, DateTimeKind kind);
    public DateTime(DateOnly date, TimeOnly time);
    public DateTime(DateOnly date, TimeOnly time, DateTimeKind kind);
    internal DateTime(long ticks, DateTimeKind kind, bool isAmbiguousDst);
    public DateTime(int year, int month, int day);
    [NullableContextAttribute("1")]
public DateTime(int year, int month, int day, Calendar calendar);
    [NullableContextAttribute("1")]
public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    [NullableContextAttribute("1")]
public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    [NullableContextAttribute("1")]
public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, DateTimeKind kind);
    [NullableContextAttribute("1")]
public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar);
    [NullableContextAttribute("1")]
public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, DateTimeKind kind);
    private DateTime(SerializationInfo info, StreamingContext context);
    private static DateTime();
    internal static ReadOnlySpan`1<UInt32> get_DaysToMonth365();
    internal static ReadOnlySpan`1<UInt32> get_DaysToMonth366();
    private static ReadOnlySpan`1<byte> get_DaysInMonth365();
    private static ReadOnlySpan`1<byte> get_DaysInMonth366();
    internal static DateTime UnsafeCreate(long ticks);
    private static void ThrowTicksOutOfRange();
    private static void ThrowInvalidKind();
    private static void ThrowMillisecondOutOfRange();
    private static void ThrowMicrosecondOutOfRange();
    private static void ThrowDateArithmetic(int param);
    private static void ThrowAddOutOfRange();
    private static ulong Init(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    private ulong get_UTicks();
    private ulong get_InternalKind();
    public DateTime Add(TimeSpan value);
    private DateTime AddUnits(double value, long maxUnitCount, long ticksPerUnit);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMicroseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    internal bool TryAddTicks(long value, DateTime& result);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(DateTime value);
    private static ulong DateToTicks(int year, int month, int day);
    private static UInt32 DaysToYear(UInt32 year);
    private static ulong TimeToTicks(int hour, int minute, int second);
    internal static ulong TimeToTicks(int hour, int minute, int second, int millisecond);
    internal static ulong TimeToTicks(int hour, int minute, int second, int millisecond, int microsecond);
    public static int DaysInMonth(int year, int month);
    internal static long DoubleDateToTicks(double value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    public static DateTime FromBinary(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsDaylightSavingTime();
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public long ToBinary();
    public DateTime get_Date();
    internal void GetDate(Int32& year, Int32& month, Int32& day);
    internal void GetTime(Int32& hour, Int32& minute, Int32& second);
    internal void GetTime(Int32& hour, Int32& minute, Int32& second, Int32& millisecond);
    internal void GetTimePrecise(Int32& hour, Int32& minute, Int32& second, Int32& tick);
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public virtual int GetHashCode();
    public int get_Hour();
    internal bool IsAmbiguousDaylightSavingTime();
    public DateTimeKind get_Kind();
    public int get_Millisecond();
    public int get_Microsecond();
    public int get_Nanosecond();
    public int get_Minute();
    public int get_Month();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public int get_Year();
    public static bool IsLeapYear(int year);
    [NullableContextAttribute("1")]
public static DateTime Parse(string s);
    [NullableContextAttribute("1")]
public static override DateTime Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private static double TicksToOADate(long value);
    public double ToOADate();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    [NullableContextAttribute("1")]
public string ToLongDateString();
    [NullableContextAttribute("1")]
public string ToLongTimeString();
    [NullableContextAttribute("1")]
public string ToShortDateString();
    [NullableContextAttribute("1")]
public string ToShortTimeString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    [NullableContextAttribute("2")]
public static bool TryParse(string s, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(DateOnly& date, TimeOnly& time);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& year, Int32& month, Int32& day);
    [NullableContextAttribute("1")]
public String[] GetDateTimeFormats();
    [NullableContextAttribute("1")]
public String[] GetDateTimeFormats(IFormatProvider provider);
    [NullableContextAttribute("1")]
public String[] GetDateTimeFormats(char format);
    [NullableContextAttribute("1")]
public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private static InvalidCastException InvalidCast(string to);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    internal static bool TryCreate(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTime& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, DateTime& result);
    public static override DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTime& result);
    public static DateTime get_UtcNow();
    internal static bool IsValidTimeWithLeapSeconds(int year, int month, int day, int hour, int minute, DateTimeKind kind);
}
internal static class System.DateTimeFormat : object {
    internal static DateTimeFormatInfo InvariantFormatInfo;
    private static String[] s_invariantAbbreviatedMonthNames;
    private static String[] s_invariantAbbreviatedDayNames;
    internal static String[] fixedNumberFormats;
    private static DateTimeFormat();
    internal static void FormatDigits(ValueListBuilder`1& outputBuffer, int value, int minimumLength);
    internal static int ParseRepeatPattern(ReadOnlySpan`1<char> format, int pos, char patternChar);
    private static string FormatDayOfWeek(int dayOfWeek, int repeat, DateTimeFormatInfo dtfi);
    private static string FormatMonth(int month, int repeatCount, DateTimeFormatInfo dtfi);
    private static string FormatHebrewMonthName(DateTime time, int month, int repeatCount, DateTimeFormatInfo dtfi);
    internal static int ParseQuoteString(ReadOnlySpan`1<char> format, int pos, ValueListBuilder`1& result);
    internal static int ParseNextChar(ReadOnlySpan`1<char> format, int pos);
    private static bool IsUseGenitiveForm(ReadOnlySpan`1<char> format, int index, int tokenLen, char patternToMatch);
    private static void FormatCustomized(DateTime dateTime, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, TimeSpan offset, ValueListBuilder`1& result);
    internal static void AppendChar(ValueListBuilder`1& result, char ch);
    private static void AppendString(ValueListBuilder`1& result, ReadOnlySpan`1<char> s);
    internal static void FormatFraction(ValueListBuilder`1& result, int fraction, ReadOnlySpan`1<char> fractionFormat);
    private static void FormatCustomizedTimeZone(DateTime dateTime, TimeSpan offset, int tokenLen, bool timeOnly, ValueListBuilder`1& result);
    private static void FormatCustomizedRoundripTimeZone(DateTime dateTime, TimeSpan offset, ValueListBuilder`1& result);
    internal static string ExpandStandardFormatToCustomPattern(char format, DateTimeFormatInfo dtfi);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider);
    internal static string Format(DateTime dateTime, string format, IFormatProvider provider, TimeSpan offset);
    internal static bool TryFormat(DateTime dateTime, Span`1<TChar> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    internal static bool TryFormat(DateTime dateTime, Span`1<TChar> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider, TimeSpan offset);
    private static bool IsTimeOnlySpecialCase(DateTime dateTime, DateTimeFormatInfo dtfi);
    private static void PrepareFormatU(DateTime& dateTime, DateTimeFormatInfo& dtfi, TimeSpan offset);
    internal static bool IsValidCustomDateOnlyFormat(ReadOnlySpan`1<char> format, bool throwOnError);
    internal static bool IsValidCustomTimeOnlyFormat(ReadOnlySpan`1<char> format, bool throwOnError);
    internal static bool TryFormatTimeOnlyO(int hour, int minute, int second, long fraction, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatTimeOnlyR(int hour, int minute, int second, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatDateOnlyO(int year, int month, int day, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatDateOnlyR(DayOfWeek dayOfWeek, int year, int month, int day, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatO(DateTime dateTime, TimeSpan offset, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatS(DateTime dateTime, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatu(DateTime dateTime, TimeSpan offset, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatR(DateTime dateTime, TimeSpan offset, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryFormatInvariantG(DateTime value, TimeSpan offset, Span`1<TChar> destination, Int32& bytesWritten);
    internal static String[] GetAllDateTimes(DateTime dateTime, char format, DateTimeFormatInfo dtfi);
    internal static String[] GetAllDateTimes(DateTime dateTime, DateTimeFormatInfo dtfi);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DateTimeOffset : ValueType {
    public static DateTimeOffset MinValue;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset UnixEpoch;
    private DateTime _dateTime;
    private short _offsetMinutes;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_androidTZDataLoaded;
    public static DateTimeOffset UtcNow { get; }
    public DateTime DateTime { get; }
    public DateTime UtcDateTime { get; }
    public DateTime LocalDateTime { get; }
    private DateTime ClockDateTime { get; }
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public int Millisecond { get; }
    public int Microsecond { get; }
    public int Nanosecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public TimeSpan Offset { get; }
    public int TotalOffsetMinutes { get; }
    public int Second { get; }
    public long Ticks { get; }
    public long UtcTicks { get; }
    public TimeSpan TimeOfDay { get; }
    public int Year { get; }
    public static DateTimeOffset Now { get; }
    private DateTimeOffset(short validOffsetMinutes, DateTime validDateTime);
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    public DateTimeOffset(DateOnly date, TimeOnly time, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    [NullableContextAttribute("1")]
public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, TimeSpan offset);
    [NullableContextAttribute("1")]
public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, TimeSpan offset);
    private DateTimeOffset(SerializationInfo info, StreamingContext context);
    private static DateTimeOffset();
    public static DateTimeOffset get_UtcNow();
    public DateTime get_DateTime();
    public DateTime get_UtcDateTime();
    public DateTime get_LocalDateTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    private DateTime get_ClockDateTime();
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public int get_Millisecond();
    public int get_Microsecond();
    public int get_Nanosecond();
    public int get_Minute();
    public int get_Month();
    public TimeSpan get_Offset();
    public int get_TotalOffsetMinutes();
    public int get_Second();
    public long get_Ticks();
    public long get_UtcTicks();
    public TimeSpan get_TimeOfDay();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMicroseconds(double microseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(DateTimeOffset other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DateTimeOffset other);
    public bool EqualsExact(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input);
    [NullableContextAttribute("1")]
public static override DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    public long ToFileTime();
    public long ToUnixTimeSeconds();
    public long ToUnixTimeMilliseconds();
    public DateTimeOffset ToLocalTime();
    internal DateTimeOffset ToLocalTime(bool throwOnOverflow);
    private static DateTimeOffset ToLocalTime(DateTime utcDateTime, bool throwOnOverflow);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    [NullableContextAttribute("2")]
public static bool TryParse(string input, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    private static short ValidateOffset(TimeSpan offset);
    private static DateTime ValidateDate(DateTime dateTime, TimeSpan offset);
    private static DateTimeStyles ValidateStyles(DateTimeStyles style, string parameterName);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(DateOnly& date, TimeOnly& time, TimeSpan& offset);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, DateTimeOffset& result);
    public static override DateTimeOffset Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeOffset& result);
    public static DateTimeOffset get_Now();
}
internal static class System.DateTimeParse : object {
    private static DS[][] s_dateParsingStates;
    private static DateTimeParse();
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style);
    internal static DateTime ParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result, TimeSpan& offset);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTime& result);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> s, String[] formats, DateTimeFormatInfo dtfi, DateTimeStyles style, DateTimeResult& result);
    private static bool MatchWord(__DTString& str, string target);
    private static bool GetTimeZoneName(__DTString& str);
    private static bool ParseFraction(__DTString& str, Double& result);
    private static bool ParseTimeZone(__DTString& str, TimeSpan& result);
    private static bool HandleTimeZone(__DTString& str, DateTimeResult& result);
    private static bool Lex(DS dps, __DTString& str, DateTimeToken& dtok, DateTimeRawInfo& raw, DateTimeResult& result, DateTimeFormatInfo& dtfi, DateTimeStyles styles);
    private static bool VerifyValidPunctuation(__DTString& str);
    private static bool GetYearMonthDayOrder(string datePattern, Int32& order);
    private static bool GetYearMonthOrder(string pattern, Int32& order);
    private static bool GetMonthDayOrder(string pattern, Int32& order);
    private static bool TryAdjustYear(DateTimeResult& result, int year, Int32& adjustedYear);
    private static bool SetDateYMD(DateTimeResult& result, int year, int month, int day);
    private static bool SetDateMDY(DateTimeResult& result, int month, int day, int year);
    private static bool SetDateDMY(DateTimeResult& result, int day, int month, int year);
    private static bool SetDateYDM(DateTimeResult& result, int year, int day, int month);
    private static void GetDefaultYear(DateTimeResult& result, DateTimeStyles& styles);
    private static bool GetDayOfNN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMN(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetHebrewDayOfNM(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNM(DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfMNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYNN(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfNNY(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool GetDayOfYMN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDayOfYM(DateTimeResult& result, DateTimeRawInfo& raw);
    private static void AdjustTimeMark(DateTimeFormatInfo dtfi, DateTimeRawInfo& raw);
    private static bool AdjustHour(Int32& hour, TM timeMark);
    private static bool GetTimeOfN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetTimeOfNNN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfDSN(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNDS(DateTimeResult& result, DateTimeRawInfo& raw);
    private static bool GetDateOfNNDS(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    private static bool ProcessDateTimeSuffix(DateTimeResult& result, DateTimeRawInfo& raw, DateTimeToken& dtok);
    internal static bool ProcessHebrewTerminalState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static bool ProcessTerminalState(DS dps, DateTimeResult& result, DateTimeStyles& styles, DateTimeRawInfo& raw, DateTimeFormatInfo dtfi);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles);
    internal static DateTime Parse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTime& result, TimeSpan& offset);
    internal static bool TryParse(ReadOnlySpan`1<char> s, DateTimeFormatInfo dtfi, DateTimeStyles styles, DateTimeResult& result);
    private static bool DetermineTimeZoneAdjustments(DateTimeResult& result, DateTimeStyles styles, bool bTimeOnly);
    private static bool DateTimeOffsetTimeZonePostProcessing(DateTimeResult& result, DateTimeStyles styles);
    private static bool AdjustTimeZoneToUniversal(DateTimeResult& result);
    private static bool AdjustTimeZoneToLocal(DateTimeResult& result, bool bTimeOnly);
    private static bool ParseISO8601(DateTimeRawInfo& raw, __DTString& str, DateTimeStyles styles, DateTimeResult& result);
    internal static bool MatchHebrewDigits(__DTString& str, Int32& number);
    internal static bool ParseDigits(__DTString& str, int digitLen, Int32& result);
    internal static bool ParseDigits(__DTString& str, int minDigitLen, int maxDigitLen, Int32& result);
    private static bool ParseFractionExact(__DTString& str, int maxDigitLen, Double& result);
    private static bool ParseSign(__DTString& str, Boolean& result);
    private static bool ParseTimeZoneOffset(__DTString& str, int len, TimeSpan& result);
    private static bool MatchAbbreviatedMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchMonthName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchAbbreviatedDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchDayName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static void SetIfStartsWith(ReadOnlySpan`1<char> span, string match, int matchResult, Int32& result, Int32& maxMatchStrLen);
    private static bool MatchEraName(__DTString& str, DateTimeFormatInfo dtfi, Int32& result);
    private static bool MatchTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool MatchAbbreviatedTimeMark(__DTString& str, DateTimeFormatInfo dtfi, TM& result);
    private static bool CheckNewValue(Int32& currentValue, int newValue, char patternChar, DateTimeResult& result);
    private static DateTime GetDateTimeNow(DateTimeResult& result, DateTimeStyles& styles);
    private static bool CheckDefaultDateTime(DateTimeResult& result, Calendar& cal, DateTimeStyles styles);
    private static string ExpandPredefinedFormat(char format, DateTimeFormatInfo& dtfi, ParsingInfo& parseInfo, DateTimeResult& result);
    private static bool ParseJapaneseEraStart(__DTString& str, DateTimeFormatInfo dtfi);
    private static bool ParseByFormat(__DTString& str, __DTString& format, ParsingInfo& parseInfo, DateTimeFormatInfo dtfi, DateTimeResult& result);
    internal static bool TryParseQuoteString(ReadOnlySpan`1<char> format, int pos, ValueStringBuilder& result, Int32& returnValue);
    private static bool DoStrictParse(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> formatParam, DateTimeStyles styles, DateTimeFormatInfo dtfi, DateTimeResult& result);
    private static bool TryParseFormatR(ReadOnlySpan`1<char> source, DateTimeResult& result);
    private static bool TryParseFormatO(ReadOnlySpan`1<char> source, DateTimeResult& result);
    private static Exception GetDateTimeParseException(DateTimeResult& result);
}
internal class System.DateTimeRawInfo : ValueType {
    private Int32* num;
    internal int numCount;
    internal int month;
    internal int year;
    internal int dayOfWeek;
    internal int era;
    internal TM timeMark;
    internal double fraction;
    internal bool hasSameDateAndTimeSeparators;
    internal void Init(Int32* numberBuffer);
    internal void AddNumber(int value);
    internal int GetNumber(int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.DateTimeResult : ValueType {
    internal int Year;
    internal int Month;
    internal int Day;
    internal int Hour;
    internal int Minute;
    internal int Second;
    internal double fraction;
    internal int era;
    internal ParseFlags flags;
    internal TimeSpan timeZoneOffset;
    internal Calendar calendar;
    internal DateTime parsedDate;
    internal ParseFailureKind failure;
    internal object failureMessageFormatArgument;
    internal string failureArgumentName;
    internal ReadOnlySpan`1<char> originalDateTimeString;
    internal ReadOnlySpan`1<char> failedFormatSpecifier;
    internal void Init(ReadOnlySpan`1<char> originalDateTimeString);
    internal void SetDate(int year, int month, int day);
    internal void SetBadFormatSpecifierFailure();
    internal void SetBadFormatSpecifierFailure(ReadOnlySpan`1<char> failedFormatSpecifier);
    internal void SetBadDateTimeFailure();
    internal void SetFailure(ParseFailureKind failure);
    internal void SetFailure(ParseFailureKind failure, object failureMessageFormatArgument);
    internal void SetFailure(ParseFailureKind failure, object failureMessageFormatArgument, string failureArgumentName);
}
internal class System.DateTimeToken : ValueType {
    internal DTT dtt;
    internal TokenType suffix;
    internal int num;
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.DBNull : object {
    public static DBNull Value;
    private static DBNull();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
}
[IsReadOnlyAttribute]
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Decimal : ValueType {
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
private static decimal AdditiveIdentity;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
private static decimal MultiplicativeIdentity;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
private static decimal NegativeOne;
    private int _flags;
    private UInt32 _hi32;
    private ulong _lo64;
    public byte Scale { get; }
    private sbyte Exponent { get; }
    private static decimal System.Numerics.IAdditiveIdentity<System.Decimal,System.Decimal>.AdditiveIdentity { get; }
    private static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.E { get; }
    private static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Pi { get; }
    private static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Tau { get; }
    private static decimal System.Numerics.IMinMaxValue<System.Decimal>.MinValue { get; }
    private static decimal System.Numerics.IMinMaxValue<System.Decimal>.MaxValue { get; }
    private static decimal System.Numerics.IMultiplicativeIdentity<System.Decimal,System.Decimal>.MultiplicativeIdentity { get; }
    private static decimal System.Numerics.INumberBase<System.Decimal>.One { get; }
    private static int System.Numerics.INumberBase<System.Decimal>.Radix { get; }
    private static decimal System.Numerics.INumberBase<System.Decimal>.Zero { get; }
    private static decimal System.Numerics.ISignedNumber<System.Decimal>.NegativeOne { get; }
    internal UInt32 High { get; }
    internal UInt32 Low { get; }
    internal UInt32 Mid { get; }
    internal ulong Low64 { get; }
    public Decimal(int value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    public Decimal(long value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public Decimal(float value);
    public Decimal(double value);
    private Decimal(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public Decimal(Int32[] bits);
    public Decimal(ReadOnlySpan`1<int> bits);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    private Decimal(int lo, int mid, int hi, int flags);
    private Decimal(Decimal& d, int flags);
    private static Decimal();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static decimal FromOACurrency(long cy);
    public static long ToOACurrency(decimal value);
    private static bool IsValid(int flags);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public byte get_Scale();
    private sbyte get_Exponent();
    public static decimal Add(decimal d1, decimal d2);
    public static override decimal Ceiling(decimal d);
    public static int Compare(decimal d1, decimal d2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(decimal value);
    public static decimal Divide(decimal d1, decimal d2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(decimal value);
    public virtual int GetHashCode();
    public static bool Equals(decimal d1, decimal d2);
    public static override decimal Floor(decimal d);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static decimal Parse(string s);
    [NullableContextAttribute("1")]
public static decimal Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override decimal Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Decimal& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    [NullableContextAttribute("1")]
public static Int32[] GetBits(decimal d);
    public static int GetBits(decimal d, Span`1<int> destination);
    public static bool TryGetBits(decimal d, Span`1<int> destination, Int32& valuesWritten);
    internal static void GetBytes(Decimal& d, Span`1<byte> buffer);
    internal static decimal ToDecimal(ReadOnlySpan`1<byte> span);
    public static decimal Remainder(decimal d1, decimal d2);
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static override decimal Round(decimal d);
    public static override decimal Round(decimal d, int decimals);
    public static override decimal Round(decimal d, MidpointRounding mode);
    public static override decimal Round(decimal d, int decimals, MidpointRounding mode);
    private static decimal Round(Decimal& d, int decimals, MidpointRounding mode);
    public static decimal Subtract(decimal d1, decimal d2);
    public static byte ToByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static short ToInt16(decimal value);
    public static double ToDouble(decimal d);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static float ToSingle(decimal d);
    public static override decimal Truncate(decimal d);
    private static void Truncate(Decimal& d);
    public static decimal op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    public static decimal op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static decimal op_Explicit(float value);
    public static decimal op_Explicit(double value);
    public static byte op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static override decimal op_UnaryPlus(decimal d);
    public static override decimal op_UnaryNegation(decimal d);
    public static override decimal op_Increment(decimal d);
    public static override decimal op_Decrement(decimal d);
    public static override decimal op_Addition(decimal d1, decimal d2);
    public static override decimal op_Subtraction(decimal d1, decimal d2);
    public static override decimal op_Multiply(decimal d1, decimal d2);
    public static override decimal op_Division(decimal d1, decimal d2);
    public static override decimal op_Modulus(decimal d1, decimal d2);
    public static override bool op_Equality(decimal d1, decimal d2);
    public static override bool op_Inequality(decimal d1, decimal d2);
    public static override bool op_LessThan(decimal d1, decimal d2);
    public static override bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static override bool op_GreaterThan(decimal d1, decimal d2);
    public static override bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override decimal System.Numerics.IAdditiveIdentity<System.Decimal,System.Decimal>.get_AdditiveIdentity();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetSignificandByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetSignificandBitLength();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override decimal System.Numerics.IFloatingPointConstants<System.Decimal>.get_E();
    private static override decimal System.Numerics.IFloatingPointConstants<System.Decimal>.get_Pi();
    private static override decimal System.Numerics.IFloatingPointConstants<System.Decimal>.get_Tau();
    private static override decimal System.Numerics.IMinMaxValue<System.Decimal>.get_MinValue();
    private static override decimal System.Numerics.IMinMaxValue<System.Decimal>.get_MaxValue();
    private static override decimal System.Numerics.IMultiplicativeIdentity<System.Decimal,System.Decimal>.get_MultiplicativeIdentity();
    public static override decimal Clamp(decimal value, decimal min, decimal max);
    public static override decimal CopySign(decimal value, decimal sign);
    public static override decimal Max(decimal x, decimal y);
    private static override decimal System.Numerics.INumber<System.Decimal>.MaxNumber(decimal x, decimal y);
    public static override decimal Min(decimal x, decimal y);
    private static override decimal System.Numerics.INumber<System.Decimal>.MinNumber(decimal x, decimal y);
    public static override int Sign(decimal d);
    private static override decimal System.Numerics.INumberBase<System.Decimal>.get_One();
    private static override int System.Numerics.INumberBase<System.Decimal>.get_Radix();
    private static override decimal System.Numerics.INumberBase<System.Decimal>.get_Zero();
    public static override decimal Abs(decimal value);
    [NullableContextAttribute("1")]
public static override decimal CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override decimal CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override decimal CreateTruncating(TOther value);
    public static override bool IsCanonical(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsComplexNumber(decimal value);
    public static override bool IsEvenInteger(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsFinite(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsImaginaryNumber(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsInfinity(decimal value);
    public static override bool IsInteger(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsNaN(decimal value);
    public static override bool IsNegative(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsNegativeInfinity(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsNormal(decimal value);
    public static override bool IsOddInteger(decimal value);
    public static override bool IsPositive(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsPositiveInfinity(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsRealNumber(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsSubnormal(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsZero(decimal value);
    public static override decimal MaxMagnitude(decimal x, decimal y);
    private static override decimal System.Numerics.INumberBase<System.Decimal>.MaxMagnitudeNumber(decimal x, decimal y);
    public static override decimal MinMagnitude(decimal x, decimal y);
    private static override decimal System.Numerics.INumberBase<System.Decimal>.MinMagnitudeNumber(decimal x, decimal y);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromChecked(TOther value, Decimal& result);
    private static bool TryConvertFromChecked(TOther value, Decimal& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromSaturating(TOther value, Decimal& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromTruncating(TOther value, Decimal& result);
    private static bool TryConvertFrom(TOther value, Decimal& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertToChecked(decimal value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertToSaturating(decimal value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertToTruncating(decimal value, TOther& result);
    private static bool TryConvertTo(decimal value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Decimal& result);
    private static override decimal System.Numerics.ISignedNumber<System.Decimal>.get_NegativeOne();
    public static override decimal Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Decimal& result);
    public static override decimal Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static override decimal Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Decimal& result);
    internal UInt32 get_High();
    internal UInt32 get_Low();
    internal UInt32 get_Mid();
    internal ulong get_Low64();
    private static DecCalc& AsMutable(Decimal& d);
    internal static UInt32 DecDivMod1E9(Decimal& value);
}
internal class System.DefaultBinder : Binder {
    private static Primitives[] s_primitiveConversions;
    private static DefaultBinder();
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
public sealed virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    public sealed virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public sealed virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificField(FieldInfo cur1, FieldInfo cur2);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    public static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    private static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static void ReorderParams(Int32[] paramOrder, Object[] vars);
    private static bool CreateParamOrder(Int32[] paramOrder, ParameterInfo[] pars, String[] names);
    internal static bool CanChangePrimitive(Type source, Type target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Delegate : object {
    private IntPtr method_ptr;
    private IntPtr invoke_impl;
    private object _target;
    private IntPtr method;
    private IntPtr delegate_trampoline;
    private IntPtr extra_arg;
    private IntPtr method_code;
    private IntPtr interp_method;
    private IntPtr interp_invoke_impl;
    private MethodInfo method_info;
    private MethodInfo original_method_info;
    private DelegateData data;
    private bool method_is_virtual;
    private bool bound;
    [NullableAttribute("2")]
public object Target { get; }
    public MethodInfo Method { get; }
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    [NullableContextAttribute("2")]
public object get_Target();
    internal virtual object GetTarget();
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    private static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure, bool allowClosed);
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    private static MethodInfo GetCandidateMethod(RuntimeType type, Type target, string method, BindingFlags bflags, bool ignoreCase);
    private static bool IsMatchingCandidate(RuntimeType type, object target, MethodInfo method, bool allowClosed, DelegateData& delegateData);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
private static MethodInfo GetDelegateInvokeMethod(RuntimeType type);
    private static bool IsReturnTypeMatch(Type delReturnType, Type returnType);
    private static bool IsArgumentTypeMatch(Type delArgType, Type argType);
    private static bool IsArgumentTypeMatchWithThis(Type delArgType, Type argType, bool boxedThis);
    [NullableContextAttribute("2")]
protected virtual object DynamicInvokeImpl(Object[] args);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual MethodInfo GetMethodImpl();
    private DelegateData CreateDelegateData();
    private static bool InternalEqualTypes(object source, object value);
    private protected static MulticastDelegate AllocDelegateLike_internal(Delegate d);
    private static Delegate CreateDelegate_internal(QCallTypeHandle type, object target, MethodInfo info, bool throwOnBindFailure);
    private MethodInfo GetVirtualMethod_internal();
    public virtual object Clone();
    [NullableContextAttribute("2")]
public static Delegate Combine(Delegate a, Delegate b);
    [NullableContextAttribute("2")]
public static Delegate Combine(Delegate[] delegates);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
public static Delegate CreateDelegate(Type type, object target, string method);
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    protected virtual Delegate CombineImpl(Delegate d);
    protected virtual Delegate RemoveImpl(Delegate d);
    public virtual Delegate[] GetInvocationList();
    [NullableContextAttribute("2")]
public object DynamicInvoke(Object[] args);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public MethodInfo get_Method();
    [NullableContextAttribute("2")]
public static Delegate Remove(Delegate source, Delegate value);
    [NullableContextAttribute("2")]
public static Delegate RemoveAll(Delegate source, Delegate value);
    [NullableContextAttribute("2")]
public static bool op_Equality(Delegate d1, Delegate d2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Delegate d1, Delegate d2);
}
internal class System.DelegateData : object {
    public Type target_type;
    public string method_name;
    public bool curried_first_arg;
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Max>k__BackingField;
    public object Min { get; public set; }
    public object Max { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(object value);
    [CompilerGeneratedAttribute]
public object get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(object value);
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
public class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
public enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
    public static DynamicallyAccessedMemberTypes All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
public class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("749")]
public class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Justification { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
public class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("736")]
public class System.Diagnostics.CodeAnalysis.RequiresAssemblyFilesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public RequiresAssemblyFilesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
public class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
public class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32")]
public class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public SuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Category();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
[AttributeUsageAttribute("2240")]
public class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ConditionString>k__BackingField;
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    [CompilerGeneratedAttribute]
public string get_ConditionString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Diagnostics.Contracts.Contract : object {
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assume(bool condition, string userMessage);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Assert(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Requires(bool condition, string userMessage);
    [NullableContextAttribute("0")]
public static void Requires(bool condition);
    [NullableContextAttribute("0")]
public static void Requires(bool condition, string userMessage);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Ensures(bool condition, string userMessage);
    [NullableContextAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition);
    [NullableContextAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void EnsuresOnThrow(bool condition, string userMessage);
    public static T Result();
    public static T ValueAtReturn(T& value);
    public static T OldValue(T value);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition);
    [NullableContextAttribute("2")]
[ConditionalAttribute("CONTRACTS_FULL")]
public static void Invariant(bool condition, string userMessage);
    public static bool ForAll(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool ForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    public static bool Exists(int fromInclusive, int toExclusive, Predicate`1<int> predicate);
    public static bool Exists(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ConditionalAttribute("CONTRACTS_FULL")]
public static void EndContractBlock();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static void AssertMustUseRewriter(ContractFailureKind kind, string contractKind);
    [DebuggerNonUserCodeAttribute]
private static void ReportFailure(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    public static void add_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    public static void remove_ContractFailed(EventHandler`1<ContractFailedEventArgs> value);
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractAbbreviatorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractArgumentValidatorAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
[ConditionalAttribute("DEBUG")]
[AttributeUsageAttribute("5124")]
public class System.Diagnostics.Contracts.ContractClassAttribute : Attribute {
    private Type _typeWithContracts;
    public Type TypeContainingContracts { get; }
    public ContractClassAttribute(Type typeContainingContracts);
    public Type get_TypeContainingContracts();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Contracts.ContractClassForAttribute : Attribute {
    private Type _typeIAmAContractFor;
    public Type TypeContractsAreFor { get; }
    public ContractClassForAttribute(Type typeContractsAreFor);
    public Type get_TypeContractsAreFor();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Diagnostics.Contracts.ContractException : Exception {
    private ContractFailureKind _kind;
    private string _userMessage;
    private string _condition;
    public ContractFailureKind Kind { get; }
    [NullableAttribute("1")]
public string Failure { get; }
    public string UserMessage { get; }
    public string Condition { get; }
    public ContractException(ContractFailureKind kind, string failure, string userMessage, string condition, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private ContractException(SerializationInfo info, StreamingContext context);
    public ContractFailureKind get_Kind();
    [NullableContextAttribute("1")]
public string get_Failure();
    public string get_UserMessage();
    public string get_Condition();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Contracts.ContractFailedEventArgs : EventArgs {
    private ContractFailureKind _failureKind;
    private string _message;
    private string _condition;
    private Exception _originalException;
    private bool _handled;
    private bool _unwind;
    internal Exception thrownDuringHandler;
    public string Message { get; }
    public string Condition { get; }
    public ContractFailureKind FailureKind { get; }
    public Exception OriginalException { get; }
    public bool Handled { get; }
    public bool Unwind { get; }
    public ContractFailedEventArgs(ContractFailureKind failureKind, string message, string condition, Exception originalException);
    public string get_Message();
    public string get_Condition();
    public ContractFailureKind get_FailureKind();
    public Exception get_OriginalException();
    public bool get_Handled();
    public void SetHandled();
    public bool get_Unwind();
    public void SetUnwind();
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public enum System.Diagnostics.Contracts.ContractFailureKind : Enum {
    public int value__;
    public static ContractFailureKind Precondition;
    public static ContractFailureKind Postcondition;
    public static ContractFailureKind PostconditionOnException;
    public static ContractFailureKind Invariant;
    public static ContractFailureKind Assert;
    public static ContractFailureKind Assume;
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Contracts.ContractInvariantMethodAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CONTRACTS_FULL")]
public class System.Diagnostics.Contracts.ContractOptionAttribute : Attribute {
    private string _category;
    private string _setting;
    private bool _enabled;
    private string _value;
    public string Category { get; }
    public string Setting { get; }
    public bool Enabled { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public ContractOptionAttribute(string category, string setting, bool enabled);
    public ContractOptionAttribute(string category, string setting, string value);
    public string get_Category();
    public string get_Setting();
    public bool get_Enabled();
    [NullableContextAttribute("2")]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("256")]
public class System.Diagnostics.Contracts.ContractPublicPropertyNameAttribute : Attribute {
    private string _publicName;
    public string Name { get; }
    public ContractPublicPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("1")]
public class System.Diagnostics.Contracts.ContractReferenceAssemblyAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.Contracts.ContractRuntimeIgnoredAttribute : Attribute {
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("237")]
public class System.Diagnostics.Contracts.ContractVerificationAttribute : Attribute {
    private bool _value;
    public bool Value { get; }
    public ContractVerificationAttribute(bool value);
    public bool get_Value();
}
[ConditionalAttribute("CONTRACTS_FULL")]
[AttributeUsageAttribute("6884")]
public class System.Diagnostics.Contracts.PureAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Diagnostics.Debug : object {
    private static DebugProvider modreq(System.Runtime.CompilerServices.IsVolatile) s_provider;
    [ThreadStaticAttribute]
private static int t_indentLevel;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_indentSize;
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    private static Debug();
    [NullableContextAttribute("1")]
public static DebugProvider SetProvider(DebugProvider provider);
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, AssertInterpolatedStringHandler& message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, AssertInterpolatedStringHandler& message, AssertInterpolatedStringHandler& detailMessage);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    internal static void ContractFailure(string message, string detailMessage, string failureKindMessage);
    [ConditionalAttribute("DEBUG")]
[DoesNotReturnAttribute]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
[DoesNotReturnAttribute]
public static void Fail(string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, WriteIfInterpolatedStringHandler& message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, WriteIfInterpolatedStringHandler& message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, WriteIfInterpolatedStringHandler& message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, WriteIfInterpolatedStringHandler& message, string category);
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggingModes <DebuggingFlags>k__BackingField;
    public bool IsJITTrackingEnabled { get; }
    public bool IsJITOptimizerDisabled { get; }
    public DebuggingModes DebuggingFlags { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public bool get_IsJITTrackingEnabled();
    public bool get_IsJITOptimizerDisabled();
    [CompilerGeneratedAttribute]
public DebuggingModes get_DebuggingFlags();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    public static bool get_IsAttached();
    private static bool IsAttached_internal();
    [IntrinsicAttribute]
public static void Break();
    public static bool IsLogging();
    public static bool Launch();
    private static void Log_icall(int level, String& category, String& message);
    public static void Log(int level, string category, string message);
    public static void NotifyOfCrossThreadDependency();
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DebuggerBrowsableState <State>k__BackingField;
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    [CompilerGeneratedAttribute]
public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    [NullableAttribute("1")]
public string Value { get; }
    public string Name { get; public set; }
    public string Type { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public DebuggerDisplayAttribute(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <ProxyTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    [NullableAttribute("1")]
[DynamicallyAccessedMembersAttribute("-1")]
public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    [NullableContextAttribute("1")]
public DebuggerTypeProxyAttribute(Type type);
    [NullableContextAttribute("1")]
public DebuggerTypeProxyAttribute(string typeName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_ProxyTypeName();
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    private Type _target;
    [CompilerGeneratedAttribute]
private string <VisualizerObjectSourceTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualizerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetTypeName>k__BackingField;
    [DynamicallyAccessedMembersAttribute("-1")]
public string VisualizerObjectSourceTypeName { get; }
    [NullableAttribute("1")]
[DynamicallyAccessedMembersAttribute("-1")]
public string VisualizerTypeName { get; }
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    [CompilerGeneratedAttribute]
public string get_VisualizerObjectSourceTypeName();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_VisualizerTypeName();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public Type get_Target();
    public void set_Target(Type value);
    [CompilerGeneratedAttribute]
public string get_TargetTypeName();
    [CompilerGeneratedAttribute]
public void set_TargetTypeName(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.DebugProvider : object {
    private static object s_lock;
    private bool _needIndent;
    private string _indentString;
    internal static Action`4<string, string, string, string> s_FailCore;
    internal static Action`1<string> s_WriteCore;
    private static bool s_shouldWriteToStdErr;
    private static DebugProvider();
    [DoesNotReturnAttribute]
public virtual void Fail(string message, string detailMessage);
    internal void WriteAssert(string stackTrace, string message, string detailMessage);
    public virtual void Write(string message);
    public virtual void WriteLine(string message);
    public virtual void OnIndentLevelChanged(int indentLevel);
    public virtual void OnIndentSizeChanged(int indentSize);
    private string GetIndentString();
    [NullableContextAttribute("1")]
public static void FailCore(string stackTrace, string message, string detailMessage, string errorSource);
    [NullableContextAttribute("1")]
public static void WriteCore(string message);
    private static void WriteToDebugger(string message);
    private static void WriteToStderr(string message);
}
internal class System.Diagnostics.MonoStackFrame : object {
    internal int ilOffset;
    internal int nativeOffset;
    internal long methodAddress;
    internal UInt32 methodIndex;
    internal MethodBase methodBase;
    internal string fileName;
    internal int lineNumber;
    internal int columnNumber;
    internal string internalMethodName;
    internal bool isLastFrameFromForeignException;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.StackFrame : object {
    private MethodBase _method;
    private int _nativeOffset;
    private int _ilOffset;
    private string _fileName;
    private int _lineNumber;
    private int _columnNumber;
    private bool _isLastFrameFromForeignExceptionStackTrace;
    public static int OFFSET_UNKNOWN;
    internal bool IsLastFrameFromForeignExceptionStackTrace { get; }
    internal StackFrame(MonoStackFrame monoStackFrame, bool needFileInfo);
    public StackFrame(bool needFileInfo);
    public StackFrame(int skipFrames);
    public StackFrame(int skipFrames, bool needFileInfo);
    public StackFrame(string fileName, int lineNumber);
    public StackFrame(string fileName, int lineNumber, int colNumber);
    private void BuildStackFrame(int skipFrames, bool needFileInfo);
    private static bool GetFrameInfo(int skipFrames, bool needFileInfo, ObjectHandleOnStack out_method, ObjectHandleOnStack out_file, Int32& ilOffset, Int32& nativeOffset, Int32& line, Int32& column);
    private void InitMembers();
    internal bool get_IsLastFrameFromForeignExceptionStackTrace();
    [RequiresUnreferencedCodeAttribute("Metadata for the method might be incomplete or removed")]
public virtual MethodBase GetMethod();
    public virtual int GetNativeOffset();
    public virtual int GetILOffset();
    public virtual string GetFileName();
    public virtual int GetFileLineNumber();
    public virtual int GetFileColumnNumber();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Diagnostics.StackFrameExtensions : object {
    [ExtensionAttribute]
public static bool HasNativeImage(StackFrame stackFrame);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public static bool HasMethod(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasILOffset(StackFrame stackFrame);
    [ExtensionAttribute]
public static bool HasSource(StackFrame stackFrame);
    [ExtensionAttribute]
public static IntPtr GetNativeIP(StackFrame stackFrame);
    [ExtensionAttribute]
public static IntPtr GetNativeImageBase(StackFrame stackFrame);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Diagnostics.StackTrace : object {
    public static int METHODS_TO_SKIP;
    private int _numOfFrames;
    private int _methodsToSkip;
    private StackFrame[] _stackFrames;
    public int FrameCount { get; }
    public StackTrace(bool fNeedFileInfo);
    public StackTrace(int skipFrames);
    public StackTrace(int skipFrames, bool fNeedFileInfo);
    public StackTrace(Exception e);
    public StackTrace(Exception e, bool fNeedFileInfo);
    public StackTrace(Exception e, int skipFrames);
    public StackTrace(Exception e, int skipFrames, bool fNeedFileInfo);
    public StackTrace(StackFrame frame);
    public StackTrace(IEnumerable`1<StackFrame> frames);
    internal static void GetTrace(ObjectHandleOnStack ex, ObjectHandleOnStack res, int skipFrames, bool needFileInfo);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private void InitializeForCurrentThread(int skipFrames, bool needFileInfo);
    private void InitializeForException(Exception e, int skipFrames, bool needFileInfo);
    public virtual int get_FrameCount();
    [NullableContextAttribute("2")]
public virtual StackFrame GetFrame(int index);
    public virtual StackFrame[] GetFrames();
    public virtual string ToString();
    internal string ToString(TraceFormat traceFormat);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
internal void ToString(TraceFormat traceFormat, StringBuilder sb);
    private static bool ShowInStackTrace(MethodBase mb);
    private static bool TryResolveStateMachineMethod(MethodBase& method, Type& declaringType);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
internal static MethodInfo[] <TryResolveStateMachineMethod>g__GetDeclaredMethods|26_0(Type type);
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Diagnostics.Stopwatch : object {
    private long _elapsed;
    private long _startTimeStamp;
    private bool _isRunning;
    public static long Frequency;
    public static bool IsHighResolution;
    private static double s_tickFrequency;
    public bool IsRunning { get; }
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    private string DebuggerDisplay { get; }
    private static Stopwatch();
    public void Start();
    public static Stopwatch StartNew();
    public void Stop();
    public void Reset();
    public void Restart();
    public virtual string ToString();
    public bool get_IsRunning();
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public static long GetTimestamp();
    public static TimeSpan GetElapsedTime(long startingTimestamp);
    public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp);
    private long GetRawElapsedTicks();
    private long GetElapsedDateTimeTicks();
    private string get_DebuggerDisplay();
    private static long QueryPerformanceCounter();
}
[NullableContextAttribute("1")]
public interface System.Diagnostics.SymbolStore.ISymbolDocumentWriter {
    public abstract virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
    public abstract virtual void SetSource(Byte[] source);
}
internal class System.Diagnostics.Tracing.ActivityTracker : object {
    private AsyncLocal`1<ActivityInfo> m_current;
    private bool m_checkedForEnable;
    private static ActivityTracker s_activityTrackerInstance;
    private static long m_nextId;
    public static ActivityTracker Instance { get; }
    private static ActivityTracker();
    public void OnStart(string providerName, string activityName, int task, Guid& activityId, Guid& relatedActivityId, EventActivityOptions options, bool useTplSource);
    public void OnStop(string providerName, string activityName, int task, Guid& activityId, bool useTplSource);
    public void Enable();
    public static ActivityTracker get_Instance();
    private static ActivityInfo FindActiveActivity(string name, ActivityInfo startLocation);
    private static string NormalizeActivityName(string providerName, string activityName, int task);
    private void ActivityChanging(AsyncLocalValueChangedArgs`1<ActivityInfo> args);
}
internal class System.Diagnostics.Tracing.ArrayTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    public ArrayTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ConcurrentSet`2 : ValueType {
    private ItemType[] items;
    public ItemType TryGet(KeyType key);
    public ItemType GetOrAdd(ItemType newItem);
}
internal abstract class System.Diagnostics.Tracing.ConcurrentSetItem`2 : object {
    public abstract virtual int Compare(ItemType other);
    public abstract virtual int Compare(KeyType key);
}
internal enum System.Diagnostics.Tracing.ControllerCommand : Enum {
    public int value__;
    public static ControllerCommand Update;
    public static ControllerCommand SendManifest;
    public static ControllerCommand Enable;
    public static ControllerCommand Disable;
}
[UnsupportedOSPlatformAttribute("browser")]
internal class System.Diagnostics.Tracing.CounterGroup : object {
    private EventSource _eventSource;
    private List`1<DiagnosticCounter> _counters;
    private static object s_counterGroupLock;
    private static WeakReference`1[] s_counterGroups;
    private DateTime _timeStampSinceCollectionStarted;
    private int _pollingIntervalInMilliseconds;
    private DateTime _nextPollingTimeStamp;
    private static Thread s_pollingThread;
    private static AutoResetEvent s_pollingThreadSleepEvent;
    private static List`1<CounterGroup> s_counterGroupEnabledList;
    internal CounterGroup(EventSource eventSource);
    private static CounterGroup();
    internal void Add(DiagnosticCounter eventCounter);
    internal void Remove(DiagnosticCounter eventCounter);
    private void RegisterCommandCallback();
    private void OnEventSourceCommand(object sender, EventCommandEventArgs e);
    private static void EnsureEventSourceIndexAvailable(int eventSourceIndex);
    internal static CounterGroup GetCounterGroup(EventSource eventSource);
    private void EnableTimer(float pollingIntervalInSeconds);
    private void DisableTimer();
    private void ResetCounters();
    private void OnTimer();
    private static void PollForValues();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.CounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Mean>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StandardDeviation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Max>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public double Mean { get; public set; }
    public double StandardDeviation { get; public set; }
    public int Count { get; public set; }
    public double Min { get; public set; }
    public double Max { get; public set; }
    public float IntervalSec { get; internal set; }
    public string Series { get; public set; }
    public string CounterType { get; public set; }
    public string Metadata { get; public set; }
    public string DisplayUnits { get; public set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public double get_Mean();
    [CompilerGeneratedAttribute]
public void set_Mean(double value);
    [CompilerGeneratedAttribute]
public double get_StandardDeviation();
    [CompilerGeneratedAttribute]
public void set_StandardDeviation(double value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
    [CompilerGeneratedAttribute]
public double get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(double value);
    [CompilerGeneratedAttribute]
public double get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(double value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    [CompilerGeneratedAttribute]
public string get_Series();
    [CompilerGeneratedAttribute]
public void set_Series(string value);
    [CompilerGeneratedAttribute]
public string get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(string value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.CounterPayload/<get_ForEnumeration>d__51")]
private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.CounterPayloadType : object {
    [CompilerGeneratedAttribute]
private CounterPayload <Payload>k__BackingField;
    public CounterPayload Payload { get; public set; }
    public CounterPayloadType(CounterPayload payload);
    [CompilerGeneratedAttribute]
public CounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(CounterPayload value);
}
internal class System.Diagnostics.Tracing.DataCollector : ValueType {
    [ThreadStaticAttribute]
internal static DataCollector ThreadInstance;
    private Byte* scratchEnd;
    private EventData* datasEnd;
    private GCHandle* pinsEnd;
    private EventData* datasStart;
    private Byte* scratch;
    private EventData* datas;
    private GCHandle* pins;
    private Byte[] buffer;
    private int bufferPos;
    private int bufferNesting;
    private bool writingScalars;
    internal void Enable(Byte* scratch, int scratchSize, EventData* datas, int dataCount, GCHandle* pins, int pinCount);
    internal void Disable();
    internal EventData* Finish();
    internal void AddScalar(Void* value, int size);
    internal void AddNullTerminatedString(string value);
    internal void AddArray(Array value, int length, int itemSize);
    internal int BeginBufferedArray();
    internal void EndBufferedArray(int bookmark, int count);
    internal void BeginBuffered();
    internal void EndBuffered();
    private void EnsureBuffer();
    private void EnsureBuffer(int additionalSize);
    private void GrowBuffer(int required);
    private void PinArray(object value, int size);
    private void ScalarsBegin();
    private void ScalarsEnd();
}
internal class System.Diagnostics.Tracing.DateTimeOffsetTypeInfo : TraceLoggingTypeInfo {
    private static DateTimeOffsetTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
internal class System.Diagnostics.Tracing.DateTimeTypeInfo : TraceLoggingTypeInfo {
    private static DateTimeTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
internal class System.Diagnostics.Tracing.DecimalTypeInfo : TraceLoggingTypeInfo {
    private static DecimalTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public abstract class System.Diagnostics.Tracing.DiagnosticCounter : object {
    private string _displayName;
    private string _displayUnits;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    private CounterGroup _group;
    private Dictionary`2<string, string> _metadata;
    public string DisplayName { get; public set; }
    public string DisplayUnits { get; public set; }
    public string Name { get; }
    public EventSource EventSource { get; }
    internal DiagnosticCounter(string Name, EventSource EventSource);
    private protected void Publish();
    public sealed virtual void Dispose();
    public void AddMetadata(string key, string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_DisplayUnits();
    public void set_DisplayUnits(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    internal abstract virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void ReportOutOfBandMessage(string message);
    internal string GetMetadataString();
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Tracing.EmptyStruct : ValueType {
}
internal class System.Diagnostics.Tracing.EnumerableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo elementInfo;
    internal TraceLoggingTypeInfo ElementInfo { get; }
    public EnumerableTypeInfo(Type type, TraceLoggingTypeInfo elementInfo);
    internal TraceLoggingTypeInfo get_ElementInfo();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventActivityOptions : Enum {
    public int value__;
    public static EventActivityOptions None;
    public static EventActivityOptions Disable;
    public static EventActivityOptions Recursive;
    public static EventActivityOptions Detachable;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.EventAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    [CompilerGeneratedAttribute]
private EventLevel <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannel <Channel>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private EventActivityOptions <ActivityOptions>k__BackingField;
    private EventOpcode m_opcode;
    private bool m_opcodeSet;
    public int EventId { get; private set; }
    public EventLevel Level { get; public set; }
    public EventKeywords Keywords { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventTask Task { get; public set; }
    public EventChannel Channel { get; public set; }
    public byte Version { get; public set; }
    public string Message { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventAttribute(int eventId);
    [CompilerGeneratedAttribute]
public int get_EventId();
    [CompilerGeneratedAttribute]
private void set_EventId(int value);
    [CompilerGeneratedAttribute]
public EventLevel get_Level();
    [CompilerGeneratedAttribute]
public void set_Level(EventLevel value);
    [CompilerGeneratedAttribute]
public EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    [CompilerGeneratedAttribute]
public EventTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(EventTask value);
    [CompilerGeneratedAttribute]
public EventChannel get_Channel();
    [CompilerGeneratedAttribute]
public void set_Channel(EventChannel value);
    [CompilerGeneratedAttribute]
public byte get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public EventTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventTags value);
    [CompilerGeneratedAttribute]
public EventActivityOptions get_ActivityOptions();
    [CompilerGeneratedAttribute]
public void set_ActivityOptions(EventActivityOptions value);
}
public enum System.Diagnostics.Tracing.EventChannel : Enum {
    public byte value__;
    public static EventChannel None;
    public static EventChannel Admin;
    public static EventChannel Operational;
    public static EventChannel Analytic;
    public static EventChannel Debug;
}
[AttributeUsageAttribute("256")]
internal class System.Diagnostics.Tracing.EventChannelAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventChannelType <EventChannelType>k__BackingField;
    public bool Enabled { get; public set; }
    public EventChannelType EventChannelType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
public void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public EventChannelType get_EventChannelType();
    [CompilerGeneratedAttribute]
public void set_EventChannelType(EventChannelType value);
}
internal enum System.Diagnostics.Tracing.EventChannelType : Enum {
    public int value__;
    public static EventChannelType Admin;
    public static EventChannelType Operational;
    public static EventChannelType Analytic;
    public static EventChannelType Debug;
}
public enum System.Diagnostics.Tracing.EventCommand : Enum {
    public int value__;
    public static EventCommand Update;
    public static EventCommand SendManifest;
    public static EventCommand Enable;
    public static EventCommand Disable;
}
public class System.Diagnostics.Tracing.EventCommandEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Arguments>k__BackingField;
    internal EventSource eventSource;
    internal EventDispatcher dispatcher;
    internal EventProviderType eventProviderType;
    internal EventListener listener;
    internal int perEventSourceSessionId;
    internal bool enable;
    internal EventLevel level;
    internal EventKeywords matchAnyKeyword;
    internal EventCommandEventArgs nextCommand;
    public EventCommand Command { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> Arguments { get; internal set; }
    internal EventCommandEventArgs(EventCommand command, IDictionary`2<string, string> arguments, EventSource eventSource, EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, bool enable, EventLevel level, EventKeywords matchAnyKeyword);
    [CompilerGeneratedAttribute]
public EventCommand get_Command();
    [CompilerGeneratedAttribute]
internal void set_Command(EventCommand value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(IDictionary`2<string, string> value);
    public bool EnableEvent(int eventId);
    public bool DisableEvent(int eventId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Diagnostics.Tracing.EventCounter : DiagnosticCounter {
    private int _count;
    private double _sum;
    private double _sumSquared;
    private double _min;
    private double _max;
    private Double[] _bufferedValues;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedValuesIndex;
    public EventCounter(string name, EventSource eventSource);
    public void WriteMetric(float value);
    public void WriteMetric(double value);
    public virtual string ToString();
    internal void OnMetricWritten(double value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Diagnostics.Tracing.CounterPayload")]
internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void ResetStatistics();
    private void Enqueue(double value);
    private void Flush();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class System.Diagnostics.Tracing.EventDataAttribute : Attribute {
    private EventLevel level;
    private EventOpcode opcode;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private EventTags <Tags>k__BackingField;
    public string Name { get; public set; }
    internal EventLevel Level { get; }
    internal EventOpcode Opcode { get; }
    internal EventKeywords Keywords { get; }
    internal EventTags Tags { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal EventLevel get_Level();
    internal EventOpcode get_Opcode();
    [CompilerGeneratedAttribute]
internal EventKeywords get_Keywords();
    [CompilerGeneratedAttribute]
internal EventTags get_Tags();
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Tracing.EventDescriptor : ValueType {
    private int m_traceloggingId;
    private ushort m_id;
    private byte m_version;
    private byte m_channel;
    private byte m_level;
    private byte m_opcode;
    private ushort m_task;
    private long m_keywords;
    public int EventId { get; }
    public byte Version { get; }
    public byte Channel { get; }
    public byte Level { get; }
    public byte Opcode { get; }
    public int Task { get; }
    public long Keywords { get; }
    public EventDescriptor(int traceloggingId, byte level, byte opcode, long keywords);
    public EventDescriptor(int id, byte version, byte channel, byte level, byte opcode, int task, long keywords);
    public int get_EventId();
    public byte get_Version();
    public byte get_Channel();
    public byte get_Level();
    public byte get_Opcode();
    public int get_Task();
    public long get_Keywords();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(EventDescriptor other);
}
internal class System.Diagnostics.Tracing.EventDispatcher : object {
    internal EventListener m_Listener;
    internal Boolean[] m_EventEnabled;
    internal EventDispatcher m_Next;
    internal EventDispatcher(EventDispatcher next, Boolean[] eventEnabled, EventListener listener);
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventFieldAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventFieldFormat <Format>k__BackingField;
    public EventFieldTags Tags { get; public set; }
    [NullableAttribute("2")]
internal string Name { get; }
    public EventFieldFormat Format { get; public set; }
    [CompilerGeneratedAttribute]
public EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(EventFieldTags value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
public EventFieldFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(EventFieldFormat value);
}
public enum System.Diagnostics.Tracing.EventFieldFormat : Enum {
    public int value__;
    public static EventFieldFormat Default;
    public static EventFieldFormat String;
    public static EventFieldFormat Boolean;
    public static EventFieldFormat Hexadecimal;
    public static EventFieldFormat Xml;
    public static EventFieldFormat Json;
    public static EventFieldFormat HResult;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventFieldTags : Enum {
    public int value__;
    public static EventFieldTags None;
}
[AttributeUsageAttribute("128")]
public class System.Diagnostics.Tracing.EventIgnoreAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventKeywords : Enum {
    public long value__;
    public static EventKeywords None;
    public static EventKeywords All;
    public static EventKeywords MicrosoftTelemetry;
    public static EventKeywords WdiContext;
    public static EventKeywords WdiDiagnostic;
    public static EventKeywords Sqm;
    public static EventKeywords AuditFailure;
    public static EventKeywords AuditSuccess;
    public static EventKeywords CorrelationHint;
    public static EventKeywords EventLogClassic;
}
public enum System.Diagnostics.Tracing.EventLevel : Enum {
    public int value__;
    public static EventLevel LogAlways;
    public static EventLevel Critical;
    public static EventLevel Error;
    public static EventLevel Warning;
    public static EventLevel Informational;
    public static EventLevel Verbose;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Diagnostics.Tracing.EventListener : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<EventSourceCreatedEventArgs> _EventSourceCreated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventWrittenEventArgs> EventWritten;
    internal EventListener modreq(System.Runtime.CompilerServices.IsVolatile) m_Next;
    internal static EventListener s_Listeners;
    internal static List`1<WeakReference`1<EventSource>> s_EventSources;
    private static bool s_CreatingListener;
    internal static object EventListenersLock { get; }
    public void add_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    public void remove_EventSourceCreated(EventHandler`1<EventSourceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventWritten(EventHandler`1<EventWrittenEventArgs> value);
    public virtual void Dispose();
    public void EnableEvents(EventSource eventSource, EventLevel level);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword);
    public void EnableEvents(EventSource eventSource, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> arguments);
    public void DisableEvents(EventSource eventSource);
    protected internal static int EventSourceIndex(EventSource eventSource);
    protected internal virtual void OnEventSourceCreated(EventSource eventSource);
    protected internal virtual void OnEventWritten(EventWrittenEventArgs eventData);
    internal static void AddEventSource(EventSource newEventSource);
    internal static void DisposeOnShutdown();
    private static void CallDisableEventsIfNecessary(EventDispatcher eventDispatcher, EventSource eventSource);
    private static void RemoveReferencesToListenerInEventSources(EventListener listenerToRemove);
    internal static object get_EventListenersLock();
    private void CallBackForExistingEventSources(bool addToListenersList, EventHandler`1<EventSourceCreatedEventArgs> callback);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventManifestOptions : Enum {
    public int value__;
    public static EventManifestOptions None;
    public static EventManifestOptions Strict;
    public static EventManifestOptions AllCultures;
    public static EventManifestOptions OnlyIfNeededForRegistration;
    public static EventManifestOptions AllowEventSourceOverride;
}
public enum System.Diagnostics.Tracing.EventOpcode : Enum {
    public int value__;
    public static EventOpcode Info;
    public static EventOpcode Start;
    public static EventOpcode Stop;
    public static EventOpcode DataCollectionStart;
    public static EventOpcode DataCollectionStop;
    public static EventOpcode Extension;
    public static EventOpcode Reply;
    public static EventOpcode Resume;
    public static EventOpcode Suspend;
    public static EventOpcode Send;
    public static EventOpcode Receive;
}
internal class System.Diagnostics.Tracing.EventParameterInfo : ValueType {
    internal string ParameterName;
    internal Type ParameterType;
    internal TraceLoggingTypeInfo TypeInfo;
    internal void SetInfo(string name, Type type, TraceLoggingTypeInfo typeInfo);
    internal bool GenerateMetadata(Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    private static bool GenerateMetadataForProperty(PropertyAnalysis property, Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    internal bool GenerateMetadataV2(Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    private static bool GenerateMetadataForNamedTypeV2(string name, TraceLoggingTypeInfo typeInfo, Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    private static bool GenerateMetadataForTypeV2(TraceLoggingTypeInfo typeInfo, Byte* pMetadataBlob, UInt32& offset, UInt32 blobSize);
    internal static bool GetTypeInfoFromType(Type type, TraceLoggingTypeInfo& typeInfo);
    internal bool GetMetadataLength(UInt32& size);
    private static UInt32 GetMetadataLengthForProperty(PropertyAnalysis property);
    private static TypeCode GetTypeCodeExtended(Type parameterType);
    internal bool GetMetadataLengthV2(UInt32& size);
    private static bool GetMetadataLengthForTypeV2(TraceLoggingTypeInfo typeInfo, UInt32& size);
    private static bool GetMetadataLengthForNamedTypeV2(string name, TraceLoggingTypeInfo typeInfo, UInt32& size);
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.EventPayload : object {
    private String[] m_names;
    private Object[] m_values;
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal EventPayload(String[] payloadNames, Object[] payloadValues);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> payloadEntry);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> entry);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.EventPayload/<GetEnumerator>d__17")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(KeyValuePair`2[] payloadEntries, int count);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> entry);
    public sealed virtual bool TryGetValue(string key, Object& value);
}
internal class System.Diagnostics.Tracing.EventPipeEventDispatcher : object {
    internal static EventPipeEventDispatcher Instance;
    private IntPtr m_RuntimeProviderID;
    private ulong m_sessionID;
    private CancellationTokenSource m_dispatchTaskCancellationSource;
    private Task m_dispatchTask;
    private object m_dispatchControlLock;
    private Dictionary`2<EventListener, EventListenerSubscription> m_subscriptions;
    private static EventPipeEventDispatcher();
    internal void SendCommand(EventListener eventListener, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeywords);
    private void CommitDispatchConfiguration();
    private void StartDispatchTask(ulong sessionID, DateTime syncTimeUtc, long syncTimeQPC, long timeQPCFrequency);
    private void SetStopDispatchTask();
    private void DispatchEventsToEventListeners(ulong sessionID, DateTime syncTimeUtc, long syncTimeQPC, long timeQPCFrequency, Task previousDispatchTask, CancellationToken token);
    private static DateTime TimeStampToDateTime(long timeStamp, DateTime syncTimeUtc, long syncTimeQPC, long timeQPCFrequency);
}
internal class System.Diagnostics.Tracing.EventPipeEventInstanceData : ValueType {
    internal IntPtr ProviderID;
    internal UInt32 EventID;
    internal UInt32 ThreadID;
    internal long TimeStamp;
    internal Guid ActivityId;
    internal Guid ChildActivityId;
    internal IntPtr Payload;
    internal UInt32 PayloadLength;
}
internal class System.Diagnostics.Tracing.EventPipeEventProvider : EventProviderImpl {
    private WeakReference`1<EventProvider> _eventProvider;
    private IntPtr _provHandle;
    private GCHandle _gcHandle;
    internal EventPipeEventProvider(EventProvider eventProvider);
    protected virtual void HandleEnableNotification(EventProvider target, Byte* additionalData, byte level, long matchAnyKeywords, long matchAllKeywords, EVENT_FILTER_DESCRIPTOR* filterData);
    [UnmanagedCallersOnlyAttribute]
private static void Callback(Byte* sourceId, int isEnabled, byte level, long matchAnyKeywords, long matchAllKeywords, EVENT_FILTER_DESCRIPTOR* filterData, Void* callbackContext);
    internal virtual void Register(EventSource eventSource);
    internal virtual void Unregister();
    internal virtual WriteEventErrorCode EventWriteTransfer(EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    internal virtual IntPtr DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
    internal static int EventActivityIdControl(ActivityControl controlCode, Guid& activityId);
}
internal static class System.Diagnostics.Tracing.EventPipeInternal : object {
    private static ulong Enable(Char* outputFile, EventPipeSerializationFormat format, UInt32 circularBufferSizeInMB, EventPipeProviderConfigurationNative* providers, UInt32 numProviders);
    internal static void Disable(ulong sessionID);
    private static IntPtr CreateProvider(string providerName, IntPtr callbackFunc, IntPtr callbackContext);
    internal static IntPtr CreateProvider(string providerName, method callbackFunc, Void* callbackContext);
    internal static IntPtr DefineEvent(IntPtr provHandle, UInt32 eventID, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
    internal static IntPtr GetProvider(Char* providerName);
    internal static IntPtr GetProvider(string providerName);
    internal static void DeleteProvider(IntPtr provHandle);
    internal static int EventActivityIdControl(UInt32 controlCode, Guid& activityId);
    internal static void WriteEventData(IntPtr eventHandle, EventData* pEventData, UInt32 dataCount, Guid* activityId, Guid* relatedActivityId);
    internal static bool GetSessionInfo(ulong sessionID, EventPipeSessionInfo* pSessionInfo);
    internal static bool GetNextEvent(ulong sessionID, EventPipeEventInstanceData* pInstance);
    internal static bool SignalSession(ulong sessionID);
    internal static bool WaitForSessionSignal(ulong sessionID, int timeoutMs);
    internal static ulong GetRuntimeCounterValue(RuntimeCounters counterID);
    internal static ulong Enable(string outputFile, EventPipeSerializationFormat format, UInt32 circularBufferSizeInMB, EventPipeProviderConfiguration[] providers);
}
internal class System.Diagnostics.Tracing.EventPipeMetadataGenerator : object {
    public static EventPipeMetadataGenerator Instance;
    private static EventPipeMetadataGenerator();
    public Byte[] GenerateEventMetadata(EventMetadata eventMetadata);
    public Byte[] GenerateEventMetadata(int eventId, string eventName, EventKeywords keywords, EventLevel level, UInt32 version, EventOpcode opcode, TraceLoggingEventTypes eventTypes);
    internal Byte[] GenerateMetadata(int eventId, string eventName, long keywords, UInt32 level, UInt32 version, EventOpcode opcode, EventParameterInfo[] parameters);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, Byte* src, UInt32 srcLength);
    internal static void WriteToBuffer(Byte* buffer, UInt32 bufferLength, UInt32& offset, T value);
}
internal static class System.Diagnostics.Tracing.EventPipePayloadDecoder : object {
    internal static Object[] DecodePayload(EventMetadata& metadata, ReadOnlySpan`1<byte> payload);
}
internal class System.Diagnostics.Tracing.EventPipeProviderConfiguration : ValueType {
    private string m_providerName;
    private ulong m_keywords;
    private UInt32 m_loggingLevel;
    private string m_filterData;
    internal string ProviderName { get; }
    internal ulong Keywords { get; }
    internal UInt32 LoggingLevel { get; }
    internal string FilterData { get; }
    internal EventPipeProviderConfiguration(string providerName, ulong keywords, UInt32 loggingLevel, string filterData);
    internal string get_ProviderName();
    internal ulong get_Keywords();
    internal UInt32 get_LoggingLevel();
    internal string get_FilterData();
}
internal enum System.Diagnostics.Tracing.EventPipeSerializationFormat : Enum {
    public int value__;
    public static EventPipeSerializationFormat NetPerf;
    public static EventPipeSerializationFormat NetTrace;
}
internal class System.Diagnostics.Tracing.EventPipeSessionInfo : ValueType {
    internal long StartTimeAsUTCFileTime;
    internal long StartTimeStamp;
    internal long TimeStampFrequency;
}
internal class System.Diagnostics.Tracing.EventProvider : object {
    internal EventProviderImpl _eventProvider;
    private string _providerName;
    private Guid _providerId;
    internal bool _disposed;
    [ThreadStaticAttribute]
private static WriteEventErrorCode s_returnCode;
    private static int BasicTypeAllocationBufferSize;
    private static int EtwMaxNumberArguments;
    private static int EtwAPIMaxRefObjCount;
    private static int TraceEventMaximumSize;
    protected EventLevel Level { get; protected set; }
    protected EventKeywords MatchAnyKeyword { get; protected set; }
    protected EventKeywords MatchAllKeyword { get; protected set; }
    internal EventProvider(EventProviderType providerType);
    internal void Register(EventSource eventSource);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    protected virtual override void Finalize();
    internal virtual void OnControllerCommand(ControllerCommand command, IDictionary`2<string, string> arguments, int sessionId);
    protected EventLevel get_Level();
    protected void set_Level(EventLevel value);
    protected EventKeywords get_MatchAnyKeyword();
    protected void set_MatchAnyKeyword(EventKeywords value);
    protected EventKeywords get_MatchAllKeyword();
    protected void set_MatchAllKeyword(EventKeywords value);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    public static WriteEventErrorCode GetLastWriteEventError();
    private static void SetLastError(WriteEventErrorCode error);
    private static object EncodeObject(Object& data, EventData*& dataDescriptor, Byte*& dataBuffer, UInt32& totalEventSize);
    internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, Object[] eventPayload);
    protected internal bool WriteEvent(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* childActivityID, int dataCount, IntPtr data);
    internal bool WriteEventRaw(EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
}
internal class System.Diagnostics.Tracing.EventProviderImpl : object {
    protected byte _level;
    protected long _anyKeywordMask;
    protected long _allKeywordMask;
    protected bool _enabled;
    internal EventLevel Level { get; internal set; }
    internal EventKeywords MatchAnyKeyword { get; internal set; }
    internal EventKeywords MatchAllKeyword { get; internal set; }
    internal EventLevel get_Level();
    internal void set_Level(EventLevel value);
    internal EventKeywords get_MatchAnyKeyword();
    internal void set_MatchAnyKeyword(EventKeywords value);
    internal EventKeywords get_MatchAllKeyword();
    internal void set_MatchAllKeyword(EventKeywords value);
    protected virtual void HandleEnableNotification(EventProvider target, Byte* additionalData, byte level, long matchAnyKeywords, long matchAllKeywords, EVENT_FILTER_DESCRIPTOR* filterData);
    public bool IsEnabled();
    public bool IsEnabled(byte level, long keywords);
    internal void Enable(byte level, long anyKeyword, long allKeyword);
    internal virtual void Disable();
    internal virtual void Register(EventSource eventSource);
    internal virtual void Unregister();
    internal virtual WriteEventErrorCode EventWriteTransfer(EventDescriptor& modreq(System.Runtime.InteropServices.InAttribute) eventDescriptor, IntPtr eventHandle, Guid* activityId, Guid* relatedActivityId, int userDataCount, EventData* userData);
    internal virtual IntPtr DefineEventHandle(UInt32 eventID, string eventName, long keywords, UInt32 eventVersion, UInt32 level, Byte* pMetadata, UInt32 metadataLength);
    protected void ProviderCallback(EventProvider target, Byte* additionalData, int controlCode, byte level, long matchAnyKeywords, long matchAllKeywords, EVENT_FILTER_DESCRIPTOR* filterData);
    private static int FindNull(Byte[] buffer, int idx);
    protected static IDictionary`2<string, string> ParseFilterData(Byte[] data);
    protected bool MarshalFilterData(EVENT_FILTER_DESCRIPTOR* filterData, ControllerCommand& command, Byte[]& data);
}
internal enum System.Diagnostics.Tracing.EventProviderType : Enum {
    public int value__;
    public static EventProviderType None;
    public static EventProviderType ETW;
    public static EventProviderType EventPipe;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DynamicallyAccessedMembersAttribute("-1")]
public class System.Diagnostics.Tracing.EventSource : object {
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    private static DynamicallyAccessedMemberTypes ManifestMemberTypes;
    private static ReadOnlyCollection`1<string> s_errorPayloadNames;
    private string m_name;
    internal int m_id;
    private Guid m_guid;
    internal EventMetadata[] modreq(System.Runtime.CompilerServices.IsVolatile) m_eventData;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) m_rawManifest;
    private EventHandler`1<EventCommandEventArgs> m_eventCommandExecuted;
    private EventSourceSettings m_config;
    private bool m_eventSourceDisposed;
    private bool m_eventSourceEnabled;
    internal EventLevel m_level;
    internal EventKeywords m_matchAnyKeyword;
    internal EventDispatcher modreq(System.Runtime.CompilerServices.IsVolatile) m_Dispatchers;
    private OverrideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_etwProvider;
    private object m_createEventLock;
    private IntPtr m_writeEventStringEventHandle;
    private OverrideEventProvider modreq(System.Runtime.CompilerServices.IsVolatile) m_eventPipeProvider;
    private bool m_completelyInited;
    private Exception m_constructionException;
    private byte m_outOfBandMessageCount;
    private EventCommandEventArgs m_deferredCommands;
    private String[] m_traits;
    [ThreadStaticAttribute]
private static byte m_EventSourceExceptionRecurenceCount;
    internal UInt64[] modreq(System.Runtime.CompilerServices.IsVolatile) m_channelData;
    private ActivityTracker m_activityTracker;
    internal static string ActivityStartSuffix;
    internal static string ActivityStopSuffix;
    internal static string DuplicateSourceNamesSwitch;
    private static bool AllowDuplicateSourceNames;
    private Byte[] m_providerMetadata;
    private static string EventSourceRequiresUnreferenceMessage;
    private static string EventSourceSuppressMessage;
    private TraceLoggingEventHandleTable m_eventHandleTable;
    internal static bool IsSupported { get; }
    [NullableAttribute("1")]
public string Name { get; }
    public Guid Guid { get; }
    public EventSourceSettings Settings { get; }
    public Exception ConstructionException { get; }
    public static Guid CurrentThreadActivityId { get; }
    private bool IsDisposed { get; }
    private bool ThrowOnEventWriteErrors { get; }
    private bool SelfDescribingEvents { get; }
    [NullableAttribute("0")]
private protected ReadOnlySpan`1<byte> ProviderMetadata { get; }
    protected EventSource(bool throwOnEventWriteErrors);
    protected EventSource(EventSourceSettings settings);
    protected EventSource(EventSourceSettings settings, String[] traits);
    internal EventSource(Guid eventSourceGuid, string eventSourceName);
    internal EventSource(Guid eventSourceGuid, string eventSourceName, EventSourceSettings settings, String[] traits);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName, EventSourceSettings config);
    [NullableContextAttribute("1")]
public EventSource(string eventSourceName, EventSourceSettings config, String[] traits);
    private static EventSource();
    [CompilerGeneratedAttribute]
internal static bool get_IsSupported();
    private static bool InitializeIsSupported();
    [NullableContextAttribute("1")]
public string get_Name();
    public Guid get_Guid();
    public bool IsEnabled();
    public bool IsEnabled(EventLevel level, EventKeywords keywords);
    public bool IsEnabled(EventLevel level, EventKeywords keywords, EventChannel channel);
    public EventSourceSettings get_Settings();
    [NullableContextAttribute("1")]
public static Guid GetGuid(Type eventSourceType);
    [NullableContextAttribute("1")]
public static string GetName(Type eventSourceType);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2114:ReflectionToDynamicallyAccessedMembers")]
public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2114:ReflectionToDynamicallyAccessedMembers")]
public static string GenerateManifest(Type eventSourceType, string assemblyPathToIncludeInManifest, EventManifestOptions flags);
    [NullableContextAttribute("1")]
public static IEnumerable`1<EventSource> GetSources();
    [NullableContextAttribute("1")]
public static void SendCommand(EventSource eventSource, EventCommand command, IDictionary`2<string, string> commandArguments);
    public Exception get_ConstructionException();
    [NullableContextAttribute("1")]
public string GetTrait(string key);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public void add_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public void remove_EventCommandExecuted(EventHandler`1<EventCommandEventArgs> value);
    public static void SetCurrentThreadActivityId(Guid activityId);
    public static Guid get_CurrentThreadActivityId();
    public static void SetCurrentThreadActivityId(Guid activityId, Guid& oldActivityThatWillContinue);
    private void DefineEventPipeEvents();
    [NullableContextAttribute("1")]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, int arg1);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, int arg1, int arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, int arg1, int arg2, int arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, long arg1);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, long arg1, long arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, long arg1, long arg2, long arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, string arg1);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, string arg1, string arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, string arg1, string arg2, string arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, string arg1, int arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, string arg1, int arg2, int arg3);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, string arg1, long arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, long arg1, string arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, int arg1, string arg2);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, Byte[] arg1);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, long arg1, Byte[] arg2);
    [NullableContextAttribute("0")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
[CLSCompliantAttribute("False")]
protected void WriteEventCore(int eventId, int eventDataCount, EventData* data);
    [NullableContextAttribute("0")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
[CLSCompliantAttribute("False")]
protected void WriteEventWithRelatedActivityIdCore(int eventId, Guid* relatedActivityId, int eventDataCount, EventData* data);
    [NullableContextAttribute("1")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
protected void WriteEvent(int eventId, EventSourcePrimitive[] args);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
protected void WriteEvent(int eventId, Object[] args);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
protected void WriteEventWithRelatedActivityId(int eventId, Guid relatedActivityId, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void WriteEventRaw(string eventName, EventDescriptor& eventDescriptor, IntPtr eventHandle, Guid* activityID, Guid* relatedActivityID, int dataCount, IntPtr data);
    private void Initialize(Guid eventSourceGuid, string eventSourceName, String[] traits);
    private static string GetName(Type eventSourceType, EventManifestOptions flags);
    private static Guid GenerateGuidFromName(string name);
    private static void DecodeObjects(Object[] decodedObjects, Type[] parameterTypes, EventData* data);
    [ConditionalAttribute("DEBUG")]
private static void AssertValidString(EventData* data);
    private EventDispatcher GetDispatcher(EventListener listener);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
private void WriteEventVarargs(int eventId, Guid* childActivityID, Object[] args);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
private Object[] SerializeEventArgs(int eventId, Object[] args);
    private void LogEventArgsMismatches(int eventId, Object[] args);
    private void WriteToAllListeners(EventWrittenEventArgs eventCallbackArgs, int eventDataCount, EventData* data);
    internal void DispatchToAllListeners(EventWrittenEventArgs eventCallbackArgs);
    private void WriteEventString(string msgString);
    private void WriteStringToAllListeners(string eventName, string msg);
    private bool IsEnabledByDefault(int eventNum, bool enable, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword);
    private bool IsEnabledCommon(bool enabled, EventLevel currentLevel, EventKeywords currentMatchAnyKeyword, EventLevel eventLevel, EventKeywords eventKeywords, EventChannel eventChannel);
    private void ThrowEventSourceException(string eventName, Exception innerEx);
    internal static EventOpcode GetOpcodeWithDefault(EventOpcode opcode, string eventName);
    internal void SendCommand(EventListener listener, EventProviderType eventProviderType, int perEventSourceSessionId, EventCommand command, bool enable, EventLevel level, EventKeywords matchAnyKeyword, IDictionary`2<string, string> commandArguments);
    internal void DoCommand(EventCommandEventArgs commandArgs);
    internal bool EnableEventForDispatcher(EventDispatcher dispatcher, EventProviderType eventProviderType, int eventId, bool value);
    private bool AnyEventEnabled();
    private bool get_IsDisposed();
    private void EnsureDescriptorsInitialized();
    private void SendManifest(Byte[] rawManifest);
    internal static bool IsCustomAttributeDefinedHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2114:ReflectionToDynamicallyAccessedMembers")]
internal static Attribute GetCustomAttributeHelper(MemberInfo member, Type attributeType, EventManifestOptions flags);
    private static bool AttributeTypeNamesMatch(Type attributeType, Type reflectedAttributeType);
    private static Type GetEventSourceBaseType(Type eventSourceType, bool allowEventSourceOverride, bool reflectionOnly);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2114:ReflectionToDynamicallyAccessedMembers")]
private static Byte[] CreateManifestAndDescriptors(Type eventSourceType, string eventSourceDllName, EventSource source, EventManifestOptions flags);
    private static bool RemoveFirstArgIfRelatedActivityId(ParameterInfo[]& args);
    private static void AddProviderEnumKind(ManifestBuilder manifest, FieldInfo staticField, string providerEnumKind);
    private static void AddEventDescriptor(EventMetadata[]& eventData, string eventName, EventAttribute eventAttribute, ParameterInfo[] eventParameters, bool hasRelatedActivityID);
    private static void TrimEventDescriptors(EventMetadata[]& eventData);
    internal void AddListener(EventListener listener);
    private static void DebugCheckEvent(Dictionary`2& eventsByName, EventMetadata[] eventData, MethodInfo method, EventAttribute eventAttribute, ManifestBuilder manifest, EventManifestOptions options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static int GetHelperCallFirstArg(MethodInfo method);
    internal void ReportOutOfBandMessage(string msg);
    private static EventSourceSettings ValidateSettings(EventSourceSettings settings);
    private bool get_ThrowOnEventWriteErrors();
    private bool get_SelfDescribingEvents();
    private protected virtual ReadOnlySpan`1<byte> get_ProviderMetadata();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
public void Write(string eventName);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
public void Write(string eventName, EventSourceOptions options);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
public void Write(string eventName, T data);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
public void Write(string eventName, EventSourceOptions options, T data);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
public void Write(string eventName, EventSourceOptions& options, T& data);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2112:ReflectionToRequiresUnreferencedCode")]
[RequiresUnreferencedCodeAttribute("EventSource will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed.")]
public void Write(string eventName, EventSourceOptions& options, Guid& activityId, Guid& relatedActivityId, T& data);
    private void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    private void WriteMultiMergeInner(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, Object[] values);
    internal void WriteMultiMerge(string eventName, EventSourceOptions& options, TraceLoggingEventTypes eventTypes, Guid* activityID, Guid* childActivityID, EventData* data);
    private void WriteImpl(string eventName, EventSourceOptions& options, object data, Guid* pActivityId, Guid* pRelatedActivityId, TraceLoggingEventTypes eventTypes);
    private void WriteToAllListeners(string eventName, EventDescriptor& eventDescriptor, EventTags tags, Guid* pActivityId, Guid* pChildActivityId, EventPayload payload);
    [NonEventAttribute]
private static void WriteCleanup(GCHandle* pPins, int cPins);
    private void InitializeProviderMetadata();
    private static int AddValueToMetaData(List`1<byte> metaData, string value);
    private static int HexDigit(char c);
    private NameInfo UpdateDescriptor(string name, TraceLoggingEventTypes eventInfo, EventSourceOptions& options, EventDescriptor& descriptor);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2119")]
internal static TraceLoggingEventTypes <WriteEventString>g__GetTrimSafeTraceLoggingEventTypes|78_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class System.Diagnostics.Tracing.EventSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalizationResources>k__BackingField;
    public string Name { get; public set; }
    public string Guid { get; public set; }
    public string LocalizationResources { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LocalizationResources();
    [CompilerGeneratedAttribute]
public void set_LocalizationResources(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventSourceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    public EventSource EventSource { get; internal set; }
    [CompilerGeneratedAttribute]
public EventSource get_EventSource();
    [CompilerGeneratedAttribute]
internal void set_EventSource(EventSource value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventSourceException : Exception {
    public EventSourceException(string message);
    public EventSourceException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EventSourceException(SerializationInfo info, StreamingContext context);
    internal EventSourceException(Exception innerException);
}
public class System.Diagnostics.Tracing.EventSourceOptions : ValueType {
    internal EventKeywords keywords;
    internal EventTags tags;
    internal EventActivityOptions activityOptions;
    internal byte level;
    internal byte opcode;
    internal byte valuesSet;
    public EventLevel Level { get; public set; }
    public EventOpcode Opcode { get; public set; }
    internal bool IsOpcodeSet { get; }
    public EventKeywords Keywords { get; public set; }
    public EventTags Tags { get; public set; }
    public EventActivityOptions ActivityOptions { get; public set; }
    public EventLevel get_Level();
    public void set_Level(EventLevel value);
    public EventOpcode get_Opcode();
    public void set_Opcode(EventOpcode value);
    internal bool get_IsOpcodeSet();
    public EventKeywords get_Keywords();
    public void set_Keywords(EventKeywords value);
    public EventTags get_Tags();
    public void set_Tags(EventTags value);
    public EventActivityOptions get_ActivityOptions();
    public void set_ActivityOptions(EventActivityOptions value);
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventSourceSettings : Enum {
    public int value__;
    public static EventSourceSettings Default;
    public static EventSourceSettings ThrowOnEventWriteErrors;
    public static EventSourceSettings EtwManifestEventFormat;
    public static EventSourceSettings EtwSelfDescribingEventFormat;
}
[FlagsAttribute]
public enum System.Diagnostics.Tracing.EventTags : Enum {
    public int value__;
    public static EventTags None;
}
public enum System.Diagnostics.Tracing.EventTask : Enum {
    public int value__;
    public static EventTask None;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.Tracing.EventWrittenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <EventId>k__BackingField;
    private Guid _activityId;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<object> <Payload>k__BackingField;
    [CompilerGeneratedAttribute]
private EventSource <EventSource>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeStamp>k__BackingField;
    private MoreEventInfo _moreInfo;
    private EventMetadata& Metadata { get; }
    public string EventName { get; internal set; }
    public int EventId { get; }
    public Guid ActivityId { get; }
    public Guid RelatedActivityId { get; }
    public ReadOnlyCollection`1<object> Payload { get; internal set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyCollection`1<string> PayloadNames { get; internal set; }
    [NullableAttribute("1")]
public EventSource EventSource { get; }
    public EventKeywords Keywords { get; internal set; }
    public EventOpcode Opcode { get; internal set; }
    public EventTask Task { get; }
    public EventTags Tags { get; internal set; }
    public string Message { get; internal set; }
    public EventChannel Channel { get; }
    public byte Version { get; }
    public EventLevel Level { get; internal set; }
    public long OSThreadId { get; internal set; }
    public DateTime TimeStamp { get; internal set; }
    [NullableAttribute("1")]
private MoreEventInfo MoreInfo { get; }
    internal EventWrittenEventArgs(EventSource eventSource, int eventId);
    internal EventWrittenEventArgs(EventSource eventSource, int eventId, Guid* pActivityID, Guid* pChildActivityID);
    private EventMetadata& get_Metadata();
    public string get_EventName();
    internal void set_EventName(string value);
    [CompilerGeneratedAttribute]
public int get_EventId();
    public Guid get_ActivityId();
    public Guid get_RelatedActivityId();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<object> get_Payload();
    [CompilerGeneratedAttribute]
internal void set_Payload(ReadOnlyCollection`1<object> value);
    public ReadOnlyCollection`1<string> get_PayloadNames();
    internal void set_PayloadNames(ReadOnlyCollection`1<string> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public EventSource get_EventSource();
    public EventKeywords get_Keywords();
    internal void set_Keywords(EventKeywords value);
    public EventOpcode get_Opcode();
    internal void set_Opcode(EventOpcode value);
    public EventTask get_Task();
    public EventTags get_Tags();
    internal void set_Tags(EventTags value);
    public string get_Message();
    internal void set_Message(string value);
    public EventChannel get_Channel();
    public byte get_Version();
    public EventLevel get_Level();
    internal void set_Level(EventLevel value);
    public long get_OSThreadId();
    internal void set_OSThreadId(long value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
internal void set_TimeStamp(DateTime value);
    private MoreEventInfo get_MoreInfo();
}
internal class System.Diagnostics.Tracing.FieldMetadata : object {
    private string name;
    private int nameSize;
    private EventFieldTags tags;
    private Byte[] custom;
    private ushort fixedCount;
    private byte inType;
    private byte outType;
    public FieldMetadata(string name, TraceLoggingDataType type, EventFieldTags tags, bool variableCount);
    private FieldMetadata(string name, TraceLoggingDataType dataType, EventFieldTags tags, byte countFlags, ushort fixedCount, Byte[] custom);
    public void IncrementStructFieldCount();
    public void Encode(Int32& pos, Byte[] metadata);
}
[EventSourceAttribute]
[GeneratedCodeAttribute("System.Private.CoreLib.Generators", "8.0.10.36612")]
internal class System.Diagnostics.Tracing.FrameworkEventSource : EventSource {
    private static string EventSourceSuppressMessage;
    public static FrameworkEventSource Log;
    private protected ReadOnlySpan`1<byte> ProviderMetadata { get; }
    private FrameworkEventSource(int _);
    private static FrameworkEventSource();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3, bool arg4, int arg5, int arg6);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[NonEventAttribute]
private void WriteEvent(int eventId, long arg1, int arg2, string arg3);
    [EventAttribute("30")]
public void ThreadPoolEnqueueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolEnqueueWorkObject(object workID);
    [EventAttribute("31")]
public void ThreadPoolDequeueWork(long workID);
    [NonEventAttribute]
public void ThreadPoolDequeueWorkObject(object workID);
    [EventAttribute("150")]
public void ThreadTransferSend(long id, int kind, string info, bool multiDequeues, int intInfo1, int intInfo2);
    [NonEventAttribute]
public void ThreadTransferSendObj(object id, int kind, string info, bool multiDequeues, int intInfo1, int intInfo2);
    [EventAttribute("151")]
public void ThreadTransferReceive(long id, int kind, string info);
    [NonEventAttribute]
public void ThreadTransferReceiveObj(object id, int kind, string info);
    private protected virtual ReadOnlySpan`1<byte> get_ProviderMetadata();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.IncrementingCounterPayload : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayRateTimeScale>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Increment>k__BackingField;
    [CompilerGeneratedAttribute]
private float <IntervalSec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Series>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CounterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayUnits>k__BackingField;
    public string Name { get; public set; }
    public string DisplayName { get; public set; }
    public string DisplayRateTimeScale { get; public set; }
    public double Increment { get; public set; }
    public float IntervalSec { get; internal set; }
    public string Metadata { get; public set; }
    public string Series { get; public set; }
    public string CounterType { get; public set; }
    public string DisplayUnits { get; public set; }
    private IEnumerable`1<KeyValuePair`2<string, object>> ForEnumeration { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(string value);
    [CompilerGeneratedAttribute]
public double get_Increment();
    [CompilerGeneratedAttribute]
public void set_Increment(double value);
    [CompilerGeneratedAttribute]
public float get_IntervalSec();
    [CompilerGeneratedAttribute]
internal void set_IntervalSec(float value);
    [CompilerGeneratedAttribute]
public string get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(string value);
    [CompilerGeneratedAttribute]
public string get_Series();
    [CompilerGeneratedAttribute]
public void set_Series(string value);
    [CompilerGeneratedAttribute]
public string get_CounterType();
    [CompilerGeneratedAttribute]
public void set_CounterType(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayUnits();
    [CompilerGeneratedAttribute]
public void set_DisplayUnits(string value);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Diagnostics.Tracing.IncrementingCounterPayload/<get_ForEnumeration>d__39")]
private IEnumerable`1<KeyValuePair`2<string, object>> get_ForEnumeration();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Diagnostics.Tracing.IncrementingEventCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    private double _increment;
    private double _prevIncrement;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingEventCounter(string name, EventSource eventSource);
    public void Increment(double increment);
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
    public virtual string ToString();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Diagnostics.Tracing.IncrementingCounterPayload")]
internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
    internal void UpdateMetric();
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.IncrementingEventCounterPayloadType : object {
    [CompilerGeneratedAttribute]
private IncrementingCounterPayload <Payload>k__BackingField;
    public IncrementingCounterPayload Payload { get; public set; }
    public IncrementingEventCounterPayloadType(IncrementingCounterPayload payload);
    [CompilerGeneratedAttribute]
public IncrementingCounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(IncrementingCounterPayload value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Diagnostics.Tracing.IncrementingPollingCounter : DiagnosticCounter {
    [CompilerGeneratedAttribute]
private TimeSpan <DisplayRateTimeScale>k__BackingField;
    private double _increment;
    private double _prevIncrement;
    private Func`1<double> _totalValueProvider;
    public TimeSpan DisplayRateTimeScale { get; public set; }
    public IncrementingPollingCounter(string name, EventSource eventSource, Func`1<double> totalValueProvider);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public TimeSpan get_DisplayRateTimeScale();
    [CompilerGeneratedAttribute]
public void set_DisplayRateTimeScale(TimeSpan value);
    internal void UpdateMetric();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Diagnostics.Tracing.IncrementingCounterPayload")]
internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.IncrementingPollingCounterPayloadType : object {
    [CompilerGeneratedAttribute]
private IncrementingCounterPayload <Payload>k__BackingField;
    public IncrementingCounterPayload Payload { get; public set; }
    public IncrementingPollingCounterPayloadType(IncrementingCounterPayload payload);
    [CompilerGeneratedAttribute]
public IncrementingCounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(IncrementingCounterPayload value);
}
internal class System.Diagnostics.Tracing.InvokeTypeInfo : TraceLoggingTypeInfo {
    internal PropertyAnalysis[] properties;
    public InvokeTypeInfo(Type type, TypeAnalysis typeAnalysis);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.ManifestBuilder : object {
    private static String[] s_escapes;
    private Dictionary`2<int, string> opcodeTab;
    private Dictionary`2<int, string> taskTab;
    private Dictionary`2<int, ChannelInfo> channelTab;
    private Dictionary`2<ulong, string> keywordTab;
    private Dictionary`2<string, Type> mapsTab;
    private Dictionary`2<string, string> stringTab;
    private ulong nextChannelKeywordBit;
    private StringBuilder sb;
    private StringBuilder events;
    private StringBuilder templates;
    private string providerName;
    private ResourceManager resources;
    private EventManifestOptions flags;
    private List`1<string> errors;
    private Dictionary`2<string, List`1<int>> perEventByteArrayArgIndices;
    private string eventName;
    private int numParams;
    private List`1<int> byteArrArgIndices;
    public IList`1<string> Errors { get; }
    public bool HasResources { get; }
    public ManifestBuilder(string providerName, Guid providerGuid, string dllName, ResourceManager resources, EventManifestOptions flags);
    internal ManifestBuilder(ResourceManager resources, EventManifestOptions flags);
    private static ManifestBuilder();
    public void AddOpcode(string name, int value);
    public void AddTask(string name, int value);
    public void AddKeyword(string name, ulong value);
    public void AddChannel(string name, int value, EventChannelAttribute channelAttribute);
    private static EventChannelType EventChannelToChannelType(EventChannel channel);
    private static EventChannelAttribute GetDefaultChannelAttribute(EventChannel channel);
    public UInt64[] GetChannelData();
    public void StartEvent(string eventName, EventAttribute eventAttribute);
    public void AddEventParameter(Type type, string name);
    public void EndEvent();
    public ulong GetChannelKeyword(EventChannel channel, ulong channelKeyword);
    public Byte[] CreateManifest();
    public IList`1<string> get_Errors();
    public bool get_HasResources();
    public void ManifestError(string msg, bool runtimeCritical);
    private string CreateManifestString();
    private void WriteNameAndMessageAttribs(StringBuilder stringBuilder, string elementName, string name);
    private void WriteMessageAttrib(StringBuilder stringBuilder, string elementName, string name, string value);
    internal string GetLocalizedMessage(string key, CultureInfo ci, bool etwFormat);
    private static void AppendLevelName(StringBuilder sb, EventLevel level);
    private string GetChannelName(EventChannel channel, string eventName, string eventMessage);
    private string GetTaskName(EventTask task, string eventName);
    private string GetOpcodeName(EventOpcode opcode, string eventName);
    private void AppendKeywords(StringBuilder sb, ulong keywords, string eventName);
    private string GetTypeName(Type type);
    private static void UpdateStringBuilder(StringBuilder& stringBuilder, string eventMessage, int startIndex, int count);
    private string TranslateToManifestConvention(string eventMessage, string evtName);
    private int TranslateIndexToManifestConvention(int idx, string evtName);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
internal static FieldInfo[] <CreateManifestString>g__GetEnumFields|19_0(Type localEnumType);
}
internal class System.Diagnostics.Tracing.ManifestEnvelope : ValueType {
    public ManifestFormats Format;
    public byte MajorVersion;
    public byte MinorVersion;
    public byte Magic;
    public ushort TotalChunks;
    public ushort ChunkNumber;
}
internal class System.Diagnostics.Tracing.NameInfo : ConcurrentSetItem`2<KeyValuePair`2<string, EventTags>, NameInfo> {
    private static int lastIdentity;
    internal string name;
    internal EventTags tags;
    internal int identity;
    internal Byte[] nameMetadata;
    public NameInfo(string name, EventTags tags, int typeMetadataSize);
    private static NameInfo();
    internal static void ReserveEventIDsBelow(int eventId);
    public virtual int Compare(NameInfo other);
    public virtual int Compare(KeyValuePair`2<string, EventTags> key);
    private int Compare(string otherName, EventTags otherTags);
    public IntPtr GetOrCreateEventHandle(EventProvider provider, TraceLoggingEventHandleTable eventHandleTable, EventDescriptor descriptor, TraceLoggingEventTypes eventTypes);
}
[EventSourceAttribute]
[GeneratedCodeAttribute("System.Private.CoreLib.Generators", "8.0.10.36612")]
internal class System.Diagnostics.Tracing.NativeRuntimeEventSource : EventSource {
    internal static string EventSourceName;
    public static NativeRuntimeEventSource Log;
    private static ushort DefaultClrInstanceId;
    private protected ReadOnlySpan`1<byte> ProviderMetadata { get; }
    private NativeRuntimeEventSource(int _);
    private static NativeRuntimeEventSource();
    [NonEventAttribute]
private static void LogContentionLockCreated(IntPtr LockID, IntPtr AssociatedObjectID, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogContentionStart(ContentionFlagsMap ContentionFlags, ushort ClrInstanceID, IntPtr LockID, IntPtr AssociatedObjectID, ulong LockOwnerThreadID);
    [NonEventAttribute]
private static void LogContentionStop(ContentionFlagsMap ContentionFlags, ushort ClrInstanceID, double DurationNs);
    [NonEventAttribute]
private static void LogThreadPoolWorkerThreadStart(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolWorkerThreadStop(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolWorkerThreadWait(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolMinMaxThreads(ushort MinWorkerThreads, ushort MaxWorkerThreads, ushort MinIOCompletionThreads, ushort MaxIOCompletionThreads, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolWorkerThreadAdjustmentSample(double Throughput, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolWorkerThreadAdjustmentAdjustment(double AverageThroughput, UInt32 NewWorkerThreadCount, ThreadAdjustmentReasonMap Reason, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolWorkerThreadAdjustmentStats(double Duration, double Throughput, double ThreadPoolWorkerThreadWait, double ThroughputWave, double ThroughputErrorEstimate, double AverageThroughputErrorEstimate, double ThroughputRatio, double Confidence, double NewControlSetting, ushort NewThreadWaveMagnitude, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolIOEnqueue(IntPtr NativeOverlapped, IntPtr Overlapped, bool MultiDequeues, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolIODequeue(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolWorkingThreadCount(UInt32 Count, ushort ClrInstanceID);
    [NonEventAttribute]
private static void LogThreadPoolIOPack(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [NonEventAttribute]
internal void ProcessEvent(UInt32 eventID, UInt32 osThreadID, DateTime timeStamp, Guid activityId, Guid childActivityId, ReadOnlySpan`1<byte> payload);
    [EventAttribute("90")]
private void ContentionLockCreated(IntPtr LockID, IntPtr AssociatedObjectID, ushort ClrInstanceID);
    [EventAttribute("81")]
private void ContentionStart(ContentionFlagsMap ContentionFlags, ushort ClrInstanceID, IntPtr LockID, IntPtr AssociatedObjectID, ulong LockOwnerThreadID);
    [EventAttribute("91")]
private void ContentionStop(ContentionFlagsMap ContentionFlags, ushort ClrInstanceID, double DurationNs);
    [NonEventAttribute]
public void ContentionStop(double durationNs);
    [EventAttribute("50")]
public void ThreadPoolWorkerThreadStart(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("51")]
public void ThreadPoolWorkerThreadStop(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("57")]
public void ThreadPoolWorkerThreadWait(UInt32 ActiveWorkerThreadCount, UInt32 RetiredWorkerThreadCount, ushort ClrInstanceID);
    [EventAttribute("54")]
public void ThreadPoolWorkerThreadAdjustmentSample(double Throughput, ushort ClrInstanceID);
    [EventAttribute("55")]
public void ThreadPoolWorkerThreadAdjustmentAdjustment(double AverageThroughput, UInt32 NewWorkerThreadCount, ThreadAdjustmentReasonMap Reason, ushort ClrInstanceID);
    [EventAttribute("56")]
public void ThreadPoolWorkerThreadAdjustmentStats(double Duration, double Throughput, double ThreadWave, double ThroughputWave, double ThroughputErrorEstimate, double AverageThroughputErrorEstimate, double ThroughputRatio, double Confidence, double NewControlSetting, ushort NewThreadWaveMagnitude, ushort ClrInstanceID);
    [EventAttribute("63")]
private void ThreadPoolIOEnqueue(IntPtr NativeOverlapped, IntPtr Overlapped, bool MultiDequeues, ushort ClrInstanceID);
    [NonEventAttribute]
public void ThreadPoolIOEnqueue(NativeOverlapped* nativeOverlapped);
    [NonEventAttribute]
public void ThreadPoolIOEnqueue(RegisteredWaitHandle registeredWaitHandle);
    [EventAttribute("64")]
private void ThreadPoolIODequeue(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [NonEventAttribute]
public void ThreadPoolIODequeue(NativeOverlapped* nativeOverlapped);
    [NonEventAttribute]
public void ThreadPoolIODequeue(RegisteredWaitHandle registeredWaitHandle);
    [EventAttribute("60")]
public void ThreadPoolWorkingThreadCount(UInt32 Count, ushort ClrInstanceID);
    [NonEventAttribute]
public void ThreadPoolIOPack(NativeOverlapped* nativeOverlapped);
    [EventAttribute("65")]
private void ThreadPoolIOPack(IntPtr NativeOverlapped, IntPtr Overlapped, ushort ClrInstanceID);
    [EventAttribute("59")]
public void ThreadPoolMinMaxThreads(ushort MinWorkerThreads, ushort MaxWorkerThreads, ushort MinIOCompletionThreads, ushort MaxIOCompletionThreads, ushort ClrInstanceID);
    [EventAttribute("1")]
private void GCStart_V2(UInt32 Count, UInt32 Depth, UInt32 Reason, UInt32 Type, ushort ClrInstanceID, ulong ClientSequenceNumber);
    [EventAttribute("2")]
private void GCEnd_V1(UInt32 Count, UInt32 Depth, ushort ClrInstanceID);
    [EventAttribute("3")]
private void GCRestartEEEnd_V1(ushort ClrInstanceID);
    [EventAttribute("4")]
private void GCHeapStats_V2(ulong GenerationSize0, ulong TotalPromotedSize0, ulong GenerationSize1, ulong TotalPromotedSize1, ulong GenerationSize2, ulong TotalPromotedSize2, ulong GenerationSize3, ulong TotalPromotedSize3, ulong FinalizationPromotedSize, ulong FinalizationPromotedCount, UInt32 PinnedObjectCount, UInt32 SinkBlockCount, UInt32 GCHandleCount, ushort ClrInstanceID, ulong GenerationSize4, ulong TotalPromotedSize4);
    [EventAttribute("5")]
private void GCCreateSegment_V1(ulong Address, ulong Size, UInt32 Type, ushort ClrInstanceID);
    [EventAttribute("6")]
private void GCFreeSegment_V1(ulong Address, ushort ClrInstanceID);
    [EventAttribute("7")]
private void GCRestartEEBegin_V1(ushort ClrInstanceID);
    [EventAttribute("8")]
private void GCSuspendEEEnd_V1(ushort ClrInstanceID);
    [EventAttribute("9")]
private void GCSuspendEEBegin_V1(UInt32 Reason, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("10")]
private void GCAllocationTick_V4(UInt32 AllocationAmount, UInt32 AllocationKind, ushort ClrInstanceID, ulong AllocationAmount64, IntPtr TypeID, string TypeName, UInt32 HeapIndex, IntPtr Address, ulong ObjectSize);
    [EventAttribute("11")]
private void GCCreateConcurrentThread_V1(ushort ClrInstanceID);
    [EventAttribute("12")]
private void GCTerminateConcurrentThread_V1(ushort ClrInstanceID);
    [EventAttribute("13")]
private void GCFinalizersEnd_V1(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("14")]
private void GCFinalizersBegin_V1(ushort ClrInstanceID);
    [EventAttribute("15")]
private void BulkType(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("16")]
private void GCBulkRootEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("17")]
private void GCBulkRootConditionalWeakTableElementEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("18")]
private void GCBulkNode(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("19")]
private void GCBulkEdge(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("20")]
private void GCSampledObjectAllocationHigh(IntPtr Address, IntPtr TypeID, UInt32 ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID);
    [EventAttribute("21")]
private void GCBulkSurvivingObjectRanges(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("22")]
private void GCBulkMovedObjectRanges(UInt32 Index, UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("23")]
private void GCGenerationRange(byte Generation, IntPtr RangeStart, ulong RangeUsedLength, ulong RangeReservedLength, ushort ClrInstanceID);
    [EventAttribute("25")]
private void GCMarkStackRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("26")]
private void GCMarkFinalizeQueueRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("27")]
private void GCMarkHandles(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("28")]
private void GCMarkOlderGenerationRoots(UInt32 HeapNum, ushort ClrInstanceID);
    [EventAttribute("29")]
private void FinalizeObject(IntPtr TypeID, IntPtr ObjectID, ushort ClrInstanceID);
    [EventAttribute("30")]
private void SetGCHandle(IntPtr HandleID, IntPtr ObjectID, UInt32 Kind, UInt32 Generation, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("31")]
private void DestroyGCHandle(IntPtr HandleID, ushort ClrInstanceID);
    [EventAttribute("32")]
private void GCSampledObjectAllocationLow(IntPtr Address, IntPtr TypeID, UInt32 ObjectCountForTypeSample, ulong TotalSizeForTypeSample, ushort ClrInstanceID);
    [EventAttribute("33")]
private void PinObjectAtGCTime(IntPtr HandleID, IntPtr ObjectID, ulong ObjectSize, string TypeName, ushort ClrInstanceID);
    [EventAttribute("35")]
private void GCTriggered(UInt32 Reason, ushort ClrInstanceID);
    [EventAttribute("36")]
private void GCBulkRootCCW(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("37")]
private void GCBulkRCW(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("38")]
private void GCBulkRootStaticVar(UInt32 Count, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("39")]
private void GCDynamicEvent(string Name, UInt32 DataSize);
    [EventAttribute("40")]
private void WorkerThreadCreate(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("41")]
private void WorkerThreadTerminate(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("42")]
private void WorkerThreadRetire(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("43")]
private void WorkerThreadUnretire(UInt32 WorkerThreadCount, UInt32 RetiredWorkerThreads);
    [EventAttribute("44")]
private void IOThreadCreate_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("45")]
private void IOThreadTerminate_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("46")]
private void IOThreadRetire_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("47")]
private void IOThreadUnretire_V1(UInt32 IOThreadCount, UInt32 RetiredIOThreads, ushort ClrInstanceID);
    [EventAttribute("48")]
private void ThreadpoolSuspensionSuspendThread(UInt32 ClrThreadID, UInt32 CpuUtilization);
    [EventAttribute("49")]
private void ThreadpoolSuspensionResumeThread(UInt32 ClrThreadID, UInt32 CpuUtilization);
    [EventAttribute("58")]
private void YieldProcessorMeasurement(ushort ClrInstanceID, double NsPerYield, double EstablishedNsPerYield);
    [EventAttribute("70")]
private void ThreadCreating(IntPtr ID, ushort ClrInstanceID);
    [EventAttribute("71")]
private void ThreadRunning(IntPtr ID, ushort ClrInstanceID);
    [EventAttribute("72")]
private void MethodDetails(ulong MethodID, ulong TypeID, UInt32 MethodToken, UInt32 TypeParameterCount, ulong LoaderModuleID);
    [EventAttribute("73")]
private void TypeLoadStart(UInt32 TypeLoadStartID, ushort ClrInstanceID);
    [EventAttribute("74")]
private void TypeLoadStop(UInt32 TypeLoadStartID, ushort ClrInstanceID, ushort LoadLevel, ulong TypeID, string TypeName);
    [EventAttribute("80")]
private void ExceptionThrown_V1(string ExceptionType, string ExceptionMessage, IntPtr ExceptionEIP, UInt32 ExceptionHRESULT, ushort ExceptionFlags, ushort ClrInstanceID);
    [EventAttribute("250")]
private void ExceptionCatchStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("251")]
private void ExceptionCatchStop();
    [EventAttribute("252")]
private void ExceptionFinallyStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("253")]
private void ExceptionFinallyStop();
    [EventAttribute("254")]
private void ExceptionFilterStart(ulong EntryEIP, ulong MethodID, string MethodName, ushort ClrInstanceID);
    [EventAttribute("255")]
private void ExceptionFilterStop();
    [EventAttribute("256")]
private void ExceptionThrownStop();
    [EventAttribute("82")]
private void CLRStackWalk(ushort ClrInstanceID, byte Reserved1, byte Reserved2, UInt32 FrameCount);
    [EventAttribute("83")]
private void AppDomainMemAllocated(ulong AppDomainID, ulong Allocated, ushort ClrInstanceID);
    [EventAttribute("84")]
private void AppDomainMemSurvived(ulong AppDomainID, ulong Survived, ulong ProcessSurvived, ushort ClrInstanceID);
    [EventAttribute("85")]
private void ThreadCreated(ulong ManagedThreadID, ulong AppDomainID, UInt32 Flags, UInt32 ManagedThreadIndex, UInt32 OSThreadID, ushort ClrInstanceID);
    [EventAttribute("86")]
private void ThreadTerminated(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("87")]
private void ThreadDomainEnter(ulong ManagedThreadID, ulong AppDomainID, ushort ClrInstanceID);
    [EventAttribute("88")]
private void ILStubGenerated(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, UInt32 StubFlags, UInt32 ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature, string NativeMethodSignature, string StubMethodSignature, string StubMethodILCode);
    [EventAttribute("89")]
private void ILStubCacheHit(ushort ClrInstanceID, ulong ModuleID, ulong StubMethodID, UInt32 ManagedInteropMethodToken, string ManagedInteropMethodNamespace, string ManagedInteropMethodName, string ManagedInteropMethodSignature);
    [EventAttribute("135")]
private void DCStartCompleteV2();
    [EventAttribute("136")]
private void DCEndCompleteV2();
    [EventAttribute("137")]
private void MethodDCStartV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags);
    [EventAttribute("138")]
private void MethodDCEndV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags);
    [EventAttribute("139")]
private void MethodDCStartVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("140")]
private void MethodDCEndVerboseV2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("141")]
private void MethodLoad_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("159")]
private void R2RGetEntryPoint(ulong MethodID, string MethodNamespace, string MethodName, string MethodSignature, ulong EntryPoint, ushort ClrInstanceID);
    [EventAttribute("160")]
private void R2RGetEntryPointStart(ulong MethodID, ushort ClrInstanceID);
    [EventAttribute("142")]
private void MethodUnload_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("143")]
private void MethodLoadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("144")]
private void MethodUnloadVerbose_V2(ulong MethodID, ulong ModuleID, ulong MethodStartAddress, UInt32 MethodSize, UInt32 MethodToken, UInt32 MethodFlags, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID, ulong ReJITID);
    [EventAttribute("145")]
private void MethodJittingStarted_V1(ulong MethodID, ulong ModuleID, UInt32 MethodToken, UInt32 MethodILSize, string MethodNamespace, string MethodName, string MethodSignature, ushort ClrInstanceID);
    [EventAttribute("146")]
private void MethodJitMemoryAllocatedForCode(ulong MethodID, ulong ModuleID, ulong JitHotCodeRequestSize, ulong JitRODataRequestSize, ulong AllocatedSizeForJitCode, UInt32 JitAllocFlag, ushort ClrInstanceID);
    [EventAttribute("185")]
private void MethodJitInliningSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, ushort ClrInstanceID);
    [EventAttribute("186")]
private void MethodJitInliningFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways);
    [EventAttribute("188")]
private void MethodJitTailCallSucceeded(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, UInt32 TailCallType, ushort ClrInstanceID);
    [EventAttribute("189")]
private void MethodJitTailCallFailedAnsi(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix);
    [EventAttribute("190")]
private void MethodILToNativeMap_V1(ulong MethodID, ulong ReJITID, byte MethodExtent, ushort CountOfMapEntries);
    [EventAttribute("191")]
private void MethodJitTailCallFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string CallerNamespace, string CallerName, string CallerNameSignature, string CalleeNamespace, string CalleeName, string CalleeNameSignature, bool TailPrefix, string FailReason, ushort ClrInstanceID);
    [EventAttribute("192")]
private void MethodJitInliningFailed(string MethodBeingCompiledNamespace, string MethodBeingCompiledName, string MethodBeingCompiledNameSignature, string InlinerNamespace, string InlinerName, string InlinerNameSignature, string InlineeNamespace, string InlineeName, string InlineeNameSignature, bool FailAlways, string FailReason, ushort ClrInstanceID);
    [EventAttribute("149")]
private void ModuleDCStartV2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath);
    [EventAttribute("150")]
private void ModuleDCEndV2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath);
    [EventAttribute("151")]
private void DomainModuleLoad_V1(ulong ModuleID, ulong AssemblyID, ulong AppDomainID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID);
    [EventAttribute("152")]
private void ModuleLoad_V2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, UInt32 ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, UInt32 NativePdbAge, string NativePdbBuildPath);
    [EventAttribute("153")]
private void ModuleUnload_V2(ulong ModuleID, ulong AssemblyID, UInt32 ModuleFlags, UInt32 Reserved1, string ModuleILPath, string ModuleNativePath, ushort ClrInstanceID, Guid ManagedPdbSignature, UInt32 ManagedPdbAge, string ManagedPdbBuildPath, Guid NativePdbSignature, UInt32 NativePdbAge, string NativePdbBuildPath);
    [EventAttribute("154")]
private void AssemblyLoad_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, UInt32 AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("155")]
private void AssemblyUnload_V1(ulong AssemblyID, ulong AppDomainID, ulong BindingID, UInt32 AssemblyFlags, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("156")]
private void AppDomainLoad_V1(ulong AppDomainID, UInt32 AppDomainFlags, string AppDomainName, UInt32 AppDomainIndex, ushort ClrInstanceID);
    [EventAttribute("157")]
private void AppDomainUnload_V1(ulong AppDomainID, UInt32 AppDomainFlags, string AppDomainName, UInt32 AppDomainIndex, ushort ClrInstanceID);
    [EventAttribute("158")]
private void ModuleRangeLoad(ushort ClrInstanceID, ulong ModuleID, UInt32 RangeBegin, UInt32 RangeSize, byte RangeType);
    [EventAttribute("181")]
private void StrongNameVerificationStart_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("182")]
private void StrongNameVerificationStop_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string FullyQualifiedAssemblyName, ushort ClrInstanceID);
    [EventAttribute("183")]
private void AuthenticodeVerificationStart_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string ModulePath, ushort ClrInstanceID);
    [EventAttribute("184")]
private void AuthenticodeVerificationStop_V1(UInt32 VerificationFlags, UInt32 ErrorCode, string ModulePath, ushort ClrInstanceID);
    [EventAttribute("187")]
private void RuntimeInformationStart(ushort ClrInstanceID, ushort Sku, ushort BclMajorVersion, ushort BclMinorVersion, ushort BclBuildNumber, ushort BclQfeNumber, ushort VMMajorVersion, ushort VMMinorVersion, ushort VMBuildNumber, ushort VMQfeNumber, UInt32 StartupFlags, byte StartupMode, string CommandLine, Guid ComObjectGuid, string RuntimeDllPath);
    [EventAttribute("200")]
private void IncreaseMemoryPressure(ulong BytesAllocated, ushort ClrInstanceID);
    [EventAttribute("201")]
private void DecreaseMemoryPressure(ulong BytesFreed, ushort ClrInstanceID);
    [EventAttribute("202")]
private void GCMarkWithType(UInt32 HeapNum, ushort ClrInstanceID, UInt32 Type, ulong Bytes);
    [EventAttribute("203")]
private void GCJoin_V2(UInt32 Heap, UInt32 JoinTime, UInt32 JoinType, ushort ClrInstanceID, UInt32 JoinID);
    [EventAttribute("204")]
private void GCPerHeapHistory_V3(ushort ClrInstanceID, IntPtr FreeListAllocated, IntPtr FreeListRejected, IntPtr EndOfSegAllocated, IntPtr CondemnedAllocated, IntPtr PinnedAllocated, IntPtr PinnedAllocatedAdvance, UInt32 RunningFreeListEfficiency, UInt32 CondemnReasons0, UInt32 CondemnReasons1, UInt32 CompactMechanisms, UInt32 ExpandMechanisms, UInt32 HeapIndex, IntPtr ExtraGen0Commit, UInt32 Count);
    [EventAttribute("205")]
private void GCGlobalHeapHistory_V4(ulong FinalYoungestDesired, int NumHeaps, UInt32 CondemnedGeneration, UInt32 Gen0ReductionCount, UInt32 Reason, UInt32 GlobalMechanisms, ushort ClrInstanceID, UInt32 PauseMode, UInt32 MemoryPressure, UInt32 CondemnReasons0, UInt32 CondemnReasons1, UInt32 Count);
    [EventAttribute("206")]
private void GenAwareBegin(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("207")]
private void GenAwareEnd(UInt32 Count, ushort ClrInstanceID);
    [EventAttribute("208")]
private void GCLOHCompact(ushort ClrInstanceID, ushort Count);
    [EventAttribute("209")]
private void GCFitBucketInfo(ushort ClrInstanceID, ushort BucketKind, ulong TotalSize, ushort Count);
    [EventAttribute("240")]
private void DebugIPCEventStart();
    [EventAttribute("241")]
private void DebugIPCEventEnd();
    [EventAttribute("242")]
private void DebugExceptionProcessingStart();
    [EventAttribute("243")]
private void DebugExceptionProcessingEnd();
    [EventAttribute("260")]
private void CodeSymbols(ulong ModuleId, ushort TotalChunks, ushort ChunkNumber, UInt32 ChunkLength);
    [EventAttribute("270")]
private void EventSource(int EventID, string EventName, string EventSourceName, string Payload);
    [EventAttribute("280")]
private void TieredCompilationSettings(ushort ClrInstanceID, UInt32 Flags);
    [EventAttribute("281")]
private void TieredCompilationPause(ushort ClrInstanceID);
    [EventAttribute("282")]
private void TieredCompilationResume(ushort ClrInstanceID, UInt32 NewMethodCount);
    [EventAttribute("283")]
private void TieredCompilationBackgroundJitStart(ushort ClrInstanceID, UInt32 PendingMethodCount);
    [EventAttribute("284")]
private void TieredCompilationBackgroundJitStop(ushort ClrInstanceID, UInt32 PendingMethodCount, UInt32 JittedMethodCount);
    [EventAttribute("290")]
private void AssemblyLoadStart(ushort ClrInstanceID, string AssemblyName, string AssemblyPath, string RequestingAssembly, string AssemblyLoadContext, string RequestingAssemblyLoadContext);
    [EventAttribute("291")]
private void AssemblyLoadStop(ushort ClrInstanceID, string AssemblyName, string AssemblyPath, string RequestingAssembly, string AssemblyLoadContext, string RequestingAssemblyLoadContext, bool Success, string ResultAssemblyName, string ResultAssemblyPath, bool Cached);
    [EventAttribute("292")]
private void ResolutionAttempted(ushort ClrInstanceID, string AssemblyName, ushort Stage, string AssemblyLoadContext, ushort Result, string ResultAssemblyName, string ResultAssemblyPath, string ErrorMessage);
    [EventAttribute("293")]
private void AssemblyLoadContextResolvingHandlerInvoked(ushort ClrInstanceID, string AssemblyName, string HandlerName, string AssemblyLoadContext, string ResultAssemblyName, string ResultAssemblyPath);
    [EventAttribute("294")]
private void AppDomainAssemblyResolveHandlerInvoked(ushort ClrInstanceID, string AssemblyName, string HandlerName, string ResultAssemblyName, string ResultAssemblyPath);
    [EventAttribute("295")]
private void AssemblyLoadFromResolveHandlerInvoked(ushort ClrInstanceID, string AssemblyName, bool IsTrackedLoad, string RequestingAssemblyPath, string ComputedRequestedAssemblyPath);
    [EventAttribute("296")]
private void KnownPathProbed(ushort ClrInstanceID, string FilePath, ushort Source, int Result);
    [EventAttribute("297")]
private void JitInstrumentationData(ushort ClrInstanceID, UInt32 MethodFlags, UInt32 DataSize, ulong MethodID);
    [EventAttribute("298")]
private void JitInstrumentationDataVerbose(ushort ClrInstanceID, UInt32 MethodFlags, UInt32 DataSize, ulong MethodID, ulong ModuleID, UInt32 MethodToken, string MethodNamespace, string MethodName, string MethodSignature);
    [EventAttribute("299")]
private void ProfilerMessage(ushort ClrInstanceID, string Message);
    [EventAttribute("300")]
private void ExecutionCheckpoint(ushort ClrInstanceID, string Name, long Timestamp);
    private protected virtual ReadOnlySpan`1<byte> get_ProviderMetadata();
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.Tracing.NonEventAttribute : Attribute {
}
internal class System.Diagnostics.Tracing.NullableTypeInfo : TraceLoggingTypeInfo {
    private TraceLoggingTypeInfo valueInfo;
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
public NullableTypeInfo(Type type, List`1<Type> recursionCheck);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2072:UnrecognizedReflectionPattern")]
public virtual void WriteData(PropertyValue value);
}
internal class System.Diagnostics.Tracing.NullTypeInfo : TraceLoggingTypeInfo {
    private static NullTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Diagnostics.Tracing.PollingCounter : DiagnosticCounter {
    private Func`1<double> _metricProvider;
    private double _lastVal;
    public PollingCounter(string name, EventSource eventSource, Func`1<double> metricProvider);
    public virtual string ToString();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[DynamicDependencyAttribute("512", "System.Diagnostics.Tracing.CounterPayload")]
internal virtual void WritePayload(float intervalSec, int pollingIntervalMillisec);
}
[EventDataAttribute]
internal class System.Diagnostics.Tracing.PollingPayloadType : object {
    [CompilerGeneratedAttribute]
private CounterPayload <Payload>k__BackingField;
    public CounterPayload Payload { get; public set; }
    public PollingPayloadType(CounterPayload payload);
    [CompilerGeneratedAttribute]
public CounterPayload get_Payload();
    [CompilerGeneratedAttribute]
public void set_Payload(CounterPayload value);
}
internal class System.Diagnostics.Tracing.PropertyAnalysis : object {
    internal string name;
    internal PropertyInfo propertyInfo;
    internal Func`2<PropertyValue, PropertyValue> getter;
    internal TraceLoggingTypeInfo typeInfo;
    internal EventFieldAttribute fieldAttribute;
    public PropertyAnalysis(string name, PropertyInfo propertyInfo, TraceLoggingTypeInfo typeInfo, EventFieldAttribute fieldAttribute);
}
[IsReadOnlyAttribute]
internal class System.Diagnostics.Tracing.PropertyValue : ValueType {
    private object _reference;
    private Scalar _scalar;
    private int _scalarLength;
    public object ReferenceValue { get; }
    public Scalar ScalarValue { get; }
    public int ScalarLength { get; }
    private PropertyValue(object value);
    private PropertyValue(Scalar scalar, int scalarLength);
    private PropertyValue(bool value);
    private PropertyValue(byte value);
    private PropertyValue(sbyte value);
    private PropertyValue(char value);
    private PropertyValue(short value);
    private PropertyValue(ushort value);
    private PropertyValue(int value);
    private PropertyValue(UInt32 value);
    private PropertyValue(long value);
    private PropertyValue(ulong value);
    private PropertyValue(IntPtr value);
    private PropertyValue(UIntPtr value);
    private PropertyValue(float value);
    private PropertyValue(double value);
    private PropertyValue(Guid value);
    private PropertyValue(DateTime value);
    private PropertyValue(DateTimeOffset value);
    private PropertyValue(TimeSpan value);
    private PropertyValue(decimal value);
    public static Func`2<object, PropertyValue> GetFactory(Type type);
    public object get_ReferenceValue();
    public Scalar get_ScalarValue();
    public int get_ScalarLength();
    public static Func`2<PropertyValue, PropertyValue> GetPropertyGetter(PropertyInfo property);
    private static Func`2<PropertyValue, PropertyValue> GetBoxedValueTypePropertyGetter(PropertyInfo property);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
private static Func`2<PropertyValue, PropertyValue> GetReferenceTypePropertyGetter(PropertyInfo property);
}
[EventSourceAttribute]
[GeneratedCodeAttribute("System.Private.CoreLib.Generators", "8.0.10.36612")]
internal class System.Diagnostics.Tracing.RuntimeEventSource : EventSource {
    internal static string EventSourceName;
    private static RuntimeEventSource s_RuntimeEventSource;
    private PollingCounter _gcHeapSizeCounter;
    private IncrementingPollingCounter _gen0GCCounter;
    private IncrementingPollingCounter _gen1GCCounter;
    private IncrementingPollingCounter _gen2GCCounter;
    private PollingCounter _gen0BudgetCounter;
    private PollingCounter _cpuTimeCounter;
    private PollingCounter _workingSetCounter;
    private PollingCounter _threadPoolThreadCounter;
    private IncrementingPollingCounter _monitorContentionCounter;
    private PollingCounter _threadPoolQueueCounter;
    private IncrementingPollingCounter _completedItemsCounter;
    private IncrementingPollingCounter _allocRateCounter;
    private PollingCounter _timerCounter;
    private PollingCounter _fragmentationCounter;
    private PollingCounter _committedCounter;
    private IncrementingPollingCounter _exceptionCounter;
    private PollingCounter _gcTimeCounter;
    private IncrementingPollingCounter _totalGcPauseTimeCounter;
    private PollingCounter _gen0SizeCounter;
    private PollingCounter _gen1SizeCounter;
    private PollingCounter _gen2SizeCounter;
    private PollingCounter _lohSizeCounter;
    private PollingCounter _pohSizeCounter;
    private PollingCounter _assemblyCounter;
    private PollingCounter _ilBytesJittedCounter;
    private PollingCounter _methodsJittedCounter;
    private IncrementingPollingCounter _jitTimeCounter;
    private protected ReadOnlySpan`1<byte> ProviderMetadata { get; }
    private RuntimeEventSource(int _);
    public static void Initialize();
    [EventAttribute("1")]
internal void LogAppContextSwitch(string switchName, int value);
    [EventAttribute("2")]
internal void ProcessorCount(int processorCount);
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    private protected virtual ReadOnlySpan`1<byte> get_ProviderMetadata();
}
internal static class System.Diagnostics.Tracing.RuntimeEventSourceHelper : object {
    private static ProcessCpuInformation s_cpuInfo;
    internal static double GetCpuUsage();
}
internal class System.Diagnostics.Tracing.ScalarArrayTypeInfo : TraceLoggingTypeInfo {
    private static ScalarArrayTypeInfo s_boolean;
    private static ScalarArrayTypeInfo s_byte;
    private static ScalarArrayTypeInfo s_sbyte;
    private static ScalarArrayTypeInfo s_char;
    private static ScalarArrayTypeInfo s_int16;
    private static ScalarArrayTypeInfo s_uint16;
    private static ScalarArrayTypeInfo s_int32;
    private static ScalarArrayTypeInfo s_uint32;
    private static ScalarArrayTypeInfo s_int64;
    private static ScalarArrayTypeInfo s_uint64;
    private static ScalarArrayTypeInfo s_intptr;
    private static ScalarArrayTypeInfo s_uintptr;
    private static ScalarArrayTypeInfo s_single;
    private static ScalarArrayTypeInfo s_double;
    private static ScalarArrayTypeInfo s_guid;
    private TraceLoggingDataType nativeFormat;
    private int elementSize;
    private ScalarArrayTypeInfo(Type type, TraceLoggingDataType nativeFormat, int elementSize);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
internal class System.Diagnostics.Tracing.ScalarTypeInfo : TraceLoggingTypeInfo {
    private static ScalarTypeInfo s_boolean;
    private static ScalarTypeInfo s_byte;
    private static ScalarTypeInfo s_sbyte;
    private static ScalarTypeInfo s_char;
    private static ScalarTypeInfo s_int16;
    private static ScalarTypeInfo s_uint16;
    private static ScalarTypeInfo s_int32;
    private static ScalarTypeInfo s_uint32;
    private static ScalarTypeInfo s_int64;
    private static ScalarTypeInfo s_uint64;
    private static ScalarTypeInfo s_intptr;
    private static ScalarTypeInfo s_uintptr;
    private static ScalarTypeInfo s_single;
    private static ScalarTypeInfo s_double;
    private static ScalarTypeInfo s_guid;
    private TraceLoggingDataType nativeFormat;
    private ScalarTypeInfo(Type type, TraceLoggingDataType nativeFormat);
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public static TraceLoggingTypeInfo Boolean();
    public static TraceLoggingTypeInfo Byte();
    public static TraceLoggingTypeInfo SByte();
    public static TraceLoggingTypeInfo Char();
    public static TraceLoggingTypeInfo Int16();
    public static TraceLoggingTypeInfo UInt16();
    public static TraceLoggingTypeInfo Int32();
    public static TraceLoggingTypeInfo UInt32();
    public static TraceLoggingTypeInfo Int64();
    public static TraceLoggingTypeInfo UInt64();
    public static TraceLoggingTypeInfo IntPtr();
    public static TraceLoggingTypeInfo UIntPtr();
    public static TraceLoggingTypeInfo Single();
    public static TraceLoggingTypeInfo Double();
    public static TraceLoggingTypeInfo Guid();
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.SessionMask : ValueType {
    private UInt32 m_mask;
    public static SessionMask All { get; }
    public SessionMask(UInt32 mask);
    public static SessionMask get_All();
    public ulong ToEventKeywords();
}
internal static class System.Diagnostics.Tracing.SimpleEventTypes`1 : object {
    private static TraceLoggingEventTypes instance;
    public static TraceLoggingEventTypes Instance { get; }
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
public static TraceLoggingEventTypes get_Instance();
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
private static TraceLoggingEventTypes InitInstance();
}
internal static class System.Diagnostics.Tracing.Statics : object {
    public static TraceLoggingDataType IntPtrType;
    public static TraceLoggingDataType UIntPtrType;
    public static TraceLoggingDataType HexIntPtrType;
    private static Statics();
    public static Byte[] MetadataForString(string name, int prefixSize, int suffixSize, int additionalSize);
    public static void EncodeTags(int tags, Int32& pos, Byte[] metadata);
    public static byte Combine(int settingValue, byte defaultValue);
    public static int Combine(int settingValue1, int settingValue2);
    public static void CheckName(string name);
    public static bool ShouldOverrideFieldName(string fieldName);
    public static TraceLoggingDataType MakeDataType(TraceLoggingDataType baseType, EventFieldFormat format);
    public static TraceLoggingDataType Format8(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format16(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format32(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType Format64(EventFieldFormat format, TraceLoggingDataType native);
    public static TraceLoggingDataType FormatScalar(EventFieldFormat format, TraceLoggingDataType nativeFormat);
    public static bool HasCustomAttribute(PropertyInfo propInfo, Type attributeType);
    public static AttributeType GetCustomAttribute(PropertyInfo propInfo);
    public static AttributeType GetCustomAttribute(Type type);
    public static Type FindEnumerableElementType(Type type);
    public static bool IsGenericMatch(Type type, object openType);
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
public static TraceLoggingTypeInfo CreateDefaultTypeInfo(Type dataType, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.StringTypeInfo : TraceLoggingTypeInfo {
    private static StringTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
}
internal class System.Diagnostics.Tracing.TimeSpanTypeInfo : TraceLoggingTypeInfo {
    private static TimeSpanTypeInfo s_instance;
    public static TraceLoggingTypeInfo Instance();
    public virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public virtual void WriteData(PropertyValue value);
}
internal static class System.Diagnostics.Tracing.TraceLoggingDataCollector : object {
    public static int BeginBufferedArray();
    public static void EndBufferedArray(int bookmark, int count);
    public static void AddScalar(PropertyValue value);
    public static void AddScalar(long value);
    public static void AddScalar(double value);
    public static void AddScalar(bool value);
    public static void AddNullTerminatedString(string value);
    public static void AddArray(PropertyValue value, int elementSize);
}
internal enum System.Diagnostics.Tracing.TraceLoggingDataType : Enum {
    public int value__;
    public static TraceLoggingDataType Nil;
    public static TraceLoggingDataType Utf16String;
    public static TraceLoggingDataType MbcsString;
    public static TraceLoggingDataType Int8;
    public static TraceLoggingDataType UInt8;
    public static TraceLoggingDataType Int16;
    public static TraceLoggingDataType UInt16;
    public static TraceLoggingDataType Int32;
    public static TraceLoggingDataType UInt32;
    public static TraceLoggingDataType Int64;
    public static TraceLoggingDataType UInt64;
    public static TraceLoggingDataType Float;
    public static TraceLoggingDataType Double;
    public static TraceLoggingDataType Boolean32;
    public static TraceLoggingDataType Binary;
    public static TraceLoggingDataType Guid;
    public static TraceLoggingDataType FileTime;
    public static TraceLoggingDataType SystemTime;
    public static TraceLoggingDataType HexInt32;
    public static TraceLoggingDataType HexInt64;
    public static TraceLoggingDataType CountedUtf16String;
    public static TraceLoggingDataType CountedMbcsString;
    public static TraceLoggingDataType Struct;
    public static TraceLoggingDataType Char16;
    public static TraceLoggingDataType Char8;
    public static TraceLoggingDataType Boolean8;
    public static TraceLoggingDataType HexInt8;
    public static TraceLoggingDataType HexInt16;
    public static TraceLoggingDataType Utf16Xml;
    public static TraceLoggingDataType MbcsXml;
    public static TraceLoggingDataType CountedUtf16Xml;
    public static TraceLoggingDataType CountedMbcsXml;
    public static TraceLoggingDataType Utf16Json;
    public static TraceLoggingDataType MbcsJson;
    public static TraceLoggingDataType CountedUtf16Json;
    public static TraceLoggingDataType CountedMbcsJson;
    public static TraceLoggingDataType HResult;
}
[DefaultMemberAttribute("Item")]
internal class System.Diagnostics.Tracing.TraceLoggingEventHandleTable : object {
    private IntPtr[] m_innerTable;
    internal IntPtr Item { get; }
    internal IntPtr get_Item(int eventID);
    internal void SetEventHandle(int eventID, IntPtr eventHandle);
}
internal class System.Diagnostics.Tracing.TraceLoggingEventTypes : object {
    internal TraceLoggingTypeInfo[] typeInfos;
    internal String[] paramNames;
    internal string name;
    internal EventTags tags;
    internal byte level;
    internal byte opcode;
    internal EventKeywords keywords;
    internal Byte[] typeMetadata;
    internal int scratchSize;
    internal int dataCount;
    internal int pinCount;
    private ConcurrentSet`2<KeyValuePair`2<string, EventTags>, NameInfo> nameInfos;
    internal string Name { get; }
    internal EventTags Tags { get; }
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
internal TraceLoggingEventTypes(string name, EventTags tags, Type[] types);
    internal TraceLoggingEventTypes(string name, EventTags tags, TraceLoggingTypeInfo[] typeInfos);
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
internal TraceLoggingEventTypes(string name, EventTags tags, ParameterInfo[] paramInfos);
    private TraceLoggingEventTypes(EventTags tags, string defaultName, TraceLoggingTypeInfo[] typeInfos);
    internal string get_Name();
    internal EventTags get_Tags();
    internal NameInfo GetNameInfo(string name, EventTags tags);
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
private static TraceLoggingTypeInfo[] MakeArray(ParameterInfo[] paramInfos);
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
private static TraceLoggingTypeInfo[] MakeArray(Type[] types);
    private static TraceLoggingTypeInfo[] MakeArray(TraceLoggingTypeInfo[] typeInfos);
    private static String[] MakeParamNameArray(ParameterInfo[] paramInfos);
}
internal class System.Diagnostics.Tracing.TraceLoggingMetadataCollector : object {
    private Impl impl;
    private FieldMetadata currentGroup;
    private int bufferedArrayFieldCount;
    [CompilerGeneratedAttribute]
private EventFieldTags <Tags>k__BackingField;
    internal EventFieldTags Tags { get; internal set; }
    internal int ScratchSize { get; }
    internal int DataCount { get; }
    internal int PinCount { get; }
    private bool BeginningBufferedArray { get; }
    private TraceLoggingMetadataCollector(TraceLoggingMetadataCollector other, FieldMetadata group);
    [CompilerGeneratedAttribute]
internal EventFieldTags get_Tags();
    [CompilerGeneratedAttribute]
internal void set_Tags(EventFieldTags value);
    internal int get_ScratchSize();
    internal int get_DataCount();
    internal int get_PinCount();
    private bool get_BeginningBufferedArray();
    public TraceLoggingMetadataCollector AddGroup(string name);
    public void AddScalar(string name, TraceLoggingDataType type);
    public void AddNullTerminatedString(string name, TraceLoggingDataType type);
    public void AddArray(string name, TraceLoggingDataType type);
    public void BeginBufferedArray();
    public void EndBufferedArray();
    internal Byte[] GetMetadata();
    private void AddField(FieldMetadata fieldMetadata);
}
internal abstract class System.Diagnostics.Tracing.TraceLoggingTypeInfo : object {
    private string name;
    private EventKeywords keywords;
    private EventLevel level;
    private EventOpcode opcode;
    private EventTags tags;
    private Type dataType;
    private Func`2<object, PropertyValue> propertyValueFactory;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, TraceLoggingTypeInfo> threadCache;
    public string Name { get; }
    public EventLevel Level { get; }
    public EventOpcode Opcode { get; }
    public EventKeywords Keywords { get; }
    public EventTags Tags { get; }
    internal Type DataType { get; }
    internal Func`2<object, PropertyValue> PropertyValueFactory { get; }
    internal TraceLoggingTypeInfo(Type dataType);
    internal TraceLoggingTypeInfo(Type dataType, string name, EventLevel level, EventOpcode opcode, EventKeywords keywords, EventTags tags);
    public string get_Name();
    public EventLevel get_Level();
    public EventOpcode get_Opcode();
    public EventKeywords get_Keywords();
    public EventTags get_Tags();
    internal Type get_DataType();
    internal Func`2<object, PropertyValue> get_PropertyValueFactory();
    public abstract virtual void WriteMetadata(TraceLoggingMetadataCollector collector, string name, EventFieldFormat format);
    public abstract virtual void WriteData(PropertyValue value);
    public virtual object GetData(object value);
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
public static TraceLoggingTypeInfo GetInstance(Type type, List`1<Type> recursionCheck);
}
internal class System.Diagnostics.Tracing.TypeAnalysis : object {
    internal PropertyAnalysis[] properties;
    internal string name;
    internal EventKeywords keywords;
    internal EventLevel level;
    internal EventOpcode opcode;
    internal EventTags tags;
    [RequiresUnreferencedCodeAttribute("EventSource WriteEvent will serialize the whole object graph. Trimmer will not safely handle this case because properties may be trimmed. This can be suppressed if the object is a primitive type")]
public TypeAnalysis(Type dataType, EventDataAttribute eventAttrib, List`1<Type> recursionCheck);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.UnreachableException : Exception {
    public UnreachableException(string message);
    public UnreachableException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DivideByZeroException : ArithmeticException {
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected DivideByZeroException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DllNotFoundException : TypeLoadException {
    public DllNotFoundException(string message);
    public DllNotFoundException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected DllNotFoundException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Double : ValueType {
    private double m_value;
    public static double MinValue;
    public static double MaxValue;
    public static double Epsilon;
    public static double NegativeInfinity;
    public static double PositiveInfinity;
    public static double NaN;
    public static double NegativeZero;
    public static double E;
    public static double Pi;
    public static double Tau;
    internal ushort BiasedExponent { get; }
    internal short Exponent { get; }
    internal ulong Significand { get; }
    internal ulong TrailingSignificand { get; }
    private static double System.Numerics.IAdditiveIdentity<System.Double,System.Double>.AdditiveIdentity { get; }
    private static double System.Numerics.IBinaryNumber<System.Double>.AllBitsSet { get; }
    private static double System.Numerics.IFloatingPointConstants<System.Double>.E { get; }
    private static double System.Numerics.IFloatingPointConstants<System.Double>.Pi { get; }
    private static double System.Numerics.IFloatingPointConstants<System.Double>.Tau { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.Epsilon { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.NaN { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeInfinity { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeZero { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.PositiveInfinity { get; }
    private static double System.Numerics.IMinMaxValue<System.Double>.MinValue { get; }
    private static double System.Numerics.IMinMaxValue<System.Double>.MaxValue { get; }
    private static double System.Numerics.IMultiplicativeIdentity<System.Double,System.Double>.MultiplicativeIdentity { get; }
    private static double System.Numerics.INumberBase<System.Double>.One { get; }
    private static int System.Numerics.INumberBase<System.Double>.Radix { get; }
    private static double System.Numerics.INumberBase<System.Double>.Zero { get; }
    private static double System.Numerics.ISignedNumber<System.Double>.NegativeOne { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.NumberBufferLength { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.ZeroBits { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.InfinityBits { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.NormalMantissaMask { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.DenormalMantissaMask { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MinBinaryExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MaxBinaryExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MinDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MaxDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.ExponentBias { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Double>.ExponentBits { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.OverflowDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.InfinityExponent { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Double>.NormalMantissaBits { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Double>.DenormalMantissaBits { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MinFastFloatDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MaxFastFloatDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MinExponentRoundToEven { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MaxExponentRoundToEven { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Double>.MaxExponentFastPath { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.MaxMantissaFastPath { get; }
    internal ushort get_BiasedExponent();
    internal short get_Exponent();
    internal ulong get_Significand();
    internal ulong get_TrailingSignificand();
    internal static ushort ExtractBiasedExponentFromBits(ulong bits);
    internal static ulong ExtractTrailingSignificandFromBits(ulong bits);
    [NonVersionableAttribute]
public static override bool IsFinite(double d);
    [NonVersionableAttribute]
public static override bool IsInfinity(double d);
    [NonVersionableAttribute]
public static override bool IsNaN(double d);
    [NonVersionableAttribute]
public static override bool IsNegative(double d);
    [NonVersionableAttribute]
public static override bool IsNegativeInfinity(double d);
    [NonVersionableAttribute]
public static override bool IsNormal(double d);
    [NonVersionableAttribute]
public static override bool IsPositiveInfinity(double d);
    [NonVersionableAttribute]
public static override bool IsSubnormal(double d);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(double value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public static override bool op_Equality(double left, double right);
    [NonVersionableAttribute]
public static override bool op_Inequality(double left, double right);
    [NonVersionableAttribute]
public static override bool op_LessThan(double left, double right);
    [NonVersionableAttribute]
public static override bool op_GreaterThan(double left, double right);
    [NonVersionableAttribute]
public static override bool op_LessThanOrEqual(double left, double right);
    [NonVersionableAttribute]
public static override bool op_GreaterThanOrEqual(double left, double right);
    public sealed virtual bool Equals(double obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static double Parse(string s);
    [NullableContextAttribute("1")]
public static double Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override double Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override double Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Double& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override double System.Numerics.IAdditionOperators<System.Double,System.Double,System.Double>.op_Addition(double left, double right);
    private static override double System.Numerics.IAdditiveIdentity<System.Double,System.Double>.get_AdditiveIdentity();
    private static override double System.Numerics.IBinaryNumber<System.Double>.get_AllBitsSet();
    public static override bool IsPow2(double value);
    [IntrinsicAttribute]
public static override double Log2(double value);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_BitwiseAnd(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_BitwiseOr(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_ExclusiveOr(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_OnesComplement(double value);
    private static override double System.Numerics.IDecrementOperators<System.Double>.op_Decrement(double value);
    private static override double System.Numerics.IDivisionOperators<System.Double,System.Double,System.Double>.op_Division(double left, double right);
    [IntrinsicAttribute]
public static override double Exp(double x);
    public static override double ExpM1(double x);
    public static override double Exp2(double x);
    public static override double Exp2M1(double x);
    public static override double Exp10(double x);
    public static override double Exp10M1(double x);
    [IntrinsicAttribute]
public static override double Ceiling(double x);
    [IntrinsicAttribute]
public static override double Floor(double x);
    [IntrinsicAttribute]
public static override double Round(double x);
    public static override double Round(double x, int digits);
    public static override double Round(double x, MidpointRounding mode);
    public static override double Round(double x, int digits, MidpointRounding mode);
    [IntrinsicAttribute]
public static override double Truncate(double x);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetSignificandByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetSignificandBitLength();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override double System.Numerics.IFloatingPointConstants<System.Double>.get_E();
    private static override double System.Numerics.IFloatingPointConstants<System.Double>.get_Pi();
    private static override double System.Numerics.IFloatingPointConstants<System.Double>.get_Tau();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_Epsilon();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_NaN();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_NegativeInfinity();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_NegativeZero();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_PositiveInfinity();
    [IntrinsicAttribute]
public static override double Atan2(double y, double x);
    public static override double Atan2Pi(double y, double x);
    public static override double BitDecrement(double x);
    public static override double BitIncrement(double x);
    [IntrinsicAttribute]
public static override double FusedMultiplyAdd(double left, double right, double addend);
    public static override double Ieee754Remainder(double left, double right);
    public static override int ILogB(double x);
    public static override double Lerp(double value1, double value2, double amount);
    public static override double ReciprocalEstimate(double x);
    public static override double ReciprocalSqrtEstimate(double x);
    public static override double ScaleB(double x, int n);
    [IntrinsicAttribute]
public static override double Acosh(double x);
    [IntrinsicAttribute]
public static override double Asinh(double x);
    [IntrinsicAttribute]
public static override double Atanh(double x);
    [IntrinsicAttribute]
public static override double Cosh(double x);
    [IntrinsicAttribute]
public static override double Sinh(double x);
    [IntrinsicAttribute]
public static override double Tanh(double x);
    private static override double System.Numerics.IIncrementOperators<System.Double>.op_Increment(double value);
    [IntrinsicAttribute]
public static override double Log(double x);
    public static override double Log(double x, double newBase);
    public static override double LogP1(double x);
    public static override double Log2P1(double x);
    [IntrinsicAttribute]
public static override double Log10(double x);
    public static override double Log10P1(double x);
    private static override double System.Numerics.IMinMaxValue<System.Double>.get_MinValue();
    private static override double System.Numerics.IMinMaxValue<System.Double>.get_MaxValue();
    private static override double System.Numerics.IModulusOperators<System.Double,System.Double,System.Double>.op_Modulus(double left, double right);
    private static override double System.Numerics.IMultiplicativeIdentity<System.Double,System.Double>.get_MultiplicativeIdentity();
    private static override double System.Numerics.IMultiplyOperators<System.Double,System.Double,System.Double>.op_Multiply(double left, double right);
    public static override double Clamp(double value, double min, double max);
    public static override double CopySign(double value, double sign);
    [IntrinsicAttribute]
public static override double Max(double x, double y);
    [IntrinsicAttribute]
public static override double MaxNumber(double x, double y);
    [IntrinsicAttribute]
public static override double Min(double x, double y);
    [IntrinsicAttribute]
public static override double MinNumber(double x, double y);
    public static override int Sign(double value);
    private static override double System.Numerics.INumberBase<System.Double>.get_One();
    private static override int System.Numerics.INumberBase<System.Double>.get_Radix();
    private static override double System.Numerics.INumberBase<System.Double>.get_Zero();
    [IntrinsicAttribute]
public static override double Abs(double value);
    [NullableContextAttribute("1")]
public static override double CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override double CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override double CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsCanonical(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsComplexNumber(double value);
    public static override bool IsEvenInteger(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsImaginaryNumber(double value);
    public static override bool IsInteger(double value);
    public static override bool IsOddInteger(double value);
    public static override bool IsPositive(double value);
    public static override bool IsRealNumber(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsZero(double value);
    [IntrinsicAttribute]
public static override double MaxMagnitude(double x, double y);
    [IntrinsicAttribute]
public static override double MaxMagnitudeNumber(double x, double y);
    [IntrinsicAttribute]
public static override double MinMagnitude(double x, double y);
    [IntrinsicAttribute]
public static override double MinMagnitudeNumber(double x, double y);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertFromChecked(TOther value, Double& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertFromSaturating(TOther value, Double& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertFromTruncating(TOther value, Double& result);
    private static bool TryConvertFrom(TOther value, Double& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertToChecked(double value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertToSaturating(double value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertToTruncating(double value, TOther& result);
    private static bool TryConvertTo(double value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Double& result);
    [IntrinsicAttribute]
public static override double Pow(double x, double y);
    [IntrinsicAttribute]
public static override double Cbrt(double x);
    public static override double Hypot(double x, double y);
    public static override double RootN(double x, int n);
    [IntrinsicAttribute]
public static override double Sqrt(double x);
    private static override double System.Numerics.ISignedNumber<System.Double>.get_NegativeOne();
    public static override double Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Double& result);
    private static override double System.Numerics.ISubtractionOperators<System.Double,System.Double,System.Double>.op_Subtraction(double left, double right);
    [IntrinsicAttribute]
public static override double Acos(double x);
    public static override double AcosPi(double x);
    [IntrinsicAttribute]
public static override double Asin(double x);
    public static override double AsinPi(double x);
    [IntrinsicAttribute]
public static override double Atan(double x);
    public static override double AtanPi(double x);
    [IntrinsicAttribute]
public static override double Cos(double x);
    public static override double CosPi(double x);
    public static override double DegreesToRadians(double degrees);
    public static override double RadiansToDegrees(double radians);
    [IntrinsicAttribute]
public static override double Sin(double x);
    public static override ValueTuple`2<double, double> SinCos(double x);
    public static override ValueTuple`2<double, double> SinCosPi(double x);
    public static override double SinPi(double x);
    [IntrinsicAttribute]
public static override double Tan(double x);
    public static override double TanPi(double x);
    private static override double System.Numerics.IUnaryNegationOperators<System.Double,System.Double>.op_UnaryNegation(double value);
    private static override double System.Numerics.IUnaryPlusOperators<System.Double,System.Double>.op_UnaryPlus(double value);
    public static override double Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Double& result);
    public static override double Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Double& result);
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_NumberBufferLength();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.get_ZeroBits();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.get_InfinityBits();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.get_NormalMantissaMask();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.get_DenormalMantissaMask();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MinBinaryExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MaxBinaryExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MinDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MaxDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_ExponentBias();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Double>.get_ExponentBits();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_OverflowDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_InfinityExponent();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Double>.get_NormalMantissaBits();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Double>.get_DenormalMantissaBits();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MinFastFloatDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MaxFastFloatDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MinExponentRoundToEven();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MaxExponentRoundToEven();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MaxExponentFastPath();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.get_MaxMantissaFastPath();
    private static override double System.IBinaryFloatParseAndFormatInfo<System.Double>.BitsToFloat(ulong bits);
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Double>.FloatToBits(double value);
    private static double CosForIntervalPiBy4(double x, double xTail);
    private static double SinForIntervalPiBy4(double x, double xTail);
    private static double TanForIntervalPiBy4(double x, double xTail, bool isReciprocal);
    [CompilerGeneratedAttribute]
internal static double <RootN>g__PositiveN|219_0(double x, int n);
    [CompilerGeneratedAttribute]
internal static double <RootN>g__NegativeN|219_1(double x, int n);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.DTSubString : ValueType {
    internal ReadOnlySpan`1<char> s;
    internal int index;
    internal int length;
    internal DTSubStringType type;
    internal int value;
    internal char Item { get; }
    internal char get_Item(int relativeIndex);
}
internal enum System.DTSubStringType : Enum {
    public int value__;
    public static DTSubStringType Unknown;
    public static DTSubStringType Invalid;
    public static DTSubStringType Number;
    public static DTSubStringType End;
    public static DTSubStringType Other;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.DuplicateWaitObjectException : ArgumentException {
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string parameterName, string message);
    public DuplicateWaitObjectException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
}
internal class System.Empty : object {
    public static Empty Value;
    private static Empty();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EntryPointNotFoundException : TypeLoadException {
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.Enum : ValueType {
    private static char EnumSeparatorChar;
    private static void GetEnumValuesAndNames(QCallTypeHandle enumType, UInt64[]& values, String[]& names);
    private static void InternalBoxEnum(QCallTypeHandle enumType, ObjectHandleOnStack res, long value);
    private static CorElementType InternalGetCorElementType(QCallTypeHandle enumType);
    private static void InternalGetUnderlyingType(QCallTypeHandle enumType, ObjectHandleOnStack res);
    private static object InternalBoxEnum(RuntimeType enumType, long value);
    private static CorElementType InternalGetCorElementType(RuntimeType rt);
    private CorElementType InternalGetCorElementType();
    internal static RuntimeType InternalGetUnderlyingType(RuntimeType enumType);
    private static EnumInfo`1<TStorage> GetEnumInfo(RuntimeType enumType, bool getNames);
    [NullableContextAttribute("0")]
public static string GetName(TEnum value);
    public static string GetName(Type enumType, object value);
    internal static string GetName(RuntimeType enumType, ulong uint64Value);
    private static string GetName(EnumInfo`1<TStorage> enumInfo, TStorage value);
    private static string GetNameInlined(EnumInfo`1<TStorage> enumInfo, TStorage value);
    public static String[] GetNames();
    public static String[] GetNames(Type enumType);
    internal static String[] GetNamesNoCopy(RuntimeType enumType);
    public static Type GetUnderlyingType(Type enumType);
    [NullableContextAttribute("0")]
public static TEnum[] GetValues();
    [RequiresDynamicCodeAttribute("It might not be possible to create an array of the enum type at runtime. Use the GetValues<TEnum> overload or the GetValuesAsUnderlyingType method instead.")]
public static Array GetValues(Type enumType);
    public static Array GetValuesAsUnderlyingType();
    public static Array GetValuesAsUnderlyingType(Type enumType);
    internal static Array GetValuesAsUnderlyingType(RuntimeType enumType);
    internal static Array GetValuesAsUnderlyingTypeNoCopy(RuntimeType enumType);
    [IntrinsicAttribute]
public bool HasFlag(Enum flag);
    [NullableContextAttribute("0")]
public static bool IsDefined(TEnum value);
    internal static bool IsDefinedPrimitive(RuntimeType enumType, TStorage value);
    public static bool IsDefined(Type enumType, object value);
    private static int FindDefinedIndex(TStorage[] values, TStorage value);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, ReadOnlySpan`1<char> value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    public static object Parse(Type enumType, ReadOnlySpan`1<char> value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value);
    [NullableContextAttribute("0")]
public static TEnum Parse(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum Parse(ReadOnlySpan`1<char> value, bool ignoreCase);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, Object& result);
    [NullableContextAttribute("0")]
public static bool TryParse(Type enumType, ReadOnlySpan`1<char> value, Object& result);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    [NullableContextAttribute("0")]
public static bool TryParse(Type enumType, ReadOnlySpan`1<char> value, bool ignoreCase, Object& result);
    private static bool TryParse(Type enumType, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, Object& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> value, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> value, bool ignoreCase, TEnum& result);
    private static bool TryParse(ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, TEnum& result);
    private static bool TryParseByValueOrName(RuntimeType enumType, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, TUnderlying& result);
    private static bool TryParseRareTypeByValueOrName(RuntimeType enumType, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, TUnderlying& result);
    private static bool TryParseByName(RuntimeType enumType, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, TStorage& result);
    internal static ulong ToUInt64(object value);
    internal object GetValue();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object target);
    public virtual string ToString();
    public string ToString(string format);
    [ObsoleteAttribute("The provider argument is not used. Use ToString() instead.")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("The provider argument is not used. Use ToString(String) instead.")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private static string ToString(RuntimeType enumType, Byte& rawData);
    private static string ToStringInlined(RuntimeType enumType, Byte& rawData);
    private static string ToString(RuntimeType enumType, char format, Byte& rawData);
    private static string ToStringInlined(RuntimeType enumType, char format, Byte& rawData);
    private static string FormatNumberAsHex(Byte& data);
    private static bool TryFormatNumberAsHex(Byte& data, Span`1<char> destination, Int32& charsWritten);
    public static string Format(Type enumType, object value, string format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static bool TryFormat(TEnum value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    internal static bool TryFormatUnconstrained(TEnum value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private static bool TryFormatPrimitiveDefault(RuntimeType enumType, TUnderlying value, Span`1<char> destination, Int32& charsWritten);
    private static bool TryFormatPrimitiveNonDefault(RuntimeType enumType, TUnderlying value, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private static string FormatFlagNames(EnumInfo`1<TStorage> enumInfo, TStorage resultValue);
    private static bool TryFormatFlagNames(EnumInfo`1<TStorage> enumInfo, TStorage resultValue, Span`1<char> destination, Int32& charsWritten, Boolean& isDestinationTooSmall);
    private static int GetMultipleEnumsFlagsFormatResultLength(int resultLength, int foundItemsCount);
    private static string GetSingleFlagsEnumNameForValue(TStorage resultValue, String[] names, TStorage[] values, Int32& index);
    private static bool TryFindFlagsNames(TStorage resultValue, String[] names, TStorage[] values, int index, Span`1<int> foundItems, Int32& resultLength, Int32& foundItemsCount);
    private static void WriteMultipleFoundFlagsNames(String[] names, ReadOnlySpan`1<int> foundItems, Span`1<char> destination);
    private static RuntimeType ValidateRuntimeType(Type enumType);
    [DoesNotReturnAttribute]
private static void ThrowInvalidRuntimeType(Type enumType);
    private static void ThrowInvalidEmptyParseArgument();
    private static FormatException CreateInvalidFormatSpecifierException();
    private static InvalidOperationException CreateUnknownEnumTypeException();
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public static object ToObject(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    public static object ToObject(Type enumType, short value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, byte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    public static object ToObject(Type enumType, long value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    internal static bool AreSequentialFromZero(TStorage[] values);
    internal static bool AreSorted(TStorage[] values);
    [ConditionalAttribute("DEBUG")]
private static void AssertValidGenerics();
    [CompilerGeneratedAttribute]
internal static bool <TryParse>g__TryParseRareTypes|42_0(RuntimeType rt, ReadOnlySpan`1<char> value, bool ignoreCase, bool throwOnFailure, Int64& result);
    [CompilerGeneratedAttribute]
internal static string <ToString>g__HandleRareTypes|56_0(RuntimeType enumType, Byte& rawData);
    [CompilerGeneratedAttribute]
internal static string <ToString>g__HandleRareTypes|57_0(RuntimeType enumType, char formatChar, Byte& rawData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Environment : object {
    [CompilerGeneratedAttribute]
private static int <ProcessorCount>k__BackingField;
    private static SByte modreq(System.Runtime.CompilerServices.IsVolatile) s_privilegedProcess;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_processId;
    private static String modreq(System.Runtime.CompilerServices.IsVolatile) s_processPath;
    private static OperatingSystem modreq(System.Runtime.CompilerServices.IsVolatile) s_osVersion;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_systemPageSize;
    private static Dictionary`2<SpecialFolder, string> s_specialFolders;
    private static Dictionary`2<string, string> s_environment;
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static int TickCount { get; }
    public static long TickCount64 { get; }
    public static int ProcessorCount { get; }
    internal static bool IsSingleProcessor { get; }
    public static bool IsPrivilegedProcess { get; }
    public static bool HasShutdownStarted { get; }
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int ProcessId { get; }
    [NullableAttribute("2")]
public static string ProcessPath { get; }
    public static bool Is64BitProcess { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static string NewLine { get; }
    public static OperatingSystem OSVersion { get; }
    public static Version Version { get; }
    public static string StackTrace { get; }
    public static int SystemPageSize { get; }
    public static bool UserInteractive { get; }
    private static string CurrentDirectoryCore { get; private set; }
    public static string SystemDirectory { get; }
    public static string UserDomainName { get; }
    public static string MachineName { get; }
    public static string UserName { get; }
    public static long WorkingSet { get; }
    private static Environment();
    public static int get_CurrentManagedThreadId();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    private static int GetProcessorCount();
    public static int get_TickCount();
    public static long get_TickCount64();
    [DoesNotReturnAttribute]
public static void Exit(int exitCode);
    public static String[] GetCommandLineArgs();
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void FailFast(string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void FailFast(string message, Exception exception);
    [DoesNotReturnAttribute]
internal static void FailFast(string message, Exception exception, string errorSource);
    [CompilerGeneratedAttribute]
public static int get_ProcessorCount();
    internal static bool get_IsSingleProcessor();
    public static bool get_IsPrivilegedProcess();
    public static bool get_HasShutdownStarted();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static string ExpandEnvironmentVariables(string name);
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static int get_ProcessId();
    [NullableContextAttribute("2")]
public static string get_ProcessPath();
    public static bool get_Is64BitProcess();
    public static bool get_Is64BitOperatingSystem();
    public static string get_NewLine();
    public static OperatingSystem get_OSVersion();
    public static Version get_Version();
    public static string get_StackTrace();
    public static int get_SystemPageSize();
    private static bool ValidateAndConvertRegistryTarget(EnvironmentVariableTarget target);
    private static void ValidateVariableAndValue(string variable, String& value);
    private static string GetFolderPathCore(SpecialFolder folder, SpecialFolderOption _);
    private static string GetSpecialFolder(SpecialFolder folder);
    private static string GetEnvironmentVariableFromRegistry(string variable, bool fromMachine);
    private static Hashtable GetEnvironmentVariablesFromRegistry(bool fromMachine);
    public static bool get_UserInteractive();
    private static string get_CurrentDirectoryCore();
    private static void set_CurrentDirectoryCore(string value);
    private static string ExpandEnvironmentVariablesCore(string name);
    public static string get_SystemDirectory();
    private static int GetSystemPageSize();
    public static string get_UserDomainName();
    private static int CheckedSysConf(SysConfName name);
    private static string GetEnvironmentVariableCore(string variable);
    internal static string GetEnvironmentVariableCore_NoArrayPool(string variable);
    private static void SetEnvironmentVariableCore(string variable, string value);
    public static IDictionary GetEnvironmentVariables();
    private static string TrimStringOnFirstZero(string value);
    private static void EnsureEnvironmentCached();
    private static Dictionary`2<string, string> GetSystemEnvironmentVariables();
    public static String[] GetLogicalDrives();
    public static string get_MachineName();
    public static string get_UserName();
    private static bool IsPrivilegedProcessCore();
    private static int GetProcessId();
    private static string GetProcessPath();
    public static long get_WorkingSet();
    private static OperatingSystem GetOSVersion();
    private static OperatingSystem GetOperatingSystem(string release);
    private static int FindAndParseNextNumber(string text, Int32& pos);
    [CompilerGeneratedAttribute]
internal static bool <GetSystemEnvironmentVariables>g__ParseEntry|94_0(IntPtr current, String& key, String& value);
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.EventArgs : object {
    [NullableAttribute("1")]
public static EventArgs Empty;
    private static EventArgs();
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Exception : object {
    private string _unused1;
    internal string _message;
    private IDictionary _data;
    private Exception _innerException;
    private string _helpURL;
    private object _traceIPs;
    private string _stackTraceString;
    private string _remoteStackTraceString;
    private int _unused4;
    private Object[] _dynamicMethods;
    private int _HResult;
    private string _source;
    private object _unused6;
    internal MonoStackFrame[] foreignExceptionsFrames;
    private IntPtr[] native_trace_ips;
    private int caught_in_unmanaged;
    private protected static string InnerExceptionPrefix;
    private bool HasBeenThrown { get; }
    public MethodBase TargetSite { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableAttribute("1")]
public IDictionary Data { get; }
    public Exception InnerException { get; }
    public string HelpLink { get; public set; }
    public string Source { get; public set; }
    public int HResult { get; public set; }
    public string StackTrace { get; }
    private string SerializationStackTraceString { get; }
    public Exception(string message);
    public Exception(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected Exception(SerializationInfo info, StreamingContext context);
    internal static UInt32 GetExceptionCount();
    private bool get_HasBeenThrown();
    [RequiresUnreferencedCodeAttribute("Metadata for the method might be incomplete or removed")]
public MethodBase get_TargetSite();
    internal DispatchState CaptureDispatchState();
    internal void RestoreDispatchState(DispatchState& state);
    private bool CanSetRemoteStackTrace();
    private static ListDictionaryInternal CreateDataContainer();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual IDictionary get_Data();
    private string GetClassName();
    [NullableContextAttribute("1")]
public virtual Exception GetBaseException();
    public Exception get_InnerException();
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
public virtual string get_Source();
    public virtual void set_Source(string value);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    public int get_HResult();
    public void set_HResult(int value);
    [NullableContextAttribute("1")]
public Type GetType();
    public virtual string get_StackTrace();
    private string GetStackTrace();
    [StackTraceHiddenAttribute]
internal void SetCurrentStackTrace();
    internal void SetRemoteStackTrace(string stackTrace);
    private string get_SerializationStackTraceString();
    [CompilerGeneratedAttribute]
internal static void <ToString>g__Write|48_0(string source, Span`1& dest);
}
internal enum System.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument obj;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument text;
    public static ExceptionArgument values;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument task;
    public static ExceptionArgument bytes;
    public static ExceptionArgument byteIndex;
    public static ExceptionArgument byteCount;
    public static ExceptionArgument ch;
    public static ExceptionArgument chars;
    public static ExceptionArgument charIndex;
    public static ExceptionArgument charCount;
    public static ExceptionArgument s;
    public static ExceptionArgument input;
    public static ExceptionArgument ownedMemory;
    public static ExceptionArgument list;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument exceptions;
    public static ExceptionArgument exception;
    public static ExceptionArgument pointer;
    public static ExceptionArgument start;
    public static ExceptionArgument format;
    public static ExceptionArgument formats;
    public static ExceptionArgument culture;
    public static ExceptionArgument comparer;
    public static ExceptionArgument comparable;
    public static ExceptionArgument source;
    public static ExceptionArgument length;
    public static ExceptionArgument comparisonType;
    public static ExceptionArgument manager;
    public static ExceptionArgument sourceBytesToCopy;
    public static ExceptionArgument callBack;
    public static ExceptionArgument creationOptions;
    public static ExceptionArgument function;
    public static ExceptionArgument scheduler;
    public static ExceptionArgument continuation;
    public static ExceptionArgument continuationAction;
    public static ExceptionArgument continuationFunction;
    public static ExceptionArgument tasks;
    public static ExceptionArgument asyncResult;
    public static ExceptionArgument beginMethod;
    public static ExceptionArgument endMethod;
    public static ExceptionArgument endFunction;
    public static ExceptionArgument cancellationToken;
    public static ExceptionArgument continuationOptions;
    public static ExceptionArgument delay;
    public static ExceptionArgument millisecondsDelay;
    public static ExceptionArgument millisecondsTimeout;
    public static ExceptionArgument stateMachine;
    public static ExceptionArgument timeout;
    public static ExceptionArgument type;
    public static ExceptionArgument sourceIndex;
    public static ExceptionArgument sourceArray;
    public static ExceptionArgument destinationIndex;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument pHandle;
    public static ExceptionArgument handle;
    public static ExceptionArgument other;
    public static ExceptionArgument newSize;
    public static ExceptionArgument lowerBounds;
    public static ExceptionArgument lengths;
    public static ExceptionArgument len;
    public static ExceptionArgument keys;
    public static ExceptionArgument indices;
    public static ExceptionArgument index1;
    public static ExceptionArgument index2;
    public static ExceptionArgument index3;
    public static ExceptionArgument length1;
    public static ExceptionArgument length2;
    public static ExceptionArgument length3;
    public static ExceptionArgument endIndex;
    public static ExceptionArgument elementType;
    public static ExceptionArgument arrayIndex;
    public static ExceptionArgument year;
    public static ExceptionArgument codePoint;
    public static ExceptionArgument str;
    public static ExceptionArgument options;
    public static ExceptionArgument prefix;
    public static ExceptionArgument suffix;
    public static ExceptionArgument buffer;
    public static ExceptionArgument buffers;
    public static ExceptionArgument offset;
    public static ExceptionArgument stream;
    public static ExceptionArgument anyOf;
    public static ExceptionArgument overlapped;
    public static ExceptionArgument minimumBytes;
}
internal enum System.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_IndexMustBeLessOrEqual;
    public static ExceptionResource ArgumentOutOfRange_IndexMustBeLess;
    public static ExceptionResource ArgumentOutOfRange_IndexCount;
    public static ExceptionResource ArgumentOutOfRange_IndexCountBuffer;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource ArgumentOutOfRange_Year;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_ByteArrayTooSmallForValue;
    public static ExceptionResource NotSupported_ReadOnlyCollection;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_GetCharCountOverflow;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_NotGreaterThanBufferLength;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource Argument_CannotExtractScalar;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource Serialization_MissingKeys;
    public static ExceptionResource Serialization_NullKey;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_NullArray;
    public static ExceptionResource TaskT_TransitionToFinal_AlreadyCompleted;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NullException;
    public static ExceptionResource TaskCompletionSourceT_TrySetException_NoExceptions;
    public static ExceptionResource NotSupported_StringComparison;
    public static ExceptionResource ConcurrentCollection_SyncRoot_NotSupported;
    public static ExceptionResource Task_MultiTaskContinuation_NullTask;
    public static ExceptionResource InvalidOperation_WrongAsyncResultOrEndCalledMultiple;
    public static ExceptionResource Task_MultiTaskContinuation_EmptyTaskList;
    public static ExceptionResource Task_Start_TaskCompleted;
    public static ExceptionResource Task_Start_Promise;
    public static ExceptionResource Task_Start_ContinuationTask;
    public static ExceptionResource Task_Start_AlreadyStarted;
    public static ExceptionResource Task_RunSynchronously_Continuation;
    public static ExceptionResource Task_RunSynchronously_Promise;
    public static ExceptionResource Task_RunSynchronously_TaskCompleted;
    public static ExceptionResource Task_RunSynchronously_AlreadyStarted;
    public static ExceptionResource AsyncMethodBuilder_InstanceNotInitialized;
    public static ExceptionResource Task_ContinueWith_ESandLR;
    public static ExceptionResource Task_ContinueWith_NotOnAnything;
    public static ExceptionResource Task_InvalidTimerTimeSpan;
    public static ExceptionResource Task_Delay_InvalidMillisecondsDelay;
    public static ExceptionResource Task_Dispose_NotCompleted;
    public static ExceptionResource Task_ThrowIfDisposed;
    public static ExceptionResource Task_WaitMulti_NullTask;
    public static ExceptionResource ArgumentException_OtherNotArrayOfCorrectLength;
    public static ExceptionResource ArgumentNull_Array;
    public static ExceptionResource ArgumentNull_SafeHandle;
    public static ExceptionResource ArgumentOutOfRange_EndIndexStartIndex;
    public static ExceptionResource ArgumentOutOfRange_Enum;
    public static ExceptionResource ArgumentOutOfRange_HugeArrayNotSupported;
    public static ExceptionResource Argument_AddingDuplicate;
    public static ExceptionResource Argument_InvalidArgumentForComparison;
    public static ExceptionResource Arg_LowerBoundsMustMatch;
    public static ExceptionResource Arg_MustBeType;
    public static ExceptionResource Arg_Need1DArray;
    public static ExceptionResource Arg_Need2DArray;
    public static ExceptionResource Arg_Need3DArray;
    public static ExceptionResource Arg_NeedAtLeast1Rank;
    public static ExceptionResource Arg_RankIndices;
    public static ExceptionResource Arg_RanksAndBounds;
    public static ExceptionResource InvalidOperation_IComparerFailed;
    public static ExceptionResource NotSupported_FixedSizeCollection;
    public static ExceptionResource Rank_MultiDimNotSupported;
    public static ExceptionResource Arg_TypeNotSupported;
    public static ExceptionResource Argument_SpansMustHaveSameLength;
    public static ExceptionResource Argument_InvalidFlag;
    public static ExceptionResource CancellationTokenSource_Disposed;
    public static ExceptionResource Argument_AlignmentMustBePow2;
    public static ExceptionResource InvalidOperation_SpanOverlappedOperation;
    public static ExceptionResource InvalidOperation_TimeProviderNullLocalTimeZone;
    public static ExceptionResource InvalidOperation_TimeProviderInvalidTimestampFrequency;
    public static ExceptionResource Format_UnexpectedClosingBrace;
    public static ExceptionResource Format_UnclosedFormatItem;
    public static ExceptionResource Format_ExpectedAsciiDigit;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ObsoleteAttribute("ExecutionEngineException previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
    private ExecutionEngineException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FieldAccessException : MemberAccessException {
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected FieldAccessException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.FormatException : SystemException {
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected FormatException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.FormattableString : object {
    [StringSyntaxAttribute("CompositeFormat")]
public string Format { get; }
    public int ArgumentCount { get; }
    public abstract virtual string get_Format();
    public abstract virtual Object[] GetArguments();
    public abstract virtual int get_ArgumentCount();
    [NullableContextAttribute("2")]
public abstract virtual object GetArgument(int index);
    public abstract virtual string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public static string Invariant(FormattableString formattable);
    public static string CurrentCulture(FormattableString formattable);
    public virtual string ToString();
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`10 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`10(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`11 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`11(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`12 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`12(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`13 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`13(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`14 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`14(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`15 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`15(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`16 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`16(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`17 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`17(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`6 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`6(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`7 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`7(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`8 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`8(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`9 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`9(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.GC : object {
    internal static object EPHEMERON_TOMBSTONE;
    public static int MaxGeneration { get; }
    private static GC();
    private static int GetCollectionCount(int generation);
    private static int GetMaxGeneration();
    private static void InternalCollect(int generation);
    private static void AddPressure(ulong bytesAllocated);
    private static void RemovePressure(ulong bytesRemoved);
    internal static void register_ephemeron_array(Ephemeron[] array);
    private static object get_ephemeron_tombstone();
    public static long GetAllocatedBytesForCurrentThread();
    public static long GetTotalAllocatedBytes(bool precise);
    public static void AddMemoryPressure(long bytesAllocated);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static int GetGeneration(object obj);
    public static void Collect(int generation);
    public static void Collect();
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    [NullableContextAttribute("2")]
public static void KeepAlive(object obj);
    public static int GetGeneration(WeakReference wo);
    public static int get_MaxGeneration();
    public static void WaitForPendingFinalizers();
    private static void _SuppressFinalize(object o);
    public static void SuppressFinalize(object obj);
    private static void _ReRegisterForFinalize(object o);
    public static void ReRegisterForFinalize(object obj);
    public static long GetTotalMemory(bool forceFullCollection);
    private static bool _RegisterForFullGCNotification(int maxGenerationPercentage, int largeObjectHeapPercentage);
    private static bool _CancelFullGCNotification();
    private static GCNotificationStatus _WaitForFullGCApproach(int millisecondsTimeout);
    private static GCNotificationStatus _WaitForFullGCComplete(int millisecondsTimeout);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void CancelFullGCNotification();
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    private static bool StartNoGCRegion(long totalSize, bool hasLohSize, long lohSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    public static void EndNoGCRegion();
    private static void _GetGCMemoryInfo(Int64& highMemoryLoadThresholdBytes, Int64& memoryLoadBytes, Int64& totalAvailableMemoryBytes, Int64& totalCommittedBytes, Int64& heapSizeBytes, Int64& fragmentedBytes);
    public static GCMemoryInfo GetGCMemoryInfo();
    public static GCMemoryInfo GetGCMemoryInfo(GCKind kind);
    private static Array AllocPinnedArray(Type t, int length);
    public static T[] AllocateUninitializedArray(int length, bool pinned);
    public static T[] AllocateArray(int length, bool pinned);
    internal static ulong GetGenerationSize(int generation);
    internal static int GetLastGCPercentTimeInGC();
    public static TimeSpan GetTotalPauseDuration();
    public static IReadOnlyDictionary`2<string, object> GetConfigurationVariables();
    public static void RefreshMemoryLimit();
    public static void RegisterNoGCRegionCallback(long totalSize, Action callback);
    public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout);
    public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout);
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
    public static GCCollectionMode Aggressive;
}
[IsReadOnlyAttribute]
public class System.GCGenerationInfo : ValueType {
    [CompilerGeneratedAttribute]
private long <SizeBeforeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FragmentationBeforeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SizeAfterBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FragmentationAfterBytes>k__BackingField;
    public long SizeBeforeBytes { get; }
    public long FragmentationBeforeBytes { get; }
    public long SizeAfterBytes { get; }
    public long FragmentationAfterBytes { get; }
    [CompilerGeneratedAttribute]
public long get_SizeBeforeBytes();
    [CompilerGeneratedAttribute]
public long get_FragmentationBeforeBytes();
    [CompilerGeneratedAttribute]
public long get_SizeAfterBytes();
    [CompilerGeneratedAttribute]
public long get_FragmentationAfterBytes();
}
public enum System.GCKind : Enum {
    public int value__;
    public static GCKind Any;
    public static GCKind Ephemeral;
    public static GCKind FullBlocking;
    public static GCKind Background;
}
[IsReadOnlyAttribute]
public class System.GCMemoryInfo : ValueType {
    private GCMemoryInfoData _data;
    public long HighMemoryLoadThresholdBytes { get; }
    public long MemoryLoadBytes { get; }
    public long TotalAvailableMemoryBytes { get; }
    public long HeapSizeBytes { get; }
    public long FragmentedBytes { get; }
    public long Index { get; }
    public int Generation { get; }
    public bool Compacted { get; }
    public bool Concurrent { get; }
    public long TotalCommittedBytes { get; }
    public long PromotedBytes { get; }
    public long PinnedObjectsCount { get; }
    public long FinalizationPendingCount { get; }
    public ReadOnlySpan`1<TimeSpan> PauseDurations { get; }
    public double PauseTimePercentage { get; }
    public ReadOnlySpan`1<GCGenerationInfo> GenerationInfo { get; }
    internal GCMemoryInfo(GCMemoryInfoData data);
    public long get_HighMemoryLoadThresholdBytes();
    public long get_MemoryLoadBytes();
    public long get_TotalAvailableMemoryBytes();
    public long get_HeapSizeBytes();
    public long get_FragmentedBytes();
    public long get_Index();
    public int get_Generation();
    public bool get_Compacted();
    public bool get_Concurrent();
    public long get_TotalCommittedBytes();
    public long get_PromotedBytes();
    public long get_PinnedObjectsCount();
    public long get_FinalizationPendingCount();
    public ReadOnlySpan`1<TimeSpan> get_PauseDurations();
    public double get_PauseTimePercentage();
    public ReadOnlySpan`1<GCGenerationInfo> get_GenerationInfo();
}
internal class System.GCMemoryInfoData : object {
    internal long _highMemoryLoadThresholdBytes;
    internal long _totalAvailableMemoryBytes;
    internal long _memoryLoadBytes;
    internal long _heapSizeBytes;
    internal long _fragmentedBytes;
    internal long _totalCommittedBytes;
    internal long _promotedBytes;
    internal long _pinnedObjectsCount;
    internal long _finalizationPendingCount;
    internal long _index;
    internal int _generation;
    internal int _pauseTimePercentage;
    internal byte _compacted;
    internal byte _concurrent;
    private GCGenerationInfo _generationInfo0;
    private GCGenerationInfo _generationInfo1;
    private GCGenerationInfo _generationInfo2;
    private GCGenerationInfo _generationInfo3;
    private GCGenerationInfo _generationInfo4;
    private TimeSpan _pauseDuration0;
    private TimeSpan _pauseDuration1;
    internal ReadOnlySpan`1<GCGenerationInfo> GenerationInfoAsSpan { get; }
    internal ReadOnlySpan`1<TimeSpan> PauseDurationsAsSpan { get; }
    internal ReadOnlySpan`1<GCGenerationInfo> get_GenerationInfoAsSpan();
    internal ReadOnlySpan`1<TimeSpan> get_PauseDurationsAsSpan();
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
internal class System.Gen2GcCallback : CriticalFinalizerObject {
    private Func`1<bool> _callback0;
    private Func`2<object, bool> _callback1;
    private GCHandle _weakTargetObj;
    private Gen2GcCallback(Func`1<bool> callback);
    private Gen2GcCallback(Func`2<object, bool> callback, object targetObj);
    public static void Register(Func`1<bool> callback);
    public static void Register(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
internal class System.GenericEmptyEnumerator`1 : GenericEmptyEnumeratorBase {
    public static GenericEmptyEnumerator`1<T> Instance;
    public T Current { get; }
    private static GenericEmptyEnumerator`1();
    public sealed virtual T get_Current();
}
internal abstract class System.GenericEmptyEnumeratorBase : object {
    public object Current { get; }
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Globalization.Calendar : object {
    private int _currentEraValue;
    private bool _isReadOnly;
    public static int CurrentEra;
    internal int _twoDigitYearMax;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public bool IsReadOnly { get; }
    internal int CurrentEraValue { get; }
    public Int32[] Eras { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public bool get_IsReadOnly();
    public virtual object Clone();
    public static Calendar ReadOnly(Calendar calendar);
    internal void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    internal virtual int get_CurrentEraValue();
    internal static void CheckAddResult(long ticks, DateTime minValue, DateTime maxValue);
    internal DateTime Add(DateTime time, double value, int scale);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public abstract virtual Int32[] get_Eras();
    public virtual int GetHour(DateTime time);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    internal int GetFirstDayWeekOfYear(DateTime time, int firstDayOfWeek);
    private int GetWeekOfYearFullDays(DateTime time, int firstDayOfWeek, int fullDays);
    private int GetWeekOfYearOfMinSupportedDateTime(int firstDayOfWeek, int minimumDaysInFirstWeek);
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidMonth(int year, int month, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
    internal static long TimeToTicks(int hour, int minute, int second, int millisecond);
    internal static int GetSystemTwoDigitYearSetting(CalendarId CalID, int defaultYearValue);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
internal class System.Globalization.CalendarData : object {
    internal string sNativeName;
    internal String[] saShortDates;
    internal String[] saYearMonths;
    internal String[] saLongDates;
    internal string sMonthDay;
    internal String[] saEraNames;
    internal String[] saAbbrevEraNames;
    internal String[] saAbbrevEnglishEraNames;
    internal String[] saDayNames;
    internal String[] saAbbrevDayNames;
    internal String[] saSuperShortDayNames;
    internal String[] saMonthNames;
    internal String[] saAbbrevMonthNames;
    internal String[] saMonthGenitiveNames;
    internal String[] saAbbrevMonthGenitiveNames;
    internal String[] saLeapYearMonthNames;
    internal int iTwoDigitYearMax;
    private int iCurrentEra;
    internal bool bUseUserOverrides;
    internal static CalendarData Invariant;
    internal CalendarData(string localeName, CalendarId calendarId, bool bUseUserOverrides);
    private static CalendarData();
    private static CalendarData CreateInvariant();
    private void InitializeEraNames(string localeName, CalendarId calendarId);
    private void InitializeAbbreviatedEraNames(string localeName, CalendarId calendarId);
    internal static int GetCalendarCurrentEra(Calendar calendar);
    private static string CalendarIdToCultureName(CalendarId calendarId);
    private bool IcuLoadCalendarDataFromSystem(string localeName, CalendarId calendarId);
    internal static int IcuGetCalendars(string localeName, CalendarId[] calendars);
    private static bool GetCalendarInfo(string localeName, CalendarId calendarId, CalendarDataType dataType, String& calendarString);
    private static bool EnumDatePatterns(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& datePatterns);
    private static void FixDefaultShortDatePattern(List`1<string> shortDatePatterns);
    private static string NormalizeDatePattern(string input);
    private static void NormalizeDayOfWeek(string input, ValueStringBuilder& destination, Int32& index);
    private static int CountOccurrences(string input, char value, Int32& index);
    private static bool EnumMonthNames(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& monthNames, String& leapHebrewMonthName);
    private static bool EnumEraNames(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& eraNames);
    internal static bool EnumCalendarInfo(string localeName, CalendarId calendarId, CalendarDataType dataType, String[]& calendarData);
    private static bool EnumCalendarInfo(string localeName, CalendarId calendarId, CalendarDataType dataType, IcuEnumCalendarsData& callbackContext);
    [UnmanagedCallersOnlyAttribute]
private static void EnumCalendarInfoCallback(Char* calendarStringPtr, IntPtr context);
    private bool LoadCalendarDataFromSystemCore(string localeName, CalendarId calendarId);
    internal static int GetCalendarsCore(string localeName, bool useUserOverride, CalendarId[] calendars);
    internal static int GetTwoDigitYearMax(CalendarId calendarId);
    [CompilerGeneratedAttribute]
private bool <InitializeEraNames>g__AreEraNamesEmpty|24_0();
}
internal enum System.Globalization.CalendarDataType : Enum {
    public int value__;
    public static CalendarDataType Uninitialized;
    public static CalendarDataType NativeName;
    public static CalendarDataType MonthDay;
    public static CalendarDataType ShortDates;
    public static CalendarDataType LongDates;
    public static CalendarDataType YearMonths;
    public static CalendarDataType DayNames;
    public static CalendarDataType AbbrevDayNames;
    public static CalendarDataType MonthNames;
    public static CalendarDataType AbbrevMonthNames;
    public static CalendarDataType SuperShortDayNames;
    public static CalendarDataType MonthGenitiveNames;
    public static CalendarDataType AbbrevMonthGenitiveNames;
    public static CalendarDataType EraNames;
    public static CalendarDataType AbbrevEraNames;
}
internal enum System.Globalization.CalendarId : Enum {
    public ushort value__;
    public static CalendarId UNINITIALIZED_VALUE;
    public static CalendarId GREGORIAN;
    public static CalendarId GREGORIAN_US;
    public static CalendarId JAPAN;
    public static CalendarId TAIWAN;
    public static CalendarId KOREA;
    public static CalendarId HIJRI;
    public static CalendarId THAI;
    public static CalendarId HEBREW;
    public static CalendarId GREGORIAN_ME_FRENCH;
    public static CalendarId GREGORIAN_ARABIC;
    public static CalendarId GREGORIAN_XLIT_ENGLISH;
    public static CalendarId GREGORIAN_XLIT_FRENCH;
    public static CalendarId JULIAN;
    public static CalendarId JAPANESELUNISOLAR;
    public static CalendarId CHINESELUNISOLAR;
    public static CalendarId SAKA;
    public static CalendarId LUNAR_ETO_CHN;
    public static CalendarId LUNAR_ETO_KOR;
    public static CalendarId LUNAR_ETO_ROKUYOU;
    public static CalendarId KOREANLUNISOLAR;
    public static CalendarId TAIWANLUNISOLAR;
    public static CalendarId PERSIAN;
    public static CalendarId UMALQURA;
    public static CalendarId LAST_CALENDAR;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
internal static class System.Globalization.CalendricalCalculationsHelper : object {
    private static long s_startOf1810;
    private static long s_startOf1900Century;
    private static EphemerisCorrectionAlgorithmMap[] s_ephemerisCorrectionTable;
    private static ReadOnlySpan`1<double> Coefficients1900to1987 { get; }
    private static ReadOnlySpan`1<double> Coefficients1800to1899 { get; }
    private static ReadOnlySpan`1<double> Coefficients1700to1799 { get; }
    private static ReadOnlySpan`1<double> Coefficients1620to1699 { get; }
    private static ReadOnlySpan`1<double> LambdaCoefficients { get; }
    private static ReadOnlySpan`1<double> AnomalyCoefficients { get; }
    private static ReadOnlySpan`1<double> EccentricityCoefficients { get; }
    private static ReadOnlySpan`1<double> CoefficientsA { get; }
    private static ReadOnlySpan`1<double> CoefficientsB { get; }
    private static ReadOnlySpan`1<double> Coefficients { get; }
    private static CalendricalCalculationsHelper();
    private static ReadOnlySpan`1<double> get_Coefficients1900to1987();
    private static ReadOnlySpan`1<double> get_Coefficients1800to1899();
    private static ReadOnlySpan`1<double> get_Coefficients1700to1799();
    private static ReadOnlySpan`1<double> get_Coefficients1620to1699();
    private static ReadOnlySpan`1<double> get_LambdaCoefficients();
    private static ReadOnlySpan`1<double> get_AnomalyCoefficients();
    private static ReadOnlySpan`1<double> get_EccentricityCoefficients();
    private static ReadOnlySpan`1<double> get_CoefficientsA();
    private static ReadOnlySpan`1<double> get_CoefficientsB();
    private static ReadOnlySpan`1<double> get_Coefficients();
    private static double RadiansFromDegrees(double degree);
    private static double SinOfDegree(double degree);
    private static double CosOfDegree(double degree);
    private static double TanOfDegree(double degree);
    private static double Obliquity(double julianCenturies);
    internal static long GetNumberOfDays(DateTime date);
    private static int GetGregorianYear(double numberOfDays);
    private static double Reminder(double divisor, double dividend);
    private static double NormalizeLongitude(double longitude);
    public static double AsDayFraction(double longitude);
    private static double PolynomialSum(ReadOnlySpan`1<double> coefficients, double indeterminate);
    private static double CenturiesFrom1900(int gregorianYear);
    private static double DefaultEphemerisCorrection(int gregorianYear);
    private static double EphemerisCorrection1988to2019(int gregorianYear);
    private static double EphemerisCorrection1900to1987(int gregorianYear);
    private static double EphemerisCorrection1800to1899(int gregorianYear);
    private static double EphemerisCorrection1700to1799(int gregorianYear);
    private static double EphemerisCorrection1620to1699(int gregorianYear);
    private static double EphemerisCorrection(double time);
    public static double JulianCenturies(double moment);
    private static double EquationOfTime(double time);
    private static double AsLocalTime(double apparentMidday, double longitude);
    public static double Midday(double date, double longitude);
    private static double InitLongitude(double longitude);
    public static double MiddayAtPersianObservationSite(double date);
    private static double PeriodicTerm(double julianCenturies, int x, double y, double z);
    private static double SumLongSequenceOfPeriodicTerms(double julianCenturies);
    private static double Aberration(double julianCenturies);
    private static double Nutation(double julianCenturies);
    public static double Compute(double time);
    public static double AsSeason(double longitude);
    private static double EstimatePrior(double longitude, double time);
    internal static long PersianNewYearOnOrBefore(long numberOfDays);
}
public static class System.Globalization.CharUnicodeInfo : object {
    private static ReadOnlySpan`1<byte> CategoryCasingLevel1Index { get; }
    private static ReadOnlySpan`1<byte> CategoryCasingLevel2Index { get; }
    private static ReadOnlySpan`1<byte> CategoryCasingLevel3Index { get; }
    private static ReadOnlySpan`1<byte> CategoriesValues { get; }
    private static ReadOnlySpan`1<byte> UppercaseValues { get; }
    private static ReadOnlySpan`1<byte> LowercaseValues { get; }
    private static ReadOnlySpan`1<byte> NumericGraphemeLevel1Index { get; }
    private static ReadOnlySpan`1<byte> NumericGraphemeLevel2Index { get; }
    private static ReadOnlySpan`1<byte> NumericGraphemeLevel3Index { get; }
    private static ReadOnlySpan`1<byte> DigitValues { get; }
    private static ReadOnlySpan`1<byte> NumericValues { get; }
    private static ReadOnlySpan`1<byte> GraphemeSegmentationValues { get; }
    internal static StrongBidiCategory GetBidiCategory(string s, int index);
    internal static StrongBidiCategory GetBidiCategory(StringBuilder s, int index);
    private static StrongBidiCategory GetBidiCategoryNoBoundsChecks(UInt32 codePoint);
    public static int GetDecimalDigitValue(char ch);
    [NullableContextAttribute("1")]
public static int GetDecimalDigitValue(string s, int index);
    private static int GetDecimalDigitValueInternalNoBoundsCheck(UInt32 codePoint);
    public static int GetDigitValue(char ch);
    [NullableContextAttribute("1")]
public static int GetDigitValue(string s, int index);
    private static int GetDigitValueInternalNoBoundsCheck(UInt32 codePoint);
    internal static GraphemeClusterBreakType GetGraphemeClusterBreakType(Rune rune);
    internal static bool GetIsWhiteSpace(char ch);
    public static double GetNumericValue(char ch);
    internal static double GetNumericValue(int codePoint);
    [NullableContextAttribute("1")]
public static double GetNumericValue(string s, int index);
    internal static double GetNumericValueInternal(string s, int index);
    private static double GetNumericValueNoBoundsCheck(UInt32 codePoint);
    internal static char ToUpper(char codePoint);
    internal static UInt32 ToUpper(UInt32 codePoint);
    internal static char ToLower(char codePoint);
    internal static UInt32 ToLower(UInt32 codePoint);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    [NullableContextAttribute("1")]
public static UnicodeCategory GetUnicodeCategory(string s, int index);
    internal static UnicodeCategory GetUnicodeCategoryInternal(string value, int index);
    internal static UnicodeCategory GetUnicodeCategoryInternal(string str, int index, Int32& charLength);
    private static UnicodeCategory GetUnicodeCategoryNoBoundsChecks(UInt32 codePoint);
    private static int GetCodePointFromString(string s, int index);
    private static UIntPtr GetCategoryCasingTableOffsetNoBoundsChecks(UInt32 codePoint);
    private static UIntPtr GetNumericGraphemeTableOffsetNoBoundsChecks(UInt32 codePoint);
    private static ReadOnlySpan`1<byte> get_CategoryCasingLevel1Index();
    private static ReadOnlySpan`1<byte> get_CategoryCasingLevel2Index();
    private static ReadOnlySpan`1<byte> get_CategoryCasingLevel3Index();
    private static ReadOnlySpan`1<byte> get_CategoriesValues();
    private static ReadOnlySpan`1<byte> get_UppercaseValues();
    private static ReadOnlySpan`1<byte> get_LowercaseValues();
    private static ReadOnlySpan`1<byte> get_NumericGraphemeLevel1Index();
    private static ReadOnlySpan`1<byte> get_NumericGraphemeLevel2Index();
    private static ReadOnlySpan`1<byte> get_NumericGraphemeLevel3Index();
    private static ReadOnlySpan`1<byte> get_DigitValues();
    private static ReadOnlySpan`1<byte> get_NumericValues();
    private static ReadOnlySpan`1<byte> get_GraphemeSegmentationValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId ID { get; }
    internal CalendarId BaseCalendarID { get; }
    public Int32[] Eras { get; }
    private static ChineseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_ID();
    internal virtual CalendarId get_BaseCalendarID();
    public virtual Int32[] get_Eras();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CompareInfo : object {
    internal static CompareInfo Invariant;
    [OptionalFieldAttribute]
private string m_name;
    private IntPtr _sortHandle;
    private string _sortName;
    [OptionalFieldAttribute]
private SortVersion m_SortVersion;
    private int culture;
    private static SearchValues`1<char> s_nonSpecialAsciiChars;
    private bool _isAsciiEqualityOrdinal;
    public string Name { get; }
    public SortVersion Version { get; }
    public int LCID { get; }
    [NullableAttribute("0")]
private static ReadOnlySpan`1<bool> HighCharTable { get; }
    internal CompareInfo(CultureInfo culture);
    private static CompareInfo();
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(string name);
    public static bool IsSortable(char ch);
    public static bool IsSortable(string text);
    [NullableContextAttribute("0")]
public static bool IsSortable(ReadOnlySpan`1<char> text);
    public static bool IsSortable(Rune value);
    [MemberNotNullAttribute("_sortName")]
private void InitSort(CultureInfo culture);
    [OnDeserializingAttribute]
private void OnDeserializing(StreamingContext ctx);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [OnDeserializedAttribute]
private void OnDeserialized(StreamingContext ctx);
    private void OnDeserialized();
    [OnSerializingAttribute]
private void OnSerializing(StreamingContext ctx);
    public string get_Name();
    [NullableContextAttribute("2")]
public int Compare(string string1, string string2);
    [NullableContextAttribute("2")]
public int Compare(string string1, string string2, CompareOptions options);
    internal int CompareOptionIgnoreCase(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, string string2, int offset2);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    [NullableContextAttribute("0")]
public int Compare(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    [StackTraceHiddenAttribute]
private static void CheckCompareOptionsForCompare(CompareOptions options);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
private static void ThrowCompareOptionsCheckFailed(CompareOptions options);
    private int CompareStringCore(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    public bool IsPrefix(string source, string prefix, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options, Int32& matchLength);
    private bool StartsWithCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options, Int32* matchLengthPtr);
    public bool IsPrefix(string source, string prefix);
    public bool IsSuffix(string source, string suffix, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options, Int32& matchLength);
    public bool IsSuffix(string source, string suffix);
    private bool EndsWithCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options, Int32* matchLengthPtr);
    public int IndexOf(string source, char value);
    public int IndexOf(string source, string value);
    public int IndexOf(string source, char value, CompareOptions options);
    public int IndexOf(string source, string value, CompareOptions options);
    public int IndexOf(string source, char value, int startIndex);
    public int IndexOf(string source, string value, int startIndex);
    public int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public int IndexOf(string source, char value, int startIndex, int count);
    public int IndexOf(string source, string value, int startIndex, int count);
    public int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    [NullableContextAttribute("0")]
public int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    [NullableContextAttribute("0")]
public int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options, Int32& matchLength);
    [NullableContextAttribute("0")]
public int IndexOf(ReadOnlySpan`1<char> source, Rune value, CompareOptions options);
    private int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, Int32* matchLengthPtr, CompareOptions options, bool fromBeginning);
    private int IndexOfCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr, bool fromBeginning);
    public int LastIndexOf(string source, char value);
    public int LastIndexOf(string source, string value);
    public int LastIndexOf(string source, char value, CompareOptions options);
    public int LastIndexOf(string source, string value, CompareOptions options);
    public int LastIndexOf(string source, char value, int startIndex);
    public int LastIndexOf(string source, string value, int startIndex);
    public int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public int LastIndexOf(string source, char value, int startIndex, int count);
    public int LastIndexOf(string source, string value, int startIndex, int count);
    public int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    [NullableContextAttribute("0")]
public int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    [NullableContextAttribute("0")]
public int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options, Int32& matchLength);
    [NullableContextAttribute("0")]
public int LastIndexOf(ReadOnlySpan`1<char> source, Rune value, CompareOptions options);
    public SortKey GetSortKey(string source, CompareOptions options);
    public SortKey GetSortKey(string source);
    private SortKey CreateSortKeyCore(string source, CompareOptions options);
    [NullableContextAttribute("0")]
public int GetSortKey(ReadOnlySpan`1<char> source, Span`1<byte> destination, CompareOptions options);
    private int GetSortKeyCore(ReadOnlySpan`1<char> source, Span`1<byte> destination, CompareOptions options);
    [NullableContextAttribute("0")]
public int GetSortKeyLength(ReadOnlySpan`1<char> source, CompareOptions options);
    private int GetSortKeyLengthCore(ReadOnlySpan`1<char> source, CompareOptions options);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public int GetHashCode(string source, CompareOptions options);
    [NullableContextAttribute("0")]
public int GetHashCode(ReadOnlySpan`1<char> source, CompareOptions options);
    private int GetHashCodeOfStringCore(ReadOnlySpan`1<char> source, CompareOptions options);
    public virtual string ToString();
    public SortVersion get_Version();
    public int get_LCID();
    private void IcuInitSortHandle(string interopCultureName);
    private bool GetIsAsciiEqualityOrdinal(string interopCultureName);
    private int IcuCompareString(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    private int IcuIndexOfCore(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr, bool fromBeginning);
    private int IndexOfOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr, bool fromBeginning);
    private int IndexOfOrdinalHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, CompareOptions options, Int32* matchLengthPtr, bool fromBeginning);
    private bool IcuStartsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options, Int32* matchLengthPtr);
    private bool StartsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options, Int32* matchLengthPtr);
    private bool StartsWithOrdinalHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options, Int32* matchLengthPtr);
    private bool IcuEndsWith(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options, Int32* matchLengthPtr);
    private bool EndsWithOrdinalIgnoreCaseHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options, Int32* matchLengthPtr);
    private bool EndsWithOrdinalHelper(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options, Int32* matchLengthPtr);
    private SortKey IcuCreateSortKey(string source, CompareOptions options);
    private int IcuGetSortKey(ReadOnlySpan`1<char> source, Span`1<byte> destination, CompareOptions options);
    private int IcuGetSortKeyLength(ReadOnlySpan`1<char> source, CompareOptions options);
    private static bool IcuIsSortable(ReadOnlySpan`1<char> text);
    private int IcuGetHashCodeOfString(ReadOnlySpan`1<char> source, CompareOptions options);
    private static bool CanUseAsciiOrdinalForOptions(CompareOptions options);
    private SortVersion IcuGetSortVersion();
    private static ReadOnlySpan`1<bool> get_HighCharTable();
    private SortKey InvariantCreateSortKey(string source, CompareOptions options);
    private static void InvariantCreateSortKeyOrdinal(ReadOnlySpan`1<char> source, Span`1<byte> sortKey);
    private static void InvariantCreateSortKeyOrdinalIgnoreCase(ReadOnlySpan`1<char> source, Span`1<byte> sortKey);
    private static int InvariantGetSortKey(ReadOnlySpan`1<char> source, Span`1<byte> destination, CompareOptions options);
    private static int InvariantGetSortKeyLength(ReadOnlySpan`1<char> source, CompareOptions options);
    internal bool IsPrefixUtf8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> prefix, CompareOptions options);
    private bool StartsWithCoreUtf8(ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> prefix, CompareOptions options);
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
internal class System.Globalization.CultureData : object {
    private string _sRealName;
    private string _sWindowsName;
    private string _sName;
    private string _sParent;
    private string _sEnglishDisplayName;
    private string _sNativeDisplayName;
    private string _sSpecificCulture;
    private string _sISO639Language;
    private string _sISO639Language2;
    private string _sEnglishLanguage;
    private string _sNativeLanguage;
    private string _sAbbrevLang;
    private string _sConsoleFallbackName;
    private int _iInputLanguageHandle;
    private string _sRegionName;
    private string _sLocalizedCountry;
    private string _sEnglishCountry;
    private string _sNativeCountry;
    private string _sISO3166CountryName;
    private string _sISO3166CountryName2;
    private int _iGeoId;
    private string _sPositiveSign;
    private string _sNegativeSign;
    private int _iDigits;
    private int _iNegativeNumber;
    private Int32[] _waGrouping;
    private string _sDecimalSeparator;
    private string _sThousandSeparator;
    private string _sNaN;
    private string _sPositiveInfinity;
    private string _sNegativeInfinity;
    private int _iNegativePercent;
    private int _iPositivePercent;
    private string _sPercent;
    private string _sPerMille;
    private string _sCurrency;
    private string _sIntlMonetarySymbol;
    private string _sEnglishCurrency;
    private string _sNativeCurrency;
    private int _iCurrencyDigits;
    private int _iCurrency;
    private int _iNegativeCurrency;
    private Int32[] _waMonetaryGrouping;
    private string _sMonetaryDecimal;
    private string _sMonetaryThousand;
    private int _iMeasure;
    private string _sListSeparator;
    private string _sAM1159;
    private string _sPM2359;
    private string _sTimeSeparator;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saLongTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saShortTimes;
    private String[] modreq(System.Runtime.CompilerServices.IsVolatile) _saDurationFormats;
    private int _iFirstDayOfWeek;
    private int _iFirstWeekOfYear;
    private CalendarId[] modreq(System.Runtime.CompilerServices.IsVolatile) _waCalendars;
    private CalendarData[] _calendars;
    private int _iReadingLayout;
    private int _iDefaultAnsiCodePage;
    private int _iDefaultOemCodePage;
    private int _iDefaultMacCodePage;
    private int _iDefaultEbcdicCodePage;
    private int _iLanguage;
    private bool _bUseOverrides;
    private bool _bUseOverridesUserSetting;
    private bool _bNeutral;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedRegions;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_regionNames;
    private static CultureData modreq(System.Runtime.CompilerServices.IsVolatile) s_Invariant;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCultures;
    private static object s_lock;
    private static Dictionary`2<string, string> RegionNames { get; }
    internal string InteropName { get; }
    internal static CultureData Invariant { get; }
    internal string CultureName { get; }
    internal bool UseUserOverride { get; }
    internal string Name { get; }
    internal string ParentName { get; }
    internal string DisplayName { get; }
    internal string EnglishName { get; }
    internal string NativeName { get; }
    internal string SpecificCultureName { get; }
    internal string TwoLetterISOLanguageName { get; }
    internal string ThreeLetterISOLanguageName { get; }
    internal string ThreeLetterWindowsLanguageName { get; }
    private string LocalizedLanguageName { get; }
    private string EnglishLanguageName { get; }
    private string NativeLanguageName { get; }
    internal string RegionName { get; }
    internal int GeoId { get; }
    internal string LocalizedCountryName { get; }
    internal string EnglishCountryName { get; }
    internal string NativeCountryName { get; }
    internal string TwoLetterISOCountryName { get; }
    internal string ThreeLetterISOCountryName { get; }
    internal int KeyboardLayoutId { get; }
    internal string SCONSOLEFALLBACKNAME { get; }
    internal Int32[] NumberGroupSizes { get; }
    private string NaNSymbol { get; }
    private string PositiveInfinitySymbol { get; }
    private string NegativeInfinitySymbol { get; }
    private int PercentNegativePattern { get; }
    private int PercentPositivePattern { get; }
    private string PercentSymbol { get; }
    private string PerMilleSymbol { get; }
    internal string CurrencySymbol { get; }
    internal string ISOCurrencySymbol { get; }
    internal string CurrencyEnglishName { get; }
    internal string CurrencyNativeName { get; }
    internal Int32[] CurrencyGroupSizes { get; }
    internal int MeasurementSystem { get; }
    internal string ListSeparator { get; }
    internal string AMDesignator { get; }
    internal string PMDesignator { get; }
    internal String[] LongTimes { get; }
    internal String[] ShortTimes { get; }
    internal int FirstDayOfWeek { get; }
    internal int CalendarWeekRule { get; }
    internal CalendarId[] CalendarIds { get; }
    internal bool IsRightToLeft { get; }
    private int ReadingLayout { get; }
    internal string TextInfoName { get; }
    internal string SortName { get; }
    internal bool IsSupplementalCustomCulture { get; }
    internal int ANSICodePage { get; }
    internal int OEMCodePage { get; }
    internal int MacCodePage { get; }
    internal int EBCDICCodePage { get; }
    internal int LCID { get; }
    internal bool IsNeutralCulture { get; }
    internal bool IsInvariantCulture { get; }
    internal bool IsReplacementCulture { get; }
    internal Calendar DefaultCalendar { get; }
    internal string TimeSeparator { get; }
    private static CultureData();
    private static Dictionary`2<string, string> get_RegionNames();
    internal string get_InteropName();
    internal static CultureData GetCultureDataForRegion(string cultureName, bool useUserOverride);
    internal static void ClearCachedData();
    internal static CultureInfo[] GetCultures(CultureTypes types);
    private static CultureData CreateCultureWithInvariantData();
    internal static CultureData get_Invariant();
    internal static CultureData GetCultureData(string cultureName, bool useUserOverride);
    private static string NormalizeCultureName(string name, Boolean& isNeutralName);
    private static CultureData CreateCultureData(string cultureName, bool useUserOverride);
    private bool InitCompatibilityCultureData();
    internal static CultureData GetCultureData(int culture, bool bUseUserOverride);
    internal string get_CultureName();
    internal bool get_UseUserOverride();
    internal string get_Name();
    internal string get_ParentName();
    internal string get_DisplayName();
    private string GetLanguageDisplayNameCore(string cultureName);
    internal string get_EnglishName();
    internal string get_NativeName();
    internal string get_SpecificCultureName();
    internal string get_TwoLetterISOLanguageName();
    internal string get_ThreeLetterISOLanguageName();
    internal string get_ThreeLetterWindowsLanguageName();
    private string get_LocalizedLanguageName();
    private string get_EnglishLanguageName();
    private string get_NativeLanguageName();
    internal string get_RegionName();
    internal int get_GeoId();
    internal string get_LocalizedCountryName();
    internal string get_EnglishCountryName();
    internal string get_NativeCountryName();
    internal string get_TwoLetterISOCountryName();
    internal string get_ThreeLetterISOCountryName();
    internal int get_KeyboardLayoutId();
    internal string get_SCONSOLEFALLBACKNAME();
    internal Int32[] get_NumberGroupSizes();
    private string get_NaNSymbol();
    private string get_PositiveInfinitySymbol();
    private string get_NegativeInfinitySymbol();
    private int get_PercentNegativePattern();
    private int get_PercentPositivePattern();
    private string get_PercentSymbol();
    private string get_PerMilleSymbol();
    internal string get_CurrencySymbol();
    internal string get_ISOCurrencySymbol();
    internal string get_CurrencyEnglishName();
    internal string get_CurrencyNativeName();
    internal Int32[] get_CurrencyGroupSizes();
    internal int get_MeasurementSystem();
    internal string get_ListSeparator();
    internal string get_AMDesignator();
    internal string get_PMDesignator();
    internal String[] get_LongTimes();
    internal String[] get_ShortTimes();
    private String[] DeriveShortTimesFromLong();
    private static string StripSecondsFromPattern(string time);
    private static int GetIndexOfNextTokenAfterSeconds(string time, int index, Boolean& containsSpace);
    internal int get_FirstDayOfWeek();
    internal int get_CalendarWeekRule();
    internal String[] ShortDates(CalendarId calendarId);
    internal String[] LongDates(CalendarId calendarId);
    internal String[] YearMonths(CalendarId calendarId);
    internal String[] DayNames(CalendarId calendarId);
    internal String[] AbbreviatedDayNames(CalendarId calendarId);
    internal String[] SuperShortDayNames(CalendarId calendarId);
    internal String[] MonthNames(CalendarId calendarId);
    internal String[] GenitiveMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedMonthNames(CalendarId calendarId);
    internal String[] AbbreviatedGenitiveMonthNames(CalendarId calendarId);
    internal String[] LeapYearMonthNames(CalendarId calendarId);
    internal string MonthDay(CalendarId calendarId);
    internal CalendarId[] get_CalendarIds();
    internal string CalendarName(CalendarId calendarId);
    internal CalendarData GetCalendar(CalendarId calendarId);
    internal bool get_IsRightToLeft();
    private int get_ReadingLayout();
    internal string get_TextInfoName();
    internal string get_SortName();
    internal bool get_IsSupplementalCustomCulture();
    internal int get_ANSICodePage();
    internal int get_OEMCodePage();
    internal int get_MacCodePage();
    internal int get_EBCDICCodePage();
    internal int get_LCID();
    internal bool get_IsNeutralCulture();
    internal bool get_IsInvariantCulture();
    internal bool get_IsReplacementCulture();
    internal Calendar get_DefaultCalendar();
    internal String[] EraNames(CalendarId calendarId);
    internal String[] AbbrevEraNames(CalendarId calendarId);
    internal String[] AbbreviatedEnglishEraNames(CalendarId calendarId);
    internal string get_TimeSeparator();
    internal string DateSeparator(CalendarId calendarId);
    private static string UnescapeNlsString(string str, int start, int end);
    private static string GetTimeSeparator(string format);
    private static string GetDateSeparator(string format);
    private static string GetSeparator(string format, string timeParts);
    private static int IndexOfTimePart(string format, int startIndex, string timeParts);
    internal static bool IsCustomCultureId(int cultureId);
    private String[] GetNativeDigits();
    internal void GetNFIValues(NumberFormatInfo nfi);
    internal static string AnsiToLower(string testString);
    private int GetLocaleInfoCore(LocaleNumberData type);
    private int GetLocaleInfoCoreUserOverride(LocaleNumberData type);
    private string GetLocaleInfoCoreUserOverride(LocaleStringData type);
    private string GetLocaleInfoCore(LocaleStringData type, string uiCultureName);
    private string GetLocaleInfoCore(string localeName, LocaleStringData type, string uiCultureName);
    private Int32[] GetLocaleInfoCoreUserOverride(LocaleGroupingData type);
    private static string NormalizeCultureName(string name, ReadOnlySpan`1<char> extension, Int32& collationStart);
    private bool InitIcuCultureDataCore();
    internal static bool GetLocaleName(string localeName, String& windowsName);
    internal static bool GetDefaultLocaleName(String& windowsName);
    private string IcuGetLocaleInfo(LocaleStringData type, string uiCultureName);
    private string IcuGetLocaleInfo(string localeName, LocaleStringData type, string uiCultureName);
    private int IcuGetLocaleInfo(LocaleNumberData type);
    private Int32[] IcuGetLocaleInfo(LocaleGroupingData type);
    private string IcuGetTimeFormatString();
    private string IcuGetTimeFormatString(bool shortFormat);
    private string IcuGetLanguageDisplayName(string cultureName);
    internal static bool IcuIsEnsurePredefinedLocaleName(string name);
    private static string ConvertIcuTimeFormatString(ReadOnlySpan`1<char> icuFormatString);
    private static int IcuLocaleNameToLCID(string cultureName);
    private static int IcuGetGeoId(string cultureName);
    private static int IcuGetDigitSubstitution(string cultureName);
    private static string IcuGetListSeparator(string cultureName);
    private static string IcuGetThreeLetterWindowsLanguageName(string cultureName);
    private static CultureInfo[] IcuEnumCultures(CultureTypes types);
    private static string IcuGetConsoleFallbackName(string cultureName);
    private static bool IsValidCultureName(string subject, Int32& indexOfUnderscore, Int32& indexOfExtensions);
    private bool InitCultureDataCore();
    private static string LCIDToLocaleName(int culture);
    private String[] GetTimeFormatsCore(bool shortFormat);
    private static int GetAnsiCodePage(string cultureName);
    private static int GetOemCodePage(string cultureName);
    private static int GetMacCodePage(string cultureName);
    private static int GetEbcdicCodePage(string cultureName);
    internal static CultureData GetCurrentRegionData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.CultureInfo : object {
    private bool _isReadOnly;
    private CompareInfo _compareInfo;
    private TextInfo _textInfo;
    internal NumberFormatInfo _numInfo;
    internal DateTimeFormatInfo _dateTimeInfo;
    private Calendar _calendar;
    internal CultureData _cultureData;
    internal bool _isInherited;
    private CultureInfo _consoleFallbackCulture;
    internal string _name;
    private string _nonSortName;
    private string _sortName;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultCulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_userDefaultUICulture;
    private static CultureInfo s_InvariantCultureInfo;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentUICulture;
    private static CultureInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_DefaultThreadCurrentCulture;
    [ThreadStaticAttribute]
private static CultureInfo s_currentThreadCulture;
    [ThreadStaticAttribute]
private static CultureInfo s_currentThreadUICulture;
    private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentCulture;
    private static AsyncLocal`1<CultureInfo> s_asyncLocalCurrentUICulture;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCulturesByName;
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_cachedCulturesByLcid;
    private CultureInfo _parent;
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    internal static CultureInfo UserDefaultUICulture { get; }
    public static CultureInfo InstalledUICulture { get; }
    [NullableAttribute("2")]
public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    [NullableAttribute("2")]
public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public static CultureInfo InvariantCulture { get; }
    public CultureInfo Parent { get; }
    public int LCID { get; }
    public int KeyboardLayoutId { get; }
    public string Name { get; }
    internal string SortName { get; }
    [NullableAttribute("2")]
internal string InteropName { get; }
    public string IetfLanguageTag { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string EnglishName { get; }
    public string TwoLetterISOLanguageName { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public CompareInfo CompareInfo { get; }
    public TextInfo TextInfo { get; }
    public bool IsNeutralCulture { get; }
    public CultureTypes CultureTypes { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    public Calendar Calendar { get; }
    public Calendar[] OptionalCalendars { get; }
    public bool UseUserOverride { get; }
    public bool IsReadOnly { get; }
    internal bool HasInvariantCultureName { get; }
    private static Dictionary`2<string, CultureInfo> CachedCulturesByName { get; }
    private static Dictionary`2<int, CultureInfo> CachedCulturesByLcid { get; }
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    private CultureInfo(CultureData cultureData, bool isReadOnly);
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    internal CultureInfo(string cultureName, string textAndCompareCultureName);
    private static CultureInfo();
    private static void AsyncLocalSetCurrentCulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static void AsyncLocalSetCurrentUICulture(AsyncLocalValueChangedArgs`1<CultureInfo> args);
    private static CultureInfo InitializeUserDefaultCulture();
    private static CultureInfo InitializeUserDefaultUICulture();
    private static string GetCultureNotSupportedExceptionMessage();
    private static CultureInfo CreateCultureInfoNoThrow(string name, bool useUserOverride);
    private static CultureInfo GetCultureByName(string name);
    public static CultureInfo CreateSpecificCulture(string name);
    internal static bool VerifyCultureName(string cultureName, bool throwException);
    internal static bool VerifyCultureName(CultureInfo culture, bool throwException);
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    internal static CultureInfo get_UserDefaultUICulture();
    public static CultureInfo get_InstalledUICulture();
    [NullableContextAttribute("2")]
public static CultureInfo get_DefaultThreadCurrentCulture();
    [NullableContextAttribute("2")]
public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    [NullableContextAttribute("2")]
public static CultureInfo get_DefaultThreadCurrentUICulture();
    [NullableContextAttribute("2")]
public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public static CultureInfo get_InvariantCulture();
    public virtual CultureInfo get_Parent();
    public virtual int get_LCID();
    public virtual int get_KeyboardLayoutId();
    public static CultureInfo[] GetCultures(CultureTypes types);
    public virtual string get_Name();
    internal string get_SortName();
    internal string get_InteropName();
    public string get_IetfLanguageTag();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_EnglishName();
    public virtual string get_TwoLetterISOLanguageName();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual CompareInfo get_CompareInfo();
    public virtual TextInfo get_TextInfo();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual object GetFormat(Type formatType);
    public virtual bool get_IsNeutralCulture();
    public CultureTypes get_CultureTypes();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    public void ClearCachedData();
    internal static Calendar GetCalendarInstance(CalendarId calType);
    internal static Calendar GetCalendarInstanceRare(CalendarId calType);
    public virtual Calendar get_Calendar();
    public virtual Calendar[] get_OptionalCalendars();
    public bool get_UseUserOverride();
    public CultureInfo GetConsoleFallbackUICulture();
    public virtual object Clone();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public bool get_IsReadOnly();
    private void VerifyWritable();
    internal bool get_HasInvariantCultureName();
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfo(string name, bool predefinedOnly);
    private static Dictionary`2<string, CultureInfo> get_CachedCulturesByName();
    private static Dictionary`2<int, CultureInfo> get_CachedCulturesByLcid();
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    internal static CultureInfo GetUserDefaultCulture();
    private static CultureInfo GetUserDefaultUICulture();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.CultureNotFoundException : ArgumentException {
    private string _invalidCultureName;
    private Nullable`1<int> _invalidCultureId;
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    [NullableAttribute("1")]
private static string DefaultMessage { get; }
    private string FormattedInvalidCultureId { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    private static string get_DefaultMessage();
    private string get_FormattedInvalidCultureId();
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("CultureTypes.WindowsOnlyCultures has been deprecated. Use other values in CultureTypes instead.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("CultureTypes.FrameworkCultures has been deprecated. Use other values in CultureTypes instead.")]
public static CultureTypes FrameworkCultures;
}
[FlagsAttribute]
internal enum System.Globalization.DateTimeFormatFlags : Enum {
    public int value__;
    public static DateTimeFormatFlags None;
    public static DateTimeFormatFlags UseGenitiveMonth;
    public static DateTimeFormatFlags UseLeapYearMonth;
    public static DateTimeFormatFlags UseSpacesInMonthNames;
    public static DateTimeFormatFlags UseHebrewRule;
    public static DateTimeFormatFlags UseSpacesInDayNames;
    public static DateTimeFormatFlags UseDigitPrefixInTokens;
    public static DateTimeFormatFlags NotInitialized;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.DateTimeFormatInfo : object {
    private CultureData _cultureData;
    private string _name;
    private string _langName;
    private CompareInfo _compareInfo;
    private CultureInfo _cultureInfo;
    private string amDesignator;
    private string pmDesignator;
    private string dateSeparator;
    private string generalShortTimePattern;
    private string generalLongTimePattern;
    private string timeSeparator;
    private string monthDayPattern;
    private string dateTimeOffsetPattern;
    private Byte[] amDesignatorUtf8;
    private Byte[] pmDesignatorUtf8;
    private Byte[] timeSeparatorUtf8;
    private Byte[] dateSeparatorUtf8;
    private Calendar calendar;
    private int firstDayOfWeek;
    private int calendarWeekRule;
    private string fullDateTimePattern;
    private String[] abbreviatedDayNames;
    private String[] m_superShortDayNames;
    private String[] dayNames;
    private String[] abbreviatedMonthNames;
    private String[] monthNames;
    private String[] genitiveMonthNames;
    private String[] m_genitiveAbbreviatedMonthNames;
    private String[] leapYearMonthNames;
    private string longDatePattern;
    private string shortDatePattern;
    private string yearMonthPattern;
    private string longTimePattern;
    private string shortTimePattern;
    private String[] allYearMonthPatterns;
    private String[] allShortDatePatterns;
    private String[] allLongDatePatterns;
    private String[] allShortTimePatterns;
    private String[] allLongTimePatterns;
    private String[] m_eraNames;
    private String[] m_abbrevEraNames;
    private String[] m_abbrevEnglishEraNames;
    private CalendarId[] optionalCalendars;
    internal bool _isReadOnly;
    private DateTimeFormatFlags formatFlags;
    private string _decimalSeparator;
    private Byte[] _decimalSeparatorUtf8;
    private string _fullTimeSpanPositivePattern;
    private string _fullTimeSpanNegativePattern;
    private TokenHashValue[] _dtfiTokenHash;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_jajpDTFI;
    private static DateTimeFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_zhtwDTFI;
    private string CultureName { get; }
    private CultureInfo Culture { get; }
    private string LanguageName { get; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    private CalendarId[] OptionalCalendars { get; }
    internal String[] EraNames { get; }
    internal String[] AbbreviatedEraNames { get; }
    internal String[] AbbreviatedEnglishEraNames { get; }
    public string DateSeparator { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    internal string GeneralShortTimePattern { get; }
    internal string GeneralLongTimePattern { get; }
    internal string DateTimeOffsetPattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public String[] DayNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public String[] MonthNames { get; public set; }
    internal bool HasSpacesInMonthNames { get; }
    internal bool HasSpacesInDayNames { get; }
    private String[] AllYearMonthPatterns { get; }
    private String[] AllShortDatePatterns { get; }
    private String[] AllShortTimePatterns { get; }
    private String[] AllLongDatePatterns { get; }
    private String[] AllLongTimePatterns { get; }
    private String[] UnclonedYearMonthPatterns { get; }
    private String[] UnclonedShortDatePatterns { get; }
    private String[] UnclonedLongDatePatterns { get; }
    private String[] UnclonedShortTimePatterns { get; }
    private String[] UnclonedLongTimePatterns { get; }
    public bool IsReadOnly { get; }
    public string NativeCalendarName { get; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    internal string DecimalSeparator { get; }
    internal string FullTimeSpanPositivePattern { get; }
    internal string FullTimeSpanNegativePattern { get; }
    internal CompareInfo CompareInfo { get; }
    internal DateTimeFormatFlags FormatFlags { get; }
    internal bool HasForceTwoDigitYears { get; }
    internal bool HasYearMonthAdjustment { get; }
    internal DateTimeFormatInfo(CultureData cultureData, Calendar cal);
    private string get_CultureName();
    private CultureInfo get_Culture();
    private string get_LanguageName();
    private String[] InternalGetAbbreviatedDayOfWeekNames();
    private String[] InternalGetAbbreviatedDayOfWeekNamesCore();
    private String[] InternalGetSuperShortDayNames();
    private String[] InternalGetSuperShortDayNamesCore();
    private String[] InternalGetDayOfWeekNames();
    private String[] InternalGetDayOfWeekNamesCore();
    private String[] InternalGetAbbreviatedMonthNames();
    private String[] InternalGetAbbreviatedMonthNamesCore();
    private String[] InternalGetMonthNames();
    private String[] internalGetMonthNamesCore();
    private void InitializeOverridableProperties(CultureData cultureData, CalendarId calendarId);
    public static DateTimeFormatInfo get_InvariantInfo();
    public static DateTimeFormatInfo get_CurrentInfo();
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public sealed virtual object Clone();
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    internal ReadOnlySpan`1<TChar> AMDesignatorTChar();
    public Calendar get_Calendar();
    [MemberNotNullAttribute("calendar")]
public void set_Calendar(Calendar value);
    private CalendarId[] get_OptionalCalendars();
    public int GetEra(string eraName);
    internal String[] get_EraNames();
    public string GetEraName(int era);
    internal String[] get_AbbreviatedEraNames();
    public string GetAbbreviatedEraName(int era);
    internal String[] get_AbbreviatedEnglishEraNames();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    internal ReadOnlySpan`1<TChar> DateSeparatorTChar();
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    private void OnLongDatePatternChanged();
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    private void OnLongTimePatternChanged();
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    internal ReadOnlySpan`1<TChar> PMDesignatorTChar();
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    private void OnShortDatePatternChanged();
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    private void OnShortTimePatternChanged();
    public string get_SortableDateTimePattern();
    internal string get_GeneralShortTimePattern();
    internal string get_GeneralLongTimePattern();
    internal string get_DateTimeOffsetPattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    internal ReadOnlySpan`1<TChar> TimeSeparatorTChar();
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    private void OnYearMonthPatternChanged();
    private static void CheckNullValue(String[] values, int length);
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    internal bool get_HasSpacesInMonthNames();
    internal bool get_HasSpacesInDayNames();
    internal string InternalGetMonthName(int month, MonthNameStyles style, bool abbreviated);
    internal String[] InternalGetGenitiveMonthNames(bool abbreviated);
    internal String[] InternalGetLeapYearMonthNames();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    private static String[] GetCombinedPatterns(String[] patterns1, String[] patterns2, string connectString);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedMonthName(int month);
    public string GetMonthName(int month);
    private static String[] GetMergedPatterns(String[] patterns, string defaultPattern);
    private String[] get_AllYearMonthPatterns();
    private String[] get_AllShortDatePatterns();
    private String[] get_AllShortTimePatterns();
    private String[] get_AllLongDatePatterns();
    private String[] get_AllLongTimePatterns();
    private String[] get_UnclonedYearMonthPatterns();
    private String[] get_UnclonedShortDatePatterns();
    private String[] get_UnclonedLongDatePatterns();
    private String[] get_UnclonedShortTimePatterns();
    private String[] get_UnclonedLongTimePatterns();
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public bool get_IsReadOnly();
    public string get_NativeCalendarName();
    public void SetAllDateTimePatterns(String[] patterns, char format);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    internal string get_DecimalSeparator();
    internal ReadOnlySpan`1<TChar> DecimalSeparatorTChar();
    internal string get_FullTimeSpanPositivePattern();
    internal string get_FullTimeSpanNegativePattern();
    internal CompareInfo get_CompareInfo();
    internal static void ValidateStyles(DateTimeStyles style, bool styles);
    internal DateTimeFormatFlags get_FormatFlags();
    private DateTimeFormatFlags InitializeFormatFlags();
    internal bool get_HasForceTwoDigitYears();
    internal bool get_HasYearMonthAdjustment();
    internal bool YearMonthAdjustment(Int32& year, Int32& month, bool parsedMonthName);
    internal static DateTimeFormatInfo GetJapaneseCalendarDTFI();
    internal static DateTimeFormatInfo GetTaiwanCalendarDTFI();
    private void ClearTokenHashTable();
    internal TokenHashValue[] CreateTokenHashTable();
    private void AddMonthNames(TokenHashValue[] temp, ReadOnlySpan`1<char> monthPostfix);
    private static bool TryParseHebrewNumber(__DTString& str, Boolean& badFormat, Int32& number);
    private static bool IsHebrewChar(char ch);
    private bool IsAllowedJapaneseTokenFollowedByNonSpaceLetter(string tokenString, char nextCh);
    internal bool Tokenize(TokenType TokenMask, TokenType& tokenType, Int32& tokenValue, __DTString& str);
    private void InsertAtCurrentHashNode(TokenHashValue[] hashTable, string str, char ch, TokenType tokenType, int tokenValue, int pos, int hashcode, int hashProbe);
    private void InsertHash(TokenHashValue[] hashTable, string str, TokenType tokenType, int tokenValue);
    private bool CompareStringIgnoreCaseOptimized(string string1, int offset1, int length1, string string2, int offset2, int length2);
    [CompilerGeneratedAttribute]
internal static void <ValidateStyles>g__ThrowInvalid|229_0(DateTimeStyles style, bool styles);
}
internal class System.Globalization.DateTimeFormatInfoScanner : object {
    internal List`1<string> m_dateWords;
    private FoundDatePattern _ymdFlags;
    internal static int SkipWhiteSpacesAndNonLetter(string pattern, int currentIndex);
    internal void AddDateWordOrPostfix(string formatPostfix, string str);
    internal int AddDateWords(string pattern, int index, string formatPostfix);
    internal static int ScanRepeatChar(string pattern, char ch, int index, Int32& count);
    internal void AddIgnorableSymbols(string text);
    internal void ScanDateWord(string pattern);
    internal String[] GetDateWordsOfDTFI(DateTimeFormatInfo dtfi);
    internal static FORMATFLAGS GetFormatFlagGenitiveMonth(String[] monthNames, String[] genitiveMonthNames, String[] abbrevMonthNames, String[] genitiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInMonthNames(String[] monthNames, String[] genitveMonthNames, String[] abbrevMonthNames, String[] genetiveAbbrevMonthNames);
    internal static FORMATFLAGS GetFormatFlagUseSpaceInDayNames(String[] dayNames, String[] abbrevDayNames);
    internal static FORMATFLAGS GetFormatFlagUseHebrewCalendar(int calID);
    private static bool ArrayElementsHaveSpace(String[] array);
    private static bool ArrayElementsBeginWithDigit(String[] array);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    private DateTime _start;
    private DateTime _end;
    private TimeSpan _delta;
    public DateTime Start { get; }
    public DateTime End { get; }
    public TimeSpan Delta { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public DateTime get_Start();
    public DateTime get_End();
    public TimeSpan get_Delta();
}
[IsReadOnlyAttribute]
internal class System.Globalization.DaylightTimeStruct : ValueType {
    public DateTime Start;
    public DateTime End;
    public TimeSpan Delta;
    public DaylightTimeStruct(DateTime start, DateTime end, TimeSpan delta);
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    private static ReadOnlySpan`1<int> DaysToMonth365 { get; }
    private static ReadOnlySpan`1<int> DaysToMonth366 { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ReadOnlySpan`1<int> get_DaysToMonth365();
    private static ReadOnlySpan`1<int> get_DaysToMonth366();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetCelestialStem(int sexagenaryYear);
    public int GetTerrestrialBranch(int sexagenaryYear);
    internal abstract virtual int GetYearInfo(int LunarYear, int Index);
    internal abstract virtual int GetYear(int year, DateTime time);
    internal abstract virtual int GetGregorianYear(int year, int era);
    internal abstract virtual int get_MinCalendarYear();
    internal abstract virtual int get_MaxCalendarYear();
    internal abstract virtual EraInfo[] get_CalEraInfo();
    internal abstract virtual DateTime get_MinDate();
    internal abstract virtual DateTime get_MaxDate();
    internal int MinEraCalendarYear(int era);
    internal int MaxEraCalendarYear(int era);
    internal void CheckTicksRange(long ticks);
    internal void CheckEraRange(int era);
    internal int CheckYearRange(int year, int era);
    internal int CheckYearMonthRange(int year, int month, int era);
    internal int InternalGetDaysInMonth(int year, int month);
    public virtual int GetDaysInMonth(int year, int month, int era);
    private static bool GregorianIsLeapYear(int y);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    private void GregorianToLunar(int solarYear, int solarMonth, int solarDate, Int32& lunarYear, Int32& lunarMonth, Int32& lunarDate);
    private bool LunarToGregorian(int lunarYear, int lunarMonth, int lunarDate, Int32& solarYear, Int32& solarMonth, Int32& solarDay);
    private DateTime LunarToTime(DateTime time, int year, int month, int day);
    private void TimeToLunar(DateTime time, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual int GetLeapMonth(int year, int era);
    internal bool InternalIsLeapYear(int year);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.EraInfo : object {
    internal int era;
    internal long ticks;
    internal int yearOffset;
    internal int minEraYear;
    internal int maxEraYear;
    internal string eraName;
    internal string abbrevEraName;
    internal string englishEraName;
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear);
    internal EraInfo(int era, int startYear, int startMonth, int startDay, int yearOffset, int minEraYear, int maxEraYear, string eraName, string abbrevEraName, string englishEraName);
}
internal enum System.Globalization.FORMATFLAGS : Enum {
    public int value__;
    public static FORMATFLAGS None;
    public static FORMATFLAGS UseGenitiveMonth;
    public static FORMATFLAGS UseLeapYearMonth;
    public static FORMATFLAGS UseSpacesInMonthNames;
    public static FORMATFLAGS UseHebrewParsing;
    public static FORMATFLAGS UseSpacesInDayNames;
    public static FORMATFLAGS UseDigitPrefixInTokens;
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
internal static class System.Globalization.GlobalizationMode : object {
    internal static bool Invariant { get; }
    internal static bool PredefinedCulturesOnly { get; }
    internal static bool get_Invariant();
    internal static bool get_PredefinedCulturesOnly();
    private static bool TryGetAppLocalIcuSwitchValue(String& value);
    private static bool TryGetStringValue(string switchName, string envVariable, String& value);
    private static void LoadAppLocalIcu(string icuSuffixAndVersion);
    private static string CreateLibraryName(ReadOnlySpan`1<char> baseName, ReadOnlySpan`1<char> suffix, ReadOnlySpan`1<char> extension, ReadOnlySpan`1<char> version, bool versionAtEnd);
    private static IntPtr LoadLibrary(string library, bool failOnLoadFailure);
    private static void LoadAppLocalIcuCore(ReadOnlySpan`1<char> version, ReadOnlySpan`1<char> suffix);
    private static int LoadICU();
}
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    private GregorianCalendarTypes _type;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal static ReadOnlySpan`1<int> DaysToMonth365 { get; }
    internal static ReadOnlySpan`1<int> DaysToMonth366 { get; }
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    internal CalendarId ID { get; }
    [NullableAttribute("1")]
public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    internal static ReadOnlySpan`1<int> get_DaysToMonth365();
    internal static ReadOnlySpan`1<int> get_DaysToMonth366();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static Calendar GetDefaultInstance();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    internal virtual CalendarId get_ID();
    internal static long GetAbsoluteDate(int year, int month, int day);
    private static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    [NullableContextAttribute("1")]
public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    internal virtual bool IsValidYear(int year, int era);
    internal virtual bool IsValidDay(int year, int month, int day, int era);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    internal virtual bool TryToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era, DateTime& result);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal class System.Globalization.GregorianCalendarHelper : object {
    private int m_maxYear;
    private int m_minYear;
    private Calendar m_Cal;
    private EraInfo[] m_EraInfo;
    internal int MaxYear { get; }
    public Int32[] Eras { get; }
    internal GregorianCalendarHelper(Calendar cal, EraInfo[] eraInfo);
    internal int get_MaxYear();
    private int GetYearOffset(int year, int era, bool throwOnError);
    internal int GetGregorianYear(int year, int era);
    internal bool IsValidYear(int year, int era);
    internal static long GetAbsoluteDate(int year, int month, int day);
    internal static long DateToTicks(int year, int month, int day);
    internal void CheckTicksRange(long ticks);
    public DateTime AddMonths(DateTime time, int months);
    public DateTime AddYears(DateTime time, int years);
    public int GetDayOfMonth(DateTime time);
    public DayOfWeek GetDayOfWeek(DateTime time);
    public int GetDayOfYear(DateTime time);
    public int GetDaysInMonth(int year, int month, int era);
    public int GetDaysInYear(int year, int era);
    public int GetEra(DateTime time);
    public Int32[] get_Eras();
    public int GetMonth(DateTime time);
    public int GetMonthsInYear(int year, int era);
    public int GetYear(DateTime time);
    public int GetYear(int year, DateTime time);
    public bool IsLeapDay(int year, int month, int day, int era);
    public void ValidateYearInEra(int year, int era);
    public int GetLeapMonth(int year, int era);
    public bool IsLeapMonth(int year, int month, int era);
    public bool IsLeapYear(int year, int era);
    public DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public int ToFourDigitYear(int year, int twoDigitYearMax);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    private static DateTime s_calendarMinValue;
    private static DateTime s_calendarMaxValue;
    private static ReadOnlySpan`1<byte> HebrewTable { get; }
    private static ReadOnlySpan`1<byte> LunarMonthLen { get; }
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    [NullableAttribute("1")]
public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HebrewCalendar();
    private static ReadOnlySpan`1<byte> get_HebrewTable();
    private static ReadOnlySpan`1<byte> get_LunarMonthLen();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    private static void CheckHebrewYearValue(int y, int era, string varName);
    private void CheckHebrewMonthValue(int year, int month, int era);
    private void CheckHebrewDayValue(int year, int month, int day, int era);
    private static void CheckEraRange(int era);
    private static void CheckTicksRange(long ticks);
    private static int GetResult(DateBuffer result, int part);
    internal static int GetLunarMonthDay(int gregorianYear, DateBuffer lunarDate);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    internal static int GetHebrewYearType(int year, int era);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    [NullableContextAttribute("1")]
public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    private static int GetDayDifference(int lunarYearType, int month1, int day1, int month2, int day2);
    private static DateTime HebrewToGregorian(int hebrewYear, int hebrewMonth, int hebrewDay, int hour, int minute, int second, int millisecond);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.HebrewNumber : object {
    private static HebrewValue[] s_hebrewValues;
    private static char s_maxHebrewNumberCh;
    private static HS[] s_numberPassingState;
    private static HebrewNumber();
    internal static void Append(ValueListBuilder`1& outputBuffer, int Number);
    internal static HebrewNumberParsingState ParseByChar(char ch, HebrewNumberParsingContext& context);
    internal static bool IsDigit(char ch);
}
internal class System.Globalization.HebrewNumberParsingContext : ValueType {
    internal HS state;
    internal int result;
    public HebrewNumberParsingContext(int result);
}
internal enum System.Globalization.HebrewNumberParsingState : Enum {
    public int value__;
    public static HebrewNumberParsingState InvalidHebrewNumber;
    public static HebrewNumberParsingState NotHebrewDigit;
    public static HebrewNumberParsingState FoundEndOfHebrewNumber;
    public static HebrewNumberParsingState ContinueParsing;
}
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    private int _hijriAdvance;
    private static DateTime s_calendarMinValue;
    private static DateTime s_calendarMaxValue;
    private static ReadOnlySpan`1<int> HijriMonthDays { get; }
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public int HijriAdjustment { get; public set; }
    [NullableAttribute("1")]
public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static HijriCalendar();
    private static ReadOnlySpan`1<int> get_HijriMonthDays();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private long GetAbsoluteDateHijri(int y, int m, int d);
    private long DaysUpToHijriYear(int HijriYear);
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    internal virtual int GetDatePart(long ticks, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    [NullableContextAttribute("1")]
public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.IcuLocaleData : object {
    private static ReadOnlySpan`1<byte> CultureNames { get; }
    private static ReadOnlySpan`1<byte> LocalesNamesIndexes { get; }
    private static ReadOnlySpan`1<byte> LcidToCultureNameIndices { get; }
    private static ReadOnlySpan`1<byte> ThreeLetterWindowsLanguageName { get; }
    private static ReadOnlySpan`1<byte> NameIndexToNumericData { get; }
    private static ReadOnlySpan`1<byte> get_CultureNames();
    private static ReadOnlySpan`1<byte> get_LocalesNamesIndexes();
    private static ReadOnlySpan`1<byte> get_LcidToCultureNameIndices();
    private static ReadOnlySpan`1<byte> get_ThreeLetterWindowsLanguageName();
    private static ReadOnlySpan`1<byte> get_NameIndexToNumericData();
    internal static string LCIDToLocaleName(int culture);
    internal static int GetLocaleDataNumericPart(string cultureName, IcuLocaleDataParts part);
    internal static string GetThreeLetterWindowsLanguageName(string cultureName);
    private static string GetLocaleDataMappedCulture(string cultureName, IcuLocaleDataParts part);
    internal static string GetSpecificCultureName(string cultureName);
    internal static string GetConsoleUICulture(string cultureName);
    private static int SearchCultureName(string name);
    private static ReadOnlySpan`1<byte> GetCultureName(int localeNameIndice);
    private static string GetString(ReadOnlySpan`1<byte> buffer);
    [CompilerGeneratedAttribute]
internal static int <GetLocaleDataNumericPart>g__ResolveIndex|25_0(int value);
    [CompilerGeneratedAttribute]
internal static int <GetLocaleDataNumericPart>g__ResolveDigitListSeparator|25_1(int value);
}
internal enum System.Globalization.IcuLocaleDataParts : Enum {
    public int value__;
    public static IcuLocaleDataParts Lcid;
    public static IcuLocaleDataParts AnsiCodePage;
    public static IcuLocaleDataParts OemCodePage;
    public static IcuLocaleDataParts MacCodePage;
    public static IcuLocaleDataParts EbcdicCodePage;
    public static IcuLocaleDataParts GeoId;
    public static IcuLocaleDataParts DigitSubstitutionOrListSeparator;
    public static IcuLocaleDataParts SpecificLocaleIndex;
    public static IcuLocaleDataParts ConsoleLocaleIndex;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.IdnMapping : object {
    private bool _allowUnassigned;
    private bool _useStd3AsciiRules;
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    private UInt32 IcuFlags { get; }
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static string GetStringForOutput(string originalString, Char* input, int inputLength, Char* output, int outputLength);
    private string GetAsciiInvariant(string unicode, int index, int count);
    private static bool ValidateStd3AndAscii(string unicode, bool bUseStd3, bool bCheckAscii);
    private static string PunycodeEncode(string unicode);
    private static bool IsDot(char c);
    private static bool IsSupplementary(int cTest);
    private static bool Basic(UInt32 cp);
    private static void ValidateStd3(char c, bool bNextToDot);
    private string GetUnicodeInvariant(string ascii, int index, int count);
    private static string PunycodeDecode(string ascii);
    private static int DecodeDigit(char cp);
    private static int Adapt(int delta, int numpoints, bool firsttime);
    private static char EncodeBasic(char bcp);
    private static char EncodeDigit(int d);
    private string IcuGetAsciiCore(string unicodeString, Char* unicode, int count);
    private string IcuGetUnicodeCore(string asciiString, Char* ascii, int count);
    private string IcuGetUnicodeCore(string asciiString, Char* ascii, int count, UInt32 flags, Char* output, int outputLength, bool reattempt);
    private UInt32 get_IcuFlags();
    private static void CheckInvalidIdnCharacters(Char* s, int count, UInt32 flags, string paramName);
}
internal static class System.Globalization.InvariantModeCasing : object {
    internal static char ToLower(char c);
    internal static char ToUpper(char c);
    internal static string ToLower(string s);
    internal static string ToUpper(string s);
    internal static void ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal static void ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private static ValueTuple`2<UInt32, int> GetScalar(Char& source, int index, int length);
    internal static int CompareStringIgnoreCase(Char& strA, int lengthA, Char& strB, int lengthB);
    internal static int IndexOfIgnoreCase(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
    internal static int LastIndexOfIgnoreCase(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
}
public static class System.Globalization.ISOWeek : object {
    public static int GetWeekOfYear(DateTime date);
    public static int GetYear(DateTime date);
    public static DateTime GetYearStart(int year);
    public static DateTime GetYearEnd(int year);
    public static int GetWeeksInYear(int year);
    public static DateTime ToDateTime(int year, int week, DayOfWeek dayOfWeek);
    private static int GetWeekNumber(DateTime date);
    private static int GetWeekday(DayOfWeek dayOfWeek);
    [CompilerGeneratedAttribute]
internal static int <GetWeeksInYear>g__P|8_0(int y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.JapaneseCalendar : Calendar {
    private static DateTime s_calendarMinValue;
    private static EraInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) s_japaneseEraInfo;
    internal static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    internal GregorianCalendarHelper _helper;
    private static String[] s_abbreviatedEnglishEraNames;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JapaneseCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal static EraInfo[] GetEraInfo();
    internal static Calendar GetDefaultInstance();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
    public virtual Int32[] get_Eras();
    internal static String[] EraNames();
    internal static String[] AbbrevEraNames();
    internal static String[] EnglishEraNames();
    internal virtual bool IsValidYear(int year, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    private static EraInfo[] IcuGetJapaneseEras();
    private static string GetAbbreviatedEraName(String[] eraNames, int eraIndex);
    private static bool GetJapaneseEraStartDate(int era, DateTime& dateTime);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    private GregorianCalendarHelper _helper;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static JapaneseLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    private static EraInfo[] TrimEras(EraInfo[] baseEras);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    internal int MaxYear;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static JulianCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    internal static void CheckEraRange(int era);
    internal void CheckYearEraRange(int year, int era);
    internal static void CheckMonthRange(int month);
    internal static void CheckDayRange(int year, int month, int day);
    internal static int GetDatePart(long ticks, int part);
    internal static long DateToTicks(int year, int month, int day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    private static EraInfo[] s_koreanEraInfo;
    private GregorianCalendarHelper _helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static KoreanCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static KoreanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[FlagsAttribute]
internal enum System.Globalization.MonthNameStyles : Enum {
    public int value__;
    public static MonthNameStyles Regular;
    public static MonthNameStyles Genitive;
    public static MonthNameStyles LeapYear;
}
internal static class System.Globalization.Normalization : object {
    internal static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    internal static string Normalize(string strInput, NormalizationForm normalizationForm);
    private static bool IcuIsNormalized(string strInput, NormalizationForm normalizationForm);
    private static string IcuNormalize(string strInput, NormalizationForm normalizationForm);
    private static void ValidateArguments(string strInput, NormalizationForm normalizationForm);
    private static bool HasInvalidUnicodeSequence(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.NumberFormatInfo : object {
    private static NumberFormatInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_invariantInfo;
    internal static String[] s_asciiDigits;
    internal Int32[] _numberGroupSizes;
    internal Int32[] _currencyGroupSizes;
    internal Int32[] _percentGroupSizes;
    internal string _positiveSign;
    internal string _negativeSign;
    internal string _numberDecimalSeparator;
    internal string _numberGroupSeparator;
    internal string _currencyGroupSeparator;
    internal string _currencyDecimalSeparator;
    internal string _currencySymbol;
    internal string _nanSymbol;
    internal string _positiveInfinitySymbol;
    internal string _negativeInfinitySymbol;
    internal string _percentDecimalSeparator;
    internal string _percentGroupSeparator;
    internal string _percentSymbol;
    internal string _perMilleSymbol;
    internal Byte[] _positiveSignUtf8;
    internal Byte[] _negativeSignUtf8;
    internal Byte[] _currencySymbolUtf8;
    internal Byte[] _numberDecimalSeparatorUtf8;
    internal Byte[] _currencyDecimalSeparatorUtf8;
    internal Byte[] _currencyGroupSeparatorUtf8;
    internal Byte[] _numberGroupSeparatorUtf8;
    internal Byte[] _percentSymbolUtf8;
    internal Byte[] _percentDecimalSeparatorUtf8;
    internal Byte[] _percentGroupSeparatorUtf8;
    internal Byte[] _perMilleSymbolUtf8;
    internal Byte[] _nanSymbolUtf8;
    internal Byte[] _positiveInfinitySymbolUtf8;
    internal Byte[] _negativeInfinitySymbolUtf8;
    internal String[] _nativeDigits;
    internal int _numberDecimalDigits;
    internal int _currencyDecimalDigits;
    internal int _currencyPositivePattern;
    internal int _currencyNegativePattern;
    internal int _numberNegativePattern;
    internal int _percentPositivePattern;
    internal int _percentNegativePattern;
    internal int _percentDecimalDigits;
    internal int _digitSubstitution;
    internal bool _isReadOnly;
    private bool _hasInvariantNumberSigns;
    private bool _allowHyphenDuringParsing;
    internal bool HasInvariantNumberSigns { get; }
    internal bool AllowHyphenDuringParsing { get; }
    public static NumberFormatInfo InvariantInfo { get; }
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public bool IsReadOnly { get; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public string NaNSymbol { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public DigitShapes DigitSubstitution { get; public set; }
    internal NumberFormatInfo(CultureData cultureData);
    private static NumberFormatInfo();
    private static void VerifyNativeDigits(String[] nativeDig, string propertyName);
    private static void VerifyDigitSubstitution(DigitShapes digitSub, string propertyName);
    internal bool get_HasInvariantNumberSigns();
    internal bool get_AllowHyphenDuringParsing();
    private void InitializeInvariantAndNegativeSignFlags();
    private void VerifyWritable();
    public static NumberFormatInfo get_InvariantInfo();
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public sealed virtual object Clone();
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    internal ReadOnlySpan`1<TChar> CurrencyDecimalSeparatorTChar();
    public bool get_IsReadOnly();
    internal static void CheckGroupSize(string propName, Int32[] groupSize);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    internal ReadOnlySpan`1<TChar> CurrencyGroupSeparatorTChar();
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    internal ReadOnlySpan`1<TChar> CurrencySymbolTChar();
    public static NumberFormatInfo get_CurrentInfo();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    internal ReadOnlySpan`1<TChar> NaNSymbolTChar();
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    internal ReadOnlySpan`1<TChar> NegativeInfinitySymbolTChar();
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    internal ReadOnlySpan`1<TChar> NegativeSignTChar();
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    internal ReadOnlySpan`1<TChar> NumberDecimalSeparatorTChar();
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    internal ReadOnlySpan`1<TChar> NumberGroupSeparatorTChar();
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    internal ReadOnlySpan`1<TChar> PositiveInfinitySymbolTChar();
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    internal ReadOnlySpan`1<TChar> PositiveSignTChar();
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    internal ReadOnlySpan`1<TChar> PercentDecimalSeparatorTChar();
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    internal ReadOnlySpan`1<TChar> PercentGroupSeparatorTChar();
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    internal ReadOnlySpan`1<TChar> PercentSymbolTChar();
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    internal ReadOnlySpan`1<TChar> PerMilleSymbolTChar();
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
    internal static void ValidateParseStyleInteger(NumberStyles style);
    internal static void ValidateParseStyleFloatingPoint(NumberStyles style);
    [CompilerGeneratedAttribute]
internal static NumberFormatInfo <GetInstance>g__GetProviderNonNull|58_0(IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static void <ValidateParseStyleInteger>g__ThrowInvalid|165_0(NumberStyles value);
    [CompilerGeneratedAttribute]
internal static void <ValidateParseStyleFloatingPoint>g__ThrowInvalid|166_0(NumberStyles value);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles AllowExponent;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles AllowBinarySpecifier;
    public static NumberStyles Integer;
    public static NumberStyles HexNumber;
    public static NumberStyles BinaryNumber;
    public static NumberStyles Number;
    public static NumberStyles Float;
    public static NumberStyles Currency;
    public static NumberStyles Any;
}
internal static class System.Globalization.Ordinal : object {
    internal static int CompareStringIgnoreCase(Char& strA, int lengthA, Char& strB, int lengthB);
    internal static int CompareStringIgnoreCaseNonAscii(Char& strA, int lengthA, Char& strB, int lengthB);
    private static bool EqualsIgnoreCase_Vector128(Char& charA, Char& charB, int length);
    internal static bool EqualsIgnoreCase(Char& charA, Char& charB, int length);
    internal static bool EqualsIgnoreCase_Scalar(Char& charA, Char& charB, int length);
    internal static int IndexOf(string source, string value, int startIndex, int count, bool ignoreCase);
    internal static int IndexOfOrdinalIgnoreCase(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
    internal static int LastIndexOfOrdinalIgnoreCase(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
    internal static int ToUpperOrdinal(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal static bool EqualsStringIgnoreCaseUtf8(Byte& strA, int lengthA, Byte& strB, int lengthB);
    internal static bool EqualsStringIgnoreCaseNonAsciiUtf8(Byte& strA, int lengthA, Byte& strB, int lengthB);
    private static bool EqualsIgnoreCaseUtf8_Vector128(Byte& charA, int lengthA, Byte& charB, int lengthB);
    internal static bool EqualsIgnoreCaseUtf8(Byte& charA, int lengthA, Byte& charB, int lengthB);
    internal static bool EqualsIgnoreCaseUtf8_Scalar(Byte& charA, int lengthA, Byte& charB, int lengthB);
    internal static bool StartsWithStringIgnoreCaseUtf8(Byte& source, int sourceLength, Byte& prefix, int prefixLength);
    internal static bool StartsWithStringIgnoreCaseNonAsciiUtf8(Byte& source, int sourceLength, Byte& prefix, int prefixLength);
    private static bool StartsWithIgnoreCaseUtf8_Vector128(Byte& source, int sourceLength, Byte& prefix, int prefixLength);
    internal static bool StartsWithIgnoreCaseUtf8(Byte& source, int sourceLength, Byte& prefix, int prefixLength);
    internal static bool StartsWithIgnoreCaseUtf8_Scalar(Byte& source, int sourceLength, Byte& prefix, int prefixLength);
}
[ExtensionAttribute]
internal static class System.Globalization.OrdinalCasing : object {
    private static UInt16[] s_basicLatin;
    private static UInt16[][] s_casingTable;
    private static UInt16[] NoCasingPage { get; }
    private static ReadOnlySpan`1<byte> s_casingTableInit { get; }
    private static OrdinalCasing();
    private static UInt16[] get_NoCasingPage();
    private static ReadOnlySpan`1<byte> get_s_casingTableInit();
    internal static char ToUpper(char c);
    internal static void ToUpperOrdinal(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal static int CompareStringIgnoreCase(Char& strA, int lengthA, Char& strB, int lengthB);
    internal static int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
    internal static int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value);
    private static UInt16[][] InitCasingTable();
    private static UInt16[] InitOrdinalCasingPage(int pageNumber);
}
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    private static long s_persianEpoch;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static ReadOnlySpan`1<int> DaysToMonth { get; }
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    [NullableAttribute("1")]
public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static PersianCalendar();
    private static ReadOnlySpan`1<int> get_DaysToMonth();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    private static long GetAbsoluteDatePersian(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static int MonthFromOrdinalDay(int ordinalDay);
    private static int DaysInPreviousMonths(int month);
    internal int GetDatePart(long ticks, int part);
    internal void GetDate(long ticks, Int32& year, Int32& month, Int32& day);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    [NullableContextAttribute("1")]
public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.RegionInfo : object {
    private string _name;
    private CultureData _cultureData;
    internal static RegionInfo modreq(System.Runtime.CompilerServices.IsVolatile) s_currentRegionInfo;
    public static RegionInfo CurrentRegion { get; }
    public string Name { get; }
    public string EnglishName { get; }
    public string DisplayName { get; }
    public string NativeName { get; }
    public string TwoLetterISORegionName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public bool IsMetric { get; }
    public int GeoId { get; }
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public string ISOCurrencySymbol { get; }
    public RegionInfo(string name);
    public RegionInfo(int culture);
    internal RegionInfo(CultureData cultureData);
    public static RegionInfo get_CurrentRegion();
    public virtual string get_Name();
    public virtual string get_EnglishName();
    public virtual string get_DisplayName();
    public virtual string get_NativeName();
    public virtual string get_TwoLetterISORegionName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual bool get_IsMetric();
    public virtual int get_GeoId();
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public virtual string get_ISOCurrencySymbol();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.SortKey : object {
    private CompareInfo _compareInfo;
    private CompareOptions _options;
    private string _string;
    private Byte[] _keyData;
    public string OriginalString { get; }
    public Byte[] KeyData { get; }
    internal SortKey(CompareInfo compareInfo, string str, CompareOptions options, Byte[] keyData);
    public string get_OriginalString();
    public Byte[] get_KeyData();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Globalization.SortVersion : object {
    private int m_NlsVersion;
    private Guid m_SortId;
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    internal SortVersion(int nlsVersion, int effectiveId, Guid customVersion);
    public int get_FullVersion();
    public Guid get_SortId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SortVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.StringInfo : object {
    private string _str;
    private Int32[] _indexes;
    [NullableAttribute("2")]
private Int32[] Indexes { get; }
    public string String { get; public set; }
    public int LengthInTextElements { get; }
    public StringInfo(string value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    private Int32[] get_Indexes();
    public string get_String();
    [MemberNotNullAttribute("_str")]
public void set_String(string value);
    public int get_LengthInTextElements();
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
    public static string GetNextTextElement(string str);
    public static string GetNextTextElement(string str, int index);
    public static int GetNextTextElementLength(string str);
    public static int GetNextTextElementLength(string str, int index);
    [NullableContextAttribute("0")]
public static int GetNextTextElementLength(ReadOnlySpan`1<char> str);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
}
internal enum System.Globalization.StrongBidiCategory : Enum {
    public int value__;
    public static StrongBidiCategory Other;
    public static StrongBidiCategory StrongLeftToRight;
    public static StrongBidiCategory StrongRightToLeft;
}
internal static class System.Globalization.SurrogateCasing : object {
    internal static void ToUpper(char h, char l, Char& hr, Char& lr);
    internal static void ToLower(char h, char l, Char& hr, Char& lr);
    internal static bool Equal(char h1, char l1, char h2, char l2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TaiwanCalendar : Calendar {
    private static EraInfo[] s_taiwanEraInfo;
    private static Calendar modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultInstance;
    private GregorianCalendarHelper _helper;
    private static DateTime s_calendarMinValue;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static TaiwanCalendar();
    internal static Calendar GetDefaultInstance();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    private static EraInfo[] s_taiwanLunisolarEraInfo;
    private GregorianCalendarHelper _helper;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    private static Int32[0...,0...] s_yinfo;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    internal int MinCalendarYear { get; }
    internal int MaxCalendarYear { get; }
    internal DateTime MinDate { get; }
    internal DateTime MaxDate { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal EraInfo[] CalEraInfo { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    private static TaiwanLunisolarCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    internal virtual int get_MinCalendarYear();
    internal virtual int get_MaxCalendarYear();
    internal virtual DateTime get_MinDate();
    internal virtual DateTime get_MaxDate();
    internal virtual EraInfo[] get_CalEraInfo();
    internal virtual int GetYearInfo(int lunarYear, int index);
    internal virtual int GetYear(int year, DateTime time);
    internal virtual int GetGregorianYear(int year, int era);
    public virtual int GetEra(DateTime time);
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    public virtual Int32[] get_Eras();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TextElementEnumerator : object {
    private string _str;
    private int _strStartIndex;
    private int _currentTextElementOffset;
    private int _currentTextElementLength;
    private string _currentTextElementSubstr;
    public object Current { get; }
    public int ElementIndex { get; }
    internal TextElementEnumerator(string str, int startIndex);
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    public string GetTextElement();
    public int get_ElementIndex();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TextInfo : object {
    private string _listSeparator;
    private bool _isReadOnly;
    private string _cultureName;
    private CultureData _cultureData;
    private string _textInfoName;
    private Tristate _isAsciiCasingSameAsInvariant;
    internal static TextInfo Invariant;
    private Tristate _needsTurkishCasing;
    private bool HasEmptyCultureName { get; }
    public int ANSICodePage { get; }
    public int OEMCodePage { get; }
    public int MacCodePage { get; }
    public int EBCDICCodePage { get; }
    public int LCID { get; }
    public string CultureName { get; }
    public bool IsReadOnly { get; }
    public string ListSeparator { get; public set; }
    private bool IsAsciiCasingSameAsInvariant { get; }
    public bool IsRightToLeft { get; }
    internal TextInfo(CultureData cultureData);
    private TextInfo(CultureData cultureData, bool readOnly);
    private static TextInfo();
    private bool get_HasEmptyCultureName();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public int get_ANSICodePage();
    public int get_OEMCodePage();
    public int get_MacCodePage();
    public int get_EBCDICCodePage();
    public int get_LCID();
    public string get_CultureName();
    public bool get_IsReadOnly();
    public sealed virtual object Clone();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private void VerifyWritable();
    internal void SetReadOnlyState(bool readOnly);
    public string get_ListSeparator();
    public void set_ListSeparator(string value);
    public char ToLower(char c);
    internal static char ToLowerInvariant(char c);
    public string ToLower(string str);
    private char ChangeCase(char c, bool toUpper);
    internal void ChangeCaseToLower(ReadOnlySpan`1<char> source, Span`1<char> destination);
    internal void ChangeCaseToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private void ChangeCaseCommon(ReadOnlySpan`1<char> source, Span`1<char> destination);
    private string ChangeCaseCommon(string source);
    internal static string ToLowerAsciiInvariant(string s);
    private static char ToLowerAsciiInvariant(char c);
    public char ToUpper(char c);
    internal static char ToUpperInvariant(char c);
    public string ToUpper(string str);
    private static char ToUpperAsciiInvariant(char c);
    private bool get_IsAsciiCasingSameAsInvariant();
    private void PopulateIsAsciiCasingSameAsInvariant();
    public bool get_IsRightToLeft();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToTitleCase(string str);
    private static int AddNonLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private int AddTitlecaseLetter(StringBuilder& result, String& input, int inputIndex, int charLen);
    private void ChangeCaseCore(Char* src, int srcLen, Char* dstBuffer, int dstBufferCapacity, bool bToUpper);
    private static bool IsWordSeparator(UnicodeCategory category);
    private static bool IsLetterCategory(UnicodeCategory uc);
    private static bool NeedsTurkishCasing(string localeName);
    internal void IcuChangeCase(Char* src, int srcLen, Char* dstBuffer, int dstBufferCapacity, bool bToUpper);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    private static EraInfo[] s_thaiBuddhistEraInfo;
    public static int ThaiBuddhistEra;
    private GregorianCalendarHelper _helper;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId ID { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static ThaiBuddhistCalendar();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_ID();
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetEra(DateTime time);
    public virtual int GetMonth(DateTime time);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual Int32[] get_Eras();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
internal static class System.Globalization.TimeSpanFormat : object {
    internal static FormatLiterals PositiveInvariantFormatLiterals;
    internal static FormatLiterals NegativeInvariantFormatLiterals;
    private static TimeSpanFormat();
    internal static string Format(TimeSpan value, string format, IFormatProvider formatProvider);
    internal static bool TryFormat(TimeSpan value, Span`1<TChar> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    internal static string FormatC(TimeSpan value);
    private static string FormatG(TimeSpan value, DateTimeFormatInfo dtfi, StandardFormat format);
    internal static bool TryFormatStandard(TimeSpan value, StandardFormat format, ReadOnlySpan`1<TChar> decimalSeparator, Span`1<TChar> destination, Int32& written);
    private static void FormatCustomized(TimeSpan value, ReadOnlySpan`1<char> format, DateTimeFormatInfo dtfi, ValueListBuilder`1& result);
}
internal static class System.Globalization.TimeSpanParse : object {
    internal static long Pow10(int pow);
    private static bool TryTimeToTicks(bool positive, TimeSpanToken days, TimeSpanToken hours, TimeSpanToken minutes, TimeSpanToken seconds, TimeSpanToken fraction, Int64& result);
    internal static TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    internal static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    internal static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    internal static TimeSpan ParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    internal static bool TryParseExactMultiple(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    private static bool TryParseTimeSpan(ReadOnlySpan`1<char> input, TimeSpanStandardStyles style, IFormatProvider formatProvider, TimeSpanResult& result);
    private static bool ProcessTerminalState(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_DHMSF(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HMS_F_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM_S_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_HM(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool ProcessTerminal_D(TimeSpanRawInfo& raw, TimeSpanStandardStyles style, TimeSpanResult& result);
    private static bool TryParseExactTimeSpan(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool TryParseByFormat(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, TimeSpanStyles styles, TimeSpanResult& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, Int32& result);
    private static bool ParseExactDigits(TimeSpanTokenizer& tokenizer, int minDigitLength, int maxDigitLength, Int32& zeroes, Int32& result);
    private static bool ParseExactLiteral(TimeSpanTokenizer& tokenizer, ValueStringBuilder& enquotedString);
    private static bool TryParseTimeSpanConstant(ReadOnlySpan`1<char> input, TimeSpanResult& result);
    private static bool TryParseExactMultipleTimeSpan(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpanResult& result);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.UmAlQuraCalendar : Calendar {
    private static DateMapping[] s_hijriYearInfo;
    public static int UmAlQuraEra;
    private static DateTime s_minDate;
    private static DateTime s_maxDate;
    public DateTime MinSupportedDateTime { get; }
    public DateTime MaxSupportedDateTime { get; }
    public CalendarAlgorithmType AlgorithmType { get; }
    internal CalendarId BaseCalendarID { get; }
    internal CalendarId ID { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int TwoDigitYearMax { get; public set; }
    private static UmAlQuraCalendar();
    private static DateMapping[] InitDateMapping();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual CalendarAlgorithmType get_AlgorithmType();
    internal virtual CalendarId get_BaseCalendarID();
    internal virtual CalendarId get_ID();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    private static void ConvertHijriToGregorian(int HijriYear, int HijriMonth, int HijriDay, Int32& yg, Int32& mg, Int32& dg);
    private static long GetAbsoluteDateUmAlQura(int year, int month, int day);
    internal static void CheckTicksRange(long ticks);
    internal static void CheckEraRange(int era);
    internal static void CheckYearRange(int year, int era);
    internal static void CheckYearMonthRange(int year, int month, int era);
    private static void ConvertGregorianToHijri(DateTime time, Int32& HijriYear, Int32& HijriMonth, Int32& HijriDay);
    private static int GetDatePart(DateTime time, int part);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    internal static int RealGetDaysInYear(int year);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual Int32[] get_Eras();
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
[IsReadOnlyAttribute]
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Guid : ValueType {
    public static Guid Empty;
    private int _a;
    private short _b;
    private short _c;
    private byte _d;
    private byte _e;
    private byte _f;
    private byte _g;
    private byte _h;
    private byte _i;
    private byte _j;
    private byte _k;
    [NullableContextAttribute("1")]
public Guid(Byte[] b);
    public Guid(ReadOnlySpan`1<byte> b);
    public Guid(ReadOnlySpan`1<byte> b, bool bigEndian);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    [NullableContextAttribute("1")]
public Guid(int a, short b, short c, Byte[] d);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    [NullableContextAttribute("1")]
public Guid(string g);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
private static void ThrowGuidArrayCtorArgumentException();
    [NullableContextAttribute("1")]
public static Guid Parse(string input);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, Guid& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    [NullableContextAttribute("1")]
public static Guid ParseExact(string input, string format);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    private static bool TryParseGuid(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactB(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactD(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactN(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactP(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static bool TryParseExactX(ReadOnlySpan`1<char> guidString, GuidResult& result);
    private static byte DecodeByte(char ch1, char ch2, Int32& invalidIfNegative);
    private static bool TryParseHex(ReadOnlySpan`1<char> guidString, UInt16& result, Boolean& overflow);
    private static bool TryParseHex(ReadOnlySpan`1<char> guidString, UInt32& result);
    private static bool TryParseHex(ReadOnlySpan`1<char> guidString, UInt32& result, Boolean& overflow);
    private static ReadOnlySpan`1<char> EatAllWhitespace(ReadOnlySpan`1<char> str);
    private static bool IsHexPrefix(ReadOnlySpan`1<char> str, int i);
    private static ReadOnlySpan`1<byte> AsBytes(Guid& source);
    [NullableContextAttribute("1")]
public Byte[] ToByteArray();
    [NullableContextAttribute("1")]
public Byte[] ToByteArray(bool bigEndian);
    public bool TryWriteBytes(Span`1<byte> destination);
    public bool TryWriteBytes(Span`1<byte> destination, bool bigEndian, Int32& bytesWritten);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public sealed virtual bool Equals(Guid g);
    private static bool EqualsCore(Guid& left, Guid& right);
    private static int GetResult(UInt32 me, UInt32 them);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Guid value);
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_Inequality(Guid a, Guid b);
    private static int HexsToChars(TChar* guidChars, int a, int b);
    private static int HexsToCharsHexOutput(TChar* guidChars, int a, int b);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format);
    private sealed virtual override bool System.IUtf8SpanFormattable.TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private bool TryFormatCore(Span`1<TChar> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    internal bool TryFormatCore(Span`1<TChar> destination, Int32& charsWritten, int flags);
    private bool TryFormatX(Span`1<TChar> destination, Int32& charsWritten);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
private static ValueTuple`3<Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>> FormatGuidVector128Utf8(Guid value, bool useDashes);
    public static bool op_LessThan(Guid left, Guid right);
    public static bool op_LessThanOrEqual(Guid left, Guid right);
    public static bool op_GreaterThan(Guid left, Guid right);
    public static bool op_GreaterThanOrEqual(Guid left, Guid right);
    [NullableContextAttribute("1")]
public static override Guid Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Guid& result);
    public static override Guid Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Guid& result);
    [DoesNotReturnAttribute]
private static void ThrowBadGuidFormatSpecification();
    public static Guid NewGuid();
    [CompilerGeneratedAttribute]
internal static bool <TryParseExactD>g__TryCompatParsing|33_0(ReadOnlySpan`1<char> guidString, GuidResult& result);
}
[IsReadOnlyAttribute]
public class System.Half : ValueType {
    internal ushort _value;
    public static Half Epsilon { get; }
    public static Half PositiveInfinity { get; }
    public static Half NegativeInfinity { get; }
    public static Half NaN { get; }
    public static Half MinValue { get; }
    public static Half MaxValue { get; }
    internal byte BiasedExponent { get; }
    internal sbyte Exponent { get; }
    internal ushort Significand { get; }
    internal ushort TrailingSignificand { get; }
    private static Half System.Numerics.IAdditiveIdentity<System.Half,System.Half>.AdditiveIdentity { get; }
    private static Half System.Numerics.IBinaryNumber<System.Half>.AllBitsSet { get; }
    public static Half E { get; }
    public static Half Pi { get; }
    public static Half Tau { get; }
    public static Half NegativeZero { get; }
    public static Half MultiplicativeIdentity { get; }
    public static Half One { get; }
    private static int System.Numerics.INumberBase<System.Half>.Radix { get; }
    public static Half Zero { get; }
    public static Half NegativeOne { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.NumberBufferLength { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.ZeroBits { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.InfinityBits { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.NormalMantissaMask { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.DenormalMantissaMask { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MinBinaryExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MaxBinaryExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MinDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MaxDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.ExponentBias { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Half>.ExponentBits { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.OverflowDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.InfinityExponent { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Half>.NormalMantissaBits { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Half>.DenormalMantissaBits { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MinFastFloatDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MaxFastFloatDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MinExponentRoundToEven { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MaxExponentRoundToEven { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Half>.MaxExponentFastPath { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.MaxMantissaFastPath { get; }
    internal Half(ushort value);
    private Half(bool sign, ushort exp, ushort sig);
    public static override Half get_Epsilon();
    public static override Half get_PositiveInfinity();
    public static override Half get_NegativeInfinity();
    public static override Half get_NaN();
    public static override Half get_MinValue();
    public static override Half get_MaxValue();
    internal byte get_BiasedExponent();
    internal sbyte get_Exponent();
    internal ushort get_Significand();
    internal ushort get_TrailingSignificand();
    internal static byte ExtractBiasedExponentFromBits(ushort bits);
    internal static ushort ExtractTrailingSignificandFromBits(ushort bits);
    public static override bool op_LessThan(Half left, Half right);
    public static override bool op_GreaterThan(Half left, Half right);
    public static override bool op_LessThanOrEqual(Half left, Half right);
    public static override bool op_GreaterThanOrEqual(Half left, Half right);
    public static override bool op_Equality(Half left, Half right);
    public static override bool op_Inequality(Half left, Half right);
    public static override bool IsFinite(Half value);
    public static override bool IsInfinity(Half value);
    public static override bool IsNaN(Half value);
    public static override bool IsNegative(Half value);
    public static override bool IsNegativeInfinity(Half value);
    public static override bool IsNormal(Half value);
    public static override bool IsPositiveInfinity(Half value);
    public static override bool IsSubnormal(Half value);
    [NullableContextAttribute("1")]
public static Half Parse(string s);
    [NullableContextAttribute("1")]
public static Half Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override Half Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override Half Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override Half Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Half& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Half& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Half& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Half& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Half& result);
    private static bool AreZero(Half left, Half right);
    private static bool IsNaNOrZero(Half value);
    private static UInt32 StripSign(Half value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Half other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Half other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static Half op_Explicit(char value);
    public static Half op_Explicit(decimal value);
    public static Half op_Explicit(double value);
    public static Half op_Explicit(short value);
    public static Half op_Explicit(int value);
    public static Half op_Explicit(long value);
    public static Half op_Explicit(IntPtr value);
    public static Half op_Explicit(float value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(ushort value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(ulong value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(UIntPtr value);
    public static byte op_Explicit(Half value);
    public static byte op_CheckedExplicit(Half value);
    public static char op_Explicit(Half value);
    public static char op_CheckedExplicit(Half value);
    public static decimal op_Explicit(Half value);
    public static short op_Explicit(Half value);
    public static short op_CheckedExplicit(Half value);
    public static int op_Explicit(Half value);
    public static int op_CheckedExplicit(Half value);
    public static long op_Explicit(Half value);
    public static long op_CheckedExplicit(Half value);
    public static Int128 op_Explicit(Half value);
    public static Int128 op_CheckedExplicit(Half value);
    public static IntPtr op_Explicit(Half value);
    public static IntPtr op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(Half value);
    public static Half op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static Half op_Implicit(sbyte value);
    public static double op_Explicit(Half value);
    public static float op_Explicit(Half value);
    internal static Half Negate(Half value);
    private static ValueTuple`2<int, UInt32> NormSubnormalF16Sig(UInt32 sig);
    private static Half CreateHalfNaN(bool sign, ulong significand);
    private static ushort RoundPackToHalf(bool sign, short exp, ushort sig);
    private static UInt32 ShiftRightJam(UInt32 i, int dist);
    private static ulong ShiftRightJam(ulong l, int dist);
    private static double CreateDoubleNaN(bool sign, ulong significand);
    private static double CreateDouble(bool sign, ushort exp, ulong sig);
    public static override Half op_Addition(Half left, Half right);
    private static override Half System.Numerics.IAdditiveIdentity<System.Half,System.Half>.get_AdditiveIdentity();
    private static override Half System.Numerics.IBinaryNumber<System.Half>.get_AllBitsSet();
    public static override bool IsPow2(Half value);
    public static override Half Log2(Half value);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_BitwiseAnd(Half left, Half right);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_BitwiseOr(Half left, Half right);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_ExclusiveOr(Half left, Half right);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_OnesComplement(Half value);
    public static override Half op_Decrement(Half value);
    public static override Half op_Division(Half left, Half right);
    public static override Half Exp(Half x);
    public static override Half ExpM1(Half x);
    public static override Half Exp2(Half x);
    public static override Half Exp2M1(Half x);
    public static override Half Exp10(Half x);
    public static override Half Exp10M1(Half x);
    public static override Half Ceiling(Half x);
    public static override Half Floor(Half x);
    public static override Half Round(Half x);
    public static override Half Round(Half x, int digits);
    public static override Half Round(Half x, MidpointRounding mode);
    public static override Half Round(Half x, int digits, MidpointRounding mode);
    public static override Half Truncate(Half x);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetSignificandByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetSignificandBitLength();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    public static override Half get_E();
    public static override Half get_Pi();
    public static override Half get_Tau();
    public static override Half get_NegativeZero();
    public static override Half Atan2(Half y, Half x);
    public static override Half Atan2Pi(Half y, Half x);
    public static override Half BitDecrement(Half x);
    public static override Half BitIncrement(Half x);
    public static override Half FusedMultiplyAdd(Half left, Half right, Half addend);
    public static override Half Ieee754Remainder(Half left, Half right);
    public static override int ILogB(Half x);
    public static override Half Lerp(Half value1, Half value2, Half amount);
    public static override Half ReciprocalEstimate(Half x);
    public static override Half ReciprocalSqrtEstimate(Half x);
    public static override Half ScaleB(Half x, int n);
    public static override Half Acosh(Half x);
    public static override Half Asinh(Half x);
    public static override Half Atanh(Half x);
    public static override Half Cosh(Half x);
    public static override Half Sinh(Half x);
    public static override Half Tanh(Half x);
    public static override Half op_Increment(Half value);
    public static override Half Log(Half x);
    public static override Half Log(Half x, Half newBase);
    public static override Half Log10(Half x);
    public static override Half LogP1(Half x);
    public static override Half Log2P1(Half x);
    public static override Half Log10P1(Half x);
    public static override Half op_Modulus(Half left, Half right);
    public static override Half get_MultiplicativeIdentity();
    public static override Half op_Multiply(Half left, Half right);
    public static override Half Clamp(Half value, Half min, Half max);
    public static override Half CopySign(Half value, Half sign);
    public static override Half Max(Half x, Half y);
    public static override Half MaxNumber(Half x, Half y);
    public static override Half Min(Half x, Half y);
    public static override Half MinNumber(Half x, Half y);
    public static override int Sign(Half value);
    public static override Half get_One();
    private static override int System.Numerics.INumberBase<System.Half>.get_Radix();
    public static override Half get_Zero();
    public static override Half Abs(Half value);
    [NullableContextAttribute("1")]
public static override Half CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override Half CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override Half CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsCanonical(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsComplexNumber(Half value);
    public static override bool IsEvenInteger(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsImaginaryNumber(Half value);
    public static override bool IsInteger(Half value);
    public static override bool IsOddInteger(Half value);
    public static override bool IsPositive(Half value);
    public static override bool IsRealNumber(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsZero(Half value);
    public static override Half MaxMagnitude(Half x, Half y);
    public static override Half MaxMagnitudeNumber(Half x, Half y);
    public static override Half MinMagnitude(Half x, Half y);
    public static override Half MinMagnitudeNumber(Half x, Half y);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertFromChecked(TOther value, Half& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertFromSaturating(TOther value, Half& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertFromTruncating(TOther value, Half& result);
    private static bool TryConvertFrom(TOther value, Half& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertToChecked(Half value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertToSaturating(Half value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertToTruncating(Half value, TOther& result);
    private static bool TryConvertTo(Half value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Half& result);
    public static override Half Pow(Half x, Half y);
    public static override Half Cbrt(Half x);
    public static override Half Hypot(Half x, Half y);
    public static override Half RootN(Half x, int n);
    public static override Half Sqrt(Half x);
    public static override Half get_NegativeOne();
    public static override Half Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Half& result);
    public static override Half op_Subtraction(Half left, Half right);
    public static override Half Acos(Half x);
    public static override Half AcosPi(Half x);
    public static override Half Asin(Half x);
    public static override Half AsinPi(Half x);
    public static override Half Atan(Half x);
    public static override Half AtanPi(Half x);
    public static override Half Cos(Half x);
    public static override Half CosPi(Half x);
    public static override Half DegreesToRadians(Half degrees);
    public static override Half RadiansToDegrees(Half radians);
    public static override Half Sin(Half x);
    public static override ValueTuple`2<Half, Half> SinCos(Half x);
    public static override ValueTuple`2<Half, Half> SinCosPi(Half x);
    public static override Half SinPi(Half x);
    public static override Half Tan(Half x);
    public static override Half TanPi(Half x);
    public static override Half op_UnaryNegation(Half value);
    public static override Half op_UnaryPlus(Half value);
    public static override Half Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Half& result);
    public static override Half Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Half& result);
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_NumberBufferLength();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.get_ZeroBits();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.get_InfinityBits();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.get_NormalMantissaMask();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.get_DenormalMantissaMask();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MinBinaryExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MaxBinaryExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MinDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MaxDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_ExponentBias();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Half>.get_ExponentBits();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_OverflowDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_InfinityExponent();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Half>.get_NormalMantissaBits();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Half>.get_DenormalMantissaBits();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MinFastFloatDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MaxFastFloatDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MinExponentRoundToEven();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MaxExponentRoundToEven();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MaxExponentFastPath();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.get_MaxMantissaFastPath();
    private static override Half System.IBinaryFloatParseAndFormatInfo<System.Half>.BitsToFloat(ulong bits);
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Half>.FloatToBits(Half value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.HashCode : ValueType {
    private static UInt32 s_seed;
    private UInt32 _v1;
    private UInt32 _v2;
    private UInt32 _v3;
    private UInt32 _v4;
    private UInt32 _queue1;
    private UInt32 _queue2;
    private UInt32 _queue3;
    private UInt32 _length;
    private static HashCode();
    private static UInt32 GenerateGlobalSeed();
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    private static void Initialize(UInt32& v1, UInt32& v2, UInt32& v3, UInt32& v4);
    private static UInt32 Round(UInt32 hash, UInt32 input);
    private static UInt32 QueueRound(UInt32 hash, UInt32 queuedValue);
    private static UInt32 MixState(UInt32 v1, UInt32 v2, UInt32 v3, UInt32 v4);
    private static UInt32 MixEmptyState();
    private static UInt32 MixFinal(UInt32 hash);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("0")]
public void AddBytes(ReadOnlySpan`1<byte> value);
    private void Add(int value);
    public int ToHashCode();
    [ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
internal static class System.HexConverter : object {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex, Casing casing);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
internal static ValueTuple`2<Vector128`1<byte>, Vector128`1<byte>> AsciiToHexVector128(Vector128`1<byte> src, Vector128`1<byte> hexMap);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
private static void EncodeToUtf16_Vector128(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static void EncodeToUtf16(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Casing casing);
    public static string ToString(ReadOnlySpan`1<byte> bytes, Casing casing);
    public static char ToCharUpper(int value);
    public static char ToCharLower(int value);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
public static bool TryDecodeFromUtf16_Vector128(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static bool TryDecodeFromUtf16(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsProcessed);
    public static int FromChar(int c);
    public static bool IsHexChar(int c);
    public static bool IsHexUpperChar(int c);
    public static bool IsHexLowerChar(int c);
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
}
internal class System.IArraySpec : object {
    private int dimensions;
    private bool bound;
    public int Rank { get; }
    public bool IsBound { get; }
    internal IArraySpec(int dimensions, bool bound);
    public sealed virtual Type Resolve(Type type);
    public sealed virtual StringBuilder Append(StringBuilder sb);
    public virtual string ToString();
    public int get_Rank();
    public bool get_IsBound();
}
public interface System.IAsyncDisposable {
    public abstract virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
public interface System.IAsyncResult {
    public bool IsCompleted { get; }
    public WaitHandle AsyncWaitHandle { get; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    public bool CompletedSynchronously { get; }
    public abstract virtual bool get_IsCompleted();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    [NullableContextAttribute("2")]
public abstract virtual object get_AsyncState();
    public abstract virtual bool get_CompletedSynchronously();
}
internal interface System.IBinaryFloatParseAndFormatInfo`1 {
    public static int NumberBufferLength { get; }
    public static ulong ZeroBits { get; }
    public static ulong InfinityBits { get; }
    public static ulong NormalMantissaMask { get; }
    public static ulong DenormalMantissaMask { get; }
    public static int MinBinaryExponent { get; }
    public static int MaxBinaryExponent { get; }
    public static int MinDecimalExponent { get; }
    public static int MaxDecimalExponent { get; }
    public static int ExponentBias { get; }
    public static ushort ExponentBits { get; }
    public static int OverflowDecimalExponent { get; }
    public static int InfinityExponent { get; }
    public static ushort NormalMantissaBits { get; }
    public static ushort DenormalMantissaBits { get; }
    public static int MinFastFloatDecimalExponent { get; }
    public static int MaxFastFloatDecimalExponent { get; }
    public static int MinExponentRoundToEven { get; }
    public static int MaxExponentRoundToEven { get; }
    public static int MaxExponentFastPath { get; }
    public static ulong MaxMantissaFastPath { get; }
    public static abstract virtual int get_NumberBufferLength();
    public static abstract virtual ulong get_ZeroBits();
    public static abstract virtual ulong get_InfinityBits();
    public static abstract virtual ulong get_NormalMantissaMask();
    public static abstract virtual ulong get_DenormalMantissaMask();
    public static abstract virtual int get_MinBinaryExponent();
    public static abstract virtual int get_MaxBinaryExponent();
    public static abstract virtual int get_MinDecimalExponent();
    public static abstract virtual int get_MaxDecimalExponent();
    public static abstract virtual int get_ExponentBias();
    public static abstract virtual ushort get_ExponentBits();
    public static abstract virtual int get_OverflowDecimalExponent();
    public static abstract virtual int get_InfinityExponent();
    public static abstract virtual ushort get_NormalMantissaBits();
    public static abstract virtual ushort get_DenormalMantissaBits();
    public static abstract virtual int get_MinFastFloatDecimalExponent();
    public static abstract virtual int get_MaxFastFloatDecimalExponent();
    public static abstract virtual int get_MinExponentRoundToEven();
    public static abstract virtual int get_MaxExponentRoundToEven();
    public static abstract virtual int get_MaxExponentFastPath();
    public static abstract virtual ulong get_MaxMantissaFastPath();
    public static abstract virtual TSelf BitsToFloat(ulong bits);
    public static abstract virtual ulong FloatToBits(TSelf value);
}
internal interface System.IBinaryIntegerParseAndFormatInfo`1 {
    public static bool IsSigned { get; }
    public static int MaxDigitCount { get; }
    public static int MaxHexDigitCount { get; }
    public static TSelf MaxValueDiv10 { get; }
    public static string OverflowMessage { get; }
    public static abstract virtual bool get_IsSigned();
    public static abstract virtual int get_MaxDigitCount();
    public static abstract virtual int get_MaxHexDigitCount();
    public static abstract virtual TSelf get_MaxValueDiv10();
    public static abstract virtual string get_OverflowMessage();
    public static abstract virtual bool IsGreaterThanAsUnsigned(TSelf left, TSelf right);
    public static abstract virtual TSelf MultiplyBy10(TSelf value);
    public static abstract virtual TSelf MultiplyBy16(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.ICloneable {
    public abstract virtual object Clone();
}
[NullableContextAttribute("2")]
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
[NullableContextAttribute("2")]
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("1")]
public abstract virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
}
[NullableContextAttribute("2")]
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
[NullableContextAttribute("2")]
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
[NullableContextAttribute("2")]
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
[NullableContextAttribute("2")]
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
internal interface System.IModifierSpec {
    public abstract virtual Type Resolve(Type type);
    public abstract virtual StringBuilder Append(StringBuilder sb);
}
[IsReadOnlyAttribute]
public class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private static void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
    private string ToStringFromEnd();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private IndexOutOfRangeException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private InsufficientExecutionStackException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private InsufficientMemoryException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[IntrinsicAttribute]
public class System.Int128 : ValueType {
    private ulong _lower;
    private ulong _upper;
    internal ulong Lower { get; }
    internal ulong Upper { get; }
    private static Int128 System.Numerics.IAdditiveIdentity<System.Int128,System.Int128>.AdditiveIdentity { get; }
    private static Int128 System.Numerics.IBinaryNumber<System.Int128>.AllBitsSet { get; }
    public static Int128 MinValue { get; }
    public static Int128 MaxValue { get; }
    private static Int128 System.Numerics.IMultiplicativeIdentity<System.Int128,System.Int128>.MultiplicativeIdentity { get; }
    public static Int128 One { get; }
    private static int System.Numerics.INumberBase<System.Int128>.Radix { get; }
    public static Int128 Zero { get; }
    public static Int128 NegativeOne { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.Int128>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int128>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int128>.MaxHexDigitCount { get; }
    private static Int128 System.IBinaryIntegerParseAndFormatInfo<System.Int128>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.Int128>.OverflowMessage { get; }
    [CLSCompliantAttribute("False")]
public Int128(ulong upper, ulong lower);
    internal ulong get_Lower();
    internal ulong get_Upper();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(Int128 value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Int128 other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Int128 Parse(string s);
    [NullableContextAttribute("1")]
public static Int128 Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override Int128 Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override Int128 Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override Int128 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int128& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int128& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Int128& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int128& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int128& result);
    public static byte op_Explicit(Int128 value);
    public static byte op_CheckedExplicit(Int128 value);
    public static char op_Explicit(Int128 value);
    public static char op_CheckedExplicit(Int128 value);
    public static decimal op_Explicit(Int128 value);
    public static double op_Explicit(Int128 value);
    public static Half op_Explicit(Int128 value);
    public static short op_Explicit(Int128 value);
    public static short op_CheckedExplicit(Int128 value);
    public static int op_Explicit(Int128 value);
    public static int op_CheckedExplicit(Int128 value);
    public static long op_Explicit(Int128 value);
    public static long op_CheckedExplicit(Int128 value);
    public static IntPtr op_Explicit(Int128 value);
    public static IntPtr op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(Int128 value);
    public static float op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(Int128 value);
    public static Int128 op_Explicit(decimal value);
    public static Int128 op_Explicit(double value);
    public static Int128 op_CheckedExplicit(double value);
    internal static Int128 ToInt128(double value);
    public static Int128 op_Explicit(float value);
    public static Int128 op_CheckedExplicit(float value);
    public static Int128 op_Implicit(byte value);
    public static Int128 op_Implicit(char value);
    public static Int128 op_Implicit(short value);
    public static Int128 op_Implicit(int value);
    public static Int128 op_Implicit(long value);
    public static Int128 op_Implicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(UIntPtr value);
    public static override Int128 op_Addition(Int128 left, Int128 right);
    public static override Int128 op_CheckedAddition(Int128 left, Int128 right);
    private static override Int128 System.Numerics.IAdditiveIdentity<System.Int128,System.Int128>.get_AdditiveIdentity();
    public static override ValueTuple`2<Int128, Int128> DivRem(Int128 left, Int128 right);
    public static override Int128 LeadingZeroCount(Int128 value);
    public static override Int128 PopCount(Int128 value);
    public static override Int128 RotateLeft(Int128 value, int rotateAmount);
    public static override Int128 RotateRight(Int128 value, int rotateAmount);
    public static override Int128 TrailingZeroCount(Int128 value);
    private static override bool System.Numerics.IBinaryInteger<System.Int128>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int128& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int128>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int128& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int128>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int128>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override Int128 System.Numerics.IBinaryNumber<System.Int128>.get_AllBitsSet();
    public static override bool IsPow2(Int128 value);
    public static override Int128 Log2(Int128 value);
    public static override Int128 op_BitwiseAnd(Int128 left, Int128 right);
    public static override Int128 op_BitwiseOr(Int128 left, Int128 right);
    public static override Int128 op_ExclusiveOr(Int128 left, Int128 right);
    public static override Int128 op_OnesComplement(Int128 value);
    public static override bool op_LessThan(Int128 left, Int128 right);
    public static override bool op_LessThanOrEqual(Int128 left, Int128 right);
    public static override bool op_GreaterThan(Int128 left, Int128 right);
    public static override bool op_GreaterThanOrEqual(Int128 left, Int128 right);
    public static override Int128 op_Decrement(Int128 value);
    public static override Int128 op_CheckedDecrement(Int128 value);
    public static override Int128 op_Division(Int128 left, Int128 right);
    public static override Int128 op_CheckedDivision(Int128 left, Int128 right);
    public static override bool op_Equality(Int128 left, Int128 right);
    public static override bool op_Inequality(Int128 left, Int128 right);
    public static override Int128 op_Increment(Int128 value);
    public static override Int128 op_CheckedIncrement(Int128 value);
    public static override Int128 get_MinValue();
    public static override Int128 get_MaxValue();
    public static override Int128 op_Modulus(Int128 left, Int128 right);
    private static override Int128 System.Numerics.IMultiplicativeIdentity<System.Int128,System.Int128>.get_MultiplicativeIdentity();
    public static override Int128 op_Multiply(Int128 left, Int128 right);
    public static override Int128 op_CheckedMultiply(Int128 left, Int128 right);
    internal static Int128 BigMul(Int128 left, Int128 right, Int128& lower);
    public static override Int128 Clamp(Int128 value, Int128 min, Int128 max);
    public static override Int128 CopySign(Int128 value, Int128 sign);
    public static override Int128 Max(Int128 x, Int128 y);
    private static override Int128 System.Numerics.INumber<System.Int128>.MaxNumber(Int128 x, Int128 y);
    public static override Int128 Min(Int128 x, Int128 y);
    private static override Int128 System.Numerics.INumber<System.Int128>.MinNumber(Int128 x, Int128 y);
    public static override int Sign(Int128 value);
    public static override Int128 get_One();
    private static override int System.Numerics.INumberBase<System.Int128>.get_Radix();
    public static override Int128 get_Zero();
    public static override Int128 Abs(Int128 value);
    [NullableContextAttribute("1")]
public static override Int128 CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override Int128 CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override Int128 CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsCanonical(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsComplexNumber(Int128 value);
    public static override bool IsEvenInteger(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsFinite(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsImaginaryNumber(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsInfinity(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsInteger(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsNaN(Int128 value);
    public static override bool IsNegative(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsNegativeInfinity(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsNormal(Int128 value);
    public static override bool IsOddInteger(Int128 value);
    public static override bool IsPositive(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsPositiveInfinity(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsRealNumber(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsSubnormal(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsZero(Int128 value);
    public static override Int128 MaxMagnitude(Int128 x, Int128 y);
    private static override Int128 System.Numerics.INumberBase<System.Int128>.MaxMagnitudeNumber(Int128 x, Int128 y);
    public static override Int128 MinMagnitude(Int128 x, Int128 y);
    private static override Int128 System.Numerics.INumberBase<System.Int128>.MinMagnitudeNumber(Int128 x, Int128 y);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertFromChecked(TOther value, Int128& result);
    private static bool TryConvertFromChecked(TOther value, Int128& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertFromSaturating(TOther value, Int128& result);
    private static bool TryConvertFromSaturating(TOther value, Int128& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertFromTruncating(TOther value, Int128& result);
    private static bool TryConvertFromTruncating(TOther value, Int128& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertToChecked(Int128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertToSaturating(Int128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertToTruncating(Int128 value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int128& result);
    public static override Int128 op_LeftShift(Int128 value, int shiftAmount);
    public static override Int128 op_RightShift(Int128 value, int shiftAmount);
    public static override Int128 op_UnsignedRightShift(Int128 value, int shiftAmount);
    public static override Int128 get_NegativeOne();
    public static override Int128 Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int128& result);
    public static override Int128 op_Subtraction(Int128 left, Int128 right);
    public static override Int128 op_CheckedSubtraction(Int128 left, Int128 right);
    public static override Int128 op_UnaryNegation(Int128 value);
    public static override Int128 op_CheckedUnaryNegation(Int128 value);
    public static override Int128 op_UnaryPlus(Int128 value);
    public static override Int128 Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Int128& result);
    public static override Int128 Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Int128& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int128>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int128>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int128>.get_MaxHexDigitCount();
    private static override Int128 System.IBinaryIntegerParseAndFormatInfo<System.Int128>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.Int128>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int128>.IsGreaterThanAsUnsigned(Int128 left, Int128 right);
    private static override Int128 System.IBinaryIntegerParseAndFormatInfo<System.Int128>.MultiplyBy10(Int128 value);
    private static override Int128 System.IBinaryIntegerParseAndFormatInfo<System.Int128>.MultiplyBy16(Int128 value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int16 : ValueType {
    private short m_value;
    public static short MaxValue;
    public static short MinValue;
    private static short System.Numerics.IAdditiveIdentity<System.Int16,System.Int16>.AdditiveIdentity { get; }
    private static short System.Numerics.IBinaryNumber<System.Int16>.AllBitsSet { get; }
    private static short System.Numerics.IMinMaxValue<System.Int16>.MinValue { get; }
    private static short System.Numerics.IMinMaxValue<System.Int16>.MaxValue { get; }
    private static short System.Numerics.IMultiplicativeIdentity<System.Int16,System.Int16>.MultiplicativeIdentity { get; }
    private static short System.Numerics.INumberBase<System.Int16>.One { get; }
    private static int System.Numerics.INumberBase<System.Int16>.Radix { get; }
    private static short System.Numerics.INumberBase<System.Int16>.Zero { get; }
    private static short System.Numerics.ISignedNumber<System.Int16>.NegativeOne { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.Int16>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int16>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int16>.MaxHexDigitCount { get; }
    private static short System.IBinaryIntegerParseAndFormatInfo<System.Int16>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.Int16>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(short value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(short obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static short Parse(string s);
    [NullableContextAttribute("1")]
public static short Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override short Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override short Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Int16& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override short System.Numerics.IAdditionOperators<System.Int16,System.Int16,System.Int16>.op_Addition(short left, short right);
    private static override short System.Numerics.IAdditionOperators<System.Int16,System.Int16,System.Int16>.op_CheckedAddition(short left, short right);
    private static override short System.Numerics.IAdditiveIdentity<System.Int16,System.Int16>.get_AdditiveIdentity();
    public static override ValueTuple`2<short, short> DivRem(short left, short right);
    public static override short LeadingZeroCount(short value);
    public static override short PopCount(short value);
    public static override short RotateLeft(short value, int rotateAmount);
    public static override short RotateRight(short value, int rotateAmount);
    public static override short TrailingZeroCount(short value);
    private static override bool System.Numerics.IBinaryInteger<System.Int16>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int16& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int16>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int16& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int16>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int16>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int16>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int16>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override short System.Numerics.IBinaryNumber<System.Int16>.get_AllBitsSet();
    public static override bool IsPow2(short value);
    public static override short Log2(short value);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_BitwiseAnd(short left, short right);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_BitwiseOr(short left, short right);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_ExclusiveOr(short left, short right);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_OnesComplement(short value);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_LessThan(short left, short right);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_LessThanOrEqual(short left, short right);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_GreaterThan(short left, short right);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_GreaterThanOrEqual(short left, short right);
    private static override short System.Numerics.IDecrementOperators<System.Int16>.op_Decrement(short value);
    private static override short System.Numerics.IDecrementOperators<System.Int16>.op_CheckedDecrement(short value);
    private static override short System.Numerics.IDivisionOperators<System.Int16,System.Int16,System.Int16>.op_Division(short left, short right);
    private static override bool System.Numerics.IEqualityOperators<System.Int16,System.Int16,System.Boolean>.op_Equality(short left, short right);
    private static override bool System.Numerics.IEqualityOperators<System.Int16,System.Int16,System.Boolean>.op_Inequality(short left, short right);
    private static override short System.Numerics.IIncrementOperators<System.Int16>.op_Increment(short value);
    private static override short System.Numerics.IIncrementOperators<System.Int16>.op_CheckedIncrement(short value);
    private static override short System.Numerics.IMinMaxValue<System.Int16>.get_MinValue();
    private static override short System.Numerics.IMinMaxValue<System.Int16>.get_MaxValue();
    private static override short System.Numerics.IModulusOperators<System.Int16,System.Int16,System.Int16>.op_Modulus(short left, short right);
    private static override short System.Numerics.IMultiplicativeIdentity<System.Int16,System.Int16>.get_MultiplicativeIdentity();
    private static override short System.Numerics.IMultiplyOperators<System.Int16,System.Int16,System.Int16>.op_Multiply(short left, short right);
    private static override short System.Numerics.IMultiplyOperators<System.Int16,System.Int16,System.Int16>.op_CheckedMultiply(short left, short right);
    public static override short Clamp(short value, short min, short max);
    public static override short CopySign(short value, short sign);
    public static override short Max(short x, short y);
    private static override short System.Numerics.INumber<System.Int16>.MaxNumber(short x, short y);
    public static override short Min(short x, short y);
    private static override short System.Numerics.INumber<System.Int16>.MinNumber(short x, short y);
    public static override int Sign(short value);
    private static override short System.Numerics.INumberBase<System.Int16>.get_One();
    private static override int System.Numerics.INumberBase<System.Int16>.get_Radix();
    private static override short System.Numerics.INumberBase<System.Int16>.get_Zero();
    public static override short Abs(short value);
    [NullableContextAttribute("1")]
public static override short CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override short CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override short CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsCanonical(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsComplexNumber(short value);
    public static override bool IsEvenInteger(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsFinite(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsImaginaryNumber(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsInfinity(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsInteger(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsNaN(short value);
    public static override bool IsNegative(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsNegativeInfinity(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsNormal(short value);
    public static override bool IsOddInteger(short value);
    public static override bool IsPositive(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsPositiveInfinity(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsRealNumber(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsSubnormal(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsZero(short value);
    public static override short MaxMagnitude(short x, short y);
    private static override short System.Numerics.INumberBase<System.Int16>.MaxMagnitudeNumber(short x, short y);
    public static override short MinMagnitude(short x, short y);
    private static override short System.Numerics.INumberBase<System.Int16>.MinMagnitudeNumber(short x, short y);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertFromChecked(TOther value, Int16& result);
    private static bool TryConvertFromChecked(TOther value, Int16& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertFromSaturating(TOther value, Int16& result);
    private static bool TryConvertFromSaturating(TOther value, Int16& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertFromTruncating(TOther value, Int16& result);
    private static bool TryConvertFromTruncating(TOther value, Int16& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertToChecked(short value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertToSaturating(short value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertToTruncating(short value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int16& result);
    private static override short System.Numerics.IShiftOperators<System.Int16,System.Int32,System.Int16>.op_LeftShift(short value, int shiftAmount);
    private static override short System.Numerics.IShiftOperators<System.Int16,System.Int32,System.Int16>.op_RightShift(short value, int shiftAmount);
    private static override short System.Numerics.IShiftOperators<System.Int16,System.Int32,System.Int16>.op_UnsignedRightShift(short value, int shiftAmount);
    private static override short System.Numerics.ISignedNumber<System.Int16>.get_NegativeOne();
    public static override short Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int16& result);
    private static override short System.Numerics.ISubtractionOperators<System.Int16,System.Int16,System.Int16>.op_Subtraction(short left, short right);
    private static override short System.Numerics.ISubtractionOperators<System.Int16,System.Int16,System.Int16>.op_CheckedSubtraction(short left, short right);
    private static override short System.Numerics.IUnaryNegationOperators<System.Int16,System.Int16>.op_UnaryNegation(short value);
    private static override short System.Numerics.IUnaryNegationOperators<System.Int16,System.Int16>.op_CheckedUnaryNegation(short value);
    private static override short System.Numerics.IUnaryPlusOperators<System.Int16,System.Int16>.op_UnaryPlus(short value);
    public static override short Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Int16& result);
    public static override short Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Int16& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int16>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int16>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int16>.get_MaxHexDigitCount();
    private static override short System.IBinaryIntegerParseAndFormatInfo<System.Int16>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.Int16>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int16>.IsGreaterThanAsUnsigned(short left, short right);
    private static override short System.IBinaryIntegerParseAndFormatInfo<System.Int16>.MultiplyBy10(short value);
    private static override short System.IBinaryIntegerParseAndFormatInfo<System.Int16>.MultiplyBy16(short value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int32 : ValueType {
    private int m_value;
    public static int MaxValue;
    public static int MinValue;
    private static int System.Numerics.IAdditiveIdentity<System.Int32,System.Int32>.AdditiveIdentity { get; }
    private static int System.Numerics.IBinaryNumber<System.Int32>.AllBitsSet { get; }
    private static int System.Numerics.IMinMaxValue<System.Int32>.MinValue { get; }
    private static int System.Numerics.IMinMaxValue<System.Int32>.MaxValue { get; }
    private static int System.Numerics.IMultiplicativeIdentity<System.Int32,System.Int32>.MultiplicativeIdentity { get; }
    private static int System.Numerics.INumberBase<System.Int32>.One { get; }
    private static int System.Numerics.INumberBase<System.Int32>.Radix { get; }
    private static int System.Numerics.INumberBase<System.Int32>.Zero { get; }
    private static int System.Numerics.ISignedNumber<System.Int32>.NegativeOne { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.Int32>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.MaxHexDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.Int32>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(int value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(int obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static int Parse(string s);
    [NullableContextAttribute("1")]
public static int Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override int Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override int Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Int32& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override int System.Numerics.IAdditionOperators<System.Int32,System.Int32,System.Int32>.op_Addition(int left, int right);
    private static override int System.Numerics.IAdditionOperators<System.Int32,System.Int32,System.Int32>.op_CheckedAddition(int left, int right);
    private static override int System.Numerics.IAdditiveIdentity<System.Int32,System.Int32>.get_AdditiveIdentity();
    public static override ValueTuple`2<int, int> DivRem(int left, int right);
    [IntrinsicAttribute]
public static override int LeadingZeroCount(int value);
    [IntrinsicAttribute]
public static override int PopCount(int value);
    [IntrinsicAttribute]
public static override int RotateLeft(int value, int rotateAmount);
    [IntrinsicAttribute]
public static override int RotateRight(int value, int rotateAmount);
    [IntrinsicAttribute]
public static override int TrailingZeroCount(int value);
    private static override bool System.Numerics.IBinaryInteger<System.Int32>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int32& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int32>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int32& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int32>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int32>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int32>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int32>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override int System.Numerics.IBinaryNumber<System.Int32>.get_AllBitsSet();
    public static override bool IsPow2(int value);
    [IntrinsicAttribute]
public static override int Log2(int value);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_BitwiseAnd(int left, int right);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_BitwiseOr(int left, int right);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_ExclusiveOr(int left, int right);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_OnesComplement(int value);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_LessThan(int left, int right);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_LessThanOrEqual(int left, int right);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_GreaterThan(int left, int right);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_GreaterThanOrEqual(int left, int right);
    private static override int System.Numerics.IDecrementOperators<System.Int32>.op_Decrement(int value);
    private static override int System.Numerics.IDecrementOperators<System.Int32>.op_CheckedDecrement(int value);
    private static override int System.Numerics.IDivisionOperators<System.Int32,System.Int32,System.Int32>.op_Division(int left, int right);
    private static override bool System.Numerics.IEqualityOperators<System.Int32,System.Int32,System.Boolean>.op_Equality(int left, int right);
    private static override bool System.Numerics.IEqualityOperators<System.Int32,System.Int32,System.Boolean>.op_Inequality(int left, int right);
    private static override int System.Numerics.IIncrementOperators<System.Int32>.op_Increment(int value);
    private static override int System.Numerics.IIncrementOperators<System.Int32>.op_CheckedIncrement(int value);
    private static override int System.Numerics.IMinMaxValue<System.Int32>.get_MinValue();
    private static override int System.Numerics.IMinMaxValue<System.Int32>.get_MaxValue();
    private static override int System.Numerics.IModulusOperators<System.Int32,System.Int32,System.Int32>.op_Modulus(int left, int right);
    private static override int System.Numerics.IMultiplicativeIdentity<System.Int32,System.Int32>.get_MultiplicativeIdentity();
    private static override int System.Numerics.IMultiplyOperators<System.Int32,System.Int32,System.Int32>.op_Multiply(int left, int right);
    private static override int System.Numerics.IMultiplyOperators<System.Int32,System.Int32,System.Int32>.op_CheckedMultiply(int left, int right);
    public static override int Clamp(int value, int min, int max);
    public static override int CopySign(int value, int sign);
    public static override int Max(int x, int y);
    private static override int System.Numerics.INumber<System.Int32>.MaxNumber(int x, int y);
    public static override int Min(int x, int y);
    private static override int System.Numerics.INumber<System.Int32>.MinNumber(int x, int y);
    public static override int Sign(int value);
    private static override int System.Numerics.INumberBase<System.Int32>.get_One();
    private static override int System.Numerics.INumberBase<System.Int32>.get_Radix();
    private static override int System.Numerics.INumberBase<System.Int32>.get_Zero();
    public static override int Abs(int value);
    [NullableContextAttribute("1")]
public static override int CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override int CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override int CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsCanonical(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsComplexNumber(int value);
    public static override bool IsEvenInteger(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsFinite(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsImaginaryNumber(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsInfinity(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsInteger(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsNaN(int value);
    public static override bool IsNegative(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsNegativeInfinity(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsNormal(int value);
    public static override bool IsOddInteger(int value);
    public static override bool IsPositive(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsPositiveInfinity(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsRealNumber(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsSubnormal(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsZero(int value);
    public static override int MaxMagnitude(int x, int y);
    private static override int System.Numerics.INumberBase<System.Int32>.MaxMagnitudeNumber(int x, int y);
    public static override int MinMagnitude(int x, int y);
    private static override int System.Numerics.INumberBase<System.Int32>.MinMagnitudeNumber(int x, int y);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertFromChecked(TOther value, Int32& result);
    private static bool TryConvertFromChecked(TOther value, Int32& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertFromSaturating(TOther value, Int32& result);
    private static bool TryConvertFromSaturating(TOther value, Int32& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertFromTruncating(TOther value, Int32& result);
    private static bool TryConvertFromTruncating(TOther value, Int32& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertToChecked(int value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertToSaturating(int value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertToTruncating(int value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int32& result);
    private static override int System.Numerics.IShiftOperators<System.Int32,System.Int32,System.Int32>.op_LeftShift(int value, int shiftAmount);
    private static override int System.Numerics.IShiftOperators<System.Int32,System.Int32,System.Int32>.op_RightShift(int value, int shiftAmount);
    private static override int System.Numerics.IShiftOperators<System.Int32,System.Int32,System.Int32>.op_UnsignedRightShift(int value, int shiftAmount);
    private static override int System.Numerics.ISignedNumber<System.Int32>.get_NegativeOne();
    public static override int Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int32& result);
    private static override int System.Numerics.ISubtractionOperators<System.Int32,System.Int32,System.Int32>.op_Subtraction(int left, int right);
    private static override int System.Numerics.ISubtractionOperators<System.Int32,System.Int32,System.Int32>.op_CheckedSubtraction(int left, int right);
    private static override int System.Numerics.IUnaryNegationOperators<System.Int32,System.Int32>.op_UnaryNegation(int value);
    private static override int System.Numerics.IUnaryNegationOperators<System.Int32,System.Int32>.op_CheckedUnaryNegation(int value);
    private static override int System.Numerics.IUnaryPlusOperators<System.Int32,System.Int32>.op_UnaryPlus(int value);
    public static override int Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Int32& result);
    public static override int Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Int32& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int32>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.get_MaxHexDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.Int32>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int32>.IsGreaterThanAsUnsigned(int left, int right);
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.MultiplyBy10(int value);
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int32>.MultiplyBy16(int value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Int64 : ValueType {
    private long m_value;
    public static long MaxValue;
    public static long MinValue;
    private static long System.Numerics.IAdditiveIdentity<System.Int64,System.Int64>.AdditiveIdentity { get; }
    private static long System.Numerics.IBinaryNumber<System.Int64>.AllBitsSet { get; }
    private static long System.Numerics.IMinMaxValue<System.Int64>.MinValue { get; }
    private static long System.Numerics.IMinMaxValue<System.Int64>.MaxValue { get; }
    private static long System.Numerics.IMultiplicativeIdentity<System.Int64,System.Int64>.MultiplicativeIdentity { get; }
    private static long System.Numerics.INumberBase<System.Int64>.One { get; }
    private static int System.Numerics.INumberBase<System.Int64>.Radix { get; }
    private static long System.Numerics.INumberBase<System.Int64>.Zero { get; }
    private static long System.Numerics.ISignedNumber<System.Int64>.NegativeOne { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.Int64>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int64>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.Int64>.MaxHexDigitCount { get; }
    private static long System.IBinaryIntegerParseAndFormatInfo<System.Int64>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.Int64>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(long value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(long obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static long Parse(string s);
    [NullableContextAttribute("1")]
public static long Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override long Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override long Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Int64& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override long System.Numerics.IAdditionOperators<System.Int64,System.Int64,System.Int64>.op_Addition(long left, long right);
    private static override long System.Numerics.IAdditionOperators<System.Int64,System.Int64,System.Int64>.op_CheckedAddition(long left, long right);
    private static override long System.Numerics.IAdditiveIdentity<System.Int64,System.Int64>.get_AdditiveIdentity();
    public static override ValueTuple`2<long, long> DivRem(long left, long right);
    [IntrinsicAttribute]
public static override long LeadingZeroCount(long value);
    [IntrinsicAttribute]
public static override long PopCount(long value);
    [IntrinsicAttribute]
public static override long RotateLeft(long value, int rotateAmount);
    [IntrinsicAttribute]
public static override long RotateRight(long value, int rotateAmount);
    [IntrinsicAttribute]
public static override long TrailingZeroCount(long value);
    private static override bool System.Numerics.IBinaryInteger<System.Int64>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int64& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int64>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int64& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int64>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int64>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int64>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int64>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override long System.Numerics.IBinaryNumber<System.Int64>.get_AllBitsSet();
    public static override bool IsPow2(long value);
    [IntrinsicAttribute]
public static override long Log2(long value);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_BitwiseAnd(long left, long right);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_BitwiseOr(long left, long right);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_ExclusiveOr(long left, long right);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_OnesComplement(long value);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_LessThan(long left, long right);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_LessThanOrEqual(long left, long right);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_GreaterThan(long left, long right);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_GreaterThanOrEqual(long left, long right);
    private static override long System.Numerics.IDecrementOperators<System.Int64>.op_Decrement(long value);
    private static override long System.Numerics.IDecrementOperators<System.Int64>.op_CheckedDecrement(long value);
    private static override long System.Numerics.IDivisionOperators<System.Int64,System.Int64,System.Int64>.op_Division(long left, long right);
    private static override bool System.Numerics.IEqualityOperators<System.Int64,System.Int64,System.Boolean>.op_Equality(long left, long right);
    private static override bool System.Numerics.IEqualityOperators<System.Int64,System.Int64,System.Boolean>.op_Inequality(long left, long right);
    private static override long System.Numerics.IIncrementOperators<System.Int64>.op_Increment(long value);
    private static override long System.Numerics.IIncrementOperators<System.Int64>.op_CheckedIncrement(long value);
    private static override long System.Numerics.IMinMaxValue<System.Int64>.get_MinValue();
    private static override long System.Numerics.IMinMaxValue<System.Int64>.get_MaxValue();
    private static override long System.Numerics.IModulusOperators<System.Int64,System.Int64,System.Int64>.op_Modulus(long left, long right);
    private static override long System.Numerics.IMultiplicativeIdentity<System.Int64,System.Int64>.get_MultiplicativeIdentity();
    private static override long System.Numerics.IMultiplyOperators<System.Int64,System.Int64,System.Int64>.op_Multiply(long left, long right);
    private static override long System.Numerics.IMultiplyOperators<System.Int64,System.Int64,System.Int64>.op_CheckedMultiply(long left, long right);
    public static override long Clamp(long value, long min, long max);
    public static override long CopySign(long value, long sign);
    public static override long Max(long x, long y);
    private static override long System.Numerics.INumber<System.Int64>.MaxNumber(long x, long y);
    public static override long Min(long x, long y);
    private static override long System.Numerics.INumber<System.Int64>.MinNumber(long x, long y);
    public static override int Sign(long value);
    private static override long System.Numerics.INumberBase<System.Int64>.get_One();
    private static override int System.Numerics.INumberBase<System.Int64>.get_Radix();
    private static override long System.Numerics.INumberBase<System.Int64>.get_Zero();
    public static override long Abs(long value);
    [NullableContextAttribute("1")]
public static override long CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override long CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override long CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsCanonical(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsComplexNumber(long value);
    public static override bool IsEvenInteger(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsFinite(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsImaginaryNumber(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsInfinity(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsInteger(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsNaN(long value);
    public static override bool IsNegative(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsNegativeInfinity(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsNormal(long value);
    public static override bool IsOddInteger(long value);
    public static override bool IsPositive(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsPositiveInfinity(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsRealNumber(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsSubnormal(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsZero(long value);
    public static override long MaxMagnitude(long x, long y);
    private static override long System.Numerics.INumberBase<System.Int64>.MaxMagnitudeNumber(long x, long y);
    public static override long MinMagnitude(long x, long y);
    private static override long System.Numerics.INumberBase<System.Int64>.MinMagnitudeNumber(long x, long y);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertFromChecked(TOther value, Int64& result);
    private static bool TryConvertFromChecked(TOther value, Int64& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertFromSaturating(TOther value, Int64& result);
    private static bool TryConvertFromSaturating(TOther value, Int64& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertFromTruncating(TOther value, Int64& result);
    private static bool TryConvertFromTruncating(TOther value, Int64& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertToChecked(long value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertToSaturating(long value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertToTruncating(long value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int64& result);
    private static override long System.Numerics.IShiftOperators<System.Int64,System.Int32,System.Int64>.op_LeftShift(long value, int shiftAmount);
    private static override long System.Numerics.IShiftOperators<System.Int64,System.Int32,System.Int64>.op_RightShift(long value, int shiftAmount);
    private static override long System.Numerics.IShiftOperators<System.Int64,System.Int32,System.Int64>.op_UnsignedRightShift(long value, int shiftAmount);
    private static override long System.Numerics.ISignedNumber<System.Int64>.get_NegativeOne();
    public static override long Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int64& result);
    private static override long System.Numerics.ISubtractionOperators<System.Int64,System.Int64,System.Int64>.op_Subtraction(long left, long right);
    private static override long System.Numerics.ISubtractionOperators<System.Int64,System.Int64,System.Int64>.op_CheckedSubtraction(long left, long right);
    private static override long System.Numerics.IUnaryNegationOperators<System.Int64,System.Int64>.op_UnaryNegation(long value);
    private static override long System.Numerics.IUnaryNegationOperators<System.Int64,System.Int64>.op_CheckedUnaryNegation(long value);
    private static override long System.Numerics.IUnaryPlusOperators<System.Int64,System.Int64>.op_UnaryPlus(long value);
    public static override long Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Int64& result);
    public static override long Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Int64& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int64>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int64>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.Int64>.get_MaxHexDigitCount();
    private static override long System.IBinaryIntegerParseAndFormatInfo<System.Int64>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.Int64>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.Int64>.IsGreaterThanAsUnsigned(long left, long right);
    private static override long System.IBinaryIntegerParseAndFormatInfo<System.Int64>.MultiplyBy10(long value);
    private static override long System.IBinaryIntegerParseAndFormatInfo<System.Int64>.MultiplyBy16(long value);
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IntPtr : ValueType {
    private IntPtr _value;
    [IntrinsicAttribute]
public static IntPtr Zero;
    public static int Size { get; }
    public static IntPtr MaxValue { get; }
    public static IntPtr MinValue { get; }
    private static IntPtr System.Numerics.IAdditiveIdentity<nint,nint>.AdditiveIdentity { get; }
    private static IntPtr System.Numerics.IBinaryNumber<nint>.AllBitsSet { get; }
    private static IntPtr System.Numerics.IMinMaxValue<nint>.MinValue { get; }
    private static IntPtr System.Numerics.IMinMaxValue<nint>.MaxValue { get; }
    private static IntPtr System.Numerics.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity { get; }
    private static IntPtr System.Numerics.INumberBase<nint>.One { get; }
    private static int System.Numerics.INumberBase<nint>.Radix { get; }
    private static IntPtr System.Numerics.INumberBase<nint>.Zero { get; }
    private static IntPtr System.Numerics.ISignedNumber<nint>.NegativeOne { get; }
    [NonVersionableAttribute]
public IntPtr(int value);
    [NonVersionableAttribute]
public IntPtr(long value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public IntPtr(Void* value);
    private IntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
public int ToInt32();
    [NonVersionableAttribute]
public long ToInt64();
    [NonVersionableAttribute]
public static IntPtr op_Explicit(int value);
    [NonVersionableAttribute]
public static IntPtr op_Explicit(long value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static IntPtr op_Explicit(Void* value);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static Void* op_Explicit(IntPtr value);
    [NonVersionableAttribute]
public static int op_Explicit(IntPtr value);
    [NonVersionableAttribute]
public static long op_Explicit(IntPtr value);
    [NonVersionableAttribute]
public static override bool op_Equality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static override bool op_Inequality(IntPtr value1, IntPtr value2);
    [NonVersionableAttribute]
public static IntPtr Add(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr op_Addition(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr Subtract(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    [NonVersionableAttribute]
public static int get_Size();
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public Void* ToPointer();
    [NonVersionableAttribute]
public static IntPtr get_MaxValue();
    [NonVersionableAttribute]
public static IntPtr get_MinValue();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(IntPtr value);
    [NonVersionableAttribute]
public sealed virtual bool Equals(IntPtr other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static IntPtr Parse(string s);
    [NullableContextAttribute("1")]
public static IntPtr Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override IntPtr Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override IntPtr Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override IntPtr Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override IntPtr Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, IntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, IntPtr& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IntPtr& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, IntPtr& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, IntPtr& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, IntPtr& result);
    private static override IntPtr System.Numerics.IAdditionOperators<nint,nint,nint>.op_Addition(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IAdditionOperators<nint,nint,nint>.op_CheckedAddition(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IAdditiveIdentity<nint,nint>.get_AdditiveIdentity();
    public static override ValueTuple`2<IntPtr, IntPtr> DivRem(IntPtr left, IntPtr right);
    [IntrinsicAttribute]
public static override IntPtr LeadingZeroCount(IntPtr value);
    [IntrinsicAttribute]
public static override IntPtr PopCount(IntPtr value);
    [IntrinsicAttribute]
public static override IntPtr RotateLeft(IntPtr value, int rotateAmount);
    [IntrinsicAttribute]
public static override IntPtr RotateRight(IntPtr value, int rotateAmount);
    [IntrinsicAttribute]
public static override IntPtr TrailingZeroCount(IntPtr value);
    private static override bool System.Numerics.IBinaryInteger<nint>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, IntPtr& value);
    private static override bool System.Numerics.IBinaryInteger<nint>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, IntPtr& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<nint>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<nint>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<nint>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<nint>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override IntPtr System.Numerics.IBinaryNumber<nint>.get_AllBitsSet();
    public static override bool IsPow2(IntPtr value);
    [IntrinsicAttribute]
public static override IntPtr Log2(IntPtr value);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_BitwiseAnd(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_BitwiseOr(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_ExclusiveOr(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_OnesComplement(IntPtr value);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_LessThan(IntPtr left, IntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_LessThanOrEqual(IntPtr left, IntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_GreaterThan(IntPtr left, IntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_GreaterThanOrEqual(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IDecrementOperators<nint>.op_Decrement(IntPtr value);
    private static override IntPtr System.Numerics.IDecrementOperators<nint>.op_CheckedDecrement(IntPtr value);
    private static override IntPtr System.Numerics.IDivisionOperators<nint,nint,nint>.op_Division(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IIncrementOperators<nint>.op_Increment(IntPtr value);
    private static override IntPtr System.Numerics.IIncrementOperators<nint>.op_CheckedIncrement(IntPtr value);
    private static override IntPtr System.Numerics.IMinMaxValue<nint>.get_MinValue();
    private static override IntPtr System.Numerics.IMinMaxValue<nint>.get_MaxValue();
    private static override IntPtr System.Numerics.IModulusOperators<nint,nint,nint>.op_Modulus(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IMultiplicativeIdentity<nint,nint>.get_MultiplicativeIdentity();
    private static override IntPtr System.Numerics.IMultiplyOperators<nint,nint,nint>.op_Multiply(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IMultiplyOperators<nint,nint,nint>.op_CheckedMultiply(IntPtr left, IntPtr right);
    public static override IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);
    public static override IntPtr CopySign(IntPtr value, IntPtr sign);
    public static override IntPtr Max(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.INumber<nint>.MaxNumber(IntPtr x, IntPtr y);
    public static override IntPtr Min(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.INumber<nint>.MinNumber(IntPtr x, IntPtr y);
    public static override int Sign(IntPtr value);
    private static override IntPtr System.Numerics.INumberBase<nint>.get_One();
    private static override int System.Numerics.INumberBase<nint>.get_Radix();
    private static override IntPtr System.Numerics.INumberBase<nint>.get_Zero();
    public static override IntPtr Abs(IntPtr value);
    [NullableContextAttribute("1")]
public static override IntPtr CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override IntPtr CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override IntPtr CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<nint>.IsCanonical(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsComplexNumber(IntPtr value);
    public static override bool IsEvenInteger(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsFinite(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsImaginaryNumber(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsInfinity(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsInteger(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsNaN(IntPtr value);
    public static override bool IsNegative(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsNegativeInfinity(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsNormal(IntPtr value);
    public static override bool IsOddInteger(IntPtr value);
    public static override bool IsPositive(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsPositiveInfinity(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsRealNumber(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsSubnormal(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsZero(IntPtr value);
    public static override IntPtr MaxMagnitude(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.INumberBase<nint>.MaxMagnitudeNumber(IntPtr x, IntPtr y);
    public static override IntPtr MinMagnitude(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.INumberBase<nint>.MinMagnitudeNumber(IntPtr x, IntPtr y);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertFromChecked(TOther value, IntPtr& result);
    private static bool TryConvertFromChecked(TOther value, IntPtr& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertFromSaturating(TOther value, IntPtr& result);
    private static bool TryConvertFromSaturating(TOther value, IntPtr& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertFromTruncating(TOther value, IntPtr& result);
    private static bool TryConvertFromTruncating(TOther value, IntPtr& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertToChecked(IntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertToSaturating(IntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertToTruncating(IntPtr value, TOther& result);
    private static override IntPtr System.Numerics.IShiftOperators<nint,System.Int32,nint>.op_LeftShift(IntPtr value, int shiftAmount);
    private static override IntPtr System.Numerics.IShiftOperators<nint,System.Int32,nint>.op_RightShift(IntPtr value, int shiftAmount);
    private static override IntPtr System.Numerics.IShiftOperators<nint,System.Int32,nint>.op_UnsignedRightShift(IntPtr value, int shiftAmount);
    private static override IntPtr System.Numerics.ISignedNumber<nint>.get_NegativeOne();
    private static override IntPtr System.Numerics.ISubtractionOperators<nint,nint,nint>.op_Subtraction(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.ISubtractionOperators<nint,nint,nint>.op_CheckedSubtraction(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IUnaryNegationOperators<nint,nint>.op_UnaryNegation(IntPtr value);
    private static override IntPtr System.Numerics.IUnaryNegationOperators<nint,nint>.op_CheckedUnaryNegation(IntPtr value);
    private static override IntPtr System.Numerics.IUnaryPlusOperators<nint,nint>.op_UnaryPlus(IntPtr value);
    public static override IntPtr Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, IntPtr& result);
    public static override IntPtr Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, IntPtr& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidCastException : SystemException {
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidCastException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidOperationException : SystemException {
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidOperationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private InvalidProgramException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.InvalidTimeZoneException : Exception {
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.BinaryReader : object {
    private Stream _stream;
    private Byte[] _buffer;
    private Decoder _decoder;
    private Byte[] _charBytes;
    private Char[] _charBuffer;
    private int _maxCharsSize;
    private bool _2BytesPerChar;
    private bool _isMemoryStream;
    private bool _leaveOpen;
    private bool _disposed;
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual void Close();
    private void ThrowIfDisposed();
    public virtual int PeekChar();
    public virtual int Read();
    public virtual byte ReadByte();
    private byte InternalReadByte();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual bool ReadBoolean();
    public virtual char ReadChar();
    public virtual short ReadInt16();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
    public virtual Half ReadHalf();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
    public virtual decimal ReadDecimal();
    public virtual string ReadString();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    private int InternalReadChars(Span`1<char> buffer);
    public virtual Char[] ReadChars(int count);
    public virtual int Read(Byte[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Byte[] ReadBytes(int count);
    private ReadOnlySpan`1<byte> InternalRead(int numBytes);
    protected virtual void FillBuffer(int numBytes);
    public int Read7BitEncodedInt();
    public long Read7BitEncodedInt64();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    private Encoding _encoding;
    private bool _leaveOpen;
    private bool _useFastUtf8;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    private static BinaryWriter();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual ValueTask DisposeAsync();
    public virtual Stream get_BaseStream();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(short value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(Half value);
    public virtual void Write(string value);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> chars);
    private void WriteCharsCommonWithoutLengthPrefix(ReadOnlySpan`1<char> chars, bool useThisWriteOverride);
    public void Write7BitEncodedInt(int value);
    public void Write7BitEncodedInt64(long value);
    [CompilerGeneratedAttribute]
private void <WriteCharsCommonWithoutLengthPrefix>g__WriteToOutStream|39_0(Byte[] buffer, int offset, int count, bool useThisWriteOverride);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.BufferedStream : Stream {
    private Stream _stream;
    private Byte[] _buffer;
    private int _bufferSize;
    private int _readPos;
    private int _readLen;
    private int _writePos;
    private CachedCompletedInt32Task _lastSyncCompletedReadTask;
    public Stream UnderlyingStream { get; }
    public int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    private void EnsureNotClosed();
    private void EnsureCanSeek();
    private void EnsureCanRead();
    private void EnsureCanWrite();
    private void EnsureShadowBufferAllocated();
    [MemberNotNullAttribute("_buffer")]
private void EnsureBufferAllocated();
    public Stream get_UnderlyingStream();
    public int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<DisposeAsync>d__33")]
public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushAsyncInternal>d__36")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    private void FlushRead();
    private void ClearReadBufferBeforeWrite();
    private void FlushWrite();
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<FlushWriteAsync>d__40")]
private ValueTask FlushWriteAsync(CancellationToken cancellationToken);
    private int ReadFromBuffer(Byte[] buffer, int offset, int count);
    private int ReadFromBuffer(Span`1<byte> destination);
    private int ReadFromBuffer(Byte[] buffer, int offset, int count, Exception& error);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> destination);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<ReadFromUnderlyingStreamAsync>d__48")]
private ValueTask`1<int> ReadFromUnderlyingStreamAsync(Memory`1<byte> buffer, CancellationToken cancellationToken, int bytesAlreadySatisfied, Task semaphoreLockTask);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int ReadByte();
    private int ReadByteSlow();
    private void WriteToBuffer(Byte[] buffer, Int32& offset, Int32& count);
    private int WriteToBuffer(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<WriteToUnderlyingStreamAsync>d__59")]
private ValueTask WriteToUnderlyingStreamAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken, Task semaphoreLockTask);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    private void WriteByteSlow(byte value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.BufferedStream/<CopyToAsyncCore>d__68")]
private Task CopyToAsyncCore(Stream destination, int bufferSize, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.IO.Directory : object {
    public static DirectoryInfo GetParent(string path);
    public static DirectoryInfo CreateDirectory(string path);
    [UnsupportedOSPlatformAttribute("windows")]
public static DirectoryInfo CreateDirectory(string path, UnixFileMode unixCreateMode);
    public static DirectoryInfo CreateTempSubdirectory(string prefix);
    private static void EnsureNoDirectorySeparators(string value, string paramName);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    internal static IEnumerable`1<string> InternalEnumeratePaths(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static string GetDirectoryRoot(string path);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static String[] GetLogicalDrives();
    public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);
    public static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget);
    private static DirectoryInfo CreateDirectoryCore(string path, UnixFileMode unixCreateMode);
    private static string CreateTempSubdirectoryCore(string prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.DirectoryInfo : FileSystemInfo {
    private bool _isNormalized;
    public string Name { get; }
    [NullableAttribute("2")]
public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public bool Exists { get; }
    public DirectoryInfo(string path);
    internal DirectoryInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    private void Init(string originalPath, string fullPath, string fileName, bool isNormalized);
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public DirectoryInfo get_Parent();
    public DirectoryInfo CreateSubdirectory(string path);
    public void Create();
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    private IEnumerable`1<FileSystemInfo> InternalEnumerateInfos(string path, string searchPattern, SearchTarget searchTarget, EnumerationOptions options);
    public DirectoryInfo get_Root();
    public void MoveTo(string destDirName);
    public virtual void Delete();
    public void Delete(bool recursive);
    public virtual bool get_Exists();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.DirectoryNotFoundException : IOException {
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.DriveInfoInternal : object {
    internal static String[] GetLogicalDrives();
}
internal static class System.IO.EncodingCache : object {
    internal static Encoding UTF8NoBOM;
    private static EncodingCache();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.EndOfStreamException : IOException {
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected EndOfStreamException(SerializationInfo info, StreamingContext context);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.IO.Enumeration.FileSystemEntry : ValueType {
    private DirectoryEntry _directoryEntry;
    private bool _isDirectory;
    private FileStatus _status;
    private Span`1<char> _pathBuffer;
    private ReadOnlySpan`1<char> _fullPath;
    private ReadOnlySpan`1<char> _fileName;
    private FileNameBuffer _fileNameBuffer;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <RootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<char> <OriginalRootDirectory>k__BackingField;
    private ReadOnlySpan`1<char> FullPath { get; }
    public ReadOnlySpan`1<char> FileName { get; }
    public ReadOnlySpan`1<char> Directory { get; private set; }
    public ReadOnlySpan`1<char> RootDirectory { get; private set; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; private set; }
    public FileAttributes Attributes { get; }
    public long Length { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public bool IsHidden { get; }
    internal bool IsReadOnly { get; }
    public bool IsDirectory { get; }
    internal bool IsSymbolicLink { get; }
    [NullableContextAttribute("1")]
public string ToSpecifiedFullPath();
    internal static FileAttributes Initialize(FileSystemEntry& entry, DirectoryEntry directoryEntry, ReadOnlySpan`1<char> directory, ReadOnlySpan`1<char> rootDirectory, ReadOnlySpan`1<char> originalRootDirectory, Span`1<char> pathBuffer);
    private ReadOnlySpan`1<char> get_FullPath();
    public ReadOnlySpan`1<char> get_FileName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_RootDirectory();
    [CompilerGeneratedAttribute]
private void set_RootDirectory(ReadOnlySpan`1<char> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    [CompilerGeneratedAttribute]
private void set_OriginalRootDirectory(ReadOnlySpan`1<char> value);
    public FileAttributes get_Attributes();
    public long get_Length();
    public DateTimeOffset get_CreationTimeUtc();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public bool get_IsHidden();
    internal bool get_IsReadOnly();
    public bool get_IsDirectory();
    internal bool get_IsSymbolicLink();
    [NullableContextAttribute("1")]
public FileSystemInfo ToFileSystemInfo();
    [NullableContextAttribute("1")]
public string ToFullPath();
}
public class System.IO.Enumeration.FileSystemEnumerable`1 : object {
    private DelegateEnumerator<TResult> _enumerator;
    private FindTransform<TResult> _transform;
    private EnumerationOptions _options;
    private string _directory;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldIncludePredicate>k__BackingField;
    [CompilerGeneratedAttribute]
private FindPredicate<TResult> <ShouldRecursePredicate>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    [NullableContextAttribute("1")]
public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    internal FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options, bool isNormalized);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldIncludePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    [CompilerGeneratedAttribute]
public FindPredicate<TResult> get_ShouldRecursePredicate();
    [CompilerGeneratedAttribute]
public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class System.IO.Enumeration.FileSystemEnumerableFactory : object {
    internal static bool NormalizeInputs(String& directory, String& expression, MatchType matchType);
    private static bool MatchesPattern(string expression, ReadOnlySpan`1<char> name, EnumerationOptions options);
    internal static IEnumerable`1<string> UserFiles(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserDirectories(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<string> UserEntries(string directory, string expression, EnumerationOptions options);
    internal static IEnumerable`1<FileInfo> FileInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
    internal static IEnumerable`1<DirectoryInfo> DirectoryInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
    internal static IEnumerable`1<FileSystemInfo> FileSystemInfos(string directory, string expression, EnumerationOptions options, bool isNormalized);
}
public abstract class System.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    private int _remainingRecursionDepth;
    private string _originalRootDirectory;
    private string _rootDirectory;
    private EnumerationOptions _options;
    private object _lock;
    private string _currentPath;
    private IntPtr _directoryHandle;
    private bool _lastEntryFound;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<ValueTuple`2<string, int>> _pending;
    private DirectoryEntry _entry;
    private TResult _current;
    private Char[] _pathBuffer;
    private Byte[] _entryBuffer;
    [NullableAttribute("1")]
public TResult Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    internal FileSystemEnumerator`1(string directory, bool isNormalized, EnumerationOptions options);
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    [NullableContextAttribute("1")]
protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    protected virtual bool ContinueOnError(int error);
    [NullableContextAttribute("1")]
public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private void DirectoryFinished();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void Init();
    private bool InternalContinueOnError(ErrorInfo info, bool ignoreNotFound);
    private static bool IsDirectoryNotFound(ErrorInfo info);
    private static bool IsAccessError(ErrorInfo info);
    private IntPtr CreateDirectoryHandle(string path, bool ignoreNotFound);
    private void CloseDirectoryHandle();
    public sealed virtual bool MoveNext();
    private void FindNextEntry();
    private void FindNextEntry(Byte* entryBufferPtr, int bufferLength);
    private bool DequeueNextDirectory();
    private void InternalDispose(bool disposing);
    [CompilerGeneratedAttribute]
private bool <MoveNext>g__ShouldSkip|36_0(FileAttributes attributeToSkip);
}
public static class System.IO.Enumeration.FileSystemName : object {
    [NullableContextAttribute("1")]
public static string TranslateWin32Expression(string expression);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    private static bool MatchPattern(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase, bool useExtendedWildcards);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.EnumerationOptions : object {
    private int _maxRecursionDepth;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Compatible>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <CompatibleRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnumerationOptions <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecurseSubdirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreInaccessible>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FileAttributes <AttributesToSkip>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchType <MatchType>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchCasing <MatchCasing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnSpecialDirectories>k__BackingField;
    internal static EnumerationOptions Compatible { get; }
    private static EnumerationOptions CompatibleRecursive { get; }
    internal static EnumerationOptions Default { get; }
    public bool RecurseSubdirectories { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public int BufferSize { get; public set; }
    public FileAttributes AttributesToSkip { get; public set; }
    public MatchType MatchType { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public int MaxRecursionDepth { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    private static EnumerationOptions();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Compatible();
    [CompilerGeneratedAttribute]
private static EnumerationOptions get_CompatibleRecursive();
    [CompilerGeneratedAttribute]
internal static EnumerationOptions get_Default();
    internal static EnumerationOptions FromSearchOption(SearchOption searchOption);
    [CompilerGeneratedAttribute]
public bool get_RecurseSubdirectories();
    [CompilerGeneratedAttribute]
public void set_RecurseSubdirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreInaccessible();
    [CompilerGeneratedAttribute]
public void set_IgnoreInaccessible(bool value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public FileAttributes get_AttributesToSkip();
    [CompilerGeneratedAttribute]
public void set_AttributesToSkip(FileAttributes value);
    [CompilerGeneratedAttribute]
public MatchType get_MatchType();
    [CompilerGeneratedAttribute]
public void set_MatchType(MatchType value);
    [CompilerGeneratedAttribute]
public MatchCasing get_MatchCasing();
    [CompilerGeneratedAttribute]
public void set_MatchCasing(MatchCasing value);
    public int get_MaxRecursionDepth();
    public void set_MaxRecursionDepth(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnSpecialDirectories();
    [CompilerGeneratedAttribute]
public void set_ReturnSpecialDirectories(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.IO.File : object {
    private static Encoding s_UTF8NoBOM;
    private static Encoding UTF8NoBOM { get; }
    private static Encoding get_UTF8NoBOM();
    public static StreamReader OpenText(string path);
    public static StreamWriter CreateText(string path);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static void Delete(string path);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    public static FileStream Open(string path, FileStreamOptions options);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    public static SafeFileHandle OpenHandle(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize);
    internal static DateTimeOffset GetUtcDateTimeOffset(DateTime dateTime);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTime(SafeFileHandle fileHandle, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static void SetCreationTimeUtc(SafeFileHandle fileHandle, DateTime creationTimeUtc);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTime(SafeFileHandle fileHandle);
    public static DateTime GetCreationTimeUtc(string path);
    public static DateTime GetCreationTimeUtc(SafeFileHandle fileHandle);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static void SetLastAccessTimeUtc(SafeFileHandle fileHandle, DateTime lastAccessTimeUtc);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTime(SafeFileHandle fileHandle);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static DateTime GetLastAccessTimeUtc(SafeFileHandle fileHandle);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    public static void SetLastWriteTimeUtc(SafeFileHandle fileHandle, DateTime lastWriteTimeUtc);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTime(SafeFileHandle fileHandle);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static DateTime GetLastWriteTimeUtc(SafeFileHandle fileHandle);
    public static FileAttributes GetAttributes(string path);
    public static FileAttributes GetAttributes(SafeFileHandle fileHandle);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes fileAttributes);
    [UnsupportedOSPlatformAttribute("windows")]
public static UnixFileMode GetUnixFileMode(string path);
    [UnsupportedOSPlatformAttribute("windows")]
public static UnixFileMode GetUnixFileMode(SafeFileHandle fileHandle);
    [UnsupportedOSPlatformAttribute("windows")]
public static void SetUnixFileMode(string path, UnixFileMode mode);
    [UnsupportedOSPlatformAttribute("windows")]
public static void SetUnixFileMode(SafeFileHandle fileHandle, UnixFileMode mode);
    public static FileStream OpenRead(string path);
    public static FileStream OpenWrite(string path);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Byte[] ReadAllBytes(string path);
    public static void WriteAllBytes(string path, Byte[] bytes);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static IAsyncEnumerable`1<string> ReadLinesAsync(string path, CancellationToken cancellationToken);
    public static IAsyncEnumerable`1<string> ReadLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    private static void InternalWriteAllLines(StreamWriter writer, IEnumerable`1<string> contents);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static void Move(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName, bool overwrite);
    [SupportedOSPlatformAttribute("windows")]
public static void Encrypt(string path);
    [SupportedOSPlatformAttribute("windows")]
public static void Decrypt(string path);
    private static StreamReader AsyncStreamReader(string path, Encoding encoding);
    private static StreamWriter AsyncStreamWriter(string path, Encoding encoding, bool append);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllTextAsync>d__86")]
private static Task`1<string> InternalReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesAsync>d__90")]
private static Task`1<Byte[]> InternalReadAllBytesAsync(SafeFileHandle sfh, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllBytesUnknownLengthAsync>d__91")]
private static Task`1<Byte[]> InternalReadAllBytesUnknownLengthAsync(SafeFileHandle sfh, CancellationToken cancellationToken);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalReadAllLinesAsync>d__95")]
private static Task`1<String[]> InternalReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.File/<InternalWriteAllLinesAsync>d__98")]
private static Task InternalWriteAllLinesAsync(StreamWriter writer, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);
    public static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget);
    private static void Validate(string path, Encoding encoding);
    private static Byte[] ReadAllBytesUnknownLength(SafeFileHandle sfh);
    private static void WriteToFile(string path, FileMode mode, string contents, Encoding encoding);
    [AsyncStateMachineAttribute("System.IO.File/<WriteToFileAsync>d__108")]
private static Task WriteToFileAsync(string path, FileMode mode, string contents, Encoding encoding, CancellationToken cancellationToken);
    private static long GetPreallocationSize(FileMode mode, string contents, Encoding encoding, int preambleSize);
    [AsyncIteratorStateMachineAttribute("System.IO.File/<IterateFileLinesAsync>d__110")]
private static IAsyncEnumerable`1<string> IterateFileLinesAsync(StreamReader sr, string path, Encoding encoding, CancellationToken ctEnumerable, CancellationToken ctEnumerator);
    private static UnixFileMode GetUnixFileModeCore(string path);
    private static UnixFileMode GetUnixFileModeCore(SafeFileHandle fileHandle);
    private static void SetUnixFileModeCore(string path, UnixFileMode mode);
    private static void SetUnixFileModeCore(SafeFileHandle fileHandle, UnixFileMode mode);
    [AsyncStateMachineAttribute("System.IO.File/<<WriteAllBytesAsync>g__Core|92_0>d")]
[CompilerGeneratedAttribute]
internal static Task <WriteAllBytesAsync>g__Core|92_0(string path, Byte[] bytes, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[FlagsAttribute]
public enum System.IO.FileAttributes : Enum {
    public int value__;
    public static FileAttributes None;
    public static FileAttributes ReadOnly;
    public static FileAttributes Hidden;
    public static FileAttributes System;
    public static FileAttributes Directory;
    public static FileAttributes Archive;
    public static FileAttributes Device;
    public static FileAttributes Normal;
    public static FileAttributes Temporary;
    public static FileAttributes SparseFile;
    public static FileAttributes ReparsePoint;
    public static FileAttributes Compressed;
    public static FileAttributes Offline;
    public static FileAttributes NotContentIndexed;
    public static FileAttributes Encrypted;
    public static FileAttributes IntegrityStream;
    public static FileAttributes NoScrubData;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.FileInfo : FileSystemInfo {
    public string Name { get; }
    public long Length { get; }
    [NullableAttribute("2")]
public string DirectoryName { get; }
    [NullableAttribute("2")]
public DirectoryInfo Directory { get; }
    public bool IsReadOnly { get; public set; }
    public bool Exists { get; }
    public FileInfo(string fileName);
    internal FileInfo(string originalPath, string fullPath, string fileName, bool isNormalized);
    public virtual string get_Name();
    public long get_Length();
    [NullableContextAttribute("2")]
public string get_DirectoryName();
    [NullableContextAttribute("2")]
public DirectoryInfo get_Directory();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public FileStream Open(FileStreamOptions options);
    public StreamReader OpenText();
    public StreamWriter CreateText();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public virtual void Delete();
    public virtual bool get_Exists();
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream OpenRead();
    public FileStream OpenWrite();
    public void MoveTo(string destFileName);
    public void MoveTo(string destFileName, bool overwrite);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    [SupportedOSPlatformAttribute("windows")]
public void Decrypt();
    [SupportedOSPlatformAttribute("windows")]
public void Encrypt();
    private StreamWriter CreateStreamWriter(bool append);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileLoadException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected FileLoadException(SerializationInfo info, StreamingContext context);
    internal static string FormatFileLoadExceptionMessage(string fileName, int hResult);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.FileNotFoundException : IOException {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FusionLog>k__BackingField;
    [NullableAttribute("1")]
public string Message { get; }
    public string FileName { get; }
    public string FusionLog { get; }
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    private void SetMessageField();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions None;
    public static FileOptions WriteThrough;
    public static FileOptions Asynchronous;
    public static FileOptions RandomAccess;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions Encrypted;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
internal class System.IO.FileStatus : ValueType {
    private int _state;
    private FileStatus _fileCache;
    private int _isReadOnlyCache;
    private bool EntryExists { get; }
    private bool IsDir { get; }
    private bool IsBrokenLink { get; }
    private bool HasHiddenFlag { get; }
    private bool HasReadOnlyFlag { get; }
    private bool HasSymbolicLinkFlag { get; }
    private bool get_EntryExists();
    private bool get_IsDir();
    private bool get_IsBrokenLink();
    private bool get_HasHiddenFlag();
    private bool get_HasReadOnlyFlag();
    private bool IsModeReadOnlyCore();
    private bool get_HasSymbolicLinkFlag();
    internal void InvalidateCaches();
    internal bool IsReadOnly(ReadOnlySpan`1<char> path, bool continueOnError);
    internal bool IsFileSystemEntryHidden(ReadOnlySpan`1<char> path, ReadOnlySpan`1<char> fileName);
    internal static bool IsNameHidden(ReadOnlySpan`1<char> fileName);
    internal bool IsDirectory(ReadOnlySpan`1<char> path, bool continueOnError);
    internal bool IsSymbolicLink(ReadOnlySpan`1<char> path, bool continueOnError);
    internal FileAttributes GetAttributes(ReadOnlySpan`1<char> path, ReadOnlySpan`1<char> fileName, bool continueOnError);
    internal FileAttributes GetAttributes(SafeFileHandle handle, bool continueOnError);
    private FileAttributes GetAttributes(SafeFileHandle handle, ReadOnlySpan`1<char> path, ReadOnlySpan`1<char> fileName, bool continueOnError);
    internal void SetAttributes(string path, FileAttributes attributes, bool asDirectory);
    internal void SetAttributes(SafeFileHandle handle, FileAttributes attributes, bool asDirectory);
    private void SetAttributes(SafeFileHandle handle, string path, FileAttributes attributes, bool asDirectory);
    internal bool GetExists(ReadOnlySpan`1<char> path, bool asDirectory);
    internal DateTimeOffset GetCreationTime(ReadOnlySpan`1<char> path, bool continueOnError);
    internal DateTimeOffset GetCreationTime(SafeFileHandle handle, bool continueOnError);
    private DateTimeOffset GetCreationTime(SafeFileHandle handle, ReadOnlySpan`1<char> path, bool continueOnError);
    internal DateTimeOffset GetLastAccessTime(ReadOnlySpan`1<char> path, bool continueOnError);
    internal DateTimeOffset GetLastAccessTime(SafeFileHandle handle, bool continueOnError);
    private DateTimeOffset GetLastAccessTime(SafeFileHandle handle, ReadOnlySpan`1<char> path, bool continueOnError);
    internal void SetLastAccessTime(string path, DateTimeOffset time, bool asDirectory);
    internal void SetLastAccessTime(SafeFileHandle handle, DateTimeOffset time, bool asDirectory);
    private void SetLastAccessTime(SafeFileHandle handle, string path, DateTimeOffset time, bool asDirectory);
    internal DateTimeOffset GetLastWriteTime(ReadOnlySpan`1<char> path, bool continueOnError);
    internal DateTimeOffset GetLastWriteTime(SafeFileHandle handle, bool continueOnError);
    private DateTimeOffset GetLastWriteTime(SafeFileHandle handle, ReadOnlySpan`1<char> path, bool continueOnError);
    internal void SetLastWriteTime(string path, DateTimeOffset time, bool asDirectory);
    internal void SetLastWriteTime(SafeFileHandle handle, DateTimeOffset time, bool asDirectory);
    internal void SetLastWriteTime(SafeFileHandle handle, string path, DateTimeOffset time, bool asDirectory);
    private static DateTimeOffset UnixTimeToDateTimeOffset(long seconds, long nanoseconds);
    private void SetAccessOrWriteTimeCore(SafeFileHandle handle, string path, DateTimeOffset time, bool isAccessTime, bool checkCreationTime, bool asDirectory);
    internal long GetLength(ReadOnlySpan`1<char> path, bool continueOnError);
    internal UnixFileMode GetUnixFileMode(ReadOnlySpan`1<char> path, bool continueOnError);
    internal UnixFileMode GetUnixFileMode(SafeFileHandle handle, bool continueOnError);
    private UnixFileMode GetUnixFileMode(SafeFileHandle handle, ReadOnlySpan`1<char> path, bool continueOnError);
    internal void SetUnixFileMode(string path, UnixFileMode mode);
    internal void SetUnixFileMode(SafeFileHandle handle, UnixFileMode mode);
    private void SetUnixFileMode(SafeFileHandle handle, string path, UnixFileMode mode);
    internal void RefreshCaches(ReadOnlySpan`1<char> path);
    internal void RefreshCaches(SafeFileHandle handle, ReadOnlySpan`1<char> path);
    internal void EnsureCachesInitialized(ReadOnlySpan`1<char> path, bool continueOnError);
    internal void EnsureCachesInitialized(SafeFileHandle handle, ReadOnlySpan`1<char> path, bool continueOnError);
    private void ThrowOnCacheInitializationError(ReadOnlySpan`1<char> path);
    private static long UnixTimeSecondsToNanoseconds(DateTimeOffset time, long seconds);
    private void ThrowNotFound(string path);
    internal void SetCreationTime(string path, DateTimeOffset time, bool asDirectory);
    internal void SetCreationTime(SafeFileHandle handle, DateTimeOffset time, bool asDirectory);
    private void SetAccessOrWriteTime(SafeFileHandle handle, string path, DateTimeOffset time, bool isAccessTime, bool asDirectory);
    private static Error SetCreationTimeCore(SafeFileHandle handle, string path, long seconds, long nanoseconds);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.FileStream : Stream {
    private FileStreamStrategy _strategy;
    [ObsoleteAttribute("FileStream.Handle has been deprecated. Use FileStream's SafeFileHandle property instead.")]
public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public SafeFileHandle SafeFileHandle { get; }
    public string Name { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanSeek { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access) instead.")]
public FileStream(IntPtr handle, FileAccess access);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access) and optionally make a new SafeFileHandle with ownsHandle=false if needed instead.")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) and optionally make a new SafeFileHandle with ownsHandle=false if needed instead.")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) and optionally make a new SafeFileHandle with ownsHandle=false if needed instead.")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public FileStream(string path, FileStreamOptions options);
    private FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, long preallocationSize);
    private static void ValidateHandle(SafeFileHandle handle, FileAccess access, int bufferSize);
    private static void ValidateHandle(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    protected virtual override void Finalize();
    public virtual IntPtr get_Handle();
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("macos")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("freebsd")]
public virtual void Lock(long position, long length);
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("macos")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("freebsd")]
public virtual void Unlock(long position, long length);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    private void ValidateReadWriteArgs(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual string get_Name();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
    [AsyncStateMachineAttribute("System.IO.FileStream/<DisposeAsync>d__57")]
public virtual ValueTask DisposeAsync();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual bool get_CanSeek();
    public virtual long Seek(long offset, SeekOrigin origin);
    internal Task BaseFlushAsync(CancellationToken cancellationToken);
    internal int BaseRead(Span`1<byte> buffer);
    internal Task`1<int> BaseReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    internal ValueTask`1<int> BaseReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    internal void BaseWrite(ReadOnlySpan`1<byte> buffer);
    internal Task BaseWriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    internal ValueTask BaseWriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    internal ValueTask BaseDisposeAsync();
    internal Task BaseCopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    internal IAsyncResult BaseBeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal int BaseEndRead(IAsyncResult asyncResult);
    internal IAsyncResult BaseBeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal void BaseEndWrite(IAsyncResult asyncResult);
}
public class System.IO.FileStreamOptions : object {
    private FileMode _mode;
    private FileAccess _access;
    private FileShare _share;
    private FileOptions _options;
    private long _preallocationSize;
    private int _bufferSize;
    private Nullable`1<UnixFileMode> _unixCreateMode;
    public FileMode Mode { get; public set; }
    public FileAccess Access { get; public set; }
    public FileShare Share { get; public set; }
    public FileOptions Options { get; public set; }
    public long PreallocationSize { get; public set; }
    public int BufferSize { get; public set; }
    public Nullable`1<UnixFileMode> UnixCreateMode { get; public set; }
    public FileMode get_Mode();
    public void set_Mode(FileMode value);
    public FileAccess get_Access();
    public void set_Access(FileAccess value);
    public FileShare get_Share();
    public void set_Share(FileShare value);
    public FileOptions get_Options();
    public void set_Options(FileOptions value);
    public long get_PreallocationSize();
    public void set_PreallocationSize(long value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public Nullable`1<UnixFileMode> get_UnixCreateMode();
    [UnsupportedOSPlatformAttribute("windows")]
public void set_UnixCreateMode(Nullable`1<UnixFileMode> value);
}
internal static class System.IO.FileSystem : object {
    internal static void VerifyValidPath(string path, string argName);
    internal static void MoveDirectory(string sourceFullPath, string destFullPath);
    public static void CopyFile(string sourceFullPath, string destFullPath, bool overwrite);
    private static Exception CreateOpenExceptionForCopyFile(ErrorInfo error, OpenFlags flags, string path);
    public static void Encrypt(string path);
    public static void Decrypt(string path);
    private static void LinkOrCopyFile(string sourceFullPath, string destFullPath);
    public static void ReplaceFile(string sourceFullPath, string destFullPath, string destBackupFullPath, bool ignoreMetadataErrors);
    public static void MoveFile(string sourceFullPath, string destFullPath, bool overwrite);
    public static void DeleteFile(string fullPath);
    public static void CreateDirectory(string fullPath);
    public static void CreateDirectory(string fullPath, UnixFileMode unixCreateMode);
    private static void CreateParentsAndDirectory(string fullPath, UnixFileMode unixCreateMode);
    private static void MoveDirectory(string sourceFullPath, string destFullPath, bool isCaseSensitiveRename);
    public static void RemoveDirectory(string fullPath, bool recursive);
    private static void RemoveDirectoryRecursive(string fullPath);
    private static bool RemoveEmptyDirectory(string fullPath, bool topLevel, bool throwWhenNotEmpty);
    public static FileAttributes GetAttributes(string fullPath);
    public static FileAttributes GetAttributes(SafeFileHandle fileHandle);
    public static void SetAttributes(string fullPath, FileAttributes attributes);
    public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes attributes);
    public static UnixFileMode GetUnixFileMode(string fullPath);
    public static UnixFileMode GetUnixFileMode(SafeFileHandle fileHandle);
    public static void SetUnixFileMode(string fullPath, UnixFileMode mode);
    public static void SetUnixFileMode(SafeFileHandle fileHandle, UnixFileMode mode);
    public static DateTimeOffset GetCreationTime(string fullPath);
    public static DateTimeOffset GetCreationTime(SafeFileHandle fileHandle);
    public static void SetCreationTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetCreationTime(SafeFileHandle fileHandle, DateTimeOffset time);
    public static DateTimeOffset GetLastAccessTime(string fullPath);
    public static DateTimeOffset GetLastAccessTime(SafeFileHandle fileHandle);
    public static void SetLastAccessTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTimeOffset time);
    public static DateTimeOffset GetLastWriteTime(string fullPath);
    public static DateTimeOffset GetLastWriteTime(SafeFileHandle fileHandle);
    public static void SetLastWriteTime(string fullPath, DateTimeOffset time, bool asDirectory);
    public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTimeOffset time);
    public static String[] GetLogicalDrives();
    internal static string GetLinkTarget(ReadOnlySpan`1<char> linkPath, bool isDirectory);
    internal static void CreateSymbolicLink(string path, string pathToTarget, bool isDirectory);
    internal static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget, bool isDirectory);
    public static bool DirectoryExists(ReadOnlySpan`1<char> fullPath);
    private static bool DirectoryExists(ReadOnlySpan`1<char> fullPath, ErrorInfo& errorInfo);
    public static bool FileExists(ReadOnlySpan`1<char> fullPath);
    private static bool FileExists(ReadOnlySpan`1<char> fullPath, ErrorInfo& errorInfo);
    [CompilerGeneratedAttribute]
internal static void <ResolveLinkTarget>g__GetLinkTargetFullPath|46_0(ValueStringBuilder& sb, ReadOnlySpan`1<char> linkTarget);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    protected string FullPath;
    protected string OriginalPath;
    internal string _name;
    private string _linkTarget;
    private bool _linkTargetIsValid;
    private bool _asDirectory;
    private FileStatus _fileStatus;
    public string FullName { get; }
    public string Extension { get; }
    public string Name { get; }
    public bool Exists { get; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public UnixFileMode UnixFileMode { get; public set; }
    public FileAttributes Attributes { get; public set; }
    internal bool ExistsCore { get; }
    internal DateTimeOffset CreationTimeCore { get; internal set; }
    internal DateTimeOffset LastAccessTimeCore { get; internal set; }
    internal DateTimeOffset LastWriteTimeCore { get; internal set; }
    internal long LengthCore { get; }
    internal UnixFileMode UnixFileModeCore { get; internal set; }
    internal string NormalizedPath { get; }
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    internal void Invalidate();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_FullName();
    public string get_Extension();
    public abstract virtual string get_Name();
    public abstract virtual bool get_Exists();
    public abstract virtual void Delete();
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    [NullableContextAttribute("2")]
public string get_LinkTarget();
    public UnixFileMode get_UnixFileMode();
    [UnsupportedOSPlatformAttribute("windows")]
public void set_UnixFileMode(UnixFileMode value);
    public void CreateAsSymbolicLink(string pathToTarget);
    [NullableContextAttribute("2")]
public FileSystemInfo ResolveLinkTarget(bool returnFinalTarget);
    public virtual string ToString();
    internal static FileSystemInfo Create(string fullPath, string fileName, bool asDirectory, FileStatus& fileStatus);
    internal void InvalidateCore();
    internal void Init(FileStatus& fileStatus);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal bool get_ExistsCore();
    internal DateTimeOffset get_CreationTimeCore();
    internal void set_CreationTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastAccessTimeCore();
    internal void set_LastAccessTimeCore(DateTimeOffset value);
    internal DateTimeOffset get_LastWriteTimeCore();
    internal void set_LastWriteTimeCore(DateTimeOffset value);
    internal long get_LengthCore();
    internal UnixFileMode get_UnixFileModeCore();
    internal void set_UnixFileModeCore(UnixFileMode value);
    public void Refresh();
    internal string get_NormalizedPath();
}
public enum System.IO.HandleInheritability : Enum {
    public int value__;
    public static HandleInheritability None;
    public static HandleInheritability Inheritable;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private InvalidDataException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.IOException : SystemException {
    public IOException(string message);
    public IOException(string message, int hresult);
    public IOException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected IOException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.IO.Iterator`1 : object {
    private int _threadId;
    internal int state;
    internal TSource current;
    public TSource Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual TSource get_Current();
    protected abstract virtual Iterator`1<TSource> Clone();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<TSource> GetEnumerator();
    public abstract virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public enum System.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing PlatformDefault;
    public static MatchCasing CaseSensitive;
    public static MatchCasing CaseInsensitive;
}
public enum System.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.MemoryStream : Stream {
    private Byte[] _buffer;
    private int _origin;
    private int _position;
    private int _length;
    private int _capacity;
    private bool _expandable;
    private bool _writable;
    private bool _exposable;
    private bool _isOpen;
    private CachedCompletedInt32Task _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(int capacity);
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    private void EnsureNotClosed();
    private void EnsureWriteable();
    protected virtual void Dispose(bool disposing);
    private bool EnsureCapacity(int value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    [NullableContextAttribute("0")]
public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    internal Byte[] InternalGetBuffer();
    internal int InternalGetPosition();
    internal ReadOnlySpan`1<byte> InternalReadSpan(int count);
    internal int InternalEmulateRead(int count);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
public static class System.IO.Path : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char VolumeSeparatorChar;
    public static char PathSeparator;
    [NullableAttribute("1")]
[ObsoleteAttribute("Path.InvalidPathChars has been deprecated. Use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    private static ReadOnlySpan`1<byte> Base32Char { get; }
    private static Path();
    [NullableContextAttribute("2")]
public static string ChangeExtension(string path, string extension);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    internal static int GetDirectoryNameOffset(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetExtension(string path);
    public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path);
    public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileNameWithoutExtension(string path);
    public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static string GetRandomFileName();
    [NullableContextAttribute("1")]
public static bool IsPathFullyQualified(string path);
    public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static bool HasExtension(string path);
    public static bool HasExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2, string path3);
    [NullableContextAttribute("1")]
public static string Combine(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("1")]
public static string Combine(String[] paths);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, ReadOnlySpan`1<char> path4);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3, string path4);
    [NullableContextAttribute("1")]
public static string Join(String[] paths);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
    public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    private static string CombineInternal(string first, string second);
    private static string CombineInternal(string first, string second, string third);
    private static string CombineInternal(string first, string second, string third, string fourth);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third);
    private static string JoinInternal(ReadOnlySpan`1<char> first, ReadOnlySpan`1<char> second, ReadOnlySpan`1<char> third, ReadOnlySpan`1<char> fourth);
    private static ReadOnlySpan`1<byte> get_Base32Char();
    internal static void Populate83FileNameFromRandomBytes(Byte* bytes, int byteCount, Span`1<char> chars);
    [NullableContextAttribute("1")]
public static string GetRelativePath(string relativeTo, string path);
    private static string GetRelativePath(string relativeTo, string path, StringComparison comparisonType);
    [NullableContextAttribute("1")]
public static string TrimEndingDirectorySeparator(string path);
    public static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    public static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static bool EndsInDirectorySeparator(string path);
    [NullableContextAttribute("1")]
public static Char[] GetInvalidFileNameChars();
    [NullableContextAttribute("1")]
public static Char[] GetInvalidPathChars();
    private static bool ExistsCore(string fullPath, Boolean& isDirectory);
    [NullableContextAttribute("1")]
public static string GetFullPath(string path);
    [NullableContextAttribute("1")]
public static string GetFullPath(string path, string basePath);
    private static string GetFullPathInternal(string path);
    [NullableContextAttribute("1")]
public static string GetTempPath();
    [NullableContextAttribute("1")]
public static string GetTempFileName();
    [NullableContextAttribute("2")]
public static bool IsPathRooted(string path);
    public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
}
internal static class System.IO.PathInternal : object {
    internal static bool StartsWithDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static string EnsureTrailingSeparator(string path);
    internal static bool IsRoot(ReadOnlySpan`1<char> path);
    internal static int GetCommonPathLength(string first, string second, bool ignoreCase);
    internal static int EqualStartingCharacterCount(string first, string second, bool ignoreCase);
    internal static bool AreRootsEqual(string first, string second, StringComparison comparisonType);
    internal static string RemoveRelativeSegments(string path, int rootLength);
    internal static bool RemoveRelativeSegments(ReadOnlySpan`1<char> path, int rootLength, ValueStringBuilder& sb);
    internal static string TrimEndingDirectorySeparator(string path);
    internal static bool EndsInDirectorySeparator(string path);
    internal static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    internal static int GetRootLength(ReadOnlySpan`1<char> path);
    internal static bool IsDirectorySeparator(char c);
    internal static string NormalizeDirectorySeparators(string path);
    internal static bool IsPartiallyQualified(ReadOnlySpan`1<char> path);
    internal static bool IsEffectivelyEmpty(string path);
    internal static bool IsEffectivelyEmpty(ReadOnlySpan`1<char> path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.IO.PathTooLongException : IOException {
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected PathTooLongException(SerializationInfo info, StreamingContext context);
}
internal static class System.IO.PersistedFiles : object {
    internal static string GetHomeDirectory();
    private static bool TryGetHomeDirectoryFromPasswd(Byte* buf, int bufLen, String& path);
}
internal class System.IO.PinnedBufferMemoryStream : UnmanagedMemoryStream {
    private Byte[] _array;
    private GCHandle _pinningHandle;
    internal PinnedBufferMemoryStream(Byte[] array);
    public virtual int Read(Span`1<byte> buffer);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
}
public static class System.IO.RandomAccess : object {
    [NullableContextAttribute("1")]
public static long GetLength(SafeFileHandle handle);
    [NullableContextAttribute("1")]
public static void SetLength(SafeFileHandle handle, long length);
    public static int Read(SafeFileHandle handle, Span`1<byte> buffer, long fileOffset);
    [NullableContextAttribute("1")]
public static long Read(SafeFileHandle handle, IReadOnlyList`1<Memory`1<byte>> buffers, long fileOffset);
    public static ValueTask`1<int> ReadAsync(SafeFileHandle handle, Memory`1<byte> buffer, long fileOffset, CancellationToken cancellationToken);
    public static ValueTask`1<long> ReadAsync(SafeFileHandle handle, IReadOnlyList`1<Memory`1<byte>> buffers, long fileOffset, CancellationToken cancellationToken);
    public static void Write(SafeFileHandle handle, ReadOnlySpan`1<byte> buffer, long fileOffset);
    [NullableContextAttribute("1")]
public static void Write(SafeFileHandle handle, IReadOnlyList`1<ReadOnlyMemory`1<byte>> buffers, long fileOffset);
    public static ValueTask WriteAsync(SafeFileHandle handle, ReadOnlyMemory`1<byte> buffer, long fileOffset, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static ValueTask WriteAsync(SafeFileHandle handle, IReadOnlyList`1<ReadOnlyMemory`1<byte>> buffers, long fileOffset, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static void FlushToDisk(SafeFileHandle handle);
    private static void ValidateInput(SafeFileHandle handle, long fileOffset, bool allowUnseekableHandles);
    private static void ValidateBuffers(IReadOnlyList`1<T> buffers);
    internal static void SetFileLength(SafeFileHandle handle, long length);
    internal static int ReadAtOffset(SafeFileHandle handle, Span`1<byte> buffer, long fileOffset);
    internal static long ReadScatterAtOffset(SafeFileHandle handle, IReadOnlyList`1<Memory`1<byte>> buffers, long fileOffset);
    internal static ValueTask`1<int> ReadAtOffsetAsync(SafeFileHandle handle, Memory`1<byte> buffer, long fileOffset, CancellationToken cancellationToken, OSFileStreamStrategy strategy);
    private static ValueTask`1<long> ReadScatterAtOffsetAsync(SafeFileHandle handle, IReadOnlyList`1<Memory`1<byte>> buffers, long fileOffset, CancellationToken cancellationToken);
    internal static void WriteAtOffset(SafeFileHandle handle, ReadOnlySpan`1<byte> buffer, long fileOffset);
    private static int GetNumberOfBytesToWrite(int byteCount);
    internal static void WriteGatherAtOffset(SafeFileHandle handle, IReadOnlyList`1<ReadOnlyMemory`1<byte>> buffers, long fileOffset);
    internal static ValueTask WriteAtOffsetAsync(SafeFileHandle handle, ReadOnlyMemory`1<byte> buffer, long fileOffset, CancellationToken cancellationToken, OSFileStreamStrategy strategy);
    private static ValueTask WriteGatherAtOffsetAsync(SafeFileHandle handle, IReadOnlyList`1<ReadOnlyMemory`1<byte>> buffers, long fileOffset, CancellationToken cancellationToken);
}
internal class System.IO.ReadLinesIterator : Iterator`1<string> {
    private string _path;
    private Encoding _encoding;
    private StreamReader _reader;
    private ReadLinesIterator(string path, Encoding encoding, StreamReader reader);
    public virtual bool MoveNext();
    protected virtual Iterator`1<string> Clone();
    protected virtual void Dispose(bool disposing);
    internal static ReadLinesIterator CreateIterator(string path, Encoding encoding);
    private static ReadLinesIterator CreateIterator(string path, Encoding encoding, StreamReader reader);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
internal enum System.IO.SearchTarget : Enum {
    public int value__;
    public static SearchTarget Files;
    public static SearchTarget Directories;
    public static SearchTarget Both;
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
internal class System.IO.Strategies.BufferedFileStreamStrategy : FileStreamStrategy {
    private FileStreamStrategy _strategy;
    private int _bufferSize;
    private Byte[] _buffer;
    private int _writePos;
    private int _readPos;
    private int _readLen;
    private CachedCompletedInt32Task _lastSyncCompletedReadTask;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool IsAsync { get; }
    internal bool IsClosed { get; }
    internal string Name { get; }
    internal SafeFileHandle SafeFileHandle { get; }
    internal BufferedFileStreamStrategy(FileStreamStrategy strategy, int bufferSize);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal virtual bool get_IsAsync();
    internal virtual bool get_IsClosed();
    internal virtual string get_Name();
    internal virtual SafeFileHandle get_SafeFileHandle();
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<DisposeAsync>d__27")]
public virtual ValueTask DisposeAsync();
    protected sealed virtual void Dispose(bool disposing);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> destination);
    private int ReadSpan(Span`1<byte> destination, ArraySegment`1<byte> arraySegment);
    public virtual int ReadByte();
    private int ReadByteSlow();
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<ReadFromNonSeekableAsync>d__36")]
private ValueTask`1<int> ReadFromNonSeekableAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<ReadAsyncSlowPath>d__37")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> ReadAsyncSlowPath(Task semaphoreLockTask, Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    private void WriteSpan(ReadOnlySpan`1<byte> source, ArraySegment`1<byte> arraySegment);
    public virtual void WriteByte(byte value);
    private void WriteByteSlow(byte value);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<WriteToNonSeekableAsync>d__47")]
private ValueTask WriteToNonSeekableAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<WriteAsyncSlowPath>d__48")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder")]
private ValueTask WriteAsyncSlowPath(Task semaphoreLockTask, ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void SetLength(long value);
    public virtual void Flush();
    internal virtual void Flush(bool flushToDisk);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<FlushAsyncInternal>d__55")]
private Task FlushAsyncInternal(CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Strategies.BufferedFileStreamStrategy/<CopyToAsyncCore>d__57")]
private Task CopyToAsyncCore(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual long Seek(long offset, SeekOrigin origin);
    internal virtual void Lock(long position, long length);
    internal virtual void Unlock(long position, long length);
    private void FlushRead();
    private void FlushWrite();
    private void ClearReadBufferBeforeWrite();
    private void EnsureNotClosed();
    private void EnsureCanRead();
    private void EnsureCanWrite();
    [MemberNotNullAttribute("_buffer")]
private void EnsureBufferAllocated();
    [MemberNotNullAttribute("_buffer")]
private void AllocateBuffer();
}
internal class System.IO.Strategies.DerivedFileStreamStrategy : FileStreamStrategy {
    private FileStreamStrategy _strategy;
    private FileStream _fileStream;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool IsAsync { get; }
    internal string Name { get; }
    internal SafeFileHandle SafeFileHandle { get; }
    internal bool IsClosed { get; }
    internal DerivedFileStreamStrategy(FileStream fileStream, FileStreamStrategy strategy);
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    internal virtual bool get_IsAsync();
    internal virtual string get_Name();
    internal virtual SafeFileHandle get_SafeFileHandle();
    internal virtual bool get_IsClosed();
    internal virtual void Lock(long position, long length);
    internal virtual void Unlock(long position, long length);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int ReadByte();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void Flush();
    internal virtual void Flush(bool flushToDisk);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual ValueTask DisposeAsync();
    protected sealed virtual void Dispose(bool disposing);
}
internal static class System.IO.Strategies.FileStreamHelpers : object {
    private static int s_cachedSerializationSwitch;
    internal static FileStreamStrategy ChooseStrategy(FileStream fileStream, SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    internal static FileStreamStrategy ChooseStrategy(FileStream fileStream, string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, long preallocationSize, Nullable`1<UnixFileMode> unixCreateMode);
    private static FileStreamStrategy EnableBufferingIfNeeded(FileStreamStrategy strategy, int bufferSize);
    private static FileStreamStrategy WrapIfDerivedType(FileStream fileStream, FileStreamStrategy strategy);
    internal static bool IsIoRelatedException(Exception e);
    internal static void ValidateArguments(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options, long preallocationSize);
    internal static void ValidateArgumentsForPreallocation(FileMode mode, FileAccess access);
    internal static void SerializationGuard(FileAccess access);
    private static UnixFileStreamStrategy ChooseStrategyCore(SafeFileHandle handle, FileAccess access, bool isAsync);
    private static UnixFileStreamStrategy ChooseStrategyCore(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize, Nullable`1<UnixFileMode> unixCreateMode);
    internal static long CheckFileCall(long result, string path, bool ignoreNotSupported);
    internal static long Seek(SafeFileHandle handle, long offset, SeekOrigin origin);
    internal static void ThrowInvalidArgument(SafeFileHandle handle);
    internal static void FlushToDisk(SafeFileHandle handle);
    internal static void Lock(SafeFileHandle handle, bool canWrite, long position, long length);
    internal static void Unlock(SafeFileHandle handle, long position, long length);
}
internal abstract class System.IO.Strategies.FileStreamStrategy : Stream {
    [CompilerGeneratedAttribute]
private bool <IsDerived>k__BackingField;
    internal bool IsAsync { get; }
    internal bool IsDerived { get; internal set; }
    internal string Name { get; }
    internal SafeFileHandle SafeFileHandle { get; }
    internal IntPtr Handle { get; }
    internal bool IsClosed { get; }
    internal abstract virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
internal bool get_IsDerived();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsDerived(bool value);
    internal abstract virtual string get_Name();
    internal abstract virtual SafeFileHandle get_SafeFileHandle();
    internal IntPtr get_Handle();
    internal abstract virtual bool get_IsClosed();
    internal abstract virtual void Lock(long position, long length);
    internal abstract virtual void Unlock(long position, long length);
    internal abstract virtual void Flush(bool flushToDisk);
    internal void DisposeInternal(bool disposing);
}
internal abstract class System.IO.Strategies.OSFileStreamStrategy : FileStreamStrategy {
    protected SafeFileHandle _fileHandle;
    private FileAccess _access;
    protected long _filePosition;
    private long _appendStart;
    internal bool IsAsync { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal string Name { get; }
    internal bool IsClosed { get; }
    internal SafeFileHandle SafeFileHandle { get; }
    internal OSFileStreamStrategy(SafeFileHandle handle, FileAccess access);
    internal OSFileStreamStrategy(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize, Nullable`1<UnixFileMode> unixCreateMode);
    internal virtual bool get_IsAsync();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual long get_Length();
    internal void OnIncompleteOperation(int expectedBytesTransferred, int actualBytesTransferred);
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    internal sealed virtual string get_Name();
    internal sealed virtual bool get_IsClosed();
    internal sealed virtual SafeFileHandle get_SafeFileHandle();
    public sealed virtual ValueTask DisposeAsync();
    protected sealed virtual void Dispose(bool disposing);
    public sealed virtual void Flush();
    public sealed virtual Task FlushAsync(CancellationToken cancellationToken);
    internal sealed virtual void Flush(bool flushToDisk);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    internal sealed virtual void Lock(long position, long length);
    internal sealed virtual void Unlock(long position, long length);
    public sealed virtual void SetLength(long value);
    protected void SetLengthCore(long value);
    public sealed virtual int ReadByte();
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual int Read(Span`1<byte> buffer);
    public sealed virtual void WriteByte(byte value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public sealed virtual void Write(ReadOnlySpan`1<byte> buffer);
    public sealed virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public sealed virtual void EndWrite(IAsyncResult asyncResult);
    public sealed virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public sealed virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> source, CancellationToken cancellationToken);
    public sealed virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public sealed virtual int EndRead(IAsyncResult asyncResult);
    public sealed virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<int> ReadAsync(Memory`1<byte> destination, CancellationToken cancellationToken);
}
internal class System.IO.Strategies.UnixFileStreamStrategy : OSFileStreamStrategy {
    internal UnixFileStreamStrategy(SafeFileHandle handle, FileAccess access);
    internal UnixFileStreamStrategy(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize, Nullable`1<UnixFileMode> unixCreateMode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    private protected SemaphoreSlim _asyncActiveSemaphore;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    private static Stream();
    [MemberNotNullAttribute("_asyncActiveSemaphore")]
private protected SemaphoreSlim EnsureAsyncActiveSemaphoreInitialized();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    private int GetCopyBufferSize();
    public sealed virtual void Dispose();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle has been deprecated. Use the ManualResetEvent(false) constructor instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal Task`1<int> BeginReadInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    public virtual int EndRead(IAsyncResult asyncResult);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask ReadExactlyAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public ValueTask ReadExactlyAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask`1<int> ReadAtLeastAsync(Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<ReadAtLeastAsyncCore>d__46")]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1")]
private ValueTask`1<int> ReadAtLeastAsyncCore(Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    [IntrinsicAttribute]
private bool HasOverriddenBeginEndRead();
    [IntrinsicAttribute]
private bool HasOverriddenBeginEndWrite();
    private Task`1<int> BeginEndReadAsync(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    internal Task BeginWriteInternal(Byte[] buffer, int offset, int count, AsyncCallback callback, object state, bool serializeAsynchronously, bool apm);
    private static void RunReadWriteTaskWhenReady(Task asyncWaiter, ReadWriteTask readWriteTask);
    private static void RunReadWriteTask(ReadWriteTask readWriteTask);
    private void FinishTrackingAsyncOperation(ReadWriteTask task);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<FinishWriteAsync>d__61")]
private static Task FinishWriteAsync(Task writeTask, Byte[] localBuffer);
    private Task BeginEndWriteAsync(Byte[] buffer, int offset, int count);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    [NullableContextAttribute("0")]
public void ReadExactly(Span`1<byte> buffer);
    public void ReadExactly(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public int ReadAtLeast(Span`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream);
    private int ReadAtLeastCore(Span`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream);
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public static Stream Synchronized(Stream stream);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    protected static void ValidateBufferArguments(Byte[] buffer, int offset, int count);
    private static void ValidateReadAtLeastArguments(int bufferLength, int minimumBytes);
    protected static void ValidateCopyToArguments(Stream destination, int bufferSize);
    [AsyncStateMachineAttribute("System.IO.Stream/<<CopyToAsync>g__Core|27_0>d")]
[CompilerGeneratedAttribute]
internal static Task <CopyToAsync>g__Core|27_0(Stream source, Stream destination, int bufferSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.Stream/<<ReadAsync>g__FinishReadAsync|42_0>d")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<int> <ReadAsync>g__FinishReadAsync|42_0(Task`1<int> readTask, Byte[] localBuffer, Memory`1<byte> localDestination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    private Stream _stream;
    private Encoding _encoding;
    private Decoder _decoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private int _byteLen;
    private int _bytePos;
    private int _maxCharsPerBuffer;
    private bool _disposed;
    private bool _detectEncoding;
    private bool _checkPreamble;
    private bool _isBlocked;
    private bool _closable;
    private Task _asyncReadTask;
    public Encoding CurrentEncoding { get; }
    public Stream BaseStream { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(string path, FileStreamOptions options);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, FileStreamOptions options);
    private static StreamReader();
    private void CheckAsyncTaskInProgress();
    [DoesNotReturnAttribute]
private static void ThrowAsyncIOInProgress();
    private static FileStream ValidateArgsAndOpenPath(string path, Encoding encoding, FileStreamOptions options);
    private static FileStream ValidateArgsAndOpenPath(string path, Encoding encoding, int bufferSize);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_CurrentEncoding();
    public virtual Stream get_BaseStream();
    public void DiscardBufferedData();
    public bool get_EndOfStream();
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    private int ReadSpan(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    private void CompressBuffer(int n);
    private void DetectEncoding();
    private bool IsPreamble();
    internal virtual int ReadBuffer();
    private int ReadBuffer(Span`1<char> userBuffer, Boolean& readToUserBuffer);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual ValueTask`1<string> ReadLineAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadLineAsyncInternal>d__63")]
private Task`1<string> ReadLineAsyncInternal(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<string> ReadToEndAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadToEndAsyncInternal>d__66")]
private Task`1<string> ReadToEndAsyncInternal(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadAsyncInternal>d__69")]
internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamReader/<ReadBufferAsync>d__72")]
private ValueTask`1<int> ReadBufferAsync(CancellationToken cancellationToken);
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private bool <IsPreamble>g__IsPreambleWorker|57_0();
    [CompilerGeneratedAttribute]
private void <ThrowIfDisposed>g__ThrowObjectDisposedException|73_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StreamWriter : TextWriter {
    public static StreamWriter Null;
    private Stream _stream;
    private Encoding _encoding;
    private Encoder _encoder;
    private Byte[] _byteBuffer;
    private Char[] _charBuffer;
    private int _charPos;
    private int _charLen;
    private bool _autoFlush;
    private bool _haveWrittenPreamble;
    private bool _closable;
    private bool _disposed;
    private Task _asyncWriteTask;
    private static Encoding UTF8NoBOM { get; }
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    public Encoding Encoding { get; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    public StreamWriter(string path, FileStreamOptions options);
    public StreamWriter(string path, Encoding encoding, FileStreamOptions options);
    private static StreamWriter();
    private void CheckAsyncTaskInProgress();
    [DoesNotReturnAttribute]
private static void ThrowAsyncIOInProgress();
    private static Encoding get_UTF8NoBOM();
    private static FileStream ValidateArgsAndOpenPath(string path, Encoding encoding, FileStreamOptions options);
    private static FileStream ValidateArgsAndOpenPath(string path, bool append, Encoding encoding, int bufferSize);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    private void CloseStreamFromDispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<DisposeAsyncCore>d__36")]
private ValueTask DisposeAsyncCore();
    public virtual void Flush();
    private void Flush(bool flushStream, bool flushEncoder);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_Encoding();
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    private void WriteSpan(ReadOnlySpan`1<char> buffer, bool appendNewLine);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    private void WriteFormatHelper(string format, ReadOnlySpan`1<object> args, bool appendNewLine);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__64")]
private Task WriteAsyncInternal(char value, bool appendNewLine);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<WriteAsyncInternal>d__68")]
private Task WriteAsyncInternal(ReadOnlyMemory`1<char> source, bool appendNewLine, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    private Task FlushAsyncInternal(bool flushStream, bool flushEncoder, CancellationToken cancellationToken);
    private void ThrowIfDisposed();
    [AsyncStateMachineAttribute("System.IO.StreamWriter/<<FlushAsyncInternal>g__Core|76_0>d")]
[CompilerGeneratedAttribute]
private Task <FlushAsyncInternal>g__Core|76_0(bool flushStream, bool flushEncoder, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <ThrowIfDisposed>g__ThrowObjectDisposedException|77_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StringReader : TextReader {
    private string _s;
    private int _pos;
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    public virtual string ReadToEnd();
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual ValueTask`1<string> ReadLineAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<string> ReadToEndAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [DoesNotReturnAttribute]
private static void ThrowObjectDisposedException_ReaderClosed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StringWriter : TextWriter {
    private static UnicodeEncoding modreq(System.Runtime.CompilerServices.IsVolatile) s_encoding;
    private StringBuilder _sb;
    private bool _isOpen;
    public Encoding Encoding { get; }
    [NullableContextAttribute("2")]
public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Encoding get_Encoding();
    public virtual StringBuilder GetStringBuilder();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public virtual void Write(StringBuilder value);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual void WriteLine(StringBuilder value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task FlushAsync();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    private static TextReader();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    public virtual string ReadToEnd();
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual ValueTask`1<string> ReadLineAsync(CancellationToken cancellationToken);
    private Task`1<string> ReadLineCoreAsync(CancellationToken cancellationToken);
    public virtual Task`1<string> ReadToEndAsync();
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadToEndAsync>d__17")]
public virtual Task`1<string> ReadToEndAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    internal virtual ValueTask`1<int> ReadAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.IO.TextReader/<ReadBlockAsyncInternal>d__23")]
internal ValueTask`1<int> ReadBlockAsyncInternal(Memory`1<char> buffer, CancellationToken cancellationToken);
    public static TextReader Synchronized(TextReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.TextWriter : MarshalByRefObject {
    public static TextWriter Null;
    private static Char[] s_coreNewLine;
    protected Char[] CoreNewLine;
    private string CoreNewLineStr;
    private IFormatProvider _internalFormatProvider;
    public IFormatProvider FormatProvider { get; }
    public Encoding Encoding { get; }
    public string NewLine { get; public set; }
    [NullableContextAttribute("2")]
protected TextWriter(IFormatProvider formatProvider);
    private static TextWriter();
    public virtual IFormatProvider get_FormatProvider();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public abstract virtual Encoding get_Encoding();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public virtual void Write(object value);
    [NullableContextAttribute("2")]
public virtual void Write(StringBuilder value);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(StringBuilder value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync();
    public virtual Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public static TextWriter Synchronized(TextWriter writer);
    [AsyncStateMachineAttribute("System.IO.TextWriter/<<WriteAsync>g__WriteAsyncCore|60_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteAsync>g__WriteAsyncCore|60_0(StringBuilder sb, CancellationToken ct);
    [AsyncStateMachineAttribute("System.IO.TextWriter/<<WriteLineAsync>g__WriteLineAsyncCore|66_0>d")]
[CompilerGeneratedAttribute]
private Task <WriteLineAsync>g__WriteLineAsyncCore|66_0(StringBuilder sb, CancellationToken ct);
}
[FlagsAttribute]
public enum System.IO.UnixFileMode : Enum {
    public int value__;
    public static UnixFileMode None;
    public static UnixFileMode OtherExecute;
    public static UnixFileMode OtherWrite;
    public static UnixFileMode OtherRead;
    public static UnixFileMode GroupExecute;
    public static UnixFileMode GroupWrite;
    public static UnixFileMode GroupRead;
    public static UnixFileMode UserExecute;
    public static UnixFileMode UserWrite;
    public static UnixFileMode UserRead;
    public static UnixFileMode StickyBit;
    public static UnixFileMode SetGroup;
    public static UnixFileMode SetUser;
}
public class System.IO.UnmanagedMemoryAccessor : object {
    private SafeBuffer _buffer;
    private long _offset;
    private long _capacity;
    private FileAccess _access;
    private bool _isOpen;
    private bool _canRead;
    private bool _canWrite;
    public long Capacity { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    protected bool IsOpen { get; }
    [NullableContextAttribute("1")]
public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity);
    [NullableContextAttribute("1")]
public UnmanagedMemoryAccessor(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    [NullableContextAttribute("1")]
protected void Initialize(SafeBuffer buffer, long offset, long capacity, FileAccess access);
    public long get_Capacity();
    public bool get_CanRead();
    public bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected bool get_IsOpen();
    public bool ReadBoolean(long position);
    public byte ReadByte(long position);
    public char ReadChar(long position);
    public short ReadInt16(long position);
    public int ReadInt32(long position);
    public long ReadInt64(long position);
    public decimal ReadDecimal(long position);
    public float ReadSingle(long position);
    public double ReadDouble(long position);
    [CLSCompliantAttribute("False")]
public sbyte ReadSByte(long position);
    [CLSCompliantAttribute("False")]
public ushort ReadUInt16(long position);
    [CLSCompliantAttribute("False")]
public UInt32 ReadUInt32(long position);
    [CLSCompliantAttribute("False")]
public ulong ReadUInt64(long position);
    public void Read(long position, T& structure);
    public int ReadArray(long position, T[] array, int offset, int count);
    public void Write(long position, bool value);
    public void Write(long position, byte value);
    public void Write(long position, char value);
    public void Write(long position, short value);
    public void Write(long position, int value);
    public void Write(long position, long value);
    public void Write(long position, decimal value);
    public void Write(long position, float value);
    public void Write(long position, double value);
    [CLSCompliantAttribute("False")]
public void Write(long position, sbyte value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ushort value);
    [CLSCompliantAttribute("False")]
public void Write(long position, UInt32 value);
    [CLSCompliantAttribute("False")]
public void Write(long position, ulong value);
    public void Write(long position, T& structure);
    public void WriteArray(long position, T[] array, int offset, int count);
    private void EnsureSafeToRead(long position, int sizeOfType);
    private void EnsureSafeToWrite(long position, int sizeOfType);
}
public class System.IO.UnmanagedMemoryStream : Stream {
    private SafeBuffer _buffer;
    private Byte* _mem;
    private UIntPtr _capacity;
    private UIntPtr _offset;
    private UIntPtr _length;
    private long _position;
    private FileAccess _access;
    private bool _isOpen;
    private CachedCompletedInt32Task _lastReadTask;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Capacity { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    [NullableContextAttribute("1")]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    [NullableContextAttribute("1")]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    [NullableContextAttribute("1")]
protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    private void EnsureNotClosed();
    private void EnsureReadable();
    private void EnsureWriteable();
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public long get_Capacity();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    internal int ReadCore(Span`1<byte> buffer);
    [NullableContextAttribute("1")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    internal void WriteCore(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("1")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
internal class System.IO.UnmanagedMemoryStreamWrapper : MemoryStream {
    private UnmanagedMemoryStream _unmanagedStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    internal UnmanagedMemoryStreamWrapper(UnmanagedMemoryStream stream);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual Byte[] GetBuffer();
    public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual Byte[] ToArray();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
    public virtual void SetLength(long value);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
public interface System.IObserver`1 {
    public abstract virtual void OnNext(T value);
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnCompleted();
}
public interface System.IParsable`1 {
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static abstract virtual bool TryParse(string s, IFormatProvider provider, TSelf& result);
}
[NullableContextAttribute("1")]
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
public interface System.ISpanFormattable {
    public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
public interface System.ISpanParsable`1 {
    public static abstract virtual TSelf Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static abstract virtual bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, TSelf& result);
}
internal interface System.ITupleInternal {
    public abstract virtual string ToString(StringBuilder sb);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
internal interface System.ITypeIdentifier {
    public string InternalName { get; }
    public abstract virtual string get_InternalName();
}
internal interface System.ITypeName {
    public string DisplayName { get; }
    public abstract virtual string get_DisplayName();
    public abstract virtual ITypeName NestedName(ITypeIdentifier innerName);
}
public interface System.IUtf8SpanFormattable {
    public abstract virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
public interface System.IUtf8SpanParsable`1 {
    public static abstract virtual TSelf Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static abstract virtual bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, TSelf& result);
}
internal interface System.IUtfChar`1 {
    public static abstract virtual TSelf CastFrom(byte value);
    public static abstract virtual TSelf CastFrom(char value);
    public static abstract virtual TSelf CastFrom(int value);
    public static abstract virtual TSelf CastFrom(UInt32 value);
    public static abstract virtual TSelf CastFrom(ulong value);
    public static abstract virtual UInt32 CastToUInt32(TSelf value);
}
internal interface System.IValueTupleInternal {
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
    public abstract virtual string ToStringEnd();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.LazyDebugView`1")]
[DebuggerDisplayAttribute("ThreadSafetyMode = {Mode}, IsValueCreated = {IsValueCreated}, IsValueFaulted = {IsValueFaulted}, Value = {ValueForDebugDisplay}")]
public class System.Lazy`1 : object {
    private LazyHelper modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Func`1<T> _factory;
    private T _value;
    [NullableAttribute("2")]
internal T ValueForDebugDisplay { get; }
    internal Nullable`1<LazyThreadSafetyMode> Mode { get; }
    internal bool IsValueFaulted { get; }
    public bool IsValueCreated { get; }
    [DebuggerBrowsableAttribute("0")]
public T Value { get; }
    public Lazy`1(T value);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    private Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode, bool useDefaultConstructor);
    private static T CreateViaDefaultConstructor();
    private void ViaConstructor();
    private void ViaFactory(LazyThreadSafetyMode mode);
    private void ExecutionAndPublication(LazyHelper executionAndPublication, bool useDefaultConstructor);
    private void PublicationOnly(LazyHelper publicationOnly, T possibleValue);
    private void PublicationOnlyViaConstructor(LazyHelper initializer);
    private void PublicationOnlyViaFactory(LazyHelper initializer);
    private void PublicationOnlyWaitForOtherThreadToPublish();
    private T CreateValue();
    [NullableContextAttribute("2")]
public virtual string ToString();
    internal T get_ValueForDebugDisplay();
    internal Nullable`1<LazyThreadSafetyMode> get_Mode();
    internal bool get_IsValueFaulted();
    public bool get_IsValueCreated();
    public T get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Lazy`2 : Lazy`1<T> {
    private TMetadata _metadata;
    public TMetadata Metadata { get; }
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata);
    public Lazy`2(TMetadata metadata);
    public Lazy`2(TMetadata metadata, bool isThreadSafe);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe);
    public Lazy`2(TMetadata metadata, LazyThreadSafetyMode mode);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
    public TMetadata get_Metadata();
}
internal class System.LazyDebugView`1 : object {
    private Lazy`1<T> _lazy;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Nullable`1<LazyThreadSafetyMode> Mode { get; }
    public bool IsValueFaulted { get; }
    public LazyDebugView`1(Lazy`1<T> lazy);
    public bool get_IsValueCreated();
    public T get_Value();
    public Nullable`1<LazyThreadSafetyMode> get_Mode();
    public bool get_IsValueFaulted();
}
internal class System.LazyHelper : object {
    internal static LazyHelper NoneViaConstructor;
    internal static LazyHelper NoneViaFactory;
    internal static LazyHelper PublicationOnlyViaConstructor;
    internal static LazyHelper PublicationOnlyViaFactory;
    internal static LazyHelper PublicationOnlyWaitForOtherThreadToPublish;
    [CompilerGeneratedAttribute]
private LazyState <State>k__BackingField;
    private ExceptionDispatchInfo _exceptionDispatch;
    internal LazyState State { get; }
    internal LazyHelper(LazyState state);
    internal LazyHelper(LazyThreadSafetyMode mode, Exception exception);
    private static LazyHelper();
    [CompilerGeneratedAttribute]
internal LazyState get_State();
    [DoesNotReturnAttribute]
internal void ThrowException();
    private LazyThreadSafetyMode GetMode();
    internal static Nullable`1<LazyThreadSafetyMode> GetMode(LazyHelper state);
    internal static bool GetIsValueFaulted(LazyHelper state);
    internal static LazyHelper Create(LazyThreadSafetyMode mode, bool useDefaultConstructor);
    internal static T CreateViaDefaultConstructor();
    internal static LazyThreadSafetyMode GetModeFromIsThreadSafe(bool isThreadSafe);
}
internal enum System.LazyState : Enum {
    public int value__;
    public static LazyState NoneViaConstructor;
    public static LazyState NoneViaFactory;
    public static LazyState NoneException;
    public static LazyState PublicationOnlyViaConstructor;
    public static LazyState PublicationOnlyViaFactory;
    public static LazyState PublicationOnlyWait;
    public static LazyState PublicationOnlyException;
    public static LazyState ExecutionAndPublicationViaConstructor;
    public static LazyState ExecutionAndPublicationViaFactory;
    public static LazyState ExecutionAndPublicationException;
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    [ObsoleteAttribute("LoaderOptimization.DisallowBindings has been deprecated and is not supported.")]
public static LoaderOptimization DisallowBindings;
    [ObsoleteAttribute("LoaderOptimization.DomainMask has been deprecated and is not supported.")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomain;
    public static LoaderOptimization MultiDomainHost;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    private byte _val;
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
internal static class System.LocalAppContextSwitches : object {
    private static int s_enableUnsafeUTF7Encoding;
    private static int s_enforceJapaneseEraYearRanges;
    private static int s_formatJapaneseFirstYearAsANumber;
    private static int s_enforceLegacyJapaneseDateParsing;
    private static int s_preserveEventListenerObjectIdentity;
    private static int s_forceEmitInvoke;
    private static int s_forceInterpretedInvoke;
    private static int s_serializationGuard;
    private static int s_showILOffset;
    public static bool EnableUnsafeUTF7Encoding { get; }
    public static bool EnforceJapaneseEraYearRanges { get; }
    public static bool FormatJapaneseFirstYearAsANumber { get; }
    public static bool EnforceLegacyJapaneseDateParsing { get; }
    public static bool PreserveEventListenerObjectIdentity { get; }
    public static bool ForceEmitInvoke { get; }
    public static bool ForceInterpretedInvoke { get; }
    public static bool SerializationGuard { get; }
    public static bool ShowILOffsets { get; }
    public static bool get_EnableUnsafeUTF7Encoding();
    public static bool get_EnforceJapaneseEraYearRanges();
    public static bool get_FormatJapaneseFirstYearAsANumber();
    public static bool get_EnforceLegacyJapaneseDateParsing();
    public static bool get_PreserveEventListenerObjectIdentity();
    public static bool get_ForceEmitInvoke();
    public static bool get_ForceInterpretedInvoke();
    public static bool get_SerializationGuard();
    private static bool GetDefaultShowILOffsetSetting();
    public static bool get_ShowILOffsets();
    internal static bool GetCachedSwitchValue(string switchName, Int32& cachedSwitchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& cachedSwitchValue);
    private static bool GetSwitchDefaultValue(string switchName);
}
public class System.LocalDataStoreSlot : object {
    [CompilerGeneratedAttribute]
private ThreadLocal`1<object> <Data>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ThreadLocal`1<object> Data { get; private set; }
    internal LocalDataStoreSlot(ThreadLocal`1<object> data);
    [CompilerGeneratedAttribute]
internal ThreadLocal`1<object> get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(ThreadLocal`1<object> value);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
public abstract class System.MarshalByRefObject : object {
    [ObsoleteAttribute("This Remoting API is not supported and throws PlatformNotSupportedException.")]
public object GetLifetimeService();
    [ObsoleteAttribute("This Remoting API is not supported and throws PlatformNotSupportedException.")]
public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
internal static class System.Marvin : object {
    [CompilerGeneratedAttribute]
private static ulong <DefaultSeed>k__BackingField;
    public static ulong DefaultSeed { get; }
    private static Marvin();
    public static int ComputeHash32(ReadOnlySpan`1<byte> data, ulong seed);
    public static int ComputeHash32(Byte& data, UInt32 count, UInt32 p0, UInt32 p1);
    private static void Block(UInt32& rp0, UInt32& rp1);
    [CompilerGeneratedAttribute]
public static ulong get_DefaultSeed();
    private static ulong GenerateSeed();
    public static int ComputeHash32OrdinalIgnoreCase(Char& data, int count, UInt32 p0, UInt32 p1);
    private static int ComputeHash32OrdinalIgnoreCaseSlow(Char& data, int count, UInt32 p0, UInt32 p1);
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    public static double Tau;
    private static ReadOnlySpan`1<double> RoundPower10Double { get; }
    public static double Acos(double d);
    public static double Acosh(double d);
    public static double Asin(double d);
    public static double Asinh(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static double Atanh(double d);
    public static double Cbrt(double d);
    public static double Ceiling(double a);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static double Exp(double d);
    public static double Floor(double d);
    public static double Log(double d);
    public static double Log10(double d);
    public static double Pow(double x, double y);
    public static double Sin(double a);
    public static ValueTuple`2<double, double> SinCos(double x);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    [IntrinsicAttribute]
public static double FusedMultiplyAdd(double x, double y, double z);
    public static double Log2(double x);
    private static double ModF(double x, Double* intptr);
    private static ReadOnlySpan`1<double> get_RoundPower10Double();
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    public static IntPtr Abs(IntPtr value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static decimal Abs(decimal value);
    [IntrinsicAttribute]
public static double Abs(double value);
    [IntrinsicAttribute]
public static float Abs(float value);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
internal static void ThrowNegateTwosCompOverflow();
    public static long BigMul(int a, int b);
    [CLSCompliantAttribute("False")]
public static ulong BigMul(ulong a, ulong b, UInt64& low);
    public static long BigMul(long a, long b, Int64& low);
    public static double BitDecrement(double x);
    public static double BitIncrement(double x);
    public static double CopySign(double x, double y);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ValueTuple`2<sbyte, sbyte> DivRem(sbyte left, sbyte right);
    [NonVersionableAttribute]
public static ValueTuple`2<byte, byte> DivRem(byte left, byte right);
    [NonVersionableAttribute]
public static ValueTuple`2<short, short> DivRem(short left, short right);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ValueTuple`2<ushort, ushort> DivRem(ushort left, ushort right);
    [NonVersionableAttribute]
public static ValueTuple`2<int, int> DivRem(int left, int right);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ValueTuple`2<UInt32, UInt32> DivRem(UInt32 left, UInt32 right);
    [NonVersionableAttribute]
public static ValueTuple`2<long, long> DivRem(long left, long right);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ValueTuple`2<ulong, ulong> DivRem(ulong left, ulong right);
    [NonVersionableAttribute]
public static ValueTuple`2<IntPtr, IntPtr> DivRem(IntPtr left, IntPtr right);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ValueTuple`2<UIntPtr, UIntPtr> DivRem(UIntPtr left, UIntPtr right);
    public static decimal Ceiling(decimal d);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    public static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    [CLSCompliantAttribute("False")]
public static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);
    public static decimal Floor(decimal d);
    public static double IEEERemainder(double x, double y);
    public static int ILogB(double x);
    public static double Log(double a, double newBase);
    [NonVersionableAttribute]
public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    [IntrinsicAttribute]
public static double Max(double val1, double val2);
    [NonVersionableAttribute]
public static short Max(short val1, short val2);
    [NonVersionableAttribute]
public static int Max(int val1, int val2);
    [NonVersionableAttribute]
public static long Max(long val1, long val2);
    [NonVersionableAttribute]
public static IntPtr Max(IntPtr val1, IntPtr val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Max(sbyte val1, sbyte val2);
    [IntrinsicAttribute]
public static float Max(float val1, float val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Max(ulong val1, ulong val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UIntPtr Max(UIntPtr val1, UIntPtr val2);
    [IntrinsicAttribute]
public static double MaxMagnitude(double x, double y);
    [NonVersionableAttribute]
public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    [IntrinsicAttribute]
public static double Min(double val1, double val2);
    [NonVersionableAttribute]
public static short Min(short val1, short val2);
    [NonVersionableAttribute]
public static int Min(int val1, int val2);
    [NonVersionableAttribute]
public static long Min(long val1, long val2);
    [NonVersionableAttribute]
public static IntPtr Min(IntPtr val1, IntPtr val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static sbyte Min(sbyte val1, sbyte val2);
    [IntrinsicAttribute]
public static float Min(float val1, float val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static ulong Min(ulong val1, ulong val2);
    [CLSCompliantAttribute("False")]
[NonVersionableAttribute]
public static UIntPtr Min(UIntPtr val1, UIntPtr val2);
    [IntrinsicAttribute]
public static double MinMagnitude(double x, double y);
    public static double ReciprocalEstimate(double d);
    public static double ReciprocalSqrtEstimate(double d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    [IntrinsicAttribute]
public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, MidpointRounding mode);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    public static int Sign(IntPtr value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static decimal Truncate(decimal d);
    [IntrinsicAttribute]
public static double Truncate(double d);
    [DoesNotReturnAttribute]
internal static void ThrowMinMaxException(T min, T max);
    public static double ScaleB(double x, int n);
    [CompilerGeneratedAttribute]
internal static ulong <BigMul>g__SoftwareFallback|48_0(ulong a, ulong b, UInt64& low);
    [CompilerGeneratedAttribute]
internal static double <CopySign>g__SoftwareFallback|52_0(double x, double y);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    public static float Tau;
    private static ReadOnlySpan`1<float> RoundPower10Single { get; }
    public static float Acos(float x);
    public static float Acosh(float x);
    public static float Asin(float x);
    public static float Asinh(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Atanh(float x);
    public static float Cbrt(float x);
    public static float Ceiling(float x);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float Log(float x);
    public static float Log10(float x);
    public static float Pow(float x, float y);
    public static float Sin(float x);
    public static ValueTuple`2<float, float> SinCos(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    [IntrinsicAttribute]
public static float FusedMultiplyAdd(float x, float y, float z);
    public static float Log2(float x);
    private static float ModF(float x, Single* intptr);
    private static ReadOnlySpan`1<float> get_RoundPower10Single();
    [IntrinsicAttribute]
public static float Abs(float x);
    public static float BitDecrement(float x);
    public static float BitIncrement(float x);
    public static float CopySign(float x, float y);
    public static float IEEERemainder(float x, float y);
    public static int ILogB(float x);
    public static float Log(float x, float y);
    [IntrinsicAttribute]
public static float Max(float x, float y);
    [IntrinsicAttribute]
public static float MaxMagnitude(float x, float y);
    [IntrinsicAttribute]
public static float Min(float x, float y);
    [IntrinsicAttribute]
public static float MinMagnitude(float x, float y);
    public static float ReciprocalEstimate(float x);
    public static float ReciprocalSqrtEstimate(float x);
    [IntrinsicAttribute]
public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, MidpointRounding mode);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static int Sign(float x);
    [IntrinsicAttribute]
public static float Truncate(float x);
    public static float ScaleB(float x, int n);
    [CompilerGeneratedAttribute]
internal static float <CopySign>g__SoftwareFallback|41_0(float x, float y);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MemberAccessException : SystemException {
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MemberAccessException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.Memory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Memory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    internal Memory`1(T[] array, int start);
    public Memory`1(T[] array, int start, int length);
    internal Memory`1(MemoryManager`1<T> manager, int length);
    internal Memory`1(MemoryManager`1<T> manager, int start, int length);
    internal Memory`1(object obj, int start, int length);
    public static Memory`1<T> op_Implicit(T[] array);
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Memory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
}
internal class System.MemoryDebugView`1 : object {
    private ReadOnlyMemory`1<T> _memory;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public MemoryDebugView`1(Memory`1<T> memory);
    public MemoryDebugView`1(ReadOnlyMemory`1<T> memory);
    public T[] get_Items();
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Range range);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, Index startIndex);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, Range range);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Index startIndex);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Range range);
    [ExtensionAttribute]
public static bool Contains(Span`1<T> span, T value);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static bool ContainsAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool ContainsAny(Span`1<T> span, SearchValues`1<T> values);
    [ExtensionAttribute]
public static bool ContainsAnyExcept(Span`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyExcept(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyExcept(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static bool ContainsAnyExcept(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool ContainsAnyExcept(Span`1<T> span, SearchValues`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyInRange(Span`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyExceptInRange(Span`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static bool ContainsAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool ContainsAny(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    [ExtensionAttribute]
public static bool ContainsAnyExcept(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static bool ContainsAnyExcept(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static bool ContainsAnyExcept(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyInRange(ReadOnlySpan`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool ContainsAnyExceptInRange(ReadOnlySpan`1<T> span, T lowInclusive, T highInclusive);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, SearchValues`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
private static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2, T value3);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, SearchValues`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
private static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2, T value3);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyInRange(Span`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyInRange(ReadOnlySpan`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExceptInRange(Span`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExceptInRange(ReadOnlySpan`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyInRange(Span`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyInRange(ReadOnlySpan`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExceptInRange(Span`1<T> span, T lowInclusive, T highInclusive);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExceptInRange(ReadOnlySpan`1<T> span, T lowInclusive, T highInclusive);
    [DoesNotReturnAttribute]
private static void ThrowNullLowHighInclusive(T lowInclusive, T highInclusive);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, SearchValues`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, SearchValues`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, SearchValues`1<T> values);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Range range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Range range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<T> span);
    [ExtensionAttribute]
public static void Sort(Span`1<T> span, TComparer comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Sort(Span`1<T> span, Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<TKey> keys, Span`1<TValue> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<TKey> keys, Span`1<TValue> items, TComparer comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<TKey> keys, Span`1<TValue> items, Comparison`1<TKey> comparison);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Replace(Span`1<T> span, T oldValue, T newValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Replace(ReadOnlySpan`1<T> source, Span`1<T> destination, T oldValue, T newValue);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(Span`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    private static void SliceLongerSpanToMatchShorterLength(ReadOnlySpan`1& span, ReadOnlySpan`1& other);
    [ExtensionAttribute]
public static int Split(ReadOnlySpan`1<char> source, Span`1<Range> destination, char separator, StringSplitOptions options);
    [ExtensionAttribute]
public static int Split(ReadOnlySpan`1<char> source, Span`1<Range> destination, ReadOnlySpan`1<char> separator, StringSplitOptions options);
    [ExtensionAttribute]
public static int SplitAny(ReadOnlySpan`1<char> source, Span`1<Range> destination, ReadOnlySpan`1<char> separators, StringSplitOptions options);
    [ExtensionAttribute]
public static int SplitAny(ReadOnlySpan`1<char> source, Span`1<Range> destination, ReadOnlySpan`1<string> separators, StringSplitOptions options);
    private static int SplitCore(ReadOnlySpan`1<char> source, Span`1<Range> destination, ReadOnlySpan`1<char> separatorOrSeparators, ReadOnlySpan`1<string> stringSeparators, bool isAny, StringSplitOptions options);
    private static ValueTuple`2<int, int> TrimSplitEntry(ReadOnlySpan`1<char> source, int startInclusive, int endExclusive);
    [ExtensionAttribute]
public static int Count(Span`1<T> span, T value);
    [ExtensionAttribute]
public static int Count(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int Count(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int Count(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, TryWriteInterpolatedStringHandler& handler, Int32& charsWritten);
    [ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, TryWriteInterpolatedStringHandler& handler, Int32& charsWritten);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, CompositeFormat format, Int32& charsWritten, TArg0 arg0);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, CompositeFormat format, Int32& charsWritten, TArg0 arg0, TArg1 arg1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, CompositeFormat format, Int32& charsWritten, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, CompositeFormat format, Int32& charsWritten, Object[] args);
    [ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, CompositeFormat format, Int32& charsWritten, ReadOnlySpan`1<object> args);
    private static bool TryWrite(Span`1<char> destination, IFormatProvider provider, CompositeFormat format, Int32& charsWritten, TArg0 arg0, TArg1 arg1, TArg2 arg2, ReadOnlySpan`1<object> args);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool EqualsOrdinal(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool EndsWithOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool StartsWithOrdinalIgnoreCase(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static SpanRuneEnumerator EnumerateRunes(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static SpanRuneEnumerator EnumerateRunes(Span`1<char> span);
    [ExtensionAttribute]
public static SpanLineEnumerator EnumerateLines(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static SpanLineEnumerator EnumerateLines(Span`1<char> span);
    [ExtensionAttribute]
internal static bool EqualsOrdinalIgnoreCaseUtf8(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
internal static bool StartsWithUtf8(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> value, StringComparison comparisonType);
    [ExtensionAttribute]
internal static bool StartsWithOrdinalIgnoreCaseUtf8(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> value);
    [ExtensionAttribute]
public static Memory`1<T> Trim(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> TrimStart(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> TrimEnd(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> Trim(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimStart(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimEnd(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> Trim(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> TrimStart(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> TrimEnd(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> Trim(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimStart(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimEnd(ReadOnlySpan`1<T> span, T trimElement);
    private static int ClampStart(ReadOnlySpan`1<T> span, T trimElement);
    private static int ClampEnd(ReadOnlySpan`1<T> span, int start, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> Trim(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> TrimStart(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> TrimEnd(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> Trim(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimStart(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimEnd(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> Trim(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> TrimStart(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> TrimEnd(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> Trim(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimStart(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimEnd(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    private static int ClampStart(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    private static int ClampEnd(ReadOnlySpan`1<T> span, int start, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<char> Trim(Memory`1<char> memory);
    [ExtensionAttribute]
public static Memory`1<char> TrimStart(Memory`1<char> memory);
    [ExtensionAttribute]
public static Memory`1<char> TrimEnd(Memory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> Trim(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimStart(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimEnd(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static Span`1<char> Trim(Span`1<char> span);
    [ExtensionAttribute]
public static Span`1<char> TrimStart(Span`1<char> span);
    [ExtensionAttribute]
public static Span`1<char> TrimEnd(Span`1<char> span);
    private static int ClampStart(ReadOnlySpan`1<char> span);
    private static int ClampEnd(ReadOnlySpan`1<char> span, int start);
    [ExtensionAttribute]
internal static ReadOnlySpan`1<byte> TrimUtf8(ReadOnlySpan`1<byte> span);
    [CompilerGeneratedAttribute]
internal static ReadOnlySpan`1<char> <Trim>g__TrimFallback|219_0(ReadOnlySpan`1<char> span);
    [CompilerGeneratedAttribute]
internal static Span`1<char> <Trim>g__TrimFallback|228_0(Span`1<char> span);
    [CompilerGeneratedAttribute]
internal static ReadOnlySpan`1<byte> <TrimUtf8>g__TrimFallback|233_0(ReadOnlySpan`1<byte> span);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MethodAccessException : MemberAccessException {
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MethodAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
    public static MidpointRounding ToZero;
    public static MidpointRounding ToNegativeInfinity;
    public static MidpointRounding ToPositiveInfinity;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    [NullableContextAttribute("2")]
public MissingFieldException(string message);
    [NullableContextAttribute("2")]
public MissingFieldException(string message, Exception inner);
    [NullableContextAttribute("2")]
public MissingFieldException(string className, string fieldName);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MissingFieldException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    [NullableAttribute("1")]
public string Message { get; }
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    public MissingMemberException(string className, string memberName);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MissingMemberException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    [NullableContextAttribute("2")]
public MissingMethodException(string message);
    [NullableContextAttribute("2")]
public MissingMethodException(string message, Exception inner);
    [NullableContextAttribute("2")]
public MissingMethodException(string className, string methodName);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MissingMethodException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ModuleHandle : ValueType {
    private IntPtr value;
    public static ModuleHandle EmptyHandle;
    internal IntPtr Value { get; }
    public int MDStreamVersion { get; }
    internal ModuleHandle(IntPtr v);
    private static ModuleHandle();
    internal IntPtr get_Value();
    public int get_MDStreamVersion();
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    private static IntPtr[] ptrs_from_handles(RuntimeTypeHandle[] handles);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ModuleHandle handle);
    public virtual int GetHashCode();
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.MulticastDelegate : Delegate {
    private Delegate[] delegates;
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
protected sealed virtual object DynamicInvokeImpl(Object[] args);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected virtual MethodInfo GetMethodImpl();
    public sealed virtual Delegate[] GetInvocationList();
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    private static int LastIndexOf(Delegate[] haystack, Delegate[] needle);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
    [NullableContextAttribute("2")]
public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    internal virtual object GetTarget();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private MulticastNotSupportedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Net.WebUtility : object {
    public static string HtmlEncode(string value);
    [NullableContextAttribute("1")]
public static void HtmlEncode(string value, TextWriter output);
    private static void HtmlEncode(ReadOnlySpan`1<char> input, ValueStringBuilder& output);
    public static string HtmlDecode(string value);
    [NullableContextAttribute("1")]
public static void HtmlDecode(string value, TextWriter output);
    private static void HtmlDecode(ReadOnlySpan`1<char> input, ValueStringBuilder& output);
    private static int IndexOfHtmlEncodingChars(ReadOnlySpan`1<char> input);
    private static void GetEncodedBytes(Byte[] originalBytes, int offset, int count, Byte[] expandedBytes);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
    private static string UrlDecodeInternal(string value, Encoding encoding);
    private static Byte[] UrlDecodeInternal(Byte[] bytes, int offset, int count);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    private static void ConvertSmpToUtf16(UInt32 smpChar, Char& leadingSurrogate, Char& trailingSurrogate);
    private static int GetNextUnicodeScalarValueFromUtf16Surrogate(ReadOnlySpan`1<char> input, Int32& index);
    private static bool IsUrlSafeChar(char ch);
    private static bool ValidateUrlEncodingParameters(Byte[] bytes, int offset, int count);
}
[AttributeUsageAttribute("256")]
[EditorBrowsableAttribute("1")]
public class System.NonSerializedAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotFiniteNumberException : ArithmeticException {
    private double _offendingNumber;
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, Exception innerException);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public double get_OffendingNumber();
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesign { get; }
    internal static Exception get_ByDesign();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotImplementedException : SystemException {
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected NotImplementedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NotSupportedException : SystemException {
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected NotSupportedException(SerializationInfo info, StreamingContext context);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    [NullableContextAttribute("1")]
public static Type GetUnderlyingType(Type nullableType);
    public static T& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrDefaultRef(Nullable`1& nullable);
}
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Nullable`1 : ValueType {
    private bool hasValue;
    internal T value;
    public bool HasValue { get; }
    public T Value { get; }
    [NonVersionableAttribute]
public Nullable`1(T value);
    private static object Box(Nullable`1<T> o);
    private static Nullable`1<T> Unbox(object o);
    private static Nullable`1<T> UnboxExact(object o);
    [IsReadOnlyAttribute]
[NonVersionableAttribute]
public bool get_HasValue();
    [IsReadOnlyAttribute]
public T get_Value();
    [IsReadOnlyAttribute]
[NonVersionableAttribute]
public T GetValueOrDefault();
    [IsReadOnlyAttribute]
[NonVersionableAttribute]
public T GetValueOrDefault(T defaultValue);
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual string ToString();
    [NonVersionableAttribute]
public static Nullable`1<T> op_Implicit(T value);
    [NonVersionableAttribute]
public static T op_Explicit(Nullable`1<T> value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.NullReferenceException : SystemException {
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected NullReferenceException(SerializationInfo info, StreamingContext context);
}
internal static class System.Number : object {
    private static String[] s_smallNumberCache;
    private static String[] s_posCurrencyFormats;
    private static String[] s_negCurrencyFormats;
    private static String[] s_posPercentFormats;
    private static String[] s_negPercentFormats;
    private static String[] s_negNumberFormats;
    private static Byte[] TwoDigitsCharsAsBytes;
    private static Byte[] TwoDigitsBytes;
    private static ReadOnlySpan`1<double> Pow10DoubleTable { get; }
    private static ReadOnlySpan`1<ulong> Pow5128Table { get; }
    private static Number();
    public static void Dragon4Double(double value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    public static void Dragon4Half(Half value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    public static void Dragon4Single(float value, int cutoffNumber, bool isSignificantDigits, NumberBuffer& number);
    private static UInt32 Dragon4(ulong mantissa, int exponent, UInt32 mantissaHighBitIdx, bool hasUnequalMargins, int cutoffNumber, bool isSignificantDigits, Span`1<byte> buffer, Int32& decimalExponent);
    public static string FormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static bool TryFormatDecimal(decimal value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<TChar> destination, Int32& charsWritten);
    internal static void DecimalToNumber(Decimal& d, NumberBuffer& number);
    public static string FormatDouble(double value, string format, NumberFormatInfo info);
    public static bool TryFormatDouble(double value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<TChar> destination, Int32& charsWritten);
    private static int GetFloatingPointMaxDigitsAndPrecision(char fmt, Int32& precision, NumberFormatInfo info, Boolean& isSignificantDigits);
    private static string FormatDouble(ValueListBuilder`1& vlb, double value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static string FormatSingle(float value, string format, NumberFormatInfo info);
    public static bool TryFormatSingle(float value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<TChar> destination, Int32& charsWritten);
    private static string FormatSingle(ValueListBuilder`1& vlb, float value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static string FormatHalf(Half value, string format, NumberFormatInfo info);
    private static string FormatHalf(ValueListBuilder`1& vlb, Half value, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    public static bool TryFormatHalf(Half value, ReadOnlySpan`1<char> format, NumberFormatInfo info, Span`1<TChar> destination, Int32& charsWritten);
    private static bool TryCopyTo(string source, Span`1<TChar> destination, Int32& charsWritten);
    internal static char GetHexBase(char fmt);
    public static string FormatInt32(int value, int hexMask, string format, IFormatProvider provider);
    public static bool TryFormatInt32(int value, int hexMask, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    public static string FormatUInt32(UInt32 value, string format, IFormatProvider provider);
    public static bool TryFormatUInt32(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    public static string FormatInt64(long value, string format, IFormatProvider provider);
    public static bool TryFormatInt64(long value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    public static string FormatUInt64(ulong value, string format, IFormatProvider provider);
    public static bool TryFormatUInt64(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    public static string FormatInt128(Int128 value, string format, IFormatProvider provider);
    public static bool TryFormatInt128(Int128 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    public static string FormatUInt128(UInt128 value, string format, IFormatProvider provider);
    public static bool TryFormatUInt128(UInt128 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    private static void Int32ToNumber(int value, NumberBuffer& number);
    public static string Int32ToDecStr(int value);
    private static string NegativeInt32ToDecStr(int value, int digits, string sNegative);
    internal static bool TryNegativeInt32ToDecStr(int value, int digits, ReadOnlySpan`1<TChar> sNegative, Span`1<TChar> destination, Int32& charsWritten);
    private static string Int32ToHexStr(int value, char hexBase, int digits);
    internal static bool TryInt32ToHexStr(int value, char hexBase, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static TChar* Int32ToHexChars(TChar* buffer, UInt32 value, int hexBase, int digits);
    private static string UInt32ToBinaryStr(UInt32 value, int digits);
    private static bool TryUInt32ToBinaryStr(UInt32 value, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static TChar* UInt32ToBinaryChars(TChar* buffer, UInt32 value, int digits);
    private static void UInt32ToNumber(UInt32 value, NumberBuffer& number);
    internal static void WriteTwoDigits(UInt32 value, TChar* ptr);
    internal static void WriteFourDigits(UInt32 value, TChar* ptr);
    internal static void WriteDigits(UInt32 value, TChar* ptr, int count);
    internal static TChar* UInt32ToDecChars(TChar* bufferEnd, UInt32 value);
    internal static TChar* UInt32ToDecChars(TChar* bufferEnd, UInt32 value, int digits);
    internal static string UInt32ToDecStr(UInt32 value);
    internal static string UInt32ToDecStrForKnownSmallNumber(UInt32 value);
    private static string UInt32ToDecStr_NoSmallNumberCheck(UInt32 value);
    private static string UInt32ToDecStr(UInt32 value, int digits);
    internal static bool TryUInt32ToDecStr(UInt32 value, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryUInt32ToDecStr(UInt32 value, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static void Int64ToNumber(long value, NumberBuffer& number);
    public static string Int64ToDecStr(long value);
    private static string NegativeInt64ToDecStr(long value, int digits, string sNegative);
    internal static bool TryNegativeInt64ToDecStr(long value, int digits, ReadOnlySpan`1<TChar> sNegative, Span`1<TChar> destination, Int32& charsWritten);
    private static string Int64ToHexStr(long value, char hexBase, int digits);
    internal static bool TryInt64ToHexStr(long value, char hexBase, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static TChar* Int64ToHexChars(TChar* buffer, ulong value, int hexBase, int digits);
    private static string UInt64ToBinaryStr(ulong value, int digits);
    private static bool TryUInt64ToBinaryStr(ulong value, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static TChar* UInt64ToBinaryChars(TChar* buffer, ulong value, int digits);
    private static void UInt64ToNumber(ulong value, NumberBuffer& number);
    internal static TChar* UInt64ToDecChars(TChar* bufferEnd, ulong value);
    internal static TChar* UInt64ToDecChars(TChar* bufferEnd, ulong value, int digits);
    internal static string UInt64ToDecStr(ulong value);
    internal static string UInt64ToDecStr(ulong value, int digits);
    internal static bool TryUInt64ToDecStr(ulong value, Span`1<TChar> destination, Int32& charsWritten);
    internal static bool TryUInt64ToDecStr(ulong value, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static void Int128ToNumber(Int128 value, NumberBuffer& number);
    public static string Int128ToDecStr(Int128 value);
    private static string NegativeInt128ToDecStr(Int128 value, int digits, string sNegative);
    private static bool TryNegativeInt128ToDecStr(Int128 value, int digits, ReadOnlySpan`1<TChar> sNegative, Span`1<TChar> destination, Int32& charsWritten);
    private static string Int128ToHexStr(Int128 value, char hexBase, int digits);
    private static bool TryInt128ToHexStr(Int128 value, char hexBase, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static TChar* Int128ToHexChars(TChar* buffer, UInt128 value, int hexBase, int digits);
    private static string UInt128ToBinaryStr(Int128 value, int digits);
    private static bool TryUInt128ToBinaryStr(Int128 value, int digits, Span`1<TChar> destination, Int32& charsWritten);
    private static TChar* UInt128ToBinaryChars(TChar* buffer, UInt128 value, int digits);
    private static void UInt128ToNumber(UInt128 value, NumberBuffer& number);
    private static ulong Int128DivMod1E19(UInt128& value);
    internal static TChar* UInt128ToDecChars(TChar* bufferEnd, UInt128 value);
    internal static TChar* UInt128ToDecChars(TChar* bufferEnd, UInt128 value, int digits);
    internal static string UInt128ToDecStr(UInt128 value);
    internal static string UInt128ToDecStr(UInt128 value, int digits);
    private static bool TryUInt128ToDecStr(UInt128 value, int digits, Span`1<TChar> destination, Int32& charsWritten);
    internal static char ParseFormatSpecifier(ReadOnlySpan`1<char> format, Int32& digits);
    internal static void NumberToString(ValueListBuilder`1& vlb, NumberBuffer& number, char format, int nMaxDigits, NumberFormatInfo info);
    internal static void NumberToStringFormat(ValueListBuilder`1& vlb, NumberBuffer& number, ReadOnlySpan`1<char> format, NumberFormatInfo info);
    private static void FormatCurrency(ValueListBuilder`1& vlb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatFixed(ValueListBuilder`1& vlb, NumberBuffer& number, int nMaxDigits, Int32[] groupDigits, ReadOnlySpan`1<TChar> sDecimal, ReadOnlySpan`1<TChar> sGroup);
    private static void AppendUnknownChar(ValueListBuilder`1& vlb, char ch);
    private static void FormatNumber(ValueListBuilder`1& vlb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    private static void FormatScientific(ValueListBuilder`1& vlb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar);
    private static void FormatExponent(ValueListBuilder`1& vlb, NumberFormatInfo info, int value, char expChar, int minDigits, bool positiveSign);
    private static void FormatGeneral(ValueListBuilder`1& vlb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info, char expChar, bool suppressScientific);
    private static void FormatPercent(ValueListBuilder`1& vlb, NumberBuffer& number, int nMaxDigits, NumberFormatInfo info);
    internal static void RoundNumber(NumberBuffer& number, int pos, bool isCorrectlyRounded);
    private static int FindSection(ReadOnlySpan`1<char> format, int section);
    private static ulong ExtractFractionAndBiasedExponent(double value, Int32& exponent);
    private static ushort ExtractFractionAndBiasedExponent(Half value, Int32& exponent);
    private static UInt32 ExtractFractionAndBiasedExponent(float value, Int32& exponent);
    private static ReadOnlySpan`1<double> get_Pow10DoubleTable();
    private static ReadOnlySpan`1<ulong> get_Pow5128Table();
    private static void AccumulateDecimalDigitsIntoBigInteger(NumberBuffer& number, UInt32 firstIndex, UInt32 lastIndex, BigInteger& result);
    private static ulong AssembleFloatingPointBits(ulong initialMantissa, int initialExponent, bool hasZeroTail);
    private static ulong ConvertBigIntegerToFloatingPointBits(BigInteger& value, UInt32 integerBitsOfPrecision, bool hasNonZeroFractionalPart);
    private static UInt32 DigitsToUInt32(Byte* p, int count);
    private static ulong DigitsToUInt64(Byte* p, int count);
    internal static UInt32 ParseEightDigitsUnrolled(Byte* chars);
    private static ulong NumberToFloatingPointBits(NumberBuffer& number);
    private static ulong NumberToFloatingPointBitsSlow(NumberBuffer& number, UInt32 positiveExponent, UInt32 integerDigitsPresent, UInt32 fractionalDigitsPresent);
    private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail);
    private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits);
    internal static ValueTuple`2<int, ulong> ComputeFloat(long q, ulong w);
    private static ValueTuple`2<ulong, ulong> ComputeProductApproximation(int bitPrecision, long q, ulong w);
    internal static int CalculatePower(int q);
    private static bool TryNumberBufferToBinaryInteger(NumberBuffer& number, TInteger& value);
    internal static TInteger ParseBinaryInteger(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info);
    private static bool TryParseNumber(TChar*& str, TChar* strEnd, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info);
    internal static ParsingStatus TryParseBinaryInteger(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info, TInteger& result);
    private static ParsingStatus TryParseBinaryIntegerNumber(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info, TInteger& result);
    internal static ParsingStatus TryParseBinaryIntegerStyle(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info, TInteger& result);
    internal static ParsingStatus TryParseBinaryIntegerHexNumberStyle(ReadOnlySpan`1<TChar> value, NumberStyles styles, TInteger& result);
    private static ParsingStatus TryParseBinaryIntegerHexOrBinaryNumberStyle(ReadOnlySpan`1<TChar> value, NumberStyles styles, TInteger& result);
    internal static decimal ParseDecimal(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info);
    internal static bool TryNumberToDecimal(NumberBuffer& number, Decimal& value);
    internal static TFloat ParseFloat(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info);
    internal static ParsingStatus TryParseDecimal(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info, Decimal& result);
    internal static bool SpanStartsWith(ReadOnlySpan`1<TChar> span, TChar c);
    internal static bool SpanStartsWith(ReadOnlySpan`1<TChar> span, ReadOnlySpan`1<TChar> value, StringComparison comparisonType);
    internal static ReadOnlySpan`1<TChar> SpanTrim(ReadOnlySpan`1<TChar> span);
    internal static bool SpanEqualsOrdinalIgnoreCase(ReadOnlySpan`1<TChar> span, ReadOnlySpan`1<TChar> value);
    internal static bool TryParseFloat(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberFormatInfo info, TFloat& result);
    internal static bool TryStringToNumber(ReadOnlySpan`1<TChar> value, NumberStyles styles, NumberBuffer& number, NumberFormatInfo info);
    private static bool TrailingZeros(ReadOnlySpan`1<TChar> value, int index);
    private static bool IsSpaceReplacingChar(UInt32 c);
    private static TChar* MatchNegativeSignChars(TChar* p, TChar* pEnd, NumberFormatInfo info);
    private static TChar* MatchChars(TChar* p, TChar* pEnd, ReadOnlySpan`1<TChar> value);
    private static bool IsWhite(UInt32 ch);
    private static bool IsDigit(UInt32 ch);
    [DoesNotReturnAttribute]
internal static void ThrowOverflowOrFormatException(ParsingStatus status, ReadOnlySpan`1<TChar> value);
    [DoesNotReturnAttribute]
internal static void ThrowFormatException(ReadOnlySpan`1<TChar> value);
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException();
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException(string message);
    internal static TFloat NumberToFloat(NumberBuffer& number);
    [CompilerGeneratedAttribute]
internal static string <FormatInt32>g__FormatInt32Slow|41_0(int value, int hexMask, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static bool <TryFormatInt32>g__TryFormatInt32Slow|42_0(int value, int hexMask, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
internal static string <FormatUInt32>g__FormatUInt32Slow|43_0(UInt32 value, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static bool <TryFormatUInt32>g__TryFormatUInt32Slow|44_0(UInt32 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
internal static string <FormatInt64>g__FormatInt64Slow|45_0(long value, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static bool <TryFormatInt64>g__TryFormatInt64Slow|46_0(long value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
internal static string <FormatUInt64>g__FormatUInt64Slow|47_0(ulong value, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static bool <TryFormatUInt64>g__TryFormatUInt64Slow|48_0(ulong value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
internal static string <FormatInt128>g__FormatInt128Slow|49_0(Int128 value, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static bool <TryFormatInt128>g__TryFormatInt128Slow|50_0(Int128 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
internal static string <FormatUInt128>g__FormatUInt128Slow|51_0(UInt128 value, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static bool <TryFormatUInt128>g__TryFormatUInt128Slow|52_0(UInt128 value, ReadOnlySpan`1<char> format, IFormatProvider provider, Span`1<TChar> destination, Int32& charsWritten);
    [CompilerGeneratedAttribute]
internal static string <UInt32ToDecStrForKnownSmallNumber>g__CreateAndCacheString|70_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static void <AppendUnknownChar>g__AppendNonAsciiBytes|115_0(ValueListBuilder`1& vlb, char ch);
    [CompilerGeneratedAttribute]
internal static bool <RoundNumber>g__ShouldRoundUp|121_0(Byte* dig, int i, NumberBufferKind numberKind, bool isCorrectlyRounded);
}
public static class System.Numerics.BitOperations : object {
    private static ReadOnlySpan`1<byte> TrailingZeroCountDeBruijn { get; }
    private static ReadOnlySpan`1<byte> Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_TrailingZeroCountDeBruijn();
    private static ReadOnlySpan`1<byte> get_Log2DeBruijn();
    public static bool IsPow2(int value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(UInt32 value);
    public static bool IsPow2(long value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(ulong value);
    public static bool IsPow2(IntPtr value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt32 RoundUpToPowerOf2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong RoundUpToPowerOf2(ulong value);
    [CLSCompliantAttribute("False")]
public static UIntPtr RoundUpToPowerOf2(UIntPtr value);
    internal static int LeadingZeroCount(Int128 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int LeadingZeroCount(ulong value);
    internal static int LeadingZeroCount(UInt128 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int Log2(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int Log2(ulong value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int Log2(UIntPtr value);
    private static int Log2SoftwareFallback(UInt32 value);
    internal static int Log2Ceiling(ulong value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int PopCount(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int PopCount(ulong value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int PopCount(UIntPtr value);
    public static int TrailingZeroCount(int value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UInt32 value);
    [IntrinsicAttribute]
public static int TrailingZeroCount(long value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int TrailingZeroCount(ulong value);
    [IntrinsicAttribute]
public static int TrailingZeroCount(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 value, int offset);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong value, int offset);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UIntPtr RotateLeft(UIntPtr value, int offset);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 value, int offset);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong value, int offset);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UIntPtr RotateRight(UIntPtr value, int offset);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Crc32C(UInt32 crc, byte data);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Crc32C(UInt32 crc, ushort data);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Crc32C(UInt32 crc, UInt32 data);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 Crc32C(UInt32 crc, ulong data);
    internal static UInt32 ResetLowestSetBit(UInt32 value);
    internal static UInt32 FlipBit(UInt32 value, int index);
    [CompilerGeneratedAttribute]
internal static int <PopCount>g__SoftwareFallback|24_0(UInt32 value);
    [CompilerGeneratedAttribute]
internal static int <PopCount>g__SoftwareFallback|25_0(ulong value);
}
internal static class System.Numerics.Crc32ReflectedTable : object {
    internal static UInt32[] Generate(UInt32 reflectedPolynomial);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IAdditionOperators`3 {
    public static abstract virtual TResult op_Addition(TSelf left, TOther right);
    public static virtual TResult op_CheckedAddition(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IAdditiveIdentity`2 {
    public static TResult AdditiveIdentity { get; }
    public static abstract virtual TResult get_AdditiveIdentity();
}
public interface System.Numerics.IBinaryFloatingPointIeee754`1 {
}
[NullableContextAttribute("1")]
public interface System.Numerics.IBinaryInteger`1 {
    public static virtual ValueTuple`2<TSelf, TSelf> DivRem(TSelf left, TSelf right);
    public static virtual TSelf LeadingZeroCount(TSelf value);
    public static abstract virtual TSelf PopCount(TSelf value);
    public static virtual TSelf ReadBigEndian(Byte[] source, bool isUnsigned);
    public static virtual TSelf ReadBigEndian(Byte[] source, int startIndex, bool isUnsigned);
    [NullableContextAttribute("0")]
public static virtual TSelf ReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned);
    public static virtual TSelf ReadLittleEndian(Byte[] source, bool isUnsigned);
    public static virtual TSelf ReadLittleEndian(Byte[] source, int startIndex, bool isUnsigned);
    [NullableContextAttribute("0")]
public static virtual TSelf ReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned);
    public static virtual TSelf RotateLeft(TSelf value, int rotateAmount);
    public static virtual TSelf RotateRight(TSelf value, int rotateAmount);
    public static abstract virtual TSelf TrailingZeroCount(TSelf value);
    [NullableContextAttribute("0")]
public static abstract virtual bool TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, TSelf& value);
    [NullableContextAttribute("0")]
public static abstract virtual bool TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, TSelf& value);
    public abstract virtual int GetByteCount();
    public abstract virtual int GetShortestBitLength();
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    public virtual int WriteBigEndian(Byte[] destination);
    public virtual int WriteBigEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteBigEndian(Span`1<byte> destination);
    public virtual int WriteLittleEndian(Byte[] destination);
    public virtual int WriteLittleEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteLittleEndian(Span`1<byte> destination);
}
public interface System.Numerics.IBinaryNumber`1 {
    [NullableAttribute("1")]
public static TSelf AllBitsSet { get; }
    [NullableContextAttribute("1")]
public static virtual TSelf get_AllBitsSet();
    [NullableContextAttribute("1")]
public static abstract virtual bool IsPow2(TSelf value);
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Log2(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IBitwiseOperators`3 {
    public static abstract virtual TResult op_BitwiseAnd(TSelf left, TOther right);
    public static abstract virtual TResult op_BitwiseOr(TSelf left, TOther right);
    public static abstract virtual TResult op_ExclusiveOr(TSelf left, TOther right);
    public static abstract virtual TResult op_OnesComplement(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IComparisonOperators`3 {
    public static abstract virtual TResult op_LessThan(TSelf left, TOther right);
    public static abstract virtual TResult op_LessThanOrEqual(TSelf left, TOther right);
    public static abstract virtual TResult op_GreaterThan(TSelf left, TOther right);
    public static abstract virtual TResult op_GreaterThanOrEqual(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IDecrementOperators`1 {
    public static abstract virtual TSelf op_Decrement(TSelf value);
    public static virtual TSelf op_CheckedDecrement(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IDivisionOperators`3 {
    public static abstract virtual TResult op_Division(TSelf left, TOther right);
    public static virtual TResult op_CheckedDivision(TSelf left, TOther right);
}
[NullableContextAttribute("2")]
public interface System.Numerics.IEqualityOperators`3 {
    public static abstract virtual TResult op_Equality(TSelf left, TOther right);
    public static abstract virtual TResult op_Inequality(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IExponentialFunctions`1 {
    public static abstract virtual TSelf Exp(TSelf x);
    public static virtual TSelf ExpM1(TSelf x);
    public static abstract virtual TSelf Exp2(TSelf x);
    public static virtual TSelf Exp2M1(TSelf x);
    public static abstract virtual TSelf Exp10(TSelf x);
    public static virtual TSelf Exp10M1(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IFloatingPoint`1 {
    public static virtual TSelf Ceiling(TSelf x);
    public static virtual TSelf Floor(TSelf x);
    public static virtual TSelf Round(TSelf x);
    public static virtual TSelf Round(TSelf x, int digits);
    public static virtual TSelf Round(TSelf x, MidpointRounding mode);
    public static abstract virtual TSelf Round(TSelf x, int digits, MidpointRounding mode);
    public static virtual TSelf Truncate(TSelf x);
    public abstract virtual int GetExponentByteCount();
    public abstract virtual int GetExponentShortestBitLength();
    public abstract virtual int GetSignificandBitLength();
    public abstract virtual int GetSignificandByteCount();
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    public virtual int WriteExponentBigEndian(Byte[] destination);
    public virtual int WriteExponentBigEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteExponentBigEndian(Span`1<byte> destination);
    public virtual int WriteExponentLittleEndian(Byte[] destination);
    public virtual int WriteExponentLittleEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteExponentLittleEndian(Span`1<byte> destination);
    public virtual int WriteSignificandBigEndian(Byte[] destination);
    public virtual int WriteSignificandBigEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteSignificandBigEndian(Span`1<byte> destination);
    public virtual int WriteSignificandLittleEndian(Byte[] destination);
    public virtual int WriteSignificandLittleEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteSignificandLittleEndian(Span`1<byte> destination);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IFloatingPointConstants`1 {
    public static TSelf E { get; }
    public static TSelf Pi { get; }
    public static TSelf Tau { get; }
    public static abstract virtual TSelf get_E();
    public static abstract virtual TSelf get_Pi();
    public static abstract virtual TSelf get_Tau();
}
[NullableContextAttribute("1")]
public interface System.Numerics.IFloatingPointIeee754`1 {
    public static TSelf Epsilon { get; }
    public static TSelf NaN { get; }
    public static TSelf NegativeInfinity { get; }
    public static TSelf NegativeZero { get; }
    public static TSelf PositiveInfinity { get; }
    public static abstract virtual TSelf get_Epsilon();
    public static abstract virtual TSelf get_NaN();
    public static abstract virtual TSelf get_NegativeInfinity();
    public static abstract virtual TSelf get_NegativeZero();
    public static abstract virtual TSelf get_PositiveInfinity();
    public static abstract virtual TSelf Atan2(TSelf y, TSelf x);
    public static abstract virtual TSelf Atan2Pi(TSelf y, TSelf x);
    public static abstract virtual TSelf BitDecrement(TSelf x);
    public static abstract virtual TSelf BitIncrement(TSelf x);
    public static abstract virtual TSelf FusedMultiplyAdd(TSelf left, TSelf right, TSelf addend);
    public static abstract virtual TSelf Ieee754Remainder(TSelf left, TSelf right);
    public static abstract virtual int ILogB(TSelf x);
    public static virtual TSelf Lerp(TSelf value1, TSelf value2, TSelf amount);
    public static virtual TSelf ReciprocalEstimate(TSelf x);
    public static virtual TSelf ReciprocalSqrtEstimate(TSelf x);
    public static abstract virtual TSelf ScaleB(TSelf x, int n);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IHyperbolicFunctions`1 {
    public static abstract virtual TSelf Acosh(TSelf x);
    public static abstract virtual TSelf Asinh(TSelf x);
    public static abstract virtual TSelf Atanh(TSelf x);
    public static abstract virtual TSelf Cosh(TSelf x);
    public static abstract virtual TSelf Sinh(TSelf x);
    public static abstract virtual TSelf Tanh(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IIncrementOperators`1 {
    public static abstract virtual TSelf op_Increment(TSelf value);
    public static virtual TSelf op_CheckedIncrement(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.ILogarithmicFunctions`1 {
    public static abstract virtual TSelf Log(TSelf x);
    public static abstract virtual TSelf Log(TSelf x, TSelf newBase);
    public static virtual TSelf LogP1(TSelf x);
    public static abstract virtual TSelf Log2(TSelf x);
    public static virtual TSelf Log2P1(TSelf x);
    public static abstract virtual TSelf Log10(TSelf x);
    public static virtual TSelf Log10P1(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IMinMaxValue`1 {
    public static TSelf MinValue { get; }
    public static TSelf MaxValue { get; }
    public static abstract virtual TSelf get_MinValue();
    public static abstract virtual TSelf get_MaxValue();
}
[NullableContextAttribute("2")]
public interface System.Numerics.IModulusOperators`3 {
    [NullableContextAttribute("1")]
public static abstract virtual TResult op_Modulus(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IMultiplicativeIdentity`2 {
    public static TResult MultiplicativeIdentity { get; }
    public static abstract virtual TResult get_MultiplicativeIdentity();
}
[NullableContextAttribute("1")]
public interface System.Numerics.IMultiplyOperators`3 {
    public static abstract virtual TResult op_Multiply(TSelf left, TOther right);
    public static virtual TResult op_CheckedMultiply(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.INumber`1 {
    public static virtual TSelf Clamp(TSelf value, TSelf min, TSelf max);
    public static virtual TSelf CopySign(TSelf value, TSelf sign);
    public static virtual TSelf Max(TSelf x, TSelf y);
    public static virtual TSelf MaxNumber(TSelf x, TSelf y);
    public static virtual TSelf Min(TSelf x, TSelf y);
    public static virtual TSelf MinNumber(TSelf x, TSelf y);
    public static virtual int Sign(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.INumberBase`1 {
    public static TSelf One { get; }
    public static int Radix { get; }
    public static TSelf Zero { get; }
    public static abstract virtual TSelf get_One();
    public static abstract virtual int get_Radix();
    public static abstract virtual TSelf get_Zero();
    public static abstract virtual TSelf Abs(TSelf value);
    [NullableContextAttribute("0")]
public static virtual TSelf CreateChecked(TOther value);
    [NullableContextAttribute("0")]
public static virtual TSelf CreateSaturating(TOther value);
    [NullableContextAttribute("0")]
public static virtual TSelf CreateTruncating(TOther value);
    public static abstract virtual bool IsCanonical(TSelf value);
    public static abstract virtual bool IsComplexNumber(TSelf value);
    public static abstract virtual bool IsEvenInteger(TSelf value);
    public static abstract virtual bool IsFinite(TSelf value);
    public static abstract virtual bool IsImaginaryNumber(TSelf value);
    public static abstract virtual bool IsInfinity(TSelf value);
    public static abstract virtual bool IsInteger(TSelf value);
    public static abstract virtual bool IsNaN(TSelf value);
    public static abstract virtual bool IsNegative(TSelf value);
    public static abstract virtual bool IsNegativeInfinity(TSelf value);
    public static abstract virtual bool IsNormal(TSelf value);
    public static abstract virtual bool IsOddInteger(TSelf value);
    public static abstract virtual bool IsPositive(TSelf value);
    public static abstract virtual bool IsPositiveInfinity(TSelf value);
    public static abstract virtual bool IsRealNumber(TSelf value);
    public static abstract virtual bool IsSubnormal(TSelf value);
    public static abstract virtual bool IsZero(TSelf value);
    public static abstract virtual TSelf MaxMagnitude(TSelf x, TSelf y);
    public static abstract virtual TSelf MaxMagnitudeNumber(TSelf x, TSelf y);
    public static abstract virtual TSelf MinMagnitude(TSelf x, TSelf y);
    public static abstract virtual TSelf MinMagnitudeNumber(TSelf x, TSelf y);
    public static abstract virtual TSelf Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static abstract virtual TSelf Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static virtual TSelf Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertFromChecked(TOther value, TSelf& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertFromSaturating(TOther value, TSelf& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertFromTruncating(TOther value, TSelf& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertToChecked(TSelf value, TOther& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertToSaturating(TSelf value, TOther& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertToTruncating(TSelf value, TOther& result);
    [NullableContextAttribute("2")]
public static abstract virtual bool TryParse(string s, NumberStyles style, IFormatProvider provider, TSelf& result);
    [NullableContextAttribute("0")]
public static abstract virtual bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, TSelf& result);
    [NullableContextAttribute("0")]
public static virtual bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, TSelf& result);
    private sealed virtual override bool System.IUtf8SpanFormattable.TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private static override TSelf System.IUtf8SpanParsable<TSelf>.Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    private static override bool System.IUtf8SpanParsable<TSelf>.TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, TSelf& result);
}
public interface System.Numerics.IPowerFunctions`1 {
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Pow(TSelf x, TSelf y);
}
public interface System.Numerics.IRootFunctions`1 {
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Cbrt(TSelf x);
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Hypot(TSelf x, TSelf y);
    [NullableContextAttribute("1")]
public static abstract virtual TSelf RootN(TSelf x, int n);
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Sqrt(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IShiftOperators`3 {
    public static abstract virtual TResult op_LeftShift(TSelf value, TOther shiftAmount);
    public static abstract virtual TResult op_RightShift(TSelf value, TOther shiftAmount);
    public static abstract virtual TResult op_UnsignedRightShift(TSelf value, TOther shiftAmount);
}
public interface System.Numerics.ISignedNumber`1 {
    [NullableAttribute("1")]
public static TSelf NegativeOne { get; }
    [NullableContextAttribute("1")]
public static abstract virtual TSelf get_NegativeOne();
}
[NullableContextAttribute("1")]
public interface System.Numerics.ISubtractionOperators`3 {
    public static abstract virtual TResult op_Subtraction(TSelf left, TOther right);
    public static virtual TResult op_CheckedSubtraction(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.ITrigonometricFunctions`1 {
    public static abstract virtual TSelf Acos(TSelf x);
    public static abstract virtual TSelf AcosPi(TSelf x);
    public static abstract virtual TSelf Asin(TSelf x);
    public static abstract virtual TSelf AsinPi(TSelf x);
    public static abstract virtual TSelf Atan(TSelf x);
    public static abstract virtual TSelf AtanPi(TSelf x);
    public static abstract virtual TSelf Cos(TSelf x);
    public static abstract virtual TSelf CosPi(TSelf x);
    public static virtual TSelf DegreesToRadians(TSelf degrees);
    public static virtual TSelf RadiansToDegrees(TSelf radians);
    public static abstract virtual TSelf Sin(TSelf x);
    public static abstract virtual ValueTuple`2<TSelf, TSelf> SinCos(TSelf x);
    public static abstract virtual ValueTuple`2<TSelf, TSelf> SinCosPi(TSelf x);
    public static abstract virtual TSelf SinPi(TSelf x);
    public static abstract virtual TSelf Tan(TSelf x);
    public static abstract virtual TSelf TanPi(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IUnaryNegationOperators`2 {
    public static abstract virtual TResult op_UnaryNegation(TSelf value);
    public static virtual TResult op_CheckedUnaryNegation(TSelf value);
}
public interface System.Numerics.IUnaryPlusOperators`2 {
    [NullableContextAttribute("1")]
public static abstract virtual TResult op_UnaryPlus(TSelf value);
}
public interface System.Numerics.IUnsignedNumber`1 {
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Matrix3x2 : ValueType {
    public float M11;
    public float M12;
    public float M21;
    public float M22;
    public float M31;
    public float M32;
    public static Matrix3x2 Identity { get; }
    public float Item { get; public set; }
    public bool IsIdentity { get; }
    public Vector2 Translation { get; public set; }
    public Matrix3x2(float m11, float m12, float m21, float m22, float m31, float m32);
    public static Matrix3x2 get_Identity();
    [IsReadOnlyAttribute]
public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    [IsReadOnlyAttribute]
public Vector2 get_Translation();
    public void set_Translation(Vector2 value);
    public static Matrix3x2 op_Addition(Matrix3x2 value1, Matrix3x2 value2);
    public static bool op_Equality(Matrix3x2 value1, Matrix3x2 value2);
    public static bool op_Inequality(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 op_Multiply(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 op_Multiply(Matrix3x2 value1, float value2);
    public static Matrix3x2 op_Subtraction(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 op_UnaryNegation(Matrix3x2 value);
    public static Matrix3x2 Add(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 CreateRotation(float radians);
    public static Matrix3x2 CreateRotation(float radians, Vector2 centerPoint);
    public static Matrix3x2 CreateScale(Vector2 scales);
    public static Matrix3x2 CreateScale(float xScale, float yScale);
    public static Matrix3x2 CreateScale(float xScale, float yScale, Vector2 centerPoint);
    public static Matrix3x2 CreateScale(Vector2 scales, Vector2 centerPoint);
    public static Matrix3x2 CreateScale(float scale);
    public static Matrix3x2 CreateScale(float scale, Vector2 centerPoint);
    public static Matrix3x2 CreateSkew(float radiansX, float radiansY);
    public static Matrix3x2 CreateSkew(float radiansX, float radiansY, Vector2 centerPoint);
    public static Matrix3x2 CreateTranslation(Vector2 position);
    public static Matrix3x2 CreateTranslation(float xPosition, float yPosition);
    public static bool Invert(Matrix3x2 matrix, Matrix3x2& result);
    public static Matrix3x2 Lerp(Matrix3x2 matrix1, Matrix3x2 matrix2, float amount);
    public static Matrix3x2 Multiply(Matrix3x2 value1, Matrix3x2 value2);
    public static Matrix3x2 Multiply(Matrix3x2 value1, float value2);
    public static Matrix3x2 Negate(Matrix3x2 value);
    public static Matrix3x2 Subtract(Matrix3x2 value1, Matrix3x2 value2);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Matrix3x2 other);
    [IsReadOnlyAttribute]
public float GetDeterminant();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [UnscopedRefAttribute]
internal Impl& AsImpl();
    [IsReadOnlyAttribute]
[UnscopedRefAttribute]
internal Impl& modreq(System.Runtime.InteropServices.InAttribute) AsROImpl();
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Matrix4x4 : ValueType {
    public float M11;
    public float M12;
    public float M13;
    public float M14;
    public float M21;
    public float M22;
    public float M23;
    public float M24;
    public float M31;
    public float M32;
    public float M33;
    public float M34;
    public float M41;
    public float M42;
    public float M43;
    public float M44;
    public static Matrix4x4 Identity { get; }
    public float Item { get; public set; }
    public bool IsIdentity { get; }
    public Vector3 Translation { get; public set; }
    public Matrix4x4(float m11, float m12, float m13, float m14, float m21, float m22, float m23, float m24, float m31, float m32, float m33, float m34, float m41, float m42, float m43, float m44);
    public Matrix4x4(Matrix3x2 value);
    public static Matrix4x4 get_Identity();
    [IsReadOnlyAttribute]
public float get_Item(int row, int column);
    public void set_Item(int row, int column, float value);
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    [IsReadOnlyAttribute]
public Vector3 get_Translation();
    public void set_Translation(Vector3 value);
    public static Matrix4x4 op_Addition(Matrix4x4 value1, Matrix4x4 value2);
    public static bool op_Equality(Matrix4x4 value1, Matrix4x4 value2);
    public static bool op_Inequality(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 op_Multiply(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 op_Multiply(Matrix4x4 value1, float value2);
    public static Matrix4x4 op_Subtraction(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 op_UnaryNegation(Matrix4x4 value);
    public static Matrix4x4 Add(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 CreateBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 cameraUpVector, Vector3 cameraForwardVector);
    public static Matrix4x4 CreateConstrainedBillboard(Vector3 objectPosition, Vector3 cameraPosition, Vector3 rotateAxis, Vector3 cameraForwardVector, Vector3 objectForwardVector);
    public static Matrix4x4 CreateFromAxisAngle(Vector3 axis, float angle);
    public static Matrix4x4 CreateFromQuaternion(Quaternion quaternion);
    public static Matrix4x4 CreateFromYawPitchRoll(float yaw, float pitch, float roll);
    public static Matrix4x4 CreateLookAt(Vector3 cameraPosition, Vector3 cameraTarget, Vector3 cameraUpVector);
    public static Matrix4x4 CreateLookAtLeftHanded(Vector3 cameraPosition, Vector3 cameraTarget, Vector3 cameraUpVector);
    public static Matrix4x4 CreateLookTo(Vector3 cameraPosition, Vector3 cameraDirection, Vector3 cameraUpVector);
    public static Matrix4x4 CreateLookToLeftHanded(Vector3 cameraPosition, Vector3 cameraDirection, Vector3 cameraUpVector);
    public static Matrix4x4 CreateOrthographic(float width, float height, float zNearPlane, float zFarPlane);
    public static Matrix4x4 CreateOrthographicLeftHanded(float width, float height, float zNearPlane, float zFarPlane);
    public static Matrix4x4 CreateOrthographicOffCenter(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane);
    public static Matrix4x4 CreateOrthographicOffCenterLeftHanded(float left, float right, float bottom, float top, float zNearPlane, float zFarPlane);
    public static Matrix4x4 CreatePerspective(float width, float height, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveLeftHanded(float width, float height, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveFieldOfView(float fieldOfView, float aspectRatio, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveFieldOfViewLeftHanded(float fieldOfView, float aspectRatio, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveOffCenter(float left, float right, float bottom, float top, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreatePerspectiveOffCenterLeftHanded(float left, float right, float bottom, float top, float nearPlaneDistance, float farPlaneDistance);
    public static Matrix4x4 CreateReflection(Plane value);
    public static Matrix4x4 CreateRotationX(float radians);
    public static Matrix4x4 CreateRotationX(float radians, Vector3 centerPoint);
    public static Matrix4x4 CreateRotationY(float radians);
    public static Matrix4x4 CreateRotationY(float radians, Vector3 centerPoint);
    public static Matrix4x4 CreateRotationZ(float radians);
    public static Matrix4x4 CreateRotationZ(float radians, Vector3 centerPoint);
    public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale);
    public static Matrix4x4 CreateScale(float xScale, float yScale, float zScale, Vector3 centerPoint);
    public static Matrix4x4 CreateScale(Vector3 scales);
    public static Matrix4x4 CreateScale(Vector3 scales, Vector3 centerPoint);
    public static Matrix4x4 CreateScale(float scale);
    public static Matrix4x4 CreateScale(float scale, Vector3 centerPoint);
    public static Matrix4x4 CreateShadow(Vector3 lightDirection, Plane plane);
    public static Matrix4x4 CreateTranslation(Vector3 position);
    public static Matrix4x4 CreateTranslation(float xPosition, float yPosition, float zPosition);
    public static Matrix4x4 CreateViewport(float x, float y, float width, float height, float minDepth, float maxDepth);
    public static Matrix4x4 CreateViewportLeftHanded(float x, float y, float width, float height, float minDepth, float maxDepth);
    public static Matrix4x4 CreateWorld(Vector3 position, Vector3 forward, Vector3 up);
    public static bool Decompose(Matrix4x4 matrix, Vector3& scale, Quaternion& rotation, Vector3& translation);
    public static bool Invert(Matrix4x4 matrix, Matrix4x4& result);
    public static Matrix4x4 Lerp(Matrix4x4 matrix1, Matrix4x4 matrix2, float amount);
    public static Matrix4x4 Multiply(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 Multiply(Matrix4x4 value1, float value2);
    public static Matrix4x4 Negate(Matrix4x4 value);
    public static Matrix4x4 Subtract(Matrix4x4 value1, Matrix4x4 value2);
    public static Matrix4x4 Transform(Matrix4x4 value, Quaternion rotation);
    public static Matrix4x4 Transpose(Matrix4x4 matrix);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Matrix4x4 other);
    [IsReadOnlyAttribute]
public float GetDeterminant();
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [UnscopedRefAttribute]
internal Impl& AsImpl();
    [IsReadOnlyAttribute]
[UnscopedRefAttribute]
internal Impl& modreq(System.Runtime.InteropServices.InAttribute) AsROImpl();
}
[IntrinsicAttribute]
public class System.Numerics.Plane : ValueType {
    public Vector3 Normal;
    public float D;
    [IntrinsicAttribute]
public Plane(float x, float y, float z, float d);
    [IntrinsicAttribute]
public Plane(Vector3 normal, float d);
    [IntrinsicAttribute]
public Plane(Vector4 value);
    public static Plane CreateFromVertices(Vector3 point1, Vector3 point2, Vector3 point3);
    [IntrinsicAttribute]
public static float Dot(Plane plane, Vector4 value);
    public static float DotCoordinate(Plane plane, Vector3 value);
    public static float DotNormal(Plane plane, Vector3 value);
    public static Plane Normalize(Plane value);
    public static Plane Transform(Plane plane, Matrix4x4 matrix);
    public static Plane Transform(Plane plane, Quaternion rotation);
    [IntrinsicAttribute]
public static bool op_Equality(Plane value1, Plane value2);
    [IntrinsicAttribute]
public static bool op_Inequality(Plane value1, Plane value2);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Plane other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|16_0(Plane& self, Plane other);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Quaternion : ValueType {
    public float X;
    public float Y;
    public float Z;
    public float W;
    public static Quaternion Zero { get; }
    public static Quaternion Identity { get; }
    public float Item { get; public set; }
    public bool IsIdentity { get; }
    [IntrinsicAttribute]
public Quaternion(float x, float y, float z, float w);
    [IntrinsicAttribute]
public Quaternion(Vector3 vectorPart, float scalarPart);
    [IntrinsicAttribute]
public static Quaternion get_Zero();
    [IntrinsicAttribute]
public static Quaternion get_Identity();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float get_Item(int index);
    public void set_Item(int index, float value);
    [IsReadOnlyAttribute]
public bool get_IsIdentity();
    [IntrinsicAttribute]
public static Quaternion op_Addition(Quaternion value1, Quaternion value2);
    public static Quaternion op_Division(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
public static bool op_Equality(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
public static bool op_Inequality(Quaternion value1, Quaternion value2);
    public static Quaternion op_Multiply(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
public static Quaternion op_Multiply(Quaternion value1, float value2);
    [IntrinsicAttribute]
public static Quaternion op_Subtraction(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
public static Quaternion op_UnaryNegation(Quaternion value);
    [IntrinsicAttribute]
public static Quaternion Add(Quaternion value1, Quaternion value2);
    public static Quaternion Concatenate(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
public static Quaternion Conjugate(Quaternion value);
    public static Quaternion CreateFromAxisAngle(Vector3 axis, float angle);
    public static Quaternion CreateFromRotationMatrix(Matrix4x4 matrix);
    public static Quaternion CreateFromYawPitchRoll(float yaw, float pitch, float roll);
    public static Quaternion Divide(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
internal static Quaternion Divide(Quaternion left, float divisor);
    [IntrinsicAttribute]
public static float Dot(Quaternion quaternion1, Quaternion quaternion2);
    [IntrinsicAttribute]
public static Quaternion Inverse(Quaternion value);
    public static Quaternion Lerp(Quaternion quaternion1, Quaternion quaternion2, float amount);
    public static Quaternion Multiply(Quaternion value1, Quaternion value2);
    [IntrinsicAttribute]
internal static Quaternion Multiply(Quaternion value1, Vector4 value2);
    [IntrinsicAttribute]
public static Quaternion Multiply(Quaternion value1, float value2);
    [IntrinsicAttribute]
public static Quaternion Negate(Quaternion value);
    [IntrinsicAttribute]
public static Quaternion Normalize(Quaternion value);
    public static Quaternion Slerp(Quaternion quaternion1, Quaternion quaternion2, float amount);
    [IntrinsicAttribute]
public static Quaternion Subtract(Quaternion value1, Quaternion value2);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Quaternion other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float Length();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float LengthSquared();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|44_0(Quaternion& self, Quaternion other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Numerics.TotalOrderIeee754Comparer`1 : ValueType {
    public sealed virtual int Compare(T x, T y);
    public sealed virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public sealed virtual int GetHashCode(T obj);
    public sealed virtual bool Equals(TotalOrderIeee754Comparer`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static int <Compare>g__CompareIntegerSemantic|0_0(TInteger x, TInteger y);
    [CompilerGeneratedAttribute]
internal static int <Compare>g__CompareGeneric|0_1(T x, T y);
    [CompilerGeneratedAttribute]
internal static int <Compare>g__CompareSignificand|0_2(T x, T y);
}
[ExtensionAttribute]
[IntrinsicAttribute]
public static class System.Numerics.Vector : object {
    internal static UIntPtr Alignment;
    public static bool IsHardwareAccelerated { get; }
    private static Vector();
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static float GetElement(Quaternion quaternion, int index);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Quaternion WithElement(Quaternion quaternion, int index, float value);
    [ExtensionAttribute]
private static float GetElementUnsafe(Quaternion& quaternion, int index);
    [ExtensionAttribute]
private static void SetElementUnsafe(Quaternion& quaternion, int index, float value);
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Abs(Vector`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Add(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> AndNot(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector`1<TTo> As(Vector`1<TFrom> vector);
    [IntrinsicAttribute]
public static Vector`1<byte> AsVectorByte(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> AsVectorDouble(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> AsVectorInt16(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> AsVectorInt32(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> AsVectorInt64(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<IntPtr> AsVectorNInt(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UIntPtr> AsVectorNUInt(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> AsVectorSByte(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> AsVectorSingle(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> AsVectorUInt16(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> AsVectorUInt32(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> AsVectorUInt64(Vector`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<double> Ceiling(Vector`1<double> value);
    [IntrinsicAttribute]
public static Vector`1<float> Ceiling(Vector`1<float> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> ConditionalSelect(Vector`1<T> condition, Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<float> ConditionalSelect(Vector`1<int> condition, Vector`1<float> left, Vector`1<float> right);
    [IntrinsicAttribute]
public static Vector`1<double> ConditionalSelect(Vector`1<long> condition, Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<double> ConvertToDouble(Vector`1<long> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<double> ConvertToDouble(Vector`1<ulong> value);
    [IntrinsicAttribute]
public static Vector`1<int> ConvertToInt32(Vector`1<float> value);
    [IntrinsicAttribute]
public static Vector`1<long> ConvertToInt64(Vector`1<double> value);
    [IntrinsicAttribute]
public static Vector`1<float> ConvertToSingle(Vector`1<int> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<float> ConvertToSingle(Vector`1<UInt32> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> ConvertToUInt32(Vector`1<float> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> ConvertToUInt64(Vector`1<double> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Divide(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> Divide(Vector`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Dot(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Equals(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<long> Equals(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<int> Equals(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> Equals(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<int> Equals(Vector`1<float> left, Vector`1<float> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAll(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAny(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<double> Floor(Vector`1<double> value);
    [IntrinsicAttribute]
public static Vector`1<float> Floor(Vector`1<float> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T GetElement(Vector`1<T> vector, int index);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> GreaterThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThan(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThan(Vector`1<int> left, Vector`1<int> right);
    public static Vector`1<long> GreaterThan(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThan(Vector`1<float> left, Vector`1<float> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAll(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAny(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> GreaterThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> GreaterThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<int> GreaterThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> LessThan(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThan(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThan(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThan(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThan(Vector`1<float> left, Vector`1<float> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAll(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAny(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> LessThanOrEqual(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThanOrEqual(Vector`1<double> left, Vector`1<double> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThanOrEqual(Vector`1<int> left, Vector`1<int> right);
    [IntrinsicAttribute]
public static Vector`1<long> LessThanOrEqual(Vector`1<long> left, Vector`1<long> right);
    [IntrinsicAttribute]
public static Vector`1<int> LessThanOrEqual(Vector`1<float> left, Vector`1<float> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAll(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAny(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<T> Load(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<T> LoadAligned(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<T> LoadAlignedNonTemporal(T* source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> LoadUnsafe(T& source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<T> LoadUnsafe(T& source, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Max(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Min(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Multiply(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> Multiply(Vector`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> Multiply(T left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<float> Narrow(Vector`1<double> low, Vector`1<double> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> Narrow(Vector`1<short> low, Vector`1<short> high);
    [IntrinsicAttribute]
public static Vector`1<short> Narrow(Vector`1<int> low, Vector`1<int> high);
    [IntrinsicAttribute]
public static Vector`1<int> Narrow(Vector`1<long> low, Vector`1<long> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<byte> Narrow(Vector`1<ushort> low, Vector`1<ushort> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> Narrow(Vector`1<UInt32> low, Vector`1<UInt32> high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> Narrow(Vector`1<ulong> low, Vector`1<ulong> high);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Negate(Vector`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> OnesComplement(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<byte> ShiftLeft(Vector`1<byte> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<short> ShiftLeft(Vector`1<short> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<int> ShiftLeft(Vector`1<int> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<long> ShiftLeft(Vector`1<long> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<IntPtr> ShiftLeft(Vector`1<IntPtr> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UIntPtr> ShiftLeft(Vector`1<UIntPtr> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> ShiftLeft(Vector`1<sbyte> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> ShiftLeft(Vector`1<ushort> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> ShiftLeft(Vector`1<UInt32> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> ShiftLeft(Vector`1<ulong> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<short> ShiftRightArithmetic(Vector`1<short> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<int> ShiftRightArithmetic(Vector`1<int> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<long> ShiftRightArithmetic(Vector`1<long> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<IntPtr> ShiftRightArithmetic(Vector`1<IntPtr> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> ShiftRightArithmetic(Vector`1<sbyte> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<byte> ShiftRightLogical(Vector`1<byte> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<short> ShiftRightLogical(Vector`1<short> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<int> ShiftRightLogical(Vector`1<int> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<long> ShiftRightLogical(Vector`1<long> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<IntPtr> ShiftRightLogical(Vector`1<IntPtr> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UIntPtr> ShiftRightLogical(Vector`1<UIntPtr> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> ShiftRightLogical(Vector`1<sbyte> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> ShiftRightLogical(Vector`1<ushort> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> ShiftRightLogical(Vector`1<UInt32> value, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> ShiftRightLogical(Vector`1<ulong> value, int shiftCount);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> SquareRoot(Vector`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Store(Vector`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAligned(Vector`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAlignedNonTemporal(Vector`1<T> source, T* destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static void StoreUnsafe(Vector`1<T> source, T& destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreUnsafe(Vector`1<T> source, T& destination, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Subtract(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Sum(Vector`1<T> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T ToScalar(Vector`1<T> vector);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<byte> source, Vector`1& low, Vector`1& high);
    public static void Widen(Vector`1<short> source, Vector`1& low, Vector`1& high);
    public static void Widen(Vector`1<int> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<sbyte> source, Vector`1& low, Vector`1& high);
    public static void Widen(Vector`1<float> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<ushort> source, Vector`1& low, Vector`1& high);
    [CLSCompliantAttribute("False")]
public static void Widen(Vector`1<UInt32> source, Vector`1& low, Vector`1& high);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> WidenLower(Vector`1<byte> source);
    [IntrinsicAttribute]
public static Vector`1<int> WidenLower(Vector`1<short> source);
    [IntrinsicAttribute]
public static Vector`1<long> WidenLower(Vector`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<short> WidenLower(Vector`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector`1<double> WidenLower(Vector`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> WidenLower(Vector`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> WidenLower(Vector`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> WidenUpper(Vector`1<byte> source);
    [IntrinsicAttribute]
public static Vector`1<int> WidenUpper(Vector`1<short> source);
    [IntrinsicAttribute]
public static Vector`1<long> WidenUpper(Vector`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<short> WidenUpper(Vector`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector`1<double> WidenUpper(Vector`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> WidenUpper(Vector`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> WidenUpper(Vector`1<UInt32> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Vector`1<T> WithElement(Vector`1<T> vector, int index, T value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector`1<T> Xor(Vector`1<T> left, Vector`1<T> right);
    [ExtensionAttribute]
internal static T GetElementUnsafe(Vector`1& vector, int index);
    [ExtensionAttribute]
internal static void SetElementUnsafe(Vector`1& vector, int index, T value);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static float GetElement(Vector2 vector, int index);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Vector2 WithElement(Vector2 vector, int index, float value);
    [ExtensionAttribute]
private static float GetElementUnsafe(Vector2& vector, int index);
    [ExtensionAttribute]
private static void SetElementUnsafe(Vector2& vector, int index, float value);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static float GetElement(Vector3 vector, int index);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Vector3 WithElement(Vector3 vector, int index, float value);
    [ExtensionAttribute]
private static float GetElementUnsafe(Vector3& vector, int index);
    [ExtensionAttribute]
private static void SetElementUnsafe(Vector3& vector, int index, float value);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static float GetElement(Vector4 vector, int index);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Vector4 WithElement(Vector4 vector, int index, float value);
    [ExtensionAttribute]
private static float GetElementUnsafe(Vector4& vector, int index);
    [ExtensionAttribute]
private static void SetElementUnsafe(Vector4& vector, int index, float value);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Numerics.VectorDebugView`1")]
public class System.Numerics.Vector`1 : ValueType {
    internal ulong _00;
    internal ulong _01;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector`1<T> AllBitsSet { get; }
    public static int Count { get; }
    public static bool IsSupported { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector`1<T> One { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector`1<T> Zero { get; }
    [NullableAttribute("1")]
internal string DisplayString { get; }
    [NullableAttribute("1")]
public T Item { get; }
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public Vector`1(T value);
    [NullableContextAttribute("1")]
public Vector`1(T[] values);
    [NullableContextAttribute("1")]
public Vector`1(T[] values, int index);
    public Vector`1(ReadOnlySpan`1<T> values);
    public Vector`1(ReadOnlySpan`1<byte> values);
    public Vector`1(Span`1<T> values);
    [IntrinsicAttribute]
public static Vector`1<T> get_AllBitsSet();
    [IntrinsicAttribute]
public static int get_Count();
    public static bool get_IsSupported();
    [IntrinsicAttribute]
public static Vector`1<T> get_One();
    [IntrinsicAttribute]
public static Vector`1<T> get_Zero();
    internal string get_DisplayString();
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public T get_Item(int index);
    [IntrinsicAttribute]
public static Vector`1<T> op_Addition(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseAnd(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_BitwiseOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_Division(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> op_Division(Vector`1<T> left, T right);
    [IntrinsicAttribute]
public static bool op_Equality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_ExclusiveOr(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<byte> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<double> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<short> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<int> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<long> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<IntPtr> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UIntPtr> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<sbyte> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<float> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ushort> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<UInt32> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector`1<ulong> op_Explicit(Vector`1<T> value);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_LeftShift(Vector`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<T> op_Multiply(Vector`1<T> left, Vector`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> op_Multiply(Vector`1<T> value, T factor);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector`1<T> op_Multiply(T factor, Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_OnesComplement(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_RightShift(Vector`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector`1<T> op_Subtraction(Vector`1<T> left, Vector`1<T> right);
    [IntrinsicAttribute]
public static Vector`1<T> op_UnaryNegation(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_UnaryPlus(Vector`1<T> value);
    [IntrinsicAttribute]
public static Vector`1<T> op_UnsignedRightShift(Vector`1<T> value, int shiftCount);
    [NullableContextAttribute("1")]
public void CopyTo(T[] destination);
    [NullableContextAttribute("1")]
public void CopyTo(T[] destination, int startIndex);
    public void CopyTo(Span`1<byte> destination);
    public void CopyTo(Span`1<T> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Vector`1<T> other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public bool TryCopyTo(Span`1<byte> destination);
    public bool TryCopyTo(Span`1<T> destination);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|57_0(Vector`1& self, Vector`1<T> other);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Vector2 : ValueType {
    public float X;
    public float Y;
    public static Vector2 Zero { get; }
    public static Vector2 One { get; }
    public static Vector2 UnitX { get; }
    public static Vector2 UnitY { get; }
    public float Item { get; public set; }
    [IntrinsicAttribute]
public Vector2(float value);
    [IntrinsicAttribute]
public Vector2(float x, float y);
    public Vector2(ReadOnlySpan`1<float> values);
    [IntrinsicAttribute]
public static Vector2 get_Zero();
    [IntrinsicAttribute]
public static Vector2 get_One();
    [IntrinsicAttribute]
public static Vector2 get_UnitX();
    [IntrinsicAttribute]
public static Vector2 get_UnitY();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float get_Item(int index);
    public void set_Item(int index, float value);
    [IntrinsicAttribute]
public static Vector2 op_Addition(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 op_Division(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 op_Division(Vector2 value1, float value2);
    [IntrinsicAttribute]
public static bool op_Equality(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 op_Multiply(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 op_Multiply(Vector2 left, float right);
    [IntrinsicAttribute]
public static Vector2 op_Multiply(float left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 op_Subtraction(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 op_UnaryNegation(Vector2 value);
    [IntrinsicAttribute]
public static Vector2 Abs(Vector2 value);
    [IntrinsicAttribute]
public static Vector2 Add(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 Clamp(Vector2 value1, Vector2 min, Vector2 max);
    [IntrinsicAttribute]
public static float Distance(Vector2 value1, Vector2 value2);
    [IntrinsicAttribute]
public static float DistanceSquared(Vector2 value1, Vector2 value2);
    [IntrinsicAttribute]
public static Vector2 Divide(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 Divide(Vector2 left, float divisor);
    [IntrinsicAttribute]
public static float Dot(Vector2 value1, Vector2 value2);
    [IntrinsicAttribute]
public static Vector2 Lerp(Vector2 value1, Vector2 value2, float amount);
    [IntrinsicAttribute]
public static Vector2 Max(Vector2 value1, Vector2 value2);
    [IntrinsicAttribute]
public static Vector2 Min(Vector2 value1, Vector2 value2);
    [IntrinsicAttribute]
public static Vector2 Multiply(Vector2 left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 Multiply(Vector2 left, float right);
    [IntrinsicAttribute]
public static Vector2 Multiply(float left, Vector2 right);
    [IntrinsicAttribute]
public static Vector2 Negate(Vector2 value);
    [IntrinsicAttribute]
public static Vector2 Normalize(Vector2 value);
    public static Vector2 Reflect(Vector2 vector, Vector2 normal);
    [IntrinsicAttribute]
public static Vector2 SquareRoot(Vector2 value);
    [IntrinsicAttribute]
public static Vector2 Subtract(Vector2 left, Vector2 right);
    public static Vector2 Transform(Vector2 position, Matrix3x2 matrix);
    internal static Vector2 Transform(Vector2 position, Impl& matrix);
    public static Vector2 Transform(Vector2 position, Matrix4x4 matrix);
    public static Vector2 Transform(Vector2 value, Quaternion rotation);
    public static Vector2 TransformNormal(Vector2 normal, Matrix3x2 matrix);
    internal static Vector2 TransformNormal(Vector2 normal, Impl& matrix);
    public static Vector2 TransformNormal(Vector2 normal, Matrix4x4 matrix);
    internal static Vector2 TransformNormal(Vector2 normal, Impl& matrix);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public void CopyTo(Single[] array);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public void CopyTo(Single[] array, int index);
    [IsReadOnlyAttribute]
public void CopyTo(Span`1<float> destination);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<float> destination);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector2 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float Length();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float LengthSquared();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public string ToString(string format);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|59_0(Vector2& self, Vector2 other);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Vector3 : ValueType {
    public float X;
    public float Y;
    public float Z;
    public static Vector3 Zero { get; }
    public static Vector3 One { get; }
    public static Vector3 UnitX { get; }
    public static Vector3 UnitY { get; }
    public static Vector3 UnitZ { get; }
    public float Item { get; public set; }
    [IntrinsicAttribute]
public Vector3(float value);
    [IntrinsicAttribute]
public Vector3(Vector2 value, float z);
    [IntrinsicAttribute]
public Vector3(float x, float y, float z);
    public Vector3(ReadOnlySpan`1<float> values);
    [IntrinsicAttribute]
public static Vector3 get_Zero();
    [IntrinsicAttribute]
public static Vector3 get_One();
    [IntrinsicAttribute]
public static Vector3 get_UnitX();
    [IntrinsicAttribute]
public static Vector3 get_UnitY();
    [IntrinsicAttribute]
public static Vector3 get_UnitZ();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float get_Item(int index);
    public void set_Item(int index, float value);
    [IntrinsicAttribute]
public static Vector3 op_Addition(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 op_Division(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 op_Division(Vector3 value1, float value2);
    [IntrinsicAttribute]
public static bool op_Equality(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 op_Multiply(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 op_Multiply(Vector3 left, float right);
    [IntrinsicAttribute]
public static Vector3 op_Multiply(float left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 op_Subtraction(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 op_UnaryNegation(Vector3 value);
    [IntrinsicAttribute]
public static Vector3 Abs(Vector3 value);
    [IntrinsicAttribute]
public static Vector3 Add(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 Clamp(Vector3 value1, Vector3 min, Vector3 max);
    public static Vector3 Cross(Vector3 vector1, Vector3 vector2);
    [IntrinsicAttribute]
public static float Distance(Vector3 value1, Vector3 value2);
    [IntrinsicAttribute]
public static float DistanceSquared(Vector3 value1, Vector3 value2);
    [IntrinsicAttribute]
public static Vector3 Divide(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 Divide(Vector3 left, float divisor);
    [IntrinsicAttribute]
public static float Dot(Vector3 vector1, Vector3 vector2);
    [IntrinsicAttribute]
public static Vector3 Lerp(Vector3 value1, Vector3 value2, float amount);
    [IntrinsicAttribute]
public static Vector3 Max(Vector3 value1, Vector3 value2);
    [IntrinsicAttribute]
public static Vector3 Min(Vector3 value1, Vector3 value2);
    [IntrinsicAttribute]
public static Vector3 Multiply(Vector3 left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 Multiply(Vector3 left, float right);
    [IntrinsicAttribute]
public static Vector3 Multiply(float left, Vector3 right);
    [IntrinsicAttribute]
public static Vector3 Negate(Vector3 value);
    [IntrinsicAttribute]
public static Vector3 Normalize(Vector3 value);
    public static Vector3 Reflect(Vector3 vector, Vector3 normal);
    [IntrinsicAttribute]
public static Vector3 SquareRoot(Vector3 value);
    [IntrinsicAttribute]
public static Vector3 Subtract(Vector3 left, Vector3 right);
    public static Vector3 Transform(Vector3 position, Matrix4x4 matrix);
    public static Vector3 Transform(Vector3 value, Quaternion rotation);
    public static Vector3 TransformNormal(Vector3 normal, Matrix4x4 matrix);
    internal static Vector3 TransformNormal(Vector3 normal, Impl& matrix);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public void CopyTo(Single[] array);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public void CopyTo(Single[] array, int index);
    [IsReadOnlyAttribute]
public void CopyTo(Span`1<float> destination);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<float> destination);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector3 other);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float Length();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float LengthSquared();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public string ToString(string format);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|60_0(Vector3& self, Vector3 other);
}
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
public class System.Numerics.Vector4 : ValueType {
    public float X;
    public float Y;
    public float Z;
    public float W;
    public static Vector4 Zero { get; }
    public static Vector4 One { get; }
    public static Vector4 UnitX { get; }
    public static Vector4 UnitY { get; }
    public static Vector4 UnitZ { get; }
    public static Vector4 UnitW { get; }
    public float Item { get; public set; }
    [IntrinsicAttribute]
public Vector4(float value);
    [IntrinsicAttribute]
public Vector4(Vector2 value, float z, float w);
    [IntrinsicAttribute]
public Vector4(Vector3 value, float w);
    [IntrinsicAttribute]
public Vector4(float x, float y, float z, float w);
    public Vector4(ReadOnlySpan`1<float> values);
    [IntrinsicAttribute]
public static Vector4 get_Zero();
    [IntrinsicAttribute]
public static Vector4 get_One();
    [IntrinsicAttribute]
public static Vector4 get_UnitX();
    [IntrinsicAttribute]
public static Vector4 get_UnitY();
    [IntrinsicAttribute]
public static Vector4 get_UnitZ();
    [IntrinsicAttribute]
public static Vector4 get_UnitW();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float get_Item(int index);
    public void set_Item(int index, float value);
    [IntrinsicAttribute]
public static Vector4 op_Addition(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 op_Division(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 op_Division(Vector4 value1, float value2);
    [IntrinsicAttribute]
public static bool op_Equality(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 op_Multiply(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 op_Multiply(Vector4 left, float right);
    [IntrinsicAttribute]
public static Vector4 op_Multiply(float left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 op_Subtraction(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 op_UnaryNegation(Vector4 value);
    [IntrinsicAttribute]
public static Vector4 Abs(Vector4 value);
    [IntrinsicAttribute]
public static Vector4 Add(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 Clamp(Vector4 value1, Vector4 min, Vector4 max);
    [IntrinsicAttribute]
public static float Distance(Vector4 value1, Vector4 value2);
    [IntrinsicAttribute]
public static float DistanceSquared(Vector4 value1, Vector4 value2);
    [IntrinsicAttribute]
public static Vector4 Divide(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 Divide(Vector4 left, float divisor);
    [IntrinsicAttribute]
public static float Dot(Vector4 vector1, Vector4 vector2);
    [IntrinsicAttribute]
public static Vector4 Lerp(Vector4 value1, Vector4 value2, float amount);
    [IntrinsicAttribute]
public static Vector4 Max(Vector4 value1, Vector4 value2);
    [IntrinsicAttribute]
public static Vector4 Min(Vector4 value1, Vector4 value2);
    [IntrinsicAttribute]
public static Vector4 Multiply(Vector4 left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 Multiply(Vector4 left, float right);
    [IntrinsicAttribute]
public static Vector4 Multiply(float left, Vector4 right);
    [IntrinsicAttribute]
public static Vector4 Negate(Vector4 value);
    [IntrinsicAttribute]
public static Vector4 Normalize(Vector4 vector);
    [IntrinsicAttribute]
public static Vector4 SquareRoot(Vector4 value);
    [IntrinsicAttribute]
public static Vector4 Subtract(Vector4 left, Vector4 right);
    public static Vector4 Transform(Vector2 position, Matrix4x4 matrix);
    internal static Vector4 Transform(Vector2 position, Impl& matrix);
    public static Vector4 Transform(Vector2 value, Quaternion rotation);
    public static Vector4 Transform(Vector3 position, Matrix4x4 matrix);
    internal static Vector4 Transform(Vector3 position, Impl& matrix);
    public static Vector4 Transform(Vector3 value, Quaternion rotation);
    public static Vector4 Transform(Vector4 vector, Matrix4x4 matrix);
    internal static Vector4 Transform(Vector4 vector, Impl& matrix);
    public static Vector4 Transform(Vector4 value, Quaternion rotation);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public void CopyTo(Single[] array);
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public void CopyTo(Single[] array, int index);
    [IsReadOnlyAttribute]
public void CopyTo(Span`1<float> destination);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<float> destination);
    [IsReadOnlyAttribute]
public sealed virtual bool Equals(Vector4 other);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float Length();
    [IsReadOnlyAttribute]
[IntrinsicAttribute]
public float LengthSquared();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("1")]
public string ToString(string format);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|66_0(Vector4& self, Vector4 other);
}
[IsReadOnlyAttribute]
internal class System.Numerics.VectorDebugView`1 : ValueType {
    private Vector`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public IntPtr[] NIntView { get; }
    public UIntPtr[] NUIntView { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public VectorDebugView`1(Vector`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public IntPtr[] get_NIntView();
    public UIntPtr[] get_NUIntView();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
internal static class System.Numerics.VectorMath : object {
    public static Vector128`1<float> ConditionalSelectBitwise(Vector128`1<float> selector, Vector128`1<float> ifTrue, Vector128`1<float> ifFalse);
    public static Vector128`1<double> ConditionalSelectBitwise(Vector128`1<double> selector, Vector128`1<double> ifTrue, Vector128`1<double> ifFalse);
}
[NullableContextAttribute("2")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Object {
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public Type GetType();
    [NullableContextAttribute("1")]
protected object MemberwiseClone();
    [NonVersionableAttribute]
protected virtual void Finalize();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    [NonVersionableAttribute]
public static bool ReferenceEquals(object objA, object objB);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ObjectDisposedException : InvalidOperationException {
    private string _objectName;
    public string Message { get; }
    public string ObjectName { get; }
    [NullableContextAttribute("2")]
public ObjectDisposedException(string objectName);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string objectName, string message);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    [StackTraceHiddenAttribute]
public static void ThrowIf(bool condition, object instance);
    [StackTraceHiddenAttribute]
public static void ThrowIf(bool condition, Type type);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
    public string get_ObjectName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string Message { get; }
    public bool IsError { get; }
    public string DiagnosticId { get; public set; }
    public string UrlFormat { get; public set; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [CompilerGeneratedAttribute]
public void set_DiagnosticId(string value);
    [CompilerGeneratedAttribute]
public string get_UrlFormat();
    [CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.OperatingSystem : object {
    private Version _version;
    private PlatformID _platform;
    private string _servicePack;
    private string _versionString;
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    internal OperatingSystem(PlatformID platform, Version version, string servicePack);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public sealed virtual object Clone();
    public virtual string ToString();
    public string get_VersionString();
    public static bool IsOSPlatform(string platform);
    public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor, int build, int revision);
    [NonVersionableAttribute]
public static bool IsBrowser();
    [NonVersionableAttribute]
public static bool IsWasi();
    [NonVersionableAttribute]
public static bool IsLinux();
    [NonVersionableAttribute]
public static bool IsFreeBSD();
    public static bool IsFreeBSDVersionAtLeast(int major, int minor, int build, int revision);
    [NonVersionableAttribute]
public static bool IsAndroid();
    public static bool IsAndroidVersionAtLeast(int major, int minor, int build, int revision);
    [SupportedOSPlatformGuardAttribute("maccatalyst")]
[NonVersionableAttribute]
public static bool IsIOS();
    [SupportedOSPlatformGuardAttribute("maccatalyst")]
[NonVersionableAttribute]
public static bool IsIOSVersionAtLeast(int major, int minor, int build);
    [NonVersionableAttribute]
public static bool IsMacOS();
    public static bool IsMacOSVersionAtLeast(int major, int minor, int build);
    [NonVersionableAttribute]
public static bool IsMacCatalyst();
    public static bool IsMacCatalystVersionAtLeast(int major, int minor, int build);
    [NonVersionableAttribute]
public static bool IsTvOS();
    public static bool IsTvOSVersionAtLeast(int major, int minor, int build);
    [NonVersionableAttribute]
public static bool IsWatchOS();
    public static bool IsWatchOSVersionAtLeast(int major, int minor, int build);
    [NonVersionableAttribute]
public static bool IsWindows();
    public static bool IsWindowsVersionAtLeast(int major, int minor, int build, int revision);
    private static bool IsOSVersionAtLeast(int major, int minor, int build, int revision);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OperationCanceledException : SystemException {
    private CancellationToken _cancellationToken;
    public CancellationToken CancellationToken { get; private set; }
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public CancellationToken get_CancellationToken();
    private void set_CancellationToken(CancellationToken value);
}
internal class System.OrdinalCaseSensitiveComparer : OrdinalComparer {
    internal static OrdinalCaseSensitiveComparer Instance;
    private static OrdinalCaseSensitiveComparer();
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OrdinalComparer : StringComparer {
    private bool _ignoreCase;
    internal OrdinalComparer(bool ignoreCase);
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    [NullableContextAttribute("1")]
public virtual int GetHashCode(string obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private protected virtual bool IsWellKnownOrdinalComparerCore(Boolean& ignoreCase);
}
internal class System.OrdinalIgnoreCaseComparer : OrdinalComparer {
    internal static OrdinalIgnoreCaseComparer Instance;
    private static OrdinalIgnoreCaseComparer();
    public virtual int Compare(string x, string y);
    public virtual bool Equals(string x, string y);
    public virtual int GetHashCode(string obj);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OutOfMemoryException : SystemException {
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.OverflowException : ArithmeticException {
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected OverflowException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
internal enum System.ParseFailureKind : Enum {
    public int value__;
    public static ParseFailureKind None;
    public static ParseFailureKind ArgumentNull_String;
    public static ParseFailureKind Format_BadDatePattern;
    public static ParseFailureKind Format_BadDateTime;
    public static ParseFailureKind Format_BadDateTimeCalendar;
    public static ParseFailureKind Format_BadDayOfWeek;
    public static ParseFailureKind Format_BadFormatSpecifier;
    public static ParseFailureKind Format_BadQuote;
    public static ParseFailureKind Format_DateOutOfRange;
    public static ParseFailureKind Format_MissingIncompleteDate;
    public static ParseFailureKind Format_NoFormatSpecifier;
    public static ParseFailureKind Format_OffsetOutOfRange;
    public static ParseFailureKind Format_RepeatDateTimePattern;
    public static ParseFailureKind Format_UnknownDateTimeWord;
    public static ParseFailureKind Format_UTCOutOfRange;
    public static ParseFailureKind Argument_InvalidDateStyles;
    public static ParseFailureKind Argument_BadFormatSpecifier;
    public static ParseFailureKind Format_BadDateOnly;
    public static ParseFailureKind Format_BadTimeOnly;
    public static ParseFailureKind Format_DateTimeOnlyContainsNoneDateParts;
}
[FlagsAttribute]
internal enum System.ParseFlags : Enum {
    public int value__;
    public static ParseFlags HaveYear;
    public static ParseFlags HaveMonth;
    public static ParseFlags HaveDay;
    public static ParseFlags HaveHour;
    public static ParseFlags HaveMinute;
    public static ParseFlags HaveSecond;
    public static ParseFlags HaveTime;
    public static ParseFlags HaveDate;
    public static ParseFlags TimeZoneUsed;
    public static ParseFlags TimeZoneUtc;
    public static ParseFlags ParsedMonthName;
    public static ParseFlags CaptureOffset;
    public static ParseFlags YearDefault;
    public static ParseFlags Rfc1123Pattern;
    public static ParseFlags UtcSortPattern;
}
internal static class System.ParseNumbers : object {
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags);
    public static long StringToLong(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags);
    public static int StringToInt(ReadOnlySpan`1<char> s, int radix, int flags, Int32& currPos);
    private static void EatWhiteSpace(ReadOnlySpan`1<char> s, Int32& i);
    private static long GrabLongs(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static int GrabInts(int radix, ReadOnlySpan`1<char> s, Int32& i, bool isUnsigned);
    private static bool IsDigit(char c, int radix, Int32& result);
}
internal class System.ParsingInfo : ValueType {
    internal Calendar calendar;
    internal int dayOfWeek;
    internal TM timeMark;
    internal bool fUseHour12;
    internal bool fUseTwoDigitYear;
    internal bool fAllowInnerWhite;
    internal bool fAllowTrailingWhite;
    internal bool fUseHebrewNumberParser;
    public ParsingInfo(Calendar calendar);
}
internal static class System.PasteArguments : object {
    internal static void AppendArgument(ValueStringBuilder& stringBuilder, string argument);
    private static bool ContainsNoWhitespaceOrQuotes(string s);
    internal static string Paste(IEnumerable`1<string> arguments, bool pasteFirstArgumentUsingArgV0Rules);
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    public static PlatformID Unix;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
    public static PlatformID Other;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.PlatformNotSupportedException : NotSupportedException {
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class System.PointerSpec : object {
    private int pointer_level;
    internal PointerSpec(int pointer_level);
    public sealed virtual Type Resolve(Type type);
    public sealed virtual StringBuilder Append(StringBuilder sb);
    public virtual string ToString();
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class System.Private.CoreLib.Strings : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Progress`1 : object {
    private SynchronizationContext _synchronizationContext;
    private Action`1<T> _handler;
    private SendOrPostCallback _invokeHandlers;
    [CompilerGeneratedAttribute]
private EventHandler`1<T> ProgressChanged;
    public Progress`1(Action`1<T> handler);
    [CompilerGeneratedAttribute]
public void add_ProgressChanged(EventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
    private void InvokeHandlers(object state);
}
internal static class System.ProgressStatics : object {
    internal static SynchronizationContext DefaultContext;
    private static ProgressStatics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Random : object {
    private ImplBase _impl;
    [CompilerGeneratedAttribute]
private static Random <Shared>k__BackingField;
    public static Random Shared { get; }
    public Random(int Seed);
    private protected Random(bool isThreadSafeRandom);
    private static Random();
    [CompilerGeneratedAttribute]
public static Random get_Shared();
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual long NextInt64();
    public virtual long NextInt64(long maxValue);
    public virtual long NextInt64(long minValue, long maxValue);
    public virtual float NextSingle();
    public virtual double NextDouble();
    public virtual void NextBytes(Byte[] buffer);
    [NullableContextAttribute("0")]
public virtual void NextBytes(Span`1<byte> buffer);
    [NullableContextAttribute("2")]
public void GetItems(ReadOnlySpan`1<T> choices, Span`1<T> destination);
    public T[] GetItems(T[] choices, int length);
    public T[] GetItems(ReadOnlySpan`1<T> choices, int length);
    public void Shuffle(T[] values);
    [NullableContextAttribute("2")]
public void Shuffle(Span`1<T> values);
    protected virtual double Sample();
    private static void ThrowMinMaxValueSwapped();
}
[IsReadOnlyAttribute]
public class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    private static void ThrowArgumentOutOfRangeException();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.RankException : SystemException {
    public RankException(string message);
    public RankException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected RankException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.MemoryDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _object;
    private int _index;
    private int _length;
    internal static int RemoveFlagsBitMask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlyMemory`1<T> Empty { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    internal ReadOnlyMemory`1(object obj, int start, int length);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> get_Empty();
    public int get_Length();
    public bool get_IsEmpty();
    public virtual string ToString();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public bool TryCopyTo(Memory`1<T> destination);
    public MemoryHandle Pin();
    public T[] ToArray();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    internal object GetObjectStartLength(Int32& start, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
[NativeMarshallingAttribute("System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2")]
public class System.ReadOnlySpan`1 : ValueType {
    internal T& _reference;
    private int _length;
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlySpan`1<T> Empty { get; }
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    public ReadOnlySpan`1(T& reference);
    internal ReadOnlySpan`1(T& reference, int length);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use the equality operator instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> get_Empty();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public virtual string ToString();
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private AmbiguousMatchException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Assembly : object {
    private static Dictionary`2<string, Assembly> s_loadfile;
    private static List`1<string> s_loadFromAssemblyList;
    private static bool s_loadFromHandlerSet;
    private static int s_cachedSerializationSwitch;
    private static object s_overriddenEntryAssembly;
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location.")]
[RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public string CodeBase { get; }
    [NullableAttribute("2")]
public MethodInfo EntryPoint { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public string Location { get; }
    public bool ReflectionOnly { get; }
    public bool IsCollectible { get; }
    public bool IsFullyTrusted { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    [ObsoleteAttribute("Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location.")]
[RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public string EscapedCodeBase { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    [ObsoleteAttribute("The Global Assembly Cache is not supported.")]
public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    private static Assembly();
    [ObsoleteAttribute("Assembly.LoadWithPartialName has been deprecated. Use Assembly.Load() instead.")]
public static Assembly LoadWithPartialName(string partialName);
    public static Assembly GetExecutingAssembly();
    internal static RuntimeAssembly GetExecutingAssembly(StackCrawlMark& stackMark);
    public static Assembly GetCallingAssembly();
    internal static Assembly GetEntryAssemblyNative();
    private static Assembly GetEntryAssemblyInternal();
    public static Assembly Load(string assemblyString);
    public static Assembly Load(AssemblyName assemblyRef);
    internal static Assembly Load(AssemblyName assemblyRef, StackCrawlMark& stackMark, AssemblyLoadContext assemblyLoadContext);
    internal static UInt32 GetAssemblyCount();
    internal static Assembly InternalLoad(string assemblyName, StackCrawlMark& stackMark, IntPtr ptrLoadContextBinder);
    internal Type InternalGetType(Module module, string name, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetTypes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual IEnumerable`1<Type> get_ExportedTypes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetExportedTypes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetForwardedTypes();
    [NullableContextAttribute("2")]
public virtual string get_CodeBase();
    [NullableContextAttribute("2")]
public virtual MethodInfo get_EntryPoint();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public virtual string get_Location();
    public virtual bool get_ReflectionOnly();
    public virtual bool get_IsCollectible();
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public bool get_IsFullyTrusted();
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name, bool throwOnError);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string get_EscapedCodeBase();
    [RequiresUnreferencedCodeAttribute("Assembly.CreateInstance is not supported with trimming. Use Type.GetType instead.")]
public object CreateInstance(string typeName);
    [RequiresUnreferencedCodeAttribute("Assembly.CreateInstance is not supported with trimming. Use Type.GetType instead.")]
public object CreateInstance(string typeName, bool ignoreCase);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Assembly.CreateInstance is not supported with trimming. Use Type.GetType instead.")]
public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [NullableContextAttribute("2")]
public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual Module get_ManifestModule();
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual IEnumerable`1<Module> get_Modules();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    [RequiresUnreferencedCodeAttribute("Assembly references might be removed")]
public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream GetFile(string name);
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles();
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles(bool getResourceModules);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(Assembly left, Assembly right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Assembly left, Assembly right);
    [NullableContextAttribute("2")]
public static string CreateQualifiedName(string assemblyName, string typeName);
    public static Assembly GetAssembly(Type type);
    [NullableContextAttribute("2")]
public static void SetEntryAssembly(Assembly assembly);
    [NullableContextAttribute("2")]
public static Assembly GetEntryAssembly();
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly Load(Byte[] rawAssembly);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly LoadFile(string path);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
[UnconditionalSuppressMessageAttribute("SingleFile", "IL3000:Avoid accessing Assembly file path when publishing as a single file")]
private static Assembly LoadFromResolveHandler(object sender, ResolveEventArgs args);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly LoadFrom(string assemblyFile);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly UnsafeLoadFrom(string assemblyFile);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded module depends on might be removed")]
public Module LoadModule(string moduleName, Byte[] rawModule);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded module depends on might be removed")]
public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly ReflectionOnlyLoad(string assemblyString);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual SecurityRuleSet get_SecurityRuleSet();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UInt32 <AlgorithmId>k__BackingField;
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    [CompilerGeneratedAttribute]
public UInt32 get_AlgorithmId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Company>k__BackingField;
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    [CompilerGeneratedAttribute]
public string get_Company();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    [CompilerGeneratedAttribute]
public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    [CompilerGeneratedAttribute]
public string get_Copyright();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    [CompilerGeneratedAttribute]
public string get_Culture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DefaultAlias>k__BackingField;
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    [CompilerGeneratedAttribute]
public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    private AssemblyNameFlags _flags;
    [ObsoleteAttribute("AssemblyFlagsAttribute.Flags has been deprecated. Use AssemblyFlags instead.")]
[CLSCompliantAttribute("False")]
public UInt32 Flags { get; }
    public int AssemblyFlags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Use AssemblyFlagsAttribute(AssemblyNameFlags) instead.")]
[CLSCompliantAttribute("False")]
public AssemblyFlagsAttribute(UInt32 flags);
    [ObsoleteAttribute("This constructor has been deprecated. Use AssemblyFlagsAttribute(AssemblyNameFlags) instead.")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    public UInt32 get_Flags();
    public int get_AssemblyFlags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <InformationalVersion>k__BackingField;
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    [CompilerGeneratedAttribute]
public string get_InformationalVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Key { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.AssemblyName : object {
    private string _name;
    private Byte[] _publicKey;
    private Byte[] _publicKeyToken;
    private CultureInfo _cultureInfo;
    private string _codeBase;
    private Version _version;
    private AssemblyHashAlgorithm _hashAlgorithm;
    private AssemblyVersionCompatibility _versionCompatibility;
    private AssemblyNameFlags _flags;
    private static Func`2<string, AssemblyName> s_getAssemblyName;
    public string Name { get; public set; }
    public Version Version { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    [ObsoleteAttribute("AssemblyName.CodeBase and AssemblyName.EscapedCodeBase are obsolete. Using them for loading an assembly is not supported.")]
public string CodeBase { get; public set; }
    [ObsoleteAttribute("AssemblyName.CodeBase and AssemblyName.EscapedCodeBase are obsolete. Using them for loading an assembly is not supported.")]
[RequiresAssemblyFilesAttribute("The code will return an empty string for assemblies embedded in a single-file app")]
public string EscapedCodeBase { get; }
    [ObsoleteAttribute("AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.")]
public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public AssemblyNameFlags Flags { get; public set; }
    [ObsoleteAttribute("AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.")]
public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    [ObsoleteAttribute("AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.")]
public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    [ObsoleteAttribute("Strong name signing is not supported and throws PlatformNotSupportedException.")]
public StrongNameKeyPair KeyPair { get; public set; }
    [NullableAttribute("1")]
public string FullName { get; }
    [NullableContextAttribute("1")]
public AssemblyName(string assemblyName);
    internal static AssemblyName Create(IntPtr monoAssembly, string codeBase);
    internal void FillName(MonoAssemblyName* native, string codeBase, bool addVersion, bool addPublickey, bool defaultToken);
    private static int DecodeBlobSize(IntPtr in_ptr, IntPtr& out_ptr);
    internal static Byte[] DecodeBlobArray(IntPtr ptr);
    internal static void FreeAssemblyName(MonoAssemblyName& name, bool freeStruct);
    private static MonoAssemblyName* GetNativeName(IntPtr assemblyPtr);
    public string get_Name();
    public void set_Name(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    [RequiresAssemblyFilesAttribute("The code will return an empty string for assemblies embedded in a single-file app")]
public string get_CodeBase();
    public void set_CodeBase(string value);
    public string get_EscapedCodeBase();
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    private static Func`2<string, AssemblyName> InitGetAssemblyName();
    [NullableContextAttribute("1")]
public static AssemblyName GetAssemblyName(string assemblyFile);
    public Byte[] GetPublicKey();
    public void SetPublicKey(Byte[] publicKey);
    public Byte[] GetPublicKeyToken();
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    [NullableContextAttribute("1")]
public string get_FullName();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    [RequiresAssemblyFilesAttribute("The code will return an empty string for assemblies embedded in a single-file app")]
internal static string EscapeCodeBase(string codebase);
    internal static Char[] EscapeString(string input, int start, int end, Char[] dest, Int32& destPos, bool isUriString, char force1, char force2, char rsvd);
    private static Char[] EnsureDestinationSize(Char* pStr, Char[] dest, int currentInputPos, short charsToAdd, short minReallocateChars, Int32& destPos, int prevInputPos);
    internal static void EscapeAsciiChar(char ch, Char[] to, Int32& pos);
    private static bool IsReservedUnreservedOrHash(char c);
    internal static bool IsUnreserved(char c);
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
    public static AssemblyNameFlags Retargetable;
}
[ExtensionAttribute]
internal static class System.Reflection.AssemblyNameFormatter : object {
    public static string ComputeDisplayName(string name, Version version, string cultureName, Byte[] pkt, AssemblyNameFlags flags, AssemblyContentType contentType);
    [ExtensionAttribute]
private static void AppendQuoted(ValueStringBuilder& vsb, string s);
}
internal static class System.Reflection.AssemblyNameHelpers : object {
    private static ReadOnlySpan`1<byte> EcmaKey { get; }
    public static Byte[] ComputePublicKeyToken(Byte[] publicKey);
    private static bool IsValidPublicKey(Byte[] publicKey);
    private static UInt32 GetAlgClass(UInt32 x);
    private static UInt32 GetAlgSid(UInt32 x);
    private static ReadOnlySpan`1<byte> get_EcmaKey();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Reflection.AssemblyNameParser : ValueType {
    private ReadOnlySpan`1<char> _input;
    private int _index;
    private AssemblyNameParser(ReadOnlySpan`1<char> input);
    public static AssemblyNameParts Parse(string name);
    private void RecordNewSeenOrThrow(AttributeKind& seenAttributes, AttributeKind newAttribute);
    private AssemblyNameParts Parse();
    private Version ParseVersion(string attributeValue);
    private static string ParseCulture(string attributeValue);
    private Byte[] ParsePKT(string attributeValue, bool isToken);
    private ProcessorArchitecture ParseProcessorArchitecture(string attributeValue);
    private byte ParseHexNybble(char c);
    private Token GetNextToken();
    private static bool IsWhiteSpace(char ch);
    private char GetNextChar();
    private Token GetNextToken(String& tokenString);
    [DoesNotReturnAttribute]
private void ThrowInvalidAssemblyName();
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    [NullableContextAttribute("1")]
public AssemblyName GetAssemblyName(string assemblyFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    [CompilerGeneratedAttribute]
public string get_Product();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Countersignature>k__BackingField;
    public string PublicKey { get; }
    public string Countersignature { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    [CompilerGeneratedAttribute]
public string get_PublicKey();
    [CompilerGeneratedAttribute]
public string get_Countersignature();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    [CompilerGeneratedAttribute]
public string get_Title();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Trademark>k__BackingField;
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    [CompilerGeneratedAttribute]
public string get_Trademark();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    [NullableContextAttribute("2")]
public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags DoNotWrapExceptions;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    [NullableAttribute("1")]
public static string ConstructorName;
    [NullableAttribute("1")]
public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    private static ConstructorInfo();
    public virtual MemberTypes get_MemberType();
    [NullableContextAttribute("1")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.ConstructorInvoker : object {
    private InvokeFunc_ObjSpanArgs _invokeFunc_ObjSpanArgs;
    private InvokeFunc_Obj4Args _invokeFunc_Obj4Args;
    private InvokeFunc_RefArgs _invokeFunc_RefArgs;
    private InvokerStrategy _strategy;
    private int _argCount;
    private RuntimeType[] _argTypes;
    private InvocationFlags _invocationFlags;
    private InvokerArgFlags[] _invokerArgFlags;
    private RuntimeConstructorInfo _method;
    private bool _needsByRefStrategy;
    internal ConstructorInvoker(RuntimeConstructorInfo constructor);
    private ConstructorInvoker(RuntimeConstructorInfo constructor, RuntimeType[] argumentTypes);
    private object InterpretedInvoke(object obj, IntPtr* args);
    public static ConstructorInvoker Create(ConstructorInfo constructor);
    public object Invoke();
    public object Invoke(object arg1);
    [NullableContextAttribute("2")]
public object Invoke(object arg1, object arg2);
    [NullableContextAttribute("2")]
public object Invoke(object arg1, object arg2, object arg3);
    [NullableContextAttribute("2")]
public object Invoke(object arg1, object arg2, object arg3, object arg4);
    private object InvokeImpl(object arg1, object arg2, object arg3, object arg4);
    public object Invoke(Span`1<object> arguments);
    internal object InvokeWithFewArgs(Span`1<object> arguments);
    internal object InvokeDirectByRef(object arg1, object arg2, object arg3, object arg4);
    internal object InvokeDirectByRefWithFewArgs(Span`1<object> copyOfArgs);
    internal object InvokeWithManyArgs(Span`1<object> arguments);
    internal void CopyBack(Span`1<object> dest, Span`1<object> copyOfParameters, Span`1<bool> shouldCopyBack);
    private bool CheckArgument(Object& arg, int i);
}
internal enum System.Reflection.CorElementType : Enum {
    public byte value__;
    public static CorElementType ELEMENT_TYPE_END;
    public static CorElementType ELEMENT_TYPE_VOID;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_PTR;
    public static CorElementType ELEMENT_TYPE_BYREF;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VAR;
    public static CorElementType ELEMENT_TYPE_ARRAY;
    public static CorElementType ELEMENT_TYPE_GENERICINST;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_FNPTR;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_SZARRAY;
    public static CorElementType ELEMENT_TYPE_MVAR;
    public static CorElementType ELEMENT_TYPE_CMOD_REQD;
    public static CorElementType ELEMENT_TYPE_CMOD_OPT;
    public static CorElementType ELEMENT_TYPE_INTERNAL;
    public static CorElementType ELEMENT_TYPE_MAX;
    public static CorElementType ELEMENT_TYPE_MODIFIER;
    public static CorElementType ELEMENT_TYPE_SENTINEL;
    public static CorElementType ELEMENT_TYPE_PINNED;
}
internal static class System.Reflection.CustomAttribute : object {
    private static Assembly corlib;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, AttributeUsageAttribute> usage_cache;
    private static AttributeUsageAttribute DefaultAttributeUsage;
    private static CustomAttribute();
    private static bool IsUserCattrProvider(object obj);
    internal static Attribute[] GetCustomAttributesInternal(ICustomAttributeProvider obj, Type attributeType, bool pseudoAttrs);
    internal static Object[] GetPseudoCustomAttributes(ICustomAttributeProvider obj, Type attributeType);
    private static Object[] GetPseudoCustomAttributes(Type type);
    internal static Object[] GetCustomAttributesBase(ICustomAttributeProvider obj, Type attributeType, bool inheritedOnly);
    private static bool AttrTypeMatches(Type attributeType, Type attrType);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider obj, Type attributeType, bool inherit);
    internal static Object[] GetCustomAttributes(ICustomAttributeProvider obj, bool inherit);
    [DynamicDependencyAttribute("#ctor(System.Reflection.ConstructorInfo,System.Reflection.Assembly,System.IntPtr,System.UInt32)", "System.Reflection.RuntimeCustomAttributeData")]
[DynamicDependencyAttribute("#ctor(System.Reflection.MemberInfo,System.Object)", "System.Reflection.CustomAttributeNamedArgument")]
[DynamicDependencyAttribute("#ctor(System.Type,System.Object)", "System.Reflection.CustomAttributeTypedArgument")]
private static CustomAttributeData[] GetCustomAttributesDataInternal(ICustomAttributeProvider obj);
    internal static IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj, bool inherit);
    internal static IList`1<CustomAttributeData> GetCustomAttributesData(ICustomAttributeProvider obj, Type attributeType, bool inherit);
    internal static IList`1<CustomAttributeData> GetCustomAttributesDataBase(ICustomAttributeProvider obj, Type attributeType, bool inheritedOnly);
    internal static CustomAttributeData[] GetPseudoCustomAttributesData(ICustomAttributeProvider obj, Type attributeType);
    private static CustomAttributeData[] GetPseudoCustomAttributesData(Type type);
    internal static bool IsDefined(ICustomAttributeProvider obj, Type attributeType, bool inherit);
    private static bool IsDefinedInternal(ICustomAttributeProvider obj, Type AttributeType);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
private static PropertyInfo GetBasePropertyDefinition(RuntimePropertyInfo property);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
private static EventInfo GetBaseEventDefinition(RuntimeEventInfo evt);
    private static ICustomAttributeProvider GetBase(ICustomAttributeProvider obj);
    private static AttributeUsageAttribute RetrieveAttributeUsageNoCache(Type attributeType);
    private static AttributeUsageAttribute RetrieveAttributeUsage(Type attributeType);
    internal static Object[] CreateAttributeArrayHelper(RuntimeType caType, int elementCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.CustomAttributeData : object {
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.CustomAttributeFormatException : FormatException {
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private MemberInfo _memberInfo;
    private CustomAttributeTypedArgument _value;
    internal Type ArgumentType { get; }
    public MemberInfo MemberInfo { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public string MemberName { get; }
    public bool IsField { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomAttributeNamedArgument other);
    internal Type get_ArgumentType();
    public MemberInfo get_MemberInfo();
    public CustomAttributeTypedArgument get_TypedValue();
    public string get_MemberName();
    public bool get_IsField();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object _value;
    private Type _argumentType;
    public Type ArgumentType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public CustomAttributeTypedArgument(object value);
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
    internal string ToString(bool typed);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomAttributeTypedArgument other);
    public Type get_ArgumentType();
    [NullableContextAttribute("2")]
public object get_Value();
    private static object CanonicalizeValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    [CompilerGeneratedAttribute]
public string get_MemberName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.AssemblyBuilder : Assembly {
    [ThreadStaticAttribute]
private static bool t_allowDynamicCode;
    [NullableAttribute("2")]
[ObsoleteAttribute("Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location instead.")]
[RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public string CodeBase { get; }
    public string Location { get; }
    [NullableAttribute("2")]
public MethodInfo EntryPoint { get; }
    public bool IsDynamic { get; }
    [RequiresDynamicCodeAttribute("Defining a dynamic assembly requires dynamic code.")]
public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access);
    [RequiresDynamicCodeAttribute("Defining a dynamic assembly requires dynamic code.")]
public static AssemblyBuilder DefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    public ModuleBuilder DefineDynamicModule(string name);
    protected abstract virtual ModuleBuilder DefineDynamicModuleCore(string name);
    public ModuleBuilder GetDynamicModule(string name);
    protected abstract virtual ModuleBuilder GetDynamicModuleCore(string name);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [NullableContextAttribute("2")]
public virtual string get_CodeBase();
    public virtual string get_Location();
    [NullableContextAttribute("2")]
public virtual MethodInfo get_EntryPoint();
    public virtual bool get_IsDynamic();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetExportedTypes();
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream GetFile(string name);
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    internal static void EnsureDynamicCodeSupported();
    internal static IDisposable ForceAllowDynamicCode();
    private static void ThrowDynamicCodeNotSupported();
}
[FlagsAttribute]
public enum System.Reflection.Emit.AssemblyBuilderAccess : Enum {
    public int value__;
    public static AssemblyBuilderAccess Run;
    public static AssemblyBuilderAccess RunAndCollect;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.ConstructorBuilder : ConstructorInfo {
    public bool InitLocals { get; public set; }
    protected bool InitLocalsCore { get; protected set; }
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    protected abstract virtual bool get_InitLocalsCore();
    protected abstract virtual void set_InitLocalsCore(bool value);
    public ParameterBuilder DefineParameter(int iSequence, ParameterAttributes attributes, string strParamName);
    protected abstract virtual ParameterBuilder DefineParameterCore(int iSequence, ParameterAttributes attributes, string strParamName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int streamSize);
    protected abstract virtual ILGenerator GetILGeneratorCore(int streamSize);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    protected abstract virtual void SetImplementationFlagsCore(MethodImplAttributes attributes);
}
internal class System.Reflection.Emit.ConstructorOnTypeBuilderInstantiation : ConstructorInfo {
    internal ConstructorInfo _ctor;
    private TypeBuilderInstantiation _type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    internal ConstructorOnTypeBuilderInstantiation(ConstructorInfo constructor, TypeBuilderInstantiation type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
internal ConstructorInfo RuntimeResolve();
    internal virtual int GetParametersCount();
    internal virtual Type[] GetParameterTypes();
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethod();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.CustomAttributeBuilder : object {
    private ConstructorInfo ctor;
    private Byte[] data;
    private Object[] args;
    private PropertyInfo[] namedProperties;
    private Object[] propertyValues;
    private FieldInfo[] namedFields;
    private Object[] fieldValues;
    internal ConstructorInfo Ctor { get; }
    internal Byte[] Data { get; }
    internal CustomAttributeBuilder(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, FieldInfo[] namedFields, Object[] fieldValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues);
    public CustomAttributeBuilder(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    internal ConstructorInfo get_Ctor();
    internal Byte[] get_Data();
    private static Byte[] GetBlob(Assembly asmb, ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    private static bool IsValidType(Type t);
    private static bool IsValidParam(object o, Type paramType);
    private static bool IsValidValue(Type type, object value);
    private void Initialize(ConstructorInfo con, Object[] constructorArgs, PropertyInfo[] namedProperties, Object[] propertyValues, FieldInfo[] namedFields, Object[] fieldValues);
    internal static int decode_len(ReadOnlySpan`1<byte> data, int pos, Int32& rpos);
    internal static string string_from_bytes(ReadOnlySpan`1<byte> data, int pos, int len);
    internal static string decode_string(Byte[] data, int pos, Int32& rpos);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2057:UnrecognizedReflectionPattern")]
internal static UnmanagedMarshal get_umarshal(CustomAttributeBuilder customBuilder, bool is_field);
    private static Type elementTypeToType(int elementType);
    private static object decode_cattr_value(Type t, ReadOnlySpan`1<byte> data, int pos, Int32& rpos);
    internal static CustomAttributeInfo decode_cattr(CustomAttributeBuilder customBuilder);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2057:UnrecognizedReflectionPattern")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
internal static CustomAttributeInfo decode_cattr(ConstructorInfo ctor, ReadOnlySpan`1<byte> data);
    private static ParameterInfo[] GetParameters(ConstructorInfo ctor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ComVisibleAttribute("True")]
public class System.Reflection.Emit.DynamicILInfo : object {
    private DynamicMethod method;
    public DynamicMethod DynamicMethod { get; }
    internal DynamicILInfo(DynamicMethod method);
    public DynamicMethod get_DynamicMethod();
    public int GetTokenFor(Byte[] signature);
    public int GetTokenFor(DynamicMethod method);
    public int GetTokenFor(RuntimeFieldHandle field);
    public int GetTokenFor(RuntimeMethodHandle method);
    public int GetTokenFor(RuntimeTypeHandle type);
    public int GetTokenFor(string literal);
    public int GetTokenFor(RuntimeMethodHandle method, RuntimeTypeHandle contextType);
    public int GetTokenFor(RuntimeFieldHandle field, RuntimeTypeHandle contextType);
    [NullableContextAttribute("2")]
public void SetCode(Byte[] code, int maxStackSize);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public void SetCode(Byte* code, int codeSize, int maxStackSize);
    [NullableContextAttribute("2")]
public void SetExceptions(Byte[] exceptions);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public void SetExceptions(Byte* exceptions, int exceptionsSize);
    [NullableContextAttribute("2")]
public void SetLocalSignature(Byte[] localSignature);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public void SetLocalSignature(Byte* localSignature, int signatureSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.DynamicMethod : MethodInfo {
    private RuntimeMethodHandle _mhandle;
    private RuntimeType _returnType;
    private RuntimeType[] _parameterTypes;
    private Module _module;
    private bool _skipVisibility;
    private bool _restrictedSkipVisibility;
    private bool _initLocals;
    private RuntimeILGenerator _ilGenerator;
    private int _nrefs;
    private Object[] _refs;
    private IntPtr _referencedBy;
    private RuntimeType _typeOwner;
    private string _name;
    private MethodAttributes _attributes;
    private CallingConventions _callingConvention;
    private RuntimeParameterInfo[] _parameters;
    private Delegate _deleg;
    private RuntimeMethodInfo _method;
    private bool _creating;
    private DynamicILInfo _dynamicILInfo;
    private object _methodHandle;
    private static Module modreq(System.Runtime.CompilerServices.IsVolatile) s_anonymouslyHostedDynamicMethodsModule;
    private static object s_anonymouslyHostedDynamicMethodsModuleLock;
    public string Name { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public bool InitLocals { get; public set; }
    internal RuntimeType[] ArgumentTypes { get; }
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, bool restrictedSkipVisibility);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Module m, bool skipVisibility);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    [RequiresDynamicCodeAttribute("Creating a DynamicMethod requires dynamic code.")]
public DynamicMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type owner, bool skipVisibility);
    private static DynamicMethod();
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    public DynamicILInfo GetDynamicILInfo();
    public ILGenerator GetILGenerator(int streamSize);
    internal RuntimeILGenerator GetRuntimeILGenerator();
    private RuntimeILGenerator GetILGeneratorInternal(int streamSize);
    [NullableContextAttribute("2")]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    internal RuntimeMethodInfo GetRuntimeMethodInfo();
    private static void create_dynamic_method(DynamicMethod m, string name, MethodAttributes attributes, CallingConventions callingConvention);
    private void CreateDynMethod();
    private int AddRef(object reference);
    internal virtual int GetParametersCount();
    private static Module GetDynamicMethodsModule();
    [MemberNotNullAttribute("_parameterTypes")]
[MemberNotNullAttribute("_returnType")]
[MemberNotNullAttribute("_module")]
[MemberNotNullAttribute("_name")]
private void Init(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] signature, Type owner, Module m, bool skipVisibility, bool transparentMethod);
    public virtual string ToString();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual MethodInfo GetBaseDefinition();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    [NullableContextAttribute("2")]
public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string parameterName);
    public ILGenerator GetILGenerator();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    internal RuntimeType[] get_ArgumentTypes();
    private RuntimeParameterInfo[] LoadParameters();
}
internal class System.Reflection.Emit.EmptyCAHolder : object {
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
    private sealed virtual override bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.EnumBuilder : TypeInfo {
    public FieldBuilder UnderlyingField { get; }
    protected FieldBuilder UnderlyingFieldCore { get; }
    public FieldBuilder get_UnderlyingField();
    protected abstract virtual FieldBuilder get_UnderlyingFieldCore();
    public Type CreateType();
    public TypeInfo CreateTypeInfo();
    protected abstract virtual TypeInfo CreateTypeInfoCore();
    public FieldBuilder DefineLiteral(string literalName, object literalValue);
    protected abstract virtual FieldBuilder DefineLiteralCore(string literalName, object literalValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType(int rank);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.EventBuilder : object {
    public void AddOtherMethod(MethodBuilder mdBuilder);
    protected abstract virtual void AddOtherMethodCore(MethodBuilder mdBuilder);
    public void SetAddOnMethod(MethodBuilder mdBuilder);
    protected abstract virtual void SetAddOnMethodCore(MethodBuilder mdBuilder);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetRaiseMethod(MethodBuilder mdBuilder);
    protected abstract virtual void SetRaiseMethodCore(MethodBuilder mdBuilder);
    public void SetRemoveOnMethod(MethodBuilder mdBuilder);
    protected abstract virtual void SetRemoveOnMethodCore(MethodBuilder mdBuilder);
}
public abstract class System.Reflection.Emit.FieldBuilder : FieldInfo {
    [NullableContextAttribute("2")]
public void SetConstant(object defaultValue);
    [NullableContextAttribute("2")]
protected abstract virtual void SetConstantCore(object defaultValue);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetOffset(int iOffset);
    protected abstract virtual void SetOffsetCore(int iOffset);
}
internal class System.Reflection.Emit.FieldOnTypeBuilderInstantiation : FieldInfo {
    private FieldInfo _field;
    private TypeBuilderInstantiation _type;
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public FieldAttributes Attributes { get; }
    internal FieldOnTypeBuilderInstantiation(FieldInfo field, TypeBuilderInstantiation type);
    internal FieldInfo RuntimeResolve();
    internal static FieldInfo GetField(FieldInfo Field, TypeBuilderInstantiation type);
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual object GetValueDirect(TypedReference obj);
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual object GetValue(object obj);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual FieldAttributes get_Attributes();
}
public enum System.Reflection.Emit.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    [ObsoleteAttribute("FlowControl.Phi has been deprecated and is not supported.")]
public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
public abstract class System.Reflection.Emit.GenericTypeParameterBuilder : TypeInfo {
    [NullableContextAttribute("1")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [NullableContextAttribute("2")]
public void SetBaseTypeConstraint(Type baseTypeConstraint);
    [NullableContextAttribute("2")]
protected abstract virtual void SetBaseTypeConstraintCore(Type baseTypeConstraint);
    public void SetInterfaceConstraints(Type[] interfaceConstraints);
    protected abstract virtual void SetInterfaceConstraintsCore(Type[] interfaceConstraints);
    public void SetGenericParameterAttributes(GenericParameterAttributes genericParameterAttributes);
    protected abstract virtual void SetGenericParameterAttributesCore(GenericParameterAttributes genericParameterAttributes);
}
internal class System.Reflection.Emit.ILExceptionBlock : ValueType {
    internal Type extype;
    internal int type;
    internal int start;
    internal int len;
    internal int filter_offset;
}
internal class System.Reflection.Emit.ILExceptionInfo : ValueType {
    internal ILExceptionBlock[] handlers;
    internal int start;
    internal int len;
    internal Label end;
    internal void AddCatch(Type extype, int offset);
    internal void AddFinally(int offset);
    internal void AddFault(int offset);
    internal void AddFilter(int offset);
    internal void End(int offset);
    internal int LastClauseType();
    internal void PatchFilterClause(int start);
    private void add_block(int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.ILGenerator : object {
    private static Type[] s_parameterTypes;
    public int ILOffset { get; }
    private static ILGenerator();
    public abstract virtual void Emit(OpCode opcode);
    public abstract virtual void Emit(OpCode opcode, byte arg);
    public abstract virtual void Emit(OpCode opcode, short arg);
    public abstract virtual void Emit(OpCode opcode, long arg);
    public abstract virtual void Emit(OpCode opcode, float arg);
    public abstract virtual void Emit(OpCode opcode, double arg);
    public abstract virtual void Emit(OpCode opcode, int arg);
    public abstract virtual void Emit(OpCode opcode, MethodInfo meth);
    [NullableContextAttribute("2")]
public abstract virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    [NullableContextAttribute("2")]
public abstract virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public abstract virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public abstract virtual void Emit(OpCode opcode, SignatureHelper signature);
    public abstract virtual void Emit(OpCode opcode, ConstructorInfo con);
    public abstract virtual void Emit(OpCode opcode, Type cls);
    public abstract virtual void Emit(OpCode opcode, Label label);
    public abstract virtual void Emit(OpCode opcode, Label[] labels);
    public abstract virtual void Emit(OpCode opcode, FieldInfo field);
    public abstract virtual void Emit(OpCode opcode, string str);
    public abstract virtual void Emit(OpCode opcode, LocalBuilder local);
    public abstract virtual Label BeginExceptionBlock();
    public abstract virtual void EndExceptionBlock();
    public abstract virtual void BeginExceptFilterBlock();
    [NullableContextAttribute("2")]
public abstract virtual void BeginCatchBlock(Type exceptionType);
    public abstract virtual void BeginFaultBlock();
    public abstract virtual void BeginFinallyBlock();
    public abstract virtual Label DefineLabel();
    public abstract virtual void MarkLabel(Label loc);
    public virtual void ThrowException(Type excType);
    public virtual void EmitWriteLine(string value);
    public virtual void EmitWriteLine(LocalBuilder localBuilder);
    public virtual void EmitWriteLine(FieldInfo fld);
    public virtual LocalBuilder DeclareLocal(Type localType);
    public abstract virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public abstract virtual void UsingNamespace(string usingNamespace);
    public abstract virtual void BeginScope();
    public abstract virtual void EndScope();
    public abstract virtual int get_ILOffset();
    [CLSCompliantAttribute("False")]
public void Emit(OpCode opcode, sbyte arg);
}
internal class System.Reflection.Emit.Int32Stack : List`1<int> {
    public Int32Stack(int initialCapacity);
    public int Peek();
    public int Pop();
    public void Push(int value);
}
internal interface System.Reflection.Emit.ITokenGenerator {
    public abstract virtual int GetToken(string str);
    public abstract virtual int GetToken(MemberInfo member, bool create_open_instance);
    public abstract virtual int GetToken(MethodBase method, Type[] opt_param_types);
    public abstract virtual int GetToken(SignatureHelper helper);
}
[IsReadOnlyAttribute]
public class System.Reflection.Emit.Label : ValueType {
    internal int m_label;
    internal Label(int label);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Label obj);
    public static bool op_Equality(Label a, Label b);
    public static bool op_Inequality(Label a, Label b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.LocalBuilder : LocalVariableInfo {
    internal Type type;
    internal bool is_pinned;
    internal ushort position;
    private string name;
    internal ILGenerator ilgen;
    private int startOffset;
    private int endOffset;
    public Type LocalType { get; }
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    [DynamicDependencyAttribute("name")]
internal LocalBuilder(Type t, ILGenerator ilgen);
    public virtual Type get_LocalType();
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.MethodBuilder : MethodInfo {
    public bool InitLocals { get; public set; }
    protected bool InitLocalsCore { get; protected set; }
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    protected abstract virtual bool get_InitLocalsCore();
    protected abstract virtual void set_InitLocalsCore(bool value);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    protected abstract virtual GenericTypeParameterBuilder[] DefineGenericParametersCore(String[] names);
    public ParameterBuilder DefineParameter(int position, ParameterAttributes attributes, string strParamName);
    protected abstract virtual ParameterBuilder DefineParameterCore(int position, ParameterAttributes attributes, string strParamName);
    public ILGenerator GetILGenerator();
    public ILGenerator GetILGenerator(int size);
    protected abstract virtual ILGenerator GetILGeneratorCore(int size);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetImplementationFlags(MethodImplAttributes attributes);
    protected abstract virtual void SetImplementationFlagsCore(MethodImplAttributes attributes);
    public void SetParameters(Type[] parameterTypes);
    [NullableContextAttribute("2")]
public void SetReturnType(Type returnType);
    [NullableContextAttribute("2")]
public void SetSignature(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [NullableContextAttribute("2")]
protected abstract virtual void SetSignatureCore(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
}
internal class System.Reflection.Emit.MethodOnTypeBuilderInstantiation : MethodInfo {
    private Type[] _typeArguments;
    private MethodInfo _genericMethodDefinition;
    internal MethodInfo _method;
    private Type _type;
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethodDefinition { get; }
    public MemberTypes MemberType { get; }
    public string Name { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsGenericMethod { get; }
    public Type ReturnType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    internal MethodOnTypeBuilderInstantiation(MethodOnTypeBuilderInstantiation gmd, Type[] typeArguments);
    internal MethodOnTypeBuilderInstantiation(MethodInfo method, Type[] typeArguments);
    internal MethodOnTypeBuilderInstantiation(MethodInfo method, Type type);
    public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual MethodInfo GetGenericMethodDefinition();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] typeArgs);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2060:MakeGenericMethod")]
internal MethodInfo RuntimeResolve();
    internal virtual int GetParametersCount();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static MethodInfo ExtractBaseMethod(MethodInfo info);
    public virtual MemberTypes get_MemberType();
    public virtual string get_Name();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Module get_Module();
    public virtual ParameterInfo[] GetParameters();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_IsGenericMethod();
    public virtual Type get_ReturnType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodInfo GetBaseDefinition();
    internal virtual Type[] GetParameterTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.ModuleBuilder : Module {
    public void CreateGlobalFunctions();
    protected abstract virtual void CreateGlobalFunctionsCore();
    public EnumBuilder DefineEnum(string name, TypeAttributes visibility, Type underlyingType);
    protected abstract virtual EnumBuilder DefineEnumCore(string name, TypeAttributes visibility, Type underlyingType);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineGlobalMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    protected abstract virtual MethodBuilder DefineGlobalMethodCore(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    protected abstract virtual FieldBuilder DefineInitializedDataCore(string name, Byte[] data, FieldAttributes attributes);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
protected abstract virtual MethodBuilder DefinePInvokeMethodCore(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public TypeBuilder DefineType(string name);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, int typesize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packsize);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, PackingSize packingSize, int typesize);
    protected abstract virtual TypeBuilder DefineTypeCore(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    protected abstract virtual FieldBuilder DefineUninitializedDataCore(string name, int size, FieldAttributes attributes);
    public MethodInfo GetArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    protected abstract virtual MethodInfo GetArrayMethodCore(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public abstract virtual int GetTypeMetadataToken(Type type);
    public abstract virtual int GetFieldMetadataToken(FieldInfo field);
    public abstract virtual int GetMethodMetadataToken(MethodInfo method);
    public abstract virtual int GetMethodMetadataToken(ConstructorInfo constructor);
    public abstract virtual int GetSignatureMetadataToken(SignatureHelper signature);
    public abstract virtual int GetStringMetadataToken(string stringConstant);
}
internal class System.Reflection.Emit.ModuleBuilderTokenGenerator : object {
    private RuntimeModuleBuilder mb;
    public ModuleBuilderTokenGenerator(RuntimeModuleBuilder mb);
    public sealed virtual int GetToken(string str);
    public sealed virtual int GetToken(MemberInfo member, bool create_open_instance);
    public sealed virtual int GetToken(MethodBase method, Type[] opt_param_types);
    public sealed virtual int GetToken(SignatureHelper helper);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.Emit.OpCode : ValueType {
    private OpCodeValues m_value;
    private int m_flags;
    private static String[] modreq(System.Runtime.CompilerServices.IsVolatile) g_nameCache;
    public OperandType OperandType { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    public int Size { get; }
    public short Value { get; }
    public string Name { get; }
    internal OpCode(OpCodeValues value, int flags);
    public OperandType get_OperandType();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public int get_Size();
    public short get_Value();
    public string get_Name();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode obj);
    public static bool op_Equality(OpCode a, OpCode b);
    public static bool op_Inequality(OpCode a, OpCode b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class System.Reflection.Emit.OpCodes : object {
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem;
    public static OpCode Stelem;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Prefix7;
    public static OpCode Prefix6;
    public static OpCode Prefix5;
    public static OpCode Prefix4;
    public static OpCode Prefix3;
    public static OpCode Prefix2;
    public static OpCode Prefix1;
    public static OpCode Prefixref;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tailcall;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
    public static bool TakesSingleByteArgument(OpCode inst);
}
public enum System.Reflection.Emit.OpCodeType : Enum {
    public int value__;
    [ObsoleteAttribute("OpCodeType.Annotation has been deprecated and is not supported.")]
public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum System.Reflection.Emit.OpCodeValues : Enum {
    public int value__;
    public static OpCodeValues Nop;
    public static OpCodeValues Break;
    public static OpCodeValues Ldarg_0;
    public static OpCodeValues Ldarg_1;
    public static OpCodeValues Ldarg_2;
    public static OpCodeValues Ldarg_3;
    public static OpCodeValues Ldloc_0;
    public static OpCodeValues Ldloc_1;
    public static OpCodeValues Ldloc_2;
    public static OpCodeValues Ldloc_3;
    public static OpCodeValues Stloc_0;
    public static OpCodeValues Stloc_1;
    public static OpCodeValues Stloc_2;
    public static OpCodeValues Stloc_3;
    public static OpCodeValues Ldarg_S;
    public static OpCodeValues Ldarga_S;
    public static OpCodeValues Starg_S;
    public static OpCodeValues Ldloc_S;
    public static OpCodeValues Ldloca_S;
    public static OpCodeValues Stloc_S;
    public static OpCodeValues Ldnull;
    public static OpCodeValues Ldc_I4_M1;
    public static OpCodeValues Ldc_I4_0;
    public static OpCodeValues Ldc_I4_1;
    public static OpCodeValues Ldc_I4_2;
    public static OpCodeValues Ldc_I4_3;
    public static OpCodeValues Ldc_I4_4;
    public static OpCodeValues Ldc_I4_5;
    public static OpCodeValues Ldc_I4_6;
    public static OpCodeValues Ldc_I4_7;
    public static OpCodeValues Ldc_I4_8;
    public static OpCodeValues Ldc_I4_S;
    public static OpCodeValues Ldc_I4;
    public static OpCodeValues Ldc_I8;
    public static OpCodeValues Ldc_R4;
    public static OpCodeValues Ldc_R8;
    public static OpCodeValues Dup;
    public static OpCodeValues Pop;
    public static OpCodeValues Jmp;
    public static OpCodeValues Call;
    public static OpCodeValues Calli;
    public static OpCodeValues Ret;
    public static OpCodeValues Br_S;
    public static OpCodeValues Brfalse_S;
    public static OpCodeValues Brtrue_S;
    public static OpCodeValues Beq_S;
    public static OpCodeValues Bge_S;
    public static OpCodeValues Bgt_S;
    public static OpCodeValues Ble_S;
    public static OpCodeValues Blt_S;
    public static OpCodeValues Bne_Un_S;
    public static OpCodeValues Bge_Un_S;
    public static OpCodeValues Bgt_Un_S;
    public static OpCodeValues Ble_Un_S;
    public static OpCodeValues Blt_Un_S;
    public static OpCodeValues Br;
    public static OpCodeValues Brfalse;
    public static OpCodeValues Brtrue;
    public static OpCodeValues Beq;
    public static OpCodeValues Bge;
    public static OpCodeValues Bgt;
    public static OpCodeValues Ble;
    public static OpCodeValues Blt;
    public static OpCodeValues Bne_Un;
    public static OpCodeValues Bge_Un;
    public static OpCodeValues Bgt_Un;
    public static OpCodeValues Ble_Un;
    public static OpCodeValues Blt_Un;
    public static OpCodeValues Switch;
    public static OpCodeValues Ldind_I1;
    public static OpCodeValues Ldind_U1;
    public static OpCodeValues Ldind_I2;
    public static OpCodeValues Ldind_U2;
    public static OpCodeValues Ldind_I4;
    public static OpCodeValues Ldind_U4;
    public static OpCodeValues Ldind_I8;
    public static OpCodeValues Ldind_I;
    public static OpCodeValues Ldind_R4;
    public static OpCodeValues Ldind_R8;
    public static OpCodeValues Ldind_Ref;
    public static OpCodeValues Stind_Ref;
    public static OpCodeValues Stind_I1;
    public static OpCodeValues Stind_I2;
    public static OpCodeValues Stind_I4;
    public static OpCodeValues Stind_I8;
    public static OpCodeValues Stind_R4;
    public static OpCodeValues Stind_R8;
    public static OpCodeValues Add;
    public static OpCodeValues Sub;
    public static OpCodeValues Mul;
    public static OpCodeValues Div;
    public static OpCodeValues Div_Un;
    public static OpCodeValues Rem;
    public static OpCodeValues Rem_Un;
    public static OpCodeValues And;
    public static OpCodeValues Or;
    public static OpCodeValues Xor;
    public static OpCodeValues Shl;
    public static OpCodeValues Shr;
    public static OpCodeValues Shr_Un;
    public static OpCodeValues Neg;
    public static OpCodeValues Not;
    public static OpCodeValues Conv_I1;
    public static OpCodeValues Conv_I2;
    public static OpCodeValues Conv_I4;
    public static OpCodeValues Conv_I8;
    public static OpCodeValues Conv_R4;
    public static OpCodeValues Conv_R8;
    public static OpCodeValues Conv_U4;
    public static OpCodeValues Conv_U8;
    public static OpCodeValues Callvirt;
    public static OpCodeValues Cpobj;
    public static OpCodeValues Ldobj;
    public static OpCodeValues Ldstr;
    public static OpCodeValues Newobj;
    public static OpCodeValues Castclass;
    public static OpCodeValues Isinst;
    public static OpCodeValues Conv_R_Un;
    public static OpCodeValues Unbox;
    public static OpCodeValues Throw;
    public static OpCodeValues Ldfld;
    public static OpCodeValues Ldflda;
    public static OpCodeValues Stfld;
    public static OpCodeValues Ldsfld;
    public static OpCodeValues Ldsflda;
    public static OpCodeValues Stsfld;
    public static OpCodeValues Stobj;
    public static OpCodeValues Conv_Ovf_I1_Un;
    public static OpCodeValues Conv_Ovf_I2_Un;
    public static OpCodeValues Conv_Ovf_I4_Un;
    public static OpCodeValues Conv_Ovf_I8_Un;
    public static OpCodeValues Conv_Ovf_U1_Un;
    public static OpCodeValues Conv_Ovf_U2_Un;
    public static OpCodeValues Conv_Ovf_U4_Un;
    public static OpCodeValues Conv_Ovf_U8_Un;
    public static OpCodeValues Conv_Ovf_I_Un;
    public static OpCodeValues Conv_Ovf_U_Un;
    public static OpCodeValues Box;
    public static OpCodeValues Newarr;
    public static OpCodeValues Ldlen;
    public static OpCodeValues Ldelema;
    public static OpCodeValues Ldelem_I1;
    public static OpCodeValues Ldelem_U1;
    public static OpCodeValues Ldelem_I2;
    public static OpCodeValues Ldelem_U2;
    public static OpCodeValues Ldelem_I4;
    public static OpCodeValues Ldelem_U4;
    public static OpCodeValues Ldelem_I8;
    public static OpCodeValues Ldelem_I;
    public static OpCodeValues Ldelem_R4;
    public static OpCodeValues Ldelem_R8;
    public static OpCodeValues Ldelem_Ref;
    public static OpCodeValues Stelem_I;
    public static OpCodeValues Stelem_I1;
    public static OpCodeValues Stelem_I2;
    public static OpCodeValues Stelem_I4;
    public static OpCodeValues Stelem_I8;
    public static OpCodeValues Stelem_R4;
    public static OpCodeValues Stelem_R8;
    public static OpCodeValues Stelem_Ref;
    public static OpCodeValues Ldelem;
    public static OpCodeValues Stelem;
    public static OpCodeValues Unbox_Any;
    public static OpCodeValues Conv_Ovf_I1;
    public static OpCodeValues Conv_Ovf_U1;
    public static OpCodeValues Conv_Ovf_I2;
    public static OpCodeValues Conv_Ovf_U2;
    public static OpCodeValues Conv_Ovf_I4;
    public static OpCodeValues Conv_Ovf_U4;
    public static OpCodeValues Conv_Ovf_I8;
    public static OpCodeValues Conv_Ovf_U8;
    public static OpCodeValues Refanyval;
    public static OpCodeValues Ckfinite;
    public static OpCodeValues Mkrefany;
    public static OpCodeValues Ldtoken;
    public static OpCodeValues Conv_U2;
    public static OpCodeValues Conv_U1;
    public static OpCodeValues Conv_I;
    public static OpCodeValues Conv_Ovf_I;
    public static OpCodeValues Conv_Ovf_U;
    public static OpCodeValues Add_Ovf;
    public static OpCodeValues Add_Ovf_Un;
    public static OpCodeValues Mul_Ovf;
    public static OpCodeValues Mul_Ovf_Un;
    public static OpCodeValues Sub_Ovf;
    public static OpCodeValues Sub_Ovf_Un;
    public static OpCodeValues Endfinally;
    public static OpCodeValues Leave;
    public static OpCodeValues Leave_S;
    public static OpCodeValues Stind_I;
    public static OpCodeValues Conv_U;
    public static OpCodeValues Prefix7;
    public static OpCodeValues Prefix6;
    public static OpCodeValues Prefix5;
    public static OpCodeValues Prefix4;
    public static OpCodeValues Prefix3;
    public static OpCodeValues Prefix2;
    public static OpCodeValues Prefix1;
    public static OpCodeValues Prefixref;
    public static OpCodeValues Arglist;
    public static OpCodeValues Ceq;
    public static OpCodeValues Cgt;
    public static OpCodeValues Cgt_Un;
    public static OpCodeValues Clt;
    public static OpCodeValues Clt_Un;
    public static OpCodeValues Ldftn;
    public static OpCodeValues Ldvirtftn;
    public static OpCodeValues Ldarg;
    public static OpCodeValues Ldarga;
    public static OpCodeValues Starg;
    public static OpCodeValues Ldloc;
    public static OpCodeValues Ldloca;
    public static OpCodeValues Stloc;
    public static OpCodeValues Localloc;
    public static OpCodeValues Endfilter;
    public static OpCodeValues Unaligned_;
    public static OpCodeValues Volatile_;
    public static OpCodeValues Tail_;
    public static OpCodeValues Initobj;
    public static OpCodeValues Constrained_;
    public static OpCodeValues Cpblk;
    public static OpCodeValues Initblk;
    public static OpCodeValues Rethrow;
    public static OpCodeValues Sizeof;
    public static OpCodeValues Refanytype;
    public static OpCodeValues Readonly_;
}
public enum System.Reflection.Emit.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    [ObsoleteAttribute("OperandType.InlinePhi has been deprecated and is not supported.")]
public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
}
public enum System.Reflection.Emit.PackingSize : Enum {
    public int value__;
    public static PackingSize Unspecified;
    public static PackingSize Size1;
    public static PackingSize Size2;
    public static PackingSize Size4;
    public static PackingSize Size8;
    public static PackingSize Size16;
    public static PackingSize Size32;
    public static PackingSize Size64;
    public static PackingSize Size128;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.ParameterBuilder : object {
    public int Attributes { get; }
    public bool IsIn { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public string Name { get; }
    public int Position { get; }
    public virtual int get_Attributes();
    public bool get_IsIn();
    public bool get_IsOptional();
    public bool get_IsOut();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual void SetConstant(object defaultValue);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    [NullableContextAttribute("1")]
public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
}
public enum System.Reflection.Emit.PEFileKinds : Enum {
    public int value__;
    public static PEFileKinds Dll;
    public static PEFileKinds ConsoleApplication;
    public static PEFileKinds WindowApplication;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.PropertyBuilder : PropertyInfo {
    public void AddOtherMethod(MethodBuilder mdBuilder);
    protected abstract virtual void AddOtherMethodCore(MethodBuilder mdBuilder);
    [NullableContextAttribute("2")]
public void SetConstant(object defaultValue);
    [NullableContextAttribute("2")]
protected abstract virtual void SetConstantCore(object defaultValue);
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    public void SetGetMethod(MethodBuilder mdBuilder);
    protected abstract virtual void SetGetMethodCore(MethodBuilder mdBuilder);
    public void SetSetMethod(MethodBuilder mdBuilder);
    protected abstract virtual void SetSetMethodCore(MethodBuilder mdBuilder);
}
internal class System.Reflection.Emit.RuntimeAssemblyBuilder : AssemblyBuilder {
    internal IntPtr _mono_assembly;
    private LoaderAllocator m_keepalive;
    private UIntPtr dynamic_assembly;
    private RuntimeModuleBuilder[] modules;
    private string name;
    private CustomAttributeBuilder[] cattrs;
    private string version;
    private string culture;
    private Byte[] public_key_token;
    private Module[] loaded_modules;
    private UInt32 access;
    private AssemblyName aname;
    private RuntimeModuleBuilder manifest_module;
    private bool manifest_module_used;
    public bool ReflectionOnly { get; }
    public bool IsCollectible { get; }
    public Module ManifestModule { get; }
    public string FullName { get; }
    [DynamicDependencyAttribute("access")]
internal RuntimeAssemblyBuilder(AssemblyName n, AssemblyBuilderAccess access);
    [DynamicDependencyAttribute("RuntimeResolve", "System.Reflection.Emit.RuntimeModuleBuilder")]
private static void basic_init(RuntimeAssemblyBuilder ab);
    private static void UpdateNativeCustomAttributes(RuntimeAssemblyBuilder ab);
    public virtual bool get_ReflectionOnly();
    protected virtual ModuleBuilder DefineDynamicModuleCore(string name);
    internal static AssemblyBuilder InternalDefineDynamicAssembly(AssemblyName name, AssemblyBuilderAccess access, AssemblyLoadContext _, IEnumerable`1<CustomAttributeBuilder> assemblyAttributes);
    protected virtual ModuleBuilder GetDynamicModuleCore(string name);
    public virtual bool get_IsCollectible();
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    internal static Type MakeGenericType(Type gtd, Type[] typeArguments);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Module GetModule(string name);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName(bool copiedName);
    [RequiresUnreferencedCodeAttribute("Assembly references might be removed")]
public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Module get_ManifestModule();
    public virtual string get_FullName();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
}
internal class System.Reflection.Emit.RuntimeConstructorBuilder : ConstructorBuilder {
    private RuntimeMethodHandle mhandle;
    private RuntimeILGenerator ilgen;
    internal Type[] parameters;
    private MethodAttributes attrs;
    private MethodImplAttributes iattrs;
    private int table_idx;
    private CallingConventions call_conv;
    private RuntimeTypeBuilder type;
    internal ParameterBuilder[] pinfo;
    private CustomAttributeBuilder[] cattrs;
    private bool init_locals;
    private Type[][] paramModReq;
    private Type[][] paramModOpt;
    internal bool finished;
    public CallingConventions CallingConvention { get; }
    protected bool InitLocalsCore { get; protected set; }
    internal RuntimeTypeBuilder TypeBuilder { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Module Module { get; }
    [DynamicDependencyAttribute("paramModOpt")]
internal RuntimeConstructorBuilder(RuntimeTypeBuilder tb, MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt);
    public virtual CallingConventions get_CallingConvention();
    protected virtual bool get_InitLocalsCore();
    protected virtual void set_InitLocalsCore(bool value);
    internal RuntimeTypeBuilder get_TypeBuilder();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
internal MethodBase RuntimeResolve();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual int get_MetadataToken();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    protected virtual ParameterBuilder DefineParameterCore(int iSequence, ParameterAttributes attributes, string strParamName);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    protected virtual ILGenerator GetILGeneratorCore(int streamSize);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    protected virtual void SetImplementationFlagsCore(MethodImplAttributes attributes);
    public virtual Module get_Module();
    public virtual string ToString();
    internal void fixup();
    internal void ResolveUserTypes();
    internal virtual int get_next_table_index(int table, int count);
    private static NotSupportedException not_supported();
    private static InvalidOperationException not_after_created();
    private static NotSupportedException not_created();
}
internal class System.Reflection.Emit.RuntimeEnumBuilder : EnumBuilder {
    [DynamicallyAccessedMembersAttribute("-1")]
private RuntimeTypeBuilder _tb;
    private FieldBuilder _underlyingField;
    private Type _underlyingType;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    protected FieldBuilder UnderlyingFieldCore { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsSZArray { get; }
    internal bool IsUserType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsByRefLike { get; }
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2064:UnrecognizedReflectionPattern")]
internal RuntimeEnumBuilder(RuntimeModuleBuilder mb, string name, TypeAttributes visibility, Type underlyingType);
    internal RuntimeTypeBuilder GetTypeBuilder();
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    protected virtual FieldBuilder get_UnderlyingFieldCore();
    public virtual Type get_UnderlyingSystemType();
    protected virtual TypeInfo CreateTypeInfoCore();
    public virtual Type GetEnumUnderlyingType();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2110:ReflectionToDynamicallyAccessedMembers")]
private void setup_enum_type(Type t);
    protected virtual FieldBuilder DefineLiteralCore(string literalName, object literalValue);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetElementType();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSZArray();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    internal virtual bool get_IsUserType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsByRefLike();
}
internal class System.Reflection.Emit.RuntimeEventBuilder : EventBuilder {
    internal string name;
    private Type type;
    private RuntimeTypeBuilder typeb;
    private CustomAttributeBuilder[] cattrs;
    internal MethodBuilder add_method;
    internal MethodBuilder remove_method;
    internal MethodBuilder raise_method;
    internal MethodBuilder[] other_methods;
    internal EventAttributes attrs;
    private int table_idx;
    [DynamicDependencyAttribute("table_idx")]
internal RuntimeEventBuilder(RuntimeTypeBuilder tb, string eventName, EventAttributes eventAttrs, Type eventType);
    internal int get_next_table_index(int table, int count);
    protected virtual void AddOtherMethodCore(MethodBuilder mdBuilder);
    protected virtual void SetAddOnMethodCore(MethodBuilder mdBuilder);
    protected virtual void SetRaiseMethodCore(MethodBuilder mdBuilder);
    protected virtual void SetRemoveOnMethodCore(MethodBuilder mdBuilder);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    private void RejectIfCreated();
}
internal class System.Reflection.Emit.RuntimeFieldBuilder : FieldBuilder {
    private FieldAttributes attrs;
    private Type type;
    private string name;
    private object def_value;
    private int offset;
    internal RuntimeTypeBuilder typeb;
    private Byte[] rva_data;
    private CustomAttributeBuilder[] cattrs;
    private UnmanagedMarshal marshal_info;
    private RuntimeFieldHandle handle;
    private Type[] modReq;
    private Type[] modOpt;
    public FieldAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    [DynamicDependencyAttribute("modOpt")]
internal RuntimeFieldBuilder(RuntimeTypeBuilder tb, string fieldName, Type type, FieldAttributes attributes, Type[] modReq, Type[] modOpt);
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual int get_MetadataToken();
    public virtual object GetValue(object obj);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    internal virtual int GetFieldOffset();
    internal void SetRVAData(Byte[] data);
    internal static PackingSize RVADataPackingSize(int size);
    protected virtual void SetConstantCore(object defaultValue);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    protected virtual void SetOffsetCore(int iOffset);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    private static NotSupportedException CreateNotSupportedException();
    private void RejectIfCreated();
    internal void ResolveUserTypes();
    internal FieldInfo RuntimeResolve();
    public virtual Module get_Module();
}
[ComVisibleAttribute("True")]
internal class System.Reflection.Emit.RuntimeGenericTypeParameterBuilder : GenericTypeParameterBuilder {
    private RuntimeTypeBuilder tbuilder;
    private RuntimeMethodBuilder mbuilder;
    private string name;
    private int index;
    private Type base_type;
    private Type[] iface_constraints;
    private CustomAttributeBuilder[] cattrs;
    private GenericParameterAttributes attrs;
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    internal bool IsUserType { get; }
    public bool IsByRefLike { get; }
    [DynamicDependencyAttribute("attrs")]
internal RuntimeGenericTypeParameterBuilder(RuntimeTypeBuilder tbuilder, RuntimeMethodBuilder mbuilder, string name, int index);
    protected virtual void SetBaseTypeConstraintCore(Type baseTypeConstraint);
    protected virtual void SetInterfaceConstraintsCore(Type[] interfaceConstraints);
    protected virtual void SetGenericParameterAttributesCore(GenericParameterAttributes genericParameterAttributes);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    public virtual bool IsSubclassOf(Type c);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsInstanceOfType(object o);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSZArray();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Type GetElementType();
    public virtual Type get_UnderlyingSystemType();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Module get_Module();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual MethodBase get_DeclaringMethod();
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    private static NotSupportedException not_supported();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    internal virtual bool get_IsUserType();
    public virtual bool get_IsByRefLike();
}
internal class System.Reflection.Emit.RuntimeILGenerator : ILGenerator {
    private Byte[] code;
    private int code_len;
    private int max_stack;
    private int cur_stack;
    private LocalBuilder[] locals;
    private ILExceptionInfo[] ex_handlers;
    private int num_token_fixups;
    private object token_fixups;
    private LabelData[] labels;
    private int num_labels;
    private LabelFixup[] fixups;
    private int num_fixups;
    internal Module module;
    private int cur_block;
    private Int32Stack open_blocks;
    private ITokenGenerator token_gen;
    [MemberNotNullWhenAttribute("True", "open_blocks")]
private bool InExceptionBlock { get; }
    internal ITokenGenerator TokenGenerator { get; }
    public int ILOffset { get; }
    [DynamicDependencyAttribute("token_fixups")]
internal RuntimeILGenerator(Module m, ITokenGenerator token_gen, int size);
    [MemberNotNullWhenAttribute("True", "open_blocks")]
private bool get_InExceptionBlock();
    private void make_room(int nbytes);
    private void emit_int(int val);
    private void ll_emit(OpCode opcode);
    private static int target_len(OpCode opcode);
    private void InternalEndClause();
    public virtual void BeginCatchBlock(Type exceptionType);
    public virtual void BeginExceptFilterBlock();
    public virtual Label BeginExceptionBlock();
    public virtual void BeginFaultBlock();
    public virtual void BeginFinallyBlock();
    public virtual void BeginScope();
    public virtual LocalBuilder DeclareLocal(Type localType, bool pinned);
    public virtual Label DefineLabel();
    public virtual void Emit(OpCode opcode);
    public virtual void Emit(OpCode opcode, byte arg);
    public virtual void Emit(OpCode opcode, ConstructorInfo con);
    public virtual void Emit(OpCode opcode, double arg);
    public virtual void Emit(OpCode opcode, FieldInfo field);
    public virtual void Emit(OpCode opcode, short arg);
    public virtual void Emit(OpCode opcode, int arg);
    public virtual void Emit(OpCode opcode, long arg);
    public virtual void Emit(OpCode opcode, Label label);
    public virtual void Emit(OpCode opcode, Label[] labels);
    public virtual void Emit(OpCode opcode, LocalBuilder local);
    public virtual void Emit(OpCode opcode, MethodInfo meth);
    private void Emit(OpCode opcode, MethodInfo method, int token);
    public virtual void Emit(OpCode opcode, SignatureHelper signature);
    public virtual void Emit(OpCode opcode, float arg);
    public virtual void Emit(OpCode opcode, string str);
    public virtual void Emit(OpCode opcode, Type cls);
    public virtual void EmitCall(OpCode opcode, MethodInfo methodInfo, Type[] optionalParameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public virtual void EmitCalli(OpCode opcode, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public virtual void EndExceptionBlock();
    public virtual void EndScope();
    public virtual void MarkLabel(Label loc);
    public virtual void UsingNamespace(string usingNamespace);
    internal void label_fixup(MethodBase mb);
    internal void SetCode(Byte[] code, int max_stack);
    internal void SetCode(Byte* code, int code_size, int max_stack);
    internal ITokenGenerator get_TokenGenerator();
    public virtual int get_ILOffset();
}
internal class System.Reflection.Emit.RuntimeMethodBuilder : MethodBuilder {
    private RuntimeMethodHandle mhandle;
    private Type rtype;
    internal Type[] parameters;
    private MethodAttributes attrs;
    private MethodImplAttributes iattrs;
    private string name;
    private int table_idx;
    private Byte[] code;
    private RuntimeILGenerator ilgen;
    private RuntimeTypeBuilder type;
    internal ParameterBuilder[] pinfo;
    private CustomAttributeBuilder[] cattrs;
    private MethodInfo[] override_methods;
    private string pi_dll;
    private string pi_entry;
    private CharSet charset;
    private UInt32 extra_flags;
    private CallingConvention native_cc;
    private CallingConventions call_conv;
    private bool init_locals;
    private IntPtr generic_container;
    internal RuntimeGenericTypeParameterBuilder[] generic_params;
    private Type[] returnModReq;
    private Type[] returnModOpt;
    private Type[][] paramModReq;
    private Type[][] paramModOpt;
    private RuntimeMethodInfo created;
    public bool ContainsGenericParameters { get; }
    protected bool InitLocalsCore { get; protected set; }
    internal RuntimeTypeBuilder TypeBuilder { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    internal RuntimeMethodHandle MethodHandleInternal { get; }
    public Type ReturnType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public MethodAttributes Attributes { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public CallingConventions CallingConvention { get; }
    unknown bool BestFitMapping {internal set; }
    unknown bool ThrowOnUnmappableChar {internal set; }
    unknown bool ExactSpelling {internal set; }
    unknown bool SetLastError {internal set; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public Module Module { get; }
    public ParameterInfo ReturnParameter { get; }
    [DynamicDependencyAttribute("paramModOpt")]
internal RuntimeMethodBuilder(RuntimeTypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt);
    internal RuntimeMethodBuilder(RuntimeTypeBuilder tb, string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt, string dllName, string entryName, CallingConvention nativeCConv, CharSet nativeCharset);
    public virtual bool get_ContainsGenericParameters();
    protected virtual bool get_InitLocalsCore();
    protected virtual void set_InitLocalsCore(bool value);
    internal RuntimeTypeBuilder get_TypeBuilder();
    public virtual int get_MetadataToken();
    public virtual RuntimeMethodHandle get_MethodHandle();
    internal RuntimeMethodHandle get_MethodHandleInternal();
    public virtual Type get_ReturnType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual MethodAttributes get_Attributes();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual CallingConventions get_CallingConvention();
    internal void set_BestFitMapping(bool value);
    internal void set_ThrowOnUnmappableChar(bool value);
    internal void set_ExactSpelling(bool value);
    internal void set_SetLastError(bool value);
    public virtual MethodInfo GetBaseDefinition();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    internal MethodBase RuntimeResolve();
    internal Module GetModule();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    protected virtual ILGenerator GetILGeneratorCore(int size);
    protected virtual ParameterBuilder DefineParameterCore(int position, ParameterAttributes attributes, string strParamName);
    internal void check_override();
    internal void fixup();
    internal void ResolveUserTypes();
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    protected virtual void SetImplementationFlagsCore(MethodImplAttributes attributes);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual int get_next_table_index(int table, int count);
    private static void ExtendArray(T[]& array, T elem);
    internal void set_override(MethodInfo mdecl);
    private void RejectIfCreated();
    private static NotSupportedException NotSupported();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual Type[] GetGenericArguments();
    protected virtual GenericTypeParameterBuilder[] DefineGenericParametersCore(String[] names);
    protected virtual void SetSignatureCore(Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public virtual Module get_Module();
    public virtual ParameterInfo get_ReturnParameter();
}
internal class System.Reflection.Emit.RuntimeModuleBuilder : ModuleBuilder {
    internal IntPtr _impl;
    internal Assembly assembly;
    internal string fqname;
    internal string name;
    internal string scopename;
    internal bool is_resource;
    internal int token;
    private UIntPtr dynamic_image;
    private int num_types;
    private RuntimeTypeBuilder[] types;
    private CustomAttributeBuilder[] cattrs;
    private int table_idx;
    internal RuntimeAssemblyBuilder assemblyb;
    private Object[] global_methods;
    private Object[] global_fields;
    private bool is_main;
    private object resources;
    private IntPtr unparented_classes;
    private Int32[] table_indexes;
    private Byte[] guid;
    private RuntimeTypeBuilder global_type;
    private bool global_type_created;
    private Dictionary`2<ITypeName, RuntimeTypeBuilder> name_cache;
    private Dictionary`2<string, int> us_string_cache;
    private ModuleBuilderTokenGenerator token_gen;
    private static int typeref_tokengen;
    private static int typedef_tokengen;
    private static int typespec_tokengen;
    private static int memberref_tokengen;
    private static int methoddef_tokengen;
    private Dictionary`2<MemberInfo, int> inst_tokens;
    private Dictionary`2<MemberInfo, int> inst_tokens_open;
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string FullyQualifiedName { get; }
    public Assembly Assembly { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string Name { get; }
    public string ScopeName { get; }
    public Guid ModuleVersionId { get; }
    public int MetadataToken { get; }
    [DynamicDependencyAttribute("table_indexes")]
internal RuntimeModuleBuilder(RuntimeAssemblyBuilder assb, string name);
    private static RuntimeModuleBuilder();
    private static void basic_init(RuntimeModuleBuilder ab);
    private static void set_wrappers_type(RuntimeModuleBuilder mb, Type ab);
    public virtual string get_FullyQualifiedName();
    protected virtual void CreateGlobalFunctionsCore();
    protected virtual FieldBuilder DefineInitializedDataCore(string name, Byte[] data, FieldAttributes attributes);
    protected virtual FieldBuilder DefineUninitializedDataCore(string name, int size, FieldAttributes attributes);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private FieldBuilder DefineDataImpl(string name, int size, FieldAttributes attributes);
    private void addGlobalMethod(MethodBuilder mb);
    protected virtual MethodBuilder DefineGlobalMethodCore(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
protected virtual MethodBuilder DefinePInvokeMethodCore(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    private void AddType(RuntimeTypeBuilder tb);
    private RuntimeTypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    internal void RegisterTypeName(RuntimeTypeBuilder tb, ITypeName name);
    internal RuntimeTypeBuilder GetRegisteredType(ITypeName name);
    protected virtual TypeBuilder DefineTypeCore(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packingSize, int typesize);
    protected virtual MethodInfo GetArrayMethodCore(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    protected virtual EnumBuilder DefineEnumCore(string name, TypeAttributes visibility, Type underlyingType);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool ignoreCase);
    private static RuntimeTypeBuilder search_in_array(RuntimeTypeBuilder[] arr, int validElementsInArray, ITypeName className);
    private static RuntimeTypeBuilder search_nested_in_array(RuntimeTypeBuilder[] arr, int validElementsInArray, ITypeName className);
    private static RuntimeTypeBuilder GetMaybeNested(RuntimeTypeBuilder t, IEnumerable`1<ITypeName> nested);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    internal int get_next_table_index(int table, int count);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetTypes();
    public virtual int GetMethodMetadataToken(MethodInfo method);
    public virtual int GetMethodMetadataToken(ConstructorInfo constructor);
    public virtual int GetFieldMetadataToken(FieldInfo field);
    internal static Module GetRuntimeModuleFromModule(Module m);
    public virtual int GetSignatureMetadataToken(SignatureHelper signature);
    public virtual int GetStringMetadataToken(string stringConstant);
    public virtual int GetTypeMetadataToken(Type type);
    private static int getUSIndex(RuntimeModuleBuilder mb, string str);
    private static int getToken(RuntimeModuleBuilder mb, object obj, bool create_open_instance);
    private static int getMethodToken(RuntimeModuleBuilder mb, MethodBase method, Type[] opt_param_types);
    internal int GetToken(string str);
    private int GetPseudoToken(MemberInfo member, bool create_open_instance);
    internal int GetToken(MemberInfo member);
    internal int GetToken(MemberInfo member, bool create_open_instance);
    internal int GetToken(MethodBase method, Type[] opt_param_types);
    internal int GetToken(SignatureHelper helper);
    internal void RegisterToken(object obj, int token);
    internal ITokenGenerator GetTokenGenerator();
    internal static object RuntimeResolve(object obj);
    internal void CreateGlobalType();
    public virtual Assembly get_Assembly();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    public virtual Guid get_ModuleVersionId();
    public virtual bool IsResource();
    private protected virtual ModuleHandle GetModuleHandleImpl();
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual string ResolveString(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Byte[] ResolveSignature(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual int get_MetadataToken();
}
internal class System.Reflection.Emit.RuntimeParameterBuilder : ParameterBuilder {
    private MethodBase methodb;
    private string name;
    private CustomAttributeBuilder[] cattrs;
    private UnmanagedMarshal marshal_info;
    private ParameterAttributes attrs;
    private int position;
    private int table_idx;
    private object def_value;
    public int Attributes { get; }
    public string Name { get; }
    public int Position { get; }
    [DynamicDependencyAttribute("def_value")]
internal RuntimeParameterBuilder(MethodBase mb, int pos, ParameterAttributes attributes, string strParamName);
    public virtual int get_Attributes();
    public virtual string get_Name();
    public virtual int get_Position();
    public virtual void SetConstant(object defaultValue);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
}
internal class System.Reflection.Emit.RuntimePropertyBuilder : PropertyBuilder {
    private PropertyAttributes attrs;
    private string name;
    private Type type;
    private Type[] parameters;
    private CustomAttributeBuilder[] cattrs;
    private object def_value;
    private MethodBuilder set_method;
    private MethodBuilder get_method;
    private int table_idx;
    internal RuntimeTypeBuilder typeb;
    private Type[] returnModReq;
    private Type[] returnModOpt;
    private Type[][] paramModReq;
    private Type[][] paramModOpt;
    private CallingConventions callingConvention;
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public Module Module { get; }
    internal RuntimePropertyBuilder(RuntimeTypeBuilder tb, string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnModReq, Type[] returnModOpt, Type[] parameterTypes, Type[][] paramModReq, Type[][] paramModOpt);
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    protected virtual void AddOtherMethodCore(MethodBuilder mdBuilder);
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual void SetConstantCore(object defaultValue);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    protected virtual void SetGetMethodCore(MethodBuilder mdBuilder);
    protected virtual void SetSetMethodCore(MethodBuilder mdBuilder);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Module get_Module();
    private static NotSupportedException not_supported();
}
internal class System.Reflection.Emit.RuntimeTypeBuilder : TypeBuilder {
    private string tname;
    private string nspace;
    [DynamicallyAccessedMembersAttribute("-1")]
private Type parent;
    private Type nesting_type;
    internal Type[] interfaces;
    internal int num_methods;
    internal RuntimeMethodBuilder[] methods;
    internal RuntimeConstructorBuilder[] ctors;
    internal RuntimePropertyBuilder[] properties;
    internal int num_fields;
    internal RuntimeFieldBuilder[] fields;
    internal RuntimeEventBuilder[] events;
    private CustomAttributeBuilder[] cattrs;
    internal RuntimeTypeBuilder[] subtypes;
    internal TypeAttributes attrs;
    private int table_idx;
    private RuntimeModuleBuilder pmodule;
    private int class_size;
    private PackingSize packing_size;
    private IntPtr generic_container;
    private RuntimeGenericTypeParameterBuilder[] generic_params;
    [DynamicallyAccessedMembersAttribute("-1")]
private TypeInfo created;
    private int is_byreflike_set;
    private int state;
    internal bool is_hidden_global_type;
    private ITypeName fullname;
    private bool createTypeCalled;
    private Type underlying_type;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public Type UnderlyingSystemType { get; }
    public string FullName { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected PackingSize PackingSizeCore { get; }
    protected int SizeCore { get; }
    public Type ReflectedType { get; }
    public bool IsSZArray { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public int MetadataToken { get; }
    internal bool is_created { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericParameter { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    internal bool IsUserType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsByRefLike { get; }
    [DynamicDependencyAttribute("state")]
[DynamicDependencyAttribute("IsAssignableToInternal")]
internal RuntimeTypeBuilder(RuntimeModuleBuilder mb, TypeAttributes attr, int table_idx, bool is_hidden_global_type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2074:UnrecognizedReflectionPattern")]
[DynamicDependencyAttribute("state")]
[DynamicDependencyAttribute("IsAssignableToInternal")]
internal RuntimeTypeBuilder(RuntimeModuleBuilder mb, string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packing_size, int type_size, Type nesting_type);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    public virtual bool IsSubclassOf(Type c);
    public virtual Type get_UnderlyingSystemType();
    private ITypeName GetFullName();
    public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    protected virtual PackingSize get_PackingSizeCore();
    protected virtual int get_SizeCore();
    public virtual Type get_ReflectedType();
    protected virtual void AddInterfaceImplementationCore(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    protected virtual TypeBuilder DefineNestedTypeCore(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize);
    protected virtual ConstructorBuilder DefineConstructorCore(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
protected virtual ConstructorBuilder DefineDefaultConstructorCore(MethodAttributes attributes);
    private void append_method(RuntimeMethodBuilder mb);
    protected virtual MethodBuilder DefineMethodCore(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
protected virtual MethodBuilder DefinePInvokeMethodCore(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    protected virtual void DefineMethodOverrideCore(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    protected virtual FieldBuilder DefineFieldCore(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    protected virtual PropertyBuilder DefinePropertyCore(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    protected virtual ConstructorBuilder DefineTypeInitializerCore();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2110:ReflectionToDynamicallyAccessedMembers")]
private TypeInfo create_runtime_class();
    private bool is_nested_in(Type t);
    private bool has_ctor_method();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2083:UnrecognizedReflectionPattern")]
protected virtual TypeInfo CreateTypeInfoCore();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2074:UnrecognizedReflectionPattern")]
private void ResolveUserTypes();
    internal static void ResolveUserTypes(Type[] types);
    internal static Type ResolveUserType(Type t);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Type GetElementType();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    private MethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsSZArray();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual RuntimeTypeHandle get_TypeHandle();
    internal void SetCustomAttribute(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    protected virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    protected virtual EventBuilder DefineEventCore(string name, EventAttributes attributes, Type eventtype);
    protected virtual FieldBuilder DefineInitializedDataCore(string name, Byte[] data, FieldAttributes attributes);
    protected virtual FieldBuilder DefineUninitializedDataCore(string name, int size, FieldAttributes attributes);
    public virtual int get_MetadataToken();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2074:UnrecognizedReflectionPattern")]
protected virtual void SetParentCore(Type parent);
    internal int get_next_table_index(int table, int count);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    internal bool get_is_created();
    private static NotSupportedException not_supported();
    internal void check_not_created();
    private void check_created();
    private static void check_name(string argName, string name);
    public virtual string ToString();
    public virtual bool IsAssignableFrom(Type c);
    internal bool IsAssignableToInternal(Type c);
    protected virtual bool IsCreatedCore();
    public virtual Type[] GetGenericArguments();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_ContainsGenericParameters();
    public virtual bool get_IsGenericParameter();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual int get_GenericParameterPosition();
    public virtual MethodBase get_DeclaringMethod();
    protected virtual GenericTypeParameterBuilder[] DefineGenericParametersCore(String[] names);
    internal virtual bool get_IsUserType();
    internal virtual bool IsTypeBuilder();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static bool SetConstantValue(Type destType, object value, Object& destValue);
    private static void throw_argument_ConstantDoesntMatch();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsByRefLike();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.Emit.SignatureHelper : object {
    private ModuleBuilder module;
    private Type[] arguments;
    private SignatureHelperType type;
    private Type returnType;
    private CallingConventions callConv;
    private CallingConvention unmanagedCallConv;
    private Type[][] modreqs;
    private Type[][] modopts;
    [DynamicDependencyAttribute("modopts")]
internal SignatureHelper(ModuleBuilder module, SignatureHelperType type);
    public static SignatureHelper GetFieldSigHelper(Module mod);
    public static SignatureHelper GetLocalVarSigHelper(Module mod);
    public static SignatureHelper GetLocalVarSigHelper();
    public static SignatureHelper GetMethodSigHelper(CallingConventions callingConvention, Type returnType);
    [NullableContextAttribute("2")]
public static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, Type returnType);
    [NullableContextAttribute("2")]
public static SignatureHelper GetMethodSigHelper(Module mod, Type returnType, Type[] parameterTypes);
    [NullableContextAttribute("2")]
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] parameterTypes);
    [NullableContextAttribute("2")]
public static SignatureHelper GetPropertySigHelper(Module mod, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    [NullableContextAttribute("2")]
public static SignatureHelper GetPropertySigHelper(Module mod, CallingConventions callingConvention, Type returnType, Type[] requiredReturnTypeCustomModifiers, Type[] optionalReturnTypeCustomModifiers, Type[] parameterTypes, Type[][] requiredParameterTypeCustomModifiers, Type[][] optionalParameterTypeCustomModifiers);
    private static int AppendArray(Type[]& array, Type t);
    private static void AppendArrayAt(Type[][]& array, Type[] t, int pos);
    private static void ValidateParameterModifiers(string name, Type[] parameter_modifiers);
    private static void ValidateCustomModifier(int n, Type[][] custom_modifiers, string name);
    private static Exception MissingFeature();
    public void AddArguments(Type[] arguments, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public void AddArgument(Type argument, bool pinned);
    public void AddArgument(Type argument, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers);
    public void AddArgument(Type clsArgument);
    public void AddSentinel();
    private static bool CompareOK(Type[][] one, Type[][] two);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal Byte[] get_signature_local();
    internal Byte[] get_signature_field();
    public Byte[] GetSignature();
    public virtual string ToString();
    internal static SignatureHelper GetMethodSigHelper(Module mod, CallingConventions callingConvention, CallingConvention unmanagedCallingConvention, Type returnType, Type[] parameters);
}
public enum System.Reflection.Emit.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
    public static StackBehaviour Popref_popi_pop1;
}
internal class System.Reflection.Emit.SymbolType : TypeInfo {
    internal Type _baseType;
    internal TypeKind _typeKind;
    internal int _rank;
    internal Int32[] _iaLowerBound;
    internal Int32[] _iaUpperBound;
    private string _format;
    private bool _isSzArray;
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Guid GUID { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public string Namespace { get; }
    public Type BaseType { get; }
    public bool IsConstructedGenericType { get; }
    public Type UnderlyingSystemType { get; }
    internal SymbolType(Type baseType, TypeKind typeKind);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type FormCompoundType(string format, Type baseType, int curIndex);
    private void SetBounds(int lower, int upper);
    internal void SetFormat(string format, int curIndex, int length);
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual int GetArrayRank();
    public virtual Guid get_GUID();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_AssemblyQualifiedName();
    public virtual string ToString();
    public virtual string get_Namespace();
    public virtual Type get_BaseType();
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Emit.TypeBuilder : TypeInfo {
    public static int UnspecifiedTypeSize;
    public PackingSize PackingSize { get; }
    protected PackingSize PackingSizeCore { get; }
    public int Size { get; }
    protected int SizeCore { get; }
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:UnrecognizedReflectionPattern")]
public static ConstructorInfo GetConstructor(Type type, ConstructorInfo constructor);
    private static bool IsValidGetMethodType(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:UnrecognizedReflectionPattern")]
public static MethodInfo GetMethod(Type type, MethodInfo method);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:UnrecognizedReflectionPattern")]
public static FieldInfo GetField(Type type, FieldInfo field);
    public PackingSize get_PackingSize();
    protected abstract virtual PackingSize get_PackingSizeCore();
    public int get_Size();
    protected abstract virtual int get_SizeCore();
    public void AddInterfaceImplementation(Type interfaceType);
    protected abstract virtual void AddInterfaceImplementationCore(Type interfaceType);
    public Type CreateType();
    public TypeInfo CreateTypeInfo();
    protected abstract virtual TypeInfo CreateTypeInfoCore();
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes);
    public ConstructorBuilder DefineConstructor(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    protected abstract virtual ConstructorBuilder DefineConstructorCore(MethodAttributes attributes, CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);
    public ConstructorBuilder DefineDefaultConstructor(MethodAttributes attributes);
    protected abstract virtual ConstructorBuilder DefineDefaultConstructorCore(MethodAttributes attributes);
    public EventBuilder DefineEvent(string name, EventAttributes attributes, Type eventtype);
    protected abstract virtual EventBuilder DefineEventCore(string name, EventAttributes attributes, Type eventtype);
    public FieldBuilder DefineField(string fieldName, Type type, FieldAttributes attributes);
    public FieldBuilder DefineField(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    protected abstract virtual FieldBuilder DefineFieldCore(string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, FieldAttributes attributes);
    public GenericTypeParameterBuilder[] DefineGenericParameters(String[] names);
    protected abstract virtual GenericTypeParameterBuilder[] DefineGenericParametersCore(String[] names);
    public FieldBuilder DefineInitializedData(string name, Byte[] data, FieldAttributes attributes);
    protected abstract virtual FieldBuilder DefineInitializedDataCore(string name, Byte[] data, FieldAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, Type returnType, Type[] parameterTypes);
    public MethodBuilder DefineMethod(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    protected abstract virtual MethodBuilder DefineMethodCore(string name, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public void DefineMethodOverride(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    protected abstract virtual void DefineMethodOverrideCore(MethodInfo methodInfoBody, MethodInfo methodInfoDeclaration);
    public TypeBuilder DefineNestedType(string name);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
    protected abstract virtual TypeBuilder DefineNestedTypeCore(string name, TypeAttributes attr, Type parent, Type[] interfaces, PackingSize packSize, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, int typeSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize);
    public TypeBuilder DefineNestedType(string name, TypeAttributes attr, Type parent, PackingSize packSize, int typeSize);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
public MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    [RequiresUnreferencedCodeAttribute("P/Invoke marshalling may dynamically access members that could be trimmed.")]
protected abstract virtual MethodBuilder DefinePInvokeMethodCore(string name, string dllName, string entryName, MethodAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, CallingConvention nativeCallConv, CharSet nativeCharSet);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public PropertyBuilder DefineProperty(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    protected abstract virtual PropertyBuilder DefinePropertyCore(string name, PropertyAttributes attributes, CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);
    public ConstructorBuilder DefineTypeInitializer();
    protected abstract virtual ConstructorBuilder DefineTypeInitializerCore();
    public FieldBuilder DefineUninitializedData(string name, int size, FieldAttributes attributes);
    protected abstract virtual FieldBuilder DefineUninitializedDataCore(string name, int size, FieldAttributes attributes);
    public bool IsCreated();
    protected abstract virtual bool IsCreatedCore();
    public void SetCustomAttribute(ConstructorInfo con, Byte[] binaryAttribute);
    [NullableContextAttribute("0")]
protected abstract virtual void SetCustomAttributeCore(ConstructorInfo con, ReadOnlySpan`1<byte> binaryAttribute);
    public void SetCustomAttribute(CustomAttributeBuilder customBuilder);
    [NullableContextAttribute("2")]
public void SetParent(Type parent);
    [NullableContextAttribute("2")]
protected abstract virtual void SetParentCore(Type parent);
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType(int rank);
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
}
internal class System.Reflection.Emit.TypeBuilderInstantiation : TypeInfo {
    private Type _genericType;
    private Type[] _typeArguments;
    private string _strFullQualName;
    internal Hashtable _hashtable;
    internal bool IsUserType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public Guid GUID { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericType { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public int GenericParameterPosition { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    internal TypeBuilderInstantiation(Type type, Type[] inst);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:UnrecognizedReflectionPattern")]
internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    internal virtual bool get_IsUserType();
    internal virtual MethodInfo GetMethod(MethodInfo fromNonInstantiated);
    internal virtual ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated);
    internal virtual FieldInfo GetField(FieldInfo fromNoninstanciated);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static Type MakeGenericType(Type type, Type[] typeArguments);
    public virtual string ToString();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual Module get_Module();
    public virtual Type MakePointerType();
    public virtual Type MakeByRefType();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Guid get_GUID();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2055:UnrecognizedReflectionPattern")]
private Type Substitute(Type[] substitutes);
    public virtual Type get_BaseType();
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Type[] GetGenericArguments();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual int get_GenericParameterPosition();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_ContainsGenericParameters();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type GetGenericTypeDefinition();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] inst);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsSubclassOf(Type c);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal enum System.Reflection.Emit.TypeKind : Enum {
    public int value__;
    public static TypeKind IsArray;
    public static TypeKind IsPointer;
    public static TypeKind IsByRef;
}
internal class System.Reflection.Emit.TypeNameBuilder : object {
    private StringBuilder _str;
    private int _instNesting;
    private bool _firstInstArg;
    private bool _nestedName;
    private bool _hasAssemblySpec;
    private List`1<int> _stack;
    private int _stackIdx;
    private void OpenGenericArguments();
    private void CloseGenericArguments();
    private void OpenGenericArgument();
    private void CloseGenericArgument();
    private void AddName(string name);
    private void AddArray(int rank);
    private void AddAssemblySpec(string assemblySpec);
    public virtual string ToString();
    private static bool ContainsReservedChar(string name);
    private static bool IsTypeNameReservedChar(char ch);
    private void EscapeName(string name);
    private void EscapeAssemblyName(string name);
    private void EscapeEmbeddedAssemblyName(string name);
    private void PushOpenGenericArgument();
    private void PopOpenGenericArgument();
    private void Append(string pStr);
    private void Append(char c);
    internal static string ToString(Type type, Format format);
    private void AddElementType(Type type);
    private void AddAssemblyQualifiedName(Type type, Format format);
}
internal class System.Reflection.Emit.UnmanagedMarshal : object {
    private int count;
    private UnmanagedType t;
    private UnmanagedType tbase;
    private string guid;
    private string mcookie;
    private string marshaltype;
    internal Type marshaltyperef;
    private int param_num;
    private bool has_size;
    private UnmanagedMarshal(UnmanagedType maint, int cnt);
    private UnmanagedMarshal(UnmanagedType maint, UnmanagedType elemt);
    public static UnmanagedMarshal DefineByValArray(int elemCount);
    public static UnmanagedMarshal DefineByValTStr(int elemCount);
    public static UnmanagedMarshal DefineLPArray(UnmanagedType elemType);
    public static UnmanagedMarshal DefineUnmanagedMarshal(UnmanagedType unmanagedType);
    internal static UnmanagedMarshal DefineLPArrayInternal(UnmanagedType elemType, int sizeConst, int sizeParamIndex);
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
    public static EventAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public EventAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public MethodInfo AddMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public MethodInfo RaiseMethod { get; }
    public bool IsMulticast { get; }
    public Type EventHandlerType { get; }
    public virtual MemberTypes get_MemberType();
    public abstract virtual EventAttributes get_Attributes();
    public bool get_IsSpecialName();
    [NullableContextAttribute("1")]
public MethodInfo[] GetOtherMethods();
    [NullableContextAttribute("1")]
public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo get_AddMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual MethodInfo get_RaiseMethod();
    public MethodInfo GetAddMethod();
    public MethodInfo GetRemoveMethod();
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual bool get_IsMulticast();
    public virtual Type get_EventHandlerType();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void AddEventHandler(object target, Delegate handler);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.ExceptionHandlingClause : object {
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes ReservedMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    private static FieldInfo internal_from_handle_type(IntPtr field_handle, IntPtr type_handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    internal virtual int GetFieldOffset();
    private MarshalAsAttribute get_marshal_info();
    internal Object[] GetPseudoCustomAttributes();
    internal CustomAttributeData[] GetPseudoCustomAttributesData();
    public virtual MemberTypes get_MemberType();
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual Type get_FieldType();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(FieldInfo left, FieldInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(FieldInfo left, FieldInfo right);
    [NullableContextAttribute("2")]
public abstract virtual object GetValue(object obj);
    [NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    [NullableContextAttribute("2")]
public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    [NullableContextAttribute("2")]
public virtual object GetRawConstantValue();
    public virtual Type GetModifiedFieldType();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
[NullableContextAttribute("1")]
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
    public static ImageFileMachine ARM;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.InterfaceMapping : ValueType {
    public Type TargetType;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public MethodInfo[] InterfaceMethods;
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class System.Reflection.IntrospectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static TypeInfo GetTypeInfo(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum System.Reflection.InvocationFlags : Enum {
    public UInt32 value__;
    public static InvocationFlags Unknown;
    public static InvocationFlags Initialized;
    public static InvocationFlags NoInvoke;
    public static InvocationFlags RunClassConstructor;
    public static InvocationFlags NoConstructorInvoke;
    public static InvocationFlags IsConstructor;
    public static InvocationFlags IsDelegateConstructor;
    public static InvocationFlags ContainsStackPointers;
    public static InvocationFlags SpecialField;
    public static InvocationFlags FieldSpecialCast;
}
internal static class System.Reflection.InvokerEmitUtil : object {
    public static InvokeFunc_Obj4Args CreateInvokeDelegate_Obj4Args(MethodBase method, bool backwardsCompat);
    public static InvokeFunc_ObjSpanArgs CreateInvokeDelegate_ObjSpanArgs(MethodBase method, bool backwardsCompat);
    public static InvokeFunc_RefArgs CreateInvokeDelegate_RefArgs(MethodBase method, bool backwardsCompat);
    private static void Unbox(ILGenerator il, Type parameterType);
    private static void EmitCallAndReturnHandling(ILGenerator il, MethodBase method, bool emitNew, bool backwardsCompat);
}
[NullableContextAttribute("1")]
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public abstract virtual Type get_UnderlyingSystemType();
}
[NullableContextAttribute("1")]
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
internal class System.Reflection.LoaderAllocator : object {
    private LoaderAllocatorScout m_scout;
    private Object[] m_slots;
    private Object[] m_hashes;
    private int m_nslots;
    private LoaderAllocator(IntPtr native);
}
internal class System.Reflection.LoaderAllocatorScout : object {
    internal IntPtr m_native;
    internal LoaderAllocatorScout(IntPtr native);
    private static bool Destroy(IntPtr native);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.LocalVariableInfo : object {
    public Type LocalType { get; }
    public int LocalIndex { get; }
    public bool IsPinned { get; }
    public virtual Type get_LocalType();
    public virtual int get_LocalIndex();
    public virtual bool get_IsPinned();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.ManifestResourceInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <ReferencedAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceLocation <ResourceLocation>k__BackingField;
    public Assembly ReferencedAssembly { get; }
    public string FileName { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    [CompilerGeneratedAttribute]
public virtual Assembly get_ReferencedAssembly();
    [CompilerGeneratedAttribute]
public virtual string get_FileName();
    [CompilerGeneratedAttribute]
public virtual ResourceLocation get_ResourceLocation();
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.MemberInfo : object {
    public MemberTypes MemberType { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Module Module { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsCollectible { get; }
    public int MetadataToken { get; }
    internal bool HasSameMetadataDefinitionAsCore(MemberInfo other);
    public abstract virtual MemberTypes get_MemberType();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public abstract virtual Type get_ReflectedType();
    public virtual Module get_Module();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool get_IsCollectible();
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(MemberInfo left, MemberInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[ExtensionAttribute]
public static class System.Reflection.Metadata.AssemblyExtensions : object {
    [ExtensionAttribute]
[CLSCompliantAttribute("False")]
public static bool TryGetRawMetadata(Assembly assembly, Byte*& blob, Int32& length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.Metadata.MetadataUpdateHandlerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <HandlerType>k__BackingField;
    [DynamicallyAccessedMembersAttribute("24")]
public Type HandlerType { get; }
    public MetadataUpdateHandlerAttribute(Type handlerType);
    [CompilerGeneratedAttribute]
public Type get_HandlerType();
}
public static class System.Reflection.Metadata.MetadataUpdater : object {
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    private static Lazy`1<string> s_ApplyUpdateCapabilities;
    public static bool IsSupported { get; }
    private static MetadataUpdater();
    public static void ApplyUpdate(Assembly assembly, ReadOnlySpan`1<byte> metadataDelta, ReadOnlySpan`1<byte> ilDelta, ReadOnlySpan`1<byte> pdbDelta);
    internal static string GetCapabilities();
    [CompilerGeneratedAttribute]
public static bool get_IsSupported();
    private static string InitializeApplyUpdateCapabilities();
    private static int ApplyUpdateEnabled(int justComponentCheck);
    private static string GetApplyUpdateCapabilities();
    private static void ApplyUpdate_internal(IntPtr base_assm, Byte* dmeta_bytes, int dmeta_length, Byte* dil_bytes, int dil_length, Byte* dpdb_bytes, int dpdb_length);
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public CallingConventions CallingConvention { get; }
    public bool IsAbstract { get; }
    public bool IsConstructor { get; }
    public bool IsFinal { get; }
    public bool IsHideBySig { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool ContainsGenericParameters { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    [RequiresUnreferencedCodeAttribute("Metadata for the method might be incomplete or removed")]
public static MethodBase GetCurrentMethod();
    internal virtual ParameterInfo[] GetParametersNoCopy();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal virtual Type GetParameterType(int pos);
    internal virtual int get_next_table_index(int table, int count);
    [NullableContextAttribute("1")]
public abstract virtual ParameterInfo[] GetParameters();
    public abstract virtual MethodAttributes get_Attributes();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    [RequiresUnreferencedCodeAttribute("Trimming may change method bodies. For example it can change some instructions, remove branches or local variables.")]
public virtual MethodBody GetMethodBody();
    public virtual CallingConventions get_CallingConvention();
    public bool get_IsAbstract();
    public bool get_IsConstructor();
    public bool get_IsFinal();
    public bool get_IsHideBySig();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsConstructedGenericMethod();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    [NullableContextAttribute("1")]
public virtual Type[] GetGenericArguments();
    public virtual bool get_ContainsGenericParameters();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
    internal static void AppendParameters(ValueStringBuilder& sbParamList, Type[] parameterTypes, CallingConventions callingConvention);
    internal virtual Type[] GetParameterTypes();
    internal static object HandleTypeMissing(ParameterInfo paramInfo, RuntimeType sigType);
}
internal class System.Reflection.MethodBaseInvoker : object {
    private InvokeFunc_ObjSpanArgs _invokeFunc_ObjSpanArgs;
    private InvokeFunc_RefArgs _invokeFunc_RefArgs;
    private InvokerStrategy _strategy;
    internal InvocationFlags _invocationFlags;
    private InvokerArgFlags[] _invokerArgFlags;
    private RuntimeType[] _argTypes;
    private MethodBase _method;
    private int _argCount;
    private bool _needsByRefStrategy;
    internal MethodBaseInvoker(RuntimeMethodInfo method);
    internal MethodBaseInvoker(RuntimeConstructorInfo constructor);
    private MethodBaseInvoker(MethodBase method, RuntimeType[] argumentTypes);
    private object InterpretedInvoke_Method(object obj, IntPtr* args);
    internal object InterpretedInvoke_Constructor(object obj, IntPtr* args);
    [DoesNotReturnAttribute]
internal static void ThrowTargetParameterCountException();
    internal object InvokeWithNoArgs(object obj, BindingFlags invokeAttr);
    internal object InvokeWithOneArg(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    internal object InvokeWithFewArgs(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    internal object InvokeDirectByRefWithFewArgs(object obj, Span`1<object> copyOfArgs, BindingFlags invokeAttr);
    internal object InvokeWithManyArgs(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    internal void CopyBack(Object[] dest, Span`1<object> copyOfParameters, Span`1<bool> shouldCopyBack);
    internal void CheckArguments(ReadOnlySpan`1<object> parameters, Span`1<object> copyOfParameters, Span`1<bool> shouldCopyBack, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    private static bool TryByRefFastPath(RuntimeType type, Object& arg);
    internal object InvokeConstructorWithoutAlloc(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    internal object InvokeConstructorWithoutAlloc(object obj, bool wrapInTargetInvocationException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.MethodBody : object {
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    [NullableContextAttribute("2")]
public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes AggressiveOptimization;
    public static MethodImplAttributes MaxMethodImplVal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public abstract virtual MethodInfo GetBaseDefinition();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public T CreateDelegate();
    public T CreateDelegate(object target);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(MethodInfo left, MethodInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MethodInfo left, MethodInfo right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.MethodInvoker : object {
    private InvokeFunc_ObjSpanArgs _invokeFunc_ObjSpanArgs;
    private InvokeFunc_Obj4Args _invokeFunc_Obj4Args;
    private InvokeFunc_RefArgs _invokeFunc_RefArgs;
    private InvokerStrategy _strategy;
    private int _argCount;
    private RuntimeType[] _argTypes;
    private InvocationFlags _invocationFlags;
    private InvokerArgFlags[] _invokerArgFlags;
    private MethodBase _method;
    private bool _needsByRefStrategy;
    private bool _isStatic;
    private MethodInvoker(RuntimeMethodInfo method);
    private MethodInvoker(DynamicMethod method);
    private MethodInvoker(RuntimeConstructorInfo constructor);
    private MethodInvoker(MethodBase method, RuntimeType[] argumentTypes);
    private object InterpretedInvoke_Method(object obj, IntPtr* args);
    private object InterpretedInvoke_Constructor(object obj, IntPtr* args);
    [NullableContextAttribute("1")]
public static MethodInvoker Create(MethodBase method);
    public object Invoke(object obj);
    public object Invoke(object obj, object arg1);
    public object Invoke(object obj, object arg1, object arg2);
    public object Invoke(object obj, object arg1, object arg2, object arg3);
    public object Invoke(object obj, object arg1, object arg2, object arg3, object arg4);
    private object InvokeImpl(object obj, object arg1, object arg2, object arg3, object arg4);
    public object Invoke(object obj, Span`1<object> arguments);
    private void ThrowForBadInvocationFlags();
    internal object InvokeWithFewArgs(object obj, Span`1<object> arguments);
    internal object InvokeDirectByRef(object obj, object arg1, object arg2, object arg3, object arg4);
    internal object InvokeDirectByRefWithFewArgs(object obj, Span`1<object> copyOfArgs);
    internal object InvokeWithManyArgs(object obj, Span`1<object> arguments);
    internal void CopyBack(Span`1<object> dest, Span`1<object> copyOfParameters, Span`1<bool> shouldCopyBack);
    private bool CheckArgument(Object& arg, int i);
}
internal static class System.Reflection.MethodInvokerCommon : object {
    internal static void Initialize(RuntimeType[] argumentTypes, InvokerStrategy& strategy, InvokerArgFlags[]& invokerFlags, Boolean& needsByRefStrategy);
    internal static void ValidateInvokeTarget(object target, MethodBase method);
    internal static void DetermineStrategy_ObjSpanArgs(InvokerStrategy& strategy, InvokeFunc_ObjSpanArgs& invokeFunc_ObjSpanArgs, MethodBase method, bool needsByRefStrategy, bool backwardsCompat);
    internal static void DetermineStrategy_Obj4Args(InvokerStrategy& strategy, InvokeFunc_Obj4Args& invokeFunc_Obj4Args, MethodBase method, bool needsByRefStrategy, bool backwardsCompat);
    internal static void DetermineStrategy_RefArgs(InvokerStrategy& strategy, InvokeFunc_RefArgs& invokeFunc_RefArgs, MethodBase method, bool backwardsCompat);
}
public class System.Reflection.Missing : object {
    [NullableAttribute("1")]
public static Missing Value;
    private static Missing();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class System.Reflection.ModifiedFunctionPointerType : ModifiedType {
    private Type[] _parameterTypes;
    private Type _returnType;
    internal ModifiedFunctionPointerType(Type unmodifiedType, TypeSignature typeSignature);
    public virtual Type GetFunctionPointerReturnType();
    public virtual Type[] GetFunctionPointerParameterTypes();
    public virtual Type[] GetFunctionPointerCallingConventions();
    [CompilerGeneratedAttribute]
private Type <GetFunctionPointerReturnType>g__Initialize|4_0();
    [CompilerGeneratedAttribute]
private Type[] <GetFunctionPointerParameterTypes>g__Initialize|5_0();
}
internal class System.Reflection.ModifiedGenericType : ModifiedType {
    private Type[] _genericArguments;
    internal ModifiedGenericType(Type unmodifiedType, TypeSignature typeSignature);
    public virtual Type[] GetGenericArguments();
    [CompilerGeneratedAttribute]
private Type[] <GetGenericArguments>g__Initialize|2_0();
}
internal class System.Reflection.ModifiedHasElementType : ModifiedType {
    private Type _elementType;
    internal ModifiedHasElementType(Type unmodifiedType, TypeSignature typeSignature);
    public virtual Type GetElementType();
    [CompilerGeneratedAttribute]
private Type <GetElementType>g__Initialize|2_0();
}
internal class System.Reflection.ModifiedType : Type {
    private TypeSignature _typeSignature;
    private Type _unmodifiedType;
    protected Type UnmodifiedType { get; }
    public Type UnderlyingSystemType { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericType { get; }
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    public string FullName { get; }
    public string Namespace { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsEnum { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsCollectible { get; }
    public bool IsFunctionPointer { get; }
    public bool IsUnmanagedFunctionPointer { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    internal ModifiedType(Type unmodifiedType, TypeSignature typeSignature);
    internal static Type Create(Type sourceType, object sourceTypeInfo, int parameterIndex);
    internal Type GetTypeParameter(Type unmodifiedType, int index);
    internal SignatureCallingConvention GetCallingConventionFromFunctionPointer();
    private Type[] GetCustomModifiers(bool required);
    protected static Type Create(Type unmodifiedType, TypeSignature typeSignature);
    protected Type get_UnmodifiedType();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual bool Equals(object obj);
    public virtual bool Equals(Type other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Type get_UnderlyingSystemType();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type GetGenericTypeDefinition();
    public virtual bool get_IsGenericType();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual string get_Namespace();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetFunctionPointerCallingConventions();
    public virtual Type[] GetFunctionPointerParameterTypes();
    public virtual Type GetFunctionPointerReturnType();
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual int GetArrayRank();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    protected virtual bool IsArrayImpl();
    public virtual bool get_IsEnum();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsCollectible();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsUnmanagedFunctionPointer();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public Assembly Assembly { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string FullyQualifiedName { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string Name { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public ModuleHandle ModuleHandle { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private static Module();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual string get_Name();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_ScopeName();
    public ModuleHandle get_ModuleHandle();
    private protected virtual ModuleHandle GetModuleHandleImpl();
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual bool IsResource();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo GetMethod(string name);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo GetMethod(string name, Type[] types);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Methods might be removed")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo[] GetMethods();
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public FieldInfo GetField(string name);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public FieldInfo[] GetFields();
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetTypes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public FieldInfo ResolveField(int metadataToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public MemberInfo ResolveMember(int metadataToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public MethodBase ResolveMethod(int metadataToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Byte[] ResolveSignature(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual string ResolveString(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public Type ResolveType(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(Module left, Module right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Module left, Module right);
    public virtual string ToString();
    private static bool FilterTypeNameImpl(Type cls, object filterCriteria, StringComparison comparison);
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
internal class System.Reflection.MonoArrayMethod : MethodInfo {
    internal RuntimeMethodHandle mhandle;
    internal Type parent;
    internal Type ret;
    internal Type[] parameters;
    internal string name;
    internal int table_idx;
    internal CallingConventions call_conv;
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    internal MonoArrayMethod(Type arrayClass, string methodName, CallingConventions callingConvention, Type returnType, Type[] parameterTypes);
    public virtual MethodInfo GetBaseDefinition();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual string ToString();
}
internal class System.Reflection.MonoEventInfo : ValueType {
    public Type declaring_type;
    public Type reflected_type;
    public string name;
    public MethodInfo add_method;
    public MethodInfo remove_method;
    public MethodInfo raise_method;
    public EventAttributes attrs;
    public MethodInfo[] other_methods;
}
internal class System.Reflection.MonoMethodInfo : ValueType {
    private Type parent;
    private Type ret;
    internal MethodAttributes attrs;
    internal MethodImplAttributes iattrs;
    private CallingConventions callconv;
    private static void get_method_info(IntPtr handle, MonoMethodInfo& info);
    private static int get_method_attributes(IntPtr handle);
    internal static MonoMethodInfo GetMethodInfo(IntPtr handle);
    internal static Type GetDeclaringType(IntPtr handle);
    internal static Type GetReturnType(IntPtr handle);
    internal static MethodAttributes GetAttributes(IntPtr handle);
    internal static CallingConventions GetCallingConvention(IntPtr handle);
    internal static MethodImplAttributes GetMethodImplementationFlags(IntPtr handle);
    private static ParameterInfo[] get_parameter_info(IntPtr handle, MemberInfo member);
    internal static ParameterInfo[] GetParametersInfo(IntPtr handle, MemberInfo member);
    private static MarshalAsAttribute get_retval_marshal(IntPtr handle);
    internal static ParameterInfo GetReturnParameterInfo(RuntimeMethodInfo method);
}
internal class System.Reflection.MonoPropertyInfo : ValueType {
    public Type parent;
    public Type declaring_type;
    public string name;
    public MethodInfo get_method;
    public MethodInfo set_method;
    public PropertyAttributes attrs;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.NullabilityInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityState <ReadState>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityState <WriteState>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityInfo <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private NullabilityInfo[] <GenericTypeArguments>k__BackingField;
    public Type Type { get; }
    public NullabilityState ReadState { get; internal set; }
    public NullabilityState WriteState { get; internal set; }
    [NullableAttribute("2")]
public NullabilityInfo ElementType { get; }
    public NullabilityInfo[] GenericTypeArguments { get; }
    internal NullabilityInfo(Type type, NullabilityState readState, NullabilityState writeState, NullabilityInfo elementType, NullabilityInfo[] typeArguments);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public NullabilityState get_ReadState();
    [CompilerGeneratedAttribute]
internal void set_ReadState(NullabilityState value);
    [CompilerGeneratedAttribute]
public NullabilityState get_WriteState();
    [CompilerGeneratedAttribute]
internal void set_WriteState(NullabilityState value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public NullabilityInfo get_ElementType();
    [CompilerGeneratedAttribute]
public NullabilityInfo[] get_GenericTypeArguments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.NullabilityInfoContext : object {
    private Dictionary`2<Module, NotAnnotatedStatus> _publicOnlyModules;
    private Dictionary`2<MemberInfo, NullabilityState> _context;
    [CompilerGeneratedAttribute]
private static bool <IsSupported>k__BackingField;
    internal static bool IsSupported { get; }
    private static NullabilityInfoContext();
    [CompilerGeneratedAttribute]
internal static bool get_IsSupported();
    private Nullable`1<NullabilityState> GetNullableContext(MemberInfo memberInfo);
    public NullabilityInfo Create(ParameterInfo parameterInfo);
    private void CheckParameterMetadataType(ParameterInfo parameter, NullabilityInfo nullability);
    private static MethodInfo GetMethodMetadataDefinition(MethodInfo method);
    private static void CheckNullabilityAttributes(NullabilityInfo nullability, IList`1<CustomAttributeData> attributes);
    public NullabilityInfo Create(PropertyInfo propertyInfo);
    private bool IsPrivateOrInternalMethodAndAnnotationDisabled(MethodBase method);
    public NullabilityInfo Create(EventInfo eventInfo);
    public NullabilityInfo Create(FieldInfo fieldInfo);
    private static void EnsureIsSupported();
    private bool IsPrivateOrInternalFieldAndAnnotationDisabled(FieldInfo fieldInfo);
    private bool IsPublicOnly(bool isPrivate, bool isFamilyAndAssembly, bool isAssembly, Module module);
    private static NotAnnotatedStatus PopulateAnnotationInfo(IList`1<CustomAttributeData> customAttributes);
    private NullabilityInfo GetNullabilityInfo(MemberInfo memberInfo, Type type, NullableAttributeStateParser parser);
    private NullabilityInfo GetNullabilityInfo(MemberInfo memberInfo, Type type, NullableAttributeStateParser parser, Int32& index);
    private static NullableAttributeStateParser CreateParser(IList`1<CustomAttributeData> customAttributes);
    private void TryLoadGenericMetaTypeNullability(MemberInfo memberInfo, NullabilityInfo nullability);
    private static MemberInfo GetMemberMetadataDefinition(MemberInfo member);
    private static Type GetPropertyMetaType(PropertyInfo property);
    private void CheckGenericParameters(NullabilityInfo nullability, MemberInfo metaMember, Type metaType, Type reflectedType);
    private bool TryUpdateGenericParameterNullability(NullabilityInfo nullability, Type genericParameter, Type reflectedType);
    private bool TryUpdateGenericTypeParameterNullabilityFromReflectedType(NullabilityInfo nullability, Type genericParameter, Type context, Type reflectedType);
    private static bool TryPopulateNullabilityInfo(NullabilityInfo nullability, NullableAttributeStateParser parser, Int32& index);
    private static NullabilityState TranslateByte(object value);
    private static NullabilityState TranslateByte(byte b);
    private static bool IsValueTypeOrValueTypeByRef(Type type);
    [CompilerGeneratedAttribute]
internal static int <TryUpdateGenericTypeParameterNullabilityFromReflectedType>g__CountNullabilityStates|28_0(Type type);
}
public enum System.Reflection.NullabilityState : Enum {
    public int value__;
    public static NullabilityState Unknown;
    public static NullabilityState NotNull;
    public static NullabilityState Nullable;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <AssemblyIsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    [CompilerGeneratedAttribute]
public bool get_AssemblyIsPrivate();
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <StripAfterObfuscation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyToMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    public bool StripAfterObfuscation { get; public set; }
    public bool Exclude { get; public set; }
    public bool ApplyToMembers { get; public set; }
    public string Feature { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_StripAfterObfuscation();
    [CompilerGeneratedAttribute]
public void set_StripAfterObfuscation(bool value);
    [CompilerGeneratedAttribute]
public bool get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(bool value);
    [CompilerGeneratedAttribute]
public bool get_ApplyToMembers();
    [CompilerGeneratedAttribute]
public void set_ApplyToMembers(bool value);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
public void set_Feature(string value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    [NullableAttribute("2")]
protected Type ClassImpl;
    [NullableAttribute("2")]
protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    [NullableAttribute("2")]
protected string NameImpl;
    protected int PositionImpl;
    private static int MetadataToken_ParamDef;
    public ParameterAttributes Attributes { get; }
    public MemberInfo Member { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    [NullableAttribute("2")]
public object RawDefaultValue { get; }
    public bool HasDefaultValue { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual MemberInfo get_Member();
    [NullableContextAttribute("2")]
public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    [NullableContextAttribute("2")]
public virtual object get_DefaultValue();
    [NullableContextAttribute("2")]
public virtual object get_RawDefaultValue();
    public virtual bool get_HasDefaultValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Type GetModifiedParameterType();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_MetadataToken();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual object GetRealObject(StreamingContext context);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private Boolean[] _byRef;
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[FlagsAttribute]
internal enum System.Reflection.PInfo : Enum {
    public int value__;
    public static PInfo Attributes;
    public static PInfo GetMethod;
    public static PInfo SetMethod;
    public static PInfo ReflectedType;
    public static PInfo DeclaringType;
    public static PInfo Name;
}
[FlagsAttribute]
internal enum System.Reflection.PInvokeAttributes : Enum {
    public int value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes BestFitUseAssem;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes ThrowOnUnmappableCharUseAssem;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdcall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes MaxValue;
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    private Void* _ptr;
    private RuntimeType _ptrType;
    private Pointer(Void* ptr, RuntimeType ptrType);
    [NullableContextAttribute("1")]
public static object Box(Void* ptr, Type type);
    public static Void* Unbox(object ptr);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal RuntimeType GetPointerType();
    internal IntPtr GetPointerValue();
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public MemberTypes MemberType { get; }
    [NullableAttribute("1")]
public Type PropertyType { get; }
    public PropertyAttributes Attributes { get; }
    public bool IsSpecialName { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public MethodInfo SetMethod { get; }
    public virtual MemberTypes get_MemberType();
    [NullableContextAttribute("1")]
public abstract virtual Type get_PropertyType();
    [NullableContextAttribute("1")]
public abstract virtual ParameterInfo[] GetIndexParameters();
    public abstract virtual PropertyAttributes get_Attributes();
    public bool get_IsSpecialName();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    [NullableContextAttribute("1")]
public MethodInfo[] GetAccessors();
    [NullableContextAttribute("1")]
public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo get_GetMethod();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo get_SetMethod();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    [NullableContextAttribute("1")]
public virtual Type GetModifiedPropertyType();
    [NullableContextAttribute("1")]
public virtual Type[] GetOptionalCustomModifiers();
    [NullableContextAttribute("1")]
public virtual Type[] GetRequiredCustomModifiers();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public object GetValue(object obj);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public void SetValue(object obj, object value);
    [DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.ReflectionContext : object {
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
    public virtual TypeInfo GetTypeForObject(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [CompilerGeneratedAttribute]
private Type[] <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception[] <LoaderExceptions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] Types { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Exception[] LoaderExceptions { get; }
    public string Message { get; }
    [NullableContextAttribute("2")]
public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    [NullableContextAttribute("2")]
public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private ReflectionTypeLoadException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Type[] get_Types();
    [CompilerGeneratedAttribute]
public Exception[] get_LoaderExceptions();
    public virtual string get_Message();
    public virtual string ToString();
    private string CreateString(bool isMessage);
}
internal enum System.Reflection.ResolveTokenError : Enum {
    public int value__;
    public static ResolveTokenError OutOfRange;
    public static ResolveTokenError BadTable;
    public static ResolveTokenError Other;
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
    public static ResourceLocation Embedded;
}
internal abstract class System.Reflection.RtFieldInfo : FieldInfo {
}
internal class System.Reflection.RuntimeAssembly : Assembly {
    private IntPtr _mono_assembly;
    private LoaderAllocator m_keepalive;
    private ResolveEventHolder resolve_event_holder;
    public MethodInfo EntryPoint { get; }
    public bool ReflectionOnly { get; }
    [ObsoleteAttribute("Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location.")]
[RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public string CodeBase { get; }
    public string FullName { get; }
    public Module ManifestModule { get; }
    [ObsoleteAttribute("The Global Assembly Cache is not supported.")]
public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public string ImageRuntimeVersion { get; }
    public string Location { get; }
    public bool IsCollectible { get; }
    internal IntPtr GetUnderlyingNativeHandle();
    private static void GetEntryPoint(QCallAssembly assembly, ObjectHandleOnStack res);
    public virtual MethodInfo get_EntryPoint();
    public virtual bool get_ReflectionOnly();
    public virtual string get_CodeBase();
    public virtual string get_FullName();
    public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public virtual Module get_ManifestModule();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual string get_ImageRuntimeVersion();
    public virtual string get_Location();
    public virtual bool get_IsCollectible();
    private static void GetManifestResourceNames(QCallAssembly assembly_h, ObjectHandleOnStack res);
    public virtual String[] GetManifestResourceNames();
    private static void GetExportedTypes(QCallAssembly assembly_h, ObjectHandleOnStack res);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetExportedTypes();
    private static void GetTopLevelForwardedTypes(QCallAssembly assembly_h, ObjectHandleOnStack res);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetForwardedTypes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
private static void AddPublicNestedTypes(Type type, List`1<Type> types, List`1<Exception> exceptions);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual AssemblyName GetName(bool copiedName);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Module GetModule(string name);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    internal static AssemblyName[] GetReferencedAssemblies(Assembly assembly);
    [RequiresUnreferencedCodeAttribute("Assembly references might be removed")]
public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    internal static Assembly InternalGetSatelliteAssembly(Assembly assembly, CultureInfo culture, Version version, bool throwOnFileNotFound);
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream GetFile(string name);
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles(bool getResourceModules);
    internal static RuntimeAssembly InternalLoad(AssemblyName assemblyRef, StackCrawlMark& stackMark, AssemblyLoadContext assemblyLoadContext);
    private static void GetInfo(QCallAssembly assembly, ObjectHandleOnStack res, AssemblyInfoKind kind);
    private string GetInfo(AssemblyInfoKind kind);
    private static bool GetManifestResourceInfoInternal(QCallAssembly assembly, string name, ManifestResourceInfo info);
    private static IntPtr GetManifestResourceInternal(QCallAssembly assembly, string name, Int32& size, ObjectHandleOnStack module);
    private static void GetManifestModuleInternal(QCallAssembly assembly, ObjectHandleOnStack res);
    private static void GetModulesInternal(QCallAssembly assembly, ObjectHandleOnStack res);
    private static IntPtr InternalGetReferencedAssemblies(Assembly assembly);
    internal string GetSimpleName();
}
internal class System.Reflection.RuntimeConstructorInfo : ConstructorInfo {
    internal IntPtr mhandle;
    private string name;
    private Type reftype;
    private string toString;
    private RuntimeType[] parameterTypes;
    private MethodBaseInvoker invoker;
    internal InvocationFlags InvocationFlags { get; }
    internal MethodBaseInvoker Invoker { get; }
    public Module Module { get; }
    internal RuntimeType[] ArgumentTypes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    internal InvocationFlags get_InvocationFlags();
    internal MethodBaseInvoker get_Invoker();
    public virtual Module get_Module();
    internal RuntimeModule GetRuntimeModule();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal RuntimeType[] get_ArgumentTypes();
    internal static void InvokeClassConstructor(QCallTypeHandle type);
    private void InvokeClassConstructor();
    internal object InternalInvoke(object obj, IntPtr* args, Exception& exc);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [RequiresUnreferencedCodeAttribute("Trimming may change method bodies. For example it can change some instructions, remove branches or local variables.")]
public virtual MethodBody GetMethodBody();
    public virtual string ToString();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual int get_MetadataToken();
    internal static int get_metadata_token(RuntimeConstructorInfo method);
    internal InvocationFlags ComputeAndUpdateInvocationFlags();
    internal static void CheckCanCreateInstance(Type declaringType, bool isVarArg);
    [DoesNotReturnAttribute]
internal void ThrowNoInvokeException();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
}
internal class System.Reflection.RuntimeCustomAttributeData : CustomAttributeData {
    private ConstructorInfo ctorInfo;
    private IList`1<CustomAttributeTypedArgument> ctorArgs;
    private IList`1<CustomAttributeNamedArgument> namedArgs;
    private LazyCAttrData lazyData;
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    internal RuntimeCustomAttributeData(ConstructorInfo ctorInfo, Assembly assembly, IntPtr data, UInt32 data_length);
    internal RuntimeCustomAttributeData(ConstructorInfo ctorInfo);
    internal RuntimeCustomAttributeData(ConstructorInfo ctorInfo, IList`1<CustomAttributeTypedArgument> ctorArgs, IList`1<CustomAttributeNamedArgument> namedArgs);
    private static void ResolveArgumentsInternal(ConstructorInfo ctor, Assembly assembly, IntPtr data, UInt32 data_length, Object[]& ctorArgs, Object[]& namedArgs);
    private void ResolveArguments();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeType target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeFieldInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeMethodInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeConstructorInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeEventInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimePropertyInfo target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeModule target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeAssembly target);
    internal static IList`1<CustomAttributeData> GetCustomAttributesInternal(RuntimeParameterInfo target);
    private static T[] UnboxValues(Object[] values);
}
internal class System.Reflection.RuntimeEventInfo : EventInfo {
    private IntPtr klass;
    private IntPtr handle;
    public Module Module { get; }
    internal BindingFlags BindingFlags { get; }
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    private static void get_event_info(RuntimeEventInfo ev, MonoEventInfo& info);
    internal static MonoEventInfo GetEventInfo(RuntimeEventInfo ev);
    public virtual Module get_Module();
    internal BindingFlags get_BindingFlags();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeModule GetRuntimeModule();
    internal BindingFlags GetBindingFlags();
    public virtual EventAttributes get_Attributes();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual Type get_DeclaringType();
    public virtual Type get_ReflectedType();
    public virtual string get_Name();
    public virtual string ToString();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    internal static int get_metadata_token(RuntimeEventInfo monoEvent);
    private static EventInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle);
    internal static EventInfo GetEventFromHandle(RuntimeEventHandle handle, RuntimeTypeHandle reflectedType);
}
internal class System.Reflection.RuntimeExceptionHandlingClause : ExceptionHandlingClause {
    internal Type catch_type;
    internal int filter_offset;
    internal ExceptionHandlingClauseOptions flags;
    internal int try_offset;
    internal int try_length;
    internal int handler_offset;
    internal int handler_length;
    public ExceptionHandlingClauseOptions Flags { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int FilterOffset { get; }
    public Type CatchType { get; }
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_TryOffset();
    public virtual int get_TryLength();
    public virtual int get_HandlerOffset();
    public virtual int get_HandlerLength();
    public virtual int get_FilterOffset();
    public virtual Type get_CatchType();
}
internal class System.Reflection.RuntimeFieldInfo : RtFieldInfo {
    internal IntPtr klass;
    internal RuntimeFieldHandle fhandle;
    private string name;
    private Type type;
    private FieldAttributes attrs;
    public Module Module { get; }
    public FieldAttributes Attributes { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    public virtual Module get_Module();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeModule GetRuntimeModule();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual void SetValueDirect(TypedReference obj, object value);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object GetValueDirect(TypedReference obj);
    public virtual FieldAttributes get_Attributes();
    public virtual RuntimeFieldHandle get_FieldHandle();
    private Type ResolveType();
    public virtual Type get_FieldType();
    private Type GetParentType(bool declaring);
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal virtual int GetFieldOffset();
    private object GetValueInternal(object obj);
    public virtual object GetValue(object obj);
    public virtual string ToString();
    private static void SetValueInternal(FieldInfo fi, object obj, object value);
    public virtual void SetValue(object obj, object val, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual object GetRawConstantValue();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    private void CheckGeneric();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual int get_MetadataToken();
    internal static int get_metadata_token(RuntimeFieldInfo monoField);
    private Type[] GetTypeModifiers(bool optional, int genericArgumentPosition);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    private Type[] GetCustomModifiers(bool optional);
    internal Type[] GetCustomModifiersFromModifiedType(bool optional, int genericArgumentPosition);
    public virtual Type GetModifiedFieldType();
}
internal class System.Reflection.RuntimeLocalVariableInfo : LocalVariableInfo {
    internal Type type;
    internal bool is_pinned;
    internal ushort position;
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
}
internal class System.Reflection.RuntimeMethodBody : MethodBody {
    private Byte[] _IL;
    private ExceptionHandlingClause[] _exceptionHandlingClauses;
    private LocalVariableInfo[] _localVariables;
    private int _localSignatureMetadataToken;
    private int _maxStackSize;
    private bool _initLocals;
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public bool InitLocals { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    internal RuntimeMethodBody(ExceptionHandlingClause[] clauses, LocalVariableInfo[] locals, Byte[] il, bool init_locals, int sig_token, int max_stack);
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual bool get_InitLocals();
    public virtual Byte[] GetILAsByteArray();
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
internal class System.Reflection.RuntimeMethodInfo : MethodInfo {
    internal IntPtr mhandle;
    private string name;
    private Type reftype;
    private string toString;
    private RuntimeType[] parameterTypes;
    private MethodBaseInvoker invoker;
    internal InvocationFlags InvocationFlags { get; }
    private MethodBaseInvoker Invoker { get; }
    public Module Module { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public int MetadataToken { get; }
    internal RuntimeType[] ArgumentTypes { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public bool ContainsGenericParameters { get; }
    internal RuntimeMethodInfo(RuntimeMethodHandle mhandle);
    internal InvocationFlags get_InvocationFlags();
    private MethodBaseInvoker get_Invoker();
    public virtual Module get_Module();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual string ToString();
    internal RuntimeModule GetRuntimeModule();
    internal static MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle);
    internal static MethodBase GetMethodFromHandleNoGenericCheck(RuntimeMethodHandle handle, RuntimeTypeHandle reflectedType);
    [DynamicDependencyAttribute("#ctor(System.Reflection.ExceptionHandlingClause[],System.Reflection.LocalVariableInfo[],System.Byte[],System.Boolean,System.Int32,System.Int32)", "System.Reflection.RuntimeMethodBody")]
internal static MethodBody GetMethodBodyInternal(IntPtr handle);
    [RequiresUnreferencedCodeAttribute("Trimming may change method bodies. For example it can change some instructions, remove branches or local variables.")]
internal static MethodBody GetMethodBody(IntPtr handle);
    internal static MethodBase GetMethodFromHandleInternalType(IntPtr method_handle, IntPtr type_handle);
    private static MethodBase GetMethodFromHandleInternalType_native(IntPtr method_handle, IntPtr type_handle, bool genericCheck);
    internal static string get_name(MethodBase method);
    internal static RuntimeMethodInfo get_base_method(RuntimeMethodInfo method, bool definition);
    internal static int get_metadata_token(RuntimeMethodInfo method);
    public virtual MethodInfo GetBaseDefinition();
    internal MethodInfo GetBaseMethod();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual int get_MetadataToken();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    internal virtual ParameterInfo[] GetParametersInternal();
    internal virtual int GetParametersCount();
    internal RuntimeType[] get_ArgumentTypes();
    internal object InternalInvoke(object obj, IntPtr* args, Exception& exc);
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal void GetPInvoke(PInvokeAttributes& flags, String& entryPoint, String& dllName);
    internal Object[] GetPseudoCustomAttributes();
    private DllImportAttribute GetDllImportAttribute();
    internal CustomAttributeData[] GetPseudoCustomAttributesData();
    private RuntimeCustomAttributeData GetDllImportAttributeData();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] methodInstantiation);
    private MethodInfo MakeGenericMethod_impl(Type[] types);
    public virtual Type[] GetGenericArguments();
    private MethodInfo GetGenericMethodDefinition_impl();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_ContainsGenericParameters();
    [RequiresUnreferencedCodeAttribute("Trimming may change method bodies. For example it can change some instructions, remove branches or local variables.")]
public virtual MethodBody GetMethodBody();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    internal InvocationFlags ComputeAndUpdateInvocationFlags();
    [DoesNotReturnAttribute]
internal void ThrowNoInvokeException();
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    [CompilerGeneratedAttribute]
internal static bool <ComputeAndUpdateInvocationFlags>g__IsDisallowedByRefType|79_0(Type type);
}
internal class System.Reflection.RuntimeModule : Module {
    internal IntPtr _impl;
    internal Assembly assembly;
    internal string fqname;
    internal string name;
    internal string scopename;
    internal bool is_resource;
    internal int token;
    public Assembly Assembly { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string Name { get; }
    public string ScopeName { get; }
    public int MDStreamVersion { get; }
    public Guid ModuleVersionId { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string FullyQualifiedName { get; }
    public int MetadataToken { get; }
    public virtual Assembly get_Assembly();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    public virtual int get_MDStreamVersion();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_FullyQualifiedName();
    public virtual bool IsResource();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual int get_MetadataToken();
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static FieldInfo ResolveField(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static MemberInfo ResolveMember(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static MethodBase ResolveMethod(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual string ResolveString(int metadataToken);
    internal static string ResolveString(Module module, IntPtr monoModule, int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    internal static Type ResolveType(Module module, IntPtr monoModule, int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Byte[] ResolveSignature(int metadataToken);
    internal static Byte[] ResolveSignature(Module module, IntPtr monoModule, int metadataToken);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetTypes();
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal Guid GetModuleVersionId();
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3002:RequiresAssemblyFiles")]
internal static Exception resolve_token_exception(Module module, int metadataToken, ResolveTokenError error, string tokenType);
    internal static Exception resolve_token_exception(string name, int metadataToken, ResolveTokenError error, string tokenType);
    internal static IntPtr[] ptrs_from_types(Type[] types);
    private protected virtual ModuleHandle GetModuleHandleImpl();
    internal static int get_MetadataToken(Module module);
    internal static int GetMDStreamVersion(IntPtr module);
    internal static Type[] InternalGetTypes(IntPtr module);
    private static void GetGuidInternal(IntPtr module, Byte[] guid);
    internal static Type GetGlobalType(IntPtr module);
    internal static IntPtr ResolveTypeToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static IntPtr ResolveMethodToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static IntPtr ResolveFieldToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static string ResolveStringToken(IntPtr module, int token, ResolveTokenError& error);
    internal static MemberInfo ResolveMemberToken(IntPtr module, int token, IntPtr[] type_args, IntPtr[] method_args, ResolveTokenError& error);
    internal static Byte[] ResolveSignature(IntPtr module, int metadataToken, ResolveTokenError& error);
    internal static void GetPEKind(IntPtr module, PortableExecutableKinds& peKind, ImageFileMachine& machine);
}
internal class System.Reflection.RuntimeParameterInfo : ParameterInfo {
    internal MarshalAsAttribute marshalAs;
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    public int MetadataToken { get; }
    public bool HasDefaultValue { get; }
    internal RuntimeParameterInfo(string name, Type type, int position, int attrs, object defaultValue, MemberInfo member, MarshalAsAttribute marshalAs);
    internal RuntimeParameterInfo(ParameterBuilder pb, Type type, MemberInfo member, int position);
    internal RuntimeParameterInfo(ParameterInfo pinfo, MemberInfo member);
    internal RuntimeParameterInfo(Type type, MemberInfo member, MarshalAsAttribute marshalAs);
    internal RuntimeParameterInfo(MethodInfo owner, string name, Type parameterType, int position);
    internal static void FormatParameters(StringBuilder sb, ParameterInfo[] p, CallingConventions callingConvention);
    internal static ParameterInfo New(ParameterBuilder pb, Type type, MemberInfo member, int position);
    private object GetDefaultValueFromCustomAttributeData();
    private static decimal GetRawDecimalConstant(CustomAttributeData attr);
    private static DateTime GetRawDateTimeConstant(CustomAttributeData attr);
    private static object GetRawConstant(CustomAttributeData attr);
    private object GetDefaultValueFromCustomAttributes();
    private object GetDefaultValue(bool raw);
    public virtual object get_DefaultValue();
    public virtual object get_RawDefaultValue();
    public virtual int get_MetadataToken();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    internal static object GetDefaultValueImpl(ParameterInfo pinfo);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    internal int GetMetadataToken();
    public virtual Type[] GetOptionalCustomModifiers();
    internal Object[] GetPseudoCustomAttributes();
    internal CustomAttributeData[] GetPseudoCustomAttributesData();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool get_HasDefaultValue();
    internal static Type[] GetTypeModifiers(Type type, MemberInfo member, int position, bool optional, int genericArgumentPosition);
    internal static ParameterInfo New(ParameterInfo pinfo, MemberInfo member);
    internal static ParameterInfo New(Type type, MemberInfo member, MarshalAsAttribute marshalAs);
    internal void SetName(string name);
    internal void SetAttributes(ParameterAttributes attributes);
    private Type[] GetCustomModifiers(bool optional);
    internal Type[] GetCustomModifiersFromModifiedType(bool optional, int genericArgumentPosition);
    public virtual Type GetModifiedParameterType();
    [CompilerGeneratedAttribute]
internal static int <GetRawDecimalConstant>g__GetConstructorArgument|10_0(IList`1<CustomAttributeTypedArgument> args, int index);
}
internal class System.Reflection.RuntimePropertyInfo : PropertyInfo {
    internal IntPtr klass;
    internal IntPtr prop;
    private MonoPropertyInfo info;
    private PInfo cached;
    private GetterAdapter cached_getter;
    internal BindingFlags BindingFlags { get; }
    public Module Module { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public int MetadataToken { get; }
    internal static void get_property_info(RuntimePropertyInfo prop, MonoPropertyInfo& info, PInfo req_info);
    internal static Type[] GetTypeModifiers(RuntimePropertyInfo prop, bool optional, int genericArgumentPosition);
    internal static object get_default_value(RuntimePropertyInfo prop);
    internal BindingFlags get_BindingFlags();
    private static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    public virtual Module get_Module();
    internal RuntimeType GetDeclaringTypeInternal();
    internal RuntimeModule GetRuntimeModule();
    public virtual string ToString();
    private string FormatNameAndSig();
    private void CachePropertyInfo(PInfo flags);
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    public virtual Type get_DeclaringType();
    public virtual string get_Name();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    private static object GetterAdapterFrame(Getter`2<T, R> getter, object obj);
    private static object StaticGetterAdapterFrame(StaticGetter`1<R> getter, object _);
    [DynamicDependencyAttribute("GetterAdapterFrame`2")]
[DynamicDependencyAttribute("StaticGetterAdapterFrame`1")]
private static GetterAdapter CreateGetterDelegate(MethodInfo method);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    private Type[] GetCustomModifiers(bool optional);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public virtual int get_MetadataToken();
    internal static int get_metadata_token(RuntimePropertyInfo monoProperty);
    private static PropertyInfo internal_from_handle_type(IntPtr event_handle, IntPtr type_handle);
    internal static PropertyInfo GetPropertyFromHandle(RuntimePropertyHandle handle, RuntimeTypeHandle reflectedType);
    internal Type[] GetCustomModifiersFromModifiedType(bool optional, int genericArgumentPosition);
    public virtual Type GetModifiedPropertyType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Reflection.RuntimeReflectionExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetRuntimeFields(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetRuntimeEvents(Type type);
    [ExtensionAttribute]
public static FieldInfo GetRuntimeField(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
    [ExtensionAttribute]
public static EventInfo GetRuntimeEvent(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeBaseDefinition(MethodInfo method);
    [ExtensionAttribute]
public static InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType);
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate del);
}
internal class System.Reflection.SignatureArrayType : SignatureHasElementType {
    private int _rank;
    private bool _isMultiDim;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureArrayType(SignatureType elementType, int rank, bool isMultiDim);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal class System.Reflection.SignatureByRefType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignatureByRefType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal enum System.Reflection.SignatureCallingConvention : Enum {
    public byte value__;
    public static SignatureCallingConvention Default;
    public static SignatureCallingConvention Cdecl;
    public static SignatureCallingConvention StdCall;
    public static SignatureCallingConvention ThisCall;
    public static SignatureCallingConvention FastCall;
    public static SignatureCallingConvention Unmanaged;
}
internal class System.Reflection.SignatureConstructedGenericType : SignatureType {
    private Type _genericTypeDefinition;
    private Type[] _genericTypeArguments;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    internal SignatureConstructedGenericType(Type genericTypeDefinition, Type[] typeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal class System.Reflection.SignatureGenericMethodParameterType : SignatureGenericParameterType {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public string Name { get; }
    internal SignatureGenericMethodParameterType(int position);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual string get_Name();
}
internal abstract class System.Reflection.SignatureGenericParameterType : SignatureType {
    private int _position;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected SignatureGenericParameterType(int position);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public abstract virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
}
internal abstract class System.Reflection.SignatureHasElementType : SignatureType {
    private SignatureType _elementType;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    internal SignatureType ElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public string Name { get; }
    public string Namespace { get; }
    protected string Suffix { get; }
    protected SignatureHasElementType(SignatureType elementType);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    protected abstract virtual bool IsByRefImpl();
    public sealed virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual SignatureType get_ElementType();
    public abstract virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual Type[] get_GenericTypeArguments();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual string get_Name();
    public sealed virtual string get_Namespace();
    public sealed virtual string ToString();
    protected abstract virtual string get_Suffix();
}
internal class System.Reflection.SignaturePointerType : SignatureHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal SignaturePointerType(SignatureType elementType);
    protected sealed virtual bool IsArrayImpl();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string get_Suffix();
}
internal abstract class System.Reflection.SignatureType : Type {
    public bool IsSignatureType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MemberTypes MemberType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    internal SignatureType ElementType { get; }
    public Type UnderlyingSystemType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public Type BaseType { get; }
    public int MetadataToken { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public Guid GUID { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsEnum { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public bool IsSerializable { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public sealed virtual bool get_IsSignatureType();
    public abstract virtual bool get_IsTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    public abstract virtual bool get_IsByRefLike();
    protected abstract virtual bool IsPointerImpl();
    public sealed virtual bool get_IsGenericType();
    public abstract virtual bool get_IsGenericTypeDefinition();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_ContainsGenericParameters();
    public sealed virtual MemberTypes get_MemberType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public sealed virtual Type MakeArrayType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakePointerType();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type GetElementType();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetGenericTypeDefinition();
    public abstract virtual Type[] get_GenericTypeArguments();
    public abstract virtual Type[] GetGenericArguments();
    public abstract virtual int get_GenericParameterPosition();
    internal abstract virtual SignatureType get_ElementType();
    public sealed virtual Type get_UnderlyingSystemType();
    public abstract virtual string get_Name();
    public abstract virtual string get_Namespace();
    public sealed virtual string get_FullName();
    public sealed virtual string get_AssemblyQualifiedName();
    public abstract virtual string ToString();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual Type get_BaseType();
    [DynamicallyAccessedMembersAttribute("8192")]
public sealed virtual Type[] GetInterfaces();
    public sealed virtual bool IsAssignableFrom(Type c);
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual Type get_DeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual bool IsEnumDefined(object value);
    public sealed virtual string GetEnumName(object value);
    public sealed virtual String[] GetEnumNames();
    public sealed virtual Type GetEnumUnderlyingType();
    [RequiresDynamicCodeAttribute("It might not be possible to create an array of the enum type at runtime. Use Enum.GetValues<T> or the GetEnumValuesAsUnderlyingType method instead.")]
public sealed virtual Array GetEnumValues();
    public sealed virtual Guid get_GUID();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    [DynamicallyAccessedMembersAttribute("7")]
public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("6144")]
public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("6144")]
public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("-1")]
public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    [DynamicallyAccessedMembersAttribute("24")]
protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("-1")]
public sealed virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    [DynamicallyAccessedMembersAttribute("8191")]
public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2731")]
public sealed virtual MemberInfo[] GetDefaultMembers();
    [DynamicallyAccessedMembersAttribute("2048")]
public sealed virtual EventInfo[] GetEvents();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [DynamicallyAccessedMembersAttribute("8192")]
public sealed virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("7")]
protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual bool IsCOMObjectImpl();
    protected sealed virtual bool IsPrimitiveImpl();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [DynamicallyAccessedMembersAttribute("8192")]
public sealed virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    protected sealed virtual bool IsContextfulImpl();
    public sealed virtual bool get_IsEnum();
    public sealed virtual bool IsEquivalentTo(Type other);
    public sealed virtual bool IsInstanceOfType(object o);
    protected sealed virtual bool IsMarshalByRefImpl();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool IsSubclassOf(Type c);
    protected sealed virtual bool IsValueTypeImpl();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
}
[ExtensionAttribute]
internal static class System.Reflection.SignatureTypeExtensions : object {
    [ExtensionAttribute]
public static bool MatchesParameterTypeExactly(Type pattern, ParameterInfo parameter);
    [ExtensionAttribute]
internal static bool MatchesExactly(SignatureType pattern, Type actual);
    [ExtensionAttribute]
internal static Type TryResolveAgainstGenericMethod(SignatureType signatureType, MethodInfo genericMethod);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
private static Type TryResolve(SignatureType signatureType, Type[] genericMethodParameters);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
private static Type TryMakeArrayType(Type type);
    [ExtensionAttribute]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
private static Type TryMakeArrayType(Type type, int rank);
    [ExtensionAttribute]
private static Type TryMakeByRefType(Type type);
    [ExtensionAttribute]
private static Type TryMakePointerType(Type type);
    [ExtensionAttribute]
[RequiresUnreferencedCodeAttribute("Wrapper around MakeGenericType which itself has RequiresUnreferencedCode")]
[RequiresDynamicCodeAttribute("Wrapper around MakeGenericType which itself has RequiresDynamicCode")]
private static Type TryMakeGenericType(Type type, Type[] instantiation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Strong name signing is not supported and throws PlatformNotSupportedException.")]
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(FileStream keyPairFile);
    public StrongNameKeyPair(Byte[] keyPairArray);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetException : ApplicationException {
    public TargetException(string message);
    public TargetException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TargetException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private TargetInvocationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private TargetParameterCountException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes CustomFormatMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.TypeDelegator : TypeInfo {
    [DynamicallyAccessedMembersAttribute("-1")]
protected Type typeImpl;
    public Guid GUID { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Assembly Assembly { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsCollectible { get; }
    public bool IsFunctionPointer { get; }
    public bool IsUnmanagedFunctionPointer { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual Guid get_GUID();
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    public virtual Module get_Module();
    public virtual Assembly get_Assembly();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    [NullableContextAttribute("2")]
public virtual string get_Namespace();
    [NullableContextAttribute("2")]
public virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetFunctionPointerCallingConventions();
    public virtual Type[] GetFunctionPointerParameterTypes();
    public virtual Type GetFunctionPointerReturnType();
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member);
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsByRefImpl();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsValueTypeImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsCollectible();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsUnmanagedFunctionPointer();
    [NullableContextAttribute("2")]
public virtual Type GetElementType();
    protected virtual bool HasElementTypeImpl();
    public virtual Type get_UnderlyingSystemType();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.TypeInfo : Type {
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
    public virtual Type AsType();
    public virtual Type[] get_GenericTypeParameters();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetDeclaredEvent(string name);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetDeclaredField(string name);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo GetDeclaredMethod(string name);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual TypeInfo GetDeclaredNestedType(string name);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo GetDeclaredProperty(string name);
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<GetDeclaredMethods>d__10")]
[DynamicallyAccessedMembersAttribute("24")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    [DynamicallyAccessedMembersAttribute("96")]
public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    [DynamicallyAccessedMembersAttribute("24")]
public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [IteratorStateMachineAttribute("System.Reflection.TypeInfo/<get_DeclaredNestedTypes>d__22")]
[DynamicallyAccessedMembersAttribute("384")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    internal static string GetRankString(int rank);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
internal static MethodInfo[] <GetDeclaredMethods>g__GetDeclaredOnlyMethods|10_0(Type type);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
internal static Type[] <get_DeclaredNestedTypes>g__GetDeclaredOnlyNestedTypes|22_0(Type type);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Reflection.TypeNameParser : ValueType {
    private Func`2<AssemblyName, Assembly> _assemblyResolver;
    private Func`4<Assembly, string, bool, Type> _typeResolver;
    private bool _throwOnError;
    private bool _ignoreCase;
    private Void* _stackMark;
    private ReadOnlySpan`1<char> _input;
    private int _index;
    private int _errorIndex;
    private TokenType Peek { get; }
    private TokenType PeekSecond { get; }
    private static ReadOnlySpan`1<char> CharsToEscape { get; }
    private TypeNameParser(ReadOnlySpan`1<char> name);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
internal static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private Assembly ResolveAssembly(string assemblyName);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private Type GetType(string typeName, ReadOnlySpan`1<string> nestedTypeNames, string assemblyNameIfAny);
    private Type Parse();
    private TypeName ParseNonQualifiedTypeName();
    private TypeName ParseNamedOrConstructedGenericTypeName();
    private TypeName ParseNamedTypeName();
    private TypeName ParseGenericTypeArgument();
    private TokenType get_Peek();
    private TokenType get_PeekSecond();
    private void Skip();
    private TokenType GetNextToken();
    private string GetNextIdentifier();
    private string GetNextAssemblyName();
    private string GetNextEmbeddedAssemblyName();
    private bool StartAssemblyName();
    private static TokenType CharToToken(char c);
    private void SkipWhiteSpace();
    private static ReadOnlySpan`1<char> get_CharsToEscape();
    private static bool NeedsEscapingInTypeName(char c);
    private static string EscapeTypeName(string name);
    private void ParseError();
    [CompilerGeneratedAttribute]
internal static string <ParseNamedTypeName>g__ApplyLeadingDotCompatQuirk|16_0(string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <RequestingAssembly>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
internal class System.Resources.FastResourceComparer : object {
    internal static FastResourceComparer Default;
    private static FastResourceComparer();
    public sealed virtual int GetHashCode(object key);
    public sealed virtual int GetHashCode(string key);
    internal static int HashFunction(string key);
    public sealed virtual int Compare(object a, object b);
    public sealed virtual int Compare(string a, string b);
    public sealed virtual bool Equals(string a, string b);
    public sealed virtual bool Equals(object a, object b);
    public static int CompareOrdinal(string a, Byte[] bytes, int bCharLength);
    public static int CompareOrdinal(Byte[] bytes, int aCharLength, string b);
    internal static int CompareOrdinal(Byte* a, int byteLen, string b);
}
internal class System.Resources.FileBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public FileBasedResourceGroveler(ResourceManagerMediator mediator);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
    private string FindResourceFile(CultureInfo culture, string fileName);
    private ResourceSet CreateResourceSet(string file);
}
internal interface System.Resources.IResourceGroveler {
    public abstract virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    [NullableContextAttribute("1")]
public abstract virtual IDictionaryEnumerator GetEnumerator();
}
internal class System.Resources.ManifestBasedResourceGroveler : object {
    private ResourceManagerMediator _mediator;
    public ManifestBasedResourceGroveler(ResourceManagerMediator mediator);
    private static Assembly InternalGetSatelliteAssembly(Assembly mainAssembly, CultureInfo culture, Version version);
    public sealed virtual ResourceSet GrovelForResourceSet(CultureInfo culture, Dictionary`2<string, ResourceSet> localResourceSets, bool tryParents, bool createIfNotExists);
    private CultureInfo UltimateFallbackFixup(CultureInfo lookForCulture);
    internal static CultureInfo GetNeutralResourcesLanguage(Assembly a, UltimateResourceFallbackLocation& fallbackLocation);
    internal ResourceSet CreateResourceSet(Stream store, Assembly assembly);
    [RequiresUnreferencedCodeAttribute("The CustomResourceTypesSupport feature switch has been enabled for this app which is being trimmed. Custom readers as well as custom objects on the resources file are not observable by the trimmer and so required assemblies, types and members may be removed.")]
private static ResourceSet InternalGetResourceSetFromSerializedData(Stream store, string readerTypeName, string resSetTypeName, ResourceManagerMediator mediator);
    private static Stream GetManifestResourceStream(Assembly satellite, string fileName);
    private static Stream CaseInsensitiveManifestResourceStreamLookup(Assembly satellite, string name);
    private Assembly GetSatelliteAssembly(CultureInfo lookForCulture);
    private bool CanUseDefaultResourceClasses(string readerTypeName, string resSetTypeName);
    private void HandleSatelliteMissing();
    private static string GetManifestResourceNamesList(Assembly assembly);
    private void HandleResourceStreamMissing(string fileName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
[EditorBrowsableAttribute("1")]
public class System.Resources.MissingManifestResourceException : SystemException {
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    private string _cultureName;
    public string CultureName { get; }
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public string get_CultureName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
[EditorBrowsableAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private UltimateResourceFallbackLocation <Location>k__BackingField;
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public UltimateResourceFallbackLocation get_Location();
}
internal class System.Resources.ResourceFallbackManager : object {
    private CultureInfo m_startingCulture;
    private CultureInfo m_neutralResourcesCulture;
    private bool m_useParents;
    internal ResourceFallbackManager(CultureInfo startingCulture, CultureInfo neutralResourcesCulture, bool useParents);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("System.Resources.ResourceFallbackManager/<GetEnumerator>d__5")]
public sealed virtual IEnumerator`1<CultureInfo> GetEnumerator();
}
[IsReadOnlyAttribute]
internal class System.Resources.ResourceLocator : ValueType {
    [CompilerGeneratedAttribute]
private int <DataPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    internal int DataPosition { get; }
    internal object Value { get; }
    internal ResourceLocator(int dataPos, object value);
    [CompilerGeneratedAttribute]
internal int get_DataPosition();
    [CompilerGeneratedAttribute]
internal object get_Value();
    internal static bool CanCache(ResourceTypeCode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Resources.ResourceManager : object {
    protected string BaseNameField;
    [NullableAttribute("2")]
protected Assembly MainAssembly;
    private Dictionary`2<string, ResourceSet> _resourceSets;
    private string _moduleDir;
    [DynamicallyAccessedMembersAttribute("7")]
private Type _userResourceSet;
    private CultureInfo _neutralResourcesCulture;
    private CultureNameResourceSetPair _lastUsedResourceCache;
    private bool _ignoreCase;
    private bool _useManifest;
    private UltimateResourceFallbackLocation _fallbackLoc;
    private Version _satelliteContractVersion;
    private bool _lookedForSatelliteContractVersion;
    private IResourceGroveler _resourceGroveler;
    public static int MagicNumber;
    public static int HeaderVersionNumber;
    public string BaseName { get; }
    public bool IgnoreCase { get; public set; }
    [DynamicallyAccessedMembersAttribute("7")]
public Type ResourceSetType { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    private ResourceManager(string baseName, string resourceDir, Type userResourceSet);
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    private static ResourceManager();
    [MemberNotNullAttribute("_resourceGroveler")]
private void CommonAssemblyInit();
    public virtual string get_BaseName();
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual void ReleaseAllResources();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected virtual string GetResourceFileName(CultureInfo culture);
    internal ResourceSet GetFirstResourceSet(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    private static void AddResourceSet(Dictionary`2<string, ResourceSet> localResourceSets, string cultureName, ResourceSet& rs);
    protected static Version GetSatelliteContractVersion(Assembly a);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    internal static bool IsDefaultType(string asmTypeName, string defaultTypeName);
    public virtual string GetString(string name);
    [NullableContextAttribute("2")]
public virtual string GetString(string name, CultureInfo culture);
    public virtual object GetObject(string name);
    [NullableContextAttribute("2")]
public virtual object GetObject(string name, CultureInfo culture);
    private object GetObject(string name, CultureInfo culture, bool wrapUnmanagedMemStream);
    public UnmanagedMemoryStream GetStream(string name);
    [NullableContextAttribute("2")]
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
}
public class System.Resources.ResourceReader : object {
    private bool _permitDeserialization;
    private object _binaryFormatter;
    [DynamicallyAccessedMembersAttribute("1")]
private static Type s_binaryFormatterType;
    private static Func`3<object, Stream, object> s_deserializeMethod;
    private BinaryReader _store;
    internal Dictionary`2<string, ResourceLocator> _resCache;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private Int32[] _nameHashes;
    private Int32* _nameHashesPtr;
    private Int32[] _namePositions;
    private Int32* _namePositionsPtr;
    private Type[] _typeTable;
    private Int32[] _typeNamePositions;
    private int _numResources;
    private UnmanagedMemoryStream _ums;
    private int _version;
    [CompilerGeneratedAttribute]
private static bool <AllowCustomResourceTypes>k__BackingField;
    internal static bool AllowCustomResourceTypes { get; }
    internal ResourceReader(Stream stream, Dictionary`2<string, ResourceLocator> resCache, bool permitDeserialization);
    [NullableContextAttribute("1")]
public ResourceReader(string fileName);
    [NullableContextAttribute("1")]
public ResourceReader(Stream stream);
    private static ResourceReader();
    private object DeserializeObject(int typeIndex);
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("The CustomResourceTypesSupport feature switch has been enabled for this app which is being trimmed. Custom readers as well as custom objects on the resources file are not observable by the trimmer and so required assemblies, types and members may be removed.")]
private bool InitializeBinaryFormatter();
    private static Func`3<object, Stream, object> CreateUntypedDelegate(MethodInfo method);
    private static bool ValidateReaderType(string readerType);
    [NullableContextAttribute("1")]
public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    [CompilerGeneratedAttribute]
internal static bool get_AllowCustomResourceTypes();
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private static int ReadUnalignedI4(Int32* p);
    private void SkipString();
    private int GetNameHash(int index);
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public sealed virtual IDictionaryEnumerator GetEnumerator();
    internal ResourceEnumerator GetEnumeratorInternal();
    internal int FindPosForResource(string name);
    private bool CompareStringEqualsName(string name);
    private string AllocateStringForNameIndex(int index, Int32& dataOffset);
    private object GetValueForNameIndex(int index);
    internal string LoadString(int pos);
    internal object LoadObject(int pos);
    internal object LoadObject(int pos, ResourceTypeCode& typeCode);
    private object LoadObjectV1(int pos);
    private object _LoadObjectV1(int pos);
    private object LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    private object _LoadObjectV2(int pos, ResourceTypeCode& typeCode);
    [MemberNotNullAttribute("_typeTable")]
[MemberNotNullAttribute("_typeNamePositions")]
private void ReadResources();
    [MemberNotNullAttribute("_typeTable")]
[MemberNotNullAttribute("_typeNamePositions")]
private void _ReadResources();
    private Type FindType(int typeIndex);
    [RequiresUnreferencedCodeAttribute("The CustomResourceTypesSupport feature switch has been enabled for this app which is being trimmed. Custom readers as well as custom objects on the resources file are not observable by the trimmer and so required assemblies, types and members may be removed.")]
private Type UseReflectionToGetType(int typeIndex);
    private string TypeNameFromTypeCode(ResourceTypeCode typeCode);
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:RequiresDynamicCode")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private bool <DeserializeObject>g__InitializeBinaryFormatterLocal|5_0();
    [CompilerGeneratedAttribute]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private Type <FindType>g__UseReflectionToGetTypeLocal|52_0(int typeIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Resources.ResourceSet : object {
    [NullableAttribute("2")]
protected IResourceReader Reader;
    private Dictionary`2<object, object> _table;
    private Dictionary`2<string, object> _caseInsensitiveTable;
    internal ResourceSet(bool _);
    public ResourceSet(string fileName);
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private object GetObjectInternal(string name);
    private object GetCaseInsensitiveObjectInternal(string name);
}
internal enum System.Resources.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
internal class System.Resources.RuntimeResourceSet : ResourceSet {
    private Dictionary`2<string, ResourceLocator> _resCache;
    private ResourceReader _defaultReader;
    private Dictionary`2<string, ResourceLocator> _caseInsensitiveTable;
    internal RuntimeResourceSet(string fileName);
    internal RuntimeResourceSet(Stream stream, bool permitDeserialization);
    protected virtual void Dispose(bool disposing);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private IDictionaryEnumerator GetEnumeratorHelper();
    public virtual string GetString(string key);
    public virtual string GetString(string key, bool ignoreCase);
    public virtual object GetObject(string key);
    public virtual object GetObject(string key, bool ignoreCase);
    private object GetObject(string key, bool ignoreCase, bool isString);
    private static object ReadValue(ResourceReader reader, int dataPos, bool isString, ResourceLocator& locator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
[EditorBrowsableAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    [CompilerGeneratedAttribute]
public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Runtime, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.AmbiguousImplementationException : Exception {
    public AmbiguousImplementationException(string message);
    public AmbiguousImplementationException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private AmbiguousImplementationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TargetedPatchBand>k__BackingField;
    public string TargetedPatchBand { get; }
    public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
    [CompilerGeneratedAttribute]
public string get_TargetedPatchBand();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncIteratorMethodBuilder : ValueType {
    private Task`1<VoidTaskResult> m_task;
    internal object ObjectIdForDebugger { get; }
    public static AsyncIteratorMethodBuilder Create();
    public void MoveNext(TStateMachine& stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void Complete();
    internal object get_ObjectIdForDebugger();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public AsyncIteratorStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5212")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
}
internal static class System.Runtime.CompilerServices.AsyncMethodBuilderCore : object {
    internal static bool TrackAsyncMethodCompletion { get; }
    [DebuggerStepThroughAttribute]
public static void Start(TStateMachine& stateMachine);
    public static void SetStateMachine(IAsyncStateMachine stateMachine, Task task);
    internal static bool get_TrackAsyncMethodCompletion();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2075:UnrecognizedReflectionPattern")]
internal static string GetAsyncStateMachineDescription(IAsyncStateMachine stateMachine);
    internal static Action CreateContinuationWrapper(Action continuation, Action`2<Action, Task> invokeAction, Task innerTask);
    internal static Action TryGetStateMachineForDebugger(Action action);
    internal static Task TryGetContinuationTask(Action continuation);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public AsyncStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private Task`1<VoidTaskResult> m_task;
    public Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    public static AsyncTaskMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public Task get_Task();
    private Task`1<VoidTaskResult> InitializeTaskAsPromise();
    public void SetResult();
    public void SetException(Exception exception);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal object get_ObjectIdForDebugger();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    private Task`1<TResult> m_task;
    public Task`1<TResult> Task { get; }
    internal object ObjectIdForDebugger { get; }
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    internal static void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine, Task`1& taskField);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    internal static void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine, Task`1& taskField);
    internal static void AwaitUnsafeOnCompleted(TAwaiter& awaiter, IAsyncStateMachineBox box);
    private static IAsyncStateMachineBox GetStateMachineBox(TStateMachine& stateMachine, Task`1& taskField);
    private static AsyncStateMachineBox`1<TResult, TStateMachine> CreateDebugFinalizableAsyncStateMachineBox();
    public Task`1<TResult> get_Task();
    private Task`1<TResult> InitializeTaskAsPromise();
    internal static Task`1<TResult> CreateWeaklyTypedStateMachineBox();
    public void SetResult(TResult result);
    internal static void SetExistingTaskResult(Task`1<TResult> task, TResult result);
    public void SetException(Exception exception);
    internal static void SetException(Exception exception, Task`1& taskField);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal static void SetNotificationForWaitCompletion(bool enabled, Task`1& taskField);
    internal object get_ObjectIdForDebugger();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private static Task`1<VoidTaskResult> s_syncSuccessSentinel;
    private Task`1<VoidTaskResult> m_task;
    public ValueTask Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncValueTaskMethodBuilder();
    public static AsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    internal object get_ObjectIdForDebugger();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    internal static Task`1<TResult> s_syncSuccessSentinel;
    private Task`1<TResult> m_task;
    private TResult _result;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTask`1<TResult> Task { get; }
    internal object ObjectIdForDebugger { get; }
    private static AsyncValueTaskMethodBuilder`1();
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    internal object get_ObjectIdForDebugger();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private SynchronizationContext _synchronizationContext;
    private AsyncTaskMethodBuilder _builder;
    private Task Task { get; }
    internal object ObjectIdForDebugger { get; }
    public static AsyncVoidMethodBuilder Create();
    [DebuggerStepThroughAttribute]
public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    private static void NotifySynchronizationContextOfCompletion(SynchronizationContext context);
    private Task get_Task();
    internal object get_ObjectIdForDebugger();
}
public class System.Runtime.CompilerServices.CallConvCdecl : object {
}
public class System.Runtime.CompilerServices.CallConvFastcall : object {
}
public class System.Runtime.CompilerServices.CallConvMemberFunction : object {
}
public class System.Runtime.CompilerServices.CallConvStdcall : object {
}
public class System.Runtime.CompilerServices.CallConvSuppressGCTransition : object {
}
public class System.Runtime.CompilerServices.CallConvThiscall : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
public class System.Runtime.CompilerServices.CollectionBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public Type BuilderType { get; }
    public string MethodName { get; }
    public CollectionBuilderAttribute(Type builderType, string methodName);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
    [CompilerGeneratedAttribute]
public string get_MethodName();
}
[AttributeUsageAttribute("96")]
internal class System.Runtime.CompilerServices.CompExactlyDependsOnAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <IntrinsicsTypeUsedInHelperFunction>k__BackingField;
    public CompExactlyDependsOnAttribute(Type intrinsicsTypeUsedInHelperFunction);
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <CompilationRelaxations>k__BackingField;
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    [CompilerGeneratedAttribute]
public int get_CompilationRelaxations();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    private object _lock;
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private int _activeEnumeratorRefCount;
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public bool TryAdd(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public bool Remove(TKey key);
    public void Clear();
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    private TValue GetValueLocked(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public TValue GetOrCreateValue(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CreateEntry(TKey key, TValue value);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredAsyncDisposable : ValueType {
    private IAsyncDisposable _source;
    private bool _continueOnCapturedContext;
    internal ConfiguredAsyncDisposable(IAsyncDisposable source, bool continueOnCapturedContext);
    public ConfiguredValueTaskAwaitable DisposeAsync();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1 : ValueType {
    private IAsyncEnumerable`1<T> _enumerable;
    private CancellationToken _cancellationToken;
    private bool _continueOnCapturedContext;
    internal ConfiguredCancelableAsyncEnumerable`1(IAsyncEnumerable`1<T> enumerable, bool continueOnCapturedContext, CancellationToken cancellationToken);
    public ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(CancellationToken cancellationToken);
    public Enumerator<T> GetAsyncEnumerator();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private ConfiguredTaskAwaiter m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable(Task task, ConfigureAwaitOptions options);
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private ConfiguredTaskAwaiter<TResult> m_configuredTaskAwaiter;
    internal ConfiguredTaskAwaitable`1(Task`1<TResult> task, ConfigureAwaitOptions options);
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private ValueTask _value;
    internal ConfiguredValueTaskAwaitable(ValueTask& value);
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private ValueTask`1<TResult> _value;
    internal ConfiguredValueTaskAwaitable`1(ValueTask`1& value);
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.ContractHelper : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ContractFailedEventArgs> InternalContractFailed;
    [CompilerGeneratedAttribute]
internal static void add_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_InternalContractFailed(EventHandler`1<ContractFailedEventArgs> value);
    [DebuggerNonUserCodeAttribute]
public static string RaiseContractFailedEvent(ContractFailureKind failureKind, string userMessage, string conditionText, Exception innerException);
    [DebuggerNonUserCodeAttribute]
public static void TriggerFailure(ContractFailureKind kind, string displayMessage, string userMessage, string conditionText, Exception innerException);
    private static string GetFailureMessage(ContractFailureKind failureKind, string conditionText);
    private static string GetDisplayMessage(ContractFailureKind failureKind, string userMessage, string conditionText);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.CreateNewOnMetadataUpdateAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    private DateTime _date;
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    private decimal _dec;
    public decimal Value { get; }
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[InterpolatedStringHandlerAttribute]
public class System.Runtime.CompilerServices.DefaultInterpolatedStringHandler : ValueType {
    private IFormatProvider _provider;
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    private bool _hasCustomFormatter;
    [NullableAttribute("0")]
internal ReadOnlySpan`1<char> Text { get; }
    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount);
    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider provider);
    [NullableContextAttribute("0")]
public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider provider, Span`1<char> initialBuffer);
    internal static int GetDefaultLength(int literalLength, int formattedCount);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToStringAndClear();
    internal void Clear();
    internal ReadOnlySpan`1<char> get_Text();
    [NullableContextAttribute("1")]
public void AppendLiteral(string value);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value);
    public void AppendFormatted(T value, string format);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value, int alignment, string format);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format);
    public void AppendFormatted(string value);
    private void AppendFormattedSlow(string value);
    public void AppendFormatted(string value, int alignment, string format);
    public void AppendFormatted(object value, int alignment, string format);
    internal static bool HasCustomFormatter(IFormatProvider provider);
    private void AppendCustomFormatter(T value, string format);
    private void AppendOrInsertAlignmentIfNeeded(int startingPos, int alignment);
    private void EnsureCapacityForAdditionalChars(int additionalChars);
    private void GrowThenCopyString(string value);
    private void GrowThenCopySpan(ReadOnlySpan`1<char> value);
    private void Grow(int additionalChars);
    private void Grow();
    private void GrowCore(UInt32 requiredMinCapacity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DependentAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadHint <LoadHint>k__BackingField;
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    [CompilerGeneratedAttribute]
public string get_DependentAssembly();
    [CompilerGeneratedAttribute]
public LoadHint get_LoadHint();
}
[ObsoleteAttribute("DisablePrivateReflectionAttribute has no effect in .NET 6.0+.")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.EnumeratorCancellationAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    [NullableContextAttribute("1")]
public static FormattableString Create(string format, Object[] arguments);
}
[NullableContextAttribute("1")]
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
internal interface System.Runtime.CompilerServices.IAsyncStateMachineBox {
    public Action MoveNextAction { get; }
    public abstract virtual void MoveNext();
    public abstract virtual Action get_MoveNextAction();
    public abstract virtual IAsyncStateMachine GetStateMachineObject();
    public abstract virtual void ClearStateUponCompletion();
}
[NullableContextAttribute("2")]
public interface System.Runtime.CompilerServices.ICastable {
    public abstract virtual bool IsInstanceOfInterface(RuntimeTypeHandle interfaceType, Exception& castError);
    public abstract virtual RuntimeTypeHandle GetImplType(RuntimeTypeHandle interfaceType);
}
internal interface System.Runtime.CompilerServices.IConfiguredTaskAwaiter {
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    [NullableContextAttribute("1")]
public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    [NullableContextAttribute("1")]
public IndexerNameAttribute(string indexerName);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.InlineArrayAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public InlineArrayAttribute(int length);
    [CompilerGeneratedAttribute]
public int get_Length();
}
[NullableContextAttribute("1")]
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllInternalsVisible>k__BackingField;
    public string AssemblyName { get; }
    public bool AllInternalsVisible { get; public set; }
    public InternalsVisibleToAttribute(string assemblyName);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public bool get_AllInternalsVisible();
    [CompilerGeneratedAttribute]
public void set_AllInternalsVisible(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[AttributeUsageAttribute("364")]
internal class System.Runtime.CompilerServices.IntrinsicAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
public static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal interface System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter {
    public abstract virtual void AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[NullableContextAttribute("2")]
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
internal interface System.Runtime.CompilerServices.ITaskAwaiter {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public IteratorStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public int Length { get; }
    public object Item { get; }
    public abstract virtual int get_Length();
    public abstract virtual object get_Item(int index);
}
internal static class System.Runtime.CompilerServices.JitHelpers : object {
    [IntrinsicAttribute]
public static bool EnumEquals(T x, T y);
    [IntrinsicAttribute]
public static int EnumCompareTo(T x, T y);
    [IntrinsicAttribute]
internal static void DisableInline();
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.MetadataUpdateOriginalTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <OriginalType>k__BackingField;
    public Type OriginalType { get; }
    public MetadataUpdateOriginalTypeAttribute(Type originalType);
    [CompilerGeneratedAttribute]
public Type get_OriginalType();
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    [CompilerGeneratedAttribute]
private MethodImplOptions <Value>k__BackingField;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplAttribute(short value);
    [CompilerGeneratedAttribute]
public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions AggressiveOptimization;
    public static MethodImplOptions InternalCall;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("27524")]
public class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte value);
    public NullableAttribute(Byte[] value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("5196")]
public class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte value);
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2")]
public class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Runtime.CompilerServices.ObjectHandleOnStack : ValueType {
    private Void* _ptr;
    private ObjectHandleOnStack(Void* pObject);
    internal static ObjectHandleOnStack Create(T& o);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder : ValueType {
    private static StateMachineBox<VoidTaskResult> s_syncSuccessSentinel;
    private StateMachineBox<VoidTaskResult> m_task;
    public ValueTask Task { get; }
    private static PoolingAsyncValueTaskMethodBuilder();
    public static PoolingAsyncValueTaskMethodBuilder Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult();
    public void SetException(Exception exception);
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1 : ValueType {
    internal static StateMachineBox<TResult> s_syncSuccessSentinel;
    private StateMachineBox<TResult> m_task;
    private TResult _result;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTask`1<TResult> Task { get; }
    private static PoolingAsyncValueTaskMethodBuilder`1();
    public static PoolingAsyncValueTaskMethodBuilder`1<TResult> Create();
    public void Start(TStateMachine& stateMachine);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void SetResult(TResult result);
    public void SetException(Exception exception);
    internal static void SetException(Exception exception, StateMachineBox& boxFieldRef);
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    internal static void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine, StateMachineBox& box);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    internal static void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine, StateMachineBox& boxRef);
    private static IAsyncStateMachineBox GetStateMachineBox(TStateMachine& stateMachine, StateMachineBox& boxFieldRef);
    internal static StateMachineBox<TResult> CreateWeaklyTypedStateMachineBox();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.PreserveBaseOverridesAttribute : Attribute {
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Runtime.CompilerServices.QCallAssembly : ValueType {
    private Void* _ptr;
    private IntPtr _assembly;
    internal QCallAssembly(RuntimeAssembly& assembly);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Runtime.CompilerServices.QCallTypeHandle : ValueType {
    private Void* _ptr;
    private IntPtr _handle;
    internal QCallTypeHandle(RuntimeType& type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2")]
public class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    public int Version { get; }
    public RefSafetyRulesAttribute(int version);
    [CompilerGeneratedAttribute]
public int get_Version();
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.RequiresLocationAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <WrapNonExceptionThrows>k__BackingField;
    public bool WrapNonExceptionThrows { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_WrapNonExceptionThrows();
    [CompilerGeneratedAttribute]
public void set_WrapNonExceptionThrows(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string PortablePdb;
    public static string DefaultImplementationsOfInterfaces;
    public static string UnmanagedSignatureCallingConvention;
    public static string CovariantReturnsOfClasses;
    public static string ByRefFields;
    public static string VirtualStaticsInInterfaces;
    public static string NumericIntPtr;
    [CompilerGeneratedAttribute]
private static bool <IsDynamicCodeSupported>k__BackingField;
    public static bool IsDynamicCodeSupported { get; }
    public static bool IsDynamicCodeCompiled { get; }
    private static RuntimeFeature();
    public static bool IsSupported(string feature);
    [CompilerGeneratedAttribute]
[IntrinsicAttribute]
public static bool get_IsDynamicCodeSupported();
    [IntrinsicAttribute]
public static bool get_IsDynamicCodeCompiled();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    [ObsoleteAttribute("OffsetToStringData has been deprecated. Use string.GetPinnableReference() instead.")]
public static int OffsetToStringData { get; }
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    private static Void* GetSpanDataFrom(RuntimeFieldHandle fldHandle, RuntimeTypeHandle targetTypeHandle, Int32& count);
    public static int get_OffsetToStringData();
    private static int InternalGetHashCode(object o);
    [NullableContextAttribute("2")]
public static int GetHashCode(object o);
    private static int InternalTryGetHashCode(object o);
    internal static int TryGetHashCode(object o);
    [NullableContextAttribute("2")]
public static bool Equals(object o1, object o2);
    [NullableContextAttribute("2")]
public static object GetObjectValue(object obj);
    [RequiresUnreferencedCodeAttribute("Trimmer can't guarantee existence of class constructor")]
public static void RunClassConstructor(RuntimeTypeHandle type);
    public static void EnsureSufficientExecutionStack();
    public static bool TryEnsureSufficientExecutionStack();
    public static void PrepareDelegate(Delegate d);
    public static void PrepareMethod(RuntimeMethodHandle method);
    [NullableContextAttribute("2")]
public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    public static void RunModuleConstructor(ModuleHandle module);
    public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Byte& GetRawData(object obj);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool IsReferenceOrContainsReferences();
    [IntrinsicAttribute]
internal static bool IsBitwiseEquatable();
    [IntrinsicAttribute]
internal static bool ObjectHasComponentSize(object obj);
    [IntrinsicAttribute]
internal static bool ObjectHasReferences(object obj);
    public static object GetUninitializedObject(Type type);
    private static void PrepareMethod(IntPtr method, IntPtr* instantiations, int ninst);
    private static object GetUninitializedObjectInternal(IntPtr type);
    private static void InitializeArray(Array array, IntPtr fldHandle);
    private static IntPtr GetSpanDataFrom(IntPtr fldHandle, IntPtr targetTypeHandle, IntPtr count);
    private static void RunClassConstructor(IntPtr type);
    private static void RunModuleConstructor(IntPtr module);
    private static bool SufficientExecutionStack();
    public static T[] GetSubArray(T[] array, Range range);
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void PrepareContractedDelegate(Delegate d);
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void ProbeForSufficientStack();
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void PrepareConstrainedRegions();
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void PrepareConstrainedRegionsNoOP();
    [ExtensionAttribute]
internal static bool IsPrimitiveType(CorElementType et);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static ReadOnlySpan`1<T> CreateSpan(RuntimeFieldHandle fldHandle);
    [IntrinsicAttribute]
internal static bool IsKnownConstant(Type t);
    [IntrinsicAttribute]
internal static bool IsKnownConstant(char t);
    [IntrinsicAttribute]
internal static bool IsKnownConstant(int t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    private object _wrappedException;
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private RuntimeWrappedException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public object get_WrappedException();
}
[EditorBrowsableAttribute("1")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
public class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <StateMachineType>k__BackingField;
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    [CompilerGeneratedAttribute]
public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    [NullableAttribute("1")]
[MaybeNullAttribute]
public T Value;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    [NullableContextAttribute("1")]
public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[ObsoleteAttribute("SuppressIldasmAttribute has no effect in .NET 6.0+.")]
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Runtime.Extensions, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")]
public class System.Runtime.CompilerServices.SwitchExpressionException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private object <UnmatchedValue>k__BackingField;
    public object UnmatchedValue { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public SwitchExpressionException(Exception innerException);
    public SwitchExpressionException(object unmatchedValue);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private SwitchExpressionException(SerializationInfo info, StreamingContext context);
    public SwitchExpressionException(string message);
    public SwitchExpressionException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public object get_UnmatchedValue();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string get_Message();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    internal Task m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter(Task task);
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [StackTraceHiddenAttribute]
public void GetResult();
    [StackTraceHiddenAttribute]
internal static void ValidateEnd(Task task, ConfigureAwaitOptions options);
    [StackTraceHiddenAttribute]
private static void HandleNonSuccessAndDebuggerNotification(Task task, ConfigureAwaitOptions options);
    [StackTraceHiddenAttribute]
private static void ThrowForNonSuccess(Task task);
    internal static void OnCompletedInternal(Task task, Action continuation, bool continueOnCapturedContext, bool flowExecutionContext);
    internal static void UnsafeOnCompletedInternal(Task task, IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext);
    private static Action OutputWaitEtwEvents(Task task, Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private Task`1<TResult> m_task;
    public bool IsCompleted { get; }
    internal TaskAwaiter`1(Task`1<TResult> task);
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    [NullableContextAttribute("1")]
[StackTraceHiddenAttribute]
public TResult GetResult();
}
[CLSCompliantAttribute("False")]
[AttributeUsageAttribute("11148")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    private String[] _transformNames;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Destination>k__BackingField;
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    [CompilerGeneratedAttribute]
public Type get_Destination();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.Unsafe : object {
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static Void* AsPointer(T& value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static int SizeOf();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static T As(object o);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static TTo& As(TFrom& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Add(T& source, int elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Add(T& source, IntPtr elementOffset);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static Void* Add(Void* source, int elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T& Add(T& source, UIntPtr elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T& AddByteOffset(T& source, UIntPtr byteOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool AreSame(T& left, T& right);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static TTo BitCast(TFrom source);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Copy(Void* destination, T& source);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Copy(T& destination, Void* source);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void CopyBlock(Void* destination, Void* source, UInt32 byteCount);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void CopyBlockUnaligned(Void* destination, Void* source, UInt32 byteCount);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void CopyBlockUnaligned(Byte& destination, Byte& source, UInt32 byteCount);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsAddressGreaterThan(T& left, T& right);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsAddressLessThan(T& left, T& right);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void InitBlock(Void* startAddress, byte value, UInt32 byteCount);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void InitBlock(Byte& startAddress, byte value, UInt32 byteCount);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T ReadUnaligned(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T ReadUnaligned(Byte& source);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void WriteUnaligned(Void* destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void WriteUnaligned(Byte& destination, T value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AddByteOffset(T& source, IntPtr byteOffset);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T Read(Void* source);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static void Write(Void* destination, T value);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T& AsRef(Void* source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& AsRef(T& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr ByteOffset(T& origin, T& target);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& NullRef();
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool IsNullRef(T& source);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void SkipInit(T& value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Subtract(T& source, int elementOffset);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static Void* Subtract(Void* source, int elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Subtract(T& source, IntPtr elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T& Subtract(T& source, UIntPtr elementOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T& SubtractByteOffset(T& source, IntPtr byteOffset);
    [IntrinsicAttribute]
[NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static T& SubtractByteOffset(T& source, UIntPtr byteOffset);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static T& Unbox(object box);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.UnsafeAccessorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UnsafeAccessorKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public UnsafeAccessorKind Kind { get; }
    public string Name { get; public set; }
    public UnsafeAccessorAttribute(UnsafeAccessorKind kind);
    [CompilerGeneratedAttribute]
public UnsafeAccessorKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public enum System.Runtime.CompilerServices.UnsafeAccessorKind : Enum {
    public int value__;
    public static UnsafeAccessorKind Constructor;
    public static UnsafeAccessorKind Method;
    public static UnsafeAccessorKind StaticMethod;
    public static UnsafeAccessorKind Field;
    public static UnsafeAccessorKind StaticField;
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    internal static Action`1<object> s_invokeActionDelegate;
    private ValueTask _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter(ValueTask& value);
    private static ValueTaskAwaiter();
    public bool get_IsCompleted();
    public void GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    private sealed virtual override void System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private ValueTask`1<TResult> _value;
    public bool IsCompleted { get; }
    internal ValueTaskAwaiter`1(ValueTask`1& value);
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public TResult GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
    private sealed virtual override void System.Runtime.CompilerServices.IStateMachineBoxAwareAwaiter.AwaitUnsafeOnCompleted(IAsyncStateMachineBox box);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
[AttributeUsageAttribute("96")]
public class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Consistency <ConsistencyGuarantee>k__BackingField;
    [CompilerGeneratedAttribute]
private Cer <Cer>k__BackingField;
    public Consistency ConsistencyGuarantee { get; }
    public Cer Cer { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    [CompilerGeneratedAttribute]
public Consistency get_ConsistencyGuarantee();
    [CompilerGeneratedAttribute]
public Cer get_Cer();
}
public static class System.Runtime.ControlledExecution : object {
    [NullableContextAttribute("1")]
[ObsoleteAttribute("ControlledExecution.Run method may corrupt the process and should not be used in production code.")]
public static void Run(Action action, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.DependentHandle : ValueType {
    private Ephemeron[] _data;
    public bool IsAllocated { get; }
    public object Target { get; public set; }
    public object Dependent { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<object, object> TargetAndDependent { get; }
    public DependentHandle(object target, object dependent);
    public bool get_IsAllocated();
    public object get_Target();
    public void set_Target(object value);
    public object get_Dependent();
    public void set_Dependent(object value);
    public ValueTuple`2<object, object> get_TargetAndDependent();
    internal object UnsafeGetTarget();
    internal object UnsafeGetDependent();
    internal object UnsafeGetTargetAndDependent(Object& dependent);
    internal void UnsafeSetTargetToNull();
    internal void UnsafeSetDependent(object dependent);
    public sealed virtual void Dispose();
}
internal class System.Runtime.Ephemeron : ValueType {
    public object Key;
    public object Value;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    private Exception _exception;
    private DispatchState _dispatchState;
    public Exception SourceException { get; }
    private ExceptionDispatchInfo(Exception exception);
    public static ExceptionDispatchInfo Capture(Exception source);
    public Exception get_SourceException();
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
public void Throw();
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
public static void Throw(Exception source);
    [StackTraceHiddenAttribute]
public static Exception SetCurrentStackTrace(Exception source);
    public static Exception SetRemoteStackTrace(Exception source, string stackTrace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
[ObsoleteAttribute("Recovery from corrupted process state exceptions is not supported; HandleProcessCorruptedStateExceptionsAttribute is ignored.")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
internal class System.Runtime.GCFrameRegistration : ValueType {
    public GCFrameRegistration(Void* allocation, UInt32 elemCount, bool areByRefs);
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static bool IsServerGC { get; }
    public static GCLatencyMode LatencyMode { get; public set; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static bool get_IsServerGC();
    private static SetLatencyModeStatus SetGCLatencyMode(GCLatencyMode newLatencyMode);
    private static void SetLOHCompactionMode(GCLargeObjectHeapCompactionMode newLOHCompactionMode);
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.AllowReversePInvokeCallsAttribute : Attribute {
}
public enum System.Runtime.InteropServices.Architecture : Enum {
    public int value__;
    public static Architecture X86;
    public static Architecture X64;
    public static Architecture Arm;
    public static Architecture Arm64;
    public static Architecture Wasm;
    public static Architecture S390x;
    public static Architecture LoongArch64;
    public static Architecture Armv6;
    public static Architecture Ppc64le;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.ArrayWithOffset : ValueType {
    private object m_array;
    private int m_offset;
    private int m_count;
    public ArrayWithOffset(object array, int offset);
    public object GetArray();
    public int GetOffset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ArrayWithOffset obj);
    public static bool op_Equality(ArrayWithOffset a, ArrayWithOffset b);
    public static bool op_Inequality(ArrayWithOffset a, ArrayWithOffset b);
}
[AttributeUsageAttribute("1037")]
public class System.Runtime.InteropServices.BestFitMappingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <BestFitMapping>k__BackingField;
    public bool ThrowOnUnmappableChar;
    public bool BestFitMapping { get; }
    public BestFitMappingAttribute(bool BestFitMapping);
    [CompilerGeneratedAttribute]
public bool get_BestFitMapping();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.BStrWrapper : object {
    [CompilerGeneratedAttribute]
private string <WrappedObject>k__BackingField;
    public string WrappedObject { get; }
    public BStrWrapper(string value);
    public BStrWrapper(object value);
    [CompilerGeneratedAttribute]
public string get_WrappedObject();
}
public enum System.Runtime.InteropServices.CallingConvention : Enum {
    public int value__;
    public static CallingConvention Winapi;
    public static CallingConvention Cdecl;
    public static CallingConvention StdCall;
    public static CallingConvention ThisCall;
    public static CallingConvention FastCall;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5")]
public class System.Runtime.InteropServices.ClassInterfaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ClassInterfaceType <Value>k__BackingField;
    public ClassInterfaceType Value { get; }
    public ClassInterfaceAttribute(ClassInterfaceType classInterfaceType);
    public ClassInterfaceAttribute(short classInterfaceType);
    [CompilerGeneratedAttribute]
public ClassInterfaceType get_Value();
}
public enum System.Runtime.InteropServices.ClassInterfaceType : Enum {
    public int value__;
    public static ClassInterfaceType None;
    public static ClassInterfaceType AutoDispatch;
    public static ClassInterfaceType AutoDual;
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public class System.Runtime.InteropServices.CLong : ValueType {
    private IntPtr _value;
    public IntPtr Value { get; }
    public CLong(int value);
    public CLong(IntPtr value);
    public IntPtr get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public sealed virtual bool Equals(CLong other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.CoClassAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <CoClass>k__BackingField;
    public Type CoClass { get; }
    public CoClassAttribute(Type coClass);
    [CompilerGeneratedAttribute]
public Type get_CoClass();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.CollectionsMarshal : object {
    [NullableContextAttribute("2")]
public static Span`1<T> AsSpan(List`1<T> list);
    public static TValue& GetValueRefOrNullRef(Dictionary`2<TKey, TValue> dictionary, TKey key);
    public static TValue& GetValueRefOrAddDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, Boolean& exists);
    public static void SetCount(List`1<T> list, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ComDefaultInterfaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Value>k__BackingField;
    public Type Value { get; }
    public ComDefaultInterfaceAttribute(Type defaultInterface);
    [CompilerGeneratedAttribute]
public Type get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1024")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComEventInterfaceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <SourceInterface>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EventProvider>k__BackingField;
    [DynamicallyAccessedMembersAttribute("8")]
public Type SourceInterface { get; }
    [DynamicallyAccessedMembersAttribute("2607")]
public Type EventProvider { get; }
    public ComEventInterfaceAttribute(Type SourceInterface, Type EventProvider);
    [CompilerGeneratedAttribute]
public Type get_SourceInterface();
    [CompilerGeneratedAttribute]
public Type get_EventProvider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static class System.Runtime.InteropServices.ComEventsHelper : object {
    public static void Combine(object rcw, Guid iid, int dispid, Delegate d);
    public static Delegate Remove(object rcw, Guid iid, int dispid, Delegate d);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.COMException : ExternalException {
    public COMException(string message);
    public COMException(string message, Exception inner);
    public COMException(string message, int errorCode);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected COMException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("1028")]
public class System.Runtime.InteropServices.ComImportAttribute : Attribute {
}
public enum System.Runtime.InteropServices.ComInterfaceType : Enum {
    public int value__;
    public static ComInterfaceType InterfaceIsDual;
    public static ComInterfaceType InterfaceIsIUnknown;
    public static ComInterfaceType InterfaceIsIDispatch;
    public static ComInterfaceType InterfaceIsIInspectable;
}
public enum System.Runtime.InteropServices.ComMemberType : Enum {
    public int value__;
    public static ComMemberType Method;
    public static ComMemberType PropGet;
    public static ComMemberType PropSet;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComSourceInterfacesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ComSourceInterfacesAttribute(string sourceInterfaces);
    public ComSourceInterfacesAttribute(Type sourceInterface);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3);
    public ComSourceInterfacesAttribute(Type sourceInterface1, Type sourceInterface2, Type sourceInterface3, Type sourceInterface4);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.BIND_OPTS : ValueType {
    public int cbStruct;
    public int grfFlags;
    public int grfMode;
    public int dwTickCountDeadline;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.BINDPTR : ValueType {
    public IntPtr lpfuncdesc;
    public IntPtr lpvardesc;
    public IntPtr lptcomp;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.CALLCONV : Enum {
    public int value__;
    public static CALLCONV CC_CDECL;
    public static CALLCONV CC_MSCPASCAL;
    public static CALLCONV CC_PASCAL;
    public static CALLCONV CC_MACPASCAL;
    public static CALLCONV CC_STDCALL;
    public static CALLCONV CC_RESERVED;
    public static CALLCONV CC_SYSCALL;
    public static CALLCONV CC_MPWCDECL;
    public static CALLCONV CC_MPWPASCAL;
    public static CALLCONV CC_MAX;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.CONNECTDATA : ValueType {
    [NullableAttribute("1")]
public object pUnk;
    public int dwCookie;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.DESCKIND : Enum {
    public int value__;
    public static DESCKIND DESCKIND_NONE;
    public static DESCKIND DESCKIND_FUNCDESC;
    public static DESCKIND DESCKIND_VARDESC;
    public static DESCKIND DESCKIND_TYPECOMP;
    public static DESCKIND DESCKIND_IMPLICITAPPOBJ;
    public static DESCKIND DESCKIND_MAX;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.DISPPARAMS : ValueType {
    public IntPtr rgvarg;
    public IntPtr rgdispidNamedArgs;
    public int cArgs;
    public int cNamedArgs;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.ELEMDESC : ValueType {
    public TYPEDESC tdesc;
    public DESCUNION desc;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.EXCEPINFO : ValueType {
    public short wCode;
    public short wReserved;
    public string bstrSource;
    public string bstrDescription;
    public string bstrHelpFile;
    public int dwHelpContext;
    public IntPtr pvReserved;
    public IntPtr pfnDeferredFillIn;
    public int scode;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.FILETIME : ValueType {
    public int dwLowDateTime;
    public int dwHighDateTime;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.FUNCDESC : ValueType {
    public int memid;
    public IntPtr lprgscode;
    public IntPtr lprgelemdescParam;
    public FUNCKIND funckind;
    public INVOKEKIND invkind;
    public CALLCONV callconv;
    public short cParams;
    public short cParamsOpt;
    public short oVft;
    public short cScodes;
    public ELEMDESC elemdescFunc;
    public short wFuncFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.FUNCFLAGS : Enum {
    public short value__;
    public static FUNCFLAGS FUNCFLAG_FRESTRICTED;
    public static FUNCFLAGS FUNCFLAG_FSOURCE;
    public static FUNCFLAGS FUNCFLAG_FBINDABLE;
    public static FUNCFLAGS FUNCFLAG_FREQUESTEDIT;
    public static FUNCFLAGS FUNCFLAG_FDISPLAYBIND;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTBIND;
    public static FUNCFLAGS FUNCFLAG_FHIDDEN;
    public static FUNCFLAGS FUNCFLAG_FUSESGETLASTERROR;
    public static FUNCFLAGS FUNCFLAG_FDEFAULTCOLLELEM;
    public static FUNCFLAGS FUNCFLAG_FUIDEFAULT;
    public static FUNCFLAGS FUNCFLAG_FNONBROWSABLE;
    public static FUNCFLAGS FUNCFLAG_FREPLACEABLE;
    public static FUNCFLAGS FUNCFLAG_FIMMEDIATEBIND;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.FUNCKIND : Enum {
    public int value__;
    public static FUNCKIND FUNC_VIRTUAL;
    public static FUNCKIND FUNC_PUREVIRTUAL;
    public static FUNCKIND FUNC_NONVIRTUAL;
    public static FUNCKIND FUNC_STATIC;
    public static FUNCKIND FUNC_DISPATCH;
}
[NullableContextAttribute("1")]
[GuidAttribute("0000000e-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IBindCtx {
    public abstract virtual void RegisterObjectBound(object punk);
    public abstract virtual void RevokeObjectBound(object punk);
    public abstract virtual void ReleaseBoundObjects();
    public abstract virtual void SetBindOptions(BIND_OPTS& pbindopts);
    public abstract virtual void GetBindOptions(BIND_OPTS& pbindopts);
    [NullableContextAttribute("2")]
public abstract virtual void GetRunningObjectTable(IRunningObjectTable& pprot);
    public abstract virtual void RegisterObjectParam(string pszKey, object punk);
    public abstract virtual void GetObjectParam(string pszKey, Object& ppunk);
    [NullableContextAttribute("2")]
public abstract virtual void EnumObjectParam(IEnumString& ppenum);
    public abstract virtual int RevokeObjectParam(string pszKey);
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B286-BAB4-101A-B69C-00AA00341D07")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPoint {
    public abstract virtual void GetConnectionInterface(Guid& pIID);
    public abstract virtual void GetConnectionPointContainer(IConnectionPointContainer& ppCPC);
    public abstract virtual void Advise(object pUnkSink, Int32& pdwCookie);
    public abstract virtual void Unadvise(int dwCookie);
    public abstract virtual void EnumConnections(IEnumConnections& ppEnum);
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B284-BAB4-101A-B69C-00AA00341D07")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IConnectionPointContainer {
    public abstract virtual void EnumConnectionPoints(IEnumConnectionPoints& ppEnum);
    [NullableContextAttribute("2")]
public abstract virtual void FindConnectionPoint(Guid& riid, IConnectionPoint& ppCP);
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.IDLDESC : ValueType {
    public IntPtr dwReserved;
    public IDLFLAG wIDLFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IDLFLAG : Enum {
    public short value__;
    public static IDLFLAG IDLFLAG_NONE;
    public static IDLFLAG IDLFLAG_FIN;
    public static IDLFLAG IDLFLAG_FOUT;
    public static IDLFLAG IDLFLAG_FLCID;
    public static IDLFLAG IDLFLAG_FRETVAL;
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B285-BAB4-101A-B69C-00AA00341D07")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnectionPoints {
    public abstract virtual int Next(int celt, IConnectionPoint[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnectionPoints& ppenum);
}
[NullableContextAttribute("1")]
[GuidAttribute("B196B287-BAB4-101A-B69C-00AA00341D07")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumConnections {
    public abstract virtual int Next(int celt, CONNECTDATA[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumConnections& ppenum);
}
[NullableContextAttribute("1")]
[GuidAttribute("00000102-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumMoniker {
    public abstract virtual int Next(int celt, IMoniker[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumMoniker& ppenum);
}
[NullableContextAttribute("1")]
[GuidAttribute("00000101-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumString {
    public abstract virtual int Next(int celt, String[] rgelt, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumString& ppenum);
}
[NullableContextAttribute("1")]
[GuidAttribute("00020404-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IEnumVARIANT {
    public abstract virtual int Next(int celt, Object[] rgVar, IntPtr pceltFetched);
    public abstract virtual int Skip(int celt);
    public abstract virtual int Reset();
    public abstract virtual IEnumVARIANT Clone();
}
[NullableContextAttribute("1")]
[GuidAttribute("0000000f-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IMoniker {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pStm);
    public abstract virtual void Save(IStream pStm, bool fClearDirty);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
    public abstract virtual void BindToObject(IBindCtx pbc, IMoniker pmkToLeft, Guid& riidResult, Object& ppvResult);
    public abstract virtual void BindToStorage(IBindCtx pbc, IMoniker pmkToLeft, Guid& riid, Object& ppvObj);
    [NullableContextAttribute("2")]
public abstract virtual void Reduce(IBindCtx pbc, int dwReduceHowFar, IMoniker& ppmkToLeft, IMoniker& ppmkReduced);
    public abstract virtual void ComposeWith(IMoniker pmkRight, bool fOnlyIfNotGeneric, IMoniker& ppmkComposite);
    [NullableContextAttribute("2")]
public abstract virtual void Enum(bool fForward, IEnumMoniker& ppenumMoniker);
    public abstract virtual int IsEqual(IMoniker pmkOtherMoniker);
    public abstract virtual void Hash(Int32& pdwHash);
    [NullableContextAttribute("2")]
public abstract virtual int IsRunning(IBindCtx pbc, IMoniker pmkToLeft, IMoniker pmkNewlyRunning);
    public abstract virtual void GetTimeOfLastChange(IBindCtx pbc, IMoniker pmkToLeft, FILETIME& pFileTime);
    public abstract virtual void Inverse(IMoniker& ppmk);
    public abstract virtual void CommonPrefixWith(IMoniker pmkOther, IMoniker& ppmkPrefix);
    public abstract virtual void RelativePathTo(IMoniker pmkOther, IMoniker& ppmkRelPath);
    public abstract virtual void GetDisplayName(IBindCtx pbc, IMoniker pmkToLeft, String& ppszDisplayName);
    public abstract virtual void ParseDisplayName(IBindCtx pbc, IMoniker pmkToLeft, string pszDisplayName, Int32& pchEaten, IMoniker& ppmkOut);
    public abstract virtual int IsSystemMoniker(Int32& pdwMksys);
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.IMPLTYPEFLAGS : Enum {
    public int value__;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULT;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FSOURCE;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FRESTRICTED;
    public static IMPLTYPEFLAGS IMPLTYPEFLAG_FDEFAULTVTABLE;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.INVOKEKIND : Enum {
    public int value__;
    public static INVOKEKIND INVOKE_FUNC;
    public static INVOKEKIND INVOKE_PROPERTYGET;
    public static INVOKEKIND INVOKE_PROPERTYPUT;
    public static INVOKEKIND INVOKE_PROPERTYPUTREF;
}
[NullableContextAttribute("1")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    [NullableContextAttribute("2")]
public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual void GetCurFile(String& ppszFileName);
}
[NullableContextAttribute("1")]
[GuidAttribute("00000010-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IRunningObjectTable {
    public abstract virtual int Register(int grfFlags, object punkObject, IMoniker pmkObjectName);
    public abstract virtual void Revoke(int dwRegister);
    public abstract virtual int IsRunning(IMoniker pmkObjectName);
    public abstract virtual int GetObject(IMoniker pmkObjectName, Object& ppunkObject);
    public abstract virtual void NoteChangeTime(int dwRegister, FILETIME& pfiletime);
    public abstract virtual int GetTimeOfLastChange(IMoniker pmkObjectName, FILETIME& pfiletime);
    public abstract virtual void EnumRunning(IEnumMoniker& ppenumMoniker);
}
[NullableContextAttribute("1")]
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.IStream {
    public abstract virtual void Read(Byte[] pv, int cb, IntPtr pcbRead);
    public abstract virtual void Write(Byte[] pv, int cb, IntPtr pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, IntPtr plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, IntPtr pcbRead, IntPtr pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
[NullableContextAttribute("1")]
[GuidAttribute("00020403-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeComp {
    public abstract virtual void Bind(string szName, int lHashVal, short wFlags, ITypeInfo& ppTInfo, DESCKIND& pDescKind, BINDPTR& pBindPtr);
    public abstract virtual void BindType(string szName, int lHashVal, ITypeInfo& ppTInfo, ITypeComp& ppTComp);
}
[NullableContextAttribute("1")]
[GuidAttribute("00020401-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    [NullableContextAttribute("2")]
public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
}
[NullableContextAttribute("1")]
[GuidAttribute("00020412-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeInfo2 {
    public abstract virtual void GetTypeAttr(IntPtr& ppTypeAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetFuncDesc(int index, IntPtr& ppFuncDesc);
    public abstract virtual void GetVarDesc(int index, IntPtr& ppVarDesc);
    public abstract virtual void GetNames(int memid, String[] rgBstrNames, int cMaxNames, Int32& pcNames);
    public abstract virtual void GetRefTypeOfImplType(int index, Int32& href);
    public abstract virtual void GetImplTypeFlags(int index, IMPLTYPEFLAGS& pImplTypeFlags);
    public abstract virtual void GetIDsOfNames(String[] rgszNames, int cNames, Int32[] pMemId);
    public abstract virtual void Invoke(object pvInstance, int memid, short wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, Int32& puArgErr);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual void GetDllEntry(int memid, INVOKEKIND invKind, IntPtr pBstrDllName, IntPtr pBstrName, IntPtr pwOrdinal);
    public abstract virtual void GetRefTypeInfo(int hRef, ITypeInfo& ppTI);
    public abstract virtual void AddressOfMember(int memid, INVOKEKIND invKind, IntPtr& ppv);
    public abstract virtual void CreateInstance(object pUnkOuter, Guid& riid, Object& ppvObj);
    [NullableContextAttribute("2")]
public abstract virtual void GetMops(int memid, String& pBstrMops);
    public abstract virtual void GetContainingTypeLib(ITypeLib& ppTLB, Int32& pIndex);
    public abstract virtual void ReleaseTypeAttr(IntPtr pTypeAttr);
    public abstract virtual void ReleaseFuncDesc(IntPtr pFuncDesc);
    public abstract virtual void ReleaseVarDesc(IntPtr pVarDesc);
    public abstract virtual void GetTypeKind(TYPEKIND& pTypeKind);
    public abstract virtual void GetTypeFlags(Int32& pTypeFlags);
    public abstract virtual void GetFuncIndexOfMemId(int memid, INVOKEKIND invKind, Int32& pFuncIndex);
    public abstract virtual void GetVarIndexOfMemId(int memid, Int32& pVarIndex);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    public abstract virtual void GetFuncCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetParamCustData(int indexFunc, int indexParam, Guid& guid, Object& pVarVal);
    public abstract virtual void GetVarCustData(int index, Guid& guid, Object& pVarVal);
    public abstract virtual void GetImplTypeCustData(int index, Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int memid, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
    public abstract virtual void GetAllFuncCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllParamCustData(int indexFunc, int indexParam, IntPtr pCustData);
    public abstract virtual void GetAllVarCustData(int index, IntPtr pCustData);
    public abstract virtual void GetAllImplTypeCustData(int index, IntPtr pCustData);
}
[NullableContextAttribute("1")]
[GuidAttribute("00020402-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
}
[NullableContextAttribute("1")]
[GuidAttribute("00020411-0000-0000-C000-000000000046")]
[EditorBrowsableAttribute("1")]
[InterfaceTypeAttribute("1")]
public interface System.Runtime.InteropServices.ComTypes.ITypeLib2 {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual void GetTypeInfo(int index, ITypeInfo& ppTI);
    public abstract virtual void GetTypeInfoType(int index, TYPEKIND& pTKind);
    public abstract virtual void GetTypeInfoOfGuid(Guid& guid, ITypeInfo& ppTInfo);
    public abstract virtual void GetLibAttr(IntPtr& ppTLibAttr);
    public abstract virtual void GetTypeComp(ITypeComp& ppTComp);
    public abstract virtual void GetDocumentation(int index, String& strName, String& strDocString, Int32& dwHelpContext, String& strHelpFile);
    public abstract virtual bool IsName(string szNameBuf, int lHashVal);
    public abstract virtual void FindName(string szNameBuf, int lHashVal, ITypeInfo[] ppTInfo, Int32[] rgMemId, Int16& pcFound);
    public abstract virtual void ReleaseTLibAttr(IntPtr pTLibAttr);
    public abstract virtual void GetCustData(Guid& guid, Object& pVarVal);
    [LCIDConversionAttribute("1")]
public abstract virtual void GetDocumentation2(int index, String& pbstrHelpString, Int32& pdwHelpStringContext, String& pbstrHelpStringDll);
    public abstract virtual void GetLibStatistics(IntPtr pcUniqueNames, Int32& pcchUniqueNames);
    public abstract virtual void GetAllCustData(IntPtr pCustData);
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.LIBFLAGS : Enum {
    public short value__;
    public static LIBFLAGS LIBFLAG_FRESTRICTED;
    public static LIBFLAGS LIBFLAG_FCONTROL;
    public static LIBFLAGS LIBFLAG_FHIDDEN;
    public static LIBFLAGS LIBFLAG_FHASDISKIMAGE;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.PARAMDESC : ValueType {
    public IntPtr lpVarValue;
    public PARAMFLAG wParamFlags;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.PARAMFLAG : Enum {
    public short value__;
    public static PARAMFLAG PARAMFLAG_NONE;
    public static PARAMFLAG PARAMFLAG_FIN;
    public static PARAMFLAG PARAMFLAG_FOUT;
    public static PARAMFLAG PARAMFLAG_FLCID;
    public static PARAMFLAG PARAMFLAG_FRETVAL;
    public static PARAMFLAG PARAMFLAG_FOPT;
    public static PARAMFLAG PARAMFLAG_FHASDEFAULT;
    public static PARAMFLAG PARAMFLAG_FHASCUSTDATA;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.STATSTG : ValueType {
    [NullableAttribute("1")]
public string pwcsName;
    public int type;
    public long cbSize;
    public FILETIME mtime;
    public FILETIME ctime;
    public FILETIME atime;
    public int grfMode;
    public int grfLocksSupported;
    public Guid clsid;
    public int grfStateBits;
    public int reserved;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.SYSKIND : Enum {
    public int value__;
    public static SYSKIND SYS_WIN16;
    public static SYSKIND SYS_WIN32;
    public static SYSKIND SYS_MAC;
    public static SYSKIND SYS_WIN64;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.TYPEATTR : ValueType {
    public static int MEMBER_ID_NIL;
    public Guid guid;
    public int lcid;
    public int dwReserved;
    public int memidConstructor;
    public int memidDestructor;
    public IntPtr lpstrSchema;
    public int cbSizeInstance;
    public TYPEKIND typekind;
    public short cFuncs;
    public short cVars;
    public short cImplTypes;
    public short cbSizeVft;
    public short cbAlignment;
    public TYPEFLAGS wTypeFlags;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public TYPEDESC tdescAlias;
    public IDLDESC idldescType;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.TYPEDESC : ValueType {
    public IntPtr lpValue;
    public short vt;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.TYPEFLAGS : Enum {
    public short value__;
    public static TYPEFLAGS TYPEFLAG_FAPPOBJECT;
    public static TYPEFLAGS TYPEFLAG_FCANCREATE;
    public static TYPEFLAGS TYPEFLAG_FLICENSED;
    public static TYPEFLAGS TYPEFLAG_FPREDECLID;
    public static TYPEFLAGS TYPEFLAG_FHIDDEN;
    public static TYPEFLAGS TYPEFLAG_FCONTROL;
    public static TYPEFLAGS TYPEFLAG_FDUAL;
    public static TYPEFLAGS TYPEFLAG_FNONEXTENSIBLE;
    public static TYPEFLAGS TYPEFLAG_FOLEAUTOMATION;
    public static TYPEFLAGS TYPEFLAG_FRESTRICTED;
    public static TYPEFLAGS TYPEFLAG_FAGGREGATABLE;
    public static TYPEFLAGS TYPEFLAG_FREPLACEABLE;
    public static TYPEFLAGS TYPEFLAG_FDISPATCHABLE;
    public static TYPEFLAGS TYPEFLAG_FREVERSEBIND;
    public static TYPEFLAGS TYPEFLAG_FPROXY;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.TYPEKIND : Enum {
    public int value__;
    public static TYPEKIND TKIND_ENUM;
    public static TYPEKIND TKIND_RECORD;
    public static TYPEKIND TKIND_MODULE;
    public static TYPEKIND TKIND_INTERFACE;
    public static TYPEKIND TKIND_DISPATCH;
    public static TYPEKIND TKIND_COCLASS;
    public static TYPEKIND TKIND_ALIAS;
    public static TYPEKIND TKIND_UNION;
    public static TYPEKIND TKIND_MAX;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.TYPELIBATTR : ValueType {
    public Guid guid;
    public int lcid;
    public SYSKIND syskind;
    public short wMajorVerNum;
    public short wMinorVerNum;
    public LIBFLAGS wLibFlags;
}
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ComTypes.VARDESC : ValueType {
    public int memid;
    [NullableAttribute("1")]
public string lpstrSchema;
    public DESCUNION desc;
    public ELEMDESC elemdescVar;
    public short wVarFlags;
    public VARKIND varkind;
}
[EditorBrowsableAttribute("1")]
[FlagsAttribute]
public enum System.Runtime.InteropServices.ComTypes.VARFLAGS : Enum {
    public short value__;
    public static VARFLAGS VARFLAG_FREADONLY;
    public static VARFLAGS VARFLAG_FSOURCE;
    public static VARFLAGS VARFLAG_FBINDABLE;
    public static VARFLAGS VARFLAG_FREQUESTEDIT;
    public static VARFLAGS VARFLAG_FDISPLAYBIND;
    public static VARFLAGS VARFLAG_FDEFAULTBIND;
    public static VARFLAGS VARFLAG_FHIDDEN;
    public static VARFLAGS VARFLAG_FRESTRICTED;
    public static VARFLAGS VARFLAG_FDEFAULTCOLLELEM;
    public static VARFLAGS VARFLAG_FUIDEFAULT;
    public static VARFLAGS VARFLAG_FNONBROWSABLE;
    public static VARFLAGS VARFLAG_FREPLACEABLE;
    public static VARFLAGS VARFLAG_FIMMEDIATEBIND;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.ComTypes.VARKIND : Enum {
    public int value__;
    public static VARKIND VAR_PERINSTANCE;
    public static VARKIND VAR_STATIC;
    public static VARKIND VAR_CONST;
    public static VARKIND VAR_DISPATCH;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    [CompilerGeneratedAttribute]
public bool get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.InteropServices.ComWrappers : object {
    [NullableContextAttribute("0")]
protected abstract virtual ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, Int32& count);
    [NullableContextAttribute("2")]
protected abstract virtual object CreateObject(IntPtr externalComObject, CreateObjectFlags flags);
    protected abstract virtual void ReleaseObjects(IEnumerable objects);
    public static bool TryGetComInstance(object obj, IntPtr& unknown);
    [NullableContextAttribute("2")]
public static bool TryGetObject(IntPtr unknown, Object& obj);
    public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);
    public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags);
    public object GetOrRegisterObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object wrapper);
    public object GetOrRegisterObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object wrapper, IntPtr inner);
    public static void RegisterForTrackerSupport(ComWrappers instance);
    [SupportedOSPlatformAttribute("windows")]
public static void RegisterForMarshalling(ComWrappers instance);
    public static void GetIUnknownImpl(IntPtr& fpQueryInterface, IntPtr& fpAddRef, IntPtr& fpRelease);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.CreateComInterfaceFlags : Enum {
    public int value__;
    public static CreateComInterfaceFlags None;
    public static CreateComInterfaceFlags CallerDefinedIUnknown;
    public static CreateComInterfaceFlags TrackerSupport;
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.CreateObjectFlags : Enum {
    public int value__;
    public static CreateObjectFlags None;
    public static CreateObjectFlags TrackerObject;
    public static CreateObjectFlags UniqueInstance;
    public static CreateObjectFlags Aggregation;
    public static CreateObjectFlags Unwrap;
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private bool _isClosed;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    protected virtual override void Finalize();
    private void Cleanup();
    protected void SetHandle(IntPtr handle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public class System.Runtime.InteropServices.CULong : ValueType {
    private UIntPtr _value;
    public UIntPtr Value { get; }
    public CULong(UInt32 value);
    public CULong(UIntPtr value);
    public UIntPtr get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public sealed virtual bool Equals(CULong other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("CurrencyWrapper and support for marshalling to the VARIANT type may be unavailable in future releases.")]
public class System.Runtime.InteropServices.CurrencyWrapper : object {
    [CompilerGeneratedAttribute]
private decimal <WrappedObject>k__BackingField;
    public decimal WrappedObject { get; }
    public CurrencyWrapper(decimal obj);
    [NullableContextAttribute("1")]
public CurrencyWrapper(object obj);
    [CompilerGeneratedAttribute]
public decimal get_WrappedObject();
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.CustomQueryInterfaceMode : Enum {
    public int value__;
    public static CustomQueryInterfaceMode Ignore;
    public static CustomQueryInterfaceMode Allow;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.CustomQueryInterfaceResult : Enum {
    public int value__;
    public static CustomQueryInterfaceResult Handled;
    public static CustomQueryInterfaceResult NotHandled;
    public static CustomQueryInterfaceResult Failed;
}
[AttributeUsageAttribute("2")]
public class System.Runtime.InteropServices.DefaultCharSetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CharSet <CharSet>k__BackingField;
    public CharSet CharSet { get; }
    public DefaultCharSetAttribute(CharSet charSet);
    [CompilerGeneratedAttribute]
public CharSet get_CharSet();
}
[AttributeUsageAttribute("65")]
public class System.Runtime.InteropServices.DefaultDllImportSearchPathsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DllImportSearchPath <Paths>k__BackingField;
    public DllImportSearchPath Paths { get; }
    public DefaultDllImportSearchPathsAttribute(DllImportSearchPath paths);
    [CompilerGeneratedAttribute]
public DllImportSearchPath get_Paths();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.DefaultParameterValueAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public DefaultParameterValueAttribute(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.DispatchWrapper : object {
    [CompilerGeneratedAttribute]
private object <WrappedObject>k__BackingField;
    public object WrappedObject { get; }
    public DispatchWrapper(object obj);
    [CompilerGeneratedAttribute]
public object get_WrappedObject();
}
[AttributeUsageAttribute("960")]
public class System.Runtime.InteropServices.DispIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public DispIdAttribute(int dispId);
    [CompilerGeneratedAttribute]
public int get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.DllImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("2")]
public string EntryPoint;
    public CharSet CharSet;
    public bool SetLastError;
    public bool ExactSpelling;
    public CallingConvention CallingConvention;
    public bool BestFitMapping;
    public bool PreserveSig;
    public bool ThrowOnUnmappableChar;
    public string Value { get; }
    public DllImportAttribute(string dllName);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class System.Runtime.InteropServices.DllImportResolver : MulticastDelegate {
    public DllImportResolver(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IntPtr Invoke(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath);
    public virtual IAsyncResult BeginInvoke(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum System.Runtime.InteropServices.DllImportSearchPath : Enum {
    public int value__;
    public static DllImportSearchPath UseDllDirectoryForDependencies;
    public static DllImportSearchPath ApplicationDirectory;
    public static DllImportSearchPath UserDirectories;
    public static DllImportSearchPath System32;
    public static DllImportSearchPath SafeDirectories;
    public static DllImportSearchPath AssemblyDirectory;
    public static DllImportSearchPath LegacyBehavior;
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.DynamicInterfaceCastableImplementationAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.ErrorWrapper : object {
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    public int ErrorCode { get; }
    public ErrorWrapper(int errorCode);
    public ErrorWrapper(object errorCode);
    public ErrorWrapper(Exception e);
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ExternalException(SerializationInfo info, StreamingContext context);
    public virtual int get_ErrorCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    [CompilerGeneratedAttribute]
public int get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private IntPtr _handle;
    public object Target { get; public set; }
    public bool IsAllocated { get; }
    private GCHandle(object value, GCHandleType type);
    private GCHandle(IntPtr handle);
    internal static IntPtr InternalAlloc(object value, GCHandleType type);
    internal static void InternalFree(IntPtr handle);
    internal static object InternalGet(IntPtr handle);
    internal static void InternalSet(IntPtr handle, object value);
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public void Free();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public bool get_IsAllocated();
    public static GCHandle op_Explicit(IntPtr value);
    public static GCHandle FromIntPtr(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static IntPtr ToIntPtr(GCHandle value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(GCHandle other);
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    private static IntPtr GetHandleValue(IntPtr handle);
    private static bool IsPinned(IntPtr handle);
    private static void ThrowIfInvalid(IntPtr handle);
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5149")]
public class System.Runtime.InteropServices.GuidAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public GuidAttribute(string guid);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.HandleRef : ValueType {
    private object _wrapper;
    private IntPtr _handle;
    public object Wrapper { get; }
    public IntPtr Handle { get; }
    public HandleRef(object wrapper, IntPtr handle);
    public object get_Wrapper();
    public IntPtr get_Handle();
    public static IntPtr op_Explicit(HandleRef value);
    public static IntPtr ToIntPtr(HandleRef value);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface System.Runtime.InteropServices.ICustomAdapter {
    public abstract virtual object GetUnderlyingObject();
}
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ICustomFactory {
    public abstract virtual MarshalByRefObject CreateInstance(Type serverType);
}
[NullableContextAttribute("1")]
public interface System.Runtime.InteropServices.ICustomMarshaler {
    [DynamicDependencyAttribute("GetCustomMarshalerInstance", "System.Runtime.InteropServices.Marshal")]
public abstract virtual object MarshalNativeToManaged(IntPtr pNativeData);
    public abstract virtual IntPtr MarshalManagedToNative(object ManagedObj);
    public abstract virtual void CleanUpNativeData(IntPtr pNativeData);
    public abstract virtual void CleanUpManagedData(object ManagedObj);
    public abstract virtual int GetNativeDataSize();
}
[EditorBrowsableAttribute("1")]
public interface System.Runtime.InteropServices.ICustomQueryInterface {
    public abstract virtual CustomQueryInterfaceResult GetInterface(Guid& iid, IntPtr& ppv);
}
public interface System.Runtime.InteropServices.IDynamicInterfaceCastable {
    public abstract virtual bool IsInterfaceImplemented(RuntimeTypeHandle interfaceType, bool throwIfNotImplemented);
    public abstract virtual RuntimeTypeHandle GetInterfaceImplementation(RuntimeTypeHandle interfaceType);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
}
[AttributeUsageAttribute("1024")]
public class System.Runtime.InteropServices.InterfaceTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ComInterfaceType <Value>k__BackingField;
    public ComInterfaceType Value { get; }
    public InterfaceTypeAttribute(ComInterfaceType interfaceType);
    public InterfaceTypeAttribute(short interfaceType);
    [CompilerGeneratedAttribute]
public ComInterfaceType get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidComObjectException : SystemException {
    public InvalidComObjectException(string message);
    public InvalidComObjectException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidComObjectException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.InvalidOleVariantTypeException : SystemException {
    public InvalidOleVariantTypeException(string message);
    public InvalidOleVariantTypeException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected InvalidOleVariantTypeException(SerializationInfo info, StreamingContext context);
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LCIDConversionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; }
    public LCIDConversionAttribute(int lcid);
    [CompilerGeneratedAttribute]
public int get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.LibraryImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <LibraryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private StringMarshalling <StringMarshalling>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StringMarshallingCustomType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetLastError>k__BackingField;
    [NullableAttribute("1")]
public string LibraryName { get; }
    public string EntryPoint { get; public set; }
    public StringMarshalling StringMarshalling { get; public set; }
    public Type StringMarshallingCustomType { get; public set; }
    public bool SetLastError { get; public set; }
    [NullableContextAttribute("1")]
public LibraryImportAttribute(string libraryName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_LibraryName();
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public StringMarshalling get_StringMarshalling();
    [CompilerGeneratedAttribute]
public void set_StringMarshalling(StringMarshalling value);
    [CompilerGeneratedAttribute]
public Type get_StringMarshallingCustomType();
    [CompilerGeneratedAttribute]
public void set_StringMarshallingCustomType(Type value);
    [CompilerGeneratedAttribute]
public bool get_SetLastError();
    [CompilerGeneratedAttribute]
public void set_SetLastError(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.Marshal : object {
    private static Dictionary`2<ValueTuple`2<Type, string>, ICustomMarshaler> MarshalerInstanceCache;
    public static int SystemDefaultCharSize;
    public static int SystemMaxDBCSCharSize;
    private static Marshal();
    public static int GetLastPInvokeError();
    public static void SetLastPInvokeError(int error);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available. Use the DestroyStructure<T> overload instead.")]
[EditorBrowsableAttribute("1")]
public static void DestroyStructure(IntPtr ptr, Type structuretype);
    [EditorBrowsableAttribute("1")]
public static IntPtr OffsetOf(Type t, string fieldName);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available. Use the StructureToPtr<T> overload instead.")]
[EditorBrowsableAttribute("1")]
public static void StructureToPtr(object structure, IntPtr ptr, bool fDeleteOld);
    internal static bool IsPinnable(object obj);
    private static void PrelinkCore(MethodInfo m);
    private static void PtrToStructureInternal(IntPtr ptr, object structure, bool allowValueClasses);
    private static void PtrToStructureHelper(IntPtr ptr, object structure, bool allowValueClasses);
    private static void GetDelegateForFunctionPointerInternal(QCallTypeHandle t, IntPtr ptr, ObjectHandleOnStack res);
    private static IntPtr GetFunctionPointerForDelegateInternal(Delegate d);
    private static Delegate GetDelegateForFunctionPointerInternal(IntPtr ptr, Type t);
    private static void PrelinkInternal(MethodInfo m);
    private static int SizeOfHelper(QCallTypeHandle t, bool throwIfNotMarshalable);
    private static int SizeOfHelper(Type t, bool throwIfNotMarshalable);
    public static IntPtr GetExceptionPointers();
    private static void SetInvokeArgs(String& cookie, IntPtr* params_byref);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
internal static ICustomMarshaler GetCustomMarshalerInstance(Type type, string cookie);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetExceptionCode() may be unavailable in future releases.")]
public static int GetExceptionCode();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadByte(Object, Int32) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static byte ReadByte(object ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadInt16(Object, Int32) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static short ReadInt16(object ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadInt32(Object, Int32) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static int ReadInt32(object ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadInt64(Object, Int32) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static long ReadInt64(object ptr, int ofs);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteByte(Object, Int32, Byte) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static void WriteByte(object ptr, int ofs, byte val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt16(Object, Int32, Int16) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static void WriteInt16(object ptr, int ofs, short val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt32(Object, Int32, Int32) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static void WriteInt32(object ptr, int ofs, int val);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt64(Object, Int32, Int64) may be unavailable in future releases.")]
[RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
public static void WriteInt64(object ptr, int ofs, long val);
    public static IntPtr AllocHGlobal(int cb);
    [NullableContextAttribute("2")]
public static string PtrToStringAnsi(IntPtr ptr);
    public static string PtrToStringAnsi(IntPtr ptr, int len);
    [NullableContextAttribute("2")]
public static string PtrToStringUni(IntPtr ptr);
    public static string PtrToStringUni(IntPtr ptr, int len);
    [NullableContextAttribute("2")]
public static string PtrToStringUTF8(IntPtr ptr);
    public static string PtrToStringUTF8(IntPtr ptr, int byteLen);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available. Use the SizeOf<T> overload instead.")]
[EditorBrowsableAttribute("1")]
public static int SizeOf(object structure);
    public static int SizeOf(T structure);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available. Use the SizeOf<T> overload instead.")]
[EditorBrowsableAttribute("1")]
public static int SizeOf(Type t);
    [NullableContextAttribute("2")]
public static int SizeOf();
    public static int QueryInterface(IntPtr pUnk, Guid& iid, IntPtr& ppv);
    public static int AddRef(IntPtr pUnk);
    public static int Release(IntPtr pUnk);
    [EditorBrowsableAttribute("1")]
public static IntPtr UnsafeAddrOfPinnedArrayElement(Array arr, int index);
    public static IntPtr UnsafeAddrOfPinnedArrayElement(T[] arr, int index);
    public static IntPtr OffsetOf(string fieldName);
    public static void Copy(Int32[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Char[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int16[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Int64[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Single[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Double[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(Byte[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr[] source, int startIndex, IntPtr destination, int length);
    private static void CopyToNative(T[] source, int startIndex, IntPtr destination, int length);
    public static void Copy(IntPtr source, Int32[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Char[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int16[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Int64[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Single[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Double[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, Byte[] destination, int startIndex, int length);
    public static void Copy(IntPtr source, IntPtr[] destination, int startIndex, int length);
    private static void CopyToManaged(IntPtr source, T[] destination, int startIndex, int length);
    public static byte ReadByte(IntPtr ptr, int ofs);
    public static byte ReadByte(IntPtr ptr);
    public static short ReadInt16(IntPtr ptr, int ofs);
    public static short ReadInt16(IntPtr ptr);
    public static int ReadInt32(IntPtr ptr, int ofs);
    public static int ReadInt32(IntPtr ptr);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ReadIntPtr(Object, Int32) may be unavailable in future releases.")]
public static IntPtr ReadIntPtr(object ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr, int ofs);
    public static IntPtr ReadIntPtr(IntPtr ptr);
    public static long ReadInt64(IntPtr ptr, int ofs);
    public static long ReadInt64(IntPtr ptr);
    public static void WriteByte(IntPtr ptr, int ofs, byte val);
    public static void WriteByte(IntPtr ptr, byte val);
    public static void WriteInt16(IntPtr ptr, int ofs, short val);
    public static void WriteInt16(IntPtr ptr, short val);
    public static void WriteInt16(IntPtr ptr, int ofs, char val);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteInt16(Object, Int32, Char) may be unavailable in future releases.")]
public static void WriteInt16(object ptr, int ofs, char val);
    public static void WriteInt16(IntPtr ptr, char val);
    public static void WriteInt32(IntPtr ptr, int ofs, int val);
    public static void WriteInt32(IntPtr ptr, int val);
    public static void WriteIntPtr(IntPtr ptr, int ofs, IntPtr val);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("WriteIntPtr(Object, Int32, IntPtr) may be unavailable in future releases.")]
public static void WriteIntPtr(object ptr, int ofs, IntPtr val);
    public static void WriteIntPtr(IntPtr ptr, IntPtr val);
    public static void WriteInt64(IntPtr ptr, int ofs, long val);
    public static void WriteInt64(IntPtr ptr, long val);
    public static void Prelink(MethodInfo m);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern")]
public static void PrelinkAll(Type c);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
public static void StructureToPtr(T structure, IntPtr ptr, bool fDeleteOld);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
[EditorBrowsableAttribute("1")]
public static object PtrToStructure(IntPtr ptr, Type structureType);
    [RequiresDynamicCodeAttribute("Marshalling code for the object might not be available")]
[EditorBrowsableAttribute("1")]
public static void PtrToStructure(IntPtr ptr, object structure);
    public static void PtrToStructure(IntPtr ptr, T structure);
    [NullableContextAttribute("2")]
public static T PtrToStructure(IntPtr ptr);
    [NullableContextAttribute("2")]
[UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
public static void DestroyStructure(IntPtr ptr);
    [RequiresAssemblyFilesAttribute("Windows only assigns HINSTANCE to assemblies loaded from disk. This API will return -1 for modules without a file on disk.")]
public static IntPtr GetHINSTANCE(Module m);
    [NullableContextAttribute("2")]
public static Exception GetExceptionForHR(int errorCode);
    [NullableContextAttribute("2")]
public static Exception GetExceptionForHR(int errorCode, IntPtr errorInfo);
    private static Exception GetExceptionForHRInternal(int errorCode, IntPtr errorInfo);
    public static void ThrowExceptionForHR(int errorCode);
    public static void ThrowExceptionForHR(int errorCode, IntPtr errorInfo);
    public static IntPtr SecureStringToBSTR(SecureString s);
    public static IntPtr SecureStringToCoTaskMemAnsi(SecureString s);
    public static IntPtr SecureStringToCoTaskMemUnicode(SecureString s);
    public static IntPtr SecureStringToGlobalAllocAnsi(SecureString s);
    public static IntPtr SecureStringToGlobalAllocUnicode(SecureString s);
    [NullableContextAttribute("2")]
public static IntPtr StringToHGlobalAnsi(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToHGlobalUni(string s);
    private static IntPtr StringToHGlobalUTF8(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemUni(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemUTF8(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemAnsi(string s);
    public static Guid GenerateGuidForType(Type type);
    public static string GenerateProgIdForType(Type type);
    [RequiresDynamicCodeAttribute("Marshalling code for the delegate might not be available. Use the GetDelegateForFunctionPointer<TDelegate> overload instead.")]
[EditorBrowsableAttribute("1")]
public static Delegate GetDelegateForFunctionPointer(IntPtr ptr, Type t);
    public static TDelegate GetDelegateForFunctionPointer(IntPtr ptr);
    [RequiresDynamicCodeAttribute("Marshalling code for the delegate might not be available. Use the GetFunctionPointerForDelegate<TDelegate> overload instead.")]
[EditorBrowsableAttribute("1")]
public static IntPtr GetFunctionPointerForDelegate(Delegate d);
    [UnconditionalSuppressMessageAttribute("AotAnalysis", "IL3050:AotUnfriendlyApi")]
public static IntPtr GetFunctionPointerForDelegate(TDelegate d);
    public static int GetHRForLastWin32Error();
    public static void ZeroFreeBSTR(IntPtr s);
    public static void ZeroFreeCoTaskMemAnsi(IntPtr s);
    public static void ZeroFreeCoTaskMemUnicode(IntPtr s);
    public static void ZeroFreeCoTaskMemUTF8(IntPtr s);
    public static void ZeroFreeGlobalAllocAnsi(IntPtr s);
    public static void ZeroFreeGlobalAllocUnicode(IntPtr s);
    [NullableContextAttribute("2")]
public static IntPtr StringToBSTR(string s);
    public static string PtrToStringBSTR(IntPtr ptr);
    internal static UInt32 SysStringByteLen(IntPtr s);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid);
    public static void InitHandle(SafeHandle safeHandle, IntPtr handle);
    public static int GetLastWin32Error();
    public static string GetLastPInvokeErrorMessage();
    [NullableContextAttribute("2")]
public static int GetHRForException(Exception e);
    public static bool AreComObjectsAvailableForCleanup();
    [SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static IntPtr CreateAggregatedObject(IntPtr pOuter, object o);
    [RequiresUnreferencedCodeAttribute("Built-in COM support is not trim compatible")]
[SupportedOSPlatformAttribute("windows")]
public static object BindToMoniker(string monikerName);
    public static void CleanupUnusedObjectsInCurrentContext();
    [SupportedOSPlatformAttribute("windows")]
public static IntPtr CreateAggregatedObject(IntPtr pOuter, T o);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static object CreateWrapperOfType(object o, Type t);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static TWrapper CreateWrapperOfType(T o);
    [SupportedOSPlatformAttribute("windows")]
public static void ChangeWrapperHandleStrength(object otp, bool fIsWeak);
    [SupportedOSPlatformAttribute("windows")]
public static int FinalReleaseComObject(object o);
    [SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static IntPtr GetComInterfaceForObject(object o, Type T);
    [SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static IntPtr GetComInterfaceForObject(object o, Type T, CustomQueryInterfaceMode mode);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static IntPtr GetComInterfaceForObject(T o);
    [SupportedOSPlatformAttribute("windows")]
public static object GetComObjectData(object obj, object key);
    [SupportedOSPlatformAttribute("windows")]
public static IntPtr GetIDispatchForObject(object o);
    [SupportedOSPlatformAttribute("windows")]
public static IntPtr GetIUnknownForObject(object o);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static void GetNativeVariantForObject(object obj, IntPtr pDstNativeVariant);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static void GetNativeVariantForObject(T obj, IntPtr pDstNativeVariant);
    [SupportedOSPlatformAttribute("windows")]
public static object GetTypedObjectForIUnknown(IntPtr pUnk, Type t);
    [SupportedOSPlatformAttribute("windows")]
public static object GetObjectForIUnknown(IntPtr pUnk);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static object GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static T GetObjectForNativeVariant(IntPtr pSrcNativeVariant);
    [SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static Object[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    [SupportedOSPlatformAttribute("windows")]
[EditorBrowsableAttribute("1")]
public static T[] GetObjectsForNativeVariants(IntPtr aSrcNativeVariant, int cVars);
    [SupportedOSPlatformAttribute("windows")]
public static int GetStartComSlot(Type t);
    [SupportedOSPlatformAttribute("windows")]
public static int GetEndComSlot(Type t);
    internal static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    [SupportedOSPlatformAttribute("windows")]
public static string GetTypeInfoName(ITypeInfo typeInfo);
    [SupportedOSPlatformAttribute("windows")]
public static object GetUniqueObjectForIUnknown(IntPtr unknown);
    public static bool IsComObject(object o);
    public static bool IsTypeVisibleFromCom(Type t);
    [SupportedOSPlatformAttribute("windows")]
public static int ReleaseComObject(object o);
    [SupportedOSPlatformAttribute("windows")]
public static bool SetComObjectData(object obj, object key, object data);
    [NullableContextAttribute("2")]
public static string PtrToStringAuto(IntPtr ptr, int len);
    [NullableContextAttribute("2")]
public static string PtrToStringAuto(IntPtr ptr);
    [NullableContextAttribute("2")]
public static IntPtr StringToHGlobalAuto(string s);
    [NullableContextAttribute("2")]
public static IntPtr StringToCoTaskMemAuto(string s);
    private static bool IsNullOrWin32Atom(IntPtr ptr);
    internal static int StringToAnsiString(string s, Byte* buffer, int bufferLength, bool bestFit, bool throwOnUnmappableChar);
    internal static int GetAnsiStringByteCount(ReadOnlySpan`1<char> chars);
    internal static void GetAnsiStringBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public static IntPtr AllocHGlobal(IntPtr cb);
    public static void FreeHGlobal(IntPtr hglobal);
    public static IntPtr ReAllocHGlobal(IntPtr pv, IntPtr cb);
    public static IntPtr AllocCoTaskMem(int cb);
    public static void FreeCoTaskMem(IntPtr ptr);
    public static IntPtr ReAllocCoTaskMem(IntPtr pv, int cb);
    internal static IntPtr AllocBSTR(int length);
    internal static IntPtr AllocBSTRByteLen(UInt32 length);
    public static void FreeBSTR(IntPtr ptr);
    internal static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    public static int GetLastSystemError();
    public static void SetLastSystemError(int error);
    public static string GetPInvokeErrorMessage(int error);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10496")]
public class System.Runtime.InteropServices.MarshalAsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private UnmanagedType <Value>k__BackingField;
    public VarEnum SafeArraySubType;
    public Type SafeArrayUserDefinedSubType;
    public int IidParameterIndex;
    public UnmanagedType ArraySubType;
    public short SizeParamIndex;
    public int SizeConst;
    public string MarshalType;
    public Type MarshalTypeRef;
    public string MarshalCookie;
    public UnmanagedType Value { get; }
    public MarshalAsAttribute(UnmanagedType unmanagedType);
    public MarshalAsAttribute(short unmanagedType);
    internal object CloneInternal();
    [CompilerGeneratedAttribute]
public UnmanagedType get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.MarshalDirectiveException : SystemException {
    public MarshalDirectiveException(string message);
    public MarshalDirectiveException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected MarshalDirectiveException(SerializationInfo info, StreamingContext context);
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.String", "0", "System.Runtime.InteropServices.Marshalling.AnsiStringMarshaller")]
[CustomMarshallerAttribute("System.String", "1", "System.Runtime.InteropServices.Marshalling.AnsiStringMarshaller/ManagedToUnmanagedIn")]
public static class System.Runtime.InteropServices.Marshalling.AnsiStringMarshaller : object {
    public static Byte* ConvertToUnmanaged(string managed);
    public static string ConvertToManaged(Byte* unmanaged);
    public static void Free(Byte* unmanaged);
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder[]", "0", "System.Runtime.InteropServices.Marshalling.ArrayMarshaller`2")]
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder[]", "1", "System.Runtime.InteropServices.Marshalling.ArrayMarshaller`2/ManagedToUnmanagedIn")]
[ContiguousCollectionMarshallerAttribute]
public static class System.Runtime.InteropServices.Marshalling.ArrayMarshaller`2 : object {
    public static TUnmanagedElement* AllocateContainerForUnmanagedElements(T[] managed, Int32& numElements);
    public static ReadOnlySpan`1<T> GetManagedValuesSource(T[] managed);
    public static Span`1<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements);
    public static T[] AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements);
    public static Span`1<T> GetManagedValuesDestination(T[] managed);
    public static ReadOnlySpan`1<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanagedValue, int numElements);
    public static void Free(TUnmanagedElement* unmanaged);
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.String", "0", "System.Runtime.InteropServices.Marshalling.BStrStringMarshaller")]
[CustomMarshallerAttribute("System.String", "1", "System.Runtime.InteropServices.Marshalling.BStrStringMarshaller/ManagedToUnmanagedIn")]
public static class System.Runtime.InteropServices.Marshalling.BStrStringMarshaller : object {
    public static UInt16* ConvertToUnmanaged(string managed);
    public static string ConvertToManaged(UInt16* unmanaged);
    public static void Free(UInt16* unmanaged);
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.Marshalling.ContiguousCollectionMarshallerAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ManagedType>k__BackingField;
    [CompilerGeneratedAttribute]
private MarshalMode <MarshalMode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MarshallerType>k__BackingField;
    public Type ManagedType { get; }
    public MarshalMode MarshalMode { get; }
    public Type MarshallerType { get; }
    public CustomMarshallerAttribute(Type managedType, MarshalMode marshalMode, Type marshallerType);
    [CompilerGeneratedAttribute]
public Type get_ManagedType();
    [CompilerGeneratedAttribute]
public MarshalMode get_MarshalMode();
    [CompilerGeneratedAttribute]
public Type get_MarshallerType();
}
public enum System.Runtime.InteropServices.Marshalling.MarshalMode : Enum {
    public int value__;
    public static MarshalMode Default;
    public static MarshalMode ManagedToUnmanagedIn;
    public static MarshalMode ManagedToUnmanagedRef;
    public static MarshalMode ManagedToUnmanagedOut;
    public static MarshalMode UnmanagedToManagedIn;
    public static MarshalMode UnmanagedToManagedRef;
    public static MarshalMode UnmanagedToManagedOut;
    public static MarshalMode ElementIn;
    public static MarshalMode ElementRef;
    public static MarshalMode ElementOut;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10240")]
public class System.Runtime.InteropServices.Marshalling.MarshalUsingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <NativeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConstantElementCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ElementIndirectionDepth>k__BackingField;
    public static string ReturnsCountValue;
    [NullableAttribute("2")]
public Type NativeType { get; }
    public string CountElementName { get; public set; }
    public int ConstantElementCount { get; public set; }
    public int ElementIndirectionDepth { get; public set; }
    public MarshalUsingAttribute(Type nativeType);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_NativeType();
    [CompilerGeneratedAttribute]
public string get_CountElementName();
    [CompilerGeneratedAttribute]
public void set_CountElementName(string value);
    [CompilerGeneratedAttribute]
public int get_ConstantElementCount();
    [CompilerGeneratedAttribute]
public void set_ConstantElementCount(int value);
    [CompilerGeneratedAttribute]
public int get_ElementIndirectionDepth();
    [CompilerGeneratedAttribute]
public void set_ElementIndirectionDepth(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5148")]
public class System.Runtime.InteropServices.Marshalling.NativeMarshallingAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <NativeType>k__BackingField;
    public Type NativeType { get; }
    public NativeMarshallingAttribute(Type nativeType);
    [CompilerGeneratedAttribute]
public Type get_NativeType();
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder*[]", "0", "System.Runtime.InteropServices.Marshalling.PointerArrayMarshaller`2")]
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder*[]", "1", "System.Runtime.InteropServices.Marshalling.PointerArrayMarshaller`2/ManagedToUnmanagedIn")]
[ContiguousCollectionMarshallerAttribute]
public static class System.Runtime.InteropServices.Marshalling.PointerArrayMarshaller`2 : object {
    public static TUnmanagedElement* AllocateContainerForUnmanagedElements(T*[] managed, Int32& numElements);
    public static ReadOnlySpan`1<IntPtr> GetManagedValuesSource(T*[] managed);
    public static Span`1<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements);
    public static T*[] AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements);
    public static Span`1<IntPtr> GetManagedValuesDestination(T*[] managed);
    public static ReadOnlySpan`1<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanagedValue, int numElements);
    public static void Free(TUnmanagedElement* unmanaged);
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.ReadOnlySpan`1", "1", "System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2/ManagedToUnmanagedIn")]
[CustomMarshallerAttribute("System.ReadOnlySpan`1", "6", "System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2/UnmanagedToManagedOut")]
[ContiguousCollectionMarshallerAttribute]
public static class System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2 : object {
}
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder", "1", "System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller`1/ManagedToUnmanagedIn")]
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder", "2", "System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller`1/ManagedToUnmanagedRef")]
[CustomMarshallerAttribute("System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute/GenericPlaceholder", "3", "System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller`1/ManagedToUnmanagedOut")]
public static class System.Runtime.InteropServices.Marshalling.SafeHandleMarshaller`1 : object {
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.Span`1", "0", "System.Runtime.InteropServices.Marshalling.SpanMarshaller`2")]
[CustomMarshallerAttribute("System.Span`1", "1", "System.Runtime.InteropServices.Marshalling.SpanMarshaller`2/ManagedToUnmanagedIn")]
[ContiguousCollectionMarshallerAttribute]
public static class System.Runtime.InteropServices.Marshalling.SpanMarshaller`2 : object {
    public static TUnmanagedElement* AllocateContainerForUnmanagedElements(Span`1<T> managed, Int32& numElements);
    public static ReadOnlySpan`1<T> GetManagedValuesSource(Span`1<T> managed);
    public static Span`1<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements);
    public static Span`1<T> AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements);
    public static Span`1<T> GetManagedValuesDestination(Span`1<T> managed);
    public static ReadOnlySpan`1<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanaged, int numElements);
    public static void Free(TUnmanagedElement* unmanaged);
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.String", "0", "System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller")]
public static class System.Runtime.InteropServices.Marshalling.Utf16StringMarshaller : object {
    public static UInt16* ConvertToUnmanaged(string managed);
    public static string ConvertToManaged(UInt16* unmanaged);
    public static void Free(UInt16* unmanaged);
    [NullableContextAttribute("2")]
public static Char& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference(string str);
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.String", "0", "System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller")]
[CustomMarshallerAttribute("System.String", "1", "System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller/ManagedToUnmanagedIn")]
public static class System.Runtime.InteropServices.Marshalling.Utf8StringMarshaller : object {
    public static Byte* ConvertToUnmanaged(string managed);
    public static string ConvertToManaged(Byte* unmanaged);
    public static void Free(Byte* unmanaged);
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static T& GetArrayDataReference(T[] array);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Byte& GetArrayDataReference(Array array);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    [NullableContextAttribute("1")]
public static T& GetReference(Span`1<T> span);
    [NullableContextAttribute("1")]
public static T& GetReference(ReadOnlySpan`1<T> span);
    internal static T& GetNonNullPinnableReference(Span`1<T> span);
    internal static T& GetNonNullPinnableReference(ReadOnlySpan`1<T> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    [NullableContextAttribute("1")]
public static Span`1<T> CreateSpan(T& reference, int length);
    [NullableContextAttribute("1")]
public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
    [CLSCompliantAttribute("False")]
public static ReadOnlySpan`1<char> CreateReadOnlySpanFromNullTerminated(Char* value);
    [CLSCompliantAttribute("False")]
public static ReadOnlySpan`1<byte> CreateReadOnlySpanFromNullTerminated(Byte* value);
    [NullableContextAttribute("2")]
public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    [NullableContextAttribute("1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static T Read(ReadOnlySpan`1<byte> source);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static void Write(Span`1<byte> destination, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static T& AsRef(Span`1<byte> span);
    public static T& modreq(System.Runtime.InteropServices.InAttribute) AsRef(ReadOnlySpan`1<byte> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<<ToEnumerable>g__FromString|18_0>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<char> <ToEnumerable>g__FromString|18_0(string s, int offset, int count);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<<ToEnumerable>g__FromArray|18_2>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<T> <ToEnumerable>g__FromArray|18_2(T[] array, int offset, int count);
    [IteratorStateMachineAttribute("System.Runtime.InteropServices.MemoryMarshal/<<ToEnumerable>g__FromMemoryManager|18_1>d`1")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<T> <ToEnumerable>g__FromMemoryManager|18_1(ReadOnlyMemory`1<T> memory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.NativeLibrary : object {
    private static ConditionalWeakTable`2<Assembly, DllImportResolver> s_nativeDllResolveMap;
    private static IntPtr LoadLibraryByName(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath, bool throwOnError);
    private static IntPtr LoadFromPath(string libraryName, bool throwOnError);
    private static IntPtr LoadByName(string libraryName, RuntimeAssembly callingAssembly, bool hasDllImportSearchPathFlag, UInt32 dllImportSearchPathFlag, bool throwOnError);
    private static void FreeLib(IntPtr handle);
    private static IntPtr GetSymbol(IntPtr handle, string symbolName, bool throwOnError);
    private static void MonoLoadLibraryCallbackStub(string libraryName, Assembly assembly, bool hasDllImportSearchPathFlags, UInt32 dllImportSearchPathFlags, IntPtr& dll);
    public static IntPtr Load(string libraryPath);
    public static bool TryLoad(string libraryPath, IntPtr& handle);
    public static IntPtr Load(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath);
    public static bool TryLoad(string libraryName, Assembly assembly, Nullable`1<DllImportSearchPath> searchPath, IntPtr& handle);
    public static void Free(IntPtr handle);
    public static IntPtr GetExport(IntPtr handle, string name);
    public static bool TryGetExport(IntPtr handle, string name, IntPtr& address);
    public static void SetDllImportResolver(Assembly assembly, DllImportResolver resolver);
    internal static IntPtr LoadLibraryCallbackStub(string libraryName, Assembly assembly, bool hasDllImportSearchPathFlags, UInt32 dllImportSearchPathFlags);
    public static IntPtr GetMainProgramHandle();
}
public static class System.Runtime.InteropServices.NativeMemory : object {
    [CLSCompliantAttribute("False")]
public static Void* Alloc(UIntPtr elementCount, UIntPtr elementSize);
    [CLSCompliantAttribute("False")]
public static Void* AllocZeroed(UIntPtr byteCount);
    [CLSCompliantAttribute("False")]
public static void Clear(Void* ptr, UIntPtr byteCount);
    [CLSCompliantAttribute("False")]
public static void Copy(Void* source, Void* destination, UIntPtr byteCount);
    [CLSCompliantAttribute("False")]
public static void Fill(Void* ptr, UIntPtr byteCount, byte value);
    private static UIntPtr GetByteCount(UIntPtr elementCount, UIntPtr elementSize);
    [CLSCompliantAttribute("False")]
public static Void* AlignedAlloc(UIntPtr byteCount, UIntPtr alignment);
    [CLSCompliantAttribute("False")]
public static void AlignedFree(Void* ptr);
    [CLSCompliantAttribute("False")]
public static Void* AlignedRealloc(Void* ptr, UIntPtr byteCount, UIntPtr alignment);
    [CLSCompliantAttribute("False")]
public static Void* Alloc(UIntPtr byteCount);
    [CLSCompliantAttribute("False")]
public static Void* AllocZeroed(UIntPtr elementCount, UIntPtr elementSize);
    [CLSCompliantAttribute("False")]
public static void Free(Void* ptr);
    [CLSCompliantAttribute("False")]
public static Void* Realloc(Void* ptr, UIntPtr byteCount);
}
[IsReadOnlyAttribute]
[IntrinsicAttribute]
[NonVersionableAttribute]
public class System.Runtime.InteropServices.NFloat : ValueType {
    private double _value;
    public static NFloat Epsilon { get; }
    public static NFloat MaxValue { get; }
    public static NFloat MinValue { get; }
    public static NFloat NaN { get; }
    public static NFloat NegativeInfinity { get; }
    public static NFloat PositiveInfinity { get; }
    public static int Size { get; }
    public double Value { get; }
    private static NFloat System.Numerics.IAdditiveIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.AdditiveIdentity { get; }
    private static NFloat System.Numerics.IBinaryNumber<System.Runtime.InteropServices.NFloat>.AllBitsSet { get; }
    public static NFloat E { get; }
    public static NFloat Pi { get; }
    public static NFloat Tau { get; }
    public static NFloat NegativeZero { get; }
    private static NFloat System.Numerics.IMultiplicativeIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.MultiplicativeIdentity { get; }
    private static NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.One { get; }
    private static int System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.Radix { get; }
    private static NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.Zero { get; }
    private static NFloat System.Numerics.ISignedNumber<System.Runtime.InteropServices.NFloat>.NegativeOne { get; }
    [NonVersionableAttribute]
public NFloat(float value);
    [NonVersionableAttribute]
public NFloat(double value);
    [NonVersionableAttribute]
public static override NFloat get_Epsilon();
    [NonVersionableAttribute]
public static override NFloat get_MaxValue();
    [NonVersionableAttribute]
public static override NFloat get_MinValue();
    [NonVersionableAttribute]
public static override NFloat get_NaN();
    [NonVersionableAttribute]
public static override NFloat get_NegativeInfinity();
    [NonVersionableAttribute]
public static override NFloat get_PositiveInfinity();
    [NonVersionableAttribute]
public static int get_Size();
    [NonVersionableAttribute]
public double get_Value();
    [NonVersionableAttribute]
public static override NFloat op_UnaryPlus(NFloat value);
    [NonVersionableAttribute]
public static override NFloat op_UnaryNegation(NFloat value);
    [NonVersionableAttribute]
public static override NFloat op_Increment(NFloat value);
    [NonVersionableAttribute]
public static override NFloat op_Decrement(NFloat value);
    [NonVersionableAttribute]
public static override NFloat op_Addition(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override NFloat op_Subtraction(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override NFloat op_Multiply(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override NFloat op_Division(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override NFloat op_Modulus(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override bool op_Equality(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override bool op_Inequality(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override bool op_LessThan(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override bool op_LessThanOrEqual(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override bool op_GreaterThan(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static override bool op_GreaterThanOrEqual(NFloat left, NFloat right);
    [NonVersionableAttribute]
public static NFloat op_Explicit(decimal value);
    [NonVersionableAttribute]
public static NFloat op_Explicit(double value);
    [NonVersionableAttribute]
public static byte op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static byte op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static char op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static char op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static decimal op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static Half op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static short op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static short op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static int op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static int op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static long op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static long op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static Int128 op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static Int128 op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static IntPtr op_Explicit(NFloat value);
    [NonVersionableAttribute]
public static IntPtr op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static float op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ushort op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(NFloat value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(NFloat value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(byte value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(char value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(Half value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(short value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(int value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(long value);
    [NonVersionableAttribute]
public static NFloat op_Explicit(Int128 value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(IntPtr value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static NFloat op_Implicit(sbyte value);
    [NonVersionableAttribute]
public static NFloat op_Implicit(float value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static NFloat op_Implicit(ushort value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static NFloat op_Implicit(UInt32 value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static NFloat op_Implicit(ulong value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static NFloat op_Explicit(UInt128 value);
    [NonVersionableAttribute]
[CLSCompliantAttribute("False")]
public static NFloat op_Implicit(UIntPtr value);
    public static double op_Implicit(NFloat value);
    [NonVersionableAttribute]
public static override bool IsFinite(NFloat value);
    [NonVersionableAttribute]
public static override bool IsInfinity(NFloat value);
    [NonVersionableAttribute]
public static override bool IsNaN(NFloat value);
    [NonVersionableAttribute]
public static override bool IsNegative(NFloat value);
    [NonVersionableAttribute]
public static override bool IsNegativeInfinity(NFloat value);
    [NonVersionableAttribute]
public static override bool IsNormal(NFloat value);
    [NonVersionableAttribute]
public static override bool IsPositiveInfinity(NFloat value);
    [NonVersionableAttribute]
public static override bool IsSubnormal(NFloat value);
    [NullableContextAttribute("1")]
public static NFloat Parse(string s);
    [NullableContextAttribute("1")]
public static NFloat Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override NFloat Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override NFloat Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override NFloat Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, NFloat& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, NFloat& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, NFloat& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, NFloat& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, NFloat& result);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(NFloat other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NFloat other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private static override NFloat System.Numerics.IAdditiveIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.get_AdditiveIdentity();
    [NonVersionableAttribute]
private static override NFloat System.Numerics.IBinaryNumber<System.Runtime.InteropServices.NFloat>.get_AllBitsSet();
    public static override bool IsPow2(NFloat value);
    public static override NFloat Log2(NFloat value);
    private static override NFloat System.Numerics.IBitwiseOperators<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.op_BitwiseAnd(NFloat left, NFloat right);
    private static override NFloat System.Numerics.IBitwiseOperators<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.op_BitwiseOr(NFloat left, NFloat right);
    private static override NFloat System.Numerics.IBitwiseOperators<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.op_ExclusiveOr(NFloat left, NFloat right);
    private static override NFloat System.Numerics.IBitwiseOperators<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.op_OnesComplement(NFloat value);
    public static override NFloat Exp(NFloat x);
    public static override NFloat ExpM1(NFloat x);
    public static override NFloat Exp2(NFloat x);
    public static override NFloat Exp2M1(NFloat x);
    public static override NFloat Exp10(NFloat x);
    public static override NFloat Exp10M1(NFloat x);
    public static override NFloat Ceiling(NFloat x);
    public static override NFloat Floor(NFloat x);
    public static override NFloat Round(NFloat x);
    public static override NFloat Round(NFloat x, int digits);
    public static override NFloat Round(NFloat x, MidpointRounding mode);
    public static override NFloat Round(NFloat x, int digits, MidpointRounding mode);
    public static override NFloat Truncate(NFloat x);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.GetSignificandByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.GetSignificandBitLength();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Runtime.InteropServices.NFloat>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    public static override NFloat get_E();
    public static override NFloat get_Pi();
    public static override NFloat get_Tau();
    public static override NFloat get_NegativeZero();
    public static override NFloat Atan2(NFloat y, NFloat x);
    public static override NFloat Atan2Pi(NFloat y, NFloat x);
    public static override NFloat BitDecrement(NFloat x);
    public static override NFloat BitIncrement(NFloat x);
    public static override NFloat FusedMultiplyAdd(NFloat left, NFloat right, NFloat addend);
    public static override NFloat Ieee754Remainder(NFloat left, NFloat right);
    public static override int ILogB(NFloat x);
    public static override NFloat Lerp(NFloat value1, NFloat value2, NFloat amount);
    public static override NFloat ReciprocalEstimate(NFloat x);
    public static override NFloat ReciprocalSqrtEstimate(NFloat x);
    public static override NFloat ScaleB(NFloat x, int n);
    public static override NFloat Acosh(NFloat x);
    public static override NFloat Asinh(NFloat x);
    public static override NFloat Atanh(NFloat x);
    public static override NFloat Cosh(NFloat x);
    public static override NFloat Sinh(NFloat x);
    public static override NFloat Tanh(NFloat x);
    public static override NFloat Log(NFloat x);
    public static override NFloat Log(NFloat x, NFloat newBase);
    public static override NFloat LogP1(NFloat x);
    public static override NFloat Log2P1(NFloat x);
    public static override NFloat Log10(NFloat x);
    public static override NFloat Log10P1(NFloat x);
    private static override NFloat System.Numerics.IMultiplicativeIdentity<System.Runtime.InteropServices.NFloat,System.Runtime.InteropServices.NFloat>.get_MultiplicativeIdentity();
    public static override NFloat Clamp(NFloat value, NFloat min, NFloat max);
    public static override NFloat CopySign(NFloat value, NFloat sign);
    public static override NFloat Max(NFloat x, NFloat y);
    public static override NFloat MaxNumber(NFloat x, NFloat y);
    public static override NFloat Min(NFloat x, NFloat y);
    public static override NFloat MinNumber(NFloat x, NFloat y);
    public static override int Sign(NFloat value);
    private static override NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.get_One();
    private static override int System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.get_Radix();
    private static override NFloat System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.get_Zero();
    public static override NFloat Abs(NFloat value);
    [NullableContextAttribute("1")]
public static override NFloat CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override NFloat CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override NFloat CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.IsCanonical(NFloat value);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.IsComplexNumber(NFloat value);
    public static override bool IsEvenInteger(NFloat value);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.IsImaginaryNumber(NFloat value);
    public static override bool IsInteger(NFloat value);
    public static override bool IsOddInteger(NFloat value);
    public static override bool IsPositive(NFloat value);
    public static override bool IsRealNumber(NFloat value);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.IsZero(NFloat value);
    public static override NFloat MaxMagnitude(NFloat x, NFloat y);
    public static override NFloat MaxMagnitudeNumber(NFloat x, NFloat y);
    public static override NFloat MinMagnitude(NFloat x, NFloat y);
    public static override NFloat MinMagnitudeNumber(NFloat x, NFloat y);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.TryConvertFromChecked(TOther value, NFloat& result);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.TryConvertFromSaturating(TOther value, NFloat& result);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.TryConvertFromTruncating(TOther value, NFloat& result);
    private static bool TryConvertFrom(TOther value, NFloat& result);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.TryConvertToChecked(NFloat value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.TryConvertToSaturating(NFloat value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Runtime.InteropServices.NFloat>.TryConvertToTruncating(NFloat value, TOther& result);
    private static bool TryConvertTo(NFloat value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, NFloat& result);
    public static override NFloat Pow(NFloat x, NFloat y);
    public static override NFloat Cbrt(NFloat x);
    public static override NFloat Hypot(NFloat x, NFloat y);
    public static override NFloat RootN(NFloat x, int n);
    public static override NFloat Sqrt(NFloat x);
    private static override NFloat System.Numerics.ISignedNumber<System.Runtime.InteropServices.NFloat>.get_NegativeOne();
    public static override NFloat Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, NFloat& result);
    public static override NFloat Acos(NFloat x);
    public static override NFloat AcosPi(NFloat x);
    public static override NFloat Asin(NFloat x);
    public static override NFloat AsinPi(NFloat x);
    public static override NFloat Atan(NFloat x);
    public static override NFloat AtanPi(NFloat x);
    public static override NFloat Cos(NFloat x);
    public static override NFloat CosPi(NFloat x);
    public static override NFloat DegreesToRadians(NFloat degrees);
    public static override NFloat RadiansToDegrees(NFloat radians);
    public static override NFloat Sin(NFloat x);
    public static override ValueTuple`2<NFloat, NFloat> SinCos(NFloat x);
    public static override ValueTuple`2<NFloat, NFloat> SinCosPi(NFloat x);
    public static override NFloat SinPi(NFloat x);
    public static override NFloat Tan(NFloat x);
    public static override NFloat TanPi(NFloat x);
    public static override NFloat Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, NFloat& result);
    public static override NFloat Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, NFloat& result);
}
[SupportedOSPlatformAttribute("macos")]
[CLSCompliantAttribute("False")]
public static class System.Runtime.InteropServices.ObjectiveC.ObjectiveCMarshal : object {
    public static void Initialize(method beginEndCallback, method isReferencedCallback, method trackedObjectEnteredFinalization, UnhandledExceptionPropagationHandler unhandledExceptionPropagationHandler);
    public static GCHandle CreateReferenceTrackingHandle(object obj, Span`1& taggedMemory);
    public static void SetMessageSendCallback(MessageSendFunction msgSendFunction, IntPtr func);
    [NullableContextAttribute("2")]
public static void SetMessageSendPendingException(Exception exception);
}
[SupportedOSPlatformAttribute("macos")]
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ObjectiveC.ObjectiveCTrackedTypeAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OptionalAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.OSPlatform : ValueType {
    [CompilerGeneratedAttribute]
private static OSPlatform <FreeBSD>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <Linux>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <OSX>k__BackingField;
    [CompilerGeneratedAttribute]
private static OSPlatform <Windows>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static OSPlatform FreeBSD { get; }
    public static OSPlatform Linux { get; }
    public static OSPlatform OSX { get; }
    public static OSPlatform Windows { get; }
    internal string Name { get; }
    private OSPlatform(string osPlatform);
    private static OSPlatform();
    [CompilerGeneratedAttribute]
public static OSPlatform get_FreeBSD();
    [CompilerGeneratedAttribute]
public static OSPlatform get_Linux();
    [CompilerGeneratedAttribute]
public static OSPlatform get_OSX();
    [CompilerGeneratedAttribute]
public static OSPlatform get_Windows();
    [CompilerGeneratedAttribute]
internal string get_Name();
    public static OSPlatform Create(string osPlatform);
    public sealed virtual bool Equals(OSPlatform other);
    internal bool Equals(string other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OSPlatform left, OSPlatform right);
    public static bool op_Inequality(OSPlatform left, OSPlatform right);
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
public enum System.Runtime.InteropServices.PosixSignal : Enum {
    public int value__;
    public static PosixSignal SIGHUP;
    public static PosixSignal SIGINT;
    public static PosixSignal SIGQUIT;
    public static PosixSignal SIGTERM;
    [UnsupportedOSPlatformAttribute("windows")]
public static PosixSignal SIGCHLD;
    [UnsupportedOSPlatformAttribute("windows")]
public static PosixSignal SIGCONT;
    [UnsupportedOSPlatformAttribute("windows")]
public static PosixSignal SIGWINCH;
    [UnsupportedOSPlatformAttribute("windows")]
public static PosixSignal SIGTTIN;
    [UnsupportedOSPlatformAttribute("windows")]
public static PosixSignal SIGTTOU;
    [UnsupportedOSPlatformAttribute("windows")]
public static PosixSignal SIGTSTP;
}
public class System.Runtime.InteropServices.PosixSignalContext : object {
    [CompilerGeneratedAttribute]
private PosixSignal <Signal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cancel>k__BackingField;
    public PosixSignal Signal { get; internal set; }
    public bool Cancel { get; public set; }
    public PosixSignalContext(PosixSignal signal);
    [CompilerGeneratedAttribute]
public PosixSignal get_Signal();
    [CompilerGeneratedAttribute]
internal void set_Signal(PosixSignal value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class System.Runtime.InteropServices.PosixSignalRegistration : object {
    private Token _token;
    private PosixSignalRegistration(Token token);
    [NullableContextAttribute("1")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public static PosixSignalRegistration Create(PosixSignal signal, Action`1<PosixSignalContext> handler);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    [DynamicDependencyAttribute("#ctor")]
private static PosixSignalRegistration Register(PosixSignal signal, Action`1<PosixSignalContext> handler);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.PreserveSigAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class System.Runtime.InteropServices.ProgIdAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public ProgIdAttribute(string progId);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.RuntimeInformation : object {
    private static string s_frameworkDescription;
    private static string s_runtimeIdentifier;
    private static string s_osDescription;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) s_osArchPlusOne;
    public static string FrameworkDescription { get; }
    public static string RuntimeIdentifier { get; }
    public static Architecture ProcessArchitecture { get; }
    public static string OSDescription { get; }
    public static Architecture OSArchitecture { get; }
    public static string get_FrameworkDescription();
    public static string get_RuntimeIdentifier();
    public static bool IsOSPlatform(OSPlatform osPlatform);
    public static Architecture get_ProcessArchitecture();
    public static string get_OSDescription();
    public static Architecture get_OSArchitecture();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SafeArrayRankMismatchException : SystemException {
    public SafeArrayRankMismatchException(string message);
    public SafeArrayRankMismatchException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SafeArrayRankMismatchException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SafeArrayTypeMismatchException : SystemException {
    public SafeArrayTypeMismatchException(string message);
    public SafeArrayTypeMismatchException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SafeArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    private UIntPtr _numBytes;
    private static UIntPtr Uninitialized { get; }
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    private static UIntPtr get_Uninitialized();
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void ReadSpan(ulong byteOffset, Span`1<T> buffer);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void WriteSpan(ulong byteOffset, ReadOnlySpan`1<T> data);
    public ulong get_ByteLength();
    private void SpaceCheck(Byte* ptr, UIntPtr sizeInBytes);
    private static void NotEnoughRoom();
    private static InvalidOperationException NotInitialized();
    internal static UInt32 AlignedSizeOf();
    internal static UInt32 SizeOf();
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private bool _ownsHandle;
    private bool _fullyInitialized;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    protected virtual override void Finalize();
    protected internal void SetHandle(IntPtr handle);
    public IntPtr DangerousGetHandle();
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void SetHandleAsInvalid();
    protected abstract virtual bool ReleaseHandle();
    public void DangerousAddRef(Boolean& success);
    internal void DangerousAddRef();
    public void DangerousRelease();
    private void InternalRelease(bool disposeOrFinalizeOperation);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.InteropServices.SEHException : ExternalException {
    public SEHException(string message);
    public SEHException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SEHException(SerializationInfo info, StreamingContext context);
    public virtual bool CanResume();
}
public class System.Runtime.InteropServices.StandardOleMarshalObject : MarshalByRefObject {
}
public enum System.Runtime.InteropServices.StringMarshalling : Enum {
    public int value__;
    public static StringMarshalling Custom;
    public static StringMarshalling Utf8;
    public static StringMarshalling Utf16;
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private LayoutKind <Value>k__BackingField;
    public int Pack;
    public int Size;
    public CharSet CharSet;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(LayoutKind layoutKind);
    public StructLayoutAttribute(short layoutKind);
    [CompilerGeneratedAttribute]
public LayoutKind get_Value();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.SuppressGCTransitionAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5144")]
public class System.Runtime.InteropServices.TypeIdentifierAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    public string Scope { get; }
    public string Identifier { get; }
    public TypeIdentifierAttribute(string scope, string identifier);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public string get_Identifier();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.UnknownWrapper : object {
    [CompilerGeneratedAttribute]
private object <WrappedObject>k__BackingField;
    public object WrappedObject { get; }
    public UnknownWrapper(object obj);
    [CompilerGeneratedAttribute]
public object get_WrappedObject();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.UnmanagedCallConvAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] CallConvs;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.UnmanagedCallersOnlyAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] CallConvs;
    [NullableAttribute("2")]
public string EntryPoint;
}
[AttributeUsageAttribute("4096")]
public class System.Runtime.InteropServices.UnmanagedFunctionPointerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CallingConvention <CallingConvention>k__BackingField;
    public bool BestFitMapping;
    public bool SetLastError;
    public bool ThrowOnUnmappableChar;
    public CharSet CharSet;
    public CallingConvention CallingConvention { get; }
    public UnmanagedFunctionPointerAttribute(CallingConvention callingConvention);
    [CompilerGeneratedAttribute]
public CallingConvention get_CallingConvention();
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as Currency may be unavailable in future releases.")]
public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType IDispatch;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as VBByRefString may be unavailable in future releases.")]
public static UnmanagedType VBByRefStr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as AnsiBStr may be unavailable in future releases.")]
public static UnmanagedType AnsiBStr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as TBstr may be unavailable in future releases.")]
public static UnmanagedType TBStr;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling arbitrary types may be unavailable in future releases. Specify the type you wish to marshal as.")]
public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType IInspectable;
    public static UnmanagedType HString;
    public static UnmanagedType LPUTF8Str;
}
[EditorBrowsableAttribute("1")]
public enum System.Runtime.InteropServices.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.InteropServices.VariantWrapper : object {
    [CompilerGeneratedAttribute]
private object <WrappedObject>k__BackingField;
    public object WrappedObject { get; }
    public VariantWrapper(object obj);
    [CompilerGeneratedAttribute]
public object get_WrappedObject();
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.AdvSimd : ArmBase {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector64`1<ushort> Abs(Vector64`1<short> value);
    public static Vector64`1<UInt32> Abs(Vector64`1<int> value);
    public static Vector64`1<byte> Abs(Vector64`1<sbyte> value);
    public static Vector64`1<float> Abs(Vector64`1<float> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<float> Abs(Vector128`1<float> value);
    public static Vector64`1<short> AbsSaturate(Vector64`1<short> value);
    public static Vector64`1<int> AbsSaturate(Vector64`1<int> value);
    public static Vector64`1<sbyte> AbsSaturate(Vector64`1<sbyte> value);
    public static Vector128`1<short> AbsSaturate(Vector128`1<short> value);
    public static Vector128`1<int> AbsSaturate(Vector128`1<int> value);
    public static Vector128`1<sbyte> AbsSaturate(Vector128`1<sbyte> value);
    public static Vector64`1<double> AbsScalar(Vector64`1<double> value);
    public static Vector64`1<float> AbsScalar(Vector64`1<float> value);
    public static Vector64`1<float> AbsoluteCompareGreaterThan(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> AbsoluteCompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<float> AbsoluteCompareGreaterThanOrEqual(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> AbsoluteCompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<float> AbsoluteCompareLessThan(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> AbsoluteCompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<float> AbsoluteCompareLessThanOrEqual(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> AbsoluteCompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<byte> AbsoluteDifference(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<ushort> AbsoluteDifference(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<UInt32> AbsoluteDifference(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<byte> AbsoluteDifference(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> AbsoluteDifference(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> AbsoluteDifference(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> AbsoluteDifference(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> AbsoluteDifference(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> AbsoluteDifference(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> AbsoluteDifference(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<byte> AbsoluteDifference(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> AbsoluteDifference(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> AbsoluteDifference(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> AbsoluteDifference(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> AbsoluteDifferenceAdd(Vector64`1<byte> addend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> AbsoluteDifferenceAdd(Vector64`1<short> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> AbsoluteDifferenceAdd(Vector64`1<int> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> AbsoluteDifferenceAdd(Vector64`1<sbyte> addend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> AbsoluteDifferenceAdd(Vector64`1<ushort> addend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> AbsoluteDifferenceAdd(Vector64`1<UInt32> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> AbsoluteDifferenceAdd(Vector128`1<byte> addend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AbsoluteDifferenceAdd(Vector128`1<short> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> AbsoluteDifferenceAdd(Vector128`1<int> addend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> AbsoluteDifferenceAdd(Vector128`1<sbyte> addend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> AbsoluteDifferenceAdd(Vector128`1<ushort> addend, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceAdd(Vector128`1<UInt32> addend, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> AbsoluteDifferenceWideningLower(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceWideningLower(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<ulong> AbsoluteDifferenceWideningLower(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<ushort> AbsoluteDifferenceWideningLower(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceWideningLower(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> AbsoluteDifferenceWideningLower(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> AbsoluteDifferenceWideningLowerAndAdd(Vector128`1<ushort> addend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> AbsoluteDifferenceWideningLowerAndAdd(Vector128`1<int> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> AbsoluteDifferenceWideningLowerAndAdd(Vector128`1<long> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> AbsoluteDifferenceWideningLowerAndAdd(Vector128`1<short> addend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceWideningLowerAndAdd(Vector128`1<UInt32> addend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> AbsoluteDifferenceWideningLowerAndAdd(Vector128`1<ulong> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> AbsoluteDifferenceWideningUpper(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceWideningUpper(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ulong> AbsoluteDifferenceWideningUpper(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<ushort> AbsoluteDifferenceWideningUpper(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceWideningUpper(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> AbsoluteDifferenceWideningUpper(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> AbsoluteDifferenceWideningUpperAndAdd(Vector128`1<ushort> addend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> AbsoluteDifferenceWideningUpperAndAdd(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> AbsoluteDifferenceWideningUpperAndAdd(Vector128`1<long> addend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> AbsoluteDifferenceWideningUpperAndAdd(Vector128`1<short> addend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<UInt32> AbsoluteDifferenceWideningUpperAndAdd(Vector128`1<UInt32> addend, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> AbsoluteDifferenceWideningUpperAndAdd(Vector128`1<ulong> addend, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> Add(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> Add(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Add(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> Add(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Add(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Add(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Add(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> Add(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Add(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Add(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> Add(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> Add(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Add(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Add(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Add(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> Add(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> AddHighNarrowingLower(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector64`1<short> AddHighNarrowingLower(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<int> AddHighNarrowingLower(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector64`1<sbyte> AddHighNarrowingLower(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector64`1<ushort> AddHighNarrowingLower(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<UInt32> AddHighNarrowingLower(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<byte> AddHighNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> AddHighNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> AddHighNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> AddHighNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddHighNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<UInt32> AddHighNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> AddPairwise(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> AddPairwise(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> AddPairwise(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> AddPairwise(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> AddPairwise(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> AddPairwise(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> AddPairwise(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<ushort> AddPairwiseWidening(Vector64`1<byte> value);
    public static Vector64`1<int> AddPairwiseWidening(Vector64`1<short> value);
    public static Vector64`1<short> AddPairwiseWidening(Vector64`1<sbyte> value);
    public static Vector64`1<UInt32> AddPairwiseWidening(Vector64`1<ushort> value);
    public static Vector128`1<ushort> AddPairwiseWidening(Vector128`1<byte> value);
    public static Vector128`1<int> AddPairwiseWidening(Vector128`1<short> value);
    public static Vector128`1<long> AddPairwiseWidening(Vector128`1<int> value);
    public static Vector128`1<short> AddPairwiseWidening(Vector128`1<sbyte> value);
    public static Vector128`1<UInt32> AddPairwiseWidening(Vector128`1<ushort> value);
    public static Vector128`1<ulong> AddPairwiseWidening(Vector128`1<UInt32> value);
    public static Vector64`1<ushort> AddPairwiseWideningAndAdd(Vector64`1<ushort> addend, Vector64`1<byte> value);
    public static Vector64`1<int> AddPairwiseWideningAndAdd(Vector64`1<int> addend, Vector64`1<short> value);
    public static Vector64`1<short> AddPairwiseWideningAndAdd(Vector64`1<short> addend, Vector64`1<sbyte> value);
    public static Vector64`1<UInt32> AddPairwiseWideningAndAdd(Vector64`1<UInt32> addend, Vector64`1<ushort> value);
    public static Vector128`1<ushort> AddPairwiseWideningAndAdd(Vector128`1<ushort> addend, Vector128`1<byte> value);
    public static Vector128`1<int> AddPairwiseWideningAndAdd(Vector128`1<int> addend, Vector128`1<short> value);
    public static Vector128`1<long> AddPairwiseWideningAndAdd(Vector128`1<long> addend, Vector128`1<int> value);
    public static Vector128`1<short> AddPairwiseWideningAndAdd(Vector128`1<short> addend, Vector128`1<sbyte> value);
    public static Vector128`1<UInt32> AddPairwiseWideningAndAdd(Vector128`1<UInt32> addend, Vector128`1<ushort> value);
    public static Vector128`1<ulong> AddPairwiseWideningAndAdd(Vector128`1<ulong> addend, Vector128`1<UInt32> value);
    public static Vector64`1<long> AddPairwiseWideningAndAddScalar(Vector64`1<long> addend, Vector64`1<int> value);
    public static Vector64`1<ulong> AddPairwiseWideningAndAddScalar(Vector64`1<ulong> addend, Vector64`1<UInt32> value);
    public static Vector64`1<long> AddPairwiseWideningScalar(Vector64`1<int> value);
    public static Vector64`1<ulong> AddPairwiseWideningScalar(Vector64`1<UInt32> value);
    public static Vector64`1<byte> AddRoundedHighNarrowingLower(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector64`1<short> AddRoundedHighNarrowingLower(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<int> AddRoundedHighNarrowingLower(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector64`1<sbyte> AddRoundedHighNarrowingLower(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector64`1<ushort> AddRoundedHighNarrowingLower(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<UInt32> AddRoundedHighNarrowingLower(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<byte> AddRoundedHighNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> AddRoundedHighNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> AddRoundedHighNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> AddRoundedHighNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddRoundedHighNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<UInt32> AddRoundedHighNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> AddSaturate(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> AddSaturate(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> AddSaturate(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> AddSaturate(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> AddSaturate(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> AddSaturate(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> AddSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> AddSaturate(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> AddSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> AddSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> AddSaturate(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> AddSaturate(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<long> AddSaturateScalar(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<ulong> AddSaturateScalar(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector64`1<double> AddScalar(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<long> AddScalar(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<float> AddScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ulong> AddScalar(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<ushort> AddWideningLower(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> AddWideningLower(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> AddWideningLower(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> AddWideningLower(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> AddWideningLower(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> AddWideningLower(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<short> AddWideningLower(Vector128`1<short> left, Vector64`1<sbyte> right);
    public static Vector128`1<int> AddWideningLower(Vector128`1<int> left, Vector64`1<short> right);
    public static Vector128`1<long> AddWideningLower(Vector128`1<long> left, Vector64`1<int> right);
    public static Vector128`1<ushort> AddWideningLower(Vector128`1<ushort> left, Vector64`1<byte> right);
    public static Vector128`1<UInt32> AddWideningLower(Vector128`1<UInt32> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> AddWideningLower(Vector128`1<ulong> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> AddWideningUpper(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> AddWideningUpper(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> AddWideningUpper(Vector128`1<short> left, Vector128`1<sbyte> right);
    public static Vector128`1<int> AddWideningUpper(Vector128`1<int> left, Vector128`1<short> right);
    public static Vector128`1<long> AddWideningUpper(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> AddWideningUpper(Vector128`1<long> left, Vector128`1<int> right);
    public static Vector128`1<short> AddWideningUpper(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> AddWideningUpper(Vector128`1<ushort> left, Vector128`1<byte> right);
    public static Vector128`1<UInt32> AddWideningUpper(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> AddWideningUpper(Vector128`1<UInt32> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> AddWideningUpper(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> AddWideningUpper(Vector128`1<ulong> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> And(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<double> And(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<short> And(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> And(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<long> And(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<sbyte> And(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> And(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> And(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> And(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<ulong> And(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<byte> And(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<double> And(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> And(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> And(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> And(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> And(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> And(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> And(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> And(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> And(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> BitwiseClear(Vector64`1<byte> value, Vector64`1<byte> mask);
    public static Vector64`1<double> BitwiseClear(Vector64`1<double> value, Vector64`1<double> mask);
    public static Vector64`1<short> BitwiseClear(Vector64`1<short> value, Vector64`1<short> mask);
    public static Vector64`1<int> BitwiseClear(Vector64`1<int> value, Vector64`1<int> mask);
    public static Vector64`1<long> BitwiseClear(Vector64`1<long> value, Vector64`1<long> mask);
    public static Vector64`1<sbyte> BitwiseClear(Vector64`1<sbyte> value, Vector64`1<sbyte> mask);
    public static Vector64`1<float> BitwiseClear(Vector64`1<float> value, Vector64`1<float> mask);
    public static Vector64`1<ushort> BitwiseClear(Vector64`1<ushort> value, Vector64`1<ushort> mask);
    public static Vector64`1<UInt32> BitwiseClear(Vector64`1<UInt32> value, Vector64`1<UInt32> mask);
    public static Vector64`1<ulong> BitwiseClear(Vector64`1<ulong> value, Vector64`1<ulong> mask);
    public static Vector128`1<byte> BitwiseClear(Vector128`1<byte> value, Vector128`1<byte> mask);
    public static Vector128`1<double> BitwiseClear(Vector128`1<double> value, Vector128`1<double> mask);
    public static Vector128`1<short> BitwiseClear(Vector128`1<short> value, Vector128`1<short> mask);
    public static Vector128`1<int> BitwiseClear(Vector128`1<int> value, Vector128`1<int> mask);
    public static Vector128`1<long> BitwiseClear(Vector128`1<long> value, Vector128`1<long> mask);
    public static Vector128`1<sbyte> BitwiseClear(Vector128`1<sbyte> value, Vector128`1<sbyte> mask);
    public static Vector128`1<float> BitwiseClear(Vector128`1<float> value, Vector128`1<float> mask);
    public static Vector128`1<ushort> BitwiseClear(Vector128`1<ushort> value, Vector128`1<ushort> mask);
    public static Vector128`1<UInt32> BitwiseClear(Vector128`1<UInt32> value, Vector128`1<UInt32> mask);
    public static Vector128`1<ulong> BitwiseClear(Vector128`1<ulong> value, Vector128`1<ulong> mask);
    public static Vector64`1<byte> BitwiseSelect(Vector64`1<byte> select, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<double> BitwiseSelect(Vector64`1<double> select, Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<short> BitwiseSelect(Vector64`1<short> select, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> BitwiseSelect(Vector64`1<int> select, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<long> BitwiseSelect(Vector64`1<long> select, Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<sbyte> BitwiseSelect(Vector64`1<sbyte> select, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> BitwiseSelect(Vector64`1<float> select, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> BitwiseSelect(Vector64`1<ushort> select, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> BitwiseSelect(Vector64`1<UInt32> select, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<ulong> BitwiseSelect(Vector64`1<ulong> select, Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<byte> BitwiseSelect(Vector128`1<byte> select, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<double> BitwiseSelect(Vector128`1<double> select, Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> BitwiseSelect(Vector128`1<short> select, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> BitwiseSelect(Vector128`1<int> select, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> BitwiseSelect(Vector128`1<long> select, Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> BitwiseSelect(Vector128`1<sbyte> select, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> BitwiseSelect(Vector128`1<float> select, Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> BitwiseSelect(Vector128`1<ushort> select, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> BitwiseSelect(Vector128`1<UInt32> select, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> BitwiseSelect(Vector128`1<ulong> select, Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<float> Ceiling(Vector64`1<float> value);
    public static Vector128`1<float> Ceiling(Vector128`1<float> value);
    public static Vector64`1<double> CeilingScalar(Vector64`1<double> value);
    public static Vector64`1<float> CeilingScalar(Vector64`1<float> value);
    public static Vector64`1<byte> CompareEqual(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> CompareEqual(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> CompareEqual(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> CompareEqual(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> CompareEqual(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> CompareEqual(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> CompareEqual(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> CompareEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> CompareEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> CompareEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> CompareEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> CompareEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> CompareGreaterThan(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> CompareGreaterThan(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> CompareGreaterThan(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> CompareGreaterThan(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> CompareGreaterThan(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> CompareGreaterThan(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> CompareGreaterThan(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> CompareGreaterThan(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareGreaterThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareGreaterThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> CompareGreaterThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> CompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> CompareGreaterThan(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> CompareGreaterThan(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> CompareGreaterThanOrEqual(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> CompareGreaterThanOrEqual(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> CompareGreaterThanOrEqual(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> CompareGreaterThanOrEqual(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> CompareGreaterThanOrEqual(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> CompareGreaterThanOrEqual(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> CompareGreaterThanOrEqual(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> CompareGreaterThanOrEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareGreaterThanOrEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareGreaterThanOrEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> CompareGreaterThanOrEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> CompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> CompareGreaterThanOrEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> CompareGreaterThanOrEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> CompareLessThan(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> CompareLessThan(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> CompareLessThan(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> CompareLessThan(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> CompareLessThan(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> CompareLessThan(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> CompareLessThan(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> CompareLessThan(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareLessThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareLessThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> CompareLessThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> CompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> CompareLessThan(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> CompareLessThan(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> CompareLessThanOrEqual(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> CompareLessThanOrEqual(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> CompareLessThanOrEqual(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> CompareLessThanOrEqual(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> CompareLessThanOrEqual(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> CompareLessThanOrEqual(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> CompareLessThanOrEqual(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> CompareLessThanOrEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareLessThanOrEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareLessThanOrEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> CompareLessThanOrEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> CompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> CompareLessThanOrEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> CompareLessThanOrEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> CompareTest(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> CompareTest(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> CompareTest(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> CompareTest(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> CompareTest(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> CompareTest(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> CompareTest(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> CompareTest(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareTest(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareTest(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> CompareTest(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> CompareTest(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> CompareTest(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> CompareTest(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<int> ConvertToInt32RoundAwayFromZero(Vector64`1<float> value);
    public static Vector128`1<int> ConvertToInt32RoundAwayFromZero(Vector128`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundAwayFromZeroScalar(Vector64`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToEven(Vector64`1<float> value);
    public static Vector128`1<int> ConvertToInt32RoundToEven(Vector128`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToEvenScalar(Vector64`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToNegativeInfinity(Vector64`1<float> value);
    public static Vector128`1<int> ConvertToInt32RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToNegativeInfinityScalar(Vector64`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToPositiveInfinity(Vector64`1<float> value);
    public static Vector128`1<int> ConvertToInt32RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToPositiveInfinityScalar(Vector64`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToZero(Vector64`1<float> value);
    public static Vector128`1<int> ConvertToInt32RoundToZero(Vector128`1<float> value);
    public static Vector64`1<int> ConvertToInt32RoundToZeroScalar(Vector64`1<float> value);
    public static Vector64`1<float> ConvertToSingle(Vector64`1<int> value);
    public static Vector64`1<float> ConvertToSingle(Vector64`1<UInt32> value);
    public static Vector128`1<float> ConvertToSingle(Vector128`1<int> value);
    public static Vector128`1<float> ConvertToSingle(Vector128`1<UInt32> value);
    public static Vector64`1<float> ConvertToSingleScalar(Vector64`1<int> value);
    public static Vector64`1<float> ConvertToSingleScalar(Vector64`1<UInt32> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundAwayFromZero(Vector64`1<float> value);
    public static Vector128`1<UInt32> ConvertToUInt32RoundAwayFromZero(Vector128`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundAwayFromZeroScalar(Vector64`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToEven(Vector64`1<float> value);
    public static Vector128`1<UInt32> ConvertToUInt32RoundToEven(Vector128`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToEvenScalar(Vector64`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToNegativeInfinity(Vector64`1<float> value);
    public static Vector128`1<UInt32> ConvertToUInt32RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToNegativeInfinityScalar(Vector64`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToPositiveInfinity(Vector64`1<float> value);
    public static Vector128`1<UInt32> ConvertToUInt32RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToPositiveInfinityScalar(Vector64`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToZero(Vector64`1<float> value);
    public static Vector128`1<UInt32> ConvertToUInt32RoundToZero(Vector128`1<float> value);
    public static Vector64`1<UInt32> ConvertToUInt32RoundToZeroScalar(Vector64`1<float> value);
    public static Vector64`1<double> DivideScalar(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> DivideScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<byte> DuplicateSelectedScalarToVector64(Vector64`1<byte> value, byte index);
    public static Vector64`1<short> DuplicateSelectedScalarToVector64(Vector64`1<short> value, byte index);
    public static Vector64`1<int> DuplicateSelectedScalarToVector64(Vector64`1<int> value, byte index);
    public static Vector64`1<float> DuplicateSelectedScalarToVector64(Vector64`1<float> value, byte index);
    public static Vector64`1<sbyte> DuplicateSelectedScalarToVector64(Vector64`1<sbyte> value, byte index);
    public static Vector64`1<ushort> DuplicateSelectedScalarToVector64(Vector64`1<ushort> value, byte index);
    public static Vector64`1<UInt32> DuplicateSelectedScalarToVector64(Vector64`1<UInt32> value, byte index);
    public static Vector64`1<byte> DuplicateSelectedScalarToVector64(Vector128`1<byte> value, byte index);
    public static Vector64`1<short> DuplicateSelectedScalarToVector64(Vector128`1<short> value, byte index);
    public static Vector64`1<int> DuplicateSelectedScalarToVector64(Vector128`1<int> value, byte index);
    public static Vector64`1<float> DuplicateSelectedScalarToVector64(Vector128`1<float> value, byte index);
    public static Vector64`1<sbyte> DuplicateSelectedScalarToVector64(Vector128`1<sbyte> value, byte index);
    public static Vector64`1<ushort> DuplicateSelectedScalarToVector64(Vector128`1<ushort> value, byte index);
    public static Vector64`1<UInt32> DuplicateSelectedScalarToVector64(Vector128`1<UInt32> value, byte index);
    public static Vector128`1<byte> DuplicateSelectedScalarToVector128(Vector64`1<byte> value, byte index);
    public static Vector128`1<short> DuplicateSelectedScalarToVector128(Vector64`1<short> value, byte index);
    public static Vector128`1<int> DuplicateSelectedScalarToVector128(Vector64`1<int> value, byte index);
    public static Vector128`1<float> DuplicateSelectedScalarToVector128(Vector64`1<float> value, byte index);
    public static Vector128`1<sbyte> DuplicateSelectedScalarToVector128(Vector64`1<sbyte> value, byte index);
    public static Vector128`1<ushort> DuplicateSelectedScalarToVector128(Vector64`1<ushort> value, byte index);
    public static Vector128`1<UInt32> DuplicateSelectedScalarToVector128(Vector64`1<UInt32> value, byte index);
    public static Vector128`1<byte> DuplicateSelectedScalarToVector128(Vector128`1<byte> value, byte index);
    public static Vector128`1<short> DuplicateSelectedScalarToVector128(Vector128`1<short> value, byte index);
    public static Vector128`1<int> DuplicateSelectedScalarToVector128(Vector128`1<int> value, byte index);
    public static Vector128`1<float> DuplicateSelectedScalarToVector128(Vector128`1<float> value, byte index);
    public static Vector128`1<sbyte> DuplicateSelectedScalarToVector128(Vector128`1<sbyte> value, byte index);
    public static Vector128`1<ushort> DuplicateSelectedScalarToVector128(Vector128`1<ushort> value, byte index);
    public static Vector128`1<UInt32> DuplicateSelectedScalarToVector128(Vector128`1<UInt32> value, byte index);
    public static Vector64`1<byte> DuplicateToVector64(byte value);
    public static Vector64`1<short> DuplicateToVector64(short value);
    public static Vector64`1<int> DuplicateToVector64(int value);
    public static Vector64`1<sbyte> DuplicateToVector64(sbyte value);
    public static Vector64`1<float> DuplicateToVector64(float value);
    public static Vector64`1<ushort> DuplicateToVector64(ushort value);
    public static Vector64`1<UInt32> DuplicateToVector64(UInt32 value);
    public static Vector128`1<byte> DuplicateToVector128(byte value);
    public static Vector128`1<short> DuplicateToVector128(short value);
    public static Vector128`1<int> DuplicateToVector128(int value);
    public static Vector128`1<sbyte> DuplicateToVector128(sbyte value);
    public static Vector128`1<float> DuplicateToVector128(float value);
    public static Vector128`1<ushort> DuplicateToVector128(ushort value);
    public static Vector128`1<UInt32> DuplicateToVector128(UInt32 value);
    public static byte Extract(Vector64`1<byte> vector, byte index);
    public static short Extract(Vector64`1<short> vector, byte index);
    public static int Extract(Vector64`1<int> vector, byte index);
    public static sbyte Extract(Vector64`1<sbyte> vector, byte index);
    public static float Extract(Vector64`1<float> vector, byte index);
    public static ushort Extract(Vector64`1<ushort> vector, byte index);
    public static UInt32 Extract(Vector64`1<UInt32> vector, byte index);
    public static byte Extract(Vector128`1<byte> vector, byte index);
    public static double Extract(Vector128`1<double> vector, byte index);
    public static short Extract(Vector128`1<short> vector, byte index);
    public static int Extract(Vector128`1<int> vector, byte index);
    public static long Extract(Vector128`1<long> vector, byte index);
    public static sbyte Extract(Vector128`1<sbyte> vector, byte index);
    public static float Extract(Vector128`1<float> vector, byte index);
    public static ushort Extract(Vector128`1<ushort> vector, byte index);
    public static UInt32 Extract(Vector128`1<UInt32> vector, byte index);
    public static ulong Extract(Vector128`1<ulong> vector, byte index);
    public static Vector64`1<byte> ExtractNarrowingLower(Vector128`1<ushort> value);
    public static Vector64`1<short> ExtractNarrowingLower(Vector128`1<int> value);
    public static Vector64`1<int> ExtractNarrowingLower(Vector128`1<long> value);
    public static Vector64`1<sbyte> ExtractNarrowingLower(Vector128`1<short> value);
    public static Vector64`1<ushort> ExtractNarrowingLower(Vector128`1<UInt32> value);
    public static Vector64`1<UInt32> ExtractNarrowingLower(Vector128`1<ulong> value);
    public static Vector64`1<byte> ExtractNarrowingSaturateLower(Vector128`1<ushort> value);
    public static Vector64`1<short> ExtractNarrowingSaturateLower(Vector128`1<int> value);
    public static Vector64`1<int> ExtractNarrowingSaturateLower(Vector128`1<long> value);
    public static Vector64`1<sbyte> ExtractNarrowingSaturateLower(Vector128`1<short> value);
    public static Vector64`1<ushort> ExtractNarrowingSaturateLower(Vector128`1<UInt32> value);
    public static Vector64`1<UInt32> ExtractNarrowingSaturateLower(Vector128`1<ulong> value);
    public static Vector64`1<byte> ExtractNarrowingSaturateUnsignedLower(Vector128`1<short> value);
    public static Vector64`1<ushort> ExtractNarrowingSaturateUnsignedLower(Vector128`1<int> value);
    public static Vector64`1<UInt32> ExtractNarrowingSaturateUnsignedLower(Vector128`1<long> value);
    public static Vector128`1<byte> ExtractNarrowingSaturateUnsignedUpper(Vector64`1<byte> lower, Vector128`1<short> value);
    public static Vector128`1<ushort> ExtractNarrowingSaturateUnsignedUpper(Vector64`1<ushort> lower, Vector128`1<int> value);
    public static Vector128`1<UInt32> ExtractNarrowingSaturateUnsignedUpper(Vector64`1<UInt32> lower, Vector128`1<long> value);
    public static Vector128`1<byte> ExtractNarrowingSaturateUpper(Vector64`1<byte> lower, Vector128`1<ushort> value);
    public static Vector128`1<short> ExtractNarrowingSaturateUpper(Vector64`1<short> lower, Vector128`1<int> value);
    public static Vector128`1<int> ExtractNarrowingSaturateUpper(Vector64`1<int> lower, Vector128`1<long> value);
    public static Vector128`1<sbyte> ExtractNarrowingSaturateUpper(Vector64`1<sbyte> lower, Vector128`1<short> value);
    public static Vector128`1<ushort> ExtractNarrowingSaturateUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> value);
    public static Vector128`1<UInt32> ExtractNarrowingSaturateUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> value);
    public static Vector128`1<byte> ExtractNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> value);
    public static Vector128`1<short> ExtractNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> value);
    public static Vector128`1<int> ExtractNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> value);
    public static Vector128`1<sbyte> ExtractNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> value);
    public static Vector128`1<ushort> ExtractNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> value);
    public static Vector128`1<UInt32> ExtractNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> value);
    public static Vector64`1<byte> ExtractVector64(Vector64`1<byte> upper, Vector64`1<byte> lower, byte index);
    public static Vector64`1<short> ExtractVector64(Vector64`1<short> upper, Vector64`1<short> lower, byte index);
    public static Vector64`1<int> ExtractVector64(Vector64`1<int> upper, Vector64`1<int> lower, byte index);
    public static Vector64`1<sbyte> ExtractVector64(Vector64`1<sbyte> upper, Vector64`1<sbyte> lower, byte index);
    public static Vector64`1<float> ExtractVector64(Vector64`1<float> upper, Vector64`1<float> lower, byte index);
    public static Vector64`1<ushort> ExtractVector64(Vector64`1<ushort> upper, Vector64`1<ushort> lower, byte index);
    public static Vector64`1<UInt32> ExtractVector64(Vector64`1<UInt32> upper, Vector64`1<UInt32> lower, byte index);
    public static Vector128`1<byte> ExtractVector128(Vector128`1<byte> upper, Vector128`1<byte> lower, byte index);
    public static Vector128`1<double> ExtractVector128(Vector128`1<double> upper, Vector128`1<double> lower, byte index);
    public static Vector128`1<short> ExtractVector128(Vector128`1<short> upper, Vector128`1<short> lower, byte index);
    public static Vector128`1<int> ExtractVector128(Vector128`1<int> upper, Vector128`1<int> lower, byte index);
    public static Vector128`1<long> ExtractVector128(Vector128`1<long> upper, Vector128`1<long> lower, byte index);
    public static Vector128`1<sbyte> ExtractVector128(Vector128`1<sbyte> upper, Vector128`1<sbyte> lower, byte index);
    public static Vector128`1<float> ExtractVector128(Vector128`1<float> upper, Vector128`1<float> lower, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector128`1<ushort> upper, Vector128`1<ushort> lower, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector128`1<UInt32> upper, Vector128`1<UInt32> lower, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector128`1<ulong> upper, Vector128`1<ulong> lower, byte index);
    public static Vector64`1<float> Floor(Vector64`1<float> value);
    public static Vector128`1<float> Floor(Vector128`1<float> value);
    public static Vector64`1<double> FloorScalar(Vector64`1<double> value);
    public static Vector64`1<float> FloorScalar(Vector64`1<float> value);
    public static Vector64`1<byte> FusedAddHalving(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> FusedAddHalving(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> FusedAddHalving(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> FusedAddHalving(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> FusedAddHalving(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> FusedAddHalving(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> FusedAddHalving(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> FusedAddHalving(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> FusedAddHalving(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> FusedAddHalving(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> FusedAddHalving(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> FusedAddHalving(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> FusedAddRoundedHalving(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> FusedAddRoundedHalving(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> FusedAddRoundedHalving(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> FusedAddRoundedHalving(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> FusedAddRoundedHalving(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> FusedAddRoundedHalving(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> FusedAddRoundedHalving(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> FusedAddRoundedHalving(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> FusedAddRoundedHalving(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> FusedAddRoundedHalving(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> FusedAddRoundedHalving(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> FusedAddRoundedHalving(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<float> FusedMultiplyAdd(Vector64`1<float> addend, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> FusedMultiplyAdd(Vector128`1<float> addend, Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<double> FusedMultiplyAddNegatedScalar(Vector64`1<double> addend, Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> FusedMultiplyAddNegatedScalar(Vector64`1<float> addend, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<double> FusedMultiplyAddScalar(Vector64`1<double> addend, Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> FusedMultiplyAddScalar(Vector64`1<float> addend, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<float> FusedMultiplySubtract(Vector64`1<float> minuend, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> FusedMultiplySubtract(Vector128`1<float> minuend, Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<double> FusedMultiplySubtractNegatedScalar(Vector64`1<double> minuend, Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> FusedMultiplySubtractNegatedScalar(Vector64`1<float> minuend, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<double> FusedMultiplySubtractScalar(Vector64`1<double> minuend, Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> FusedMultiplySubtractScalar(Vector64`1<float> minuend, Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<byte> FusedSubtractHalving(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> FusedSubtractHalving(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> FusedSubtractHalving(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> FusedSubtractHalving(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> FusedSubtractHalving(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> FusedSubtractHalving(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> FusedSubtractHalving(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> FusedSubtractHalving(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> FusedSubtractHalving(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> FusedSubtractHalving(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> FusedSubtractHalving(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> FusedSubtractHalving(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> Insert(Vector64`1<byte> vector, byte index, byte data);
    public static Vector64`1<short> Insert(Vector64`1<short> vector, byte index, short data);
    public static Vector64`1<int> Insert(Vector64`1<int> vector, byte index, int data);
    public static Vector64`1<sbyte> Insert(Vector64`1<sbyte> vector, byte index, sbyte data);
    public static Vector64`1<float> Insert(Vector64`1<float> vector, byte index, float data);
    public static Vector64`1<ushort> Insert(Vector64`1<ushort> vector, byte index, ushort data);
    public static Vector64`1<UInt32> Insert(Vector64`1<UInt32> vector, byte index, UInt32 data);
    public static Vector128`1<byte> Insert(Vector128`1<byte> vector, byte index, byte data);
    public static Vector128`1<double> Insert(Vector128`1<double> vector, byte index, double data);
    public static Vector128`1<short> Insert(Vector128`1<short> vector, byte index, short data);
    public static Vector128`1<int> Insert(Vector128`1<int> vector, byte index, int data);
    public static Vector128`1<long> Insert(Vector128`1<long> vector, byte index, long data);
    public static Vector128`1<sbyte> Insert(Vector128`1<sbyte> vector, byte index, sbyte data);
    public static Vector128`1<float> Insert(Vector128`1<float> vector, byte index, float data);
    public static Vector128`1<ushort> Insert(Vector128`1<ushort> vector, byte index, ushort data);
    public static Vector128`1<UInt32> Insert(Vector128`1<UInt32> vector, byte index, UInt32 data);
    public static Vector128`1<ulong> Insert(Vector128`1<ulong> vector, byte index, ulong data);
    public static Vector128`1<double> InsertScalar(Vector128`1<double> result, byte resultIndex, Vector64`1<double> value);
    public static Vector128`1<long> InsertScalar(Vector128`1<long> result, byte resultIndex, Vector64`1<long> value);
    public static Vector128`1<ulong> InsertScalar(Vector128`1<ulong> result, byte resultIndex, Vector64`1<ulong> value);
    public static Vector64`1<short> LeadingSignCount(Vector64`1<short> value);
    public static Vector64`1<int> LeadingSignCount(Vector64`1<int> value);
    public static Vector64`1<sbyte> LeadingSignCount(Vector64`1<sbyte> value);
    public static Vector128`1<short> LeadingSignCount(Vector128`1<short> value);
    public static Vector128`1<int> LeadingSignCount(Vector128`1<int> value);
    public static Vector128`1<sbyte> LeadingSignCount(Vector128`1<sbyte> value);
    public static Vector64`1<byte> LeadingZeroCount(Vector64`1<byte> value);
    public static Vector64`1<short> LeadingZeroCount(Vector64`1<short> value);
    public static Vector64`1<int> LeadingZeroCount(Vector64`1<int> value);
    public static Vector64`1<sbyte> LeadingZeroCount(Vector64`1<sbyte> value);
    public static Vector64`1<ushort> LeadingZeroCount(Vector64`1<ushort> value);
    public static Vector64`1<UInt32> LeadingZeroCount(Vector64`1<UInt32> value);
    public static Vector128`1<byte> LeadingZeroCount(Vector128`1<byte> value);
    public static Vector128`1<short> LeadingZeroCount(Vector128`1<short> value);
    public static Vector128`1<int> LeadingZeroCount(Vector128`1<int> value);
    public static Vector128`1<sbyte> LeadingZeroCount(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> LeadingZeroCount(Vector128`1<ushort> value);
    public static Vector128`1<UInt32> LeadingZeroCount(Vector128`1<UInt32> value);
    public static Vector64`1<byte> LoadAndInsertScalar(Vector64`1<byte> value, byte index, Byte* address);
    public static Vector64`1<short> LoadAndInsertScalar(Vector64`1<short> value, byte index, Int16* address);
    public static Vector64`1<int> LoadAndInsertScalar(Vector64`1<int> value, byte index, Int32* address);
    public static Vector64`1<sbyte> LoadAndInsertScalar(Vector64`1<sbyte> value, byte index, SByte* address);
    public static Vector64`1<float> LoadAndInsertScalar(Vector64`1<float> value, byte index, Single* address);
    public static Vector64`1<ushort> LoadAndInsertScalar(Vector64`1<ushort> value, byte index, UInt16* address);
    public static Vector64`1<UInt32> LoadAndInsertScalar(Vector64`1<UInt32> value, byte index, UInt32* address);
    public static Vector128`1<byte> LoadAndInsertScalar(Vector128`1<byte> value, byte index, Byte* address);
    public static Vector128`1<double> LoadAndInsertScalar(Vector128`1<double> value, byte index, Double* address);
    public static Vector128`1<short> LoadAndInsertScalar(Vector128`1<short> value, byte index, Int16* address);
    public static Vector128`1<int> LoadAndInsertScalar(Vector128`1<int> value, byte index, Int32* address);
    public static Vector128`1<long> LoadAndInsertScalar(Vector128`1<long> value, byte index, Int64* address);
    public static Vector128`1<sbyte> LoadAndInsertScalar(Vector128`1<sbyte> value, byte index, SByte* address);
    public static Vector128`1<float> LoadAndInsertScalar(Vector128`1<float> value, byte index, Single* address);
    public static Vector128`1<ushort> LoadAndInsertScalar(Vector128`1<ushort> value, byte index, UInt16* address);
    public static Vector128`1<UInt32> LoadAndInsertScalar(Vector128`1<UInt32> value, byte index, UInt32* address);
    public static Vector128`1<ulong> LoadAndInsertScalar(Vector128`1<ulong> value, byte index, UInt64* address);
    public static Vector64`1<byte> LoadAndReplicateToVector64(Byte* address);
    public static Vector64`1<short> LoadAndReplicateToVector64(Int16* address);
    public static Vector64`1<int> LoadAndReplicateToVector64(Int32* address);
    public static Vector64`1<sbyte> LoadAndReplicateToVector64(SByte* address);
    public static Vector64`1<float> LoadAndReplicateToVector64(Single* address);
    public static Vector64`1<ushort> LoadAndReplicateToVector64(UInt16* address);
    public static Vector64`1<UInt32> LoadAndReplicateToVector64(UInt32* address);
    public static Vector128`1<byte> LoadAndReplicateToVector128(Byte* address);
    public static Vector128`1<short> LoadAndReplicateToVector128(Int16* address);
    public static Vector128`1<int> LoadAndReplicateToVector128(Int32* address);
    public static Vector128`1<sbyte> LoadAndReplicateToVector128(SByte* address);
    public static Vector128`1<float> LoadAndReplicateToVector128(Single* address);
    public static Vector128`1<ushort> LoadAndReplicateToVector128(UInt16* address);
    public static Vector128`1<UInt32> LoadAndReplicateToVector128(UInt32* address);
    public static Vector64`1<byte> LoadVector64(Byte* address);
    public static Vector64`1<double> LoadVector64(Double* address);
    public static Vector64`1<short> LoadVector64(Int16* address);
    public static Vector64`1<int> LoadVector64(Int32* address);
    public static Vector64`1<long> LoadVector64(Int64* address);
    public static Vector64`1<sbyte> LoadVector64(SByte* address);
    public static Vector64`1<float> LoadVector64(Single* address);
    public static Vector64`1<ushort> LoadVector64(UInt16* address);
    public static Vector64`1<UInt32> LoadVector64(UInt32* address);
    public static Vector64`1<ulong> LoadVector64(UInt64* address);
    public static Vector128`1<byte> LoadVector128(Byte* address);
    public static Vector128`1<double> LoadVector128(Double* address);
    public static Vector128`1<short> LoadVector128(Int16* address);
    public static Vector128`1<int> LoadVector128(Int32* address);
    public static Vector128`1<long> LoadVector128(Int64* address);
    public static Vector128`1<sbyte> LoadVector128(SByte* address);
    public static Vector128`1<float> LoadVector128(Single* address);
    public static Vector128`1<ushort> LoadVector128(UInt16* address);
    public static Vector128`1<UInt32> LoadVector128(UInt32* address);
    public static Vector128`1<ulong> LoadVector128(UInt64* address);
    public static Vector64`1<byte> Max(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> Max(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Max(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> Max(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Max(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Max(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Max(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<float> MaxNumber(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> MaxNumber(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<double> MaxNumberScalar(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> MaxNumberScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<byte> MaxPairwise(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> MaxPairwise(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MaxPairwise(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> MaxPairwise(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> MaxPairwise(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> MaxPairwise(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MaxPairwise(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<byte> Min(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> Min(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Min(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> Min(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Min(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Min(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Min(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<float> MinNumber(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> MinNumber(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<double> MinNumberScalar(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> MinNumberScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<byte> MinPairwise(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> MinPairwise(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MinPairwise(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> MinPairwise(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> MinPairwise(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> MinPairwise(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MinPairwise(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<byte> Multiply(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> Multiply(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Multiply(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> Multiply(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Multiply(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Multiply(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Multiply(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> Multiply(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Multiply(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> Multiply(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Multiply(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> MultiplyAdd(Vector64`1<byte> addend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> MultiplyAdd(Vector64`1<short> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyAdd(Vector64`1<int> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> MultiplyAdd(Vector64`1<sbyte> addend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> MultiplyAdd(Vector64`1<ushort> addend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MultiplyAdd(Vector64`1<UInt32> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> MultiplyAdd(Vector128`1<byte> addend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> MultiplyAdd(Vector128`1<short> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> MultiplyAdd(Vector128`1<int> addend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> MultiplyAdd(Vector128`1<sbyte> addend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> MultiplyAdd(Vector128`1<ushort> addend, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> MultiplyAdd(Vector128`1<UInt32> addend, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<short> MultiplyAddByScalar(Vector64`1<short> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyAddByScalar(Vector64`1<int> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<ushort> MultiplyAddByScalar(Vector64`1<ushort> addend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MultiplyAddByScalar(Vector64`1<UInt32> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<short> MultiplyAddByScalar(Vector128`1<short> addend, Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<int> MultiplyAddByScalar(Vector128`1<int> addend, Vector128`1<int> left, Vector64`1<int> right);
    public static Vector128`1<ushort> MultiplyAddByScalar(Vector128`1<ushort> addend, Vector128`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<UInt32> MultiplyAddByScalar(Vector128`1<UInt32> addend, Vector128`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<short> MultiplyAddBySelectedScalar(Vector64`1<short> addend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplyAddBySelectedScalar(Vector64`1<short> addend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplyAddBySelectedScalar(Vector64`1<int> addend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplyAddBySelectedScalar(Vector64`1<int> addend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<ushort> MultiplyAddBySelectedScalar(Vector64`1<ushort> addend, Vector64`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector64`1<ushort> MultiplyAddBySelectedScalar(Vector64`1<ushort> addend, Vector64`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector64`1<UInt32> MultiplyAddBySelectedScalar(Vector64`1<UInt32> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector64`1<UInt32> MultiplyAddBySelectedScalar(Vector64`1<UInt32> addend, Vector64`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<short> MultiplyAddBySelectedScalar(Vector128`1<short> addend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplyAddBySelectedScalar(Vector128`1<short> addend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyAddBySelectedScalar(Vector128`1<int> addend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyAddBySelectedScalar(Vector128`1<int> addend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplyAddBySelectedScalar(Vector128`1<ushort> addend, Vector128`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplyAddBySelectedScalar(Vector128`1<ushort> addend, Vector128`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyAddBySelectedScalar(Vector128`1<UInt32> addend, Vector128`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyAddBySelectedScalar(Vector128`1<UInt32> addend, Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector64`1<short> MultiplyByScalar(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyByScalar(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<float> MultiplyByScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> MultiplyByScalar(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MultiplyByScalar(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<short> MultiplyByScalar(Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<int> MultiplyByScalar(Vector128`1<int> left, Vector64`1<int> right);
    public static Vector128`1<float> MultiplyByScalar(Vector128`1<float> left, Vector64`1<float> right);
    public static Vector128`1<ushort> MultiplyByScalar(Vector128`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<UInt32> MultiplyByScalar(Vector128`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<short> MultiplyBySelectedScalar(Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplyBySelectedScalar(Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplyBySelectedScalar(Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplyBySelectedScalar(Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<float> MultiplyBySelectedScalar(Vector64`1<float> left, Vector64`1<float> right, byte rightIndex);
    public static Vector64`1<float> MultiplyBySelectedScalar(Vector64`1<float> left, Vector128`1<float> right, byte rightIndex);
    public static Vector64`1<ushort> MultiplyBySelectedScalar(Vector64`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector64`1<ushort> MultiplyBySelectedScalar(Vector64`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector64`1<UInt32> MultiplyBySelectedScalar(Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector64`1<UInt32> MultiplyBySelectedScalar(Vector64`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<short> MultiplyBySelectedScalar(Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplyBySelectedScalar(Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalar(Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalar(Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<float> MultiplyBySelectedScalar(Vector128`1<float> left, Vector64`1<float> right, byte rightIndex);
    public static Vector128`1<float> MultiplyBySelectedScalar(Vector128`1<float> left, Vector128`1<float> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplyBySelectedScalar(Vector128`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplyBySelectedScalar(Vector128`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalar(Vector128`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalar(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningLower(Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningLower(Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningLower(Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningLower(Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningLower(Vector64`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningLower(Vector64`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningLower(Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningLower(Vector64`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<int> addend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<int> addend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<long> addend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<long> addend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<UInt32> addend, Vector64`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<UInt32> addend, Vector64`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<ulong> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningLowerAndAdd(Vector128`1<ulong> addend, Vector64`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<int> minuend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<int> minuend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<long> minuend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<long> minuend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<UInt32> minuend, Vector64`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<UInt32> minuend, Vector64`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<ulong> minuend, Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningLowerAndSubtract(Vector128`1<ulong> minuend, Vector64`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningUpper(Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningUpper(Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningUpper(Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningUpper(Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningUpper(Vector128`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningUpper(Vector128`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningUpper(Vector128`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningUpper(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<int> addend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<long> addend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<long> addend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<UInt32> addend, Vector128`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<UInt32> addend, Vector128`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<ulong> addend, Vector128`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningUpperAndAdd(Vector128`1<ulong> addend, Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<int> minuend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<int> minuend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<long> minuend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<long> minuend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<UInt32> minuend, Vector128`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<UInt32> minuend, Vector128`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<ulong> minuend, Vector128`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ulong> MultiplyBySelectedScalarWideningUpperAndSubtract(Vector128`1<ulong> minuend, Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector64`1<short> MultiplyDoublingByScalarSaturateHigh(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyDoublingByScalarSaturateHigh(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyDoublingByScalarSaturateHigh(Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<int> MultiplyDoublingByScalarSaturateHigh(Vector128`1<int> left, Vector64`1<int> right);
    public static Vector64`1<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingBySelectedScalarSaturateHigh(Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<short> MultiplyDoublingSaturateHigh(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyDoublingSaturateHigh(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyDoublingSaturateHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> MultiplyDoublingSaturateHigh(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningLowerAndAddSaturate(Vector128`1<int> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningLowerAndAddSaturate(Vector128`1<long> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningLowerAndSubtractSaturate(Vector128`1<int> minuend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningLowerAndSubtractSaturate(Vector128`1<long> minuend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningLowerByScalarAndAddSaturate(Vector128`1<int> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningLowerByScalarAndAddSaturate(Vector128`1<long> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(Vector128`1<int> minuend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningLowerByScalarAndSubtractSaturate(Vector128`1<long> minuend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128`1<int> addend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128`1<int> addend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128`1<long> addend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningLowerBySelectedScalarAndAddSaturate(Vector128`1<long> addend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128`1<int> minuend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128`1<int> minuend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128`1<long> minuend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningLowerBySelectedScalarAndSubtractSaturate(Vector128`1<long> minuend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateLower(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateLower(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateLowerByScalar(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateLowerByScalar(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateLowerBySelectedScalar(Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateUpper(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateUpper(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateUpperByScalar(Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateUpperByScalar(Vector128`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningSaturateUpperBySelectedScalar(Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningUpperAndAddSaturate(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningUpperAndAddSaturate(Vector128`1<long> addend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningUpperAndSubtractSaturate(Vector128`1<int> minuend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningUpperAndSubtractSaturate(Vector128`1<long> minuend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningUpperByScalarAndAddSaturate(Vector128`1<int> addend, Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningUpperByScalarAndAddSaturate(Vector128`1<long> addend, Vector128`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(Vector128`1<int> minuend, Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyDoublingWideningUpperByScalarAndSubtractSaturate(Vector128`1<long> minuend, Vector128`1<int> left, Vector64`1<int> right);
    public static Vector128`1<int> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128`1<int> addend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128`1<long> addend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningUpperBySelectedScalarAndAddSaturate(Vector128`1<long> addend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128`1<int> minuend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128`1<int> minuend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128`1<long> minuend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<long> MultiplyDoublingWideningUpperBySelectedScalarAndSubtractSaturate(Vector128`1<long> minuend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<short> MultiplyRoundedDoublingByScalarSaturateHigh(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyRoundedDoublingByScalarSaturateHigh(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyRoundedDoublingByScalarSaturateHigh(Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<int> MultiplyRoundedDoublingByScalarSaturateHigh(Vector128`1<int> left, Vector64`1<int> right);
    public static Vector64`1<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyRoundedDoublingBySelectedScalarSaturateHigh(Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<short> MultiplyRoundedDoublingSaturateHigh(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyRoundedDoublingSaturateHigh(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyRoundedDoublingSaturateHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> MultiplyRoundedDoublingSaturateHigh(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<double> MultiplyScalar(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<float> MultiplyScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<float> MultiplyScalarBySelectedScalar(Vector64`1<float> left, Vector64`1<float> right, byte rightIndex);
    public static Vector64`1<float> MultiplyScalarBySelectedScalar(Vector64`1<float> left, Vector128`1<float> right, byte rightIndex);
    public static Vector64`1<byte> MultiplySubtract(Vector64`1<byte> minuend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> MultiplySubtract(Vector64`1<short> minuend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplySubtract(Vector64`1<int> minuend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> MultiplySubtract(Vector64`1<sbyte> minuend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> MultiplySubtract(Vector64`1<ushort> minuend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MultiplySubtract(Vector64`1<UInt32> minuend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> MultiplySubtract(Vector128`1<byte> minuend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> MultiplySubtract(Vector128`1<short> minuend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> MultiplySubtract(Vector128`1<int> minuend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<sbyte> MultiplySubtract(Vector128`1<sbyte> minuend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> MultiplySubtract(Vector128`1<ushort> minuend, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> MultiplySubtract(Vector128`1<UInt32> minuend, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<short> MultiplySubtractByScalar(Vector64`1<short> minuend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplySubtractByScalar(Vector64`1<int> minuend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<ushort> MultiplySubtractByScalar(Vector64`1<ushort> minuend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> MultiplySubtractByScalar(Vector64`1<UInt32> minuend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<short> MultiplySubtractByScalar(Vector128`1<short> minuend, Vector128`1<short> left, Vector64`1<short> right);
    public static Vector128`1<int> MultiplySubtractByScalar(Vector128`1<int> minuend, Vector128`1<int> left, Vector64`1<int> right);
    public static Vector128`1<ushort> MultiplySubtractByScalar(Vector128`1<ushort> minuend, Vector128`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<UInt32> MultiplySubtractByScalar(Vector128`1<UInt32> minuend, Vector128`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<short> MultiplySubtractBySelectedScalar(Vector64`1<short> minuend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplySubtractBySelectedScalar(Vector64`1<short> minuend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplySubtractBySelectedScalar(Vector64`1<int> minuend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplySubtractBySelectedScalar(Vector64`1<int> minuend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<ushort> MultiplySubtractBySelectedScalar(Vector64`1<ushort> minuend, Vector64`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector64`1<ushort> MultiplySubtractBySelectedScalar(Vector64`1<ushort> minuend, Vector64`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector64`1<UInt32> MultiplySubtractBySelectedScalar(Vector64`1<UInt32> minuend, Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector64`1<UInt32> MultiplySubtractBySelectedScalar(Vector64`1<UInt32> minuend, Vector64`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<short> MultiplySubtractBySelectedScalar(Vector128`1<short> minuend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplySubtractBySelectedScalar(Vector128`1<short> minuend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplySubtractBySelectedScalar(Vector128`1<int> minuend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplySubtractBySelectedScalar(Vector128`1<int> minuend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplySubtractBySelectedScalar(Vector128`1<ushort> minuend, Vector128`1<ushort> left, Vector64`1<ushort> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplySubtractBySelectedScalar(Vector128`1<ushort> minuend, Vector128`1<ushort> left, Vector128`1<ushort> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplySubtractBySelectedScalar(Vector128`1<UInt32> minuend, Vector128`1<UInt32> left, Vector64`1<UInt32> right, byte rightIndex);
    public static Vector128`1<UInt32> MultiplySubtractBySelectedScalar(Vector128`1<UInt32> minuend, Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte rightIndex);
    public static Vector128`1<ushort> MultiplyWideningLower(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> MultiplyWideningLower(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyWideningLower(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyWideningLower(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> MultiplyWideningLower(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> MultiplyWideningLower(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> MultiplyWideningLowerAndAdd(Vector128`1<ushort> addend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> MultiplyWideningLowerAndAdd(Vector128`1<int> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyWideningLowerAndAdd(Vector128`1<long> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyWideningLowerAndAdd(Vector128`1<short> addend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> MultiplyWideningLowerAndAdd(Vector128`1<UInt32> addend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> MultiplyWideningLowerAndAdd(Vector128`1<ulong> addend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> MultiplyWideningLowerAndSubtract(Vector128`1<ushort> minuend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> MultiplyWideningLowerAndSubtract(Vector128`1<int> minuend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> MultiplyWideningLowerAndSubtract(Vector128`1<long> minuend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyWideningLowerAndSubtract(Vector128`1<short> minuend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> MultiplyWideningLowerAndSubtract(Vector128`1<UInt32> minuend, Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> MultiplyWideningLowerAndSubtract(Vector128`1<ulong> minuend, Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> MultiplyWideningUpper(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> MultiplyWideningUpper(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> MultiplyWideningUpper(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> MultiplyWideningUpper(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<UInt32> MultiplyWideningUpper(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> MultiplyWideningUpper(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> MultiplyWideningUpperAndAdd(Vector128`1<ushort> addend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> MultiplyWideningUpperAndAdd(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> MultiplyWideningUpperAndAdd(Vector128`1<long> addend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> MultiplyWideningUpperAndAdd(Vector128`1<short> addend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<UInt32> MultiplyWideningUpperAndAdd(Vector128`1<UInt32> addend, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> MultiplyWideningUpperAndAdd(Vector128`1<ulong> addend, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> MultiplyWideningUpperAndSubtract(Vector128`1<ushort> minuend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> MultiplyWideningUpperAndSubtract(Vector128`1<int> minuend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<long> MultiplyWideningUpperAndSubtract(Vector128`1<long> minuend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> MultiplyWideningUpperAndSubtract(Vector128`1<short> minuend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<UInt32> MultiplyWideningUpperAndSubtract(Vector128`1<UInt32> minuend, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> MultiplyWideningUpperAndSubtract(Vector128`1<ulong> minuend, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<short> Negate(Vector64`1<short> value);
    public static Vector64`1<int> Negate(Vector64`1<int> value);
    public static Vector64`1<sbyte> Negate(Vector64`1<sbyte> value);
    public static Vector64`1<float> Negate(Vector64`1<float> value);
    public static Vector128`1<short> Negate(Vector128`1<short> value);
    public static Vector128`1<int> Negate(Vector128`1<int> value);
    public static Vector128`1<sbyte> Negate(Vector128`1<sbyte> value);
    public static Vector128`1<float> Negate(Vector128`1<float> value);
    public static Vector64`1<short> NegateSaturate(Vector64`1<short> value);
    public static Vector64`1<int> NegateSaturate(Vector64`1<int> value);
    public static Vector64`1<sbyte> NegateSaturate(Vector64`1<sbyte> value);
    public static Vector128`1<short> NegateSaturate(Vector128`1<short> value);
    public static Vector128`1<int> NegateSaturate(Vector128`1<int> value);
    public static Vector128`1<sbyte> NegateSaturate(Vector128`1<sbyte> value);
    public static Vector64`1<double> NegateScalar(Vector64`1<double> value);
    public static Vector64`1<float> NegateScalar(Vector64`1<float> value);
    public static Vector64`1<byte> Not(Vector64`1<byte> value);
    public static Vector64`1<double> Not(Vector64`1<double> value);
    public static Vector64`1<short> Not(Vector64`1<short> value);
    public static Vector64`1<int> Not(Vector64`1<int> value);
    public static Vector64`1<long> Not(Vector64`1<long> value);
    public static Vector64`1<sbyte> Not(Vector64`1<sbyte> value);
    public static Vector64`1<float> Not(Vector64`1<float> value);
    public static Vector64`1<ushort> Not(Vector64`1<ushort> value);
    public static Vector64`1<UInt32> Not(Vector64`1<UInt32> value);
    public static Vector64`1<ulong> Not(Vector64`1<ulong> value);
    public static Vector128`1<byte> Not(Vector128`1<byte> value);
    public static Vector128`1<double> Not(Vector128`1<double> value);
    public static Vector128`1<short> Not(Vector128`1<short> value);
    public static Vector128`1<int> Not(Vector128`1<int> value);
    public static Vector128`1<long> Not(Vector128`1<long> value);
    public static Vector128`1<sbyte> Not(Vector128`1<sbyte> value);
    public static Vector128`1<float> Not(Vector128`1<float> value);
    public static Vector128`1<ushort> Not(Vector128`1<ushort> value);
    public static Vector128`1<UInt32> Not(Vector128`1<UInt32> value);
    public static Vector128`1<ulong> Not(Vector128`1<ulong> value);
    public static Vector64`1<byte> Or(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<double> Or(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<short> Or(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Or(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<long> Or(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<sbyte> Or(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Or(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Or(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Or(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<ulong> Or(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<byte> Or(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<double> Or(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> Or(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Or(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> Or(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> Or(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Or(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Or(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Or(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> Or(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> OrNot(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<double> OrNot(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<short> OrNot(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> OrNot(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<long> OrNot(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<sbyte> OrNot(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> OrNot(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> OrNot(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> OrNot(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<ulong> OrNot(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<byte> OrNot(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<double> OrNot(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> OrNot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> OrNot(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> OrNot(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> OrNot(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> OrNot(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> OrNot(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> OrNot(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> OrNot(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> PolynomialMultiply(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<sbyte> PolynomialMultiply(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<byte> PolynomialMultiply(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> PolynomialMultiply(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> PolynomialMultiplyWideningLower(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<short> PolynomialMultiplyWideningLower(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<ushort> PolynomialMultiplyWideningUpper(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> PolynomialMultiplyWideningUpper(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector64`1<byte> PopCount(Vector64`1<byte> value);
    public static Vector64`1<sbyte> PopCount(Vector64`1<sbyte> value);
    public static Vector128`1<byte> PopCount(Vector128`1<byte> value);
    public static Vector128`1<sbyte> PopCount(Vector128`1<sbyte> value);
    public static Vector64`1<float> ReciprocalEstimate(Vector64`1<float> value);
    public static Vector64`1<UInt32> ReciprocalEstimate(Vector64`1<UInt32> value);
    public static Vector128`1<float> ReciprocalEstimate(Vector128`1<float> value);
    public static Vector128`1<UInt32> ReciprocalEstimate(Vector128`1<UInt32> value);
    public static Vector64`1<float> ReciprocalSquareRootEstimate(Vector64`1<float> value);
    public static Vector64`1<UInt32> ReciprocalSquareRootEstimate(Vector64`1<UInt32> value);
    public static Vector128`1<float> ReciprocalSquareRootEstimate(Vector128`1<float> value);
    public static Vector128`1<UInt32> ReciprocalSquareRootEstimate(Vector128`1<UInt32> value);
    public static Vector64`1<float> ReciprocalSquareRootStep(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> ReciprocalSquareRootStep(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<float> ReciprocalStep(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector128`1<float> ReciprocalStep(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector64`1<int> ReverseElement16(Vector64`1<int> value);
    public static Vector64`1<long> ReverseElement16(Vector64`1<long> value);
    public static Vector64`1<UInt32> ReverseElement16(Vector64`1<UInt32> value);
    public static Vector64`1<ulong> ReverseElement16(Vector64`1<ulong> value);
    public static Vector128`1<int> ReverseElement16(Vector128`1<int> value);
    public static Vector128`1<long> ReverseElement16(Vector128`1<long> value);
    public static Vector128`1<UInt32> ReverseElement16(Vector128`1<UInt32> value);
    public static Vector128`1<ulong> ReverseElement16(Vector128`1<ulong> value);
    public static Vector64`1<long> ReverseElement32(Vector64`1<long> value);
    public static Vector64`1<ulong> ReverseElement32(Vector64`1<ulong> value);
    public static Vector128`1<long> ReverseElement32(Vector128`1<long> value);
    public static Vector128`1<ulong> ReverseElement32(Vector128`1<ulong> value);
    public static Vector64`1<short> ReverseElement8(Vector64`1<short> value);
    public static Vector64`1<int> ReverseElement8(Vector64`1<int> value);
    public static Vector64`1<long> ReverseElement8(Vector64`1<long> value);
    public static Vector64`1<ushort> ReverseElement8(Vector64`1<ushort> value);
    public static Vector64`1<UInt32> ReverseElement8(Vector64`1<UInt32> value);
    public static Vector64`1<ulong> ReverseElement8(Vector64`1<ulong> value);
    public static Vector128`1<short> ReverseElement8(Vector128`1<short> value);
    public static Vector128`1<int> ReverseElement8(Vector128`1<int> value);
    public static Vector128`1<long> ReverseElement8(Vector128`1<long> value);
    public static Vector128`1<ushort> ReverseElement8(Vector128`1<ushort> value);
    public static Vector128`1<UInt32> ReverseElement8(Vector128`1<UInt32> value);
    public static Vector128`1<ulong> ReverseElement8(Vector128`1<ulong> value);
    public static Vector64`1<float> RoundAwayFromZero(Vector64`1<float> value);
    public static Vector128`1<float> RoundAwayFromZero(Vector128`1<float> value);
    public static Vector64`1<double> RoundAwayFromZeroScalar(Vector64`1<double> value);
    public static Vector64`1<float> RoundAwayFromZeroScalar(Vector64`1<float> value);
    public static Vector64`1<float> RoundToNearest(Vector64`1<float> value);
    public static Vector128`1<float> RoundToNearest(Vector128`1<float> value);
    public static Vector64`1<double> RoundToNearestScalar(Vector64`1<double> value);
    public static Vector64`1<float> RoundToNearestScalar(Vector64`1<float> value);
    public static Vector64`1<float> RoundToNegativeInfinity(Vector64`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector64`1<double> RoundToNegativeInfinityScalar(Vector64`1<double> value);
    public static Vector64`1<float> RoundToNegativeInfinityScalar(Vector64`1<float> value);
    public static Vector64`1<float> RoundToPositiveInfinity(Vector64`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector64`1<double> RoundToPositiveInfinityScalar(Vector64`1<double> value);
    public static Vector64`1<float> RoundToPositiveInfinityScalar(Vector64`1<float> value);
    public static Vector64`1<float> RoundToZero(Vector64`1<float> value);
    public static Vector128`1<float> RoundToZero(Vector128`1<float> value);
    public static Vector64`1<double> RoundToZeroScalar(Vector64`1<double> value);
    public static Vector64`1<float> RoundToZeroScalar(Vector64`1<float> value);
    public static Vector64`1<short> ShiftArithmetic(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftArithmetic(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftArithmetic(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector128`1<short> ShiftArithmetic(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftArithmetic(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftArithmetic(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftArithmetic(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector64`1<short> ShiftArithmeticRounded(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftArithmeticRounded(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftArithmeticRounded(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector128`1<short> ShiftArithmeticRounded(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftArithmeticRounded(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftArithmeticRounded(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftArithmeticRounded(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector64`1<short> ShiftArithmeticRoundedSaturate(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftArithmeticRoundedSaturate(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftArithmeticRoundedSaturate(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector128`1<short> ShiftArithmeticRoundedSaturate(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftArithmeticRoundedSaturate(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftArithmeticRoundedSaturate(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftArithmeticRoundedSaturate(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector64`1<long> ShiftArithmeticRoundedSaturateScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<long> ShiftArithmeticRoundedScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<short> ShiftArithmeticSaturate(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftArithmeticSaturate(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftArithmeticSaturate(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector128`1<short> ShiftArithmeticSaturate(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftArithmeticSaturate(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftArithmeticSaturate(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftArithmeticSaturate(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector64`1<long> ShiftArithmeticSaturateScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<long> ShiftArithmeticScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<byte> ShiftLeftAndInsert(Vector64`1<byte> left, Vector64`1<byte> right, byte shift);
    public static Vector64`1<short> ShiftLeftAndInsert(Vector64`1<short> left, Vector64`1<short> right, byte shift);
    public static Vector64`1<int> ShiftLeftAndInsert(Vector64`1<int> left, Vector64`1<int> right, byte shift);
    public static Vector64`1<sbyte> ShiftLeftAndInsert(Vector64`1<sbyte> left, Vector64`1<sbyte> right, byte shift);
    public static Vector64`1<ushort> ShiftLeftAndInsert(Vector64`1<ushort> left, Vector64`1<ushort> right, byte shift);
    public static Vector64`1<UInt32> ShiftLeftAndInsert(Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte shift);
    public static Vector128`1<byte> ShiftLeftAndInsert(Vector128`1<byte> left, Vector128`1<byte> right, byte shift);
    public static Vector128`1<short> ShiftLeftAndInsert(Vector128`1<short> left, Vector128`1<short> right, byte shift);
    public static Vector128`1<int> ShiftLeftAndInsert(Vector128`1<int> left, Vector128`1<int> right, byte shift);
    public static Vector128`1<long> ShiftLeftAndInsert(Vector128`1<long> left, Vector128`1<long> right, byte shift);
    public static Vector128`1<sbyte> ShiftLeftAndInsert(Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte shift);
    public static Vector128`1<ushort> ShiftLeftAndInsert(Vector128`1<ushort> left, Vector128`1<ushort> right, byte shift);
    public static Vector128`1<UInt32> ShiftLeftAndInsert(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte shift);
    public static Vector128`1<ulong> ShiftLeftAndInsert(Vector128`1<ulong> left, Vector128`1<ulong> right, byte shift);
    public static Vector64`1<long> ShiftLeftAndInsertScalar(Vector64`1<long> left, Vector64`1<long> right, byte shift);
    public static Vector64`1<ulong> ShiftLeftAndInsertScalar(Vector64`1<ulong> left, Vector64`1<ulong> right, byte shift);
    public static Vector64`1<byte> ShiftLeftLogical(Vector64`1<byte> value, byte count);
    public static Vector64`1<short> ShiftLeftLogical(Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftLeftLogical(Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftLeftLogical(Vector64`1<sbyte> value, byte count);
    public static Vector64`1<ushort> ShiftLeftLogical(Vector64`1<ushort> value, byte count);
    public static Vector64`1<UInt32> ShiftLeftLogical(Vector64`1<UInt32> value, byte count);
    public static Vector128`1<byte> ShiftLeftLogical(Vector128`1<byte> value, byte count);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftLeftLogical(Vector128`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftLeftLogicalSaturate(Vector64`1<byte> value, byte count);
    public static Vector64`1<short> ShiftLeftLogicalSaturate(Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftLeftLogicalSaturate(Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftLeftLogicalSaturate(Vector64`1<sbyte> value, byte count);
    public static Vector64`1<ushort> ShiftLeftLogicalSaturate(Vector64`1<ushort> value, byte count);
    public static Vector64`1<UInt32> ShiftLeftLogicalSaturate(Vector64`1<UInt32> value, byte count);
    public static Vector128`1<byte> ShiftLeftLogicalSaturate(Vector128`1<byte> value, byte count);
    public static Vector128`1<short> ShiftLeftLogicalSaturate(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftLeftLogicalSaturate(Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftLeftLogicalSaturate(Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftLeftLogicalSaturate(Vector128`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogicalSaturate(Vector128`1<ushort> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogicalSaturate(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogicalSaturate(Vector128`1<ulong> value, byte count);
    public static Vector64`1<long> ShiftLeftLogicalSaturateScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<ulong> ShiftLeftLogicalSaturateScalar(Vector64`1<ulong> value, byte count);
    public static Vector64`1<ushort> ShiftLeftLogicalSaturateUnsigned(Vector64`1<short> value, byte count);
    public static Vector64`1<UInt32> ShiftLeftLogicalSaturateUnsigned(Vector64`1<int> value, byte count);
    public static Vector64`1<byte> ShiftLeftLogicalSaturateUnsigned(Vector64`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogicalSaturateUnsigned(Vector128`1<short> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogicalSaturateUnsigned(Vector128`1<int> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogicalSaturateUnsigned(Vector128`1<long> value, byte count);
    public static Vector128`1<byte> ShiftLeftLogicalSaturateUnsigned(Vector128`1<sbyte> value, byte count);
    public static Vector64`1<ulong> ShiftLeftLogicalSaturateUnsignedScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<long> ShiftLeftLogicalScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<ulong> ShiftLeftLogicalScalar(Vector64`1<ulong> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogicalWideningLower(Vector64`1<byte> value, byte count);
    public static Vector128`1<int> ShiftLeftLogicalWideningLower(Vector64`1<short> value, byte count);
    public static Vector128`1<long> ShiftLeftLogicalWideningLower(Vector64`1<int> value, byte count);
    public static Vector128`1<short> ShiftLeftLogicalWideningLower(Vector64`1<sbyte> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogicalWideningLower(Vector64`1<ushort> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogicalWideningLower(Vector64`1<UInt32> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogicalWideningUpper(Vector128`1<byte> value, byte count);
    public static Vector128`1<int> ShiftLeftLogicalWideningUpper(Vector128`1<short> value, byte count);
    public static Vector128`1<long> ShiftLeftLogicalWideningUpper(Vector128`1<int> value, byte count);
    public static Vector128`1<short> ShiftLeftLogicalWideningUpper(Vector128`1<sbyte> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogicalWideningUpper(Vector128`1<ushort> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogicalWideningUpper(Vector128`1<UInt32> value, byte count);
    public static Vector64`1<byte> ShiftLogical(Vector64`1<byte> value, Vector64`1<sbyte> count);
    public static Vector64`1<short> ShiftLogical(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftLogical(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftLogical(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector64`1<ushort> ShiftLogical(Vector64`1<ushort> value, Vector64`1<short> count);
    public static Vector64`1<UInt32> ShiftLogical(Vector64`1<UInt32> value, Vector64`1<int> count);
    public static Vector128`1<byte> ShiftLogical(Vector128`1<byte> value, Vector128`1<sbyte> count);
    public static Vector128`1<short> ShiftLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftLogical(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector128`1<ushort> ShiftLogical(Vector128`1<ushort> value, Vector128`1<short> count);
    public static Vector128`1<UInt32> ShiftLogical(Vector128`1<UInt32> value, Vector128`1<int> count);
    public static Vector128`1<ulong> ShiftLogical(Vector128`1<ulong> value, Vector128`1<long> count);
    public static Vector64`1<byte> ShiftLogicalRounded(Vector64`1<byte> value, Vector64`1<sbyte> count);
    public static Vector64`1<short> ShiftLogicalRounded(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftLogicalRounded(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftLogicalRounded(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector64`1<ushort> ShiftLogicalRounded(Vector64`1<ushort> value, Vector64`1<short> count);
    public static Vector64`1<UInt32> ShiftLogicalRounded(Vector64`1<UInt32> value, Vector64`1<int> count);
    public static Vector128`1<byte> ShiftLogicalRounded(Vector128`1<byte> value, Vector128`1<sbyte> count);
    public static Vector128`1<short> ShiftLogicalRounded(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftLogicalRounded(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftLogicalRounded(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftLogicalRounded(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector128`1<ushort> ShiftLogicalRounded(Vector128`1<ushort> value, Vector128`1<short> count);
    public static Vector128`1<UInt32> ShiftLogicalRounded(Vector128`1<UInt32> value, Vector128`1<int> count);
    public static Vector128`1<ulong> ShiftLogicalRounded(Vector128`1<ulong> value, Vector128`1<long> count);
    public static Vector64`1<byte> ShiftLogicalRoundedSaturate(Vector64`1<byte> value, Vector64`1<sbyte> count);
    public static Vector64`1<short> ShiftLogicalRoundedSaturate(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftLogicalRoundedSaturate(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftLogicalRoundedSaturate(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector64`1<ushort> ShiftLogicalRoundedSaturate(Vector64`1<ushort> value, Vector64`1<short> count);
    public static Vector64`1<UInt32> ShiftLogicalRoundedSaturate(Vector64`1<UInt32> value, Vector64`1<int> count);
    public static Vector128`1<byte> ShiftLogicalRoundedSaturate(Vector128`1<byte> value, Vector128`1<sbyte> count);
    public static Vector128`1<short> ShiftLogicalRoundedSaturate(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftLogicalRoundedSaturate(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftLogicalRoundedSaturate(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftLogicalRoundedSaturate(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector128`1<ushort> ShiftLogicalRoundedSaturate(Vector128`1<ushort> value, Vector128`1<short> count);
    public static Vector128`1<UInt32> ShiftLogicalRoundedSaturate(Vector128`1<UInt32> value, Vector128`1<int> count);
    public static Vector128`1<ulong> ShiftLogicalRoundedSaturate(Vector128`1<ulong> value, Vector128`1<long> count);
    public static Vector64`1<long> ShiftLogicalRoundedSaturateScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<ulong> ShiftLogicalRoundedSaturateScalar(Vector64`1<ulong> value, Vector64`1<long> count);
    public static Vector64`1<long> ShiftLogicalRoundedScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<ulong> ShiftLogicalRoundedScalar(Vector64`1<ulong> value, Vector64`1<long> count);
    public static Vector64`1<byte> ShiftLogicalSaturate(Vector64`1<byte> value, Vector64`1<sbyte> count);
    public static Vector64`1<short> ShiftLogicalSaturate(Vector64`1<short> value, Vector64`1<short> count);
    public static Vector64`1<int> ShiftLogicalSaturate(Vector64`1<int> value, Vector64`1<int> count);
    public static Vector64`1<sbyte> ShiftLogicalSaturate(Vector64`1<sbyte> value, Vector64`1<sbyte> count);
    public static Vector64`1<ushort> ShiftLogicalSaturate(Vector64`1<ushort> value, Vector64`1<short> count);
    public static Vector64`1<UInt32> ShiftLogicalSaturate(Vector64`1<UInt32> value, Vector64`1<int> count);
    public static Vector128`1<byte> ShiftLogicalSaturate(Vector128`1<byte> value, Vector128`1<sbyte> count);
    public static Vector128`1<short> ShiftLogicalSaturate(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftLogicalSaturate(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<long> ShiftLogicalSaturate(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<sbyte> ShiftLogicalSaturate(Vector128`1<sbyte> value, Vector128`1<sbyte> count);
    public static Vector128`1<ushort> ShiftLogicalSaturate(Vector128`1<ushort> value, Vector128`1<short> count);
    public static Vector128`1<UInt32> ShiftLogicalSaturate(Vector128`1<UInt32> value, Vector128`1<int> count);
    public static Vector128`1<ulong> ShiftLogicalSaturate(Vector128`1<ulong> value, Vector128`1<long> count);
    public static Vector64`1<long> ShiftLogicalSaturateScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<ulong> ShiftLogicalSaturateScalar(Vector64`1<ulong> value, Vector64`1<long> count);
    public static Vector64`1<long> ShiftLogicalScalar(Vector64`1<long> value, Vector64`1<long> count);
    public static Vector64`1<ulong> ShiftLogicalScalar(Vector64`1<ulong> value, Vector64`1<long> count);
    public static Vector64`1<byte> ShiftRightAndInsert(Vector64`1<byte> left, Vector64`1<byte> right, byte shift);
    public static Vector64`1<short> ShiftRightAndInsert(Vector64`1<short> left, Vector64`1<short> right, byte shift);
    public static Vector64`1<int> ShiftRightAndInsert(Vector64`1<int> left, Vector64`1<int> right, byte shift);
    public static Vector64`1<sbyte> ShiftRightAndInsert(Vector64`1<sbyte> left, Vector64`1<sbyte> right, byte shift);
    public static Vector64`1<ushort> ShiftRightAndInsert(Vector64`1<ushort> left, Vector64`1<ushort> right, byte shift);
    public static Vector64`1<UInt32> ShiftRightAndInsert(Vector64`1<UInt32> left, Vector64`1<UInt32> right, byte shift);
    public static Vector128`1<byte> ShiftRightAndInsert(Vector128`1<byte> left, Vector128`1<byte> right, byte shift);
    public static Vector128`1<short> ShiftRightAndInsert(Vector128`1<short> left, Vector128`1<short> right, byte shift);
    public static Vector128`1<int> ShiftRightAndInsert(Vector128`1<int> left, Vector128`1<int> right, byte shift);
    public static Vector128`1<long> ShiftRightAndInsert(Vector128`1<long> left, Vector128`1<long> right, byte shift);
    public static Vector128`1<sbyte> ShiftRightAndInsert(Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte shift);
    public static Vector128`1<ushort> ShiftRightAndInsert(Vector128`1<ushort> left, Vector128`1<ushort> right, byte shift);
    public static Vector128`1<UInt32> ShiftRightAndInsert(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte shift);
    public static Vector128`1<ulong> ShiftRightAndInsert(Vector128`1<ulong> left, Vector128`1<ulong> right, byte shift);
    public static Vector64`1<long> ShiftRightAndInsertScalar(Vector64`1<long> left, Vector64`1<long> right, byte shift);
    public static Vector64`1<ulong> ShiftRightAndInsertScalar(Vector64`1<ulong> left, Vector64`1<ulong> right, byte shift);
    public static Vector64`1<short> ShiftRightArithmetic(Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightArithmetic(Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightArithmetic(Vector64`1<sbyte> value, byte count);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightArithmetic(Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightArithmetic(Vector128`1<sbyte> value, byte count);
    public static Vector64`1<short> ShiftRightArithmeticAdd(Vector64`1<short> addend, Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightArithmeticAdd(Vector64`1<int> addend, Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightArithmeticAdd(Vector64`1<sbyte> addend, Vector64`1<sbyte> value, byte count);
    public static Vector128`1<short> ShiftRightArithmeticAdd(Vector128`1<short> addend, Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmeticAdd(Vector128`1<int> addend, Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightArithmeticAdd(Vector128`1<long> addend, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightArithmeticAdd(Vector128`1<sbyte> addend, Vector128`1<sbyte> value, byte count);
    public static Vector64`1<long> ShiftRightArithmeticAddScalar(Vector64`1<long> addend, Vector64`1<long> value, byte count);
    public static Vector64`1<short> ShiftRightArithmeticNarrowingSaturateLower(Vector128`1<int> value, byte count);
    public static Vector64`1<int> ShiftRightArithmeticNarrowingSaturateLower(Vector128`1<long> value, byte count);
    public static Vector64`1<sbyte> ShiftRightArithmeticNarrowingSaturateLower(Vector128`1<short> value, byte count);
    public static Vector64`1<byte> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128`1<short> value, byte count);
    public static Vector64`1<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128`1<int> value, byte count);
    public static Vector64`1<UInt32> ShiftRightArithmeticNarrowingSaturateUnsignedLower(Vector128`1<long> value, byte count);
    public static Vector128`1<byte> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64`1<byte> lower, Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64`1<ushort> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftRightArithmeticNarrowingSaturateUnsignedUpper(Vector64`1<UInt32> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<short> ShiftRightArithmeticNarrowingSaturateUpper(Vector64`1<short> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightArithmeticNarrowingSaturateUpper(Vector64`1<int> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightArithmeticNarrowingSaturateUpper(Vector64`1<sbyte> lower, Vector128`1<short> value, byte count);
    public static Vector64`1<short> ShiftRightArithmeticRounded(Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightArithmeticRounded(Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightArithmeticRounded(Vector64`1<sbyte> value, byte count);
    public static Vector128`1<short> ShiftRightArithmeticRounded(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmeticRounded(Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightArithmeticRounded(Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightArithmeticRounded(Vector128`1<sbyte> value, byte count);
    public static Vector64`1<short> ShiftRightArithmeticRoundedAdd(Vector64`1<short> addend, Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightArithmeticRoundedAdd(Vector64`1<int> addend, Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightArithmeticRoundedAdd(Vector64`1<sbyte> addend, Vector64`1<sbyte> value, byte count);
    public static Vector128`1<short> ShiftRightArithmeticRoundedAdd(Vector128`1<short> addend, Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmeticRoundedAdd(Vector128`1<int> addend, Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightArithmeticRoundedAdd(Vector128`1<long> addend, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightArithmeticRoundedAdd(Vector128`1<sbyte> addend, Vector128`1<sbyte> value, byte count);
    public static Vector64`1<long> ShiftRightArithmeticRoundedAddScalar(Vector64`1<long> addend, Vector64`1<long> value, byte count);
    public static Vector64`1<short> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128`1<int> value, byte count);
    public static Vector64`1<int> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128`1<long> value, byte count);
    public static Vector64`1<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateLower(Vector128`1<short> value, byte count);
    public static Vector64`1<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128`1<short> value, byte count);
    public static Vector64`1<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128`1<int> value, byte count);
    public static Vector64`1<UInt32> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedLower(Vector128`1<long> value, byte count);
    public static Vector128`1<byte> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64`1<byte> lower, Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64`1<ushort> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftRightArithmeticRoundedNarrowingSaturateUnsignedUpper(Vector64`1<UInt32> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<short> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64`1<short> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64`1<int> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightArithmeticRoundedNarrowingSaturateUpper(Vector64`1<sbyte> lower, Vector128`1<short> value, byte count);
    public static Vector64`1<long> ShiftRightArithmeticRoundedScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<long> ShiftRightArithmeticScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<byte> ShiftRightLogical(Vector64`1<byte> value, byte count);
    public static Vector64`1<short> ShiftRightLogical(Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightLogical(Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogical(Vector64`1<sbyte> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogical(Vector64`1<ushort> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogical(Vector64`1<UInt32> value, byte count);
    public static Vector128`1<byte> ShiftRightLogical(Vector128`1<byte> value, byte count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogical(Vector128`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalAdd(Vector64`1<byte> addend, Vector64`1<byte> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalAdd(Vector64`1<short> addend, Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalAdd(Vector64`1<int> addend, Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalAdd(Vector64`1<sbyte> addend, Vector64`1<sbyte> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalAdd(Vector64`1<ushort> addend, Vector64`1<ushort> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalAdd(Vector64`1<UInt32> addend, Vector64`1<UInt32> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalAdd(Vector128`1<byte> addend, Vector128`1<byte> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalAdd(Vector128`1<short> addend, Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalAdd(Vector128`1<int> addend, Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightLogicalAdd(Vector128`1<long> addend, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalAdd(Vector128`1<sbyte> addend, Vector128`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalAdd(Vector128`1<ushort> addend, Vector128`1<ushort> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalAdd(Vector128`1<UInt32> addend, Vector128`1<UInt32> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogicalAdd(Vector128`1<ulong> addend, Vector128`1<ulong> value, byte count);
    public static Vector64`1<long> ShiftRightLogicalAddScalar(Vector64`1<long> addend, Vector64`1<long> value, byte count);
    public static Vector64`1<ulong> ShiftRightLogicalAddScalar(Vector64`1<ulong> addend, Vector64`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalNarrowingLower(Vector128`1<ushort> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalNarrowingLower(Vector128`1<int> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalNarrowingLower(Vector128`1<long> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalNarrowingLower(Vector128`1<short> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalNarrowingLower(Vector128`1<UInt32> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalNarrowingLower(Vector128`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalNarrowingSaturateLower(Vector128`1<ushort> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalNarrowingSaturateLower(Vector128`1<int> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalNarrowingSaturateLower(Vector128`1<long> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalNarrowingSaturateLower(Vector128`1<short> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalNarrowingSaturateLower(Vector128`1<UInt32> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalNarrowingSaturateLower(Vector128`1<ulong> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalNarrowingSaturateUpper(Vector64`1<byte> lower, Vector128`1<ushort> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalNarrowingSaturateUpper(Vector64`1<short> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalNarrowingSaturateUpper(Vector64`1<int> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalNarrowingSaturateUpper(Vector64`1<sbyte> lower, Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalNarrowingSaturateUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalNarrowingSaturateUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalRounded(Vector64`1<byte> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalRounded(Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalRounded(Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalRounded(Vector64`1<sbyte> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalRounded(Vector64`1<ushort> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalRounded(Vector64`1<UInt32> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalRounded(Vector128`1<byte> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalRounded(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalRounded(Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightLogicalRounded(Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalRounded(Vector128`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalRounded(Vector128`1<ushort> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalRounded(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogicalRounded(Vector128`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalRoundedAdd(Vector64`1<byte> addend, Vector64`1<byte> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalRoundedAdd(Vector64`1<short> addend, Vector64`1<short> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalRoundedAdd(Vector64`1<int> addend, Vector64`1<int> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalRoundedAdd(Vector64`1<sbyte> addend, Vector64`1<sbyte> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalRoundedAdd(Vector64`1<ushort> addend, Vector64`1<ushort> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalRoundedAdd(Vector64`1<UInt32> addend, Vector64`1<UInt32> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalRoundedAdd(Vector128`1<byte> addend, Vector128`1<byte> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalRoundedAdd(Vector128`1<short> addend, Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalRoundedAdd(Vector128`1<int> addend, Vector128`1<int> value, byte count);
    public static Vector128`1<long> ShiftRightLogicalRoundedAdd(Vector128`1<long> addend, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalRoundedAdd(Vector128`1<sbyte> addend, Vector128`1<sbyte> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalRoundedAdd(Vector128`1<ushort> addend, Vector128`1<ushort> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalRoundedAdd(Vector128`1<UInt32> addend, Vector128`1<UInt32> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogicalRoundedAdd(Vector128`1<ulong> addend, Vector128`1<ulong> value, byte count);
    public static Vector64`1<long> ShiftRightLogicalRoundedAddScalar(Vector64`1<long> addend, Vector64`1<long> value, byte count);
    public static Vector64`1<ulong> ShiftRightLogicalRoundedAddScalar(Vector64`1<ulong> addend, Vector64`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalRoundedNarrowingLower(Vector128`1<ushort> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalRoundedNarrowingLower(Vector128`1<int> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalRoundedNarrowingLower(Vector128`1<long> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalRoundedNarrowingLower(Vector128`1<short> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalRoundedNarrowingLower(Vector128`1<UInt32> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalRoundedNarrowingLower(Vector128`1<ulong> value, byte count);
    public static Vector64`1<byte> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128`1<ushort> value, byte count);
    public static Vector64`1<short> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128`1<int> value, byte count);
    public static Vector64`1<int> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128`1<long> value, byte count);
    public static Vector64`1<sbyte> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128`1<short> value, byte count);
    public static Vector64`1<ushort> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128`1<UInt32> value, byte count);
    public static Vector64`1<UInt32> ShiftRightLogicalRoundedNarrowingSaturateLower(Vector128`1<ulong> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64`1<byte> lower, Vector128`1<ushort> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64`1<short> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64`1<int> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64`1<sbyte> lower, Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalRoundedNarrowingSaturateUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> value, byte count);
    public static Vector128`1<byte> ShiftRightLogicalRoundedNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> value, byte count);
    public static Vector128`1<short> ShiftRightLogicalRoundedNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightLogicalRoundedNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogicalRoundedNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogicalRoundedNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogicalRoundedNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> value, byte count);
    public static Vector64`1<long> ShiftRightLogicalRoundedScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<ulong> ShiftRightLogicalRoundedScalar(Vector64`1<ulong> value, byte count);
    public static Vector64`1<long> ShiftRightLogicalScalar(Vector64`1<long> value, byte count);
    public static Vector64`1<ulong> ShiftRightLogicalScalar(Vector64`1<ulong> value, byte count);
    public static Vector128`1<int> SignExtendWideningLower(Vector64`1<short> value);
    public static Vector128`1<long> SignExtendWideningLower(Vector64`1<int> value);
    public static Vector128`1<short> SignExtendWideningLower(Vector64`1<sbyte> value);
    public static Vector128`1<int> SignExtendWideningUpper(Vector128`1<short> value);
    public static Vector128`1<long> SignExtendWideningUpper(Vector128`1<int> value);
    public static Vector128`1<short> SignExtendWideningUpper(Vector128`1<sbyte> value);
    public static Vector64`1<double> SqrtScalar(Vector64`1<double> value);
    public static Vector64`1<float> SqrtScalar(Vector64`1<float> value);
    public static void Store(Byte* address, Vector64`1<byte> source);
    public static void Store(Double* address, Vector64`1<double> source);
    public static void Store(Int16* address, Vector64`1<short> source);
    public static void Store(Int32* address, Vector64`1<int> source);
    public static void Store(Int64* address, Vector64`1<long> source);
    public static void Store(SByte* address, Vector64`1<sbyte> source);
    public static void Store(Single* address, Vector64`1<float> source);
    public static void Store(UInt16* address, Vector64`1<ushort> source);
    public static void Store(UInt32* address, Vector64`1<UInt32> source);
    public static void Store(UInt64* address, Vector64`1<ulong> source);
    public static void Store(Byte* address, Vector128`1<byte> source);
    public static void Store(Double* address, Vector128`1<double> source);
    public static void Store(Int16* address, Vector128`1<short> source);
    public static void Store(Int32* address, Vector128`1<int> source);
    public static void Store(Int64* address, Vector128`1<long> source);
    public static void Store(SByte* address, Vector128`1<sbyte> source);
    public static void Store(Single* address, Vector128`1<float> source);
    public static void Store(UInt16* address, Vector128`1<ushort> source);
    public static void Store(UInt32* address, Vector128`1<UInt32> source);
    public static void Store(UInt64* address, Vector128`1<ulong> source);
    public static void StoreSelectedScalar(Byte* address, Vector64`1<byte> value, byte index);
    public static void StoreSelectedScalar(Int16* address, Vector64`1<short> value, byte index);
    public static void StoreSelectedScalar(Int32* address, Vector64`1<int> value, byte index);
    public static void StoreSelectedScalar(SByte* address, Vector64`1<sbyte> value, byte index);
    public static void StoreSelectedScalar(Single* address, Vector64`1<float> value, byte index);
    public static void StoreSelectedScalar(UInt16* address, Vector64`1<ushort> value, byte index);
    public static void StoreSelectedScalar(UInt32* address, Vector64`1<UInt32> value, byte index);
    public static void StoreSelectedScalar(Byte* address, Vector128`1<byte> value, byte index);
    public static void StoreSelectedScalar(Double* address, Vector128`1<double> value, byte index);
    public static void StoreSelectedScalar(Int16* address, Vector128`1<short> value, byte index);
    public static void StoreSelectedScalar(Int32* address, Vector128`1<int> value, byte index);
    public static void StoreSelectedScalar(Int64* address, Vector128`1<long> value, byte index);
    public static void StoreSelectedScalar(SByte* address, Vector128`1<sbyte> value, byte index);
    public static void StoreSelectedScalar(Single* address, Vector128`1<float> value, byte index);
    public static void StoreSelectedScalar(UInt16* address, Vector128`1<ushort> value, byte index);
    public static void StoreSelectedScalar(UInt32* address, Vector128`1<UInt32> value, byte index);
    public static void StoreSelectedScalar(UInt64* address, Vector128`1<ulong> value, byte index);
    public static Vector64`1<byte> Subtract(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> Subtract(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Subtract(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> Subtract(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Subtract(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Subtract(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Subtract(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> Subtract(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Subtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Subtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> Subtract(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> Subtract(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Subtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Subtract(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Subtract(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> Subtract(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> SubtractHighNarrowingLower(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector64`1<short> SubtractHighNarrowingLower(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<int> SubtractHighNarrowingLower(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector64`1<sbyte> SubtractHighNarrowingLower(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector64`1<ushort> SubtractHighNarrowingLower(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<UInt32> SubtractHighNarrowingLower(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<byte> SubtractHighNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> SubtractHighNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> SubtractHighNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> SubtractHighNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> SubtractHighNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<UInt32> SubtractHighNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> SubtractRoundedHighNarrowingLower(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector64`1<short> SubtractRoundedHighNarrowingLower(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<int> SubtractRoundedHighNarrowingLower(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector64`1<sbyte> SubtractRoundedHighNarrowingLower(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector64`1<ushort> SubtractRoundedHighNarrowingLower(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector64`1<UInt32> SubtractRoundedHighNarrowingLower(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<byte> SubtractRoundedHighNarrowingUpper(Vector64`1<byte> lower, Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> SubtractRoundedHighNarrowingUpper(Vector64`1<short> lower, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> SubtractRoundedHighNarrowingUpper(Vector64`1<int> lower, Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> SubtractRoundedHighNarrowingUpper(Vector64`1<sbyte> lower, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> SubtractRoundedHighNarrowingUpper(Vector64`1<ushort> lower, Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<UInt32> SubtractRoundedHighNarrowingUpper(Vector64`1<UInt32> lower, Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<byte> SubtractSaturate(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<short> SubtractSaturate(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> SubtractSaturate(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<sbyte> SubtractSaturate(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<ushort> SubtractSaturate(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> SubtractSaturate(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> SubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> SubtractSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> SubtractSaturate(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> SubtractSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> SubtractSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> SubtractSaturate(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> SubtractSaturate(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector64`1<long> SubtractSaturateScalar(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<ulong> SubtractSaturateScalar(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector64`1<double> SubtractScalar(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<long> SubtractScalar(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<float> SubtractScalar(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ulong> SubtractScalar(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<ushort> SubtractWideningLower(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> SubtractWideningLower(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector128`1<long> SubtractWideningLower(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> SubtractWideningLower(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector128`1<UInt32> SubtractWideningLower(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> SubtractWideningLower(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector128`1<short> SubtractWideningLower(Vector128`1<short> left, Vector64`1<sbyte> right);
    public static Vector128`1<int> SubtractWideningLower(Vector128`1<int> left, Vector64`1<short> right);
    public static Vector128`1<long> SubtractWideningLower(Vector128`1<long> left, Vector64`1<int> right);
    public static Vector128`1<ushort> SubtractWideningLower(Vector128`1<ushort> left, Vector64`1<byte> right);
    public static Vector128`1<UInt32> SubtractWideningLower(Vector128`1<UInt32> left, Vector64`1<ushort> right);
    public static Vector128`1<ulong> SubtractWideningLower(Vector128`1<ulong> left, Vector64`1<UInt32> right);
    public static Vector128`1<ushort> SubtractWideningUpper(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> SubtractWideningUpper(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> SubtractWideningUpper(Vector128`1<short> left, Vector128`1<sbyte> right);
    public static Vector128`1<int> SubtractWideningUpper(Vector128`1<int> left, Vector128`1<short> right);
    public static Vector128`1<long> SubtractWideningUpper(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> SubtractWideningUpper(Vector128`1<long> left, Vector128`1<int> right);
    public static Vector128`1<short> SubtractWideningUpper(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> SubtractWideningUpper(Vector128`1<ushort> left, Vector128`1<byte> right);
    public static Vector128`1<UInt32> SubtractWideningUpper(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> SubtractWideningUpper(Vector128`1<UInt32> left, Vector128`1<ushort> right);
    public static Vector128`1<ulong> SubtractWideningUpper(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> SubtractWideningUpper(Vector128`1<ulong> left, Vector128`1<UInt32> right);
    public static Vector64`1<byte> VectorTableLookup(Vector128`1<byte> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookup(Vector128`1<sbyte> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookup(ValueTuple`2<Vector128`1<byte>, Vector128`1<byte>> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookup(ValueTuple`2<Vector128`1<sbyte>, Vector128`1<sbyte>> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookup(ValueTuple`3<Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookup(ValueTuple`3<Vector128`1<sbyte>, Vector128`1<sbyte>, Vector128`1<sbyte>> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookup(ValueTuple`4<Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookup(ValueTuple`4<Vector128`1<sbyte>, Vector128`1<sbyte>, Vector128`1<sbyte>, Vector128`1<sbyte>> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookupExtension(Vector64`1<byte> defaultValues, Vector128`1<byte> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookupExtension(Vector64`1<sbyte> defaultValues, Vector128`1<sbyte> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookupExtension(Vector64`1<byte> defaultValues, ValueTuple`2<Vector128`1<byte>, Vector128`1<byte>> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookupExtension(Vector64`1<sbyte> defaultValues, ValueTuple`2<Vector128`1<sbyte>, Vector128`1<sbyte>> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookupExtension(Vector64`1<byte> defaultValues, ValueTuple`3<Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookupExtension(Vector64`1<sbyte> defaultValues, ValueTuple`3<Vector128`1<sbyte>, Vector128`1<sbyte>, Vector128`1<sbyte>> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> VectorTableLookupExtension(Vector64`1<byte> defaultValues, ValueTuple`4<Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>, Vector128`1<byte>> table, Vector64`1<byte> byteIndexes);
    public static Vector64`1<sbyte> VectorTableLookupExtension(Vector64`1<sbyte> defaultValues, ValueTuple`4<Vector128`1<sbyte>, Vector128`1<sbyte>, Vector128`1<sbyte>, Vector128`1<sbyte>> table, Vector64`1<sbyte> byteIndexes);
    public static Vector64`1<byte> Xor(Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector64`1<double> Xor(Vector64`1<double> left, Vector64`1<double> right);
    public static Vector64`1<short> Xor(Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> Xor(Vector64`1<int> left, Vector64`1<int> right);
    public static Vector64`1<long> Xor(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector64`1<sbyte> Xor(Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<float> Xor(Vector64`1<float> left, Vector64`1<float> right);
    public static Vector64`1<ushort> Xor(Vector64`1<ushort> left, Vector64`1<ushort> right);
    public static Vector64`1<UInt32> Xor(Vector64`1<UInt32> left, Vector64`1<UInt32> right);
    public static Vector64`1<ulong> Xor(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<byte> Xor(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<double> Xor(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<short> Xor(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Xor(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<long> Xor(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<sbyte> Xor(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<float> Xor(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<ushort> Xor(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<UInt32> Xor(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ulong> Xor(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<ushort> ZeroExtendWideningLower(Vector64`1<byte> value);
    public static Vector128`1<int> ZeroExtendWideningLower(Vector64`1<short> value);
    public static Vector128`1<long> ZeroExtendWideningLower(Vector64`1<int> value);
    public static Vector128`1<short> ZeroExtendWideningLower(Vector64`1<sbyte> value);
    public static Vector128`1<UInt32> ZeroExtendWideningLower(Vector64`1<ushort> value);
    public static Vector128`1<ulong> ZeroExtendWideningLower(Vector64`1<UInt32> value);
    public static Vector128`1<ushort> ZeroExtendWideningUpper(Vector128`1<byte> value);
    public static Vector128`1<int> ZeroExtendWideningUpper(Vector128`1<short> value);
    public static Vector128`1<long> ZeroExtendWideningUpper(Vector128`1<int> value);
    public static Vector128`1<short> ZeroExtendWideningUpper(Vector128`1<sbyte> value);
    public static Vector128`1<UInt32> ZeroExtendWideningUpper(Vector128`1<ushort> value);
    public static Vector128`1<ulong> ZeroExtendWideningUpper(Vector128`1<UInt32> value);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.Aes : ArmBase {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> MixColumns(Vector128`1<byte> value);
    public static Vector128`1<long> PolynomialMultiplyWideningLower(Vector64`1<long> left, Vector64`1<long> right);
    public static Vector128`1<ulong> PolynomialMultiplyWideningLower(Vector64`1<ulong> left, Vector64`1<ulong> right);
    public static Vector128`1<long> PolynomialMultiplyWideningUpper(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> PolynomialMultiplyWideningUpper(Vector128`1<ulong> left, Vector128`1<ulong> right);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.ArmBase : object {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static int LeadingZeroCount(int value);
    public static int LeadingZeroCount(UInt32 value);
    public static int ReverseElementBits(int value);
    public static UInt32 ReverseElementBits(UInt32 value);
    public static void Yield();
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.Crc32 : ArmBase {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static UInt32 ComputeCrc32(UInt32 crc, byte data);
    public static UInt32 ComputeCrc32(UInt32 crc, ushort data);
    public static UInt32 ComputeCrc32(UInt32 crc, UInt32 data);
    public static UInt32 ComputeCrc32C(UInt32 crc, byte data);
    public static UInt32 ComputeCrc32C(UInt32 crc, ushort data);
    public static UInt32 ComputeCrc32C(UInt32 crc, UInt32 data);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.Dp : AdvSimd {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector64`1<int> DotProduct(Vector64`1<int> addend, Vector64`1<sbyte> left, Vector64`1<sbyte> right);
    public static Vector64`1<UInt32> DotProduct(Vector64`1<UInt32> addend, Vector64`1<byte> left, Vector64`1<byte> right);
    public static Vector128`1<int> DotProduct(Vector128`1<int> addend, Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<UInt32> DotProduct(Vector128`1<UInt32> addend, Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector64`1<int> DotProductBySelectedQuadruplet(Vector64`1<int> addend, Vector64`1<sbyte> left, Vector64`1<sbyte> right, byte rightScaledIndex);
    public static Vector64`1<int> DotProductBySelectedQuadruplet(Vector64`1<int> addend, Vector64`1<sbyte> left, Vector128`1<sbyte> right, byte rightScaledIndex);
    public static Vector64`1<UInt32> DotProductBySelectedQuadruplet(Vector64`1<UInt32> addend, Vector64`1<byte> left, Vector64`1<byte> right, byte rightScaledIndex);
    public static Vector64`1<UInt32> DotProductBySelectedQuadruplet(Vector64`1<UInt32> addend, Vector64`1<byte> left, Vector128`1<byte> right, byte rightScaledIndex);
    public static Vector128`1<int> DotProductBySelectedQuadruplet(Vector128`1<int> addend, Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte rightScaledIndex);
    public static Vector128`1<int> DotProductBySelectedQuadruplet(Vector128`1<int> addend, Vector128`1<sbyte> left, Vector64`1<sbyte> right, byte rightScaledIndex);
    public static Vector128`1<UInt32> DotProductBySelectedQuadruplet(Vector128`1<UInt32> addend, Vector128`1<byte> left, Vector128`1<byte> right, byte rightScaledIndex);
    public static Vector128`1<UInt32> DotProductBySelectedQuadruplet(Vector128`1<UInt32> addend, Vector128`1<byte> left, Vector64`1<byte> right, byte rightScaledIndex);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.Rdm : AdvSimd {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector64`1<short> MultiplyRoundedDoublingAndAddSaturateHigh(Vector64`1<short> addend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyRoundedDoublingAndAddSaturateHigh(Vector64`1<int> addend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyRoundedDoublingAndAddSaturateHigh(Vector128`1<short> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> MultiplyRoundedDoublingAndAddSaturateHigh(Vector128`1<int> addend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<short> MultiplyRoundedDoublingAndSubtractSaturateHigh(Vector64`1<short> minuend, Vector64`1<short> left, Vector64`1<short> right);
    public static Vector64`1<int> MultiplyRoundedDoublingAndSubtractSaturateHigh(Vector64`1<int> minuend, Vector64`1<int> left, Vector64`1<int> right);
    public static Vector128`1<short> MultiplyRoundedDoublingAndSubtractSaturateHigh(Vector128`1<short> minuend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> MultiplyRoundedDoublingAndSubtractSaturateHigh(Vector128`1<int> minuend, Vector128`1<int> left, Vector128`1<int> right);
    public static Vector64`1<short> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector64`1<short> addend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector64`1<short> addend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector64`1<int> addend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector64`1<int> addend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<short> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector128`1<short> addend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector128`1<short> addend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector128`1<int> addend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyRoundedDoublingBySelectedScalarAndAddSaturateHigh(Vector128`1<int> addend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector64`1<short> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector64`1<short> minuend, Vector64`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector64`1<short> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector64`1<short> minuend, Vector64`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector64`1<int> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector64`1<int> minuend, Vector64`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector64`1<int> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector64`1<int> minuend, Vector64`1<int> left, Vector128`1<int> right, byte rightIndex);
    public static Vector128`1<short> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector128`1<short> minuend, Vector128`1<short> left, Vector64`1<short> right, byte rightIndex);
    public static Vector128`1<short> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector128`1<short> minuend, Vector128`1<short> left, Vector128`1<short> right, byte rightIndex);
    public static Vector128`1<int> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector128`1<int> minuend, Vector128`1<int> left, Vector64`1<int> right, byte rightIndex);
    public static Vector128`1<int> MultiplyRoundedDoublingBySelectedScalarAndSubtractSaturateHigh(Vector128`1<int> minuend, Vector128`1<int> left, Vector128`1<int> right, byte rightIndex);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.Sha1 : ArmBase {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector64`1<UInt32> FixedRotate(Vector64`1<UInt32> hash_e);
    public static Vector128`1<UInt32> HashUpdateChoose(Vector128`1<UInt32> hash_abcd, Vector64`1<UInt32> hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashUpdateMajority(Vector128`1<UInt32> hash_abcd, Vector64`1<UInt32> hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashUpdateParity(Vector128`1<UInt32> hash_abcd, Vector64`1<UInt32> hash_e, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> ScheduleUpdate0(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7, Vector128`1<UInt32> w8_11);
    public static Vector128`1<UInt32> ScheduleUpdate1(Vector128`1<UInt32> tw0_3, Vector128`1<UInt32> w12_15);
}
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Arm.Sha256 : ArmBase {
    public static bool IsSupported { get; }
    public static bool get_IsSupported();
    public static Vector128`1<UInt32> HashUpdate1(Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> HashUpdate2(Vector128`1<UInt32> hash_efgh, Vector128`1<UInt32> hash_abcd, Vector128`1<UInt32> wk);
    public static Vector128`1<UInt32> ScheduleUpdate0(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w4_7);
    public static Vector128`1<UInt32> ScheduleUpdate1(Vector128`1<UInt32> w0_3, Vector128`1<UInt32> w8_11, Vector128`1<UInt32> w12_15);
}
internal static class System.Runtime.Intrinsics.Scalar`1 : object {
    public static T AllBitsSet { get; }
    public static T One { get; }
    public static T get_AllBitsSet();
    public static T get_One();
    public static T Abs(T value);
    public static T Add(T left, T right);
    public static T Ceiling(T value);
    public static T Divide(T left, T right);
    public static bool Equals(T left, T right);
    public static UInt32 ExtractMostSignificantBit(T value);
    public static T Floor(T value);
    public static bool GreaterThan(T left, T right);
    public static bool GreaterThanOrEqual(T left, T right);
    public static bool LessThan(T left, T right);
    public static bool LessThanOrEqual(T left, T right);
    public static T Multiply(T left, T right);
    public static bool ObjectEquals(T left, T right);
    public static T ShiftLeft(T value, int shiftCount);
    public static T ShiftRightArithmetic(T value, int shiftCount);
    public static T ShiftRightLogical(T value, int shiftCount);
    public static T Sqrt(T value);
    public static T Subtract(T left, T right);
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector128 : object {
    public static bool IsHardwareAccelerated { get; }
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Abs(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Add(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> AndNot(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<TTo> As(Vector128`1<TFrom> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<byte> AsByte(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<double> AsDouble(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<short> AsInt16(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<int> AsInt32(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<long> AsInt64(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<IntPtr> AsNInt(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> AsNUInt(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> AsSByte(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<float> AsSingle(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> AsUInt16(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> AsUInt32(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> AsUInt64(Vector128`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Vector128`1<float> AsVector128(Plane value);
    [ExtensionAttribute]
[IntrinsicAttribute]
internal static Vector128`1<float> AsVector128(Quaternion value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<float> AsVector128(Vector2 value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<float> AsVector128(Vector3 value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<float> AsVector128(Vector4 value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> AsVector128(Vector`1<T> value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector2 AsVector2(Vector128`1<float> value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector3 AsVector3(Vector128`1<float> value);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector4 AsVector4(Vector128`1<float> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector`1<T> AsVector(Vector128`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> BitwiseAnd(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> BitwiseOr(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<float> Ceiling(Vector128`1<float> vector);
    [IntrinsicAttribute]
public static Vector128`1<double> Ceiling(Vector128`1<double> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> ConditionalSelect(Vector128`1<T> condition, Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<double> ConvertToDouble(Vector128`1<long> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<double> ConvertToDouble(Vector128`1<ulong> vector);
    [IntrinsicAttribute]
public static Vector128`1<int> ConvertToInt32(Vector128`1<float> vector);
    [IntrinsicAttribute]
public static Vector128`1<long> ConvertToInt64(Vector128`1<double> vector);
    [IntrinsicAttribute]
public static Vector128`1<float> ConvertToSingle(Vector128`1<int> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<float> ConvertToSingle(Vector128`1<UInt32> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> ConvertToUInt32(Vector128`1<float> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> ConvertToUInt64(Vector128`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector128`1<T> vector, T[] destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector128`1<T> vector, T[] destination, int startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(Vector128`1<T> vector, Span`1<T> destination);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> Create(T value);
    [IntrinsicAttribute]
public static Vector128`1<byte> Create(byte value);
    [IntrinsicAttribute]
public static Vector128`1<double> Create(double value);
    [IntrinsicAttribute]
public static Vector128`1<short> Create(short value);
    [IntrinsicAttribute]
public static Vector128`1<int> Create(int value);
    [IntrinsicAttribute]
public static Vector128`1<long> Create(long value);
    [IntrinsicAttribute]
public static Vector128`1<IntPtr> Create(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> Create(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Create(sbyte value);
    [IntrinsicAttribute]
public static Vector128`1<float> Create(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Create(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Create(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Create(ulong value);
    [NullableContextAttribute("1")]
public static Vector128`1<T> Create(T[] values);
    [NullableContextAttribute("1")]
public static Vector128`1<T> Create(T[] values, int index);
    [NullableContextAttribute("2")]
public static Vector128`1<T> Create(ReadOnlySpan`1<T> values);
    [IntrinsicAttribute]
public static Vector128`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15);
    [IntrinsicAttribute]
public static Vector128`1<double> Create(double e0, double e1);
    [IntrinsicAttribute]
public static Vector128`1<short> Create(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7);
    [IntrinsicAttribute]
public static Vector128`1<int> Create(int e0, int e1, int e2, int e3);
    [IntrinsicAttribute]
public static Vector128`1<long> Create(long e0, long e1);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15);
    [IntrinsicAttribute]
public static Vector128`1<float> Create(float e0, float e1, float e2, float e3);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Create(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Create(ulong e0, ulong e1);
    [NullableContextAttribute("2")]
public static Vector128`1<T> Create(Vector64`1<T> lower, Vector64`1<T> upper);
    public static Vector128`1<byte> Create(Vector64`1<byte> lower, Vector64`1<byte> upper);
    public static Vector128`1<double> Create(Vector64`1<double> lower, Vector64`1<double> upper);
    public static Vector128`1<short> Create(Vector64`1<short> lower, Vector64`1<short> upper);
    public static Vector128`1<int> Create(Vector64`1<int> lower, Vector64`1<int> upper);
    public static Vector128`1<long> Create(Vector64`1<long> lower, Vector64`1<long> upper);
    public static Vector128`1<IntPtr> Create(Vector64`1<IntPtr> lower, Vector64`1<IntPtr> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> Create(Vector64`1<UIntPtr> lower, Vector64`1<UIntPtr> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Create(Vector64`1<sbyte> lower, Vector64`1<sbyte> upper);
    public static Vector128`1<float> Create(Vector64`1<float> lower, Vector64`1<float> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Create(Vector64`1<ushort> lower, Vector64`1<ushort> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Create(Vector64`1<UInt32> lower, Vector64`1<UInt32> upper);
    [CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Create(Vector64`1<ulong> lower, Vector64`1<ulong> upper);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> CreateScalar(T value);
    [IntrinsicAttribute]
public static Vector128`1<byte> CreateScalar(byte value);
    [IntrinsicAttribute]
public static Vector128`1<double> CreateScalar(double value);
    [IntrinsicAttribute]
public static Vector128`1<short> CreateScalar(short value);
    [IntrinsicAttribute]
public static Vector128`1<int> CreateScalar(int value);
    [IntrinsicAttribute]
public static Vector128`1<long> CreateScalar(long value);
    [IntrinsicAttribute]
public static Vector128`1<IntPtr> CreateScalar(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> CreateScalar(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> CreateScalar(sbyte value);
    [IntrinsicAttribute]
public static Vector128`1<float> CreateScalar(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> CreateScalar(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> CreateScalar(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> CreateScalar(ulong value);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> CreateScalarUnsafe(T value);
    [IntrinsicAttribute]
public static Vector128`1<byte> CreateScalarUnsafe(byte value);
    [IntrinsicAttribute]
public static Vector128`1<double> CreateScalarUnsafe(double value);
    [IntrinsicAttribute]
public static Vector128`1<short> CreateScalarUnsafe(short value);
    [IntrinsicAttribute]
public static Vector128`1<int> CreateScalarUnsafe(int value);
    [IntrinsicAttribute]
public static Vector128`1<long> CreateScalarUnsafe(long value);
    [IntrinsicAttribute]
public static Vector128`1<IntPtr> CreateScalarUnsafe(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> CreateScalarUnsafe(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> CreateScalarUnsafe(sbyte value);
    [IntrinsicAttribute]
public static Vector128`1<float> CreateScalarUnsafe(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> CreateScalarUnsafe(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> CreateScalarUnsafe(ulong value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Divide(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> Divide(Vector128`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Dot(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Equals(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAll(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAny(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 ExtractMostSignificantBits(Vector128`1<T> vector);
    [IntrinsicAttribute]
public static Vector128`1<float> Floor(Vector128`1<float> vector);
    [IntrinsicAttribute]
public static Vector128`1<double> Floor(Vector128`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T GetElement(Vector128`1<T> vector, int index);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<T> GetLower(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<T> GetUpper(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> GreaterThan(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAll(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAny(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> GreaterThanOrEqual(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAll(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAny(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> LessThan(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAll(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAny(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> LessThanOrEqual(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAll(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAny(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<T> Load(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<T> LoadAligned(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<T> LoadAlignedNonTemporal(T* source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> LoadUnsafe(T& source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<T> LoadUnsafe(T& source, UIntPtr elementOffset);
    internal static Vector128`1<ushort> LoadUnsafe(Char& source);
    internal static Vector128`1<ushort> LoadUnsafe(Char& source, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Max(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Min(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Multiply(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> Multiply(Vector128`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector128`1<T> Multiply(T left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<float> Narrow(Vector128`1<double> lower, Vector128`1<double> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Narrow(Vector128`1<short> lower, Vector128`1<short> upper);
    [IntrinsicAttribute]
public static Vector128`1<short> Narrow(Vector128`1<int> lower, Vector128`1<int> upper);
    [IntrinsicAttribute]
public static Vector128`1<int> Narrow(Vector128`1<long> lower, Vector128`1<long> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<byte> Narrow(Vector128`1<ushort> lower, Vector128`1<ushort> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Narrow(Vector128`1<UInt32> lower, Vector128`1<UInt32> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Narrow(Vector128`1<ulong> lower, Vector128`1<ulong> upper);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Negate(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> OnesComplement(Vector128`1<T> vector);
    [IntrinsicAttribute]
public static Vector128`1<byte> ShiftLeft(Vector128`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<short> ShiftLeft(Vector128`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<int> ShiftLeft(Vector128`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<long> ShiftLeft(Vector128`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<IntPtr> ShiftLeft(Vector128`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> ShiftLeft(Vector128`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> ShiftLeft(Vector128`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> ShiftLeft(Vector128`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> ShiftLeft(Vector128`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> ShiftLeft(Vector128`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<long> ShiftRightArithmetic(Vector128`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<IntPtr> ShiftRightArithmetic(Vector128`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> ShiftRightArithmetic(Vector128`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<byte> ShiftRightLogical(Vector128`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<IntPtr> ShiftRightLogical(Vector128`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UIntPtr> ShiftRightLogical(Vector128`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> ShiftRightLogical(Vector128`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<byte> Shuffle(Vector128`1<byte> vector, Vector128`1<byte> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<sbyte> Shuffle(Vector128`1<sbyte> vector, Vector128`1<sbyte> indices);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Ssse3")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Wasm.PackedSimd")]
internal static Vector128`1<byte> ShuffleUnsafe(Vector128`1<byte> vector, Vector128`1<byte> indices);
    [IntrinsicAttribute]
public static Vector128`1<short> Shuffle(Vector128`1<short> vector, Vector128`1<short> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> Shuffle(Vector128`1<ushort> vector, Vector128`1<ushort> indices);
    [IntrinsicAttribute]
public static Vector128`1<int> Shuffle(Vector128`1<int> vector, Vector128`1<int> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> Shuffle(Vector128`1<UInt32> vector, Vector128`1<UInt32> indices);
    [IntrinsicAttribute]
public static Vector128`1<float> Shuffle(Vector128`1<float> vector, Vector128`1<int> indices);
    [IntrinsicAttribute]
public static Vector128`1<long> Shuffle(Vector128`1<long> vector, Vector128`1<long> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> Shuffle(Vector128`1<ulong> vector, Vector128`1<ulong> indices);
    [IntrinsicAttribute]
public static Vector128`1<double> Shuffle(Vector128`1<double> vector, Vector128`1<long> indices);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Sqrt(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Store(Vector128`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAligned(Vector128`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAlignedNonTemporal(Vector128`1<T> source, T* destination);
    [ExtensionAttribute]
internal static void StoreLowerUnsafe(Vector128`1<T> source, T& destination, UIntPtr elementOffset);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static void StoreUnsafe(Vector128`1<T> source, T& destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreUnsafe(Vector128`1<T> source, T& destination, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Subtract(Vector128`1<T> left, Vector128`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Sum(Vector128`1<T> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T ToScalar(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> ToVector256(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> ToVector256Unsafe(Vector128`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryCopyTo(Vector128`1<T> vector, Span`1<T> destination);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector128`1<ushort>, Vector128`1<ushort>> Widen(Vector128`1<byte> source);
    public static ValueTuple`2<Vector128`1<int>, Vector128`1<int>> Widen(Vector128`1<short> source);
    public static ValueTuple`2<Vector128`1<long>, Vector128`1<long>> Widen(Vector128`1<int> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector128`1<short>, Vector128`1<short>> Widen(Vector128`1<sbyte> source);
    public static ValueTuple`2<Vector128`1<double>, Vector128`1<double>> Widen(Vector128`1<float> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector128`1<UInt32>, Vector128`1<UInt32>> Widen(Vector128`1<ushort> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector128`1<ulong>, Vector128`1<ulong>> Widen(Vector128`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> WidenLower(Vector128`1<byte> source);
    [IntrinsicAttribute]
public static Vector128`1<int> WidenLower(Vector128`1<short> source);
    [IntrinsicAttribute]
public static Vector128`1<long> WidenLower(Vector128`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<short> WidenLower(Vector128`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector128`1<double> WidenLower(Vector128`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> WidenLower(Vector128`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> WidenLower(Vector128`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ushort> WidenUpper(Vector128`1<byte> source);
    [IntrinsicAttribute]
public static Vector128`1<int> WidenUpper(Vector128`1<short> source);
    [IntrinsicAttribute]
public static Vector128`1<long> WidenUpper(Vector128`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<short> WidenUpper(Vector128`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector128`1<double> WidenUpper(Vector128`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<UInt32> WidenUpper(Vector128`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector128`1<ulong> WidenUpper(Vector128`1<UInt32> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> WithElement(Vector128`1<T> vector, int index, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> WithLower(Vector128`1<T> vector, Vector64`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> WithUpper(Vector128`1<T> vector, Vector64`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector128`1<T> Xor(Vector128`1<T> left, Vector128`1<T> right);
    [ExtensionAttribute]
internal static T GetElementUnsafe(Vector128`1& vector, int index);
    [ExtensionAttribute]
internal static void SetElementUnsafe(Vector128`1& vector, int index, T value);
    [ExtensionAttribute]
internal static void SetLowerUnsafe(Vector128`1& vector, Vector64`1<T> value);
    [ExtensionAttribute]
internal static void SetUpperUnsafe(Vector128`1& vector, Vector64`1<T> value);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
internal static Vector128`1<byte> UnpackLow(Vector128`1<byte> left, Vector128`1<byte> right);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
internal static Vector128`1<byte> UnpackHigh(Vector128`1<byte> left, Vector128`1<byte> right);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
internal static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
[CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Sse2")]
internal static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    [CompilerGeneratedAttribute]
internal static Vector128`1<float> <ConvertToSingle>g__SoftwareFallback|40_0(Vector128`1<UInt32> vector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector128DebugView`1")]
public class System.Runtime.Intrinsics.Vector128`1 : ValueType {
    internal Vector64`1<T> _lower;
    internal Vector64`1<T> _upper;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector128`1<T> AllBitsSet { get; }
    public static int Count { get; }
    public static bool IsSupported { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector128`1<T> One { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector128`1<T> Zero { get; }
    internal string DisplayString { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public static Vector128`1<T> get_AllBitsSet();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static bool get_IsSupported();
    [IntrinsicAttribute]
public static Vector128`1<T> get_One();
    [IntrinsicAttribute]
public static Vector128`1<T> get_Zero();
    internal string get_DisplayString();
    public T get_Item(int index);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Addition(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_BitwiseAnd(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_BitwiseOr(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Division(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Division(Vector128`1<T> left, T right);
    [IntrinsicAttribute]
public static bool op_Equality(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_ExclusiveOr(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_LeftShift(Vector128`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Multiply(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Multiply(Vector128`1<T> left, T right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Multiply(T left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_OnesComplement(Vector128`1<T> vector);
    [IntrinsicAttribute]
public static Vector128`1<T> op_RightShift(Vector128`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector128`1<T> op_Subtraction(Vector128`1<T> left, Vector128`1<T> right);
    [IntrinsicAttribute]
public static Vector128`1<T> op_UnaryNegation(Vector128`1<T> vector);
    [IntrinsicAttribute]
public static Vector128`1<T> op_UnaryPlus(Vector128`1<T> value);
    [IntrinsicAttribute]
public static Vector128`1<T> op_UnsignedRightShift(Vector128`1<T> value, int shiftCount);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [IntrinsicAttribute]
internal static bool EqualsFloatingPoint(Vector128`1<T> lhs, Vector128`1<T> rhs);
    public sealed virtual bool Equals(Vector128`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector128DebugView`1 : ValueType {
    private Vector128`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public IntPtr[] NIntView { get; }
    public UIntPtr[] NUIntView { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector128DebugView`1(Vector128`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public IntPtr[] get_NIntView();
    public UIntPtr[] get_NUIntView();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector256 : object {
    public static bool IsHardwareAccelerated { get; }
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Abs(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Add(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> AndNot(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<TTo> As(Vector256`1<TFrom> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<byte> AsByte(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<double> AsDouble(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<short> AsInt16(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<int> AsInt32(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<long> AsInt64(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<IntPtr> AsNInt(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> AsNUInt(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> AsSByte(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<float> AsSingle(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> AsUInt16(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> AsUInt32(Vector256`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> AsUInt64(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> AsVector256(Vector`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector`1<T> AsVector(Vector256`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> BitwiseAnd(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> BitwiseOr(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<float> Ceiling(Vector256`1<float> vector);
    [IntrinsicAttribute]
public static Vector256`1<double> Ceiling(Vector256`1<double> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> ConditionalSelect(Vector256`1<T> condition, Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<double> ConvertToDouble(Vector256`1<long> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<double> ConvertToDouble(Vector256`1<ulong> vector);
    [IntrinsicAttribute]
public static Vector256`1<int> ConvertToInt32(Vector256`1<float> vector);
    [IntrinsicAttribute]
public static Vector256`1<long> ConvertToInt64(Vector256`1<double> vector);
    [IntrinsicAttribute]
public static Vector256`1<float> ConvertToSingle(Vector256`1<int> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<float> ConvertToSingle(Vector256`1<UInt32> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> ConvertToUInt32(Vector256`1<float> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> ConvertToUInt64(Vector256`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector256`1<T> vector, T[] destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector256`1<T> vector, T[] destination, int startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(Vector256`1<T> vector, Span`1<T> destination);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> Create(T value);
    [IntrinsicAttribute]
public static Vector256`1<byte> Create(byte value);
    [IntrinsicAttribute]
public static Vector256`1<double> Create(double value);
    [IntrinsicAttribute]
public static Vector256`1<short> Create(short value);
    [IntrinsicAttribute]
public static Vector256`1<int> Create(int value);
    [IntrinsicAttribute]
public static Vector256`1<long> Create(long value);
    [IntrinsicAttribute]
public static Vector256`1<IntPtr> Create(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> Create(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Create(sbyte value);
    [IntrinsicAttribute]
public static Vector256`1<float> Create(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Create(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Create(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Create(ulong value);
    [NullableContextAttribute("1")]
public static Vector256`1<T> Create(T[] values);
    [NullableContextAttribute("1")]
public static Vector256`1<T> Create(T[] values, int index);
    [NullableContextAttribute("2")]
public static Vector256`1<T> Create(ReadOnlySpan`1<T> values);
    [IntrinsicAttribute]
public static Vector256`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15, byte e16, byte e17, byte e18, byte e19, byte e20, byte e21, byte e22, byte e23, byte e24, byte e25, byte e26, byte e27, byte e28, byte e29, byte e30, byte e31);
    [IntrinsicAttribute]
public static Vector256`1<double> Create(double e0, double e1, double e2, double e3);
    [IntrinsicAttribute]
public static Vector256`1<short> Create(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7, short e8, short e9, short e10, short e11, short e12, short e13, short e14, short e15);
    [IntrinsicAttribute]
public static Vector256`1<int> Create(int e0, int e1, int e2, int e3, int e4, int e5, int e6, int e7);
    [IntrinsicAttribute]
public static Vector256`1<long> Create(long e0, long e1, long e2, long e3);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15, sbyte e16, sbyte e17, sbyte e18, sbyte e19, sbyte e20, sbyte e21, sbyte e22, sbyte e23, sbyte e24, sbyte e25, sbyte e26, sbyte e27, sbyte e28, sbyte e29, sbyte e30, sbyte e31);
    [IntrinsicAttribute]
public static Vector256`1<float> Create(float e0, float e1, float e2, float e3, float e4, float e5, float e6, float e7);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7, ushort e8, ushort e9, ushort e10, ushort e11, ushort e12, ushort e13, ushort e14, ushort e15);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Create(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3, UInt32 e4, UInt32 e5, UInt32 e6, UInt32 e7);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Create(ulong e0, ulong e1, ulong e2, ulong e3);
    [NullableContextAttribute("2")]
public static Vector256`1<T> Create(Vector128`1<T> lower, Vector128`1<T> upper);
    public static Vector256`1<byte> Create(Vector128`1<byte> lower, Vector128`1<byte> upper);
    public static Vector256`1<double> Create(Vector128`1<double> lower, Vector128`1<double> upper);
    public static Vector256`1<short> Create(Vector128`1<short> lower, Vector128`1<short> upper);
    public static Vector256`1<int> Create(Vector128`1<int> lower, Vector128`1<int> upper);
    public static Vector256`1<long> Create(Vector128`1<long> lower, Vector128`1<long> upper);
    public static Vector256`1<IntPtr> Create(Vector128`1<IntPtr> lower, Vector128`1<IntPtr> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> Create(Vector128`1<UIntPtr> lower, Vector128`1<UIntPtr> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Create(Vector128`1<sbyte> lower, Vector128`1<sbyte> upper);
    public static Vector256`1<float> Create(Vector128`1<float> lower, Vector128`1<float> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Create(Vector128`1<ushort> lower, Vector128`1<ushort> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Create(Vector128`1<UInt32> lower, Vector128`1<UInt32> upper);
    [CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Create(Vector128`1<ulong> lower, Vector128`1<ulong> upper);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> CreateScalar(T value);
    [IntrinsicAttribute]
public static Vector256`1<byte> CreateScalar(byte value);
    [IntrinsicAttribute]
public static Vector256`1<double> CreateScalar(double value);
    [IntrinsicAttribute]
public static Vector256`1<short> CreateScalar(short value);
    [IntrinsicAttribute]
public static Vector256`1<int> CreateScalar(int value);
    [IntrinsicAttribute]
public static Vector256`1<long> CreateScalar(long value);
    [IntrinsicAttribute]
public static Vector256`1<IntPtr> CreateScalar(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> CreateScalar(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> CreateScalar(sbyte value);
    [IntrinsicAttribute]
public static Vector256`1<float> CreateScalar(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> CreateScalar(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> CreateScalar(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> CreateScalar(ulong value);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> CreateScalarUnsafe(T value);
    [IntrinsicAttribute]
public static Vector256`1<byte> CreateScalarUnsafe(byte value);
    [IntrinsicAttribute]
public static Vector256`1<double> CreateScalarUnsafe(double value);
    [IntrinsicAttribute]
public static Vector256`1<short> CreateScalarUnsafe(short value);
    [IntrinsicAttribute]
public static Vector256`1<int> CreateScalarUnsafe(int value);
    [IntrinsicAttribute]
public static Vector256`1<long> CreateScalarUnsafe(long value);
    [IntrinsicAttribute]
public static Vector256`1<IntPtr> CreateScalarUnsafe(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> CreateScalarUnsafe(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> CreateScalarUnsafe(sbyte value);
    [IntrinsicAttribute]
public static Vector256`1<float> CreateScalarUnsafe(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> CreateScalarUnsafe(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> CreateScalarUnsafe(ulong value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Divide(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> Divide(Vector256`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Dot(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Equals(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAll(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAny(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 ExtractMostSignificantBits(Vector256`1<T> vector);
    [IntrinsicAttribute]
public static Vector256`1<float> Floor(Vector256`1<float> vector);
    [IntrinsicAttribute]
public static Vector256`1<double> Floor(Vector256`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T GetElement(Vector256`1<T> vector, int index);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> GetLower(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> GetUpper(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> GreaterThan(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAll(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAny(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> GreaterThanOrEqual(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAll(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAny(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> LessThan(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAll(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAny(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> LessThanOrEqual(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAll(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAny(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<T> Load(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<T> LoadAligned(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<T> LoadAlignedNonTemporal(T* source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> LoadUnsafe(T& source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<T> LoadUnsafe(T& source, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Max(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Min(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Multiply(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> Multiply(Vector256`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector256`1<T> Multiply(T left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<float> Narrow(Vector256`1<double> lower, Vector256`1<double> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Narrow(Vector256`1<short> lower, Vector256`1<short> upper);
    [IntrinsicAttribute]
public static Vector256`1<short> Narrow(Vector256`1<int> lower, Vector256`1<int> upper);
    [IntrinsicAttribute]
public static Vector256`1<int> Narrow(Vector256`1<long> lower, Vector256`1<long> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<byte> Narrow(Vector256`1<ushort> lower, Vector256`1<ushort> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Narrow(Vector256`1<UInt32> lower, Vector256`1<UInt32> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Narrow(Vector256`1<ulong> lower, Vector256`1<ulong> upper);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Negate(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> OnesComplement(Vector256`1<T> vector);
    [IntrinsicAttribute]
public static Vector256`1<byte> ShiftLeft(Vector256`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<short> ShiftLeft(Vector256`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<int> ShiftLeft(Vector256`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<long> ShiftLeft(Vector256`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<IntPtr> ShiftLeft(Vector256`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> ShiftLeft(Vector256`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> ShiftLeft(Vector256`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> ShiftLeft(Vector256`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> ShiftLeft(Vector256`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> ShiftLeft(Vector256`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<long> ShiftRightArithmetic(Vector256`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<IntPtr> ShiftRightArithmetic(Vector256`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> ShiftRightArithmetic(Vector256`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<byte> ShiftRightLogical(Vector256`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<IntPtr> ShiftRightLogical(Vector256`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UIntPtr> ShiftRightLogical(Vector256`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> ShiftRightLogical(Vector256`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<byte> Shuffle(Vector256`1<byte> vector, Vector256`1<byte> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<sbyte> Shuffle(Vector256`1<sbyte> vector, Vector256`1<sbyte> indices);
    [IntrinsicAttribute]
public static Vector256`1<short> Shuffle(Vector256`1<short> vector, Vector256`1<short> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> Shuffle(Vector256`1<ushort> vector, Vector256`1<ushort> indices);
    [IntrinsicAttribute]
public static Vector256`1<int> Shuffle(Vector256`1<int> vector, Vector256`1<int> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> Shuffle(Vector256`1<UInt32> vector, Vector256`1<UInt32> indices);
    [IntrinsicAttribute]
public static Vector256`1<float> Shuffle(Vector256`1<float> vector, Vector256`1<int> indices);
    [IntrinsicAttribute]
public static Vector256`1<long> Shuffle(Vector256`1<long> vector, Vector256`1<long> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> Shuffle(Vector256`1<ulong> vector, Vector256`1<ulong> indices);
    [IntrinsicAttribute]
public static Vector256`1<double> Shuffle(Vector256`1<double> vector, Vector256`1<long> indices);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Sqrt(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Store(Vector256`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAligned(Vector256`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAlignedNonTemporal(Vector256`1<T> source, T* destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static void StoreUnsafe(Vector256`1<T> source, T& destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreUnsafe(Vector256`1<T> source, T& destination, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Subtract(Vector256`1<T> left, Vector256`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Sum(Vector256`1<T> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T ToScalar(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<T> ToVector512(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<T> ToVector512Unsafe(Vector256`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryCopyTo(Vector256`1<T> vector, Span`1<T> destination);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector256`1<ushort>, Vector256`1<ushort>> Widen(Vector256`1<byte> source);
    public static ValueTuple`2<Vector256`1<int>, Vector256`1<int>> Widen(Vector256`1<short> source);
    public static ValueTuple`2<Vector256`1<long>, Vector256`1<long>> Widen(Vector256`1<int> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector256`1<short>, Vector256`1<short>> Widen(Vector256`1<sbyte> source);
    public static ValueTuple`2<Vector256`1<double>, Vector256`1<double>> Widen(Vector256`1<float> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector256`1<UInt32>, Vector256`1<UInt32>> Widen(Vector256`1<ushort> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector256`1<ulong>, Vector256`1<ulong>> Widen(Vector256`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> WidenLower(Vector256`1<byte> source);
    [IntrinsicAttribute]
public static Vector256`1<int> WidenLower(Vector256`1<short> source);
    [IntrinsicAttribute]
public static Vector256`1<long> WidenLower(Vector256`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<short> WidenLower(Vector256`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector256`1<double> WidenLower(Vector256`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> WidenLower(Vector256`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> WidenLower(Vector256`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ushort> WidenUpper(Vector256`1<byte> source);
    [IntrinsicAttribute]
public static Vector256`1<int> WidenUpper(Vector256`1<short> source);
    [IntrinsicAttribute]
public static Vector256`1<long> WidenUpper(Vector256`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<short> WidenUpper(Vector256`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector256`1<double> WidenUpper(Vector256`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<UInt32> WidenUpper(Vector256`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector256`1<ulong> WidenUpper(Vector256`1<UInt32> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> WithElement(Vector256`1<T> vector, int index, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> WithLower(Vector256`1<T> vector, Vector128`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> WithUpper(Vector256`1<T> vector, Vector128`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector256`1<T> Xor(Vector256`1<T> left, Vector256`1<T> right);
    [ExtensionAttribute]
internal static T GetElementUnsafe(Vector256`1& vector, int index);
    [ExtensionAttribute]
internal static void SetElementUnsafe(Vector256`1& vector, int index, T value);
    [ExtensionAttribute]
internal static void SetLowerUnsafe(Vector256`1& vector, Vector128`1<T> value);
    [ExtensionAttribute]
internal static void SetUpperUnsafe(Vector256`1& vector, Vector128`1<T> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector256DebugView`1")]
public class System.Runtime.Intrinsics.Vector256`1 : ValueType {
    internal Vector128`1<T> _lower;
    internal Vector128`1<T> _upper;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector256`1<T> AllBitsSet { get; }
    public static int Count { get; }
    public static bool IsSupported { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector256`1<T> One { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector256`1<T> Zero { get; }
    internal string DisplayString { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public static Vector256`1<T> get_AllBitsSet();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static bool get_IsSupported();
    [IntrinsicAttribute]
public static Vector256`1<T> get_One();
    [IntrinsicAttribute]
public static Vector256`1<T> get_Zero();
    internal string get_DisplayString();
    public T get_Item(int index);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Addition(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_BitwiseAnd(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_BitwiseOr(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Division(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Division(Vector256`1<T> left, T right);
    [IntrinsicAttribute]
public static bool op_Equality(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_ExclusiveOr(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_LeftShift(Vector256`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Multiply(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Multiply(Vector256`1<T> left, T right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Multiply(T left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_OnesComplement(Vector256`1<T> vector);
    [IntrinsicAttribute]
public static Vector256`1<T> op_RightShift(Vector256`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector256`1<T> op_Subtraction(Vector256`1<T> left, Vector256`1<T> right);
    [IntrinsicAttribute]
public static Vector256`1<T> op_UnaryNegation(Vector256`1<T> vector);
    [IntrinsicAttribute]
public static Vector256`1<T> op_UnaryPlus(Vector256`1<T> value);
    [IntrinsicAttribute]
public static Vector256`1<T> op_UnsignedRightShift(Vector256`1<T> value, int shiftCount);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Vector256`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector256DebugView`1 : ValueType {
    private Vector256`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public IntPtr[] NIntView { get; }
    public UIntPtr[] NUIntView { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector256DebugView`1(Vector256`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public IntPtr[] get_NIntView();
    public UIntPtr[] get_NUIntView();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector512 : object {
    public static bool IsHardwareAccelerated { get; }
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Abs(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Add(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> AndNot(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<TTo> As(Vector512`1<TFrom> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<byte> AsByte(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<double> AsDouble(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<short> AsInt16(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<int> AsInt32(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<long> AsInt64(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<IntPtr> AsNInt(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> AsNUInt(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> AsSByte(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<float> AsSingle(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> AsUInt16(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> AsUInt32(Vector512`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> AsUInt64(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<T> AsVector512(Vector`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector`1<T> AsVector(Vector512`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> BitwiseAnd(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> BitwiseOr(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<float> Ceiling(Vector512`1<float> vector);
    [IntrinsicAttribute]
public static Vector512`1<double> Ceiling(Vector512`1<double> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> ConditionalSelect(Vector512`1<T> condition, Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<double> ConvertToDouble(Vector512`1<long> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<double> ConvertToDouble(Vector512`1<ulong> vector);
    [IntrinsicAttribute]
public static Vector512`1<int> ConvertToInt32(Vector512`1<float> vector);
    [IntrinsicAttribute]
public static Vector512`1<long> ConvertToInt64(Vector512`1<double> vector);
    [IntrinsicAttribute]
public static Vector512`1<float> ConvertToSingle(Vector512`1<int> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<float> ConvertToSingle(Vector512`1<UInt32> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> ConvertToUInt32(Vector512`1<float> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> ConvertToUInt64(Vector512`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector512`1<T> vector, T[] destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector512`1<T> vector, T[] destination, int startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(Vector512`1<T> vector, Span`1<T> destination);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector512`1<T> Create(T value);
    [IntrinsicAttribute]
public static Vector512`1<byte> Create(byte value);
    [IntrinsicAttribute]
public static Vector512`1<double> Create(double value);
    [IntrinsicAttribute]
public static Vector512`1<short> Create(short value);
    [IntrinsicAttribute]
public static Vector512`1<int> Create(int value);
    [IntrinsicAttribute]
public static Vector512`1<long> Create(long value);
    [IntrinsicAttribute]
public static Vector512`1<IntPtr> Create(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> Create(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> Create(sbyte value);
    [IntrinsicAttribute]
public static Vector512`1<float> Create(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> Create(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> Create(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> Create(ulong value);
    [NullableContextAttribute("1")]
public static Vector512`1<T> Create(T[] values);
    [NullableContextAttribute("1")]
public static Vector512`1<T> Create(T[] values, int index);
    [NullableContextAttribute("2")]
public static Vector512`1<T> Create(ReadOnlySpan`1<T> values);
    [IntrinsicAttribute]
public static Vector512`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7, byte e8, byte e9, byte e10, byte e11, byte e12, byte e13, byte e14, byte e15, byte e16, byte e17, byte e18, byte e19, byte e20, byte e21, byte e22, byte e23, byte e24, byte e25, byte e26, byte e27, byte e28, byte e29, byte e30, byte e31, byte e32, byte e33, byte e34, byte e35, byte e36, byte e37, byte e38, byte e39, byte e40, byte e41, byte e42, byte e43, byte e44, byte e45, byte e46, byte e47, byte e48, byte e49, byte e50, byte e51, byte e52, byte e53, byte e54, byte e55, byte e56, byte e57, byte e58, byte e59, byte e60, byte e61, byte e62, byte e63);
    [IntrinsicAttribute]
public static Vector512`1<double> Create(double e0, double e1, double e2, double e3, double e4, double e5, double e6, double e7);
    [IntrinsicAttribute]
public static Vector512`1<short> Create(short e0, short e1, short e2, short e3, short e4, short e5, short e6, short e7, short e8, short e9, short e10, short e11, short e12, short e13, short e14, short e15, short e16, short e17, short e18, short e19, short e20, short e21, short e22, short e23, short e24, short e25, short e26, short e27, short e28, short e29, short e30, short e31);
    [IntrinsicAttribute]
public static Vector512`1<int> Create(int e0, int e1, int e2, int e3, int e4, int e5, int e6, int e7, int e8, int e9, int e10, int e11, int e12, int e13, int e14, int e15);
    [IntrinsicAttribute]
public static Vector512`1<long> Create(long e0, long e1, long e2, long e3, long e4, long e5, long e6, long e7);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7, sbyte e8, sbyte e9, sbyte e10, sbyte e11, sbyte e12, sbyte e13, sbyte e14, sbyte e15, sbyte e16, sbyte e17, sbyte e18, sbyte e19, sbyte e20, sbyte e21, sbyte e22, sbyte e23, sbyte e24, sbyte e25, sbyte e26, sbyte e27, sbyte e28, sbyte e29, sbyte e30, sbyte e31, sbyte e32, sbyte e33, sbyte e34, sbyte e35, sbyte e36, sbyte e37, sbyte e38, sbyte e39, sbyte e40, sbyte e41, sbyte e42, sbyte e43, sbyte e44, sbyte e45, sbyte e46, sbyte e47, sbyte e48, sbyte e49, sbyte e50, sbyte e51, sbyte e52, sbyte e53, sbyte e54, sbyte e55, sbyte e56, sbyte e57, sbyte e58, sbyte e59, sbyte e60, sbyte e61, sbyte e62, sbyte e63);
    [IntrinsicAttribute]
public static Vector512`1<float> Create(float e0, float e1, float e2, float e3, float e4, float e5, float e6, float e7, float e8, float e9, float e10, float e11, float e12, float e13, float e14, float e15);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3, ushort e4, ushort e5, ushort e6, ushort e7, ushort e8, ushort e9, ushort e10, ushort e11, ushort e12, ushort e13, ushort e14, ushort e15, ushort e16, ushort e17, ushort e18, ushort e19, ushort e20, ushort e21, ushort e22, ushort e23, ushort e24, ushort e25, ushort e26, ushort e27, ushort e28, ushort e29, ushort e30, ushort e31);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> Create(UInt32 e0, UInt32 e1, UInt32 e2, UInt32 e3, UInt32 e4, UInt32 e5, UInt32 e6, UInt32 e7, UInt32 e8, UInt32 e9, UInt32 e10, UInt32 e11, UInt32 e12, UInt32 e13, UInt32 e14, UInt32 e15);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> Create(ulong e0, ulong e1, ulong e2, ulong e3, ulong e4, ulong e5, ulong e6, ulong e7);
    [NullableContextAttribute("2")]
public static Vector512`1<T> Create(Vector256`1<T> lower, Vector256`1<T> upper);
    public static Vector512`1<byte> Create(Vector256`1<byte> lower, Vector256`1<byte> upper);
    public static Vector512`1<double> Create(Vector256`1<double> lower, Vector256`1<double> upper);
    public static Vector512`1<short> Create(Vector256`1<short> lower, Vector256`1<short> upper);
    public static Vector512`1<int> Create(Vector256`1<int> lower, Vector256`1<int> upper);
    public static Vector512`1<long> Create(Vector256`1<long> lower, Vector256`1<long> upper);
    public static Vector512`1<IntPtr> Create(Vector256`1<IntPtr> lower, Vector256`1<IntPtr> upper);
    [CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> Create(Vector256`1<UIntPtr> lower, Vector256`1<UIntPtr> upper);
    [CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> Create(Vector256`1<sbyte> lower, Vector256`1<sbyte> upper);
    public static Vector512`1<float> Create(Vector256`1<float> lower, Vector256`1<float> upper);
    [CLSCompliantAttribute("False")]
public static Vector512`1<ushort> Create(Vector256`1<ushort> lower, Vector256`1<ushort> upper);
    [CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> Create(Vector256`1<UInt32> lower, Vector256`1<UInt32> upper);
    [CLSCompliantAttribute("False")]
public static Vector512`1<ulong> Create(Vector256`1<ulong> lower, Vector256`1<ulong> upper);
    [NullableContextAttribute("1")]
public static Vector512`1<T> CreateScalar(T value);
    public static Vector512`1<byte> CreateScalar(byte value);
    public static Vector512`1<double> CreateScalar(double value);
    public static Vector512`1<short> CreateScalar(short value);
    public static Vector512`1<int> CreateScalar(int value);
    public static Vector512`1<long> CreateScalar(long value);
    public static Vector512`1<IntPtr> CreateScalar(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> CreateScalar(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> CreateScalar(sbyte value);
    public static Vector512`1<float> CreateScalar(float value);
    [CLSCompliantAttribute("False")]
public static Vector512`1<ushort> CreateScalar(ushort value);
    [CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> CreateScalar(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Vector512`1<ulong> CreateScalar(ulong value);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector512`1<T> CreateScalarUnsafe(T value);
    [IntrinsicAttribute]
public static Vector512`1<byte> CreateScalarUnsafe(byte value);
    [IntrinsicAttribute]
public static Vector512`1<double> CreateScalarUnsafe(double value);
    [IntrinsicAttribute]
public static Vector512`1<short> CreateScalarUnsafe(short value);
    [IntrinsicAttribute]
public static Vector512`1<int> CreateScalarUnsafe(int value);
    [IntrinsicAttribute]
public static Vector512`1<long> CreateScalarUnsafe(long value);
    [IntrinsicAttribute]
public static Vector512`1<IntPtr> CreateScalarUnsafe(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> CreateScalarUnsafe(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> CreateScalarUnsafe(sbyte value);
    [IntrinsicAttribute]
public static Vector512`1<float> CreateScalarUnsafe(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> CreateScalarUnsafe(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> CreateScalarUnsafe(ulong value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Divide(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector512`1<T> Divide(Vector512`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Dot(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Equals(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAll(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAny(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static ulong ExtractMostSignificantBits(Vector512`1<T> vector);
    [IntrinsicAttribute]
public static Vector512`1<float> Floor(Vector512`1<float> vector);
    [IntrinsicAttribute]
public static Vector512`1<double> Floor(Vector512`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T GetElement(Vector512`1<T> vector, int index);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> GetLower(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector256`1<T> GetUpper(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> GreaterThan(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAll(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAny(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> GreaterThanOrEqual(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAll(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAny(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> LessThan(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAll(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAny(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> LessThanOrEqual(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAll(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAny(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<T> Load(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<T> LoadAligned(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<T> LoadAlignedNonTemporal(T* source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector512`1<T> LoadUnsafe(T& source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<T> LoadUnsafe(T& source, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Max(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Min(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Multiply(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector512`1<T> Multiply(Vector512`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector512`1<T> Multiply(T left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<float> Narrow(Vector512`1<double> lower, Vector512`1<double> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> Narrow(Vector512`1<short> lower, Vector512`1<short> upper);
    [IntrinsicAttribute]
public static Vector512`1<short> Narrow(Vector512`1<int> lower, Vector512`1<int> upper);
    [IntrinsicAttribute]
public static Vector512`1<int> Narrow(Vector512`1<long> lower, Vector512`1<long> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<byte> Narrow(Vector512`1<ushort> lower, Vector512`1<ushort> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> Narrow(Vector512`1<UInt32> lower, Vector512`1<UInt32> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> Narrow(Vector512`1<ulong> lower, Vector512`1<ulong> upper);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Negate(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> OnesComplement(Vector512`1<T> vector);
    [IntrinsicAttribute]
public static Vector512`1<byte> ShiftLeft(Vector512`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<short> ShiftLeft(Vector512`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<int> ShiftLeft(Vector512`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<long> ShiftLeft(Vector512`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<IntPtr> ShiftLeft(Vector512`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> ShiftLeft(Vector512`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> ShiftLeft(Vector512`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> ShiftLeft(Vector512`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> ShiftLeft(Vector512`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> ShiftLeft(Vector512`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<short> ShiftRightArithmetic(Vector512`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<int> ShiftRightArithmetic(Vector512`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<long> ShiftRightArithmetic(Vector512`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<IntPtr> ShiftRightArithmetic(Vector512`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> ShiftRightArithmetic(Vector512`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<byte> ShiftRightLogical(Vector512`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<short> ShiftRightLogical(Vector512`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<int> ShiftRightLogical(Vector512`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<long> ShiftRightLogical(Vector512`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<IntPtr> ShiftRightLogical(Vector512`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UIntPtr> ShiftRightLogical(Vector512`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> ShiftRightLogical(Vector512`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> ShiftRightLogical(Vector512`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> ShiftRightLogical(Vector512`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> ShiftRightLogical(Vector512`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<byte> Shuffle(Vector512`1<byte> vector, Vector512`1<byte> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<sbyte> Shuffle(Vector512`1<sbyte> vector, Vector512`1<sbyte> indices);
    [IntrinsicAttribute]
public static Vector512`1<short> Shuffle(Vector512`1<short> vector, Vector512`1<short> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> Shuffle(Vector512`1<ushort> vector, Vector512`1<ushort> indices);
    [IntrinsicAttribute]
public static Vector512`1<int> Shuffle(Vector512`1<int> vector, Vector512`1<int> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> Shuffle(Vector512`1<UInt32> vector, Vector512`1<UInt32> indices);
    [IntrinsicAttribute]
public static Vector512`1<float> Shuffle(Vector512`1<float> vector, Vector512`1<int> indices);
    [IntrinsicAttribute]
public static Vector512`1<long> Shuffle(Vector512`1<long> vector, Vector512`1<long> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> Shuffle(Vector512`1<ulong> vector, Vector512`1<ulong> indices);
    [IntrinsicAttribute]
public static Vector512`1<double> Shuffle(Vector512`1<double> vector, Vector512`1<long> indices);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Sqrt(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Store(Vector512`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAligned(Vector512`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAlignedNonTemporal(Vector512`1<T> source, T* destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static void StoreUnsafe(Vector512`1<T> source, T& destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreUnsafe(Vector512`1<T> source, T& destination, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Subtract(Vector512`1<T> left, Vector512`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Sum(Vector512`1<T> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T ToScalar(Vector512`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryCopyTo(Vector512`1<T> vector, Span`1<T> destination);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector512`1<ushort>, Vector512`1<ushort>> Widen(Vector512`1<byte> source);
    public static ValueTuple`2<Vector512`1<int>, Vector512`1<int>> Widen(Vector512`1<short> source);
    public static ValueTuple`2<Vector512`1<long>, Vector512`1<long>> Widen(Vector512`1<int> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector512`1<short>, Vector512`1<short>> Widen(Vector512`1<sbyte> source);
    public static ValueTuple`2<Vector512`1<double>, Vector512`1<double>> Widen(Vector512`1<float> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector512`1<UInt32>, Vector512`1<UInt32>> Widen(Vector512`1<ushort> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector512`1<ulong>, Vector512`1<ulong>> Widen(Vector512`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> WidenLower(Vector512`1<byte> source);
    [IntrinsicAttribute]
public static Vector512`1<int> WidenLower(Vector512`1<short> source);
    [IntrinsicAttribute]
public static Vector512`1<long> WidenLower(Vector512`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<short> WidenLower(Vector512`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector512`1<double> WidenLower(Vector512`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> WidenLower(Vector512`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> WidenLower(Vector512`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ushort> WidenUpper(Vector512`1<byte> source);
    [IntrinsicAttribute]
public static Vector512`1<int> WidenUpper(Vector512`1<short> source);
    [IntrinsicAttribute]
public static Vector512`1<long> WidenUpper(Vector512`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<short> WidenUpper(Vector512`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector512`1<double> WidenUpper(Vector512`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<UInt32> WidenUpper(Vector512`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector512`1<ulong> WidenUpper(Vector512`1<UInt32> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<T> WithElement(Vector512`1<T> vector, int index, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<T> WithLower(Vector512`1<T> vector, Vector256`1<T> value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector512`1<T> WithUpper(Vector512`1<T> vector, Vector256`1<T> value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector512`1<T> Xor(Vector512`1<T> left, Vector512`1<T> right);
    [ExtensionAttribute]
internal static T GetElementUnsafe(Vector512`1& vector, int index);
    [ExtensionAttribute]
internal static void SetElementUnsafe(Vector512`1& vector, int index, T value);
    [ExtensionAttribute]
internal static void SetLowerUnsafe(Vector512`1& vector, Vector256`1<T> value);
    [ExtensionAttribute]
internal static void SetUpperUnsafe(Vector512`1& vector, Vector256`1<T> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector512DebugView`1")]
public class System.Runtime.Intrinsics.Vector512`1 : ValueType {
    internal Vector256`1<T> _lower;
    internal Vector256`1<T> _upper;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector512`1<T> AllBitsSet { get; }
    public static int Count { get; }
    public static bool IsSupported { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector512`1<T> One { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector512`1<T> Zero { get; }
    internal string DisplayString { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public static Vector512`1<T> get_AllBitsSet();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static bool get_IsSupported();
    [IntrinsicAttribute]
public static Vector512`1<T> get_One();
    [IntrinsicAttribute]
public static Vector512`1<T> get_Zero();
    internal string get_DisplayString();
    public T get_Item(int index);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Addition(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_BitwiseAnd(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_BitwiseOr(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Division(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Division(Vector512`1<T> left, T right);
    [IntrinsicAttribute]
public static bool op_Equality(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_ExclusiveOr(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_LeftShift(Vector512`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Multiply(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Multiply(Vector512`1<T> left, T right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Multiply(T left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_OnesComplement(Vector512`1<T> vector);
    [IntrinsicAttribute]
public static Vector512`1<T> op_RightShift(Vector512`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector512`1<T> op_Subtraction(Vector512`1<T> left, Vector512`1<T> right);
    [IntrinsicAttribute]
public static Vector512`1<T> op_UnaryNegation(Vector512`1<T> vector);
    [IntrinsicAttribute]
public static Vector512`1<T> op_UnaryPlus(Vector512`1<T> value);
    [IntrinsicAttribute]
public static Vector512`1<T> op_UnsignedRightShift(Vector512`1<T> value, int shiftCount);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Vector512`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector512DebugView`1 : ValueType {
    private Vector512`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public IntPtr[] NIntView { get; }
    public UIntPtr[] NUIntView { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector512DebugView`1(Vector512`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public IntPtr[] get_NIntView();
    public UIntPtr[] get_NUIntView();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[ExtensionAttribute]
public static class System.Runtime.Intrinsics.Vector64 : object {
    public static bool IsHardwareAccelerated { get; }
    [IntrinsicAttribute]
public static bool get_IsHardwareAccelerated();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Abs(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Add(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> AndNot(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<TTo> As(Vector64`1<TFrom> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<byte> AsByte(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<double> AsDouble(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<short> AsInt16(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<int> AsInt32(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<long> AsInt64(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<IntPtr> AsNInt(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UIntPtr> AsNUInt(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> AsSByte(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<float> AsSingle(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> AsUInt16(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> AsUInt32(Vector64`1<T> vector);
    [ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> AsUInt64(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> BitwiseAnd(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> BitwiseOr(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<float> Ceiling(Vector64`1<float> vector);
    [IntrinsicAttribute]
public static Vector64`1<double> Ceiling(Vector64`1<double> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> ConditionalSelect(Vector64`1<T> condition, Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<double> ConvertToDouble(Vector64`1<long> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<double> ConvertToDouble(Vector64`1<ulong> vector);
    [IntrinsicAttribute]
public static Vector64`1<int> ConvertToInt32(Vector64`1<float> vector);
    [IntrinsicAttribute]
public static Vector64`1<long> ConvertToInt64(Vector64`1<double> vector);
    [IntrinsicAttribute]
public static Vector64`1<float> ConvertToSingle(Vector64`1<int> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<float> ConvertToSingle(Vector64`1<UInt32> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> ConvertToUInt32(Vector64`1<float> vector);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> ConvertToUInt64(Vector64`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector64`1<T> vector, T[] destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void CopyTo(Vector64`1<T> vector, T[] destination, int startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(Vector64`1<T> vector, Span`1<T> destination);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> Create(T value);
    [IntrinsicAttribute]
public static Vector64`1<byte> Create(byte value);
    [IntrinsicAttribute]
public static Vector64`1<double> Create(double value);
    [IntrinsicAttribute]
public static Vector64`1<short> Create(short value);
    [IntrinsicAttribute]
public static Vector64`1<int> Create(int value);
    [IntrinsicAttribute]
public static Vector64`1<long> Create(long value);
    [IntrinsicAttribute]
public static Vector64`1<IntPtr> Create(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UIntPtr> Create(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> Create(sbyte value);
    [IntrinsicAttribute]
public static Vector64`1<float> Create(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> Create(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> Create(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> Create(ulong value);
    [NullableContextAttribute("1")]
public static Vector64`1<T> Create(T[] values);
    [NullableContextAttribute("1")]
public static Vector64`1<T> Create(T[] values, int index);
    [NullableContextAttribute("2")]
public static Vector64`1<T> Create(ReadOnlySpan`1<T> values);
    [IntrinsicAttribute]
public static Vector64`1<byte> Create(byte e0, byte e1, byte e2, byte e3, byte e4, byte e5, byte e6, byte e7);
    [IntrinsicAttribute]
public static Vector64`1<short> Create(short e0, short e1, short e2, short e3);
    [IntrinsicAttribute]
public static Vector64`1<int> Create(int e0, int e1);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> Create(sbyte e0, sbyte e1, sbyte e2, sbyte e3, sbyte e4, sbyte e5, sbyte e6, sbyte e7);
    [IntrinsicAttribute]
public static Vector64`1<float> Create(float e0, float e1);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> Create(ushort e0, ushort e1, ushort e2, ushort e3);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> Create(UInt32 e0, UInt32 e1);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> CreateScalar(T value);
    [IntrinsicAttribute]
public static Vector64`1<byte> CreateScalar(byte value);
    [IntrinsicAttribute]
public static Vector64`1<double> CreateScalar(double value);
    [IntrinsicAttribute]
public static Vector64`1<short> CreateScalar(short value);
    [IntrinsicAttribute]
public static Vector64`1<int> CreateScalar(int value);
    [IntrinsicAttribute]
public static Vector64`1<long> CreateScalar(long value);
    [IntrinsicAttribute]
public static Vector64`1<IntPtr> CreateScalar(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UIntPtr> CreateScalar(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> CreateScalar(sbyte value);
    [IntrinsicAttribute]
public static Vector64`1<float> CreateScalar(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> CreateScalar(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> CreateScalar(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> CreateScalar(ulong value);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> CreateScalarUnsafe(T value);
    [IntrinsicAttribute]
public static Vector64`1<byte> CreateScalarUnsafe(byte value);
    [IntrinsicAttribute]
public static Vector64`1<double> CreateScalarUnsafe(double value);
    [IntrinsicAttribute]
public static Vector64`1<short> CreateScalarUnsafe(short value);
    [IntrinsicAttribute]
public static Vector64`1<int> CreateScalarUnsafe(int value);
    [IntrinsicAttribute]
public static Vector64`1<long> CreateScalarUnsafe(long value);
    [IntrinsicAttribute]
public static Vector64`1<IntPtr> CreateScalarUnsafe(IntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UIntPtr> CreateScalarUnsafe(UIntPtr value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> CreateScalarUnsafe(sbyte value);
    [IntrinsicAttribute]
public static Vector64`1<float> CreateScalarUnsafe(float value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> CreateScalarUnsafe(ushort value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> CreateScalarUnsafe(UInt32 value);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> CreateScalarUnsafe(ulong value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Divide(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> Divide(Vector64`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Dot(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Equals(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAll(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool EqualsAny(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static UInt32 ExtractMostSignificantBits(Vector64`1<T> vector);
    [IntrinsicAttribute]
public static Vector64`1<float> Floor(Vector64`1<float> vector);
    [IntrinsicAttribute]
public static Vector64`1<double> Floor(Vector64`1<double> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T GetElement(Vector64`1<T> vector, int index);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> GreaterThan(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAll(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanAny(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> GreaterThanOrEqual(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAll(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool GreaterThanOrEqualAny(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> LessThan(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAll(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanAny(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> LessThanOrEqual(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAll(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool LessThanOrEqualAny(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<T> Load(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<T> LoadAligned(T* source);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<T> LoadAlignedNonTemporal(T* source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> LoadUnsafe(T& source);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<T> LoadUnsafe(T& source, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Max(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Min(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Multiply(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> Multiply(Vector64`1<T> left, T right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static Vector64`1<T> Multiply(T left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<float> Narrow(Vector64`1<double> lower, Vector64`1<double> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> Narrow(Vector64`1<short> lower, Vector64`1<short> upper);
    [IntrinsicAttribute]
public static Vector64`1<short> Narrow(Vector64`1<int> lower, Vector64`1<int> upper);
    [IntrinsicAttribute]
public static Vector64`1<int> Narrow(Vector64`1<long> lower, Vector64`1<long> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<byte> Narrow(Vector64`1<ushort> lower, Vector64`1<ushort> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> Narrow(Vector64`1<UInt32> lower, Vector64`1<UInt32> upper);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> Narrow(Vector64`1<ulong> lower, Vector64`1<ulong> upper);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Negate(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> OnesComplement(Vector64`1<T> vector);
    [IntrinsicAttribute]
public static Vector64`1<byte> ShiftLeft(Vector64`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<short> ShiftLeft(Vector64`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<int> ShiftLeft(Vector64`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<long> ShiftLeft(Vector64`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<IntPtr> ShiftLeft(Vector64`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UIntPtr> ShiftLeft(Vector64`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> ShiftLeft(Vector64`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> ShiftLeft(Vector64`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> ShiftLeft(Vector64`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> ShiftLeft(Vector64`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<short> ShiftRightArithmetic(Vector64`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<int> ShiftRightArithmetic(Vector64`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<long> ShiftRightArithmetic(Vector64`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<IntPtr> ShiftRightArithmetic(Vector64`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> ShiftRightArithmetic(Vector64`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<byte> ShiftRightLogical(Vector64`1<byte> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<short> ShiftRightLogical(Vector64`1<short> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<int> ShiftRightLogical(Vector64`1<int> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<long> ShiftRightLogical(Vector64`1<long> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<IntPtr> ShiftRightLogical(Vector64`1<IntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UIntPtr> ShiftRightLogical(Vector64`1<UIntPtr> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> ShiftRightLogical(Vector64`1<sbyte> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> ShiftRightLogical(Vector64`1<ushort> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> ShiftRightLogical(Vector64`1<UInt32> vector, int shiftCount);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> ShiftRightLogical(Vector64`1<ulong> vector, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<byte> Shuffle(Vector64`1<byte> vector, Vector64`1<byte> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<sbyte> Shuffle(Vector64`1<sbyte> vector, Vector64`1<sbyte> indices);
    [IntrinsicAttribute]
public static Vector64`1<short> Shuffle(Vector64`1<short> vector, Vector64`1<short> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> Shuffle(Vector64`1<ushort> vector, Vector64`1<ushort> indices);
    [IntrinsicAttribute]
public static Vector64`1<int> Shuffle(Vector64`1<int> vector, Vector64`1<int> indices);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> Shuffle(Vector64`1<UInt32> vector, Vector64`1<UInt32> indices);
    [IntrinsicAttribute]
public static Vector64`1<float> Shuffle(Vector64`1<float> vector, Vector64`1<int> indices);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Sqrt(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void Store(Vector64`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAligned(Vector64`1<T> source, T* destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreAlignedNonTemporal(Vector64`1<T> source, T* destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static void StoreUnsafe(Vector64`1<T> source, T& destination);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static void StoreUnsafe(Vector64`1<T> source, T& destination, UIntPtr elementOffset);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Subtract(Vector64`1<T> left, Vector64`1<T> right);
    [NullableContextAttribute("1")]
[IntrinsicAttribute]
public static T Sum(Vector64`1<T> vector);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static T ToScalar(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> ToVector128(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector128`1<T> ToVector128Unsafe(Vector64`1<T> vector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryCopyTo(Vector64`1<T> vector, Span`1<T> destination);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector64`1<ushort>, Vector64`1<ushort>> Widen(Vector64`1<byte> source);
    public static ValueTuple`2<Vector64`1<int>, Vector64`1<int>> Widen(Vector64`1<short> source);
    public static ValueTuple`2<Vector64`1<long>, Vector64`1<long>> Widen(Vector64`1<int> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector64`1<short>, Vector64`1<short>> Widen(Vector64`1<sbyte> source);
    public static ValueTuple`2<Vector64`1<double>, Vector64`1<double>> Widen(Vector64`1<float> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector64`1<UInt32>, Vector64`1<UInt32>> Widen(Vector64`1<ushort> source);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<Vector64`1<ulong>, Vector64`1<ulong>> Widen(Vector64`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> WidenLower(Vector64`1<byte> source);
    [IntrinsicAttribute]
public static Vector64`1<int> WidenLower(Vector64`1<short> source);
    [IntrinsicAttribute]
public static Vector64`1<long> WidenLower(Vector64`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<short> WidenLower(Vector64`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector64`1<double> WidenLower(Vector64`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> WidenLower(Vector64`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> WidenLower(Vector64`1<UInt32> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ushort> WidenUpper(Vector64`1<byte> source);
    [IntrinsicAttribute]
public static Vector64`1<int> WidenUpper(Vector64`1<short> source);
    [IntrinsicAttribute]
public static Vector64`1<long> WidenUpper(Vector64`1<int> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<short> WidenUpper(Vector64`1<sbyte> source);
    [IntrinsicAttribute]
public static Vector64`1<double> WidenUpper(Vector64`1<float> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<UInt32> WidenUpper(Vector64`1<ushort> source);
    [IntrinsicAttribute]
[CLSCompliantAttribute("False")]
public static Vector64`1<ulong> WidenUpper(Vector64`1<UInt32> source);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[IntrinsicAttribute]
public static Vector64`1<T> WithElement(Vector64`1<T> vector, int index, T value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static Vector64`1<T> Xor(Vector64`1<T> left, Vector64`1<T> right);
    [ExtensionAttribute]
internal static T GetElementUnsafe(Vector64`1& vector, int index);
    [ExtensionAttribute]
internal static void SetElementUnsafe(Vector64`1& vector, int index, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[IntrinsicAttribute]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Runtime.Intrinsics.Vector64DebugView`1")]
public class System.Runtime.Intrinsics.Vector64`1 : ValueType {
    internal ulong _00;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector64`1<T> AllBitsSet { get; }
    public static int Count { get; }
    public static bool IsSupported { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector64`1<T> One { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Vector64`1<T> Zero { get; }
    internal string DisplayString { get; }
    public T Item { get; }
    [IntrinsicAttribute]
public static Vector64`1<T> get_AllBitsSet();
    [IntrinsicAttribute]
public static int get_Count();
    [IntrinsicAttribute]
public static bool get_IsSupported();
    [IntrinsicAttribute]
public static Vector64`1<T> get_One();
    [IntrinsicAttribute]
public static Vector64`1<T> get_Zero();
    internal string get_DisplayString();
    public T get_Item(int index);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Addition(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_BitwiseAnd(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_BitwiseOr(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Division(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Division(Vector64`1<T> left, T right);
    [IntrinsicAttribute]
public static bool op_Equality(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_ExclusiveOr(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static bool op_Inequality(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_LeftShift(Vector64`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Multiply(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Multiply(Vector64`1<T> left, T right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Multiply(T left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_OnesComplement(Vector64`1<T> vector);
    [IntrinsicAttribute]
public static Vector64`1<T> op_RightShift(Vector64`1<T> value, int shiftCount);
    [IntrinsicAttribute]
public static Vector64`1<T> op_Subtraction(Vector64`1<T> left, Vector64`1<T> right);
    [IntrinsicAttribute]
public static Vector64`1<T> op_UnaryNegation(Vector64`1<T> vector);
    [IntrinsicAttribute]
public static Vector64`1<T> op_UnaryPlus(Vector64`1<T> value);
    [IntrinsicAttribute]
public static Vector64`1<T> op_UnsignedRightShift(Vector64`1<T> value, int shiftCount);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Vector64`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private string ToString(string format, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__SoftwareFallback|34_0(Vector64`1& self, Vector64`1<T> other);
}
[IsReadOnlyAttribute]
internal class System.Runtime.Intrinsics.Vector64DebugView`1 : ValueType {
    private Vector64`1<T> _value;
    public Byte[] ByteView { get; }
    public Double[] DoubleView { get; }
    public Int16[] Int16View { get; }
    public Int32[] Int32View { get; }
    public Int64[] Int64View { get; }
    public IntPtr[] NIntView { get; }
    public UIntPtr[] NUIntView { get; }
    public SByte[] SByteView { get; }
    public Single[] SingleView { get; }
    public UInt16[] UInt16View { get; }
    public UInt32[] UInt32View { get; }
    public UInt64[] UInt64View { get; }
    public Vector64DebugView`1(Vector64`1<T> value);
    public Byte[] get_ByteView();
    public Double[] get_DoubleView();
    public Int16[] get_Int16View();
    public Int32[] get_Int32View();
    public Int64[] get_Int64View();
    public IntPtr[] get_NIntView();
    public UIntPtr[] get_NUIntView();
    public SByte[] get_SByteView();
    public Single[] get_SingleView();
    public UInt16[] get_UInt16View();
    public UInt32[] get_UInt32View();
    public UInt64[] get_UInt64View();
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.Wasm.PackedSimd : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<sbyte> Splat(sbyte value);
    public static Vector128`1<byte> Splat(byte value);
    public static Vector128`1<short> Splat(short value);
    public static Vector128`1<ushort> Splat(ushort value);
    public static Vector128`1<int> Splat(int value);
    public static Vector128`1<UInt32> Splat(UInt32 value);
    public static Vector128`1<long> Splat(long value);
    public static Vector128`1<ulong> Splat(ulong value);
    public static Vector128`1<float> Splat(float value);
    public static Vector128`1<double> Splat(double value);
    public static Vector128`1<IntPtr> Splat(IntPtr value);
    public static Vector128`1<UIntPtr> Splat(UIntPtr value);
    public static int ExtractScalar(Vector128`1<sbyte> value, byte index);
    public static UInt32 ExtractScalar(Vector128`1<byte> value, byte index);
    public static int ExtractScalar(Vector128`1<short> value, byte index);
    public static UInt32 ExtractScalar(Vector128`1<ushort> value, byte index);
    public static int ExtractScalar(Vector128`1<int> value, byte index);
    public static UInt32 ExtractScalar(Vector128`1<UInt32> value, byte index);
    public static long ExtractScalar(Vector128`1<long> value, byte index);
    public static ulong ExtractScalar(Vector128`1<ulong> value, byte index);
    public static float ExtractScalar(Vector128`1<float> value, byte index);
    public static double ExtractScalar(Vector128`1<double> value, byte index);
    public static IntPtr ExtractScalar(Vector128`1<IntPtr> value, byte index);
    public static UIntPtr ExtractScalar(Vector128`1<UIntPtr> value, byte index);
    public static Vector128`1<sbyte> ReplaceScalar(Vector128`1<sbyte> vector, byte imm, int value);
    public static Vector128`1<byte> ReplaceScalar(Vector128`1<byte> vector, byte imm, UInt32 value);
    public static Vector128`1<short> ReplaceScalar(Vector128`1<short> vector, byte imm, int value);
    public static Vector128`1<ushort> ReplaceScalar(Vector128`1<ushort> vector, byte imm, UInt32 value);
    public static Vector128`1<int> ReplaceScalar(Vector128`1<int> vector, byte imm, int value);
    public static Vector128`1<int> ReplaceScalar(Vector128`1<UInt32> vector, byte imm, UInt32 value);
    public static Vector128`1<long> ReplaceScalar(Vector128`1<long> vector, byte imm, long value);
    public static Vector128`1<ulong> ReplaceScalar(Vector128`1<ulong> vector, byte imm, ulong value);
    public static Vector128`1<float> ReplaceScalar(Vector128`1<float> vector, byte imm, float value);
    public static Vector128`1<double> ReplaceScalar(Vector128`1<double> vector, byte imm, double value);
    public static Vector128`1<IntPtr> ReplaceScalar(Vector128`1<IntPtr> vector, byte imm, IntPtr value);
    public static Vector128`1<UIntPtr> ReplaceScalar(Vector128`1<UIntPtr> vector, byte imm, UIntPtr value);
    public static Vector128`1<sbyte> Swizzle(Vector128`1<sbyte> vector, Vector128`1<sbyte> indices);
    public static Vector128`1<byte> Swizzle(Vector128`1<byte> vector, Vector128`1<byte> indices);
    public static Vector128`1<sbyte> Add(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> Add(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Add(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Add(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Add(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Add(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Add(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Add(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<IntPtr> Add(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> Add(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> Subtract(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> Subtract(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Subtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Subtract(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Subtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Subtract(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Subtract(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Subtract(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<IntPtr> Subtract(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> Subtract(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<short> Multiply(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Multiply(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Multiply(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Multiply(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<IntPtr> Multiply(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> Multiply(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<int> Dot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> Negate(Vector128`1<sbyte> value);
    public static Vector128`1<byte> Negate(Vector128`1<byte> value);
    public static Vector128`1<short> Negate(Vector128`1<short> value);
    public static Vector128`1<ushort> Negate(Vector128`1<ushort> value);
    public static Vector128`1<int> Negate(Vector128`1<int> value);
    public static Vector128`1<UInt32> Negate(Vector128`1<UInt32> value);
    public static Vector128`1<long> Negate(Vector128`1<long> value);
    public static Vector128`1<ulong> Negate(Vector128`1<ulong> value);
    public static Vector128`1<IntPtr> Negate(Vector128`1<IntPtr> value);
    public static Vector128`1<UIntPtr> Negate(Vector128`1<UIntPtr> value);
    public static Vector128`1<short> MultiplyWideningLower(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> MultiplyWideningLower(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> MultiplyWideningLower(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> MultiplyWideningLower(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<long> MultiplyWideningLower(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<ulong> MultiplyWideningLower(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<short> MultiplyWideningUpper(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> MultiplyWideningUpper(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<int> MultiplyWideningUpper(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<UInt32> MultiplyWideningUpper(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<long> MultiplyWideningUpper(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<ulong> MultiplyWideningUpper(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<short> AddPairwiseWidening(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> AddPairwiseWidening(Vector128`1<byte> value);
    public static Vector128`1<int> AddPairwiseWidening(Vector128`1<short> value);
    public static Vector128`1<UInt32> AddPairwiseWidening(Vector128`1<ushort> value);
    public static Vector128`1<sbyte> AddSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<sbyte> SubtractSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> SubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> SubtractSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> MultiplyRoundedSaturateQ15(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<byte> AverageRounded(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> AverageRounded(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<sbyte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<short> Abs(Vector128`1<short> value);
    public static Vector128`1<int> Abs(Vector128`1<int> value);
    public static Vector128`1<long> Abs(Vector128`1<long> value);
    public static Vector128`1<IntPtr> Abs(Vector128`1<IntPtr> value);
    public static Vector128`1<sbyte> ShiftLeft(Vector128`1<sbyte> value, int count);
    public static Vector128`1<byte> ShiftLeft(Vector128`1<byte> value, int count);
    public static Vector128`1<short> ShiftLeft(Vector128`1<short> value, int count);
    public static Vector128`1<ushort> ShiftLeft(Vector128`1<ushort> value, int count);
    public static Vector128`1<int> ShiftLeft(Vector128`1<int> value, int count);
    public static Vector128`1<UInt32> ShiftLeft(Vector128`1<UInt32> value, int count);
    public static Vector128`1<long> ShiftLeft(Vector128`1<long> value, int count);
    public static Vector128`1<ulong> ShiftLeft(Vector128`1<ulong> value, int count);
    public static Vector128`1<IntPtr> ShiftLeft(Vector128`1<IntPtr> value, int count);
    public static Vector128`1<UIntPtr> ShiftLeft(Vector128`1<UIntPtr> value, int count);
    public static Vector128`1<sbyte> ShiftRightArithmetic(Vector128`1<sbyte> value, int count);
    public static Vector128`1<byte> ShiftRightArithmetic(Vector128`1<byte> value, int count);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, int count);
    public static Vector128`1<ushort> ShiftRightArithmetic(Vector128`1<ushort> value, int count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, int count);
    public static Vector128`1<UInt32> ShiftRightArithmetic(Vector128`1<UInt32> value, int count);
    public static Vector128`1<long> ShiftRightArithmetic(Vector128`1<long> value, int count);
    public static Vector128`1<ulong> ShiftRightArithmetic(Vector128`1<ulong> value, int count);
    public static Vector128`1<IntPtr> ShiftRightArithmetic(Vector128`1<IntPtr> value, int count);
    public static Vector128`1<UIntPtr> ShiftRightArithmetic(Vector128`1<UIntPtr> value, int count);
    public static Vector128`1<sbyte> ShiftRightLogical(Vector128`1<sbyte> value, int count);
    public static Vector128`1<byte> ShiftRightLogical(Vector128`1<byte> value, int count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, int count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, int count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, int count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, int count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, int count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, int count);
    public static Vector128`1<IntPtr> ShiftRightLogical(Vector128`1<IntPtr> value, int count);
    public static Vector128`1<UIntPtr> ShiftRightLogical(Vector128`1<UIntPtr> value, int count);
    public static Vector128`1<sbyte> And(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> And(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> And(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> And(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> And(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> And(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> And(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> And(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> And(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> And(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> And(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> And(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> Or(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> Or(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Or(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Or(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Or(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Or(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Or(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Or(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> Or(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Or(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> Or(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> Or(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> Xor(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> Xor(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Xor(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Xor(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Xor(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Xor(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Xor(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Xor(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> Xor(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Xor(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> Xor(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> Xor(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> Not(Vector128`1<sbyte> value);
    public static Vector128`1<byte> Not(Vector128`1<byte> value);
    public static Vector128`1<short> Not(Vector128`1<short> value);
    public static Vector128`1<ushort> Not(Vector128`1<ushort> value);
    public static Vector128`1<int> Not(Vector128`1<int> value);
    public static Vector128`1<UInt32> Not(Vector128`1<UInt32> value);
    public static Vector128`1<long> Not(Vector128`1<long> value);
    public static Vector128`1<ulong> Not(Vector128`1<ulong> value);
    public static Vector128`1<float> Not(Vector128`1<float> value);
    public static Vector128`1<double> Not(Vector128`1<double> value);
    public static Vector128`1<IntPtr> Not(Vector128`1<IntPtr> value);
    public static Vector128`1<UIntPtr> Not(Vector128`1<UIntPtr> value);
    public static Vector128`1<sbyte> AndNot(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> AndNot(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AndNot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AndNot(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> AndNot(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> AndNot(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> AndNot(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> AndNot(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> AndNot(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> AndNot(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> AndNot(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> AndNot(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> BitwiseSelect(Vector128`1<sbyte> left, Vector128`1<sbyte> right, Vector128`1<sbyte> select);
    public static Vector128`1<byte> BitwiseSelect(Vector128`1<byte> left, Vector128`1<byte> right, Vector128`1<byte> select);
    public static Vector128`1<short> BitwiseSelect(Vector128`1<short> left, Vector128`1<short> right, Vector128`1<short> select);
    public static Vector128`1<ushort> BitwiseSelect(Vector128`1<ushort> left, Vector128`1<ushort> right, Vector128`1<ushort> select);
    public static Vector128`1<int> BitwiseSelect(Vector128`1<int> left, Vector128`1<int> right, Vector128`1<int> select);
    public static Vector128`1<UInt32> BitwiseSelect(Vector128`1<UInt32> left, Vector128`1<UInt32> right, Vector128`1<UInt32> select);
    public static Vector128`1<long> BitwiseSelect(Vector128`1<long> left, Vector128`1<long> right, Vector128`1<long> select);
    public static Vector128`1<ulong> BitwiseSelect(Vector128`1<ulong> left, Vector128`1<ulong> right, Vector128`1<ulong> select);
    public static Vector128`1<float> BitwiseSelect(Vector128`1<float> left, Vector128`1<float> right, Vector128`1<float> select);
    public static Vector128`1<double> BitwiseSelect(Vector128`1<double> left, Vector128`1<double> right, Vector128`1<double> select);
    public static Vector128`1<IntPtr> BitwiseSelect(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right, Vector128`1<IntPtr> select);
    public static Vector128`1<UIntPtr> BitwiseSelect(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right, Vector128`1<UIntPtr> select);
    public static Vector128`1<byte> PopCount(Vector128`1<byte> value);
    public static bool AnyTrue(Vector128`1<sbyte> value);
    public static bool AnyTrue(Vector128`1<byte> value);
    public static bool AnyTrue(Vector128`1<short> value);
    public static bool AnyTrue(Vector128`1<ushort> value);
    public static bool AnyTrue(Vector128`1<int> value);
    public static bool AnyTrue(Vector128`1<UInt32> value);
    public static bool AnyTrue(Vector128`1<long> value);
    public static bool AnyTrue(Vector128`1<ulong> value);
    public static bool AnyTrue(Vector128`1<float> value);
    public static bool AnyTrue(Vector128`1<double> value);
    public static bool AnyTrue(Vector128`1<IntPtr> value);
    public static bool AnyTrue(Vector128`1<UIntPtr> value);
    public static bool AllTrue(Vector128`1<sbyte> value);
    public static bool AllTrue(Vector128`1<byte> value);
    public static bool AllTrue(Vector128`1<short> value);
    public static bool AllTrue(Vector128`1<ushort> value);
    public static bool AllTrue(Vector128`1<int> value);
    public static bool AllTrue(Vector128`1<UInt32> value);
    public static bool AllTrue(Vector128`1<long> value);
    public static bool AllTrue(Vector128`1<ulong> value);
    public static bool AllTrue(Vector128`1<IntPtr> value);
    public static bool AllTrue(Vector128`1<UIntPtr> value);
    public static int Bitmask(Vector128`1<sbyte> value);
    public static int Bitmask(Vector128`1<byte> value);
    public static int Bitmask(Vector128`1<short> value);
    public static int Bitmask(Vector128`1<ushort> value);
    public static int Bitmask(Vector128`1<int> value);
    public static int Bitmask(Vector128`1<UInt32> value);
    public static int Bitmask(Vector128`1<long> value);
    public static int Bitmask(Vector128`1<ulong> value);
    public static int Bitmask(Vector128`1<IntPtr> value);
    public static int Bitmask(Vector128`1<UIntPtr> value);
    public static Vector128`1<sbyte> CompareEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> CompareEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> CompareEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> CompareEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> CompareEqual(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> CompareEqual(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> CompareNotEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareNotEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareNotEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareNotEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareNotEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareNotEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> CompareNotEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareNotEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> CompareNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> CompareNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> CompareNotEqual(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> CompareNotEqual(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> CompareLessThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareLessThan(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareLessThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareLessThan(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareLessThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareLessThan(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> CompareLessThan(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareLessThan(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> CompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> CompareLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> CompareLessThan(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> CompareLessThan(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> CompareLessThanOrEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareLessThanOrEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareLessThanOrEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareLessThanOrEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareLessThanOrEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareLessThanOrEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> CompareLessThanOrEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareLessThanOrEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> CompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> CompareLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> CompareLessThanOrEqual(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> CompareLessThanOrEqual(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> CompareGreaterThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareGreaterThan(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareGreaterThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareGreaterThan(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareGreaterThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareGreaterThan(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> CompareGreaterThan(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareGreaterThan(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> CompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> CompareGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> CompareGreaterThan(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> CompareGreaterThan(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> CompareGreaterThanOrEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareGreaterThanOrEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareGreaterThanOrEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareGreaterThanOrEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareGreaterThanOrEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareGreaterThanOrEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> CompareGreaterThanOrEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareGreaterThanOrEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<float> CompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> CompareGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<IntPtr> CompareGreaterThanOrEqual(Vector128`1<IntPtr> left, Vector128`1<IntPtr> right);
    public static Vector128`1<UIntPtr> CompareGreaterThanOrEqual(Vector128`1<UIntPtr> left, Vector128`1<UIntPtr> right);
    public static Vector128`1<sbyte> LoadVector128(SByte* address);
    public static Vector128`1<byte> LoadVector128(Byte* address);
    public static Vector128`1<short> LoadVector128(Int16* address);
    public static Vector128`1<ushort> LoadVector128(UInt16* address);
    public static Vector128`1<int> LoadVector128(Int32* address);
    public static Vector128`1<UInt32> LoadVector128(UInt32* address);
    public static Vector128`1<long> LoadVector128(Int64* address);
    public static Vector128`1<ulong> LoadVector128(UInt64* address);
    public static Vector128`1<float> LoadVector128(Single* address);
    public static Vector128`1<double> LoadVector128(Double* address);
    public static Vector128`1<IntPtr> LoadVector128(IntPtr* address);
    public static Vector128`1<UIntPtr> LoadVector128(UIntPtr* address);
    public static Vector128`1<int> LoadScalarVector128(Int32* address);
    public static Vector128`1<UInt32> LoadScalarVector128(UInt32* address);
    public static Vector128`1<long> LoadScalarVector128(Int64* address);
    public static Vector128`1<ulong> LoadScalarVector128(UInt64* address);
    public static Vector128`1<float> LoadScalarVector128(Single* address);
    public static Vector128`1<double> LoadScalarVector128(Double* address);
    public static Vector128`1<IntPtr> LoadScalarVector128(IntPtr* address);
    public static Vector128`1<UIntPtr> LoadScalarVector128(UIntPtr* address);
    public static Vector128`1<sbyte> LoadScalarAndSplatVector128(SByte* address);
    public static Vector128`1<byte> LoadScalarAndSplatVector128(Byte* address);
    public static Vector128`1<short> LoadScalarAndSplatVector128(Int16* address);
    public static Vector128`1<ushort> LoadScalarAndSplatVector128(UInt16* address);
    public static Vector128`1<int> LoadScalarAndSplatVector128(Int32* address);
    public static Vector128`1<UInt32> LoadScalarAndSplatVector128(UInt32* address);
    public static Vector128`1<long> LoadScalarAndSplatVector128(Int64* address);
    public static Vector128`1<ulong> LoadScalarAndSplatVector128(UInt64* address);
    public static Vector128`1<float> LoadScalarAndSplatVector128(Single* address);
    public static Vector128`1<double> LoadScalarAndSplatVector128(Double* address);
    public static Vector128`1<IntPtr> LoadScalarAndSplatVector128(IntPtr* address);
    public static Vector128`1<UIntPtr> LoadScalarAndSplatVector128(UIntPtr* address);
    public static Vector128`1<sbyte> LoadScalarAndInsert(SByte* address, Vector128`1<sbyte> vector, byte index);
    public static Vector128`1<byte> LoadScalarAndInsert(Byte* address, Vector128`1<byte> vector, byte index);
    public static Vector128`1<short> LoadScalarAndInsert(Int16* address, Vector128`1<short> vector, byte index);
    public static Vector128`1<ushort> LoadScalarAndInsert(UInt16* address, Vector128`1<ushort> vector, byte index);
    public static Vector128`1<int> LoadScalarAndInsert(Int32* address, Vector128`1<int> vector, byte index);
    public static Vector128`1<UInt32> LoadScalarAndInsert(UInt32* address, Vector128`1<UInt32> vector, byte index);
    public static Vector128`1<long> LoadScalarAndInsert(Int64* address, Vector128`1<long> vector, byte index);
    public static Vector128`1<ulong> LoadScalarAndInsert(UInt64* address, Vector128`1<ulong> vector, byte index);
    public static Vector128`1<float> LoadScalarAndInsert(Single* address, Vector128`1<float> vector, byte index);
    public static Vector128`1<double> LoadScalarAndInsert(Double* address, Vector128`1<double> vector, byte index);
    public static Vector128`1<IntPtr> LoadScalarAndInsert(IntPtr* address, Vector128`1<IntPtr> vector, byte index);
    public static Vector128`1<UIntPtr> LoadScalarAndInsert(UIntPtr* address, Vector128`1<UIntPtr> vector, byte index);
    public static Vector128`1<short> LoadWideningVector128(SByte* address);
    public static Vector128`1<ushort> LoadWideningVector128(Byte* address);
    public static Vector128`1<int> LoadWideningVector128(Int16* address);
    public static Vector128`1<UInt32> LoadWideningVector128(UInt16* address);
    public static Vector128`1<long> LoadWideningVector128(Int32* address);
    public static Vector128`1<ulong> LoadWideningVector128(UInt32* address);
    public static void Store(SByte* address, Vector128`1<sbyte> source);
    public static void Store(Byte* address, Vector128`1<byte> source);
    public static void Store(Int16* address, Vector128`1<short> source);
    public static void Store(UInt16* address, Vector128`1<ushort> source);
    public static void Store(Int32* address, Vector128`1<int> source);
    public static void Store(UInt32* address, Vector128`1<UInt32> source);
    public static void Store(Int64* address, Vector128`1<long> source);
    public static void Store(UInt64* address, Vector128`1<ulong> source);
    public static void Store(Single* address, Vector128`1<float> source);
    public static void Store(Double* address, Vector128`1<double> source);
    public static void Store(IntPtr* address, Vector128`1<IntPtr> source);
    public static void Store(UIntPtr* address, Vector128`1<UIntPtr> source);
    public static void StoreSelectedScalar(SByte* address, Vector128`1<sbyte> source, byte index);
    public static void StoreSelectedScalar(Byte* address, Vector128`1<byte> source, byte index);
    public static void StoreSelectedScalar(Int16* address, Vector128`1<short> source, byte index);
    public static void StoreSelectedScalar(UInt16* address, Vector128`1<ushort> source, byte index);
    public static void StoreSelectedScalar(Int32* address, Vector128`1<int> source, byte index);
    public static void StoreSelectedScalar(UInt32* address, Vector128`1<UInt32> source, byte index);
    public static void StoreSelectedScalar(Int64* address, Vector128`1<long> source, byte index);
    public static void StoreSelectedScalar(UInt64* address, Vector128`1<ulong> source, byte index);
    public static void StoreSelectedScalar(Single* address, Vector128`1<float> source, byte index);
    public static void StoreSelectedScalar(Double* address, Vector128`1<double> source, byte index);
    public static void StoreSelectedScalar(IntPtr* address, Vector128`1<IntPtr> source, byte index);
    public static void StoreSelectedScalar(UIntPtr* address, Vector128`1<UIntPtr> source, byte index);
    public static Vector128`1<float> Negate(Vector128`1<float> value);
    public static Vector128`1<double> Negate(Vector128`1<double> value);
    public static Vector128`1<float> Abs(Vector128`1<float> value);
    public static Vector128`1<double> Abs(Vector128`1<double> value);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> PseudoMin(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> PseudoMin(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> PseudoMax(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> PseudoMax(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> Add(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Add(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> Subtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Subtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector128`1<float> Ceiling(Vector128`1<float> value);
    public static Vector128`1<double> Ceiling(Vector128`1<double> value);
    public static Vector128`1<float> Floor(Vector128`1<float> value);
    public static Vector128`1<double> Floor(Vector128`1<double> value);
    public static Vector128`1<float> Truncate(Vector128`1<float> value);
    public static Vector128`1<double> Truncate(Vector128`1<double> value);
    public static Vector128`1<float> RoundToNearest(Vector128`1<float> value);
    public static Vector128`1<double> RoundToNearest(Vector128`1<double> value);
    public static Vector128`1<float> ConvertToSingle(Vector128`1<int> value);
    public static Vector128`1<float> ConvertToSingle(Vector128`1<UInt32> value);
    public static Vector128`1<float> ConvertToSingle(Vector128`1<double> value);
    public static Vector128`1<double> ConvertToDoubleLower(Vector128`1<int> value);
    public static Vector128`1<double> ConvertToDoubleLower(Vector128`1<UInt32> value);
    public static Vector128`1<double> ConvertToDoubleLower(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToInt32Saturate(Vector128`1<float> value);
    public static Vector128`1<UInt32> ConvertToUInt32Saturate(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToInt32Saturate(Vector128`1<double> value);
    public static Vector128`1<UInt32> ConvertToUInt32Saturate(Vector128`1<double> value);
    public static Vector128`1<sbyte> ConvertNarrowingSaturateSigned(Vector128`1<short> lower, Vector128`1<short> upper);
    public static Vector128`1<short> ConvertNarrowingSaturateSigned(Vector128`1<int> lower, Vector128`1<int> upper);
    public static Vector128`1<byte> ConvertNarrowingSaturateUnsigned(Vector128`1<short> lower, Vector128`1<short> upper);
    public static Vector128`1<ushort> ConvertNarrowingSaturateUnsigned(Vector128`1<int> lower, Vector128`1<int> upper);
    public static Vector128`1<short> SignExtendWideningLower(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> SignExtendWideningLower(Vector128`1<byte> value);
    public static Vector128`1<int> SignExtendWideningLower(Vector128`1<short> value);
    public static Vector128`1<UInt32> SignExtendWideningLower(Vector128`1<ushort> value);
    public static Vector128`1<long> SignExtendWideningLower(Vector128`1<int> value);
    public static Vector128`1<ulong> SignExtendWideningLower(Vector128`1<UInt32> value);
    public static Vector128`1<short> SignExtendWideningUpper(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> SignExtendWideningUpper(Vector128`1<byte> value);
    public static Vector128`1<int> SignExtendWideningUpper(Vector128`1<short> value);
    public static Vector128`1<UInt32> SignExtendWideningUpper(Vector128`1<ushort> value);
    public static Vector128`1<long> SignExtendWideningUpper(Vector128`1<int> value);
    public static Vector128`1<ulong> SignExtendWideningUpper(Vector128`1<UInt32> value);
    public static Vector128`1<short> ZeroExtendWideningLower(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> ZeroExtendWideningLower(Vector128`1<byte> value);
    public static Vector128`1<int> ZeroExtendWideningLower(Vector128`1<short> value);
    public static Vector128`1<UInt32> ZeroExtendWideningLower(Vector128`1<ushort> value);
    public static Vector128`1<long> ZeroExtendWideningLower(Vector128`1<int> value);
    public static Vector128`1<ulong> ZeroExtendWideningLower(Vector128`1<UInt32> value);
    public static Vector128`1<short> ZeroExtendWideningUpper(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> ZeroExtendWideningUpper(Vector128`1<byte> value);
    public static Vector128`1<int> ZeroExtendWideningUpper(Vector128`1<short> value);
    public static Vector128`1<UInt32> ZeroExtendWideningUpper(Vector128`1<ushort> value);
    public static Vector128`1<long> ZeroExtendWideningUpper(Vector128`1<int> value);
    public static Vector128`1<ulong> ZeroExtendWideningUpper(Vector128`1<UInt32> value);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Aes : Sse2 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<byte> Decrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> DecryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> Encrypt(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> EncryptLast(Vector128`1<byte> value, Vector128`1<byte> roundKey);
    public static Vector128`1<byte> InverseMixColumns(Vector128`1<byte> value);
    public static Vector128`1<byte> KeygenAssist(Vector128`1<byte> value, byte control);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx : Sse42 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector256`1<float> Add(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Add(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AddSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AddSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> And(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> And(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> AndNot(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> AndNot(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Blend(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Blend(Vector256`1<double> left, Vector256`1<double> right, byte control);
    public static Vector256`1<float> BlendVariable(Vector256`1<float> left, Vector256`1<float> right, Vector256`1<float> mask);
    public static Vector256`1<double> BlendVariable(Vector256`1<double> left, Vector256`1<double> right, Vector256`1<double> mask);
    public static Vector128`1<float> BroadcastScalarToVector128(Single* source);
    public static Vector256`1<float> BroadcastScalarToVector256(Single* source);
    public static Vector256`1<double> BroadcastScalarToVector256(Double* source);
    public static Vector256`1<float> BroadcastVector128ToVector256(Single* address);
    public static Vector256`1<double> BroadcastVector128ToVector256(Double* address);
    public static Vector256`1<float> Ceiling(Vector256`1<float> value);
    public static Vector256`1<double> Ceiling(Vector256`1<double> value);
    public static Vector128`1<float> Compare(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static Vector256`1<float> Compare(Vector256`1<float> left, Vector256`1<float> right, FloatComparisonMode mode);
    public static Vector256`1<float> CompareEqual(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareGreaterThan(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareGreaterThanOrEqual(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareLessThan(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareLessThanOrEqual(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareNotEqual(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareNotGreaterThan(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareNotGreaterThanOrEqual(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareNotLessThan(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareNotLessThanOrEqual(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareOrdered(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<float> CompareUnordered(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector128`1<double> Compare(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector256`1<double> Compare(Vector256`1<double> left, Vector256`1<double> right, FloatComparisonMode mode);
    public static Vector256`1<double> CompareEqual(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareGreaterThan(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareGreaterThanOrEqual(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareLessThan(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareLessThanOrEqual(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareNotEqual(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareNotGreaterThan(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareNotGreaterThanOrEqual(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareNotLessThan(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareNotLessThanOrEqual(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareOrdered(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<double> CompareUnordered(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector128`1<float> CompareScalar(Vector128`1<float> left, Vector128`1<float> right, FloatComparisonMode mode);
    public static Vector128`1<double> CompareScalar(Vector128`1<double> left, Vector128`1<double> right, FloatComparisonMode mode);
    public static Vector128`1<int> ConvertToVector128Int32(Vector256`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector256`1<double> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<int> value);
    public static Vector256`1<double> ConvertToVector256Double(Vector128`1<float> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector256`1<float> value);
    public static Vector256`1<float> ConvertToVector256Single(Vector256`1<int> value);
    public static Vector256`1<int> ConvertToVector256Int32WithTruncation(Vector256`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector256`1<double> value);
    public static Vector256`1<float> Divide(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Divide(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> DotProduct(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<float> DuplicateEvenIndexed(Vector256`1<float> value);
    public static Vector256`1<double> DuplicateEvenIndexed(Vector256`1<double> value);
    public static Vector256`1<float> DuplicateOddIndexed(Vector256`1<float> value);
    public static Vector128`1<byte> ExtractVector128(Vector256`1<byte> value, byte index);
    public static Vector128`1<sbyte> ExtractVector128(Vector256`1<sbyte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector256`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector256`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector256`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector256`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector256`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector256`1<ulong> value, byte index);
    public static Vector128`1<float> ExtractVector128(Vector256`1<float> value, byte index);
    public static Vector128`1<double> ExtractVector128(Vector256`1<double> value, byte index);
    public static Vector256`1<float> Floor(Vector256`1<float> value);
    public static Vector256`1<double> Floor(Vector256`1<double> value);
    public static Vector256`1<float> HorizontalAdd(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalAdd(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> HorizontalSubtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> HorizontalSubtract(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Vector128`1<short> data, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Vector128`1<int> data, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Vector128`1<long> data, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector256`1<float> InsertVector128(Vector256`1<float> value, Vector128`1<float> data, byte index);
    public static Vector256`1<double> InsertVector128(Vector256`1<double> value, Vector128`1<double> data, byte index);
    public static Vector256`1<sbyte> LoadAlignedVector256(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256(UInt64* address);
    public static Vector256`1<float> LoadAlignedVector256(Single* address);
    public static Vector256`1<double> LoadAlignedVector256(Double* address);
    public static Vector256`1<sbyte> LoadDquVector256(SByte* address);
    public static Vector256`1<byte> LoadDquVector256(Byte* address);
    public static Vector256`1<short> LoadDquVector256(Int16* address);
    public static Vector256`1<ushort> LoadDquVector256(UInt16* address);
    public static Vector256`1<int> LoadDquVector256(Int32* address);
    public static Vector256`1<UInt32> LoadDquVector256(UInt32* address);
    public static Vector256`1<long> LoadDquVector256(Int64* address);
    public static Vector256`1<ulong> LoadDquVector256(UInt64* address);
    public static Vector256`1<sbyte> LoadVector256(SByte* address);
    public static Vector256`1<byte> LoadVector256(Byte* address);
    public static Vector256`1<short> LoadVector256(Int16* address);
    public static Vector256`1<ushort> LoadVector256(UInt16* address);
    public static Vector256`1<int> LoadVector256(Int32* address);
    public static Vector256`1<UInt32> LoadVector256(UInt32* address);
    public static Vector256`1<long> LoadVector256(Int64* address);
    public static Vector256`1<ulong> LoadVector256(UInt64* address);
    public static Vector256`1<float> LoadVector256(Single* address);
    public static Vector256`1<double> LoadVector256(Double* address);
    public static Vector128`1<float> MaskLoad(Single* address, Vector128`1<float> mask);
    public static Vector128`1<double> MaskLoad(Double* address, Vector128`1<double> mask);
    public static Vector256`1<float> MaskLoad(Single* address, Vector256`1<float> mask);
    public static Vector256`1<double> MaskLoad(Double* address, Vector256`1<double> mask);
    public static void MaskStore(Single* address, Vector128`1<float> mask, Vector128`1<float> source);
    public static void MaskStore(Double* address, Vector128`1<double> mask, Vector128`1<double> source);
    public static void MaskStore(Single* address, Vector256`1<float> mask, Vector256`1<float> source);
    public static void MaskStore(Double* address, Vector256`1<double> mask, Vector256`1<double> source);
    public static Vector256`1<float> Max(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Max(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Min(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Min(Vector256`1<double> left, Vector256`1<double> right);
    public static int MoveMask(Vector256`1<float> value);
    public static int MoveMask(Vector256`1<double> value);
    public static Vector256`1<float> Multiply(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Multiply(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Or(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Or(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector128`1<float> Permute(Vector128`1<float> value, byte control);
    public static Vector128`1<double> Permute(Vector128`1<double> value, byte control);
    public static Vector256`1<float> Permute(Vector256`1<float> value, byte control);
    public static Vector256`1<double> Permute(Vector256`1<double> value, byte control);
    public static Vector256`1<byte> Permute2x128(Vector256`1<byte> left, Vector256`1<byte> right, byte control);
    public static Vector256`1<sbyte> Permute2x128(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte control);
    public static Vector256`1<short> Permute2x128(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Permute2x128(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Permute2x128(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Permute2x128(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<long> Permute2x128(Vector256`1<long> left, Vector256`1<long> right, byte control);
    public static Vector256`1<ulong> Permute2x128(Vector256`1<ulong> left, Vector256`1<ulong> right, byte control);
    public static Vector256`1<float> Permute2x128(Vector256`1<float> left, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Permute2x128(Vector256`1<double> left, Vector256`1<double> right, byte control);
    public static Vector128`1<float> PermuteVar(Vector128`1<float> left, Vector128`1<int> control);
    public static Vector128`1<double> PermuteVar(Vector128`1<double> left, Vector128`1<long> control);
    public static Vector256`1<float> PermuteVar(Vector256`1<float> left, Vector256`1<int> control);
    public static Vector256`1<double> PermuteVar(Vector256`1<double> left, Vector256`1<long> control);
    public static Vector256`1<float> Reciprocal(Vector256`1<float> value);
    public static Vector256`1<float> ReciprocalSqrt(Vector256`1<float> value);
    public static Vector256`1<float> RoundCurrentDirection(Vector256`1<float> value);
    public static Vector256`1<double> RoundCurrentDirection(Vector256`1<double> value);
    public static Vector256`1<float> RoundToNearestInteger(Vector256`1<float> value);
    public static Vector256`1<double> RoundToNearestInteger(Vector256`1<double> value);
    public static Vector256`1<float> RoundToNegativeInfinity(Vector256`1<float> value);
    public static Vector256`1<double> RoundToNegativeInfinity(Vector256`1<double> value);
    public static Vector256`1<float> RoundToPositiveInfinity(Vector256`1<float> value);
    public static Vector256`1<double> RoundToPositiveInfinity(Vector256`1<double> value);
    public static Vector256`1<float> RoundToZero(Vector256`1<float> value);
    public static Vector256`1<double> RoundToZero(Vector256`1<double> value);
    public static Vector256`1<float> Shuffle(Vector256`1<float> value, Vector256`1<float> right, byte control);
    public static Vector256`1<double> Shuffle(Vector256`1<double> value, Vector256`1<double> right, byte control);
    public static Vector256`1<float> Sqrt(Vector256`1<float> value);
    public static Vector256`1<double> Sqrt(Vector256`1<double> value);
    public static void Store(SByte* address, Vector256`1<sbyte> source);
    public static void Store(Byte* address, Vector256`1<byte> source);
    public static void Store(Int16* address, Vector256`1<short> source);
    public static void Store(UInt16* address, Vector256`1<ushort> source);
    public static void Store(Int32* address, Vector256`1<int> source);
    public static void Store(UInt32* address, Vector256`1<UInt32> source);
    public static void Store(Int64* address, Vector256`1<long> source);
    public static void Store(UInt64* address, Vector256`1<ulong> source);
    public static void Store(Single* address, Vector256`1<float> source);
    public static void Store(Double* address, Vector256`1<double> source);
    public static void StoreAligned(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector256`1<byte> source);
    public static void StoreAligned(Int16* address, Vector256`1<short> source);
    public static void StoreAligned(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector256`1<int> source);
    public static void StoreAligned(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector256`1<long> source);
    public static void StoreAligned(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAligned(Single* address, Vector256`1<float> source);
    public static void StoreAligned(Double* address, Vector256`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector256`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector256`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector256`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector256`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector256`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector256`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector256`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector256`1<ulong> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector256`1<float> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector256`1<double> source);
    public static Vector256`1<float> Subtract(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Subtract(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestC(Vector256`1<byte> left, Vector256`1<byte> right);
    public static bool TestC(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static bool TestC(Vector256`1<short> left, Vector256`1<short> right);
    public static bool TestC(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static bool TestC(Vector256`1<int> left, Vector256`1<int> right);
    public static bool TestC(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static bool TestC(Vector256`1<long> left, Vector256`1<long> right);
    public static bool TestC(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static bool TestC(Vector256`1<float> left, Vector256`1<float> right);
    public static bool TestC(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestNotZAndNotC(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestNotZAndNotC(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestNotZAndNotC(Vector256`1<byte> left, Vector256`1<byte> right);
    public static bool TestNotZAndNotC(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static bool TestNotZAndNotC(Vector256`1<short> left, Vector256`1<short> right);
    public static bool TestNotZAndNotC(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static bool TestNotZAndNotC(Vector256`1<int> left, Vector256`1<int> right);
    public static bool TestNotZAndNotC(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static bool TestNotZAndNotC(Vector256`1<long> left, Vector256`1<long> right);
    public static bool TestNotZAndNotC(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static bool TestNotZAndNotC(Vector256`1<float> left, Vector256`1<float> right);
    public static bool TestNotZAndNotC(Vector256`1<double> left, Vector256`1<double> right);
    public static bool TestZ(Vector128`1<float> left, Vector128`1<float> right);
    public static bool TestZ(Vector128`1<double> left, Vector128`1<double> right);
    public static bool TestZ(Vector256`1<byte> left, Vector256`1<byte> right);
    public static bool TestZ(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static bool TestZ(Vector256`1<short> left, Vector256`1<short> right);
    public static bool TestZ(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static bool TestZ(Vector256`1<int> left, Vector256`1<int> right);
    public static bool TestZ(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static bool TestZ(Vector256`1<long> left, Vector256`1<long> right);
    public static bool TestZ(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static bool TestZ(Vector256`1<float> left, Vector256`1<float> right);
    public static bool TestZ(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> UnpackHigh(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackHigh(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> UnpackLow(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> UnpackLow(Vector256`1<double> left, Vector256`1<double> right);
    public static Vector256`1<float> Xor(Vector256`1<float> left, Vector256`1<float> right);
    public static Vector256`1<double> Xor(Vector256`1<double> left, Vector256`1<double> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx2 : Avx {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector256`1<byte> Abs(Vector256`1<sbyte> value);
    public static Vector256`1<ushort> Abs(Vector256`1<short> value);
    public static Vector256`1<UInt32> Abs(Vector256`1<int> value);
    public static Vector256`1<sbyte> Add(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Add(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Add(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Add(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Add(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Add(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Add(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Add(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AddSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AddSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AddSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<sbyte> AlignRight(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte mask);
    public static Vector256`1<byte> AlignRight(Vector256`1<byte> left, Vector256`1<byte> right, byte mask);
    public static Vector256`1<short> AlignRight(Vector256`1<short> left, Vector256`1<short> right, byte mask);
    public static Vector256`1<ushort> AlignRight(Vector256`1<ushort> left, Vector256`1<ushort> right, byte mask);
    public static Vector256`1<int> AlignRight(Vector256`1<int> left, Vector256`1<int> right, byte mask);
    public static Vector256`1<UInt32> AlignRight(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte mask);
    public static Vector256`1<long> AlignRight(Vector256`1<long> left, Vector256`1<long> right, byte mask);
    public static Vector256`1<ulong> AlignRight(Vector256`1<ulong> left, Vector256`1<ulong> right, byte mask);
    public static Vector256`1<sbyte> And(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> And(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> And(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> And(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> And(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> And(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> And(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> And(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> AndNot(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> AndNot(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> AndNot(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> AndNot(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> AndNot(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> AndNot(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> AndNot(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> AndNot(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<byte> Average(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> Average(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector128`1<int> Blend(Vector128`1<int> left, Vector128`1<int> right, byte control);
    public static Vector128`1<UInt32> Blend(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte control);
    public static Vector256`1<short> Blend(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Blend(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Blend(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Blend(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<sbyte> BlendVariable(Vector256`1<sbyte> left, Vector256`1<sbyte> right, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> BlendVariable(Vector256`1<byte> left, Vector256`1<byte> right, Vector256`1<byte> mask);
    public static Vector256`1<short> BlendVariable(Vector256`1<short> left, Vector256`1<short> right, Vector256`1<short> mask);
    public static Vector256`1<ushort> BlendVariable(Vector256`1<ushort> left, Vector256`1<ushort> right, Vector256`1<ushort> mask);
    public static Vector256`1<int> BlendVariable(Vector256`1<int> left, Vector256`1<int> right, Vector256`1<int> mask);
    public static Vector256`1<UInt32> BlendVariable(Vector256`1<UInt32> left, Vector256`1<UInt32> right, Vector256`1<UInt32> mask);
    public static Vector256`1<long> BlendVariable(Vector256`1<long> left, Vector256`1<long> right, Vector256`1<long> mask);
    public static Vector256`1<ulong> BlendVariable(Vector256`1<ulong> left, Vector256`1<ulong> right, Vector256`1<ulong> mask);
    public static Vector128`1<byte> BroadcastScalarToVector128(Vector128`1<byte> value);
    public static Vector128`1<sbyte> BroadcastScalarToVector128(Vector128`1<sbyte> value);
    public static Vector128`1<short> BroadcastScalarToVector128(Vector128`1<short> value);
    public static Vector128`1<ushort> BroadcastScalarToVector128(Vector128`1<ushort> value);
    public static Vector128`1<int> BroadcastScalarToVector128(Vector128`1<int> value);
    public static Vector128`1<UInt32> BroadcastScalarToVector128(Vector128`1<UInt32> value);
    public static Vector128`1<long> BroadcastScalarToVector128(Vector128`1<long> value);
    public static Vector128`1<ulong> BroadcastScalarToVector128(Vector128`1<ulong> value);
    public static Vector128`1<float> BroadcastScalarToVector128(Vector128`1<float> value);
    public static Vector128`1<double> BroadcastScalarToVector128(Vector128`1<double> value);
    public static Vector128`1<byte> BroadcastScalarToVector128(Byte* source);
    public static Vector128`1<sbyte> BroadcastScalarToVector128(SByte* source);
    public static Vector128`1<short> BroadcastScalarToVector128(Int16* source);
    public static Vector128`1<ushort> BroadcastScalarToVector128(UInt16* source);
    public static Vector128`1<int> BroadcastScalarToVector128(Int32* source);
    public static Vector128`1<UInt32> BroadcastScalarToVector128(UInt32* source);
    public static Vector128`1<long> BroadcastScalarToVector128(Int64* source);
    public static Vector128`1<ulong> BroadcastScalarToVector128(UInt64* source);
    public static Vector256`1<byte> BroadcastScalarToVector256(Vector128`1<byte> value);
    public static Vector256`1<sbyte> BroadcastScalarToVector256(Vector128`1<sbyte> value);
    public static Vector256`1<short> BroadcastScalarToVector256(Vector128`1<short> value);
    public static Vector256`1<ushort> BroadcastScalarToVector256(Vector128`1<ushort> value);
    public static Vector256`1<int> BroadcastScalarToVector256(Vector128`1<int> value);
    public static Vector256`1<UInt32> BroadcastScalarToVector256(Vector128`1<UInt32> value);
    public static Vector256`1<long> BroadcastScalarToVector256(Vector128`1<long> value);
    public static Vector256`1<ulong> BroadcastScalarToVector256(Vector128`1<ulong> value);
    public static Vector256`1<float> BroadcastScalarToVector256(Vector128`1<float> value);
    public static Vector256`1<double> BroadcastScalarToVector256(Vector128`1<double> value);
    public static Vector256`1<byte> BroadcastScalarToVector256(Byte* source);
    public static Vector256`1<sbyte> BroadcastScalarToVector256(SByte* source);
    public static Vector256`1<short> BroadcastScalarToVector256(Int16* source);
    public static Vector256`1<ushort> BroadcastScalarToVector256(UInt16* source);
    public static Vector256`1<int> BroadcastScalarToVector256(Int32* source);
    public static Vector256`1<UInt32> BroadcastScalarToVector256(UInt32* source);
    public static Vector256`1<long> BroadcastScalarToVector256(Int64* source);
    public static Vector256`1<ulong> BroadcastScalarToVector256(UInt64* source);
    public static Vector256`1<sbyte> BroadcastVector128ToVector256(SByte* address);
    public static Vector256`1<byte> BroadcastVector128ToVector256(Byte* address);
    public static Vector256`1<short> BroadcastVector128ToVector256(Int16* address);
    public static Vector256`1<ushort> BroadcastVector128ToVector256(UInt16* address);
    public static Vector256`1<int> BroadcastVector128ToVector256(Int32* address);
    public static Vector256`1<UInt32> BroadcastVector128ToVector256(UInt32* address);
    public static Vector256`1<long> BroadcastVector128ToVector256(Int64* address);
    public static Vector256`1<ulong> BroadcastVector128ToVector256(UInt64* address);
    public static Vector256`1<sbyte> CompareEqual(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> CompareEqual(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> CompareEqual(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> CompareEqual(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> CompareEqual(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> CompareEqual(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> CompareEqual(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> CompareEqual(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> CompareGreaterThan(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> CompareGreaterThan(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> CompareGreaterThan(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<long> CompareGreaterThan(Vector256`1<long> left, Vector256`1<long> right);
    public static int ConvertToInt32(Vector256`1<int> value);
    public static UInt32 ConvertToUInt32(Vector256`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector128`1<sbyte> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector128`1<byte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<sbyte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<byte> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<short> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector128`1<ushort> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<sbyte> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<byte> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<short> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<ushort> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<int> value);
    public static Vector256`1<long> ConvertToVector256Int64(Vector128`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16(SByte* address);
    public static Vector256`1<short> ConvertToVector256Int16(Byte* address);
    public static Vector256`1<int> ConvertToVector256Int32(SByte* address);
    public static Vector256`1<int> ConvertToVector256Int32(Byte* address);
    public static Vector256`1<int> ConvertToVector256Int32(Int16* address);
    public static Vector256`1<int> ConvertToVector256Int32(UInt16* address);
    public static Vector256`1<long> ConvertToVector256Int64(SByte* address);
    public static Vector256`1<long> ConvertToVector256Int64(Byte* address);
    public static Vector256`1<long> ConvertToVector256Int64(Int16* address);
    public static Vector256`1<long> ConvertToVector256Int64(UInt16* address);
    public static Vector256`1<long> ConvertToVector256Int64(Int32* address);
    public static Vector256`1<long> ConvertToVector256Int64(UInt32* address);
    public static Vector128`1<sbyte> ExtractVector128(Vector256`1<sbyte> value, byte index);
    public static Vector128`1<byte> ExtractVector128(Vector256`1<byte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector256`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector256`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector256`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector256`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector256`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector256`1<ulong> value, byte index);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<long> GatherVector128(Int64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<ulong> GatherVector128(UInt64* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector128`1<double> GatherVector128(Double* baseAddress, Vector128`1<long> index, byte scale);
    public static Vector256`1<int> GatherVector256(Int32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<UInt32> GatherVector256(UInt32* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector256`1<float> GatherVector256(Single* baseAddress, Vector256`1<int> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector128`1<int> index, byte scale);
    public static Vector128`1<int> GatherVector128(Int32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<UInt32> GatherVector128(UInt32* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<long> GatherVector256(Int64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<ulong> GatherVector256(UInt64* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<float> GatherVector128(Single* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector256`1<double> GatherVector256(Double* baseAddress, Vector256`1<long> index, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<int> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<int> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<int> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector128`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector128`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector128`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector128`1<long> GatherMaskVector128(Vector128`1<long> source, Int64* baseAddress, Vector128`1<long> index, Vector128`1<long> mask, byte scale);
    public static Vector128`1<ulong> GatherMaskVector128(Vector128`1<ulong> source, UInt64* baseAddress, Vector128`1<long> index, Vector128`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector128`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector128`1<double> GatherMaskVector128(Vector128`1<double> source, Double* baseAddress, Vector128`1<long> index, Vector128`1<double> mask, byte scale);
    public static Vector256`1<int> GatherMaskVector256(Vector256`1<int> source, Int32* baseAddress, Vector256`1<int> index, Vector256`1<int> mask, byte scale);
    public static Vector256`1<UInt32> GatherMaskVector256(Vector256`1<UInt32> source, UInt32* baseAddress, Vector256`1<int> index, Vector256`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector128`1<int> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector128`1<int> index, Vector256`1<ulong> mask, byte scale);
    public static Vector256`1<float> GatherMaskVector256(Vector256`1<float> source, Single* baseAddress, Vector256`1<int> index, Vector256`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector128`1<int> index, Vector256`1<double> mask, byte scale);
    public static Vector128`1<int> GatherMaskVector128(Vector128`1<int> source, Int32* baseAddress, Vector256`1<long> index, Vector128`1<int> mask, byte scale);
    public static Vector128`1<UInt32> GatherMaskVector128(Vector128`1<UInt32> source, UInt32* baseAddress, Vector256`1<long> index, Vector128`1<UInt32> mask, byte scale);
    public static Vector256`1<long> GatherMaskVector256(Vector256`1<long> source, Int64* baseAddress, Vector256`1<long> index, Vector256`1<long> mask, byte scale);
    public static Vector256`1<ulong> GatherMaskVector256(Vector256`1<ulong> source, UInt64* baseAddress, Vector256`1<long> index, Vector256`1<ulong> mask, byte scale);
    public static Vector128`1<float> GatherMaskVector128(Vector128`1<float> source, Single* baseAddress, Vector256`1<long> index, Vector128`1<float> mask, byte scale);
    public static Vector256`1<double> GatherMaskVector256(Vector256`1<double> source, Double* baseAddress, Vector256`1<long> index, Vector256`1<double> mask, byte scale);
    public static Vector256`1<short> HorizontalAdd(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalAdd(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalAddSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> HorizontalSubtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> HorizontalSubtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<short> HorizontalSubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<sbyte> InsertVector128(Vector256`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector256`1<byte> InsertVector128(Vector256`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector256`1<short> InsertVector128(Vector256`1<short> value, Vector128`1<short> data, byte index);
    public static Vector256`1<ushort> InsertVector128(Vector256`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector256`1<int> InsertVector128(Vector256`1<int> value, Vector128`1<int> data, byte index);
    public static Vector256`1<UInt32> InsertVector128(Vector256`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector256`1<long> InsertVector128(Vector256`1<long> value, Vector128`1<long> data, byte index);
    public static Vector256`1<ulong> InsertVector128(Vector256`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector256`1<sbyte> LoadAlignedVector256NonTemporal(SByte* address);
    public static Vector256`1<byte> LoadAlignedVector256NonTemporal(Byte* address);
    public static Vector256`1<short> LoadAlignedVector256NonTemporal(Int16* address);
    public static Vector256`1<ushort> LoadAlignedVector256NonTemporal(UInt16* address);
    public static Vector256`1<int> LoadAlignedVector256NonTemporal(Int32* address);
    public static Vector256`1<UInt32> LoadAlignedVector256NonTemporal(UInt32* address);
    public static Vector256`1<long> LoadAlignedVector256NonTemporal(Int64* address);
    public static Vector256`1<ulong> LoadAlignedVector256NonTemporal(UInt64* address);
    public static Vector128`1<int> MaskLoad(Int32* address, Vector128`1<int> mask);
    public static Vector128`1<UInt32> MaskLoad(UInt32* address, Vector128`1<UInt32> mask);
    public static Vector128`1<long> MaskLoad(Int64* address, Vector128`1<long> mask);
    public static Vector128`1<ulong> MaskLoad(UInt64* address, Vector128`1<ulong> mask);
    public static Vector256`1<int> MaskLoad(Int32* address, Vector256`1<int> mask);
    public static Vector256`1<UInt32> MaskLoad(UInt32* address, Vector256`1<UInt32> mask);
    public static Vector256`1<long> MaskLoad(Int64* address, Vector256`1<long> mask);
    public static Vector256`1<ulong> MaskLoad(UInt64* address, Vector256`1<ulong> mask);
    public static void MaskStore(Int32* address, Vector128`1<int> mask, Vector128`1<int> source);
    public static void MaskStore(UInt32* address, Vector128`1<UInt32> mask, Vector128`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector128`1<long> mask, Vector128`1<long> source);
    public static void MaskStore(UInt64* address, Vector128`1<ulong> mask, Vector128`1<ulong> source);
    public static void MaskStore(Int32* address, Vector256`1<int> mask, Vector256`1<int> source);
    public static void MaskStore(UInt32* address, Vector256`1<UInt32> mask, Vector256`1<UInt32> source);
    public static void MaskStore(Int64* address, Vector256`1<long> mask, Vector256`1<long> source);
    public static void MaskStore(UInt64* address, Vector256`1<ulong> mask, Vector256`1<ulong> source);
    public static Vector256`1<int> MultiplyAddAdjacent(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyAddAdjacent(Vector256`1<byte> left, Vector256`1<sbyte> right);
    public static Vector256`1<sbyte> Max(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Max(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Max(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Max(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Max(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Max(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<sbyte> Min(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Min(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Min(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Min(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Min(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Min(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static int MoveMask(Vector256`1<sbyte> value);
    public static int MoveMask(Vector256`1<byte> value);
    public static Vector256`1<ushort> MultipleSumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right, byte mask);
    public static Vector256`1<long> Multiply(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<ulong> Multiply(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<short> MultiplyHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> MultiplyHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<short> MultiplyHighRoundScale(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> MultiplyLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> MultiplyLow(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> MultiplyLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> MultiplyLow(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<sbyte> Or(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Or(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Or(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Or(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Or(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Or(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Or(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Or(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> PackSignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<short> PackSignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<byte> PackUnsignedSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> PackUnsignedSaturate(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Permute2x128(Vector256`1<sbyte> left, Vector256`1<sbyte> right, byte control);
    public static Vector256`1<byte> Permute2x128(Vector256`1<byte> left, Vector256`1<byte> right, byte control);
    public static Vector256`1<short> Permute2x128(Vector256`1<short> left, Vector256`1<short> right, byte control);
    public static Vector256`1<ushort> Permute2x128(Vector256`1<ushort> left, Vector256`1<ushort> right, byte control);
    public static Vector256`1<int> Permute2x128(Vector256`1<int> left, Vector256`1<int> right, byte control);
    public static Vector256`1<UInt32> Permute2x128(Vector256`1<UInt32> left, Vector256`1<UInt32> right, byte control);
    public static Vector256`1<long> Permute2x128(Vector256`1<long> left, Vector256`1<long> right, byte control);
    public static Vector256`1<ulong> Permute2x128(Vector256`1<ulong> left, Vector256`1<ulong> right, byte control);
    public static Vector256`1<long> Permute4x64(Vector256`1<long> value, byte control);
    public static Vector256`1<ulong> Permute4x64(Vector256`1<ulong> value, byte control);
    public static Vector256`1<double> Permute4x64(Vector256`1<double> value, byte control);
    public static Vector256`1<int> PermuteVar8x32(Vector256`1<int> left, Vector256`1<int> control);
    public static Vector256`1<UInt32> PermuteVar8x32(Vector256`1<UInt32> left, Vector256`1<UInt32> control);
    public static Vector256`1<float> PermuteVar8x32(Vector256`1<float> left, Vector256`1<int> control);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftLeftLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftLeftLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftLeftLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftLeftLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftLeftLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftLeftLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftLeftLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftLeftLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftLeftLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftLeftLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftLeftLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftLeftLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftLeftLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftLeftLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector128`1<int> ShiftLeftLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftLeftLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftLeftLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<int> ShiftLeftLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftLeftLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftLeftLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftLeftLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<short> ShiftRightArithmetic(Vector256`1<short> value, byte count);
    public static Vector256`1<int> ShiftRightArithmetic(Vector256`1<int> value, byte count);
    public static Vector128`1<int> ShiftRightArithmeticVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector256`1<int> ShiftRightArithmeticVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, Vector128`1<short> count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, Vector128`1<ushort> count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, Vector128`1<int> count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, Vector128`1<long> count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<short> ShiftRightLogical(Vector256`1<short> value, byte count);
    public static Vector256`1<ushort> ShiftRightLogical(Vector256`1<ushort> value, byte count);
    public static Vector256`1<int> ShiftRightLogical(Vector256`1<int> value, byte count);
    public static Vector256`1<UInt32> ShiftRightLogical(Vector256`1<UInt32> value, byte count);
    public static Vector256`1<long> ShiftRightLogical(Vector256`1<long> value, byte count);
    public static Vector256`1<ulong> ShiftRightLogical(Vector256`1<ulong> value, byte count);
    public static Vector256`1<sbyte> ShiftRightLogical128BitLane(Vector256`1<sbyte> value, byte numBytes);
    public static Vector256`1<byte> ShiftRightLogical128BitLane(Vector256`1<byte> value, byte numBytes);
    public static Vector256`1<short> ShiftRightLogical128BitLane(Vector256`1<short> value, byte numBytes);
    public static Vector256`1<ushort> ShiftRightLogical128BitLane(Vector256`1<ushort> value, byte numBytes);
    public static Vector256`1<int> ShiftRightLogical128BitLane(Vector256`1<int> value, byte numBytes);
    public static Vector256`1<UInt32> ShiftRightLogical128BitLane(Vector256`1<UInt32> value, byte numBytes);
    public static Vector256`1<long> ShiftRightLogical128BitLane(Vector256`1<long> value, byte numBytes);
    public static Vector256`1<ulong> ShiftRightLogical128BitLane(Vector256`1<ulong> value, byte numBytes);
    public static Vector128`1<int> ShiftRightLogicalVariable(Vector128`1<int> value, Vector128`1<UInt32> count);
    public static Vector128`1<UInt32> ShiftRightLogicalVariable(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogicalVariable(Vector128`1<long> value, Vector128`1<ulong> count);
    public static Vector128`1<ulong> ShiftRightLogicalVariable(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector256`1<int> ShiftRightLogicalVariable(Vector256`1<int> value, Vector256`1<UInt32> count);
    public static Vector256`1<UInt32> ShiftRightLogicalVariable(Vector256`1<UInt32> value, Vector256`1<UInt32> count);
    public static Vector256`1<long> ShiftRightLogicalVariable(Vector256`1<long> value, Vector256`1<ulong> count);
    public static Vector256`1<ulong> ShiftRightLogicalVariable(Vector256`1<ulong> value, Vector256`1<ulong> count);
    public static Vector256`1<sbyte> Shuffle(Vector256`1<sbyte> value, Vector256`1<sbyte> mask);
    public static Vector256`1<byte> Shuffle(Vector256`1<byte> value, Vector256`1<byte> mask);
    public static Vector256`1<int> Shuffle(Vector256`1<int> value, byte control);
    public static Vector256`1<UInt32> Shuffle(Vector256`1<UInt32> value, byte control);
    public static Vector256`1<short> ShuffleHigh(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleHigh(Vector256`1<ushort> value, byte control);
    public static Vector256`1<short> ShuffleLow(Vector256`1<short> value, byte control);
    public static Vector256`1<ushort> ShuffleLow(Vector256`1<ushort> value, byte control);
    public static Vector256`1<sbyte> Sign(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> Sign(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<int> Sign(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<sbyte> Subtract(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Subtract(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Subtract(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Subtract(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Subtract(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Subtract(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Subtract(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Subtract(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> SubtractSaturate(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<short> SubtractSaturate(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<byte> SubtractSaturate(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<ushort> SubtractSaturate(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<ushort> SumAbsoluteDifferences(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<sbyte> UnpackHigh(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackHigh(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackHigh(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackHigh(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackHigh(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackHigh(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackHigh(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackHigh(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> UnpackLow(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> UnpackLow(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> UnpackLow(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> UnpackLow(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> UnpackLow(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> UnpackLow(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> UnpackLow(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> UnpackLow(Vector256`1<ulong> left, Vector256`1<ulong> right);
    public static Vector256`1<sbyte> Xor(Vector256`1<sbyte> left, Vector256`1<sbyte> right);
    public static Vector256`1<byte> Xor(Vector256`1<byte> left, Vector256`1<byte> right);
    public static Vector256`1<short> Xor(Vector256`1<short> left, Vector256`1<short> right);
    public static Vector256`1<ushort> Xor(Vector256`1<ushort> left, Vector256`1<ushort> right);
    public static Vector256`1<int> Xor(Vector256`1<int> left, Vector256`1<int> right);
    public static Vector256`1<UInt32> Xor(Vector256`1<UInt32> left, Vector256`1<UInt32> right);
    public static Vector256`1<long> Xor(Vector256`1<long> left, Vector256`1<long> right);
    public static Vector256`1<ulong> Xor(Vector256`1<ulong> left, Vector256`1<ulong> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx512BW : Avx512F {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector512`1<byte> Abs(Vector512`1<sbyte> value);
    public static Vector512`1<ushort> Abs(Vector512`1<short> value);
    public static Vector512`1<sbyte> Add(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> Add(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> Add(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> Add(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<sbyte> AddSaturate(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> AddSaturate(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> AddSaturate(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> AddSaturate(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<sbyte> AlignRight(Vector512`1<sbyte> left, Vector512`1<sbyte> right, byte mask);
    public static Vector512`1<byte> AlignRight(Vector512`1<byte> left, Vector512`1<byte> right, byte mask);
    public static Vector512`1<byte> Average(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<ushort> Average(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<byte> BlendVariable(Vector512`1<byte> left, Vector512`1<byte> right, Vector512`1<byte> mask);
    public static Vector512`1<short> BlendVariable(Vector512`1<short> left, Vector512`1<short> right, Vector512`1<short> mask);
    public static Vector512`1<sbyte> BlendVariable(Vector512`1<sbyte> left, Vector512`1<sbyte> right, Vector512`1<sbyte> mask);
    public static Vector512`1<ushort> BlendVariable(Vector512`1<ushort> left, Vector512`1<ushort> right, Vector512`1<ushort> mask);
    public static Vector512`1<byte> BroadcastScalarToVector512(Vector128`1<byte> value);
    public static Vector512`1<sbyte> BroadcastScalarToVector512(Vector128`1<sbyte> value);
    public static Vector512`1<short> BroadcastScalarToVector512(Vector128`1<short> value);
    public static Vector512`1<ushort> BroadcastScalarToVector512(Vector128`1<ushort> value);
    public static Vector512`1<byte> CompareEqual(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<byte> CompareGreaterThan(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<byte> CompareGreaterThanOrEqual(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<byte> CompareLessThan(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<byte> CompareLessThanOrEqual(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<byte> CompareNotEqual(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> CompareEqual(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> CompareGreaterThan(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> CompareGreaterThanOrEqual(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> CompareLessThan(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> CompareLessThanOrEqual(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> CompareNotEqual(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<sbyte> CompareEqual(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<sbyte> CompareGreaterThan(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<sbyte> CompareGreaterThanOrEqual(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<sbyte> CompareLessThan(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<sbyte> CompareLessThanOrEqual(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<sbyte> CompareNotEqual(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<ushort> CompareEqual(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<ushort> CompareGreaterThan(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<ushort> CompareGreaterThanOrEqual(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<ushort> CompareLessThan(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<ushort> CompareLessThanOrEqual(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<ushort> CompareNotEqual(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector256`1<byte> ConvertToVector256Byte(Vector512`1<short> value);
    public static Vector256`1<byte> ConvertToVector256Byte(Vector512`1<ushort> value);
    public static Vector256`1<byte> ConvertToVector256ByteWithSaturation(Vector512`1<ushort> value);
    public static Vector256`1<sbyte> ConvertToVector256SByte(Vector512`1<short> value);
    public static Vector256`1<sbyte> ConvertToVector256SByte(Vector512`1<ushort> value);
    public static Vector256`1<sbyte> ConvertToVector256SByteWithSaturation(Vector512`1<short> value);
    public static Vector512`1<short> ConvertToVector512Int16(Vector256`1<sbyte> value);
    public static Vector512`1<short> ConvertToVector512Int16(Vector256`1<byte> value);
    public static Vector512`1<ushort> ConvertToVector512UInt16(Vector256`1<sbyte> value);
    public static Vector512`1<ushort> ConvertToVector512UInt16(Vector256`1<byte> value);
    public static Vector512`1<sbyte> LoadVector512(SByte* address);
    public static Vector512`1<byte> LoadVector512(Byte* address);
    public static Vector512`1<short> LoadVector512(Int16* address);
    public static Vector512`1<ushort> LoadVector512(UInt16* address);
    public static Vector512`1<sbyte> Max(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> Max(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> Max(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> Max(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<sbyte> Min(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> Min(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> Min(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> Min(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<int> MultiplyAddAdjacent(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> MultiplyAddAdjacent(Vector512`1<byte> left, Vector512`1<sbyte> right);
    public static Vector512`1<short> MultiplyHigh(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> MultiplyHigh(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<short> MultiplyHighRoundScale(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> MultiplyLow(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> MultiplyLow(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<sbyte> PackSignedSaturate(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<short> PackSignedSaturate(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<byte> PackUnsignedSaturate(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> PackUnsignedSaturate(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<short> PermuteVar32x16(Vector512`1<short> left, Vector512`1<short> control);
    public static Vector512`1<ushort> PermuteVar32x16(Vector512`1<ushort> left, Vector512`1<ushort> control);
    public static Vector512`1<short> PermuteVar32x16x2(Vector512`1<short> lower, Vector512`1<short> indices, Vector512`1<short> upper);
    public static Vector512`1<ushort> PermuteVar32x16x2(Vector512`1<ushort> lower, Vector512`1<ushort> indices, Vector512`1<ushort> upper);
    public static Vector512`1<short> ShiftLeftLogical(Vector512`1<short> value, Vector128`1<short> count);
    public static Vector512`1<ushort> ShiftLeftLogical(Vector512`1<ushort> value, Vector128`1<ushort> count);
    public static Vector512`1<short> ShiftLeftLogical(Vector512`1<short> value, byte count);
    public static Vector512`1<ushort> ShiftLeftLogical(Vector512`1<ushort> value, byte count);
    public static Vector512`1<sbyte> ShiftLeftLogical128BitLane(Vector512`1<sbyte> value, byte numBytes);
    public static Vector512`1<byte> ShiftLeftLogical128BitLane(Vector512`1<byte> value, byte numBytes);
    public static Vector512`1<short> ShiftLeftLogicalVariable(Vector512`1<short> value, Vector512`1<ushort> count);
    public static Vector512`1<ushort> ShiftLeftLogicalVariable(Vector512`1<ushort> value, Vector512`1<ushort> count);
    public static Vector512`1<short> ShiftRightArithmetic(Vector512`1<short> value, Vector128`1<short> count);
    public static Vector512`1<short> ShiftRightArithmetic(Vector512`1<short> value, byte count);
    public static Vector512`1<short> ShiftRightArithmeticVariable(Vector512`1<short> value, Vector512`1<ushort> count);
    public static Vector512`1<short> ShiftRightLogical(Vector512`1<short> value, Vector128`1<short> count);
    public static Vector512`1<ushort> ShiftRightLogical(Vector512`1<ushort> value, Vector128`1<ushort> count);
    public static Vector512`1<short> ShiftRightLogical(Vector512`1<short> value, byte count);
    public static Vector512`1<ushort> ShiftRightLogical(Vector512`1<ushort> value, byte count);
    public static Vector512`1<sbyte> ShiftRightLogical128BitLane(Vector512`1<sbyte> value, byte numBytes);
    public static Vector512`1<byte> ShiftRightLogical128BitLane(Vector512`1<byte> value, byte numBytes);
    public static Vector512`1<short> ShiftRightLogicalVariable(Vector512`1<short> value, Vector512`1<ushort> count);
    public static Vector512`1<ushort> ShiftRightLogicalVariable(Vector512`1<ushort> value, Vector512`1<ushort> count);
    public static Vector512`1<sbyte> Shuffle(Vector512`1<sbyte> value, Vector512`1<sbyte> mask);
    public static Vector512`1<byte> Shuffle(Vector512`1<byte> value, Vector512`1<byte> mask);
    public static Vector512`1<short> ShuffleHigh(Vector512`1<short> value, byte control);
    public static Vector512`1<ushort> ShuffleHigh(Vector512`1<ushort> value, byte control);
    public static Vector512`1<short> ShuffleLow(Vector512`1<short> value, byte control);
    public static Vector512`1<ushort> ShuffleLow(Vector512`1<ushort> value, byte control);
    public static void Store(SByte* address, Vector512`1<sbyte> source);
    public static void Store(Byte* address, Vector512`1<byte> source);
    public static void Store(Int16* address, Vector512`1<short> source);
    public static void Store(UInt16* address, Vector512`1<ushort> source);
    public static Vector512`1<sbyte> Subtract(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> Subtract(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> Subtract(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> Subtract(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<sbyte> SubtractSaturate(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<short> SubtractSaturate(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<byte> SubtractSaturate(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<ushort> SubtractSaturate(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<ushort> SumAbsoluteDifferences(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<ushort> SumAbsoluteDifferencesInBlock32(Vector512`1<byte> left, Vector512`1<byte> right, byte control);
    public static Vector512`1<sbyte> UnpackHigh(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> UnpackHigh(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> UnpackHigh(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> UnpackHigh(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<sbyte> UnpackLow(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<byte> UnpackLow(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<short> UnpackLow(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> UnpackLow(Vector512`1<ushort> left, Vector512`1<ushort> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx512CD : Avx512F {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector512`1<int> DetectConflicts(Vector512`1<int> value);
    public static Vector512`1<UInt32> DetectConflicts(Vector512`1<UInt32> value);
    public static Vector512`1<long> DetectConflicts(Vector512`1<long> value);
    public static Vector512`1<ulong> DetectConflicts(Vector512`1<ulong> value);
    public static Vector512`1<int> LeadingZeroCount(Vector512`1<int> value);
    public static Vector512`1<UInt32> LeadingZeroCount(Vector512`1<UInt32> value);
    public static Vector512`1<long> LeadingZeroCount(Vector512`1<long> value);
    public static Vector512`1<ulong> LeadingZeroCount(Vector512`1<ulong> value);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx512DQ : Avx512F {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector512`1<float> And(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> And(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<float> AndNot(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> AndNot(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<int> BroadcastPairScalarToVector512(Vector128`1<int> value);
    public static Vector512`1<UInt32> BroadcastPairScalarToVector512(Vector128`1<UInt32> value);
    public static Vector512`1<float> BroadcastPairScalarToVector512(Vector128`1<float> value);
    public static Vector512`1<long> BroadcastVector128ToVector512(Int64* address);
    public static Vector512`1<ulong> BroadcastVector128ToVector512(UInt64* address);
    public static Vector512`1<double> BroadcastVector128ToVector512(Double* address);
    public static Vector512`1<int> BroadcastVector256ToVector512(Int32* address);
    public static Vector512`1<UInt32> BroadcastVector256ToVector512(UInt32* address);
    public static Vector512`1<float> BroadcastVector256ToVector512(Single* address);
    public static Vector256`1<float> ConvertToVector256Single(Vector512`1<long> value);
    public static Vector256`1<float> ConvertToVector256Single(Vector512`1<ulong> value);
    public static Vector512`1<double> ConvertToVector512Double(Vector512`1<long> value);
    public static Vector512`1<double> ConvertToVector512Double(Vector512`1<ulong> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector256`1<float> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector512`1<double> value);
    public static Vector512`1<long> ConvertToVector512Int64WithTruncation(Vector256`1<float> value);
    public static Vector512`1<long> ConvertToVector512Int64WithTruncation(Vector512`1<double> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector256`1<float> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector512`1<double> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64WithTruncation(Vector256`1<float> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64WithTruncation(Vector512`1<double> value);
    public static Vector128`1<long> ExtractVector128(Vector512`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector512`1<ulong> value, byte index);
    public static Vector128`1<double> ExtractVector128(Vector512`1<double> value, byte index);
    public static Vector256`1<int> ExtractVector256(Vector512`1<int> value, byte index);
    public static Vector256`1<UInt32> ExtractVector256(Vector512`1<UInt32> value, byte index);
    public static Vector256`1<float> ExtractVector256(Vector512`1<float> value, byte index);
    public static Vector512`1<long> InsertVector128(Vector512`1<long> value, Vector128`1<long> data, byte index);
    public static Vector512`1<ulong> InsertVector128(Vector512`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector512`1<double> InsertVector128(Vector512`1<double> value, Vector128`1<double> data, byte index);
    public static Vector512`1<int> InsertVector256(Vector512`1<int> value, Vector256`1<int> data, byte index);
    public static Vector512`1<UInt32> InsertVector256(Vector512`1<UInt32> value, Vector256`1<UInt32> data, byte index);
    public static Vector512`1<float> InsertVector256(Vector512`1<float> value, Vector256`1<float> data, byte index);
    public static Vector512`1<long> MultiplyLow(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> MultiplyLow(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<float> Or(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Or(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<float> Range(Vector512`1<float> left, Vector512`1<float> right, byte control);
    public static Vector512`1<double> Range(Vector512`1<double> left, Vector512`1<double> right, byte control);
    public static Vector128`1<float> RangeScalar(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> RangeScalar(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector512`1<float> Reduce(Vector512`1<float> value, byte control);
    public static Vector512`1<double> Reduce(Vector512`1<double> value, byte control);
    public static Vector128`1<float> ReduceScalar(Vector128`1<float> value, byte control);
    public static Vector128`1<double> ReduceScalar(Vector128`1<double> value, byte control);
    public static Vector128`1<float> ReduceScalar(Vector128`1<float> upper, Vector128`1<float> value, byte control);
    public static Vector128`1<double> ReduceScalar(Vector128`1<double> upper, Vector128`1<double> value, byte control);
    public static Vector512`1<float> Xor(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Xor(Vector512`1<double> left, Vector512`1<double> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx512F : Avx2 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector512`1<UInt32> Abs(Vector512`1<int> value);
    public static Vector512`1<ulong> Abs(Vector512`1<long> value);
    public static Vector512`1<int> Add(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> Add(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> Add(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> Add(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<double> Add(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<float> Add(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<int> AlignRight32(Vector512`1<int> left, Vector512`1<int> right, byte mask);
    public static Vector512`1<UInt32> AlignRight32(Vector512`1<UInt32> left, Vector512`1<UInt32> right, byte mask);
    public static Vector512`1<long> AlignRight64(Vector512`1<long> left, Vector512`1<long> right, byte mask);
    public static Vector512`1<ulong> AlignRight64(Vector512`1<ulong> left, Vector512`1<ulong> right, byte mask);
    public static Vector512`1<byte> And(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<sbyte> And(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<short> And(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> And(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<int> And(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> And(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> And(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> And(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<byte> AndNot(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<sbyte> AndNot(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<short> AndNot(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> AndNot(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<int> AndNot(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> AndNot(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> AndNot(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> AndNot(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<double> BlendVariable(Vector512`1<double> left, Vector512`1<double> right, Vector512`1<double> mask);
    public static Vector512`1<int> BlendVariable(Vector512`1<int> left, Vector512`1<int> right, Vector512`1<int> mask);
    public static Vector512`1<long> BlendVariable(Vector512`1<long> left, Vector512`1<long> right, Vector512`1<long> mask);
    public static Vector512`1<float> BlendVariable(Vector512`1<float> left, Vector512`1<float> right, Vector512`1<float> mask);
    public static Vector512`1<UInt32> BlendVariable(Vector512`1<UInt32> left, Vector512`1<UInt32> right, Vector512`1<UInt32> mask);
    public static Vector512`1<ulong> BlendVariable(Vector512`1<ulong> left, Vector512`1<ulong> right, Vector512`1<ulong> mask);
    public static Vector512`1<int> BroadcastScalarToVector512(Vector128`1<int> value);
    public static Vector512`1<UInt32> BroadcastScalarToVector512(Vector128`1<UInt32> value);
    public static Vector512`1<long> BroadcastScalarToVector512(Vector128`1<long> value);
    public static Vector512`1<ulong> BroadcastScalarToVector512(Vector128`1<ulong> value);
    public static Vector512`1<float> BroadcastScalarToVector512(Vector128`1<float> value);
    public static Vector512`1<double> BroadcastScalarToVector512(Vector128`1<double> value);
    public static Vector512`1<int> BroadcastVector128ToVector512(Int32* address);
    public static Vector512`1<UInt32> BroadcastVector128ToVector512(UInt32* address);
    public static Vector512`1<float> BroadcastVector128ToVector512(Single* address);
    public static Vector512`1<long> BroadcastVector256ToVector512(Int64* address);
    public static Vector512`1<ulong> BroadcastVector256ToVector512(UInt64* address);
    public static Vector512`1<double> BroadcastVector256ToVector512(Double* address);
    public static Vector512`1<double> Compare(Vector512`1<double> left, Vector512`1<double> right, FloatComparisonMode mode);
    public static Vector512`1<double> CompareEqual(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareGreaterThan(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareGreaterThanOrEqual(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareLessThan(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareLessThanOrEqual(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareNotEqual(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareNotGreaterThan(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareNotGreaterThanOrEqual(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareNotLessThan(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareNotLessThanOrEqual(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareOrdered(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<double> CompareUnordered(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<float> Compare(Vector512`1<float> left, Vector512`1<float> right, FloatComparisonMode mode);
    public static Vector512`1<float> CompareEqual(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareGreaterThan(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareGreaterThanOrEqual(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareLessThan(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareLessThanOrEqual(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareNotEqual(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareNotGreaterThan(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareNotGreaterThanOrEqual(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareNotLessThan(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareNotLessThanOrEqual(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareOrdered(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<float> CompareUnordered(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<int> CompareEqual(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<int> CompareGreaterThan(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<int> CompareGreaterThanOrEqual(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<int> CompareLessThan(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<int> CompareLessThanOrEqual(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<int> CompareNotEqual(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<long> CompareEqual(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<long> CompareGreaterThan(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<long> CompareGreaterThanOrEqual(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<long> CompareLessThan(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<long> CompareLessThanOrEqual(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<long> CompareNotEqual(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<UInt32> CompareEqual(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<UInt32> CompareGreaterThan(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<UInt32> CompareGreaterThanOrEqual(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<UInt32> CompareLessThan(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<UInt32> CompareLessThanOrEqual(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<UInt32> CompareNotEqual(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<ulong> CompareEqual(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<ulong> CompareGreaterThan(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<ulong> CompareGreaterThanOrEqual(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<ulong> CompareLessThan(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<ulong> CompareLessThanOrEqual(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<ulong> CompareNotEqual(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, UInt32 value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, UInt32 value);
    public static UInt32 ConvertToUInt32(Vector128`1<float> value);
    public static UInt32 ConvertToUInt32(Vector128`1<double> value);
    public static UInt32 ConvertToUInt32WithTruncation(Vector128`1<float> value);
    public static UInt32 ConvertToUInt32WithTruncation(Vector128`1<double> value);
    public static Vector128`1<byte> ConvertToVector128Byte(Vector512`1<int> value);
    public static Vector128`1<byte> ConvertToVector128Byte(Vector512`1<long> value);
    public static Vector128`1<byte> ConvertToVector128Byte(Vector512`1<UInt32> value);
    public static Vector128`1<byte> ConvertToVector128Byte(Vector512`1<ulong> value);
    public static Vector128`1<byte> ConvertToVector128ByteWithSaturation(Vector512`1<UInt32> value);
    public static Vector128`1<byte> ConvertToVector128ByteWithSaturation(Vector512`1<ulong> value);
    public static Vector128`1<short> ConvertToVector128Int16(Vector512`1<long> value);
    public static Vector128`1<short> ConvertToVector128Int16(Vector512`1<ulong> value);
    public static Vector128`1<short> ConvertToVector128Int16WithSaturation(Vector512`1<long> value);
    public static Vector128`1<sbyte> ConvertToVector128SByte(Vector512`1<int> value);
    public static Vector128`1<sbyte> ConvertToVector128SByte(Vector512`1<long> value);
    public static Vector128`1<sbyte> ConvertToVector128SByte(Vector512`1<UInt32> value);
    public static Vector128`1<sbyte> ConvertToVector128SByte(Vector512`1<ulong> value);
    public static Vector128`1<sbyte> ConvertToVector128SByteWithSaturation(Vector512`1<int> value);
    public static Vector128`1<sbyte> ConvertToVector128SByteWithSaturation(Vector512`1<long> value);
    public static Vector128`1<ushort> ConvertToVector128UInt16(Vector512`1<long> value);
    public static Vector128`1<ushort> ConvertToVector128UInt16(Vector512`1<ulong> value);
    public static Vector128`1<ushort> ConvertToVector128UInt16WithSaturation(Vector512`1<ulong> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector512`1<int> value);
    public static Vector256`1<short> ConvertToVector256Int16(Vector512`1<UInt32> value);
    public static Vector256`1<short> ConvertToVector256Int16WithSaturation(Vector512`1<int> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector512`1<double> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector512`1<long> value);
    public static Vector256`1<int> ConvertToVector256Int32(Vector512`1<ulong> value);
    public static Vector256`1<int> ConvertToVector256Int32WithSaturation(Vector512`1<long> value);
    public static Vector256`1<int> ConvertToVector256Int32WithTruncation(Vector512`1<double> value);
    public static Vector256`1<float> ConvertToVector256Single(Vector512`1<double> value);
    public static Vector256`1<ushort> ConvertToVector256UInt16(Vector512`1<int> value);
    public static Vector256`1<ushort> ConvertToVector256UInt16(Vector512`1<UInt32> value);
    public static Vector256`1<ushort> ConvertToVector256UInt16WithSaturation(Vector512`1<UInt32> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector512`1<double> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector512`1<long> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32(Vector512`1<ulong> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32WithSaturation(Vector512`1<ulong> value);
    public static Vector256`1<UInt32> ConvertToVector256UInt32WithTruncation(Vector512`1<double> value);
    public static Vector512`1<double> ConvertToVector512Double(Vector256`1<int> value);
    public static Vector512`1<double> ConvertToVector512Double(Vector256`1<float> value);
    public static Vector512`1<double> ConvertToVector512Double(Vector256`1<UInt32> value);
    public static Vector512`1<int> ConvertToVector512Int32(Vector128`1<sbyte> value);
    public static Vector512`1<int> ConvertToVector512Int32(Vector128`1<byte> value);
    public static Vector512`1<int> ConvertToVector512Int32(Vector256`1<short> value);
    public static Vector512`1<int> ConvertToVector512Int32(Vector256`1<ushort> value);
    public static Vector512`1<int> ConvertToVector512Int32(Vector512`1<float> value);
    public static Vector512`1<int> ConvertToVector512Int32WithTruncation(Vector512`1<float> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector128`1<sbyte> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector128`1<byte> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector128`1<short> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector128`1<ushort> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector256`1<int> value);
    public static Vector512`1<long> ConvertToVector512Int64(Vector256`1<UInt32> value);
    public static Vector512`1<float> ConvertToVector512Single(Vector512`1<int> value);
    public static Vector512`1<float> ConvertToVector512Single(Vector512`1<UInt32> value);
    public static Vector512`1<UInt32> ConvertToVector512UInt32(Vector128`1<sbyte> value);
    public static Vector512`1<UInt32> ConvertToVector512UInt32(Vector128`1<byte> value);
    public static Vector512`1<UInt32> ConvertToVector512UInt32(Vector256`1<short> value);
    public static Vector512`1<UInt32> ConvertToVector512UInt32(Vector256`1<ushort> value);
    public static Vector512`1<UInt32> ConvertToVector512UInt32(Vector512`1<float> value);
    public static Vector512`1<UInt32> ConvertToVector512UInt32WithTruncation(Vector512`1<float> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector128`1<sbyte> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector128`1<byte> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector128`1<short> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector128`1<ushort> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector256`1<int> value);
    public static Vector512`1<ulong> ConvertToVector512UInt64(Vector256`1<UInt32> value);
    public static Vector512`1<float> Divide(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Divide(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<float> DuplicateEvenIndexed(Vector512`1<float> value);
    public static Vector512`1<double> DuplicateEvenIndexed(Vector512`1<double> value);
    public static Vector512`1<float> DuplicateOddIndexed(Vector512`1<float> value);
    public static Vector128`1<sbyte> ExtractVector128(Vector512`1<sbyte> value, byte index);
    public static Vector128`1<byte> ExtractVector128(Vector512`1<byte> value, byte index);
    public static Vector128`1<short> ExtractVector128(Vector512`1<short> value, byte index);
    public static Vector128`1<ushort> ExtractVector128(Vector512`1<ushort> value, byte index);
    public static Vector128`1<int> ExtractVector128(Vector512`1<int> value, byte index);
    public static Vector128`1<UInt32> ExtractVector128(Vector512`1<UInt32> value, byte index);
    public static Vector128`1<long> ExtractVector128(Vector512`1<long> value, byte index);
    public static Vector128`1<ulong> ExtractVector128(Vector512`1<ulong> value, byte index);
    public static Vector128`1<float> ExtractVector128(Vector512`1<float> value, byte index);
    public static Vector128`1<double> ExtractVector128(Vector512`1<double> value, byte index);
    public static Vector256`1<sbyte> ExtractVector256(Vector512`1<sbyte> value, byte index);
    public static Vector256`1<byte> ExtractVector256(Vector512`1<byte> value, byte index);
    public static Vector256`1<short> ExtractVector256(Vector512`1<short> value, byte index);
    public static Vector256`1<ushort> ExtractVector256(Vector512`1<ushort> value, byte index);
    public static Vector256`1<int> ExtractVector256(Vector512`1<int> value, byte index);
    public static Vector256`1<UInt32> ExtractVector256(Vector512`1<UInt32> value, byte index);
    public static Vector256`1<long> ExtractVector256(Vector512`1<long> value, byte index);
    public static Vector256`1<ulong> ExtractVector256(Vector512`1<ulong> value, byte index);
    public static Vector256`1<float> ExtractVector256(Vector512`1<float> value, byte index);
    public static Vector256`1<double> ExtractVector256(Vector512`1<double> value, byte index);
    public static Vector512`1<float> Fixup(Vector512`1<float> left, Vector512`1<float> right, Vector512`1<int> table, byte control);
    public static Vector512`1<double> Fixup(Vector512`1<double> left, Vector512`1<double> right, Vector512`1<long> table, byte control);
    public static Vector128`1<float> FixupScalar(Vector128`1<float> left, Vector128`1<float> right, Vector128`1<int> table, byte control);
    public static Vector128`1<double> FixupScalar(Vector128`1<double> left, Vector128`1<double> right, Vector128`1<long> table, byte control);
    public static Vector512`1<float> FusedMultiplyAdd(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c);
    public static Vector512`1<double> FusedMultiplyAdd(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c);
    public static Vector512`1<float> FusedMultiplyAddSubtract(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c);
    public static Vector512`1<double> FusedMultiplyAddSubtract(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c);
    public static Vector512`1<float> FusedMultiplySubtract(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c);
    public static Vector512`1<double> FusedMultiplySubtract(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c);
    public static Vector512`1<float> FusedMultiplySubtractAdd(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c);
    public static Vector512`1<double> FusedMultiplySubtractAdd(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c);
    public static Vector512`1<float> FusedMultiplyAddNegated(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c);
    public static Vector512`1<double> FusedMultiplyAddNegated(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c);
    public static Vector512`1<float> FusedMultiplySubtractNegated(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c);
    public static Vector512`1<double> FusedMultiplySubtractNegated(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c);
    public static Vector512`1<float> GetExponent(Vector512`1<float> value);
    public static Vector512`1<double> GetExponent(Vector512`1<double> value);
    public static Vector128`1<float> GetExponentScalar(Vector128`1<float> value);
    public static Vector128`1<double> GetExponentScalar(Vector128`1<double> value);
    public static Vector128`1<float> GetExponentScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> GetExponentScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector512`1<float> GetMantissa(Vector512`1<float> value, byte control);
    public static Vector512`1<double> GetMantissa(Vector512`1<double> value, byte control);
    public static Vector128`1<float> GetMantissaScalar(Vector128`1<float> value, byte control);
    public static Vector128`1<double> GetMantissaScalar(Vector128`1<double> value, byte control);
    public static Vector128`1<float> GetMantissaScalar(Vector128`1<float> upper, Vector128`1<float> value, byte control);
    public static Vector128`1<double> GetMantissaScalar(Vector128`1<double> upper, Vector128`1<double> value, byte control);
    public static Vector512`1<sbyte> InsertVector128(Vector512`1<sbyte> value, Vector128`1<sbyte> data, byte index);
    public static Vector512`1<byte> InsertVector128(Vector512`1<byte> value, Vector128`1<byte> data, byte index);
    public static Vector512`1<short> InsertVector128(Vector512`1<short> value, Vector128`1<short> data, byte index);
    public static Vector512`1<ushort> InsertVector128(Vector512`1<ushort> value, Vector128`1<ushort> data, byte index);
    public static Vector512`1<int> InsertVector128(Vector512`1<int> value, Vector128`1<int> data, byte index);
    public static Vector512`1<UInt32> InsertVector128(Vector512`1<UInt32> value, Vector128`1<UInt32> data, byte index);
    public static Vector512`1<long> InsertVector128(Vector512`1<long> value, Vector128`1<long> data, byte index);
    public static Vector512`1<ulong> InsertVector128(Vector512`1<ulong> value, Vector128`1<ulong> data, byte index);
    public static Vector512`1<float> InsertVector128(Vector512`1<float> value, Vector128`1<float> data, byte index);
    public static Vector512`1<double> InsertVector128(Vector512`1<double> value, Vector128`1<double> data, byte index);
    public static Vector512`1<sbyte> InsertVector256(Vector512`1<sbyte> value, Vector256`1<sbyte> data, byte index);
    public static Vector512`1<byte> InsertVector256(Vector512`1<byte> value, Vector256`1<byte> data, byte index);
    public static Vector512`1<short> InsertVector256(Vector512`1<short> value, Vector256`1<short> data, byte index);
    public static Vector512`1<ushort> InsertVector256(Vector512`1<ushort> value, Vector256`1<ushort> data, byte index);
    public static Vector512`1<int> InsertVector256(Vector512`1<int> value, Vector256`1<int> data, byte index);
    public static Vector512`1<UInt32> InsertVector256(Vector512`1<UInt32> value, Vector256`1<UInt32> data, byte index);
    public static Vector512`1<long> InsertVector256(Vector512`1<long> value, Vector256`1<long> data, byte index);
    public static Vector512`1<ulong> InsertVector256(Vector512`1<ulong> value, Vector256`1<ulong> data, byte index);
    public static Vector512`1<float> InsertVector256(Vector512`1<float> value, Vector256`1<float> data, byte index);
    public static Vector512`1<double> InsertVector256(Vector512`1<double> value, Vector256`1<double> data, byte index);
    public static Vector512`1<byte> LoadAlignedVector512(Byte* address);
    public static Vector512`1<sbyte> LoadAlignedVector512(SByte* address);
    public static Vector512`1<short> LoadAlignedVector512(Int16* address);
    public static Vector512`1<ushort> LoadAlignedVector512(UInt16* address);
    public static Vector512`1<int> LoadAlignedVector512(Int32* address);
    public static Vector512`1<UInt32> LoadAlignedVector512(UInt32* address);
    public static Vector512`1<long> LoadAlignedVector512(Int64* address);
    public static Vector512`1<ulong> LoadAlignedVector512(UInt64* address);
    public static Vector512`1<float> LoadAlignedVector512(Single* address);
    public static Vector512`1<double> LoadAlignedVector512(Double* address);
    public static Vector512`1<sbyte> LoadAlignedVector512NonTemporal(SByte* address);
    public static Vector512`1<byte> LoadAlignedVector512NonTemporal(Byte* address);
    public static Vector512`1<short> LoadAlignedVector512NonTemporal(Int16* address);
    public static Vector512`1<ushort> LoadAlignedVector512NonTemporal(UInt16* address);
    public static Vector512`1<int> LoadAlignedVector512NonTemporal(Int32* address);
    public static Vector512`1<UInt32> LoadAlignedVector512NonTemporal(UInt32* address);
    public static Vector512`1<long> LoadAlignedVector512NonTemporal(Int64* address);
    public static Vector512`1<ulong> LoadAlignedVector512NonTemporal(UInt64* address);
    public static Vector512`1<sbyte> LoadVector512(SByte* address);
    public static Vector512`1<byte> LoadVector512(Byte* address);
    public static Vector512`1<short> LoadVector512(Int16* address);
    public static Vector512`1<ushort> LoadVector512(UInt16* address);
    public static Vector512`1<int> LoadVector512(Int32* address);
    public static Vector512`1<UInt32> LoadVector512(UInt32* address);
    public static Vector512`1<long> LoadVector512(Int64* address);
    public static Vector512`1<ulong> LoadVector512(UInt64* address);
    public static Vector512`1<float> LoadVector512(Single* address);
    public static Vector512`1<double> LoadVector512(Double* address);
    public static Vector512`1<int> Max(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> Max(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> Max(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> Max(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<float> Max(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Max(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<int> Min(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> Min(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> Min(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> Min(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<float> Min(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Min(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<long> Multiply(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<ulong> Multiply(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<float> Multiply(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Multiply(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<int> MultiplyLow(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> MultiplyLow(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<byte> Or(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<sbyte> Or(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<short> Or(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> Or(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<int> Or(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> Or(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> Or(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> Or(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<double> Permute2x64(Vector512`1<double> value, byte control);
    public static Vector512`1<float> Permute4x32(Vector512`1<float> value, byte control);
    public static Vector512`1<long> Permute4x64(Vector512`1<long> value, byte control);
    public static Vector512`1<ulong> Permute4x64(Vector512`1<ulong> value, byte control);
    public static Vector512`1<double> Permute4x64(Vector512`1<double> value, byte control);
    public static Vector512`1<double> PermuteVar2x64(Vector512`1<double> left, Vector512`1<long> control);
    public static Vector512`1<float> PermuteVar4x32(Vector512`1<float> left, Vector512`1<int> control);
    public static Vector512`1<long> PermuteVar8x64(Vector512`1<long> value, Vector512`1<long> control);
    public static Vector512`1<ulong> PermuteVar8x64(Vector512`1<ulong> value, Vector512`1<ulong> control);
    public static Vector512`1<double> PermuteVar8x64(Vector512`1<double> value, Vector512`1<long> control);
    public static Vector512`1<long> PermuteVar8x64x2(Vector512`1<long> lower, Vector512`1<long> indices, Vector512`1<long> upper);
    public static Vector512`1<ulong> PermuteVar8x64x2(Vector512`1<ulong> lower, Vector512`1<ulong> indices, Vector512`1<ulong> upper);
    public static Vector512`1<double> PermuteVar8x64x2(Vector512`1<double> lower, Vector512`1<long> indices, Vector512`1<double> upper);
    public static Vector512`1<int> PermuteVar16x32(Vector512`1<int> left, Vector512`1<int> control);
    public static Vector512`1<UInt32> PermuteVar16x32(Vector512`1<UInt32> left, Vector512`1<UInt32> control);
    public static Vector512`1<float> PermuteVar16x32(Vector512`1<float> left, Vector512`1<int> control);
    public static Vector512`1<int> PermuteVar16x32x2(Vector512`1<int> lower, Vector512`1<int> indices, Vector512`1<int> upper);
    public static Vector512`1<UInt32> PermuteVar16x32x2(Vector512`1<UInt32> lower, Vector512`1<UInt32> indices, Vector512`1<UInt32> upper);
    public static Vector512`1<float> PermuteVar16x32x2(Vector512`1<float> lower, Vector512`1<int> indices, Vector512`1<float> upper);
    public static Vector512`1<float> Reciprocal14(Vector512`1<float> value);
    public static Vector512`1<double> Reciprocal14(Vector512`1<double> value);
    public static Vector128`1<float> Reciprocal14Scalar(Vector128`1<float> value);
    public static Vector128`1<double> Reciprocal14Scalar(Vector128`1<double> value);
    public static Vector128`1<float> Reciprocal14Scalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> Reciprocal14Scalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector512`1<float> ReciprocalSqrt14(Vector512`1<float> value);
    public static Vector512`1<double> ReciprocalSqrt14(Vector512`1<double> value);
    public static Vector128`1<float> ReciprocalSqrt14Scalar(Vector128`1<float> value);
    public static Vector128`1<double> ReciprocalSqrt14Scalar(Vector128`1<double> value);
    public static Vector128`1<float> ReciprocalSqrt14Scalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> ReciprocalSqrt14Scalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector512`1<int> RotateLeft(Vector512`1<int> value, byte count);
    public static Vector512`1<UInt32> RotateLeft(Vector512`1<UInt32> value, byte count);
    public static Vector512`1<long> RotateLeft(Vector512`1<long> value, byte count);
    public static Vector512`1<ulong> RotateLeft(Vector512`1<ulong> value, byte count);
    public static Vector512`1<int> RotateLeftVariable(Vector512`1<int> value, Vector512`1<UInt32> count);
    public static Vector512`1<UInt32> RotateLeftVariable(Vector512`1<UInt32> value, Vector512`1<UInt32> count);
    public static Vector512`1<long> RotateLeftVariable(Vector512`1<long> value, Vector512`1<ulong> count);
    public static Vector512`1<ulong> RotateLeftVariable(Vector512`1<ulong> value, Vector512`1<ulong> count);
    public static Vector512`1<int> RotateRight(Vector512`1<int> value, byte count);
    public static Vector512`1<UInt32> RotateRight(Vector512`1<UInt32> value, byte count);
    public static Vector512`1<long> RotateRight(Vector512`1<long> value, byte count);
    public static Vector512`1<ulong> RotateRight(Vector512`1<ulong> value, byte count);
    public static Vector512`1<int> RotateRightVariable(Vector512`1<int> value, Vector512`1<UInt32> count);
    public static Vector512`1<UInt32> RotateRightVariable(Vector512`1<UInt32> value, Vector512`1<UInt32> count);
    public static Vector512`1<long> RotateRightVariable(Vector512`1<long> value, Vector512`1<ulong> count);
    public static Vector512`1<ulong> RotateRightVariable(Vector512`1<ulong> value, Vector512`1<ulong> count);
    public static Vector512`1<float> RoundScale(Vector512`1<float> value, byte control);
    public static Vector512`1<double> RoundScale(Vector512`1<double> value, byte control);
    public static Vector128`1<float> RoundScaleScalar(Vector128`1<float> value, byte control);
    public static Vector128`1<double> RoundScaleScalar(Vector128`1<double> value, byte control);
    public static Vector128`1<float> RoundScaleScalar(Vector128`1<float> upper, Vector128`1<float> value, byte control);
    public static Vector128`1<double> RoundScaleScalar(Vector128`1<double> upper, Vector128`1<double> value, byte control);
    public static Vector512`1<float> Scale(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Scale(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector128`1<float> ScaleScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> ScaleScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector512`1<int> ShiftLeftLogical(Vector512`1<int> value, Vector128`1<int> count);
    public static Vector512`1<UInt32> ShiftLeftLogical(Vector512`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector512`1<long> ShiftLeftLogical(Vector512`1<long> value, Vector128`1<long> count);
    public static Vector512`1<ulong> ShiftLeftLogical(Vector512`1<ulong> value, Vector128`1<ulong> count);
    public static Vector512`1<int> ShiftLeftLogical(Vector512`1<int> value, byte count);
    public static Vector512`1<UInt32> ShiftLeftLogical(Vector512`1<UInt32> value, byte count);
    public static Vector512`1<long> ShiftLeftLogical(Vector512`1<long> value, byte count);
    public static Vector512`1<ulong> ShiftLeftLogical(Vector512`1<ulong> value, byte count);
    public static Vector512`1<int> ShiftLeftLogicalVariable(Vector512`1<int> value, Vector512`1<UInt32> count);
    public static Vector512`1<UInt32> ShiftLeftLogicalVariable(Vector512`1<UInt32> value, Vector512`1<UInt32> count);
    public static Vector512`1<long> ShiftLeftLogicalVariable(Vector512`1<long> value, Vector512`1<ulong> count);
    public static Vector512`1<ulong> ShiftLeftLogicalVariable(Vector512`1<ulong> value, Vector512`1<ulong> count);
    public static Vector512`1<int> ShiftRightArithmetic(Vector512`1<int> value, Vector128`1<int> count);
    public static Vector512`1<long> ShiftRightArithmetic(Vector512`1<long> value, Vector128`1<long> count);
    public static Vector512`1<int> ShiftRightArithmetic(Vector512`1<int> value, byte count);
    public static Vector512`1<long> ShiftRightArithmetic(Vector512`1<long> value, byte count);
    public static Vector512`1<int> ShiftRightArithmeticVariable(Vector512`1<int> value, Vector512`1<UInt32> count);
    public static Vector512`1<long> ShiftRightArithmeticVariable(Vector512`1<long> value, Vector512`1<ulong> count);
    public static Vector512`1<int> ShiftRightLogical(Vector512`1<int> value, Vector128`1<int> count);
    public static Vector512`1<UInt32> ShiftRightLogical(Vector512`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector512`1<long> ShiftRightLogical(Vector512`1<long> value, Vector128`1<long> count);
    public static Vector512`1<ulong> ShiftRightLogical(Vector512`1<ulong> value, Vector128`1<ulong> count);
    public static Vector512`1<int> ShiftRightLogical(Vector512`1<int> value, byte count);
    public static Vector512`1<UInt32> ShiftRightLogical(Vector512`1<UInt32> value, byte count);
    public static Vector512`1<long> ShiftRightLogical(Vector512`1<long> value, byte count);
    public static Vector512`1<ulong> ShiftRightLogical(Vector512`1<ulong> value, byte count);
    public static Vector512`1<int> ShiftRightLogicalVariable(Vector512`1<int> value, Vector512`1<UInt32> count);
    public static Vector512`1<UInt32> ShiftRightLogicalVariable(Vector512`1<UInt32> value, Vector512`1<UInt32> count);
    public static Vector512`1<long> ShiftRightLogicalVariable(Vector512`1<long> value, Vector512`1<ulong> count);
    public static Vector512`1<ulong> ShiftRightLogicalVariable(Vector512`1<ulong> value, Vector512`1<ulong> count);
    public static Vector512`1<int> Shuffle(Vector512`1<int> value, byte control);
    public static Vector512`1<UInt32> Shuffle(Vector512`1<UInt32> value, byte control);
    public static Vector512`1<float> Shuffle(Vector512`1<float> value, Vector512`1<float> right, byte control);
    public static Vector512`1<double> Shuffle(Vector512`1<double> value, Vector512`1<double> right, byte control);
    public static Vector512`1<double> Shuffle4x128(Vector512`1<double> left, Vector512`1<double> right, byte control);
    public static Vector512`1<int> Shuffle4x128(Vector512`1<int> left, Vector512`1<int> right, byte control);
    public static Vector512`1<long> Shuffle4x128(Vector512`1<long> left, Vector512`1<long> right, byte control);
    public static Vector512`1<float> Shuffle4x128(Vector512`1<float> left, Vector512`1<float> right, byte control);
    public static Vector512`1<UInt32> Shuffle4x128(Vector512`1<UInt32> left, Vector512`1<UInt32> right, byte control);
    public static Vector512`1<ulong> Shuffle4x128(Vector512`1<ulong> left, Vector512`1<ulong> right, byte control);
    public static Vector512`1<float> Sqrt(Vector512`1<float> value);
    public static Vector512`1<double> Sqrt(Vector512`1<double> value);
    public static void Store(SByte* address, Vector512`1<sbyte> source);
    public static void Store(Byte* address, Vector512`1<byte> source);
    public static void Store(Int16* address, Vector512`1<short> source);
    public static void Store(UInt16* address, Vector512`1<ushort> source);
    public static void Store(Int32* address, Vector512`1<int> source);
    public static void Store(UInt32* address, Vector512`1<UInt32> source);
    public static void Store(Int64* address, Vector512`1<long> source);
    public static void Store(UInt64* address, Vector512`1<ulong> source);
    public static void Store(Single* address, Vector512`1<float> source);
    public static void Store(Double* address, Vector512`1<double> source);
    public static void StoreAligned(Byte* address, Vector512`1<byte> source);
    public static void StoreAligned(SByte* address, Vector512`1<sbyte> source);
    public static void StoreAligned(Int16* address, Vector512`1<short> source);
    public static void StoreAligned(UInt16* address, Vector512`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector512`1<int> source);
    public static void StoreAligned(UInt32* address, Vector512`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector512`1<long> source);
    public static void StoreAligned(UInt64* address, Vector512`1<ulong> source);
    public static void StoreAligned(Single* address, Vector512`1<float> source);
    public static void StoreAligned(Double* address, Vector512`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector512`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector512`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector512`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector512`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector512`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector512`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector512`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector512`1<ulong> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector512`1<float> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector512`1<double> source);
    public static Vector512`1<int> Subtract(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> Subtract(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> Subtract(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> Subtract(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<float> Subtract(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> Subtract(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<sbyte> TernaryLogic(Vector512`1<sbyte> a, Vector512`1<sbyte> b, Vector512`1<sbyte> c, byte control);
    public static Vector512`1<byte> TernaryLogic(Vector512`1<byte> a, Vector512`1<byte> b, Vector512`1<byte> c, byte control);
    public static Vector512`1<short> TernaryLogic(Vector512`1<short> a, Vector512`1<short> b, Vector512`1<short> c, byte control);
    public static Vector512`1<ushort> TernaryLogic(Vector512`1<ushort> a, Vector512`1<ushort> b, Vector512`1<ushort> c, byte control);
    public static Vector512`1<int> TernaryLogic(Vector512`1<int> a, Vector512`1<int> b, Vector512`1<int> c, byte control);
    public static Vector512`1<UInt32> TernaryLogic(Vector512`1<UInt32> a, Vector512`1<UInt32> b, Vector512`1<UInt32> c, byte control);
    public static Vector512`1<long> TernaryLogic(Vector512`1<long> a, Vector512`1<long> b, Vector512`1<long> c, byte control);
    public static Vector512`1<ulong> TernaryLogic(Vector512`1<ulong> a, Vector512`1<ulong> b, Vector512`1<ulong> c, byte control);
    public static Vector512`1<float> TernaryLogic(Vector512`1<float> a, Vector512`1<float> b, Vector512`1<float> c, byte control);
    public static Vector512`1<double> TernaryLogic(Vector512`1<double> a, Vector512`1<double> b, Vector512`1<double> c, byte control);
    public static Vector512`1<int> UnpackHigh(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> UnpackHigh(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> UnpackHigh(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> UnpackHigh(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<float> UnpackHigh(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> UnpackHigh(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<int> UnpackLow(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> UnpackLow(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> UnpackLow(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> UnpackLow(Vector512`1<ulong> left, Vector512`1<ulong> right);
    public static Vector512`1<float> UnpackLow(Vector512`1<float> left, Vector512`1<float> right);
    public static Vector512`1<double> UnpackLow(Vector512`1<double> left, Vector512`1<double> right);
    public static Vector512`1<byte> Xor(Vector512`1<byte> left, Vector512`1<byte> right);
    public static Vector512`1<sbyte> Xor(Vector512`1<sbyte> left, Vector512`1<sbyte> right);
    public static Vector512`1<short> Xor(Vector512`1<short> left, Vector512`1<short> right);
    public static Vector512`1<ushort> Xor(Vector512`1<ushort> left, Vector512`1<ushort> right);
    public static Vector512`1<int> Xor(Vector512`1<int> left, Vector512`1<int> right);
    public static Vector512`1<UInt32> Xor(Vector512`1<UInt32> left, Vector512`1<UInt32> right);
    public static Vector512`1<long> Xor(Vector512`1<long> left, Vector512`1<long> right);
    public static Vector512`1<ulong> Xor(Vector512`1<ulong> left, Vector512`1<ulong> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Avx512Vbmi : Avx512BW {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector512`1<sbyte> PermuteVar64x8(Vector512`1<sbyte> left, Vector512`1<sbyte> control);
    public static Vector512`1<byte> PermuteVar64x8(Vector512`1<byte> left, Vector512`1<byte> control);
    public static Vector512`1<byte> PermuteVar64x8x2(Vector512`1<byte> lower, Vector512`1<byte> indices, Vector512`1<byte> upper);
    public static Vector512`1<sbyte> PermuteVar64x8x2(Vector512`1<sbyte> lower, Vector512`1<sbyte> indices, Vector512`1<sbyte> upper);
}
[CLSCompliantAttribute("False")]
[RequiresPreviewFeaturesAttribute("AvxVnni is in preview.")]
public abstract class System.Runtime.Intrinsics.X86.AvxVnni : Avx2 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<int> MultiplyWideningAndAdd(Vector128`1<int> addend, Vector128`1<byte> left, Vector128`1<sbyte> right);
    public static Vector128`1<int> MultiplyWideningAndAdd(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector256`1<int> MultiplyWideningAndAdd(Vector256`1<int> addend, Vector256`1<byte> left, Vector256`1<sbyte> right);
    public static Vector256`1<int> MultiplyWideningAndAdd(Vector256`1<int> addend, Vector256`1<short> left, Vector256`1<short> right);
    public static Vector128`1<int> MultiplyWideningAndAddSaturate(Vector128`1<int> addend, Vector128`1<byte> left, Vector128`1<sbyte> right);
    public static Vector128`1<int> MultiplyWideningAndAddSaturate(Vector128`1<int> addend, Vector128`1<short> left, Vector128`1<short> right);
    public static Vector256`1<int> MultiplyWideningAndAddSaturate(Vector256`1<int> addend, Vector256`1<byte> left, Vector256`1<sbyte> right);
    public static Vector256`1<int> MultiplyWideningAndAddSaturate(Vector256`1<int> addend, Vector256`1<short> left, Vector256`1<short> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Bmi1 : X86Base {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static UInt32 AndNot(UInt32 left, UInt32 right);
    public static UInt32 BitFieldExtract(UInt32 value, byte start, byte length);
    public static UInt32 BitFieldExtract(UInt32 value, ushort control);
    public static UInt32 ExtractLowestSetBit(UInt32 value);
    public static UInt32 GetMaskUpToLowestSetBit(UInt32 value);
    public static UInt32 ResetLowestSetBit(UInt32 value);
    public static UInt32 TrailingZeroCount(UInt32 value);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Bmi2 : X86Base {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static UInt32 ZeroHighBits(UInt32 value, UInt32 index);
    public static UInt32 MultiplyNoFlags(UInt32 left, UInt32 right);
    public static UInt32 MultiplyNoFlags(UInt32 left, UInt32 right, UInt32* low);
    public static UInt32 ParallelBitDeposit(UInt32 value, UInt32 mask);
    public static UInt32 ParallelBitExtract(UInt32 value, UInt32 mask);
}
public enum System.Runtime.Intrinsics.X86.FloatComparisonMode : Enum {
    public byte value__;
    public static FloatComparisonMode OrderedEqualNonSignaling;
    public static FloatComparisonMode OrderedLessThanSignaling;
    public static FloatComparisonMode OrderedLessThanOrEqualSignaling;
    public static FloatComparisonMode UnorderedNonSignaling;
    public static FloatComparisonMode UnorderedNotEqualNonSignaling;
    public static FloatComparisonMode UnorderedNotLessThanSignaling;
    public static FloatComparisonMode UnorderedNotLessThanOrEqualSignaling;
    public static FloatComparisonMode OrderedNonSignaling;
    public static FloatComparisonMode UnorderedEqualNonSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanOrEqualSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanSignaling;
    public static FloatComparisonMode OrderedFalseNonSignaling;
    public static FloatComparisonMode OrderedNotEqualNonSignaling;
    public static FloatComparisonMode OrderedGreaterThanOrEqualSignaling;
    public static FloatComparisonMode OrderedGreaterThanSignaling;
    public static FloatComparisonMode UnorderedTrueNonSignaling;
    public static FloatComparisonMode OrderedEqualSignaling;
    public static FloatComparisonMode OrderedLessThanNonSignaling;
    public static FloatComparisonMode OrderedLessThanOrEqualNonSignaling;
    public static FloatComparisonMode UnorderedSignaling;
    public static FloatComparisonMode UnorderedNotEqualSignaling;
    public static FloatComparisonMode UnorderedNotLessThanNonSignaling;
    public static FloatComparisonMode UnorderedNotLessThanOrEqualNonSignaling;
    public static FloatComparisonMode OrderedSignaling;
    public static FloatComparisonMode UnorderedEqualSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanOrEqualNonSignaling;
    public static FloatComparisonMode UnorderedNotGreaterThanNonSignaling;
    public static FloatComparisonMode OrderedFalseSignaling;
    public static FloatComparisonMode OrderedNotEqualSignaling;
    public static FloatComparisonMode OrderedGreaterThanOrEqualNonSignaling;
    public static FloatComparisonMode OrderedGreaterThanNonSignaling;
    public static FloatComparisonMode UnorderedTrueSignaling;
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Fma : Avx {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<float> MultiplyAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplyAddSubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddSubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddSubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddSubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtract(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtract(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtract(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtract(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractAdd(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractAdd(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractAdd(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractAdd(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplyAddNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplyAddNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplyAddNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplyAddNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegated(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegated(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
    public static Vector256`1<float> MultiplySubtractNegated(Vector256`1<float> a, Vector256`1<float> b, Vector256`1<float> c);
    public static Vector256`1<double> MultiplySubtractNegated(Vector256`1<double> a, Vector256`1<double> b, Vector256`1<double> c);
    public static Vector128`1<float> MultiplySubtractNegatedScalar(Vector128`1<float> a, Vector128`1<float> b, Vector128`1<float> c);
    public static Vector128`1<double> MultiplySubtractNegatedScalar(Vector128`1<double> a, Vector128`1<double> b, Vector128`1<double> c);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Lzcnt : X86Base {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static UInt32 LeadingZeroCount(UInt32 value);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Pclmulqdq : Sse2 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<long> CarrylessMultiply(Vector128`1<long> left, Vector128`1<long> right, byte control);
    public static Vector128`1<ulong> CarrylessMultiply(Vector128`1<ulong> left, Vector128`1<ulong> right, byte control);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Popcnt : Sse42 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static UInt32 PopCount(UInt32 value);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse : X86Base {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<float> Add(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AddScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> And(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> AndNot(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareNotLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareOrdered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarNotLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarOrdered(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarOrderedNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareScalarUnordered(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedGreaterThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedGreaterThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedLessThan(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedLessThanOrEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static bool CompareScalarUnorderedNotEqual(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> CompareUnordered(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, int value);
    public static int ConvertToInt32(Vector128`1<float> value);
    public static int ConvertToInt32WithTruncation(Vector128`1<float> value);
    public static Vector128`1<float> Divide(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> DivideScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> LoadAlignedVector128(Single* address);
    public static Vector128`1<float> LoadHigh(Vector128`1<float> lower, Single* address);
    public static Vector128`1<float> LoadLow(Vector128`1<float> upper, Single* address);
    public static Vector128`1<float> LoadScalarVector128(Single* address);
    public static Vector128`1<float> LoadVector128(Single* address);
    public static Vector128`1<float> Max(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MaxScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Min(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MinScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveHighToLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MoveLowToHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static int MoveMask(Vector128`1<float> value);
    public static Vector128`1<float> MoveScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> Multiply(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> MultiplyScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Or(Vector128`1<float> left, Vector128`1<float> right);
    public static void Prefetch0(Void* address);
    public static void Prefetch1(Void* address);
    public static void Prefetch2(Void* address);
    public static void PrefetchNonTemporal(Void* address);
    public static Vector128`1<float> Reciprocal(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrt(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> ReciprocalSqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<float> Shuffle(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<float> Sqrt(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> value);
    public static Vector128`1<float> SqrtScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static void Store(Single* address, Vector128`1<float> source);
    public static void StoreAligned(Single* address, Vector128`1<float> source);
    public static void StoreAlignedNonTemporal(Single* address, Vector128`1<float> source);
    public static void StoreFence();
    public static void StoreHigh(Single* address, Vector128`1<float> source);
    public static void StoreLow(Single* address, Vector128`1<float> source);
    public static void StoreScalar(Single* address, Vector128`1<float> source);
    public static Vector128`1<float> Subtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> SubtractScalar(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackHigh(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> UnpackLow(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<float> Xor(Vector128`1<float> left, Vector128`1<float> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse2 : Sse {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<byte> Add(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Add(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Add(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Add(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Add(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Add(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Add(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Add(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Add(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> AddScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> AddSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> AddSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> AddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AddSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<byte> And(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> And(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> And(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> And(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> And(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> And(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> And(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> And(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> And(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> AndNot(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> AndNot(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> AndNot(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> AndNot(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> AndNot(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> AndNot(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> AndNot(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> AndNot(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> AndNot(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Average(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> Average(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<sbyte> CompareEqual(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<byte> CompareEqual(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> CompareEqual(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> CompareEqual(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> CompareEqual(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> CompareEqual(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> CompareEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareGreaterThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareGreaterThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareGreaterThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> CompareLessThan(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> CompareLessThan(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> CompareLessThan(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<double> CompareLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareNotLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareOrdered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarNotLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarOrdered(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarOrderedNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareScalarUnordered(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedGreaterThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedGreaterThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedLessThan(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedLessThanOrEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static bool CompareScalarUnorderedNotEqual(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> CompareUnordered(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, int value);
    public static Vector128`1<double> ConvertScalarToVector128Double(Vector128`1<double> upper, Vector128`1<float> value);
    public static Vector128`1<int> ConvertScalarToVector128Int32(int value);
    public static Vector128`1<float> ConvertScalarToVector128Single(Vector128`1<float> upper, Vector128`1<double> value);
    public static Vector128`1<UInt32> ConvertScalarToVector128UInt32(UInt32 value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<int> value);
    public static Vector128`1<double> ConvertToVector128Double(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<double> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<float> value);
    public static Vector128`1<int> ConvertToVector128Int32WithTruncation(Vector128`1<double> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<int> value);
    public static Vector128`1<float> ConvertToVector128Single(Vector128`1<double> value);
    public static int ConvertToInt32(Vector128`1<int> value);
    public static int ConvertToInt32(Vector128`1<double> value);
    public static int ConvertToInt32WithTruncation(Vector128`1<double> value);
    public static UInt32 ConvertToUInt32(Vector128`1<UInt32> value);
    public static Vector128`1<double> Divide(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> DivideScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static ushort Extract(Vector128`1<ushort> value, byte index);
    public static Vector128`1<short> Insert(Vector128`1<short> value, short data, byte index);
    public static Vector128`1<ushort> Insert(Vector128`1<ushort> value, ushort data, byte index);
    public static Vector128`1<sbyte> LoadAlignedVector128(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128(UInt64* address);
    public static Vector128`1<double> LoadAlignedVector128(Double* address);
    public static void LoadFence();
    public static Vector128`1<double> LoadHigh(Vector128`1<double> lower, Double* address);
    public static Vector128`1<double> LoadLow(Vector128`1<double> upper, Double* address);
    public static Vector128`1<int> LoadScalarVector128(Int32* address);
    public static Vector128`1<UInt32> LoadScalarVector128(UInt32* address);
    public static Vector128`1<long> LoadScalarVector128(Int64* address);
    public static Vector128`1<ulong> LoadScalarVector128(UInt64* address);
    public static Vector128`1<double> LoadScalarVector128(Double* address);
    public static Vector128`1<sbyte> LoadVector128(SByte* address);
    public static Vector128`1<byte> LoadVector128(Byte* address);
    public static Vector128`1<short> LoadVector128(Int16* address);
    public static Vector128`1<ushort> LoadVector128(UInt16* address);
    public static Vector128`1<int> LoadVector128(Int32* address);
    public static Vector128`1<UInt32> LoadVector128(UInt32* address);
    public static Vector128`1<long> LoadVector128(Int64* address);
    public static Vector128`1<ulong> LoadVector128(UInt64* address);
    public static Vector128`1<double> LoadVector128(Double* address);
    public static void MaskMove(Vector128`1<sbyte> source, Vector128`1<sbyte> mask, SByte* address);
    public static void MaskMove(Vector128`1<byte> source, Vector128`1<byte> mask, Byte* address);
    public static Vector128`1<byte> Max(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Max(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Max(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MaxScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static void MemoryFence();
    public static Vector128`1<byte> Min(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<short> Min(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<double> Min(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> MinScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static int MoveMask(Vector128`1<sbyte> value);
    public static int MoveMask(Vector128`1<byte> value);
    public static int MoveMask(Vector128`1<double> value);
    public static Vector128`1<long> MoveScalar(Vector128`1<long> value);
    public static Vector128`1<ulong> MoveScalar(Vector128`1<ulong> value);
    public static Vector128`1<double> MoveScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<ulong> Multiply(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<double> Multiply(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<int> MultiplyAddAdjacent(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> MultiplyHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<short> MultiplyLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> MultiplyLow(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<double> MultiplyScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Or(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Or(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Or(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Or(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Or(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Or(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Or(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Or(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Or(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> PackSignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> PackSignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<byte> PackUnsignedSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftLeftLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftLeftLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftLeftLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftLeftLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftLeftLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftLeftLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftLeftLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftLeftLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftLeftLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftLeftLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftLeftLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftLeftLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftLeftLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftLeftLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<short> ShiftRightArithmetic(Vector128`1<short> value, byte count);
    public static Vector128`1<int> ShiftRightArithmetic(Vector128`1<int> value, byte count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, Vector128`1<short> count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, Vector128`1<ushort> count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, Vector128`1<int> count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, Vector128`1<UInt32> count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, Vector128`1<long> count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, Vector128`1<ulong> count);
    public static Vector128`1<short> ShiftRightLogical(Vector128`1<short> value, byte count);
    public static Vector128`1<ushort> ShiftRightLogical(Vector128`1<ushort> value, byte count);
    public static Vector128`1<int> ShiftRightLogical(Vector128`1<int> value, byte count);
    public static Vector128`1<UInt32> ShiftRightLogical(Vector128`1<UInt32> value, byte count);
    public static Vector128`1<long> ShiftRightLogical(Vector128`1<long> value, byte count);
    public static Vector128`1<ulong> ShiftRightLogical(Vector128`1<ulong> value, byte count);
    public static Vector128`1<sbyte> ShiftRightLogical128BitLane(Vector128`1<sbyte> value, byte numBytes);
    public static Vector128`1<byte> ShiftRightLogical128BitLane(Vector128`1<byte> value, byte numBytes);
    public static Vector128`1<short> ShiftRightLogical128BitLane(Vector128`1<short> value, byte numBytes);
    public static Vector128`1<ushort> ShiftRightLogical128BitLane(Vector128`1<ushort> value, byte numBytes);
    public static Vector128`1<int> ShiftRightLogical128BitLane(Vector128`1<int> value, byte numBytes);
    public static Vector128`1<UInt32> ShiftRightLogical128BitLane(Vector128`1<UInt32> value, byte numBytes);
    public static Vector128`1<long> ShiftRightLogical128BitLane(Vector128`1<long> value, byte numBytes);
    public static Vector128`1<ulong> ShiftRightLogical128BitLane(Vector128`1<ulong> value, byte numBytes);
    public static Vector128`1<int> Shuffle(Vector128`1<int> value, byte control);
    public static Vector128`1<UInt32> Shuffle(Vector128`1<UInt32> value, byte control);
    public static Vector128`1<double> Shuffle(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<short> ShuffleHigh(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleHigh(Vector128`1<ushort> value, byte control);
    public static Vector128`1<short> ShuffleLow(Vector128`1<short> value, byte control);
    public static Vector128`1<ushort> ShuffleLow(Vector128`1<ushort> value, byte control);
    public static Vector128`1<double> Sqrt(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> value);
    public static Vector128`1<double> SqrtScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static void Store(SByte* address, Vector128`1<sbyte> source);
    public static void Store(Byte* address, Vector128`1<byte> source);
    public static void Store(Int16* address, Vector128`1<short> source);
    public static void Store(UInt16* address, Vector128`1<ushort> source);
    public static void Store(Int32* address, Vector128`1<int> source);
    public static void Store(UInt32* address, Vector128`1<UInt32> source);
    public static void Store(Int64* address, Vector128`1<long> source);
    public static void Store(UInt64* address, Vector128`1<ulong> source);
    public static void Store(Double* address, Vector128`1<double> source);
    public static void StoreAligned(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAligned(Byte* address, Vector128`1<byte> source);
    public static void StoreAligned(Int16* address, Vector128`1<short> source);
    public static void StoreAligned(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAligned(Int32* address, Vector128`1<int> source);
    public static void StoreAligned(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAligned(Int64* address, Vector128`1<long> source);
    public static void StoreAligned(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAligned(Double* address, Vector128`1<double> source);
    public static void StoreAlignedNonTemporal(SByte* address, Vector128`1<sbyte> source);
    public static void StoreAlignedNonTemporal(Byte* address, Vector128`1<byte> source);
    public static void StoreAlignedNonTemporal(Int16* address, Vector128`1<short> source);
    public static void StoreAlignedNonTemporal(UInt16* address, Vector128`1<ushort> source);
    public static void StoreAlignedNonTemporal(Int32* address, Vector128`1<int> source);
    public static void StoreAlignedNonTemporal(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreAlignedNonTemporal(Int64* address, Vector128`1<long> source);
    public static void StoreAlignedNonTemporal(UInt64* address, Vector128`1<ulong> source);
    public static void StoreAlignedNonTemporal(Double* address, Vector128`1<double> source);
    public static void StoreHigh(Double* address, Vector128`1<double> source);
    public static void StoreLow(Double* address, Vector128`1<double> source);
    public static void StoreNonTemporal(Int32* address, int value);
    public static void StoreNonTemporal(UInt32* address, UInt32 value);
    public static void StoreScalar(Int32* address, Vector128`1<int> source);
    public static void StoreScalar(UInt32* address, Vector128`1<UInt32> source);
    public static void StoreScalar(Int64* address, Vector128`1<long> source);
    public static void StoreScalar(UInt64* address, Vector128`1<ulong> source);
    public static void StoreScalar(Double* address, Vector128`1<double> source);
    public static Vector128`1<byte> Subtract(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Subtract(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Subtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Subtract(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Subtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Subtract(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Subtract(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Subtract(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Subtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> SubtractScalar(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<sbyte> SubtractSaturate(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> SubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<byte> SubtractSaturate(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<ushort> SubtractSaturate(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<ushort> SumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<byte> UnpackHigh(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackHigh(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackHigh(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackHigh(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackHigh(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackHigh(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackHigh(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackHigh(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackHigh(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> UnpackLow(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> UnpackLow(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> UnpackLow(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> UnpackLow(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> UnpackLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> UnpackLow(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> UnpackLow(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> UnpackLow(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> UnpackLow(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<byte> Xor(Vector128`1<byte> left, Vector128`1<byte> right);
    public static Vector128`1<sbyte> Xor(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Xor(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<ushort> Xor(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Xor(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Xor(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<long> Xor(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> Xor(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<double> Xor(Vector128`1<double> left, Vector128`1<double> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse3 : Sse2 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<float> AddSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> AddSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalAdd(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalAdd(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<float> HorizontalSubtract(Vector128`1<float> left, Vector128`1<float> right);
    public static Vector128`1<double> HorizontalSubtract(Vector128`1<double> left, Vector128`1<double> right);
    public static Vector128`1<double> LoadAndDuplicateToVector128(Double* address);
    public static Vector128`1<sbyte> LoadDquVector128(SByte* address);
    public static Vector128`1<byte> LoadDquVector128(Byte* address);
    public static Vector128`1<short> LoadDquVector128(Int16* address);
    public static Vector128`1<ushort> LoadDquVector128(UInt16* address);
    public static Vector128`1<int> LoadDquVector128(Int32* address);
    public static Vector128`1<UInt32> LoadDquVector128(UInt32* address);
    public static Vector128`1<long> LoadDquVector128(Int64* address);
    public static Vector128`1<ulong> LoadDquVector128(UInt64* address);
    public static Vector128`1<double> MoveAndDuplicate(Vector128`1<double> source);
    public static Vector128`1<float> MoveHighAndDuplicate(Vector128`1<float> source);
    public static Vector128`1<float> MoveLowAndDuplicate(Vector128`1<float> source);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse41 : Ssse3 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<short> Blend(Vector128`1<short> left, Vector128`1<short> right, byte control);
    public static Vector128`1<ushort> Blend(Vector128`1<ushort> left, Vector128`1<ushort> right, byte control);
    public static Vector128`1<float> Blend(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> Blend(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static Vector128`1<sbyte> BlendVariable(Vector128`1<sbyte> left, Vector128`1<sbyte> right, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> BlendVariable(Vector128`1<byte> left, Vector128`1<byte> right, Vector128`1<byte> mask);
    public static Vector128`1<short> BlendVariable(Vector128`1<short> left, Vector128`1<short> right, Vector128`1<short> mask);
    public static Vector128`1<ushort> BlendVariable(Vector128`1<ushort> left, Vector128`1<ushort> right, Vector128`1<ushort> mask);
    public static Vector128`1<int> BlendVariable(Vector128`1<int> left, Vector128`1<int> right, Vector128`1<int> mask);
    public static Vector128`1<UInt32> BlendVariable(Vector128`1<UInt32> left, Vector128`1<UInt32> right, Vector128`1<UInt32> mask);
    public static Vector128`1<long> BlendVariable(Vector128`1<long> left, Vector128`1<long> right, Vector128`1<long> mask);
    public static Vector128`1<ulong> BlendVariable(Vector128`1<ulong> left, Vector128`1<ulong> right, Vector128`1<ulong> mask);
    public static Vector128`1<float> BlendVariable(Vector128`1<float> left, Vector128`1<float> right, Vector128`1<float> mask);
    public static Vector128`1<double> BlendVariable(Vector128`1<double> left, Vector128`1<double> right, Vector128`1<double> mask);
    public static Vector128`1<float> Ceiling(Vector128`1<float> value);
    public static Vector128`1<double> Ceiling(Vector128`1<double> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> value);
    public static Vector128`1<float> CeilingScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> value);
    public static Vector128`1<double> CeilingScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<long> CompareEqual(Vector128`1<long> left, Vector128`1<long> right);
    public static Vector128`1<ulong> CompareEqual(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<sbyte> value);
    public static Vector128`1<short> ConvertToVector128Int16(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<sbyte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<byte> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<short> value);
    public static Vector128`1<int> ConvertToVector128Int32(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<sbyte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<byte> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<short> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<ushort> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<int> value);
    public static Vector128`1<long> ConvertToVector128Int64(Vector128`1<UInt32> value);
    public static Vector128`1<short> ConvertToVector128Int16(SByte* address);
    public static Vector128`1<short> ConvertToVector128Int16(Byte* address);
    public static Vector128`1<int> ConvertToVector128Int32(SByte* address);
    public static Vector128`1<int> ConvertToVector128Int32(Byte* address);
    public static Vector128`1<int> ConvertToVector128Int32(Int16* address);
    public static Vector128`1<int> ConvertToVector128Int32(UInt16* address);
    public static Vector128`1<long> ConvertToVector128Int64(SByte* address);
    public static Vector128`1<long> ConvertToVector128Int64(Byte* address);
    public static Vector128`1<long> ConvertToVector128Int64(Int16* address);
    public static Vector128`1<long> ConvertToVector128Int64(UInt16* address);
    public static Vector128`1<long> ConvertToVector128Int64(Int32* address);
    public static Vector128`1<long> ConvertToVector128Int64(UInt32* address);
    public static Vector128`1<float> DotProduct(Vector128`1<float> left, Vector128`1<float> right, byte control);
    public static Vector128`1<double> DotProduct(Vector128`1<double> left, Vector128`1<double> right, byte control);
    public static byte Extract(Vector128`1<byte> value, byte index);
    public static int Extract(Vector128`1<int> value, byte index);
    public static UInt32 Extract(Vector128`1<UInt32> value, byte index);
    public static float Extract(Vector128`1<float> value, byte index);
    public static Vector128`1<float> Floor(Vector128`1<float> value);
    public static Vector128`1<double> Floor(Vector128`1<double> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> value);
    public static Vector128`1<float> FloorScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> value);
    public static Vector128`1<double> FloorScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<sbyte> Insert(Vector128`1<sbyte> value, sbyte data, byte index);
    public static Vector128`1<byte> Insert(Vector128`1<byte> value, byte data, byte index);
    public static Vector128`1<int> Insert(Vector128`1<int> value, int data, byte index);
    public static Vector128`1<UInt32> Insert(Vector128`1<UInt32> value, UInt32 data, byte index);
    public static Vector128`1<float> Insert(Vector128`1<float> value, Vector128`1<float> data, byte index);
    public static Vector128`1<sbyte> LoadAlignedVector128NonTemporal(SByte* address);
    public static Vector128`1<byte> LoadAlignedVector128NonTemporal(Byte* address);
    public static Vector128`1<short> LoadAlignedVector128NonTemporal(Int16* address);
    public static Vector128`1<ushort> LoadAlignedVector128NonTemporal(UInt16* address);
    public static Vector128`1<int> LoadAlignedVector128NonTemporal(Int32* address);
    public static Vector128`1<UInt32> LoadAlignedVector128NonTemporal(UInt32* address);
    public static Vector128`1<long> LoadAlignedVector128NonTemporal(Int64* address);
    public static Vector128`1<ulong> LoadAlignedVector128NonTemporal(UInt64* address);
    public static Vector128`1<sbyte> Max(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Max(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Max(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Max(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<sbyte> Min(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<ushort> Min(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static Vector128`1<int> Min(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> Min(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> MinHorizontal(Vector128`1<ushort> value);
    public static Vector128`1<ushort> MultipleSumAbsoluteDifferences(Vector128`1<byte> left, Vector128`1<byte> right, byte mask);
    public static Vector128`1<long> Multiply(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<int> MultiplyLow(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<UInt32> MultiplyLow(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static Vector128`1<ushort> PackUnsignedSaturate(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<float> RoundCurrentDirection(Vector128`1<float> value);
    public static Vector128`1<double> RoundCurrentDirection(Vector128`1<double> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundCurrentDirectionScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundCurrentDirectionScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundToNearestInteger(Vector128`1<float> value);
    public static Vector128`1<double> RoundToNearestInteger(Vector128`1<double> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNearestIntegerScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNearestIntegerScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundToNegativeInfinity(Vector128`1<float> value);
    public static Vector128`1<double> RoundToNegativeInfinity(Vector128`1<double> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToNegativeInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToNegativeInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundToPositiveInfinity(Vector128`1<float> value);
    public static Vector128`1<double> RoundToPositiveInfinity(Vector128`1<double> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToPositiveInfinityScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToPositiveInfinityScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static Vector128`1<float> RoundToZero(Vector128`1<float> value);
    public static Vector128`1<double> RoundToZero(Vector128`1<double> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> value);
    public static Vector128`1<float> RoundToZeroScalar(Vector128`1<float> upper, Vector128`1<float> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> value);
    public static Vector128`1<double> RoundToZeroScalar(Vector128`1<double> upper, Vector128`1<double> value);
    public static bool TestC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestNotZAndNotC(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestNotZAndNotC(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestNotZAndNotC(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestNotZAndNotC(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestNotZAndNotC(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestNotZAndNotC(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestNotZAndNotC(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestNotZAndNotC(Vector128`1<ulong> left, Vector128`1<ulong> right);
    public static bool TestZ(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static bool TestZ(Vector128`1<byte> left, Vector128`1<byte> right);
    public static bool TestZ(Vector128`1<short> left, Vector128`1<short> right);
    public static bool TestZ(Vector128`1<ushort> left, Vector128`1<ushort> right);
    public static bool TestZ(Vector128`1<int> left, Vector128`1<int> right);
    public static bool TestZ(Vector128`1<UInt32> left, Vector128`1<UInt32> right);
    public static bool TestZ(Vector128`1<long> left, Vector128`1<long> right);
    public static bool TestZ(Vector128`1<ulong> left, Vector128`1<ulong> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Sse42 : Sse41 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<long> CompareGreaterThan(Vector128`1<long> left, Vector128`1<long> right);
    public static UInt32 Crc32(UInt32 crc, byte data);
    public static UInt32 Crc32(UInt32 crc, ushort data);
    public static UInt32 Crc32(UInt32 crc, UInt32 data);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.Ssse3 : Sse3 {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static Vector128`1<byte> Abs(Vector128`1<sbyte> value);
    public static Vector128`1<ushort> Abs(Vector128`1<short> value);
    public static Vector128`1<UInt32> Abs(Vector128`1<int> value);
    public static Vector128`1<sbyte> AlignRight(Vector128`1<sbyte> left, Vector128`1<sbyte> right, byte mask);
    public static Vector128`1<byte> AlignRight(Vector128`1<byte> left, Vector128`1<byte> right, byte mask);
    public static Vector128`1<short> AlignRight(Vector128`1<short> left, Vector128`1<short> right, byte mask);
    public static Vector128`1<ushort> AlignRight(Vector128`1<ushort> left, Vector128`1<ushort> right, byte mask);
    public static Vector128`1<int> AlignRight(Vector128`1<int> left, Vector128`1<int> right, byte mask);
    public static Vector128`1<UInt32> AlignRight(Vector128`1<UInt32> left, Vector128`1<UInt32> right, byte mask);
    public static Vector128`1<long> AlignRight(Vector128`1<long> left, Vector128`1<long> right, byte mask);
    public static Vector128`1<ulong> AlignRight(Vector128`1<ulong> left, Vector128`1<ulong> right, byte mask);
    public static Vector128`1<short> HorizontalAdd(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalAdd(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalAddSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> HorizontalSubtract(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> HorizontalSubtract(Vector128`1<int> left, Vector128`1<int> right);
    public static Vector128`1<short> HorizontalSubtractSaturate(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<short> MultiplyAddAdjacent(Vector128`1<byte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> MultiplyHighRoundScale(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<sbyte> Shuffle(Vector128`1<sbyte> value, Vector128`1<sbyte> mask);
    public static Vector128`1<byte> Shuffle(Vector128`1<byte> value, Vector128`1<byte> mask);
    public static Vector128`1<sbyte> Sign(Vector128`1<sbyte> left, Vector128`1<sbyte> right);
    public static Vector128`1<short> Sign(Vector128`1<short> left, Vector128`1<short> right);
    public static Vector128`1<int> Sign(Vector128`1<int> left, Vector128`1<int> right);
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.X86Base : object {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static ValueTuple`4<int, int, int, int> CpuId(int functionId, int subFunctionId);
    [RequiresPreviewFeaturesAttribute("DivRem is in preview.")]
public static ValueTuple`2<UInt32, UInt32> DivRem(UInt32 lower, UInt32 upper, UInt32 divisor);
    [RequiresPreviewFeaturesAttribute("DivRem is in preview.")]
public static ValueTuple`2<int, int> DivRem(UInt32 lower, int upper, int divisor);
    [RequiresPreviewFeaturesAttribute("DivRem is in preview.")]
public static ValueTuple`2<UIntPtr, UIntPtr> DivRem(UIntPtr lower, UIntPtr upper, UIntPtr divisor);
    [RequiresPreviewFeaturesAttribute("DivRem is in preview.")]
public static ValueTuple`2<IntPtr, IntPtr> DivRem(UIntPtr lower, IntPtr upper, IntPtr divisor);
    public static void Pause();
}
[CLSCompliantAttribute("False")]
public abstract class System.Runtime.Intrinsics.X86.X86Serialize : X86Base {
    public static bool IsSupported { get; }
    [IntrinsicAttribute]
public static bool get_IsSupported();
    public static void Serialize();
}
public static class System.Runtime.JitInfo : object {
    public static long GetCompiledILBytes(bool currentThread);
    public static long GetCompiledMethodCount(bool currentThread);
    private static long GetCompilationTimeInTicks(bool currentThread);
    public static TimeSpan GetCompilationTime(bool currentThread);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("android")]
[UnsupportedOSPlatformAttribute("browser")]
[UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("tvos")]
public class System.Runtime.Loader.AssemblyDependencyResolver : object {
    public AssemblyDependencyResolver(string componentAssemblyPath);
    public string ResolveAssemblyToPath(AssemblyName assemblyName);
    public string ResolveUnmanagedDllToPath(string unmanagedDllName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Loader.AssemblyLoadContext : object {
    private static Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) s_allContexts;
    private static long s_nextId;
    private IntPtr _nativeAssemblyLoadContext;
    private object _unloadLock;
    [CompilerGeneratedAttribute]
private Func`3<Assembly, string, IntPtr> _resolvingUnmanagedDll;
    [CompilerGeneratedAttribute]
private Func`3<AssemblyLoadContext, AssemblyName, Assembly> _resolving;
    [CompilerGeneratedAttribute]
private Action`1<AssemblyLoadContext> _unloading;
    private string _name;
    private long _id;
    private InternalState _state;
    private bool _isCollectible;
    [CompilerGeneratedAttribute]
private static AssemblyLoadEventHandler AssemblyLoad;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler TypeResolve;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler ResourceResolve;
    [CompilerGeneratedAttribute]
private static ResolveEventHandler AssemblyResolve;
    private static AsyncLocal`1<AssemblyLoadContext> s_asyncLocalCurrent;
    internal IntPtr NativeALC { get; }
    [MemberNotNullAttribute("s_allContexts")]
private static Dictionary`2<long, WeakReference`1<AssemblyLoadContext>> AllContexts { get; }
    public IEnumerable`1<Assembly> Assemblies { get; }
    public static AssemblyLoadContext Default { get; }
    public bool IsCollectible { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public static IEnumerable`1<AssemblyLoadContext> All { get; }
    [NullableAttribute("2")]
public static AssemblyLoadContext CurrentContextualReflectionContext { get; }
    protected AssemblyLoadContext(bool isCollectible);
    [NullableContextAttribute("2")]
public AssemblyLoadContext(string name, bool isCollectible);
    private protected AssemblyLoadContext(bool representsTPALoadContext, bool isCollectible, string name);
    internal IntPtr get_NativeALC();
    [DynamicDependencyAttribute("_nativeAssemblyLoadContext")]
private IntPtr InitializeAssemblyLoadContext(IntPtr thisHandlePtr, bool representsTPALoadContext, bool isCollectible);
    [DynamicDependencyAttribute("-1", "System.Reflection.LoaderAllocator")]
private static void KeepLoaderAllocator();
    private static void PrepareForAssemblyLoadContextRelease(IntPtr nativeAssemblyLoadContext, IntPtr assemblyLoadContextStrong);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
private Assembly InternalLoadFromPath(string assemblyPath, string nativeImagePath);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
internal Assembly InternalLoad(ReadOnlySpan`1<byte> arrAssembly, ReadOnlySpan`1<byte> arrSymbols);
    internal static Assembly[] GetLoadedAssemblies();
    private static IntPtr GetLoadContextForAssembly(RuntimeAssembly rtAsm);
    public static AssemblyLoadContext GetLoadContext(Assembly assembly);
    public void SetProfileOptimizationRoot(string directoryPath);
    [NullableContextAttribute("2")]
public void StartProfileOptimization(string profile);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
private static Assembly InternalLoadFile(IntPtr nativeAssemblyLoadContext, string assemblyFile, StackCrawlMark& stackMark);
    private static IntPtr InternalInitializeNativeALC(IntPtr thisHandlePtr, IntPtr name, bool representsTPALoadContext, bool isCollectible);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
private static Assembly InternalLoadFromStream(IntPtr nativeAssemblyLoadContext, IntPtr assm, int assmLength, IntPtr symbols, int symbolsLength);
    private static Assembly[] InternalGetLoadedAssemblies();
    private static Assembly MonoResolveUsingLoad(IntPtr gchALC, string assemblyName);
    private static Assembly MonoResolveUsingResolvingEvent(IntPtr gchALC, string assemblyName);
    private static Assembly MonoResolveUsingResolveSatelliteAssembly(IntPtr gchALC, string assemblyName);
    private static AssemblyLoadContext GetAssemblyLoadContext(IntPtr gchManagedAssemblyLoadContext);
    private static void MonoResolveUnmanagedDll(string unmanagedDllName, IntPtr gchManagedAssemblyLoadContext, IntPtr& dll);
    private static void MonoResolveUnmanagedDllUsingEvent(string unmanagedDllName, Assembly assembly, IntPtr gchManagedAssemblyLoadContext, IntPtr& dll);
    private static RuntimeAssembly GetRuntimeAssembly(Assembly asm);
    [MemberNotNullAttribute("s_allContexts")]
private static Dictionary`2<long, WeakReference`1<AssemblyLoadContext>> get_AllContexts();
    [CompilerGeneratedAttribute]
private void add__resolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    [CompilerGeneratedAttribute]
private void remove__resolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    [CompilerGeneratedAttribute]
private void add__resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
private void remove__resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    [CompilerGeneratedAttribute]
private void add__unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
private void remove__unloading(Action`1<AssemblyLoadContext> value);
    protected virtual override void Finalize();
    private void RaiseUnloadEvent();
    private void InitiateUnload();
    [IteratorStateMachineAttribute("System.Runtime.Loader.AssemblyLoadContext/<get_Assemblies>d__52")]
public IEnumerable`1<Assembly> get_Assemblies();
    [DynamicDependencyAttribute("MonoResolveUnmanagedDllUsingEvent")]
public void add_ResolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    public void remove_ResolvingUnmanagedDll(Func`3<Assembly, string, IntPtr> value);
    [DynamicDependencyAttribute("MonoResolveUsingResolvingEvent")]
public void add_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    public void remove_Resolving(Func`3<AssemblyLoadContext, AssemblyName, Assembly> value);
    public void add_Unloading(Action`1<AssemblyLoadContext> value);
    public void remove_Unloading(Action`1<AssemblyLoadContext> value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnAssemblyLoad")]
internal static void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnAssemblyLoad")]
internal static void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnTypeResolve")]
internal static void add_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnTypeResolve")]
internal static void remove_TypeResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnResourceResolve")]
internal static void add_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnResourceResolve")]
internal static void remove_ResourceResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnAssemblyResolve")]
internal static void add_AssemblyResolve(ResolveEventHandler value);
    [CompilerGeneratedAttribute]
[DynamicDependencyAttribute("OnAssemblyResolve")]
internal static void remove_AssemblyResolve(ResolveEventHandler value);
    public static AssemblyLoadContext get_Default();
    public bool get_IsCollectible();
    [NullableContextAttribute("2")]
public string get_Name();
    public virtual string ToString();
    [IteratorStateMachineAttribute("System.Runtime.Loader.AssemblyLoadContext/<get_All>d__82")]
public static IEnumerable`1<AssemblyLoadContext> get_All();
    public static AssemblyName GetAssemblyName(string assemblyPath);
    protected virtual Assembly Load(AssemblyName assemblyName);
    public Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly LoadFromAssemblyPath(string assemblyPath);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly LoadFromStream(Stream assembly);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly LoadFromStream(Stream assembly, Stream assemblySymbols);
    protected IntPtr LoadUnmanagedDllFromPath(string unmanagedDllPath);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    public void Unload();
    internal static void OnProcessExit();
    private void VerifyIsAlive();
    [NullableContextAttribute("2")]
public static AssemblyLoadContext get_CurrentContextualReflectionContext();
    private static void SetCurrentContextualReflectionContext(AssemblyLoadContext value);
    public ContextualReflectionScope EnterContextualReflection();
    [NullableContextAttribute("2")]
public static ContextualReflectionScope EnterContextualReflection(Assembly activating);
    private static Assembly Resolve(IntPtr gchManagedAssemblyLoadContext, AssemblyName assemblyName);
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3000: Avoid accessing Assembly file path when publishing as a single file")]
private Assembly GetFirstResolvedAssemblyFromResolvingEvent(AssemblyName assemblyName);
    private static Assembly ValidateAssemblyNameWithSimpleName(Assembly assembly, string requestedSimpleName);
    private Assembly ResolveUsingLoad(AssemblyName assemblyName);
    private Assembly ResolveUsingEvent(AssemblyName assemblyName);
    private static void OnAssemblyLoad(RuntimeAssembly assembly);
    internal static RuntimeAssembly OnResourceResolve(RuntimeAssembly assembly, string resourceName);
    internal static RuntimeAssembly OnTypeResolve(RuntimeAssembly assembly, string typeName);
    private static RuntimeAssembly OnAssemblyResolve(RuntimeAssembly assembly, string assemblyFullName);
    internal static void InvokeAssemblyLoadEvent(Assembly assembly);
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3000: Avoid accessing Assembly file path when publishing as a single file")]
private static RuntimeAssembly InvokeResolveEvent(ResolveEventHandler eventHandler, RuntimeAssembly assembly, string name);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
[UnconditionalSuppressMessageAttribute("SingleFile", "IL3000: Avoid accessing Assembly file path when publishing as a single file")]
private Assembly ResolveSatelliteAssembly(AssemblyName assemblyName);
    internal IntPtr GetResolvedUnmanagedDll(Assembly assembly, string unmanagedDllName);
    [CompilerGeneratedAttribute]
internal static ReadOnlySpan`1<byte> <LoadFromStream>g__ReadAllBytes|89_0(Stream stream);
}
internal class System.Runtime.Loader.DefaultAssemblyLoadContext : AssemblyLoadContext {
    internal static AssemblyLoadContext s_loadContext;
    private static DefaultAssemblyLoadContext();
}
internal class System.Runtime.Loader.IndividualAssemblyLoadContext : AssemblyLoadContext {
    internal IndividualAssemblyLoadContext(string name);
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    private static ulong s_topOfMemory;
    private static long s_hiddenLastKnownFreeAddressSpace;
    private static long s_hiddenLastTimeCheckingAddressSpace;
    private static ulong s_GCSegmentSize;
    private static long s_failPointReservedMemory;
    private ulong _reservedMemory;
    private bool _mustSubtractReservation;
    private static long LastKnownFreeAddressSpace { get; }
    private static long LastTimeCheckingAddressSpace { get; }
    internal static ulong MemoryFailPointReservedMemory { get; }
    public MemoryFailPoint(int sizeInMegabytes);
    private static MemoryFailPoint();
    private static long get_LastKnownFreeAddressSpace();
    private static void AddToLastKnownFreeAddressSpace(long addend);
    private static long get_LastTimeCheckingAddressSpace();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Disposing();
    internal static long AddMemoryFailPointReservation(long size);
    internal static ulong get_MemoryFailPointReservedMemory();
    private static bool CheckForAvailableMemory(UInt64& availPageFile, UInt64& totalAddressSpaceFree);
    private static void CheckForFreeAddressSpace(ulong size, bool shouldThrow);
    private static void GrowPageFileIfNecessaryAndPossible(UIntPtr numBytes);
}
public static class System.Runtime.ProfileOptimization : object {
    [NullableContextAttribute("1")]
public static void SetProfileRoot(string directoryPath);
    [NullableContextAttribute("2")]
public static void StartProfile(string profile);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
    private object _wrappedObject;
    public ObjectHandle(object o);
    public object Unwrap();
}
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.DeserializationToken : ValueType {
    private DeserializationTracker _tracker;
    internal DeserializationToken(DeserializationTracker tracker);
    public sealed virtual void Dispose();
}
internal class System.Runtime.Serialization.DeserializationTracker : object {
    [CompilerGeneratedAttribute]
private bool <DeserializationInProgress>k__BackingField;
    internal bool DeserializationInProgress { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_DeserializationInProgress();
    [CompilerGeneratedAttribute]
internal void set_DeserializationInProgress(bool value);
}
[NullableContextAttribute("2")]
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual ulong ToUInt64(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual string ToString(object value);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.ISerializable {
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    private int _versionAdded;
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private StreamingContext <StreamingContext>k__BackingField;
    public StreamingContext StreamingContext { get; }
    [NullableContextAttribute("1")]
public void AddSerializedState(ISafeSerializationData serializedState);
    [CompilerGeneratedAttribute]
public StreamingContext get_StreamingContext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private string _name;
    private object _value;
    private Type _type;
    [NullableAttribute("2")]
public object Value { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    internal SerializationEntry(string entryName, object entryValue, Type entryType);
    [NullableContextAttribute("2")]
public object get_Value();
    public string get_Name();
    public Type get_ObjectType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Runtime.Serialization.SerializationException : SystemException {
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SerializationException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.SerializationInfo : object {
    private String[] _names;
    private Object[] _values;
    private Type[] _types;
    private int _count;
    private Dictionary`2<string, int> _nameToIndex;
    private IFormatterConverter _converter;
    private string _rootTypeName;
    private string _rootTypeAssemblyName;
    private Type _rootType;
    [CompilerGeneratedAttribute]
private bool <IsFullTypeNameSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAssemblyNameSetExplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AsyncLocal`1<bool> <AsyncDeserializationInProgress>k__BackingField;
    [ThreadStaticAttribute]
private static DeserializationTracker t_deserializationTracker;
    public string FullTypeName { get; public set; }
    public string AssemblyName { get; public set; }
    public bool IsFullTypeNameSetExplicit { get; private set; }
    public bool IsAssemblyNameSetExplicit { get; private set; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    internal static AsyncLocal`1<bool> AsyncDeserializationInProgress { get; }
    internal static bool DeserializationInProgress { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    private static SerializationInfo();
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsFullTypeNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsFullTypeNameSetExplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAssemblyNameSetExplicit();
    [CompilerGeneratedAttribute]
private void set_IsAssemblyNameSetExplicit(bool value);
    public void SetType(Type type);
    public int get_MemberCount();
    public Type get_ObjectType();
    public SerializationInfoEnumerator GetEnumerator();
    private void ExpandArrays();
    public void AddValue(string name, object value, Type type);
    public void AddValue(string name, object value);
    public void AddValue(string name, bool value);
    public void AddValue(string name, char value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, short value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    public void AddValue(string name, int value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    public void AddValue(string name, long value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public void AddValue(string name, float value);
    public void AddValue(string name, double value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, DateTime value);
    internal void AddValueInternal(string name, object value, Type type);
    internal void UpdateValue(string name, object value, Type type);
    private int FindElement(string name);
    private object GetElement(string name, Type& foundType);
    private object GetElementNoThrow(string name, Type& foundType);
    public object GetValue(string name, Type type);
    internal object GetValueNoThrow(string name, Type type);
    public bool GetBoolean(string name);
    public char GetChar(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public byte GetByte(string name);
    public short GetInt16(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    public int GetInt32(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public float GetSingle(string name);
    public double GetDouble(string name);
    public decimal GetDecimal(string name);
    public DateTime GetDateTime(string name);
    public string GetString(string name);
    [CompilerGeneratedAttribute]
internal static AsyncLocal`1<bool> get_AsyncDeserializationInProgress();
    private static DeserializationTracker GetThreadDeserializationTracker();
    internal static bool get_DeserializationInProgress();
    internal static void ThrowIfDeserializationInProgress(string switchSuffix, Int32& cachedValue);
    public static DeserializationToken StartDeserialization();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    private String[] _members;
    private Object[] _data;
    private Type[] _types;
    private int _numItems;
    private int _currItem;
    private bool _current;
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public SerializationEntry Current { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public Type ObjectType { get; }
    internal SerializationInfoEnumerator(String[] members, Object[] info, Type[] types, int numItems);
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public SerializationEntry get_Current();
    public sealed virtual void Reset();
    public string get_Name();
    [NullableContextAttribute("2")]
public object get_Value();
    public Type get_ObjectType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _additionalContext;
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
private StreamingContextStates _state;
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public StreamingContextStates State { get; }
    public object Context { get; }
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public StreamingContext(StreamingContextStates state);
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public StreamingContext(StreamingContextStates state, object additional);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public StreamingContextStates get_State();
    public object get_Context();
}
[FlagsAttribute]
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("96")]
public class System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public string Reason { get; }
    public TargetedPatchingOptOutAttribute(string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ComponentGuaranteesOptions <Guarantees>k__BackingField;
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    [CompilerGeneratedAttribute]
public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions Stable;
    public static ComponentGuaranteesOptions SideBySide;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Versioning.FrameworkName : object {
    private string _identifier;
    private Version _version;
    private string _profile;
    private string _fullName;
    public string Identifier { get; }
    public Version Version { get; }
    public string Profile { get; }
    public string FullName { get; }
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public FrameworkName(string frameworkName);
    public string get_Identifier();
    public Version get_Version();
    public string get_Profile();
    public string get_FullName();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool op_Equality(FrameworkName left, FrameworkName right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(FrameworkName left, FrameworkName right);
}
[AttributeUsageAttribute("108")]
internal class System.Runtime.Versioning.NonVersionableAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
public class System.Runtime.Versioning.ObsoletedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
public class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ResourceScope <ResourceScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceScope <ConsumptionScope>k__BackingField;
    public ResourceScope ResourceScope { get; }
    public ResourceScope ConsumptionScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    [CompilerGeneratedAttribute]
public ResourceScope get_ResourceScope();
    [CompilerGeneratedAttribute]
public ResourceScope get_ConsumptionScope();
}
[AttributeUsageAttribute("480")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    [CompilerGeneratedAttribute]
private ResourceScope <ResourceExposureLevel>k__BackingField;
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    [CompilerGeneratedAttribute]
public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope None;
    public static ResourceScope Machine;
    public static ResourceScope Process;
    public static ResourceScope AppDomain;
    public static ResourceScope Library;
    public static ResourceScope Private;
    public static ResourceScope Assembly;
}
[AttributeUsageAttribute("2047")]
public class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
public class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public SupportedOSPlatformGuardAttribute(string platformName);
}
[FlagsAttribute]
internal enum System.Runtime.Versioning.SxSRequirements : Enum {
    public int value__;
    public static SxSRequirements None;
    public static SxSRequirements AppDomainID;
    public static SxSRequirements ProcessID;
    public static SxSRequirements CLRInstanceID;
    public static SxSRequirements AssemblyName;
    public static SxSRequirements TypeName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    private string _frameworkName;
    private string _frameworkDisplayName;
    public string FrameworkName { get; }
    [NullableAttribute("2")]
public string FrameworkDisplayName { get; public set; }
    public TargetFrameworkAttribute(string frameworkName);
    public string get_FrameworkName();
    [NullableContextAttribute("2")]
public string get_FrameworkDisplayName();
    [NullableContextAttribute("2")]
public void set_FrameworkDisplayName(string value);
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public TargetPlatformAttribute(string platformName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
public class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
public string Message { get; }
    public UnsupportedOSPlatformAttribute(string platformName);
    public UnsupportedOSPlatformAttribute(string platformName, string message);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Message();
}
[AttributeUsageAttribute("448")]
public class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public UnsupportedOSPlatformGuardAttribute(string platformName);
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    [NullableContextAttribute("1")]
public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    [NullableContextAttribute("2")]
public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
    private static SxSRequirements GetRequirements(ResourceScope consumeAsScope, ResourceScope calleeScope);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
    internal IntPtr args;
}
public class System.RuntimeFieldHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeFieldHandle(IntPtr v);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public IntPtr get_Value();
    internal bool IsNullHandle();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeFieldHandle handle);
    public virtual int GetHashCode();
    public static RuntimeFieldHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(RuntimeFieldHandle value);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    internal static object GetValueDirect(RuntimeFieldInfo field, RuntimeType fieldType, Void* pTypedRef, RuntimeType contextType);
    internal static void SetValueDirect(RuntimeFieldInfo field, RuntimeType fieldType, Void* pTypedRef, object value, RuntimeType contextType);
}
public class System.RuntimeMethodHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeMethodHandle(IntPtr v);
    public IntPtr get_Value();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static IntPtr GetFunctionPointer(IntPtr m);
    public IntPtr GetFunctionPointer();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeMethodHandle handle);
    public virtual int GetHashCode();
    public static RuntimeMethodHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(RuntimeMethodHandle value);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    internal static string ConstructInstantiation(RuntimeMethodInfo method);
    internal bool IsNullHandle();
    private static void ReboxFromNullable(object src, ObjectHandleOnStack res);
    private static void ReboxToNullable(object src, QCallTypeHandle destNullableType, ObjectHandleOnStack res);
    internal static object ReboxFromNullable(object src);
    internal static object ReboxToNullable(object src, RuntimeType destNullableType);
}
internal class System.RuntimeType : TypeInfo {
    internal static RuntimeType ValueType;
    internal static RuntimeType EnumType;
    private static RuntimeType ObjectType;
    private static RuntimeType StringType;
    private TypeCache cache;
    public bool IsEnum { get; }
    internal bool IsActualEnum { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    internal TypeCache Cache { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public bool ContainsGenericParameters { get; }
    public Guid GUID { get; }
    public MethodBase DeclaringMethod { get; }
    public string AssemblyQualifiedName { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    internal bool IsNullableOfT { get; }
    public bool IsSZArray { get; }
    public bool IsFunctionPointer { get; }
    public bool IsUnmanagedFunctionPointer { get; }
    internal bool IsUserType { get; }
    public Assembly Assembly { get; }
    public Type BaseType { get; }
    public bool IsByRefLike { get; }
    public bool IsGenericParameter { get; }
    public bool IsTypeDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    private static RuntimeType();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
internal static RuntimeType GetType(string typeName, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    private static void SplitName(string fullname, String& name, String& ns);
    internal static BindingFlags FilterPreCalculate(bool isPublic, bool isInherited, bool isStatic);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, bool allowPrefixLookup, Boolean& prefixLookup, Boolean& ignoreCase, MemberListType& listType);
    private static void FilterHelper(BindingFlags bindingFlags, String& name, Boolean& ignoreCase, MemberListType& listType);
    private static bool FilterApplyPrefixLookup(MemberInfo memberInfo, string name, bool ignoreCase);
    private static bool FilterApplyBase(MemberInfo memberInfo, BindingFlags bindingFlags, bool isPublic, bool isNonProtectedInternal, bool isStatic, string name, bool prefixLookup);
    private static bool FilterApplyType(Type type, BindingFlags bindingFlags, string name, bool prefixLookup, string ns);
    private static bool FilterApplyMethodInfo(RuntimeMethodInfo method, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyConstructorInfo(RuntimeConstructorInfo constructor, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private static bool FilterApplyMethodBase(MethodBase methodBase, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
    private ListBuilder`1<MethodInfo> GetMethodCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, int genericParamCount, bool allowPrefixLookup);
    private ListBuilder`1<ConstructorInfo> GetConstructorCandidates(string name, BindingFlags bindingAttr, CallingConventions callConv, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<PropertyInfo> GetPropertyCandidates(string name, BindingFlags bindingAttr, Type[] types, bool allowPrefixLookup);
    private ListBuilder`1<EventInfo> GetEventCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<FieldInfo> GetFieldCandidates(string name, BindingFlags bindingAttr, bool allowPrefixLookup);
    private ListBuilder`1<Type> GetNestedTypeCandidates(string fullname, BindingFlags bindingAttr, bool allowPrefixLookup);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, int genericParamCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConv, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2063:UnrecognizedReflectionPattern")]
[DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string fullname, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string fullname, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member);
    private static MethodInfo GetMethodWithSameMetadataDefinitionAs(RuntimeType runtimeType, MemberInfo methodInfo);
    private static ConstructorInfo GetConstructorWithSameMetadataDefinitionAs(RuntimeType runtimeType, MemberInfo constructorInfo);
    private static PropertyInfo GetPropertyWithSameMetadataDefinitionAs(RuntimeType runtimeType, MemberInfo propertyInfo);
    private static FieldInfo GetFieldWithSameMetadataDefinitionAs(RuntimeType runtimeType, MemberInfo fieldInfo);
    private static EventInfo GetEventWithSameMetadataDefinitionAs(RuntimeType runtimeType, MemberInfo eventInfo);
    private static Type GetNestedTypeWithSameMetadataDefinitionAs(RuntimeType runtimeType, MemberInfo nestedType);
    public virtual bool IsEquivalentTo(Type other);
    internal CorElementType GetCorElementType();
    internal TypeAttributes GetAttributes();
    internal bool IsDelegate();
    protected virtual bool IsValueTypeImpl();
    public virtual bool get_IsEnum();
    internal bool get_IsActualEnum();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual Type GetGenericTypeDefinition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    internal RuntimeType[] GetGenericArgumentsInternal();
    public virtual Type[] GetGenericArguments();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] instantiation);
    public virtual int get_GenericParameterPosition();
    public static bool op_Equality(RuntimeType left, RuntimeType right);
    public static bool op_Inequality(RuntimeType left, RuntimeType right);
    private void CreateInstanceCheckThis();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2082:UnrecognizedReflectionPattern")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
internal object CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object CreateInstanceDefaultCtor(bool publicOnly, bool wrapExceptions);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
internal object CreateInstanceOfT();
    internal TypeCache get_Cache();
    private void UpdateCached(TypeCacheEntries entry);
    private void CacheFlag(TypeCacheEntries flag, bool value);
    internal RuntimeConstructorInfo GetDefaultConstructor();
    private static MemberInfo GetCorrespondingInflatedMethod(QCallTypeHandle type, MemberInfo generic);
    internal virtual MethodInfo GetMethod(MethodInfo fromNoninstanciated);
    internal virtual ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
internal virtual FieldInfo GetField(FieldInfo fromNoninstanciated);
    private string GetDefaultMemberName();
    private object CreateInstanceMono(bool nonPublic, bool wrapExceptions);
    private CheckValueStatus TryChangeTypeSpecial(Object& value);
    private static object IsConvertibleToPrimitiveType(object value, Type targetType);
    private static void make_array_type(QCallTypeHandle type, int rank, ObjectHandleOnStack res);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    private static void make_byref_type(QCallTypeHandle type, ObjectHandleOnStack res);
    public virtual Type MakeByRefType();
    private static void make_pointer_type(QCallTypeHandle type, ObjectHandleOnStack res);
    public virtual Type MakePointerType();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type[] GetGenericParameterConstraints();
    internal static object CreateInstanceForAnotherGenericParameter(Type genericType, RuntimeType genericArgument, RuntimeType genericArgument2);
    private static void MakeGenericType(Type gt, Type[] types, ObjectHandleOnStack res);
    internal static IntPtr GetMethodsByName_native(QCallTypeHandle type, IntPtr namePtr, BindingFlags bindingAttr, MemberListType listType);
    internal RuntimeMethodInfo[] GetMethodsByName(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    private static IntPtr GetPropertiesByName_native(QCallTypeHandle type, IntPtr name, BindingFlags bindingAttr, MemberListType listType);
    private static IntPtr GetConstructors_native(QCallTypeHandle type, BindingFlags bindingAttr);
    private RuntimeConstructorInfo[] GetConstructors_internal(BindingFlags bindingAttr, RuntimeType reflectedType);
    private RuntimePropertyInfo[] GetPropertiesByName(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    private static void GetInterfaceMapData(QCallTypeHandle t, QCallTypeHandle iface, MethodInfo[]& targets, MethodInfo[]& methods);
    public virtual Guid get_GUID();
    private static void GetPacking(QCallTypeHandle type, Int32& packing, Int32& size);
    internal void GetPacking(Int32& packing, Int32& size);
    public virtual string ToString();
    private static object CreateInstanceInternal(QCallTypeHandle type);
    private static void AllocateValueType(QCallTypeHandle type, object value, ObjectHandleOnStack res);
    internal static object AllocateValueType(RuntimeType type, object value);
    private static void GetDeclaringMethod(QCallTypeHandle type, ObjectHandleOnStack res);
    public virtual MethodBase get_DeclaringMethod();
    internal static void getFullName(QCallTypeHandle type, ObjectHandleOnStack res, bool full_name, bool assembly_qualified);
    private static void GetGenericArgumentsInternal(QCallTypeHandle type, ObjectHandleOnStack res, bool runtimeArray);
    internal string getFullName(bool full_name, bool assembly_qualified);
    private GenericParameterAttributes GetGenericParameterAttributes();
    private static int GetGenericParameterPosition(QCallTypeHandle type);
    private static IntPtr GetEvents_native(QCallTypeHandle type, IntPtr name, MemberListType listType);
    private static IntPtr GetFields_native(QCallTypeHandle type, IntPtr name, BindingFlags bindingAttr, MemberListType listType);
    private RuntimeFieldInfo[] GetFields_internal(string name, BindingFlags bindingAttr, MemberListType listType, RuntimeType reflectedType);
    private RuntimeEventInfo[] GetEvents_internal(string name, MemberListType listType, RuntimeType reflectedType);
    private static void GetInterfaces(QCallTypeHandle type, ObjectHandleOnStack res);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    private static IntPtr GetNestedTypes_native(QCallTypeHandle type, IntPtr name, BindingFlags bindingAttr, MemberListType listType);
    private RuntimeType[] GetNestedTypes_internal(string displayName, BindingFlags bindingAttr, MemberListType listType);
    public virtual string get_AssemblyQualifiedName();
    private static void GetDeclaringType(QCallTypeHandle type, ObjectHandleOnStack res);
    public virtual Type get_DeclaringType();
    private static void GetName(QCallTypeHandle type, ObjectHandleOnStack res);
    public virtual string get_Name();
    private static void GetNamespace(QCallTypeHandle type, ObjectHandleOnStack res);
    public virtual string get_Namespace();
    public virtual string get_FullName();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    internal bool get_IsNullableOfT();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsFunctionPointer();
    internal static bool IsUnmanagedFunctionPointerInternal(QCallTypeHandle type);
    internal static bool IsUnmanagedFunctionPointerInternal(RuntimeType type);
    public virtual bool get_IsUnmanagedFunctionPointer();
    public virtual Type[] GetFunctionPointerParameterTypes();
    public virtual Type GetFunctionPointerReturnType();
    internal static IntPtr FunctionPointerReturnAndParameterTypes(QCallTypeHandle type);
    internal static Type[] FunctionPointerReturnAndParameterTypes(RuntimeType type, bool returnType);
    internal static Type[] GetFunctionPointerTypeModifiers(QCallTypeHandle type, int position, bool optional);
    internal static Type[] GetFunctionPointerTypeModifiers(RuntimeType type, int position, bool optional);
    public Type[] GetCustomModifiersFromFunctionPointer(int position, bool optional);
    internal static byte GetCallingConventionFromFunctionPointerInternal(QCallTypeHandle type);
    internal static byte GetCallingConventionFromFunctionPointerInternal(RuntimeType type);
    public SignatureCallingConvention GetCallingConventionFromFunctionPointer();
    public virtual Type[] GetFunctionPointerCallingConventions();
    internal virtual bool get_IsUserType();
    public virtual bool IsSubclassOf(Type type);
    internal StructLayoutAttribute GetStructLayoutAttribute();
    public virtual Assembly get_Assembly();
    public virtual Type get_BaseType();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    [IntrinsicAttribute]
public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public sealed virtual object Clone();
    public virtual bool Equals(object obj);
    public virtual int GetArrayRank();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [DynamicallyAccessedMembersAttribute("2731")]
public virtual MemberInfo[] GetDefaultMembers();
    public virtual Type GetElementType();
    public virtual string GetEnumName(object value);
    private static void ThrowMustBeEnum();
    public virtual String[] GetEnumNames();
    [RequiresDynamicCodeAttribute("It might not be possible to create an array of the enum type at runtime. Use Enum.GetValues<T> or the GetEnumValuesAsUnderlyingType method instead.")]
public virtual Array GetEnumValues();
    public virtual Array GetEnumValuesAsUnderlyingType();
    public virtual Type GetEnumUnderlyingType();
    public virtual int GetHashCode();
    internal RuntimeModule GetRuntimeModule();
    protected virtual TypeCode GetTypeCodeImpl();
    protected virtual bool HasElementTypeImpl();
    protected virtual bool IsArrayImpl();
    protected virtual bool IsContextfulImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsEnumDefined(object value);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public virtual bool IsAssignableFrom(Type c);
    [DebuggerStepThroughAttribute]
[DebuggerHiddenAttribute]
[DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags bindingFlags, Binder binder, object target, Object[] providedArgs, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParams);
    private RuntimeType GetBaseType();
    private static void ThrowIfTypeNeverValidGenericArgument(RuntimeType type);
    internal static void SanityCheckGenericArguments(RuntimeType[] genericArguments, RuntimeType[] genericParameters);
    internal static bool TryGetByRefElementType(RuntimeType type, RuntimeType& elementType);
    internal bool CheckValue(Object& value);
    internal bool CheckValue(Object& value, Binder binder, CultureInfo culture, BindingFlags invokeAttr);
    private CheckValueStatus TryChangeType(Object& value, Boolean& copyBack);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.RuntimeTypeHandle : ValueType {
    private IntPtr value;
    public IntPtr Value { get; }
    internal RuntimeTypeHandle(IntPtr val);
    internal RuntimeTypeHandle(RuntimeType type);
    public IntPtr get_Value();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeTypeHandle handle);
    public virtual int GetHashCode();
    public static RuntimeTypeHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(RuntimeTypeHandle value);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    internal static TypeAttributes GetAttributes(QCallTypeHandle type);
    internal static TypeAttributes GetAttributes(RuntimeType type);
    public ModuleHandle GetModuleHandle();
    private static int GetMetadataToken(QCallTypeHandle type);
    internal static int GetToken(RuntimeType type);
    private static void GetGenericTypeDefinition_impl(QCallTypeHandle type, ObjectHandleOnStack res);
    internal static Type GetGenericTypeDefinition(RuntimeType type);
    internal static bool IsPrimitive(RuntimeType type);
    internal static bool IsByRef(RuntimeType type);
    internal static bool IsPointer(RuntimeType type);
    internal static bool IsFunctionPointer(RuntimeType type);
    internal static bool IsArray(RuntimeType type);
    internal static bool IsSzArray(RuntimeType type);
    internal static bool IsValueType(RuntimeType type);
    internal static bool HasElementType(RuntimeType type);
    internal static CorElementType GetCorElementType(QCallTypeHandle type);
    internal static bool HasInstantiation(QCallTypeHandle type);
    internal static bool IsComObject(QCallTypeHandle type);
    internal static bool IsInstanceOfType(QCallTypeHandle type, object o);
    internal static bool IsInstanceOfType(RuntimeType type, object o);
    internal static bool HasReferences(QCallTypeHandle type);
    internal static bool HasReferences(RuntimeType type);
    internal static CorElementType GetCorElementType(RuntimeType type);
    internal static bool HasInstantiation(RuntimeType type);
    internal static bool IsComObject(RuntimeType type, bool isGenericCOM);
    internal static bool IsEquivalentTo(RuntimeType rtType1, RuntimeType rtType2);
    internal static bool IsInterface(RuntimeType type);
    internal static int GetArrayRank(QCallTypeHandle type);
    internal static void GetAssembly(QCallTypeHandle type, ObjectHandleOnStack res);
    internal static void GetElementType(QCallTypeHandle type, ObjectHandleOnStack res);
    internal static void GetModule(QCallTypeHandle type, ObjectHandleOnStack res);
    internal static void GetBaseType(QCallTypeHandle type, ObjectHandleOnStack res);
    internal static int GetArrayRank(RuntimeType type);
    internal static RuntimeAssembly GetAssembly(RuntimeType type);
    internal static RuntimeModule GetModule(RuntimeType type);
    internal static RuntimeType GetElementType(RuntimeType type);
    internal static RuntimeType GetBaseType(RuntimeType type);
    internal static bool CanCastTo(RuntimeType type, RuntimeType target);
    internal static bool IsGenericVariable(RuntimeType type);
    private static bool type_is_assignable_from(QCallTypeHandle a, QCallTypeHandle b);
    internal static bool IsGenericTypeDefinition(QCallTypeHandle type);
    internal static IntPtr GetGenericParameterInfo(QCallTypeHandle type);
    internal static bool IsGenericTypeDefinition(RuntimeType type);
    internal static IntPtr GetGenericParameterInfo(RuntimeType type);
    internal static bool IsSubclassOf(RuntimeType childType, RuntimeType baseType);
    internal static bool is_subclass_of(QCallTypeHandle childType, QCallTypeHandle baseType);
    [DynamicDependencyAttribute("#ctor()", "System.Runtime.CompilerServices.IsByRefLikeAttribute")]
internal static bool IsByRefLike(QCallTypeHandle type);
    internal static bool IsByRefLike(RuntimeType type);
    internal static bool IsTypeDefinition(RuntimeType type);
    private static void internal_from_name(IntPtr name, StackCrawlMark& stackMark, ObjectHandleOnStack res, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
internal static RuntimeType GetTypeByName(string typeName, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    internal static IntPtr[] CopyRuntimeTypeHandles(RuntimeTypeHandle[] inHandles, Int32& length);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.SByte : ValueType {
    private sbyte m_value;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    private static sbyte System.Numerics.IAdditiveIdentity<System.SByte,System.SByte>.AdditiveIdentity { get; }
    private static sbyte System.Numerics.IBinaryNumber<System.SByte>.AllBitsSet { get; }
    private static sbyte System.Numerics.IMinMaxValue<System.SByte>.MinValue { get; }
    private static sbyte System.Numerics.IMinMaxValue<System.SByte>.MaxValue { get; }
    private static sbyte System.Numerics.IMultiplicativeIdentity<System.SByte,System.SByte>.MultiplicativeIdentity { get; }
    private static sbyte System.Numerics.INumberBase<System.SByte>.One { get; }
    private static int System.Numerics.INumberBase<System.SByte>.Radix { get; }
    private static sbyte System.Numerics.INumberBase<System.SByte>.Zero { get; }
    private static sbyte System.Numerics.ISignedNumber<System.SByte>.NegativeOne { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.SByte>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.SByte>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.SByte>.MaxHexDigitCount { get; }
    private static sbyte System.IBinaryIntegerParseAndFormatInfo<System.SByte>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.SByte>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static sbyte Parse(string s);
    [NullableContextAttribute("1")]
public static sbyte Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override sbyte Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, SByte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, SByte& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override sbyte System.Numerics.IAdditionOperators<System.SByte,System.SByte,System.SByte>.op_Addition(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IAdditionOperators<System.SByte,System.SByte,System.SByte>.op_CheckedAddition(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IAdditiveIdentity<System.SByte,System.SByte>.get_AdditiveIdentity();
    public static override ValueTuple`2<sbyte, sbyte> DivRem(sbyte left, sbyte right);
    public static override sbyte LeadingZeroCount(sbyte value);
    public static override sbyte PopCount(sbyte value);
    public static override sbyte RotateLeft(sbyte value, int rotateAmount);
    public static override sbyte RotateRight(sbyte value, int rotateAmount);
    public static override sbyte TrailingZeroCount(sbyte value);
    private static override bool System.Numerics.IBinaryInteger<System.SByte>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, SByte& value);
    private static override bool System.Numerics.IBinaryInteger<System.SByte>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, SByte& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.SByte>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.SByte>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.SByte>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.SByte>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override sbyte System.Numerics.IBinaryNumber<System.SByte>.get_AllBitsSet();
    public static override bool IsPow2(sbyte value);
    public static override sbyte Log2(sbyte value);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_BitwiseAnd(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_BitwiseOr(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_ExclusiveOr(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_OnesComplement(sbyte value);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_LessThan(sbyte left, sbyte right);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_LessThanOrEqual(sbyte left, sbyte right);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_GreaterThan(sbyte left, sbyte right);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_GreaterThanOrEqual(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IDecrementOperators<System.SByte>.op_Decrement(sbyte value);
    private static override sbyte System.Numerics.IDecrementOperators<System.SByte>.op_CheckedDecrement(sbyte value);
    private static override sbyte System.Numerics.IDivisionOperators<System.SByte,System.SByte,System.SByte>.op_Division(sbyte left, sbyte right);
    private static override bool System.Numerics.IEqualityOperators<System.SByte,System.SByte,System.Boolean>.op_Equality(sbyte left, sbyte right);
    private static override bool System.Numerics.IEqualityOperators<System.SByte,System.SByte,System.Boolean>.op_Inequality(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IIncrementOperators<System.SByte>.op_Increment(sbyte value);
    private static override sbyte System.Numerics.IIncrementOperators<System.SByte>.op_CheckedIncrement(sbyte value);
    private static override sbyte System.Numerics.IMinMaxValue<System.SByte>.get_MinValue();
    private static override sbyte System.Numerics.IMinMaxValue<System.SByte>.get_MaxValue();
    private static override sbyte System.Numerics.IModulusOperators<System.SByte,System.SByte,System.SByte>.op_Modulus(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IMultiplicativeIdentity<System.SByte,System.SByte>.get_MultiplicativeIdentity();
    private static override sbyte System.Numerics.IMultiplyOperators<System.SByte,System.SByte,System.SByte>.op_Multiply(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IMultiplyOperators<System.SByte,System.SByte,System.SByte>.op_CheckedMultiply(sbyte left, sbyte right);
    public static override sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static override sbyte CopySign(sbyte value, sbyte sign);
    public static override sbyte Max(sbyte x, sbyte y);
    private static override sbyte System.Numerics.INumber<System.SByte>.MaxNumber(sbyte x, sbyte y);
    public static override sbyte Min(sbyte x, sbyte y);
    private static override sbyte System.Numerics.INumber<System.SByte>.MinNumber(sbyte x, sbyte y);
    public static override int Sign(sbyte value);
    private static override sbyte System.Numerics.INumberBase<System.SByte>.get_One();
    private static override int System.Numerics.INumberBase<System.SByte>.get_Radix();
    private static override sbyte System.Numerics.INumberBase<System.SByte>.get_Zero();
    public static override sbyte Abs(sbyte value);
    [NullableContextAttribute("1")]
public static override sbyte CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override sbyte CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override sbyte CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsCanonical(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsComplexNumber(sbyte value);
    public static override bool IsEvenInteger(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsFinite(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsImaginaryNumber(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsInfinity(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsNaN(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsInteger(sbyte value);
    public static override bool IsNegative(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsNegativeInfinity(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsNormal(sbyte value);
    public static override bool IsOddInteger(sbyte value);
    public static override bool IsPositive(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsPositiveInfinity(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsRealNumber(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsSubnormal(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsZero(sbyte value);
    public static override sbyte MaxMagnitude(sbyte x, sbyte y);
    private static override sbyte System.Numerics.INumberBase<System.SByte>.MaxMagnitudeNumber(sbyte x, sbyte y);
    public static override sbyte MinMagnitude(sbyte x, sbyte y);
    private static override sbyte System.Numerics.INumberBase<System.SByte>.MinMagnitudeNumber(sbyte x, sbyte y);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertFromChecked(TOther value, SByte& result);
    private static bool TryConvertFromChecked(TOther value, SByte& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertFromSaturating(TOther value, SByte& result);
    private static bool TryConvertFromSaturating(TOther value, SByte& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertFromTruncating(TOther value, SByte& result);
    private static bool TryConvertFromTruncating(TOther value, SByte& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertToChecked(sbyte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertToSaturating(sbyte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertToTruncating(sbyte value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, SByte& result);
    private static override sbyte System.Numerics.IShiftOperators<System.SByte,System.Int32,System.SByte>.op_LeftShift(sbyte value, int shiftAmount);
    private static override sbyte System.Numerics.IShiftOperators<System.SByte,System.Int32,System.SByte>.op_RightShift(sbyte value, int shiftAmount);
    private static override sbyte System.Numerics.IShiftOperators<System.SByte,System.Int32,System.SByte>.op_UnsignedRightShift(sbyte value, int shiftAmount);
    private static override sbyte System.Numerics.ISignedNumber<System.SByte>.get_NegativeOne();
    public static override sbyte Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, SByte& result);
    private static override sbyte System.Numerics.ISubtractionOperators<System.SByte,System.SByte,System.SByte>.op_Subtraction(sbyte left, sbyte right);
    private static override sbyte System.Numerics.ISubtractionOperators<System.SByte,System.SByte,System.SByte>.op_CheckedSubtraction(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IUnaryNegationOperators<System.SByte,System.SByte>.op_UnaryNegation(sbyte value);
    private static override sbyte System.Numerics.IUnaryNegationOperators<System.SByte,System.SByte>.op_CheckedUnaryNegation(sbyte value);
    private static override sbyte System.Numerics.IUnaryPlusOperators<System.SByte,System.SByte>.op_UnaryPlus(sbyte value);
    public static override sbyte Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, SByte& result);
    public static override sbyte Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, SByte& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.SByte>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.SByte>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.SByte>.get_MaxHexDigitCount();
    private static override sbyte System.IBinaryIntegerParseAndFormatInfo<System.SByte>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.SByte>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.SByte>.IsGreaterThanAsUnsigned(sbyte left, sbyte right);
    private static override sbyte System.IBinaryIntegerParseAndFormatInfo<System.SByte>.MultiplyBy10(sbyte value);
    private static override sbyte System.IBinaryIntegerParseAndFormatInfo<System.SByte>.MultiplyBy16(sbyte value);
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    [CompilerGeneratedAttribute]
private PartialTrustVisibilityLevel <PartialTrustVisibilityLevel>k__BackingField;
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    [CompilerGeneratedAttribute]
public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    [CompilerGeneratedAttribute]
public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    [NullableContextAttribute("2")]
public CryptographicException(string message);
    [NullableContextAttribute("2")]
public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected CryptographicException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public interface System.Security.IPermission {
    [NullableContextAttribute("1")]
public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
[NullableContextAttribute("1")]
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    [NullableContextAttribute("2")]
public abstract virtual SecurityElement ToXml();
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public interface System.Security.IStackWalk {
    public abstract virtual void Assert();
    public abstract virtual void Demand();
    public abstract virtual void Deny();
    public abstract virtual void PermitOnly();
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public enum System.Security.Permissions.PermissionState : Enum {
    public int value__;
    public static PermissionState None;
    public static PermissionState Unrestricted;
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Assert;
    public static SecurityAction Demand;
    public static SecurityAction Deny;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction LinkDemand;
    public static SecurityAction PermitOnly;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Unrestricted>k__BackingField;
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public SecurityAction get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(SecurityAction value);
    [CompilerGeneratedAttribute]
public bool get_Unrestricted();
    [CompilerGeneratedAttribute]
public void set_Unrestricted(bool value);
    [NullableContextAttribute("2")]
public abstract virtual IPermission CreatePermission();
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    [CompilerGeneratedAttribute]
private bool <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BindingRedirects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlAppDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlDomainPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlEvidence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Execution>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityPermissionFlag <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Infrastructure>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemotingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializationFormatter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipVerification>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnmanagedCode>k__BackingField;
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    [CompilerGeneratedAttribute]
public bool get_Assertion();
    [CompilerGeneratedAttribute]
public void set_Assertion(bool value);
    [CompilerGeneratedAttribute]
public bool get_BindingRedirects();
    [CompilerGeneratedAttribute]
public void set_BindingRedirects(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlAppDomain();
    [CompilerGeneratedAttribute]
public void set_ControlAppDomain(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlDomainPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlDomainPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlEvidence();
    [CompilerGeneratedAttribute]
public void set_ControlEvidence(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPolicy();
    [CompilerGeneratedAttribute]
public void set_ControlPolicy(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlPrincipal();
    [CompilerGeneratedAttribute]
public void set_ControlPrincipal(bool value);
    [CompilerGeneratedAttribute]
public bool get_ControlThread();
    [CompilerGeneratedAttribute]
public void set_ControlThread(bool value);
    [CompilerGeneratedAttribute]
public bool get_Execution();
    [CompilerGeneratedAttribute]
public void set_Execution(bool value);
    [CompilerGeneratedAttribute]
public SecurityPermissionFlag get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(SecurityPermissionFlag value);
    [CompilerGeneratedAttribute]
public bool get_Infrastructure();
    [CompilerGeneratedAttribute]
public void set_Infrastructure(bool value);
    [CompilerGeneratedAttribute]
public bool get_RemotingConfiguration();
    [CompilerGeneratedAttribute]
public void set_RemotingConfiguration(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializationFormatter();
    [CompilerGeneratedAttribute]
public void set_SerializationFormatter(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipVerification();
    [CompilerGeneratedAttribute]
public void set_SkipVerification(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnmanagedCode();
    [CompilerGeneratedAttribute]
public void set_UnmanagedCode(bool value);
    [NullableContextAttribute("2")]
public virtual IPermission CreatePermission();
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag AllFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag UnmanagedCode;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public class System.Security.PermissionSet : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("1")]
public object SyncRoot { get; }
    public PermissionSet(PermissionState state);
    public PermissionSet(PermissionSet permSet);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    [NullableContextAttribute("1")]
public virtual object get_SyncRoot();
    public IPermission AddPermission(IPermission perm);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    public sealed virtual void Assert();
    public bool ContainsNonCodeAccessPermissions();
    [NullableContextAttribute("1")]
[ObsoleteAttribute]
public static Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat);
    [NullableContextAttribute("1")]
public virtual PermissionSet Copy();
    [NullableContextAttribute("1")]
public virtual void CopyTo(Array array, int index);
    public sealed virtual void Demand();
    [ObsoleteAttribute]
public sealed virtual void Deny();
    public virtual bool Equals(object o);
    [NullableContextAttribute("1")]
public virtual void FromXml(SecurityElement et);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator GetEnumerator();
    [NullableContextAttribute("1")]
protected virtual IEnumerator GetEnumeratorImpl();
    public virtual int GetHashCode();
    public IPermission GetPermission(Type permClass);
    protected virtual IPermission GetPermissionImpl(Type permClass);
    public PermissionSet Intersect(PermissionSet other);
    public bool IsEmpty();
    public bool IsSubsetOf(PermissionSet target);
    public bool IsUnrestricted();
    public sealed virtual void PermitOnly();
    public IPermission RemovePermission(Type permClass);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    public static void RevertAssert();
    public IPermission SetPermission(IPermission perm);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual SecurityElement ToXml();
    public PermissionSet Union(PermissionSet other);
}
[NullableContextAttribute("2")]
public interface System.Security.Principal.IIdentity {
    public string Name { get; }
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_IsAuthenticated();
}
[NullableContextAttribute("2")]
public interface System.Security.Principal.IPrincipal {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
    [NullableContextAttribute("1")]
public abstract virtual bool IsInRole(string role);
}
public enum System.Security.Principal.PrincipalPolicy : Enum {
    public int value__;
    public static PrincipalPolicy UnauthenticatedPrincipal;
    public static PrincipalPolicy NoPrincipal;
    public static PrincipalPolicy WindowsPrincipal;
}
public enum System.Security.Principal.TokenImpersonationLevel : Enum {
    public int value__;
    public static TokenImpersonationLevel None;
    public static TokenImpersonationLevel Anonymous;
    public static TokenImpersonationLevel Identification;
    public static TokenImpersonationLevel Impersonation;
    public static TokenImpersonationLevel Delegation;
}
public class System.Security.SecureString : object {
    private object _methodLock;
    private UnmanagedBuffer _buffer;
    private int _decryptedLength;
    private bool _encrypted;
    private bool _readOnly;
    public int Length { get; }
    [CLSCompliantAttribute("False")]
public SecureString(Char* value, int length);
    private SecureString(SecureString str);
    private void Initialize(ReadOnlySpan`1<char> value);
    public int get_Length();
    private void EnsureCapacity(int capacity);
    public void AppendChar(char c);
    public void Clear();
    [NullableContextAttribute("1")]
public SecureString Copy();
    public sealed virtual void Dispose();
    public void InsertAt(int index, char c);
    public bool IsReadOnly();
    public void MakeReadOnly();
    public void RemoveAt(int index);
    public void SetAt(int index, char c);
    private Span`1<char> AcquireSpan(SafeBuffer& bufferToRelease);
    private void EnsureNotReadOnly();
    private void EnsureNotDisposed();
    internal IntPtr MarshalToBSTR();
    internal IntPtr MarshalToString(bool globalAlloc, bool unicode);
    private static int GetAlignedByteSize(int length);
    private void ProtectMemory();
    private void UnprotectMemory();
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private SecurityCriticalScope <Scope>k__BackingField;
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    [CompilerGeneratedAttribute]
public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.SecurityElement : object {
    internal string _tag;
    internal string _text;
    private ArrayList _children;
    internal ArrayList _attributes;
    private static String[] s_escapeStringPairs;
    [NullableAttribute("1")]
public string Tag { get; public set; }
    public Hashtable Attributes { get; public set; }
    public string Text { get; public set; }
    public ArrayList Children { get; public set; }
    [NullableContextAttribute("1")]
public SecurityElement(string tag);
    [NullableContextAttribute("1")]
public SecurityElement(string tag, string text);
    private static SecurityElement();
    [NullableContextAttribute("1")]
public string get_Tag();
    [NullableContextAttribute("1")]
public void set_Tag(string value);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public string get_Text();
    public void set_Text(string value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    internal void AddAttributeSafe(string name, string value);
    [NullableContextAttribute("1")]
public void AddAttribute(string name, string value);
    [NullableContextAttribute("1")]
public void AddChild(SecurityElement child);
    public bool Equal(SecurityElement other);
    [NullableContextAttribute("1")]
public SecurityElement Copy();
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    private static string GetEscapeSequence(char c);
    public static string Escape(string str);
    private static string GetUnescapeSequence(string str, int index, Int32& newIndex);
    private static string Unescape(string str);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private void ToString(object obj, Action`2<object, string> write);
    [NullableContextAttribute("1")]
public string Attribute(string name);
    [NullableContextAttribute("1")]
public SecurityElement SearchForChildByTag(string tag);
    [NullableContextAttribute("1")]
public string SearchForTextOfTag(string tag);
    [NullableContextAttribute("1")]
public static SecurityElement FromString(string xml);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.SecurityException : SystemException {
    [CompilerGeneratedAttribute]
private object <Demanded>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DenySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyName <FailedAssemblyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GrantedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PermissionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PermissionType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <PermitOnlySetInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefusedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SecurityException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_Demanded();
    [CompilerGeneratedAttribute]
public void set_Demanded(object value);
    [CompilerGeneratedAttribute]
public object get_DenySetInstance();
    [CompilerGeneratedAttribute]
public void set_DenySetInstance(object value);
    [CompilerGeneratedAttribute]
public AssemblyName get_FailedAssemblyInfo();
    [CompilerGeneratedAttribute]
public void set_FailedAssemblyInfo(AssemblyName value);
    [CompilerGeneratedAttribute]
public string get_GrantedSet();
    [CompilerGeneratedAttribute]
public void set_GrantedSet(string value);
    [CompilerGeneratedAttribute]
public MethodInfo get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(MethodInfo value);
    [CompilerGeneratedAttribute]
public string get_PermissionState();
    [CompilerGeneratedAttribute]
public void set_PermissionState(string value);
    [CompilerGeneratedAttribute]
public Type get_PermissionType();
    [CompilerGeneratedAttribute]
public void set_PermissionType(Type value);
    [CompilerGeneratedAttribute]
public object get_PermitOnlySetInstance();
    [CompilerGeneratedAttribute]
public void set_PermitOnlySetInstance(object value);
    [CompilerGeneratedAttribute]
public string get_RefusedSet();
    [CompilerGeneratedAttribute]
public void set_RefusedSet(string value);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <SkipVerificationInFullTrust>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityRuleSet <RuleSet>k__BackingField;
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRuleSet RuleSet { get; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    [CompilerGeneratedAttribute]
public bool get_SkipVerificationInFullTrust();
    [CompilerGeneratedAttribute]
public void set_SkipVerificationInFullTrust(bool value);
    [CompilerGeneratedAttribute]
public SecurityRuleSet get_RuleSet();
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility. Use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Security.VerificationException : SystemException {
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected VerificationException(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("4124")]
[EditorBrowsableAttribute("1")]
public class System.SerializableAttribute : Attribute {
}
internal class System.Sha1ForNonSecretPurposes : ValueType {
    private long _length;
    private UInt32[] _w;
    private int _pos;
    public void Start();
    public void Append(byte input);
    public void Append(ReadOnlySpan`1<byte> input);
    public void Finish(Span`1<byte> output);
    private void Drain();
}
[IsReadOnlyAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Single : ValueType {
    private float m_value;
    public static float MinValue;
    public static float MaxValue;
    public static float Epsilon;
    public static float NegativeInfinity;
    public static float PositiveInfinity;
    public static float NaN;
    public static float NegativeZero;
    public static float E;
    public static float Pi;
    public static float Tau;
    internal byte BiasedExponent { get; }
    internal sbyte Exponent { get; }
    internal UInt32 Significand { get; }
    internal UInt32 TrailingSignificand { get; }
    private static float System.Numerics.IAdditiveIdentity<System.Single,System.Single>.AdditiveIdentity { get; }
    private static float System.Numerics.IBinaryNumber<System.Single>.AllBitsSet { get; }
    private static float System.Numerics.IFloatingPointConstants<System.Single>.E { get; }
    private static float System.Numerics.IFloatingPointConstants<System.Single>.Pi { get; }
    private static float System.Numerics.IFloatingPointConstants<System.Single>.Tau { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.Epsilon { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.NaN { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeInfinity { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeZero { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.PositiveInfinity { get; }
    private static float System.Numerics.IMinMaxValue<System.Single>.MinValue { get; }
    private static float System.Numerics.IMinMaxValue<System.Single>.MaxValue { get; }
    private static float System.Numerics.IMultiplicativeIdentity<System.Single,System.Single>.MultiplicativeIdentity { get; }
    private static float System.Numerics.INumberBase<System.Single>.One { get; }
    private static int System.Numerics.INumberBase<System.Single>.Radix { get; }
    private static float System.Numerics.INumberBase<System.Single>.Zero { get; }
    private static float System.Numerics.ISignedNumber<System.Single>.NegativeOne { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.NumberBufferLength { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.ZeroBits { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.InfinityBits { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.NormalMantissaMask { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.DenormalMantissaMask { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MinBinaryExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MaxBinaryExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MinDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MaxDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.ExponentBias { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Single>.ExponentBits { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.OverflowDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.InfinityExponent { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Single>.NormalMantissaBits { get; }
    private static ushort System.IBinaryFloatParseAndFormatInfo<System.Single>.DenormalMantissaBits { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MinFastFloatDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MaxFastFloatDecimalExponent { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MinExponentRoundToEven { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MaxExponentRoundToEven { get; }
    private static int System.IBinaryFloatParseAndFormatInfo<System.Single>.MaxExponentFastPath { get; }
    private static ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.MaxMantissaFastPath { get; }
    internal byte get_BiasedExponent();
    internal sbyte get_Exponent();
    internal UInt32 get_Significand();
    internal UInt32 get_TrailingSignificand();
    internal static byte ExtractBiasedExponentFromBits(UInt32 bits);
    internal static UInt32 ExtractTrailingSignificandFromBits(UInt32 bits);
    [NonVersionableAttribute]
public static override bool IsFinite(float f);
    [NonVersionableAttribute]
public static override bool IsInfinity(float f);
    [NonVersionableAttribute]
public static override bool IsNaN(float f);
    [NonVersionableAttribute]
public static override bool IsNegative(float f);
    [NonVersionableAttribute]
public static override bool IsNegativeInfinity(float f);
    [NonVersionableAttribute]
public static override bool IsNormal(float f);
    [NonVersionableAttribute]
public static override bool IsPositiveInfinity(float f);
    [NonVersionableAttribute]
public static override bool IsSubnormal(float f);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    [NonVersionableAttribute]
public static override bool op_Equality(float left, float right);
    [NonVersionableAttribute]
public static override bool op_Inequality(float left, float right);
    [NonVersionableAttribute]
public static override bool op_LessThan(float left, float right);
    [NonVersionableAttribute]
public static override bool op_GreaterThan(float left, float right);
    [NonVersionableAttribute]
public static override bool op_LessThanOrEqual(float left, float right);
    [NonVersionableAttribute]
public static override bool op_GreaterThanOrEqual(float left, float right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static float Parse(string s);
    [NullableContextAttribute("1")]
public static float Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override float Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override float Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, Single& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override float System.Numerics.IAdditionOperators<System.Single,System.Single,System.Single>.op_Addition(float left, float right);
    private static override float System.Numerics.IAdditiveIdentity<System.Single,System.Single>.get_AdditiveIdentity();
    private static override float System.Numerics.IBinaryNumber<System.Single>.get_AllBitsSet();
    public static override bool IsPow2(float value);
    [IntrinsicAttribute]
public static override float Log2(float value);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_BitwiseAnd(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_BitwiseOr(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_ExclusiveOr(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_OnesComplement(float value);
    private static override float System.Numerics.IDecrementOperators<System.Single>.op_Decrement(float value);
    private static override float System.Numerics.IDivisionOperators<System.Single,System.Single,System.Single>.op_Division(float left, float right);
    [IntrinsicAttribute]
public static override float Exp(float x);
    public static override float ExpM1(float x);
    public static override float Exp2(float x);
    public static override float Exp2M1(float x);
    public static override float Exp10(float x);
    public static override float Exp10M1(float x);
    [IntrinsicAttribute]
public static override float Ceiling(float x);
    [IntrinsicAttribute]
public static override float Floor(float x);
    [IntrinsicAttribute]
public static override float Round(float x);
    public static override float Round(float x, int digits);
    public static override float Round(float x, MidpointRounding mode);
    public static override float Round(float x, int digits, MidpointRounding mode);
    [IntrinsicAttribute]
public static override float Truncate(float x);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetSignificandByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetSignificandBitLength();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override float System.Numerics.IFloatingPointConstants<System.Single>.get_E();
    private static override float System.Numerics.IFloatingPointConstants<System.Single>.get_Pi();
    private static override float System.Numerics.IFloatingPointConstants<System.Single>.get_Tau();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_Epsilon();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_NaN();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_NegativeInfinity();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_NegativeZero();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_PositiveInfinity();
    [IntrinsicAttribute]
public static override float Atan2(float y, float x);
    public static override float Atan2Pi(float y, float x);
    public static override float BitDecrement(float x);
    public static override float BitIncrement(float x);
    [IntrinsicAttribute]
public static override float FusedMultiplyAdd(float left, float right, float addend);
    public static override float Ieee754Remainder(float left, float right);
    public static override int ILogB(float x);
    public static override float Lerp(float value1, float value2, float amount);
    public static override float ReciprocalEstimate(float x);
    public static override float ReciprocalSqrtEstimate(float x);
    public static override float ScaleB(float x, int n);
    [IntrinsicAttribute]
public static override float Acosh(float x);
    [IntrinsicAttribute]
public static override float Asinh(float x);
    [IntrinsicAttribute]
public static override float Atanh(float x);
    [IntrinsicAttribute]
public static override float Cosh(float x);
    [IntrinsicAttribute]
public static override float Sinh(float x);
    [IntrinsicAttribute]
public static override float Tanh(float x);
    private static override float System.Numerics.IIncrementOperators<System.Single>.op_Increment(float value);
    [IntrinsicAttribute]
public static override float Log(float x);
    public static override float Log(float x, float newBase);
    public static override float LogP1(float x);
    [IntrinsicAttribute]
public static override float Log10(float x);
    public static override float Log2P1(float x);
    public static override float Log10P1(float x);
    private static override float System.Numerics.IMinMaxValue<System.Single>.get_MinValue();
    private static override float System.Numerics.IMinMaxValue<System.Single>.get_MaxValue();
    private static override float System.Numerics.IModulusOperators<System.Single,System.Single,System.Single>.op_Modulus(float left, float right);
    private static override float System.Numerics.IMultiplicativeIdentity<System.Single,System.Single>.get_MultiplicativeIdentity();
    private static override float System.Numerics.IMultiplyOperators<System.Single,System.Single,System.Single>.op_Multiply(float left, float right);
    public static override float Clamp(float value, float min, float max);
    public static override float CopySign(float value, float sign);
    [IntrinsicAttribute]
public static override float Max(float x, float y);
    [IntrinsicAttribute]
public static override float MaxNumber(float x, float y);
    [IntrinsicAttribute]
public static override float Min(float x, float y);
    [IntrinsicAttribute]
public static override float MinNumber(float x, float y);
    public static override int Sign(float value);
    private static override float System.Numerics.INumberBase<System.Single>.get_One();
    private static override int System.Numerics.INumberBase<System.Single>.get_Radix();
    private static override float System.Numerics.INumberBase<System.Single>.get_Zero();
    [IntrinsicAttribute]
public static override float Abs(float value);
    [NullableContextAttribute("1")]
public static override float CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override float CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override float CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsCanonical(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsComplexNumber(float value);
    public static override bool IsEvenInteger(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsImaginaryNumber(float value);
    public static override bool IsInteger(float value);
    public static override bool IsOddInteger(float value);
    public static override bool IsPositive(float value);
    public static override bool IsRealNumber(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsZero(float value);
    [IntrinsicAttribute]
public static override float MaxMagnitude(float x, float y);
    [IntrinsicAttribute]
public static override float MaxMagnitudeNumber(float x, float y);
    [IntrinsicAttribute]
public static override float MinMagnitude(float x, float y);
    [IntrinsicAttribute]
public static override float MinMagnitudeNumber(float x, float y);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertFromChecked(TOther value, Single& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertFromSaturating(TOther value, Single& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertFromTruncating(TOther value, Single& result);
    private static bool TryConvertFrom(TOther value, Single& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertToChecked(float value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertToSaturating(float value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertToTruncating(float value, TOther& result);
    private static bool TryConvertTo(float value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Single& result);
    [IntrinsicAttribute]
public static override float Pow(float x, float y);
    [IntrinsicAttribute]
public static override float Cbrt(float x);
    public static override float Hypot(float x, float y);
    public static override float RootN(float x, int n);
    [IntrinsicAttribute]
public static override float Sqrt(float x);
    private static override float System.Numerics.ISignedNumber<System.Single>.get_NegativeOne();
    public static override float Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Single& result);
    private static override float System.Numerics.ISubtractionOperators<System.Single,System.Single,System.Single>.op_Subtraction(float left, float right);
    [IntrinsicAttribute]
public static override float Acos(float x);
    public static override float AcosPi(float x);
    [IntrinsicAttribute]
public static override float Asin(float x);
    public static override float AsinPi(float x);
    [IntrinsicAttribute]
public static override float Atan(float x);
    public static override float AtanPi(float x);
    [IntrinsicAttribute]
public static override float Cos(float x);
    public static override float CosPi(float x);
    public static override float DegreesToRadians(float degrees);
    public static override float RadiansToDegrees(float radians);
    [IntrinsicAttribute]
public static override float Sin(float x);
    public static override ValueTuple`2<float, float> SinCos(float x);
    public static override ValueTuple`2<float, float> SinCosPi(float x);
    public static override float SinPi(float x);
    [IntrinsicAttribute]
public static override float Tan(float x);
    public static override float TanPi(float x);
    private static override float System.Numerics.IUnaryNegationOperators<System.Single,System.Single>.op_UnaryNegation(float value);
    private static override float System.Numerics.IUnaryPlusOperators<System.Single,System.Single>.op_UnaryPlus(float value);
    public static override float Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, Single& result);
    public static override float Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, Single& result);
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_NumberBufferLength();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.get_ZeroBits();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.get_InfinityBits();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.get_NormalMantissaMask();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.get_DenormalMantissaMask();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MinBinaryExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MaxBinaryExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MinDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MaxDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_ExponentBias();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Single>.get_ExponentBits();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_OverflowDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_InfinityExponent();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Single>.get_NormalMantissaBits();
    private static override ushort System.IBinaryFloatParseAndFormatInfo<System.Single>.get_DenormalMantissaBits();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MinFastFloatDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MaxFastFloatDecimalExponent();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MinExponentRoundToEven();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MaxExponentRoundToEven();
    private static override int System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MaxExponentFastPath();
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.get_MaxMantissaFastPath();
    private static override float System.IBinaryFloatParseAndFormatInfo<System.Single>.BitsToFloat(ulong bits);
    private static override ulong System.IBinaryFloatParseAndFormatInfo<System.Single>.FloatToBits(float value);
    private static float CosForIntervalPiBy4(float x);
    private static float SinForIntervalPiBy4(float x);
    private static float TanForIntervalPiBy4(float x, bool isReciprocal);
    [CompilerGeneratedAttribute]
internal static float <RootN>g__PositiveN|219_0(float x, int n);
    [CompilerGeneratedAttribute]
internal static float <RootN>g__NegativeN|219_1(float x, int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("System.SpanDebugView`1")]
[DebuggerDisplayAttribute("{ToString(),raw}")]
[NonVersionableAttribute]
[NativeMarshallingAttribute("System.Runtime.InteropServices.Marshalling.SpanMarshaller`2")]
public class System.Span`1 : ValueType {
    internal T& _reference;
    private int _length;
    public T& Item { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Span`1<T> Empty { get; }
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    public Span`1(T& reference);
    internal Span`1(T& reference, int length);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public T& get_Item(int index);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public int get_Length();
    [NonVersionableAttribute]
public bool get_IsEmpty();
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use the equality operator instead.")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
[EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Span`1<T> op_Implicit(T[] array);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static Span`1<T> get_Empty();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public void Clear();
    public void Fill(T value);
    public void CopyTo(Span`1<T> destination);
    public bool TryCopyTo(Span`1<T> destination);
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public virtual string ToString();
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
}
internal class System.SpanDebugView`1 : object {
    private T[] _array;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public SpanDebugView`1(Span`1<T> span);
    public SpanDebugView`1(ReadOnlySpan`1<T> span);
    public T[] get_Items();
}
[ExtensionAttribute]
internal static class System.SpanHelpers : object {
    [ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    public static int BinarySearch(T& spanStart, int length, TComparable comparable);
    public static int IndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    public static int LastIndexOf(Byte& searchSpace, int searchSpaceLength, Byte& value, int valueLength);
    [DoesNotReturnAttribute]
private static void ThrowMustBeNullTerminatedString();
    internal static int IndexOfNullByte(Byte* searchSpace);
    [IntrinsicAttribute]
public static bool SequenceEqual(Byte& first, Byte& second, UIntPtr length);
    public static int SequenceCompareTo(Byte& first, int firstLength, Byte& second, int secondLength);
    public static UIntPtr CommonPrefixLength(Byte& first, Byte& second, UIntPtr length);
    private static ushort LoadUShort(Byte& start);
    private static UInt32 LoadUInt(Byte& start);
    private static UInt32 LoadUInt(Byte& start, UIntPtr offset);
    private static UIntPtr LoadNUInt(Byte& start);
    private static UIntPtr LoadNUInt(Byte& start, UIntPtr offset);
    private static UIntPtr GetByteVector128SpanLength(UIntPtr offset, int length);
    private static UIntPtr UnalignedCountVector128(Byte* searchSpace);
    public static void Reverse(Byte& buf, UIntPtr length);
    public static int IndexOf(Char& searchSpace, int searchSpaceLength, Char& value, int valueLength);
    public static int LastIndexOf(Char& searchSpace, int searchSpaceLength, Char& value, int valueLength);
    public static int SequenceCompareTo(Char& first, int firstLength, Char& second, int secondLength);
    public static int IndexOfNullCharacter(Char* searchSpace);
    private static IntPtr GetCharVector128SpanLength(IntPtr offset, IntPtr length);
    private static IntPtr UnalignedCountVector128(Char* searchSpace);
    public static void Reverse(Char& buf, UIntPtr length);
    public static void ClearWithoutReferences(Byte& b, UIntPtr byteLength);
    public static void ClearWithReferences(IntPtr& ip, UIntPtr pointerSizeLength);
    public static void Reverse(Int32& buf, UIntPtr length);
    public static void Reverse(Int64& buf, UIntPtr length);
    public static void Reverse(T& elements, UIntPtr length);
    private static void ReverseInner(T& elements, UIntPtr length);
    public static void Fill(T& refData, UIntPtr numElements, T value);
    public static int IndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static bool Contains(T& searchSpace, T value, int length);
    public static int IndexOf(T& searchSpace, T value, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int IndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int IndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    public static int LastIndexOf(T& searchSpace, T value, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, int length);
    public static int LastIndexOfAny(T& searchSpace, T value0, T value1, T value2, int length);
    public static int LastIndexOfAny(T& searchSpace, int searchSpaceLength, T& value, int valueLength);
    internal static int IndexOfAnyExcept(T& searchSpace, T value0, int length);
    internal static int LastIndexOfAnyExcept(T& searchSpace, T value0, int length);
    internal static int IndexOfAnyExcept(T& searchSpace, T value0, T value1, int length);
    internal static int LastIndexOfAnyExcept(T& searchSpace, T value0, T value1, int length);
    internal static int IndexOfAnyExcept(T& searchSpace, T value0, T value1, T value2, int length);
    internal static int LastIndexOfAnyExcept(T& searchSpace, T value0, T value1, T value2, int length);
    internal static int IndexOfAnyExcept(T& searchSpace, T value0, T value1, T value2, T value3, int length);
    internal static int LastIndexOfAnyExcept(T& searchSpace, T value0, T value1, T value2, T value3, int length);
    public static bool SequenceEqual(T& first, T& second, int length);
    public static int SequenceCompareTo(T& first, int firstLength, T& second, int secondLength);
    internal static bool ContainsValueType(T& searchSpace, T value, int length);
    internal static bool NonPackedContainsValueType(T& searchSpace, T value, int length);
    internal static int IndexOfChar(Char& searchSpace, char value, int length);
    internal static int NonPackedIndexOfChar(Char& searchSpace, char value, int length);
    internal static int IndexOfValueType(T& searchSpace, T value, int length);
    internal static int IndexOfAnyExceptValueType(T& searchSpace, T value, int length);
    private static int IndexOfValueType(TValue& searchSpace, TValue value, int length);
    internal static int NonPackedIndexOfValueType(TValue& searchSpace, TValue value, int length);
    internal static int IndexOfAnyChar(Char& searchSpace, char value0, char value1, int length);
    internal static int IndexOfAnyValueType(T& searchSpace, T value0, T value1, int length);
    internal static int IndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, int length);
    private static int IndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, int length);
    internal static int NonPackedIndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, int length);
    internal static int IndexOfAnyValueType(T& searchSpace, T value0, T value1, T value2, int length);
    internal static int IndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, T value2, int length);
    private static int IndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, int length);
    internal static int NonPackedIndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, int length);
    internal static int IndexOfAnyValueType(T& searchSpace, T value0, T value1, T value2, T value3, int length);
    internal static int IndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, T value2, T value3, int length);
    private static int IndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, TValue value3, int length);
    internal static int IndexOfAnyValueType(T& searchSpace, T value0, T value1, T value2, T value3, T value4, int length);
    internal static int IndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, T value2, T value3, T value4, int length);
    private static int IndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, TValue value3, TValue value4, int length);
    internal static int LastIndexOfValueType(T& searchSpace, T value, int length);
    internal static int LastIndexOfAnyExceptValueType(T& searchSpace, T value, int length);
    private static int LastIndexOfValueType(TValue& searchSpace, TValue value, int length);
    internal static int LastIndexOfAnyValueType(T& searchSpace, T value0, T value1, int length);
    internal static int LastIndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, int length);
    private static int LastIndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, int length);
    internal static int LastIndexOfAnyValueType(T& searchSpace, T value0, T value1, T value2, int length);
    internal static int LastIndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, T value2, int length);
    private static int LastIndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, int length);
    internal static int LastIndexOfAnyValueType(T& searchSpace, T value0, T value1, T value2, T value3, int length);
    internal static int LastIndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, T value2, T value3, int length);
    private static int LastIndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, TValue value3, int length);
    public static void Replace(T& src, T& dst, T oldValue, T newValue, UIntPtr length);
    public static void ReplaceValueType(T& src, T& dst, T oldValue, T newValue, UIntPtr length);
    internal static int LastIndexOfAnyValueType(T& searchSpace, T value0, T value1, T value2, T value3, T value4, int length);
    internal static int LastIndexOfAnyExceptValueType(T& searchSpace, T value0, T value1, T value2, T value3, T value4, int length);
    private static int LastIndexOfAnyValueType(TValue& searchSpace, TValue value0, TValue value1, TValue value2, TValue value3, TValue value4, int length);
    private static int ComputeFirstIndex(T& searchSpace, T& current, Vector128`1<T> equals);
    private static int ComputeLastIndex(IntPtr offset, Vector128`1<T> equals);
    internal static int IndexOfAnyInRange(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int IndexOfAnyExceptInRange(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int IndexOfAnyInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int IndexOfAnyExceptInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    private static int IndexOfAnyInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int NonPackedIndexOfAnyInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int LastIndexOfAnyInRange(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int LastIndexOfAnyExceptInRange(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int LastIndexOfAnyInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    internal static int LastIndexOfAnyExceptInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    private static int LastIndexOfAnyInRangeUnsignedNumber(T& searchSpace, T lowInclusive, T highInclusive, int length);
    public static int Count(T& current, T value, int length);
    public static int CountValueType(T& current, T value, int length);
}
internal static class System.SR : object {
    private static object _lock;
    private static List`1<string> _currentlyLoading;
    private static int _infinitelyRecursingCount;
    private static bool _resourceManagerInited;
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Acc_CreateAbstEx { get; }
    internal static string Acc_CreateArgIterator { get; }
    internal static string Acc_CreateGenericEx { get; }
    internal static string Acc_CreateInterfaceEx { get; }
    internal static string Acc_CreateVoid { get; }
    internal static string Acc_NotClassInit { get; }
    internal static string Acc_ReadOnly { get; }
    internal static string Access_Void { get; }
    internal static string AggregateException_ctor_DefaultMessage { get; }
    internal static string AggregateException_ctor_InnerExceptionNull { get; }
    internal static string AggregateException_DeserializationFailure { get; }
    internal static string AggregateException_InnerException { get; }
    internal static string AppDomain_Name { get; }
    internal static string AppDomain_NoContextPolicies { get; }
    internal static string AppDomain_Policy_PrincipalTwice { get; }
    internal static string Arg_AccessException { get; }
    internal static string Arg_AccessViolationException { get; }
    internal static string Arg_AmbiguousImplementationException_NoMessage { get; }
    internal static string Arg_AmbiguousMatchException_Attribute { get; }
    internal static string Arg_AmbiguousMatchException_NoMessage { get; }
    internal static string Arg_AmbiguousMatchException_MemberInfo { get; }
    internal static string Arg_ApplicationException { get; }
    internal static string Arg_ArgumentException { get; }
    internal static string Arg_ArgumentOutOfRangeException { get; }
    internal static string Arg_ArithmeticException { get; }
    internal static string Arg_ArrayLengthsDiffer { get; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_ByteArrayTooSmallForValue { get; }
    internal static string Arg_ArrayTypeMismatchException { get; }
    internal static string Arg_ArrayZeroError { get; }
    internal static string Arg_BadDecimal { get; }
    internal static string Arg_BadImageFormatException { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string Arg_BufferTooSmall { get; }
    internal static string Arg_CannotBeNaN { get; }
    internal static string Arg_CannotHaveNegativeValue { get; }
    internal static string Arg_CannotMixComparisonInfrastructure { get; }
    internal static string Arg_CannotUnloadAppDomainException { get; }
    internal static string Arg_COMException { get; }
    internal static string Arg_CreatInstAccess { get; }
    internal static string Arg_CryptographyException { get; }
    internal static string Arg_CustomAttributeFormatException { get; }
    internal static string Arg_DataMisalignedException { get; }
    internal static string Arg_DecBitCtor { get; }
    internal static string Arg_DirectoryNotFoundException { get; }
    internal static string Arg_DivideByZero { get; }
    internal static string Arg_DlgtTargMeth { get; }
    internal static string Arg_DlgtTypeMis { get; }
    internal static string Arg_DllNotFoundException { get; }
    internal static string Arg_DllNameCannotBeEmpty { get; }
    internal static string Arg_DuplicateWaitObjectException { get; }
    internal static string Arg_EHClauseNotFilter { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string Arg_EmptySpan { get; }
    internal static string Arg_EndOfStreamException { get; }
    internal static string Arg_EntryPointNotFoundException { get; }
    internal static string Arg_EnumAndObjectMustBeSameType { get; }
    internal static string Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_EnumUnderlyingTypeAndObjectMustBeSameType { get; }
    internal static string Arg_EnumValueNotFound { get; }
    internal static string Arg_ExecutionEngineException { get; }
    internal static string Arg_ExternalException { get; }
    internal static string Arg_EnC_ExpectedPrimitive { get; }
    internal static string Arg_FieldAccessException { get; }
    internal static string Arg_FieldDeclTarget { get; }
    internal static string Arg_FldGetArgErr { get; }
    internal static string Arg_FldGetPropSet { get; }
    internal static string Arg_FldSetArgErr { get; }
    internal static string Arg_FldSetGet { get; }
    internal static string Arg_FldSetInvoke { get; }
    internal static string Arg_FldSetPropGet { get; }
    internal static string Arg_FormatException { get; }
    internal static string Arg_GenericArgumentsAfterArrayOrPointerType { get; }
    internal static string Arg_GenericParameter { get; }
    internal static string Arg_GetMethNotFnd { get; }
    internal static string Arg_GuidArrayCtor { get; }
    internal static string Arg_HandleNotAsync { get; }
    internal static string Arg_HandleNotSync { get; }
    internal static string Arg_HexBinaryStylesNotSupported { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_IndexMustBeInt { get; }
    internal static string Arg_IndexOutOfRangeException { get; }
    internal static string Arg_InsufficientExecutionStackException { get; }
    internal static string Arg_InvalidBase { get; }
    internal static string Arg_InvalidCastException { get; }
    internal static string Arg_InvalidComObjectException { get; }
    internal static string Arg_InvalidFilterCriteriaException { get; }
    internal static string Arg_InvalidHandle { get; }
    internal static string Arg_InvalidHexBinaryStyle { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_Asm_Culture { get; }
    internal static string Arg_InvalidNeutralResourcesLanguage_FallbackLoc { get; }
    internal static string Arg_InvalidSatelliteContract_Asm_Ver { get; }
    internal static string Arg_InvalidOleVariantTypeException { get; }
    internal static string Arg_InvalidOperationException { get; }
    internal static string Arg_InvalidTypeInRetType { get; }
    internal static string Arg_InvalidTypeInSignature { get; }
    internal static string Arg_IOException { get; }
    internal static string Arg_KeyNotFound { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanDestArray { get; }
    internal static string Arg_LongerThanSrcArray { get; }
    internal static string Arg_LongerThanSrcString { get; }
    internal static string Arg_LowerBoundsMustMatch { get; }
    internal static string Arg_MarshalDirectiveException { get; }
    internal static string Arg_MethodAccessException { get; }
    internal static string Arg_MissingFieldException { get; }
    internal static string Arg_MissingManifestResourceException { get; }
    internal static string Arg_MissingMemberException { get; }
    internal static string Arg_MissingMethodException { get; }
    internal static string Arg_MulticastNotSupportedException { get; }
    internal static string Arg_MustBeBoolean { get; }
    internal static string Arg_MustBeByte { get; }
    internal static string Arg_MustBeChar { get; }
    internal static string Arg_MustBeDateOnly { get; }
    internal static string Arg_MustBeTimeOnly { get; }
    internal static string Arg_MustBeDateTime { get; }
    internal static string Arg_MustBeDateTimeOffset { get; }
    internal static string Arg_MustBeDecimal { get; }
    internal static string Arg_MustBeDelegate { get; }
    internal static string Arg_MustBeDouble { get; }
    internal static string Arg_MustBeEnum { get; }
    internal static string Arg_MustBeEnumBaseTypeOrEnum { get; }
    internal static string Arg_MustBeGuid { get; }
    internal static string Arg_MustBeInt16 { get; }
    internal static string Arg_MustBeInt32 { get; }
    internal static string Arg_MustBeInt64 { get; }
    internal static string Arg_MustBeInt128 { get; }
    internal static string Arg_MustBeIntPtr { get; }
    internal static string Arg_MustBeInterface { get; }
    internal static string Arg_MustBeNFloat { get; }
    internal static string Arg_MustBePointer { get; }
    internal static string Arg_MustBePrimArray { get; }
    internal static string Arg_MustBeRuntimeAssembly { get; }
    internal static string Arg_MustBeSByte { get; }
    internal static string Arg_MustBeSingle { get; }
    internal static string Arg_MustBeString { get; }
    internal static string Arg_MustBeTimeSpan { get; }
    internal static string Arg_MustBeType { get; }
    internal static string Arg_MustBeTrue { get; }
    internal static string Arg_MustBeUInt16 { get; }
    internal static string Arg_MustBeUInt32 { get; }
    internal static string Arg_MustBeUInt64 { get; }
    internal static string Arg_MustBeUInt128 { get; }
    internal static string Arg_MustBeUIntPtr { get; }
    internal static string Arg_MustBeVersion { get; }
    internal static string Arg_MustContainEnumInfo { get; }
    internal static string Arg_NamedParamNull { get; }
    internal static string Arg_NamedParamTooBig { get; }
    internal static string Arg_Need1DArray { get; }
    internal static string Arg_Need2DArray { get; }
    internal static string Arg_Need3DArray { get; }
    internal static string Arg_NeedAtLeast1Rank { get; }
    internal static string Arg_NoAccessSpec { get; }
    internal static string Arg_NoDefCTorWithoutTypeName { get; }
    internal static string Arg_NoDefCTor { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_NoStaticVirtual { get; }
    internal static string Arg_NotFiniteNumberException { get; }
    internal static string Arg_NotFoundIFace { get; }
    internal static string Arg_NotGenericMethodDefinition { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_NotGenericTypeDefinition { get; }
    internal static string Arg_NotImplementedException { get; }
    internal static string Arg_NotSupportedException { get; }
    internal static string Arg_NullReferenceException { get; }
    internal static string Arg_ObjObjEx { get; }
    internal static string Arg_OleAutDateInvalid { get; }
    internal static string Arg_OleAutDateScale { get; }
    internal static string Arg_OverflowException { get; }
    internal static string Arg_OutOfMemoryException { get; }
    internal static string Arg_ParamName_Name { get; }
    internal static string Arg_ParmArraySize { get; }
    internal static string Arg_ParmCnt { get; }
    internal static string Arg_PathEmpty { get; }
    internal static string Arg_PlatformNotSupported { get; }
    internal static string Arg_PropSetGet { get; }
    internal static string Arg_PropSetInvoke { get; }
    internal static string Arg_RankException { get; }
    internal static string Arg_RankIndices { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_RanksAndBounds { get; }
    internal static string Arg_ResMgrNotResSet { get; }
    internal static string Arg_ResourceFileUnsupportedVersion { get; }
    internal static string Arg_ResourceNameNotExist { get; }
    internal static string Arg_SafeArrayRankMismatchException { get; }
    internal static string Arg_SafeArrayTypeMismatchException { get; }
    internal static string Arg_SecurityException { get; }
    internal static string SerializationException { get; }
    internal static string Arg_SetMethNotFnd { get; }
    internal static string Arg_StackOverflowException { get; }
    internal static string Arg_SurrogatesNotAllowedAsSingleChar { get; }
    internal static string Arg_SynchronizationLockException { get; }
    internal static string Arg_SystemException { get; }
    internal static string Arg_TargetInvocationException { get; }
    internal static string Arg_TargetParameterCountException { get; }
    internal static string Arg_ThreadStartException { get; }
    internal static string Arg_ThreadStateException { get; }
    internal static string Arg_TimeoutException { get; }
    internal static string Arg_TypeAccessException { get; }
    internal static string Arg_TypedReference_Null { get; }
    internal static string Arg_TypeLoadException { get; }
    internal static string Arg_TypeLoadNullStr { get; }
    internal static string Arg_TypeRefPrimitive { get; }
    internal static string Arg_TypeUnloadedException { get; }
    internal static string Arg_UnauthorizedAccessException { get; }
    internal static string Arg_UnboundGenField { get; }
    internal static string Arg_UnboundGenParam { get; }
    internal static string Arg_UnknownTypeCode { get; }
    internal static string Arg_UnreachableException { get; }
    internal static string Arg_VarMissNull { get; }
    internal static string Arg_VersionString { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AbsolutePathRequired { get; }
    internal static string Argument_AddingDuplicate { get; }
    internal static string Argument_AddingDuplicate__ { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_AdjustmentRulesNoNulls { get; }
    internal static string Argument_AdjustmentRulesOutOfOrder { get; }
    internal static string Argument_AlignmentMustBePow2 { get; }
    internal static string Argument_ArraysInvalid { get; }
    internal static string Argument_ArrayParsingError { get; }
    internal static string Argument_AttributeNamesMustBeUnique { get; }
    internal static string Argument_BadConstructor { get; }
    internal static string Argument_BadExceptionCodeGen { get; }
    internal static string Argument_BadFieldType { get; }
    internal static string Argument_BadFormatSpecifier { get; }
    internal static string Argument_BadParameterCountsForConstructor { get; }
    internal static string Argument_BadParameterTypeForCAB { get; }
    internal static string Argument_BadSigFormat { get; }
    internal static string Argument_BadSizeForData { get; }
    internal static string Argument_ByrefQualifierMustBeLastOneOfAType { get; }
    internal static string Argument_CannotSetParentToInterface { get; }
    internal static string Argument_CodepageNotSupported { get; }
    internal static string Argument_CompareOptionOrdinal { get; }
    internal static string Argument_ConflictingDateTimeRoundtripStyles { get; }
    internal static string Argument_ConflictingDateTimeStyles { get; }
    internal static string Argument_ConstantDoesntMatch { get; }
    internal static string Argument_ConstantNotSupported { get; }
    internal static string Argument_ConstructorNeedGenericDeclaringType { get; }
    internal static string Argument_ConversionOverflow { get; }
    internal static string Argument_ConvertMismatch { get; }
    internal static string Argument_CultureIetfNotSupported { get; }
    internal static string Argument_CultureInvalidIdentifier { get; }
    internal static string Argument_CultureIsNeutral { get; }
    internal static string Argument_CultureNotSupported { get; }
    internal static string Argument_CultureNotSupportedInInvariantMode { get; }
    internal static string Argument_CustomAssemblyLoadContextRequestedNameMismatch { get; }
    internal static string Argument_CustomCultureCannotBePassedByNumber { get; }
    internal static string Argument_CustomModifierLengthInvalidLength { get; }
    internal static string Argument_DateTimeBadBinaryData { get; }
    internal static string Argument_DateTimeHasTicks { get; }
    internal static string Argument_DateTimeHasTimeOfDay { get; }
    internal static string Argument_DateTimeIsInvalid { get; }
    internal static string Argument_DateTimeIsNotAmbiguous { get; }
    internal static string Argument_DateTimeKindMustBeUnspecified { get; }
    internal static string Argument_DateTimeKindMustBeUnspecifiedOrUtc { get; }
    internal static string Argument_DateTimeOffsetInvalidDateTimeStyles { get; }
    internal static string Argument_DateTimeOffsetIsNotAmbiguous { get; }
    internal static string Argument_DestinationTooShort { get; }
    internal static string Argument_DuplicateTypeName { get; }
    internal static string Argument_EmitWriteLineType { get; }
    internal static string Argument_EmptyName { get; }
    internal static string Argument_EmptyWaithandleArray { get; }
    internal static string Argument_EncoderFallbackNotEmpty { get; }
    internal static string Argument_EncodingConversionOverflowBytes { get; }
    internal static string Argument_EncodingConversionOverflowChars { get; }
    internal static string Argument_EncodingNotSupported { get; }
    internal static string Argument_EnumTypeDoesNotMatch { get; }
    internal static string Argument_FallbackBufferNotEmpty { get; }
    internal static string Argument_FieldDoesNotBelongToConstructorClass { get; }
    internal static string Argument_FieldDoesNotHaveAValidType { get; }
    internal static string Argument_FieldDoesNotHaveAValidValue { get; }
    internal static string Argument_FieldPropertyEventAndTypeHandleIncompatibility { get; }
    internal static string Argument_FieldNeedGenericDeclaringType { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_GenericArgumentCannotBeByrefOrPointerType { get; }
    internal static string Argument_GenericParsingError { get; }
    internal static string Argument_OpenGenericTypeNotPermitted { get; }
    internal static string Argument_GlobalMembersMustBeStatic { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string Argument_IdnBadBidi { get; }
    internal static string Argument_IdnBadLabelSize { get; }
    internal static string Argument_IdnBadNameSize { get; }
    internal static string Argument_IdnBadPunycode { get; }
    internal static string Argument_IdnBadStd3 { get; }
    internal static string Argument_IdnIllegalName { get; }
    internal static string Argument_IllegalEnvVarName { get; }
    internal static string Argument_ImplementIComparable { get; }
    internal static string Argument_InterfaceMap { get; }
    internal static string Argument_InvalidAppendMode { get; }
    internal static string Argument_InvalidPreallocateAccess { get; }
    internal static string Argument_InvalidPreallocateMode { get; }
    internal static string Argument_InvalidUnixCreateMode { get; }
    internal static string Argument_InvalidArgumentForComparison { get; }
    internal static string Argument_InvalidArrayLength { get; }
    internal static string Argument_MultiDimensionalArrayCannotBeBound { get; }
    internal static string Argument_IncompatibleArrayType { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string InvalidAssemblyName { get; }
    internal static string Argument_InvalidCalendar { get; }
    internal static string Argument_InvalidCharInArraySpecification { get; }
    internal static string Argument_InvalidCharSequence { get; }
    internal static string Argument_InvalidCharSequenceNoIndex { get; }
    internal static string Argument_InvalidCodePageBytesIndex { get; }
    internal static string Argument_InvalidCodePageConversionIndex { get; }
    internal static string Argument_InvalidConstructorDeclaringType { get; }
    internal static string Argument_InvalidCultureName { get; }
    internal static string Argument_InvalidPredefinedCultureName { get; }
    internal static string Argument_InvalidDateTimeKind { get; }
    internal static string Argument_InvalidDateTimeStyles { get; }
    internal static string Argument_InvalidDateStyles { get; }
    internal static string Argument_InvalidDigitSubstitution { get; }
    internal static string Argument_InvalidElementName { get; }
    internal static string Argument_InvalidElementTag { get; }
    internal static string Argument_InvalidElementText { get; }
    internal static string Argument_InvalidElementValue { get; }
    internal static string Argument_InvalidEnum { get; }
    internal static string Argument_InvalidEnumValue { get; }
    internal static string Argument_InvalidFieldDeclaringType { get; }
    internal static string Argument_InvalidFileModeAndAccessCombo { get; }
    internal static string Argument_InvalidFlag { get; }
    internal static string Argument_InvalidGenericArg { get; }
    internal static string Argument_InvalidGenericArgumentsSeparator { get; }
    internal static string Argument_InvalidGroupSize { get; }
    internal static string Argument_InvalidHandle { get; }
    internal static string Argument_InvalidHighSurrogate { get; }
    internal static string Argument_InvalidId { get; }
    internal static string Argument_InvalidKindOfTypeForCA { get; }
    internal static string Argument_InvalidLabel { get; }
    internal static string Argument_InvalidLowSurrogate { get; }
    internal static string Argument_InvalidMemberForNamedArgument { get; }
    internal static string Argument_InvalidMethodDeclaringType { get; }
    internal static string Argument_InvalidName { get; }
    internal static string Argument_InvalidNativeDigitCount { get; }
    internal static string Argument_InvalidNativeDigitValue { get; }
    internal static string Argument_InvalidNeutralRegionName { get; }
    internal static string Argument_InvalidNormalizationForm { get; }
    internal static string Argument_InvalidNumberStyles { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOpCodeOnDynamicMethod { get; }
    internal static string Argument_NullCharInPath { get; }
    internal static string Argument_InvalidResourceCultureName { get; }
    internal static string Argument_InvalidSafeBufferOffLen { get; }
    internal static string Argument_InvalidSeekOrigin { get; }
    internal static string Argument_InvalidSerializedString { get; }
    internal static string Argument_InvalidStartupHookSignature { get; }
    internal static string Argument_InvalidTimeSpanStyles { get; }
    internal static string Argument_InvalidToken { get; }
    internal static string Argument_InvalidTypeForDynamicMethod { get; }
    internal static string Argument_InvalidTypeName { get; }
    internal static string Argument_InvalidTypeWithPointersNotSupported { get; }
    internal static string Argument_InvalidUnity { get; }
    internal static string Argument_LabelUnmarked { get; }
    internal static string Argument_MethodBodyMustBelongToType { get; }
    internal static string Argument_MethodDeclaringTypeGeneric { get; }
    internal static string Argument_MethodNeedGenericDeclaringType { get; }
    internal static string Argument_MinMaxValue { get; }
    internal static string Argument_MismatchedArrays { get; }
    internal static string Argument_MustBeFalse { get; }
    internal static string Argument_MustBeRuntimeAssembly { get; }
    internal static string Argument_MustBeRuntimeFieldInfo { get; }
    internal static string Argument_MustBeRuntimeConstructorInfo { get; }
    internal static string Argument_MustBeRuntimeMethodInfo { get; }
    internal static string Argument_MustBeRuntimeMethod { get; }
    internal static string Argument_MustBeRuntimeType { get; }
    internal static string Argument_MustBeTypeBuilder { get; }
    internal static string Argument_MustHaveAttributeBaseClass { get; }
    internal static string Argument_NativeOverlappedAlreadyFree { get; }
    internal static string Argument_NativeOverlappedWrongBoundHandle { get; }
    internal static string Argument_NeedGenericMethodDefinition { get; }
    internal static string Argument_NeedNonGenericType { get; }
    internal static string Argument_NeedStructWithNoRefs { get; }
    internal static string Argument_NegativeFieldOffsetNotPermitted { get; }
    internal static string Argument_NeverValidGenericArgument { get; }
    internal static string Argument_NoEra { get; }
    internal static string Argument_NoRegionInvariantCulture { get; }
    internal static string Argument_NotEnoughBytesToRead { get; }
    internal static string Argument_NotEnoughBytesToWrite { get; }
    internal static string Argument_NotEnoughGenArguments { get; }
    internal static string Argument_NotExceptionType { get; }
    internal static string Argument_NotInExceptionBlock { get; }
    internal static string Argument_NotMethodCallOpcode { get; }
    internal static string Argument_OffsetAndCapacityOutOfBounds { get; }
    internal static string Argument_OffsetLocalMismatch { get; }
    internal static string Argument_OffsetOutOfRange { get; }
    internal static string Argument_OffsetPrecision { get; }
    internal static string Argument_OffsetUtcMismatch { get; }
    internal static string Argument_OneOfCulturesNotSupported { get; }
    internal static string Argument_OnlyMscorlib { get; }
    internal static string Argument_OutOfOrderDateTimes { get; }
    internal static string Argument_PathEmpty { get; }
    internal static string Argument_ParameterHasUnmatchedArgumentValue { get; }
    internal static string Argument_ParameterInvalidType { get; }
    internal static string Argument_ParameterInvalidValue { get; }
    internal static string Argument_TypeParseError { get; }
    internal static string Argument_PreAllocatedAlreadyAllocated { get; }
    internal static string Argument_RecursiveFallback { get; }
    internal static string Argument_RecursiveFallbackBytes { get; }
    internal static string Argument_RedefinedLabel { get; }
    internal static string Argument_ResolveType { get; }
    internal static string Argument_ResultCalendarRange { get; }
    internal static string Argument_SemaphoreInitialMaximum { get; }
    internal static string Argument_ShouldNotSpecifyExceptionType { get; }
    internal static string Argument_ShouldOnlySetVisibilityFlags { get; }
    internal static string Argument_StreamNotReadable { get; }
    internal static string Argument_StreamNotWritable { get; }
    internal static string Argument_StringFirstCharIsZero { get; }
    internal static string Argument_TimeSpanHasSeconds { get; }
    internal static string Argument_TimeZoneInfoBadTZif { get; }
    internal static string Argument_TimeZoneInfoInvalidTZif { get; }
    internal static string Argument_ToExclusiveLessThanFromExclusive { get; }
    internal static string Argument_TransitionTimesAreIdentical { get; }
    internal static string Argument_TypedReferenceInvalidField { get; }
    internal static string Argument_TypeMustNotBeComImport { get; }
    internal static string Argument_UnclosedAssemblyQualifiedTypeName { get; }
    internal static string Argument_UnmanagedMemAccessorWrapAround { get; }
    internal static string Argument_UnmanagedTypeOnlyValidOnFields { get; }
    internal static string Argument_UnmatchedFieldValueAndType { get; }
    internal static string Argument_UnmatchedMethodForLocal { get; }
    internal static string Argument_UnmatchedSquareBracketWhileParsingGenericArgAssemblyName { get; }
    internal static string Argument_UTCOutOfRange { get; }
    internal static string ArgumentException_BufferNotFromPool { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string ArgumentException_NotIsomorphic { get; }
    internal static string ArgumentException_TupleIncorrectType { get; }
    internal static string ArgumentException_TupleLastArgumentNotATuple { get; }
    internal static string ArgumentException_ValueTupleIncorrectType { get; }
    internal static string ArgumentException_ValueTupleLastArgumentNotAValueTuple { get; }
    internal static string ArgumentNull_Array { get; }
    internal static string ArgumentNull_ArrayElement { get; }
    internal static string ArgumentNull_ArrayValue { get; }
    internal static string ArgumentNull_Child { get; }
    internal static string ArgumentNull_Generic { get; }
    internal static string ArgumentNull_SafeHandle { get; }
    internal static string ArgumentNull_String { get; }
    internal static string ArgumentOutOfRange_ActualValue { get; }
    internal static string ArgumentOutOfRange_AddValue { get; }
    internal static string ArgumentOutOfRange_ArrayLB { get; }
    internal static string ArgumentOutOfRange_BadHourMinuteSecond { get; }
    internal static string ArgumentOutOfRange_BadYearMonthDay { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_BinaryReaderFillBuffer { get; }
    internal static string ArgumentOutOfRange_Bounds_Lower_Upper { get; }
    internal static string ArgumentOutOfRange_CalendarRange { get; }
    internal static string ArgumentOutOfRange_Capacity { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_DateArithmetic { get; }
    internal static string ArgumentOutOfRange_DateTimeBadMonths { get; }
    internal static string ArgumentOutOfRange_DateTimeBadTicks { get; }
    internal static string ArgumentOutOfRange_TimeOnlyBadTicks { get; }
    internal static string ArgumentOutOfRange_DateTimeBadYears { get; }
    internal static string ArgumentOutOfRange_Day { get; }
    internal static string ArgumentOutOfRange_DayOfWeek { get; }
    internal static string ArgumentOutOfRange_DayParam { get; }
    internal static string ArgumentOutOfRange_DecimalRound { get; }
    internal static string ArgumentOutOfRange_EndIndexStartIndex { get; }
    internal static string ArgumentOutOfRange_Enum { get; }
    internal static string ArgumentOutOfRange_Era { get; }
    internal static string ArgumentOutOfRange_FileLengthTooBig { get; }
    internal static string ArgumentOutOfRange_FileTimeInvalid { get; }
    internal static string ArgumentOutOfRange_GetByteCountOverflow { get; }
    internal static string ArgumentOutOfRange_GetCharCountOverflow { get; }
    internal static string ArgumentOutOfRange_HashtableLoadFactor { get; }
    internal static string ArgumentOutOfRange_HugeArrayNotSupported { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLess { get; }
    internal static string ArgumentOutOfRange_IndexMustBeLessOrEqual { get; }
    internal static string ArgumentOutOfRange_IndexCount { get; }
    internal static string ArgumentOutOfRange_IndexCountBuffer { get; }
    internal static string ArgumentOutOfRange_IndexLength { get; }
    internal static string ArgumentOutOfRange_IndexString { get; }
    internal static string ArgumentOutOfRange_InvalidEraValue { get; }
    internal static string ArgumentOutOfRange_InvalidHighSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidLowSurrogate { get; }
    internal static string ArgumentOutOfRange_InvalidUTF32 { get; }
    internal static string ArgumentOutOfRange_LengthGreaterThanCapacity { get; }
    internal static string ArgumentOutOfRange_LessEqualToIntegerMaxVal { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_Month { get; }
    internal static string ArgumentOutOfRange_DayNumber { get; }
    internal static string ArgumentOutOfRange_MonthParam { get; }
    internal static string ArgumentOutOfRange_MustBeNonNegNum { get; }
    internal static string ArgumentOutOfRange_MustBePositive { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedNonNegOrNegative1 { get; }
    internal static string ArgumentOutOfRange_NeedValidId { get; }
    internal static string ArgumentOutOfRange_OffsetLength { get; }
    internal static string ArgumentOutOfRange_OffsetOut { get; }
    internal static string ArgumentOutOfRange_ParamSequence { get; }
    internal static string ArgumentOutOfRange_PartialWCHAR { get; }
    internal static string ArgumentOutOfRange_PositionLessThanCapacityRequired { get; }
    internal static string ArgumentOutOfRange_Range { get; }
    internal static string ArgumentOutOfRange_RoundingDigits { get; }
    internal static string ArgumentOutOfRange_RoundingDigits_MathF { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string ArgumentOutOfRange_StartIndex { get; }
    internal static string ArgumentOutOfRange_StartIndexLargerThanLength { get; }
    internal static string ArgumentOutOfRange_StreamLength { get; }
    internal static string ArgumentOutOfRange_UIntPtrMax { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamLength { get; }
    internal static string ArgumentOutOfRange_UnmanagedMemStreamWrapAround { get; }
    internal static string ArgumentOutOfRange_UtcOffset { get; }
    internal static string ArgumentOutOfRange_UtcOffsetAndDaylightDelta { get; }
    internal static string ArgumentOutOfRange_Week { get; }
    internal static string ArgumentOutOfRange_Year { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeNonZero { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeNonNegative { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeNonNegativeNonZero { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeLessOrEqual { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeLess { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeGreaterOrEqual { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeGreater { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeEqual { get; }
    internal static string ArgumentOutOfRange_Generic_MustBeNotEqual { get; }
    internal static string Arithmetic_NaN { get; }
    internal static string ArrayTypeMismatch_CantAssignType { get; }
    internal static string AssemblyLoadContext_Unload_CannotUnloadIfNotCollectible { get; }
    internal static string AssemblyLoadContext_Verify_NotUnloading { get; }
    internal static string AssertionFailed { get; }
    internal static string AssertionFailed_Cnd { get; }
    internal static string AssumptionFailed { get; }
    internal static string AssumptionFailed_Cnd { get; }
    internal static string AsyncMethodBuilder_InstanceNotInitialized { get; }
    internal static string BadImageFormat_BadILFormat { get; }
    internal static string BadImageFormat_InvalidType { get; }
    internal static string BadImageFormat_NegativeStringLength { get; }
    internal static string BadImageFormat_ResType_SerBlobMismatch { get; }
    internal static string BadImageFormat_ResourceDataLengthInvalid { get; }
    internal static string BadImageFormat_ResourceNameCorrupted { get; }
    internal static string BadImageFormat_ResourceNameCorrupted_NameIndex { get; }
    internal static string BadImageFormat_ResourcesDataInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesHeaderCorrupted { get; }
    internal static string BadImageFormat_ResourcesIndexTooLong { get; }
    internal static string BadImageFormat_ResourcesNameInvalidOffset { get; }
    internal static string BadImageFormat_ResourcesNameTooLong { get; }
    internal static string BadImageFormat_TypeMismatch { get; }
    internal static string CancellationToken_CreateLinkedToken_TokensIsEmpty { get; }
    internal static string CancellationTokenSource_Disposed { get; }
    internal static string ConcurrentCollection_SyncRoot_NotSupported { get; }
    internal static string CustomMarshaler_MultipleGetInstanceMethods { get; }
    internal static string CustomMarshaler_NoGetInstanceMethod { get; }
    internal static string CustomMarshaler_UnassignedGenericParams { get; }
    internal static string CustomMarshaler_NullReturnForGetInstance { get; }
    internal static string EventSource_AbstractMustNotDeclareEventMethods { get; }
    internal static string EventSource_AbstractMustNotDeclareKTOC { get; }
    internal static string EventSource_AddScalarOutOfRange { get; }
    internal static string EventSource_BadHexDigit { get; }
    internal static string EventSource_ChannelTypeDoesNotMatchEventChannelValue { get; }
    internal static string EventSource_CouldNotEnableEventPipe { get; }
    internal static string EventSource_DataDescriptorsOutOfRange { get; }
    internal static string EventSource_DuplicateStringKey { get; }
    internal static string EventSource_EnumKindMismatch { get; }
    internal static string EventSource_EvenHexDigits { get; }
    internal static string EventSource_EventChannelOutOfRange { get; }
    internal static string EventSource_EventIdReused { get; }
    internal static string EventSource_EventMustHaveTaskIfNonDefaultOpcode { get; }
    internal static string EventSource_EventMustNotBeExplicitImplementation { get; }
    internal static string EventSource_EventNameReused { get; }
    internal static string EventSource_EventParametersMismatch { get; }
    internal static string EventSource_EventSourceGuidInUse { get; }
    internal static string EventSource_EventTooBig { get; }
    internal static string EventSource_EventWithAdminChannelMustHaveMessage { get; }
    internal static string EventSource_IllegalKeywordsValue { get; }
    internal static string EventSource_IllegalOpcodeValue { get; }
    internal static string EventSource_IllegalTaskValue { get; }
    internal static string EventSource_IllegalValue { get; }
    internal static string EventSource_IncorrentlyAuthoredTypeInfo { get; }
    internal static string EventSource_InvalidCommand { get; }
    internal static string EventSource_InvalidEventFormat { get; }
    internal static string EventSource_KeywordCollision { get; }
    internal static string EventSource_KeywordNeedPowerOfTwo { get; }
    internal static string EventSource_ListenerCreatedInsideCallback { get; }
    internal static string EventSource_ListenerNotFound { get; }
    internal static string EventSource_ListenerWriteFailure { get; }
    internal static string EventSource_MaxChannelExceeded { get; }
    internal static string EventSource_MismatchIdToWriteEvent { get; }
    internal static string EventSource_NeedGuid { get; }
    internal static string EventSource_NeedName { get; }
    internal static string EventSource_NeedPositiveId { get; }
    internal static string EventSource_NoFreeBuffers { get; }
    internal static string EventSource_NonCompliantTypeError { get; }
    internal static string EventSource_NoRelatedActivityId { get; }
    internal static string EventSource_NotSupportedArrayOfBinary { get; }
    internal static string EventSource_NotSupportedArrayOfNil { get; }
    internal static string EventSource_NotSupportedArrayOfNullTerminatedString { get; }
    internal static string EventSource_NotSupportedNestedArraysEnums { get; }
    internal static string EventSource_NullInput { get; }
    internal static string EventSource_OpcodeCollision { get; }
    internal static string EventSource_PinArrayOutOfRange { get; }
    internal static string EventSource_RecursiveTypeDefinition { get; }
    internal static string EventSource_StopsFollowStarts { get; }
    internal static string EventSource_TaskCollision { get; }
    internal static string EventSource_TaskOpcodePairReused { get; }
    internal static string EventSource_TooManyArgs { get; }
    internal static string EventSource_TooManyFields { get; }
    internal static string EventSource_ToString { get; }
    internal static string EventSource_TraitEven { get; }
    internal static string EventSource_TypeMustBeSealedOrAbstract { get; }
    internal static string EventSource_TypeMustDeriveFromEventSource { get; }
    internal static string EventSource_UndefinedChannel { get; }
    internal static string EventSource_UndefinedKeyword { get; }
    internal static string EventSource_UndefinedOpcode { get; }
    internal static string EventSource_UnknownEtwTrait { get; }
    internal static string EventSource_UnsupportedEventTypeInManifest { get; }
    internal static string EventSource_UnsupportedMessageProperty { get; }
    internal static string EventSource_VarArgsParameterMismatch { get; }
    internal static string Exception_EmptyFieldForCustomAttributeType { get; }
    internal static string Exception_EndOfInnerExceptionStack { get; }
    internal static string Exception_EndStackTraceFromPreviousThrow { get; }
    internal static string Exception_InvalidCustomAttributeLength { get; }
    internal static string Exception_InvalidProlog { get; }
    internal static string Exception_UnknownNamedType { get; }
    internal static string Exception_UnknownMarshalAsAttributeField { get; }
    internal static string Exception_UnhandledSubType { get; }
    internal static string Exception_WasThrown { get; }
    internal static string ExecutionContext_ExceptionInAsyncLocalNotification { get; }
    internal static string FileNotFound_ResolveAssembly { get; }
    internal static string FileNotFound_LoadFile { get; }
    internal static string Format_AttributeUsage { get; }
    internal static string Format_Bad7BitInt { get; }
    internal static string Format_BadBase64Char { get; }
    internal static string Format_BadBoolean { get; }
    internal static string Format_BadDatePattern { get; }
    internal static string Format_BadDateTime { get; }
    internal static string Format_BadDateOnly { get; }
    internal static string Format_BadTimeOnly { get; }
    internal static string Format_DateTimeOnlyContainsNoneDateParts { get; }
    internal static string Format_BadDateTimeCalendar { get; }
    internal static string Format_BadDayOfWeek { get; }
    internal static string Format_BadFormatSpecifier { get; }
    internal static string Format_NoFormatSpecifier { get; }
    internal static string Format_BadHexChar { get; }
    internal static string Format_BadHexLength { get; }
    internal static string Format_BadQuote { get; }
    internal static string Format_BadTimeSpan { get; }
    internal static string Format_DateOutOfRange { get; }
    internal static string Format_EmptyInputString { get; }
    internal static string Format_ExtraJunkAtEnd { get; }
    internal static string Format_GuidBrace { get; }
    internal static string Format_GuidBraceAfterLastNumber { get; }
    internal static string Format_GuidComma { get; }
    internal static string Format_GuidDashes { get; }
    internal static string Format_GuidEndBrace { get; }
    internal static string Format_GuidHexPrefix { get; }
    internal static string Format_GuidInvalidChar { get; }
    internal static string Format_GuidInvLen { get; }
    internal static string Format_GuidUnrecognized { get; }
    internal static string Format_IndexOutOfRange { get; }
    internal static string Format_InvalidEnumFormatSpecification { get; }
    internal static string Format_InvalidGuidFormatSpecification { get; }
    internal static string Format_InvalidString { get; }
    internal static string Format_InvalidStringWithValue { get; }
    internal static string Format_InvalidStringWithOffsetAndReason { get; }
    internal static string Format_UnexpectedClosingBrace { get; }
    internal static string Format_UnclosedFormatItem { get; }
    internal static string Format_ExpectedAsciiDigit { get; }
    internal static string Format_MissingIncompleteDate { get; }
    internal static string Format_NeedSingleChar { get; }
    internal static string Format_NoParsibleDigits { get; }
    internal static string Format_OffsetOutOfRange { get; }
    internal static string Format_RepeatDateTimePattern { get; }
    internal static string Format_StringZeroLength { get; }
    internal static string Format_UnknownDateTimeWord { get; }
    internal static string Format_UTCOutOfRange { get; }
    internal static string Globalization_cp_1200 { get; }
    internal static string Globalization_cp_12000 { get; }
    internal static string Globalization_cp_12001 { get; }
    internal static string Globalization_cp_1201 { get; }
    internal static string Globalization_cp_20127 { get; }
    internal static string Globalization_cp_28591 { get; }
    internal static string Globalization_cp_65000 { get; }
    internal static string Globalization_cp_65001 { get; }
    internal static string IndexOutOfRange_UMSPosition { get; }
    internal static string InsufficientMemory_MemFailPoint { get; }
    internal static string InsufficientMemory_MemFailPoint_TooBig { get; }
    internal static string InsufficientMemory_MemFailPoint_VAFrag { get; }
    internal static string InvalidCast_CannotCastNullToValueType { get; }
    internal static string InvalidCast_DBNull { get; }
    internal static string InvalidCast_DownCastArrayElement { get; }
    internal static string InvalidCast_Empty { get; }
    internal static string InvalidCast_FromDBNull { get; }
    internal static string InvalidCast_FromTo { get; }
    internal static string InvalidCast_IConvertible { get; }
    internal static string InvalidOperation_AbstractMethod { get; }
    internal static string InvalidOperation_AsyncFlowCtrlCtxMismatch { get; }
    internal static string InvalidOperation_AsyncIOInProgress { get; }
    internal static string InvalidOperation_BadEmptyMethodBody { get; }
    internal static string InvalidOperation_BadInstructionOrIndexOutOfBound { get; }
    internal static string InvalidOperation_BadInterfaceNotAbstract { get; }
    internal static string InvalidOperation_BadInterfaceNotAbstractAndVirtual { get; }
    internal static string InvalidOperation_CalledTwice { get; }
    internal static string InvalidOperation_CannotRegisterSecondResolver { get; }
    internal static string InvalidOperation_CannotRestoreUnsuppressedFlow { get; }
    internal static string InvalidOperation_CannotUseAFCOtherThread { get; }
    internal static string InvalidOperation_CollectionCorrupted { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_DateTimeParsing { get; }
    internal static string InvalidOperation_EnumEnded { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumNotStarted { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_GlobalsHaveBeenCreated { get; }
    internal static string InvalidOperation_HandleIsNotInitialized { get; }
    internal static string InvalidOperation_HandleIsNotPinned { get; }
    internal static string InvalidOperation_InvalidUtf8 { get; }
    internal static string InvalidOperation_HashInsertFailed { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string InvalidOperation_MethodBaked { get; }
    internal static string InvalidOperation_ModuleFieldsMethodsRelyOnCreateGlobalFunctionsMethod { get; }
    internal static string InvalidOperation_MustCallInitialize { get; }
    internal static string InvalidOperation_NativeOverlappedReused { get; }
    internal static string InvalidOperation_NoMultiModuleAssembly { get; }
    internal static string InvalidOperation_NoPublicAddMethod { get; }
    internal static string InvalidOperation_NoPublicRemoveMethod { get; }
    internal static string InvalidOperation_NotAllowedInDynamicMethod { get; }
    internal static string InvalidOperation_NotAVarArgCallingConvention { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string InvalidOperation_NotWithConcurrentGC { get; }
    internal static string InvalidOperation_NoValue { get; }
    internal static string InvalidOperation_NullArray { get; }
    internal static string InvalidOperation_NullContext { get; }
    internal static string InvalidOperation_Overlapped_Pack { get; }
    internal static string InvalidOperation_ReadOnly { get; }
    internal static string InvalidOperation_ResMgrBadResSet_Type { get; }
    internal static string InvalidOperation_ResourceNotStream_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Name { get; }
    internal static string InvalidOperation_ResourceNotString_Type { get; }
    internal static string InvalidOperation_SetLatencyModeNoGC { get; }
    internal static string InvalidOperation_ShouldNotHaveMethodBody { get; }
    internal static string InvalidOperation_ThreadWrongThreadStart { get; }
    internal static string InvalidOperation_TimeoutsNotSupported { get; }
    internal static string InvalidOperation_TimerAlreadyClosed { get; }
    internal static string InvalidOperation_TypeHasBeenCreated { get; }
    internal static string InvalidOperation_TypeNotCreated { get; }
    internal static string InvalidOperation_UnderlyingArrayListChanged { get; }
    internal static string InvalidOperation_UnknownEnumType { get; }
    internal static string InvalidOperation_WrongAsyncResultOrEndCalledMultiple { get; }
    internal static string InvalidProgram_Default { get; }
    internal static string InvalidTimeZone_InvalidFileData { get; }
    internal static string InvalidTimeZone_InvalidJulianDay { get; }
    internal static string InvalidTimeZone_NoTTInfoStructures { get; }
    internal static string InvalidTimeZone_UnparsablePosixMDateString { get; }
    internal static string InvariantFailed { get; }
    internal static string InvariantFailed_Cnd { get; }
    internal static string IO_NoFileTableInInMemoryAssemblies { get; }
    internal static string IO_EOF_ReadBeyondEOF { get; }
    internal static string IO_FileLoad { get; }
    internal static string IO_FileName_Name { get; }
    internal static string IO_FileNotFound { get; }
    internal static string IO_FileNotFound_FileName { get; }
    internal static string IO_AlreadyExists_Name { get; }
    internal static string IO_DiskFull_Path_AllocationSize { get; }
    internal static string IO_FileTooLarge_Path_AllocationSize { get; }
    internal static string IO_FileExists_Name { get; }
    internal static string IO_FileTooLong2GB { get; }
    internal static string IO_FixedCapacity { get; }
    internal static string IO_InvalidStringLen_Len { get; }
    internal static string IO_SeekAppendOverwrite { get; }
    internal static string IO_SeekBeforeBegin { get; }
    internal static string IO_SetLengthAppendTruncate { get; }
    internal static string IO_SharingViolation_File { get; }
    internal static string IO_SharingViolation_NoFileName { get; }
    internal static string IO_StreamTooLong { get; }
    internal static string IO_PathNotFound_NoPathName { get; }
    internal static string IO_PathNotFound_Path { get; }
    internal static string IO_PathTooLong { get; }
    internal static string IO_PathTooLong_Path { get; }
    internal static string IO_TooManySymbolicLinkLevels { get; }
    internal static string IO_UnknownFileName { get; }
    internal static string Lazy_CreateValue_NoParameterlessCtorForT { get; }
    internal static string Lazy_ctor_ModeInvalid { get; }
    internal static string Lazy_StaticInit_InvalidOperation { get; }
    internal static string Lazy_ToString_ValueNotCreated { get; }
    internal static string Lazy_Value_RecursiveCallsToValue { get; }
    internal static string ManualResetEventSlim_ctor_TooManyWaiters { get; }
    internal static string MissingConstructor_Name { get; }
    internal static string MissingField { get; }
    internal static string MissingField_Name { get; }
    internal static string MissingManifestResource_MultipleBlobs { get; }
    internal static string MissingManifestResource_NoNeutralAsm { get; }
    internal static string MissingManifestResource_NoNeutralDisk { get; }
    internal static string MissingMember { get; }
    internal static string MissingMember_Name { get; }
    internal static string MissingMemberNestErr { get; }
    internal static string MissingMemberTypeRef { get; }
    internal static string MissingMethod_Name { get; }
    internal static string MissingSatelliteAssembly_Culture_Name { get; }
    internal static string MissingSatelliteAssembly_Default { get; }
    internal static string Multicast_Combine { get; }
    internal static string MustUseCCRewrite { get; }
    internal static string NotSupported_AbstractNonCLS { get; }
    internal static string NotSupported_ActivAttr { get; }
    internal static string NotSupported_AssemblyLoadFromHash { get; }
    internal static string NotSupported_ByRefLike { get; }
    internal static string NotSupported_ByRefToByRefLikeReturn { get; }
    internal static string NotSupported_ByRefToVoidReturn { get; }
    internal static string NotSupported_CallToVarArg { get; }
    internal static string NotSupported_CannotCallEqualsOnSpan { get; }
    internal static string NotSupported_CannotCallGetHashCodeOnSpan { get; }
    internal static string NotSupported_ChangeType { get; }
    internal static string NotSupported_ContainsStackPtr { get; }
    internal static string NotSupported_CreateInstanceWithTypeBuilder { get; }
    internal static string NotSupported_DynamicAssembly { get; }
    internal static string NotSupported_DynamicMethodFlags { get; }
    internal static string NotSupported_DynamicModule { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string InvalidOperation_SpanOverlappedOperation { get; }
    internal static string InvalidOperation_TimeProviderNullLocalTimeZone { get; }
    internal static string InvalidOperation_TimeProviderInvalidTimestampFrequency { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_MaxWaitHandles { get; }
    internal static string NotSupported_MemStreamNotExpandable { get; }
    internal static string NotSupported_MustBeModuleBuilder { get; }
    internal static string NotSupported_NoCodepageData { get; }
    internal static string InvalidOperation_FunctionMissingUnmanagedCallersOnly { get; }
    internal static string NotSupported_NonReflectedType { get; }
    internal static string NotImplemented_NoSupportForModOpt { get; }
    internal static string NotSupported_NoParentDefaultConstructor { get; }
    internal static string NotSupported_NoTypeInfo { get; }
    internal static string NotSupported_NYI { get; }
    internal static string NotSupported_ObsoleteResourcesFile { get; }
    internal static string NotSupported_OutputStreamUsingTypeBuilder { get; }
    internal static string NotSupported_RangeCollection { get; }
    internal static string NotSupported_Reading { get; }
    internal static string NotSupported_ReadOnlyCollection { get; }
    internal static string NotSupported_ResourceObjectSerialization { get; }
    internal static string NotSupported_StringComparison { get; }
    internal static string NotSupported_SubclassOverride { get; }
    internal static string NotSupported_Type { get; }
    internal static string NotSupported_UmsSafeBuffer { get; }
    internal static string NotSupported_UnitySerHolder { get; }
    internal static string NotSupported_UnreadableStream { get; }
    internal static string NotSupported_UnseekableStream { get; }
    internal static string NotSupported_UnwritableStream { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string NotSupported_Writing { get; }
    internal static string NotSupported_WrongResourceReader_Type { get; }
    internal static string ObjectDisposed_FileClosed { get; }
    internal static string ObjectDisposed_Generic { get; }
    internal static string ObjectDisposed_ObjectName_Name { get; }
    internal static string ObjectDisposed_WriterClosed { get; }
    internal static string ObjectDisposed_ReaderClosed { get; }
    internal static string ObjectDisposed_ResourceSet { get; }
    internal static string ObjectDisposed_StreamClosed { get; }
    internal static string ObjectDisposed_ViewAccessorClosed { get; }
    internal static string OperationCanceled { get; }
    internal static string Overflow_Byte { get; }
    internal static string Overflow_Char { get; }
    internal static string Overflow_Currency { get; }
    internal static string Overflow_Decimal { get; }
    internal static string Overflow_Duration { get; }
    internal static string Overflow_Int16 { get; }
    internal static string Overflow_Int32 { get; }
    internal static string Overflow_Int64 { get; }
    internal static string Overflow_Int128 { get; }
    internal static string Overflow_MutexReacquireCount { get; }
    internal static string Overflow_NegateTwosCompNum { get; }
    internal static string Overflow_NegativeUnsigned { get; }
    internal static string Overflow_SByte { get; }
    internal static string Overflow_TimeSpanElementTooLarge { get; }
    internal static string Overflow_TimeSpanTooLong { get; }
    internal static string Overflow_UInt16 { get; }
    internal static string Overflow_UInt32 { get; }
    internal static string Overflow_UInt64 { get; }
    internal static string Overflow_UInt128 { get; }
    internal static string PlatformNotSupported_ComInterop { get; }
    internal static string PlatformNotSupported_NamedSynchronizationPrimitives { get; }
    internal static string PlatformNotSupported_ReflectionOnly { get; }
    internal static string PlatformNotSupported_Remoting { get; }
    internal static string PlatformNotSupported_SecureBinarySerialization { get; }
    internal static string PlatformNotSupported_StrongNameSigning { get; }
    internal static string PlatformNotSupported_OverlappedIO { get; }
    internal static string PlatformNotSupported_AppDomains { get; }
    internal static string PlatformNotSupported_CAS { get; }
    internal static string PlatformNotSupported_Principal { get; }
    internal static string PlatformNotSupported_ThreadAbort { get; }
    internal static string PlatformNotSupported_ThreadSuspend { get; }
    internal static string PlatformNotSupported_UserDefinedSubclassesOfType { get; }
    internal static string PostconditionFailed { get; }
    internal static string PostconditionFailed_Cnd { get; }
    internal static string PostconditionOnExceptionFailed { get; }
    internal static string PostconditionOnExceptionFailed_Cnd { get; }
    internal static string PreconditionFailed { get; }
    internal static string PreconditionFailed_Cnd { get; }
    internal static string Rank_MultiDimNotSupported { get; }
    internal static string ResourceReaderIsClosed { get; }
    internal static string Resources_StreamNotValid { get; }
    internal static string InvalidFilterCriteriaException_CritInt { get; }
    internal static string InvalidFilterCriteriaException_CritString { get; }
    internal static string RFLCT_Targ_ITargMismatch { get; }
    internal static string RFLCT_Targ_StatFldReqTarg { get; }
    internal static string RFLCT_Targ_StatMethReqTarg { get; }
    internal static string RuntimeWrappedException { get; }
    internal static string Security_CannotReadFileData { get; }
    internal static string SemaphoreSlim_ctor_InitialCountWrong { get; }
    internal static string SemaphoreSlim_ctor_MaxCountWrong { get; }
    internal static string SemaphoreSlim_Release_CountWrong { get; }
    internal static string SemaphoreSlim_Wait_TimeoutWrong { get; }
    internal static string Serialization_BadParameterInfo { get; }
    internal static string Serialization_CorruptField { get; }
    internal static string Serialization_DateTimeTicksOutOfRange { get; }
    internal static string Serialization_DelegatesNotSupported { get; }
    internal static string Serialization_InsufficientState { get; }
    internal static string Serialization_InvalidData { get; }
    internal static string Serialization_InvalidEscapeSequence { get; }
    internal static string Serialization_InvalidOnDeser { get; }
    internal static string Serialization_InvalidType { get; }
    internal static string Serialization_KeyValueDifferentSizes { get; }
    internal static string Serialization_MissingDateTimeData { get; }
    internal static string Serialization_MissingKeys { get; }
    internal static string Serialization_MissingValues { get; }
    internal static string Serialization_NoParameterInfo { get; }
    internal static string Serialization_NotFound { get; }
    internal static string Serialization_NullKey { get; }
    internal static string Serialization_OptionalFieldVersionValue { get; }
    internal static string Serialization_SameNameTwice { get; }
    internal static string Serialization_StringBuilderCapacity { get; }
    internal static string Serialization_StringBuilderMaxCapacity { get; }
    internal static string SetterHasNoParams { get; }
    internal static string SpinLock_Exit_SynchronizationLockException { get; }
    internal static string SpinLock_IsHeldByCurrentThread { get; }
    internal static string SpinLock_TryEnter_ArgumentOutOfRange { get; }
    internal static string SpinLock_TryEnter_LockRecursionException { get; }
    internal static string SpinLock_TryReliableEnter_ArgumentException { get; }
    internal static string SpinWait_SpinUntil_TimeoutWrong { get; }
    internal static string StackTrace_InFileILOffset { get; }
    internal static string StackTrace_InFileLineNumber { get; }
    internal static string TargetInvocation_MethodCannotBeInvoked { get; }
    internal static string Task_ContinueWith_ESandLR { get; }
    internal static string Task_ContinueWith_NotOnAnything { get; }
    internal static string Task_InvalidTimerTimeSpan { get; }
    internal static string Task_Delay_InvalidMillisecondsDelay { get; }
    internal static string Task_Dispose_NotCompleted { get; }
    internal static string Task_FromAsync_LongRunning { get; }
    internal static string Task_FromAsync_PreferFairness { get; }
    internal static string Task_MultiTaskContinuation_EmptyTaskList { get; }
    internal static string Task_MultiTaskContinuation_FireOptions { get; }
    internal static string Task_MultiTaskContinuation_NullTask { get; }
    internal static string Task_RunSynchronously_AlreadyStarted { get; }
    internal static string Task_RunSynchronously_Continuation { get; }
    internal static string Task_RunSynchronously_Promise { get; }
    internal static string Task_RunSynchronously_TaskCompleted { get; }
    internal static string Task_Start_AlreadyStarted { get; }
    internal static string Task_Start_ContinuationTask { get; }
    internal static string Task_Start_Promise { get; }
    internal static string Task_Start_TaskCompleted { get; }
    internal static string Task_ThrowIfDisposed { get; }
    internal static string Task_WaitMulti_NullTask { get; }
    internal static string TaskT_ConfigureAwait_InvalidOptions { get; }
    internal static string TaskCanceledException_ctor_DefaultMessage { get; }
    internal static string TaskCompletionSourceT_TrySetException_NoExceptions { get; }
    internal static string TaskCompletionSourceT_TrySetException_NullException { get; }
    internal static string TaskExceptionHolder_UnhandledException { get; }
    internal static string TaskExceptionHolder_UnknownExceptionType { get; }
    internal static string TaskScheduler_ExecuteTask_WrongTaskScheduler { get; }
    internal static string TaskScheduler_FromCurrentSynchronizationContext_NoCurrent { get; }
    internal static string TaskScheduler_InconsistentStateAfterTryExecuteTaskInline { get; }
    internal static string TaskSchedulerException_ctor_DefaultMessage { get; }
    internal static string TaskT_DebuggerNoResult { get; }
    internal static string TaskT_TransitionToFinal_AlreadyCompleted { get; }
    internal static string Thread_GetSetCompressedStack_NotSupported { get; }
    internal static string Thread_Operation_RequiresCurrentThread { get; }
    internal static string Threading_AbandonedMutexException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException { get; }
    internal static string Threading_WaitHandleCannotBeOpenedException_InvalidHandle { get; }
    internal static string Threading_WaitHandleTooManyPosts { get; }
    internal static string Threading_SemaphoreFullException { get; }
    internal static string Threading_ThreadInterrupted { get; }
    internal static string ThreadLocal_Value_RecursiveCallsToValue { get; }
    internal static string ThreadLocal_ValuesNotAvailable { get; }
    internal static string TimeZoneNotFound_MissingData { get; }
    internal static string TypeInitialization_Type { get; }
    internal static string TypeLoad_AssemblyEnumContainsMethodsError { get; }
    internal static string TypeLoad_AssemblyInaccessibleInterfaceError { get; }
    internal static string TypeLoad_AssemblySealedParentTypeError { get; }
    internal static string TypeLoad_ResolveNestedType { get; }
    internal static string TypeLoad_ResolveType { get; }
    internal static string TypeLoad_ResolveTypeFromAssembly { get; }
    internal static string UnauthorizedAccess_IODenied_NoPathName { get; }
    internal static string UnauthorizedAccess_IODenied_Path { get; }
    internal static string UnauthorizedAccess_MemStreamBuffer { get; }
    internal static string Verification_Exception { get; }
    internal static string Word_At { get; }
    internal static string DebugAssertBanner { get; }
    internal static string DebugAssertLongMessage { get; }
    internal static string DebugAssertShortMessage { get; }
    internal static string LockRecursionException_ReadAfterWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveReadNotAllowed { get; }
    internal static string LockRecursionException_RecursiveWriteNotAllowed { get; }
    internal static string LockRecursionException_RecursiveUpgradeNotAllowed { get; }
    internal static string LockRecursionException_WriteAfterReadNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedUpgrade { get; }
    internal static string SynchronizationLockException_MisMatchedRead { get; }
    internal static string SynchronizationLockException_IncorrectDispose { get; }
    internal static string LockRecursionException_UpgradeAfterReadNotAllowed { get; }
    internal static string LockRecursionException_UpgradeAfterWriteNotAllowed { get; }
    internal static string SynchronizationLockException_MisMatchedWrite { get; }
    internal static string NotSupported_SignatureType { get; }
    internal static string HashCode_HashCodeNotSupported { get; }
    internal static string HashCode_EqualityNotSupported { get; }
    internal static string Arg_TypeNotSupported { get; }
    internal static string IO_InvalidReadLength { get; }
    internal static string Arg_BasePathNotFullyQualified { get; }
    internal static string Argument_OverlapAlignmentMismatch { get; }
    internal static string Arg_MustBeNullTerminatedString { get; }
    internal static string ArgumentOutOfRange_Week_ISO { get; }
    internal static string Argument_BadPInvokeMethod { get; }
    internal static string Argument_BadPInvokeOnInterface { get; }
    internal static string Argument_BadTypeDef { get; }
    internal static string Argument_CannotExtractScalar { get; }
    internal static string Argument_CannotParsePrecision { get; }
    internal static string Argument_GWithPrecisionNotSupported { get; }
    internal static string Argument_PrecisionTooLarge { get; }
    internal static string Argument_PropertyClassUnmatchedWithConstructor { get; }
    internal static string Argument_PropertyInvalidType { get; }
    internal static string Argument_PropertyInvalidValue { get; }
    internal static string Argument_PropertyMissingSetter { get; }
    internal static string Argument_PropertyUnmatchingPropertyType { get; }
    internal static string Argument_StructArrayTooLarge { get; }
    internal static string IndexOutOfRange_ArrayWithOffset { get; }
    internal static string Serialization_DangerousDeserialization_Switch { get; }
    internal static string Argument_InvalidStartupHookSimpleAssemblyName { get; }
    internal static string Argument_StartupHookAssemblyLoadFailed { get; }
    internal static string InvalidOperation_InvalidHandle { get; }
    internal static string Argument_SpansMustHaveSameLength { get; }
    internal static string NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed { get; }
    internal static string GenericInvalidData { get; }
    internal static string Argument_ResourceScopeWrongDirection { get; }
    internal static string ArgumentNull_TypeRequiredByResourceScope { get; }
    internal static string Argument_BadResourceScopeTypeBits { get; }
    internal static string Argument_BadResourceScopeVisibilityBits { get; }
    internal static string Argument_EmptyString { get; }
    internal static string Argument_EmptyOrWhiteSpaceString { get; }
    internal static string Argument_FrameworkNameInvalid { get; }
    internal static string Argument_FrameworkNameInvalidVersion { get; }
    internal static string Argument_FrameworkNameMissingVersion { get; }
    internal static string Argument_FrameworkNameTooShort { get; }
    internal static string Arg_SwitchExpressionException { get; }
    internal static string Arg_ContextMarshalException { get; }
    internal static string Arg_AppDomainUnloadedException { get; }
    internal static string SwitchExpressionException_UnmatchedValue { get; }
    internal static string Encoding_UTF7_Disabled { get; }
    internal static string Arg_MustBeHalf { get; }
    internal static string Arg_MustBeRune { get; }
    internal static string BinaryFormatter_SerializationDisallowed { get; }
    internal static string ResourceManager_ReflectionNotAllowed { get; }
    internal static string InvalidOperation_AssemblyNotEditable { get; }
    internal static string InvalidOperation_EmptyQueue { get; }
    internal static string Arg_FileIsDirectory_Name { get; }
    internal static string Arg_InvalidFileAttrs { get; }
    internal static string Arg_InvalidUnixFileMode { get; }
    internal static string Arg_Path2IsRooted { get; }
    internal static string Argument_InvalidSubPath { get; }
    internal static string IO_CannotReplaceSameFile { get; }
    internal static string IO_NotAFile { get; }
    internal static string IO_SourceDestMustBeDifferent { get; }
    internal static string PlatformNotSupported_FileEncryption { get; }
    internal static string Arg_MemberInfoNotFound { get; }
    internal static string InvalidOperation_BadTZHeader { get; }
    internal static string InvalidOperation_ReadTZError { get; }
    internal static string InvalidOperation_BadIndexLength { get; }
    internal static string TimeZoneNotFound_ValidTimeZoneFileMissing { get; }
    internal static string NullabilityInfoContext_NotSupported { get; }
    internal static string ThreadState_Dead_State { get; }
    internal static string NullReference_InvokeNullRefReturned { get; }
    internal static string PlatformNotSupported_ReflectionEmit { get; }
    internal static string NotSupported_IncompleteTypes { get; }
    internal static string Security_InvalidAssemblyPublicKey { get; }
    internal static string ClassLoad_General { get; }
    internal static string ClassLoad_General_Hex { get; }
    internal static string ArgumentOutOfRange_NotGreaterThanBufferLength { get; }
    internal static string NoMetadataTokenAvailable { get; }
    internal static string ArgumentException_InvalidTypeArgument { get; }
    internal static string Argument_CannotBeByRefType { get; }
    internal static string CannotCreateByRefOfByRef { get; }
    internal static string CannotCreatePointerOfByRef { get; }
    internal static string TypeLoad_MethodOverrideNotVirtual { get; }
    internal static string Argument_DirectorySeparatorInvalid { get; }
    internal static string InvalidOperation_NotFunctionPointer { get; }
    internal static string NotSupported_ModifiedType { get; }
    internal static string Argument_UnexpectedStateForKnownCallback { get; }
    internal static string OutOfMemory_StringTooLong { get; }
    private static SR();
    private static string InternalGetResourceString(string key);
    internal static bool UsingResourceKeys();
    private static string GetResourceString(string resourceKey);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Acc_CreateAbstEx();
    internal static string get_Acc_CreateArgIterator();
    internal static string get_Acc_CreateGenericEx();
    internal static string get_Acc_CreateInterfaceEx();
    internal static string get_Acc_CreateVoid();
    internal static string get_Acc_NotClassInit();
    internal static string get_Acc_ReadOnly();
    internal static string get_Access_Void();
    internal static string get_AggregateException_ctor_DefaultMessage();
    internal static string get_AggregateException_ctor_InnerExceptionNull();
    internal static string get_AggregateException_DeserializationFailure();
    internal static string get_AggregateException_InnerException();
    internal static string get_AppDomain_Name();
    internal static string get_AppDomain_NoContextPolicies();
    internal static string get_AppDomain_Policy_PrincipalTwice();
    internal static string get_Arg_AccessException();
    internal static string get_Arg_AccessViolationException();
    internal static string get_Arg_AmbiguousImplementationException_NoMessage();
    internal static string get_Arg_AmbiguousMatchException_Attribute();
    internal static string get_Arg_AmbiguousMatchException_NoMessage();
    internal static string get_Arg_AmbiguousMatchException_MemberInfo();
    internal static string get_Arg_ApplicationException();
    internal static string get_Arg_ArgumentException();
    internal static string get_Arg_ArgumentOutOfRangeException();
    internal static string get_Arg_ArithmeticException();
    internal static string get_Arg_ArrayLengthsDiffer();
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_ByteArrayTooSmallForValue();
    internal static string get_Arg_ArrayTypeMismatchException();
    internal static string get_Arg_ArrayZeroError();
    internal static string get_Arg_BadDecimal();
    internal static string get_Arg_BadImageFormatException();
    internal static string get_Arg_BogusIComparer();
    internal static string get_Arg_BufferTooSmall();
    internal static string get_Arg_CannotBeNaN();
    internal static string get_Arg_CannotHaveNegativeValue();
    internal static string get_Arg_CannotMixComparisonInfrastructure();
    internal static string get_Arg_CannotUnloadAppDomainException();
    internal static string get_Arg_COMException();
    internal static string get_Arg_CreatInstAccess();
    internal static string get_Arg_CryptographyException();
    internal static string get_Arg_CustomAttributeFormatException();
    internal static string get_Arg_DataMisalignedException();
    internal static string get_Arg_DecBitCtor();
    internal static string get_Arg_DirectoryNotFoundException();
    internal static string get_Arg_DivideByZero();
    internal static string get_Arg_DlgtTargMeth();
    internal static string get_Arg_DlgtTypeMis();
    internal static string get_Arg_DllNotFoundException();
    internal static string get_Arg_DllNameCannotBeEmpty();
    internal static string get_Arg_DuplicateWaitObjectException();
    internal static string get_Arg_EHClauseNotFilter();
    internal static string get_Arg_EmptyArray();
    internal static string get_Arg_EmptySpan();
    internal static string get_Arg_EndOfStreamException();
    internal static string get_Arg_EntryPointNotFoundException();
    internal static string get_Arg_EnumAndObjectMustBeSameType();
    internal static string get_Arg_EnumFormatUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_EnumUnderlyingTypeAndObjectMustBeSameType();
    internal static string get_Arg_EnumValueNotFound();
    internal static string get_Arg_ExecutionEngineException();
    internal static string get_Arg_ExternalException();
    internal static string get_Arg_EnC_ExpectedPrimitive();
    internal static string get_Arg_FieldAccessException();
    internal static string get_Arg_FieldDeclTarget();
    internal static string get_Arg_FldGetArgErr();
    internal static string get_Arg_FldGetPropSet();
    internal static string get_Arg_FldSetArgErr();
    internal static string get_Arg_FldSetGet();
    internal static string get_Arg_FldSetInvoke();
    internal static string get_Arg_FldSetPropGet();
    internal static string get_Arg_FormatException();
    internal static string get_Arg_GenericArgumentsAfterArrayOrPointerType();
    internal static string get_Arg_GenericParameter();
    internal static string get_Arg_GetMethNotFnd();
    internal static string get_Arg_GuidArrayCtor();
    internal static string get_Arg_HandleNotAsync();
    internal static string get_Arg_HandleNotSync();
    internal static string get_Arg_HexBinaryStylesNotSupported();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_IndexMustBeInt();
    internal static string get_Arg_IndexOutOfRangeException();
    internal static string get_Arg_InsufficientExecutionStackException();
    internal static string get_Arg_InvalidBase();
    internal static string get_Arg_InvalidCastException();
    internal static string get_Arg_InvalidComObjectException();
    internal static string get_Arg_InvalidFilterCriteriaException();
    internal static string get_Arg_InvalidHandle();
    internal static string get_Arg_InvalidHexBinaryStyle();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_Asm_Culture();
    internal static string get_Arg_InvalidNeutralResourcesLanguage_FallbackLoc();
    internal static string get_Arg_InvalidSatelliteContract_Asm_Ver();
    internal static string get_Arg_InvalidOleVariantTypeException();
    internal static string get_Arg_InvalidOperationException();
    internal static string get_Arg_InvalidTypeInRetType();
    internal static string get_Arg_InvalidTypeInSignature();
    internal static string get_Arg_IOException();
    internal static string get_Arg_KeyNotFound();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanDestArray();
    internal static string get_Arg_LongerThanSrcArray();
    internal static string get_Arg_LongerThanSrcString();
    internal static string get_Arg_LowerBoundsMustMatch();
    internal static string get_Arg_MarshalDirectiveException();
    internal static string get_Arg_MethodAccessException();
    internal static string get_Arg_MissingFieldException();
    internal static string get_Arg_MissingManifestResourceException();
    internal static string get_Arg_MissingMemberException();
    internal static string get_Arg_MissingMethodException();
    internal static string get_Arg_MulticastNotSupportedException();
    internal static string get_Arg_MustBeBoolean();
    internal static string get_Arg_MustBeByte();
    internal static string get_Arg_MustBeChar();
    internal static string get_Arg_MustBeDateOnly();
    internal static string get_Arg_MustBeTimeOnly();
    internal static string get_Arg_MustBeDateTime();
    internal static string get_Arg_MustBeDateTimeOffset();
    internal static string get_Arg_MustBeDecimal();
    internal static string get_Arg_MustBeDelegate();
    internal static string get_Arg_MustBeDouble();
    internal static string get_Arg_MustBeEnum();
    internal static string get_Arg_MustBeEnumBaseTypeOrEnum();
    internal static string get_Arg_MustBeGuid();
    internal static string get_Arg_MustBeInt16();
    internal static string get_Arg_MustBeInt32();
    internal static string get_Arg_MustBeInt64();
    internal static string get_Arg_MustBeInt128();
    internal static string get_Arg_MustBeIntPtr();
    internal static string get_Arg_MustBeInterface();
    internal static string get_Arg_MustBeNFloat();
    internal static string get_Arg_MustBePointer();
    internal static string get_Arg_MustBePrimArray();
    internal static string get_Arg_MustBeRuntimeAssembly();
    internal static string get_Arg_MustBeSByte();
    internal static string get_Arg_MustBeSingle();
    internal static string get_Arg_MustBeString();
    internal static string get_Arg_MustBeTimeSpan();
    internal static string get_Arg_MustBeType();
    internal static string get_Arg_MustBeTrue();
    internal static string get_Arg_MustBeUInt16();
    internal static string get_Arg_MustBeUInt32();
    internal static string get_Arg_MustBeUInt64();
    internal static string get_Arg_MustBeUInt128();
    internal static string get_Arg_MustBeUIntPtr();
    internal static string get_Arg_MustBeVersion();
    internal static string get_Arg_MustContainEnumInfo();
    internal static string get_Arg_NamedParamNull();
    internal static string get_Arg_NamedParamTooBig();
    internal static string get_Arg_Need1DArray();
    internal static string get_Arg_Need2DArray();
    internal static string get_Arg_Need3DArray();
    internal static string get_Arg_NeedAtLeast1Rank();
    internal static string get_Arg_NoAccessSpec();
    internal static string get_Arg_NoDefCTorWithoutTypeName();
    internal static string get_Arg_NoDefCTor();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_NoStaticVirtual();
    internal static string get_Arg_NotFiniteNumberException();
    internal static string get_Arg_NotFoundIFace();
    internal static string get_Arg_NotGenericMethodDefinition();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_NotGenericTypeDefinition();
    internal static string get_Arg_NotImplementedException();
    internal static string get_Arg_NotSupportedException();
    internal static string get_Arg_NullReferenceException();
    internal static string get_Arg_ObjObjEx();
    internal static string get_Arg_OleAutDateInvalid();
    internal static string get_Arg_OleAutDateScale();
    internal static string get_Arg_OverflowException();
    internal static string get_Arg_OutOfMemoryException();
    internal static string get_Arg_ParamName_Name();
    internal static string get_Arg_ParmArraySize();
    internal static string get_Arg_ParmCnt();
    internal static string get_Arg_PathEmpty();
    internal static string get_Arg_PlatformNotSupported();
    internal static string get_Arg_PropSetGet();
    internal static string get_Arg_PropSetInvoke();
    internal static string get_Arg_RankException();
    internal static string get_Arg_RankIndices();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_RanksAndBounds();
    internal static string get_Arg_ResMgrNotResSet();
    internal static string get_Arg_ResourceFileUnsupportedVersion();
    internal static string get_Arg_ResourceNameNotExist();
    internal static string get_Arg_SafeArrayRankMismatchException();
    internal static string get_Arg_SafeArrayTypeMismatchException();
    internal static string get_Arg_SecurityException();
    internal static string get_SerializationException();
    internal static string get_Arg_SetMethNotFnd();
    internal static string get_Arg_StackOverflowException();
    internal static string get_Arg_SurrogatesNotAllowedAsSingleChar();
    internal static string get_Arg_SynchronizationLockException();
    internal static string get_Arg_SystemException();
    internal static string get_Arg_TargetInvocationException();
    internal static string get_Arg_TargetParameterCountException();
    internal static string get_Arg_ThreadStartException();
    internal static string get_Arg_ThreadStateException();
    internal static string get_Arg_TimeoutException();
    internal static string get_Arg_TypeAccessException();
    internal static string get_Arg_TypedReference_Null();
    internal static string get_Arg_TypeLoadException();
    internal static string get_Arg_TypeLoadNullStr();
    internal static string get_Arg_TypeRefPrimitive();
    internal static string get_Arg_TypeUnloadedException();
    internal static string get_Arg_UnauthorizedAccessException();
    internal static string get_Arg_UnboundGenField();
    internal static string get_Arg_UnboundGenParam();
    internal static string get_Arg_UnknownTypeCode();
    internal static string get_Arg_UnreachableException();
    internal static string get_Arg_VarMissNull();
    internal static string get_Arg_VersionString();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AbsolutePathRequired();
    internal static string get_Argument_AddingDuplicate();
    internal static string get_Argument_AddingDuplicate__();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_AdjustmentRulesNoNulls();
    internal static string get_Argument_AdjustmentRulesOutOfOrder();
    internal static string get_Argument_AlignmentMustBePow2();
    internal static string get_Argument_ArraysInvalid();
    internal static string get_Argument_ArrayParsingError();
    internal static string get_Argument_AttributeNamesMustBeUnique();
    internal static string get_Argument_BadConstructor();
    internal static string get_Argument_BadExceptionCodeGen();
    internal static string get_Argument_BadFieldType();
    internal static string get_Argument_BadFormatSpecifier();
    internal static string get_Argument_BadParameterCountsForConstructor();
    internal static string get_Argument_BadParameterTypeForCAB();
    internal static string get_Argument_BadSigFormat();
    internal static string get_Argument_BadSizeForData();
    internal static string get_Argument_ByrefQualifierMustBeLastOneOfAType();
    internal static string get_Argument_CannotSetParentToInterface();
    internal static string get_Argument_CodepageNotSupported();
    internal static string get_Argument_CompareOptionOrdinal();
    internal static string get_Argument_ConflictingDateTimeRoundtripStyles();
    internal static string get_Argument_ConflictingDateTimeStyles();
    internal static string get_Argument_ConstantDoesntMatch();
    internal static string get_Argument_ConstantNotSupported();
    internal static string get_Argument_ConstructorNeedGenericDeclaringType();
    internal static string get_Argument_ConversionOverflow();
    internal static string get_Argument_ConvertMismatch();
    internal static string get_Argument_CultureIetfNotSupported();
    internal static string get_Argument_CultureInvalidIdentifier();
    internal static string get_Argument_CultureIsNeutral();
    internal static string get_Argument_CultureNotSupported();
    internal static string get_Argument_CultureNotSupportedInInvariantMode();
    internal static string get_Argument_CustomAssemblyLoadContextRequestedNameMismatch();
    internal static string get_Argument_CustomCultureCannotBePassedByNumber();
    internal static string get_Argument_CustomModifierLengthInvalidLength();
    internal static string get_Argument_DateTimeBadBinaryData();
    internal static string get_Argument_DateTimeHasTicks();
    internal static string get_Argument_DateTimeHasTimeOfDay();
    internal static string get_Argument_DateTimeIsInvalid();
    internal static string get_Argument_DateTimeIsNotAmbiguous();
    internal static string get_Argument_DateTimeKindMustBeUnspecified();
    internal static string get_Argument_DateTimeKindMustBeUnspecifiedOrUtc();
    internal static string get_Argument_DateTimeOffsetInvalidDateTimeStyles();
    internal static string get_Argument_DateTimeOffsetIsNotAmbiguous();
    internal static string get_Argument_DestinationTooShort();
    internal static string get_Argument_DuplicateTypeName();
    internal static string get_Argument_EmitWriteLineType();
    internal static string get_Argument_EmptyName();
    internal static string get_Argument_EmptyWaithandleArray();
    internal static string get_Argument_EncoderFallbackNotEmpty();
    internal static string get_Argument_EncodingConversionOverflowBytes();
    internal static string get_Argument_EncodingConversionOverflowChars();
    internal static string get_Argument_EncodingNotSupported();
    internal static string get_Argument_EnumTypeDoesNotMatch();
    internal static string get_Argument_FallbackBufferNotEmpty();
    internal static string get_Argument_FieldDoesNotBelongToConstructorClass();
    internal static string get_Argument_FieldDoesNotHaveAValidType();
    internal static string get_Argument_FieldDoesNotHaveAValidValue();
    internal static string get_Argument_FieldPropertyEventAndTypeHandleIncompatibility();
    internal static string get_Argument_FieldNeedGenericDeclaringType();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_GenericArgumentCannotBeByrefOrPointerType();
    internal static string get_Argument_GenericParsingError();
    internal static string get_Argument_OpenGenericTypeNotPermitted();
    internal static string get_Argument_GlobalMembersMustBeStatic();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_Argument_IdnBadBidi();
    internal static string get_Argument_IdnBadLabelSize();
    internal static string get_Argument_IdnBadNameSize();
    internal static string get_Argument_IdnBadPunycode();
    internal static string get_Argument_IdnBadStd3();
    internal static string get_Argument_IdnIllegalName();
    internal static string get_Argument_IllegalEnvVarName();
    internal static string get_Argument_ImplementIComparable();
    internal static string get_Argument_InterfaceMap();
    internal static string get_Argument_InvalidAppendMode();
    internal static string get_Argument_InvalidPreallocateAccess();
    internal static string get_Argument_InvalidPreallocateMode();
    internal static string get_Argument_InvalidUnixCreateMode();
    internal static string get_Argument_InvalidArgumentForComparison();
    internal static string get_Argument_InvalidArrayLength();
    internal static string get_Argument_MultiDimensionalArrayCannotBeBound();
    internal static string get_Argument_IncompatibleArrayType();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_InvalidAssemblyName();
    internal static string get_Argument_InvalidCalendar();
    internal static string get_Argument_InvalidCharInArraySpecification();
    internal static string get_Argument_InvalidCharSequence();
    internal static string get_Argument_InvalidCharSequenceNoIndex();
    internal static string get_Argument_InvalidCodePageBytesIndex();
    internal static string get_Argument_InvalidCodePageConversionIndex();
    internal static string get_Argument_InvalidConstructorDeclaringType();
    internal static string get_Argument_InvalidCultureName();
    internal static string get_Argument_InvalidPredefinedCultureName();
    internal static string get_Argument_InvalidDateTimeKind();
    internal static string get_Argument_InvalidDateTimeStyles();
    internal static string get_Argument_InvalidDateStyles();
    internal static string get_Argument_InvalidDigitSubstitution();
    internal static string get_Argument_InvalidElementName();
    internal static string get_Argument_InvalidElementTag();
    internal static string get_Argument_InvalidElementText();
    internal static string get_Argument_InvalidElementValue();
    internal static string get_Argument_InvalidEnum();
    internal static string get_Argument_InvalidEnumValue();
    internal static string get_Argument_InvalidFieldDeclaringType();
    internal static string get_Argument_InvalidFileModeAndAccessCombo();
    internal static string get_Argument_InvalidFlag();
    internal static string get_Argument_InvalidGenericArg();
    internal static string get_Argument_InvalidGenericArgumentsSeparator();
    internal static string get_Argument_InvalidGroupSize();
    internal static string get_Argument_InvalidHandle();
    internal static string get_Argument_InvalidHighSurrogate();
    internal static string get_Argument_InvalidId();
    internal static string get_Argument_InvalidKindOfTypeForCA();
    internal static string get_Argument_InvalidLabel();
    internal static string get_Argument_InvalidLowSurrogate();
    internal static string get_Argument_InvalidMemberForNamedArgument();
    internal static string get_Argument_InvalidMethodDeclaringType();
    internal static string get_Argument_InvalidName();
    internal static string get_Argument_InvalidNativeDigitCount();
    internal static string get_Argument_InvalidNativeDigitValue();
    internal static string get_Argument_InvalidNeutralRegionName();
    internal static string get_Argument_InvalidNormalizationForm();
    internal static string get_Argument_InvalidNumberStyles();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOpCodeOnDynamicMethod();
    internal static string get_Argument_NullCharInPath();
    internal static string get_Argument_InvalidResourceCultureName();
    internal static string get_Argument_InvalidSafeBufferOffLen();
    internal static string get_Argument_InvalidSeekOrigin();
    internal static string get_Argument_InvalidSerializedString();
    internal static string get_Argument_InvalidStartupHookSignature();
    internal static string get_Argument_InvalidTimeSpanStyles();
    internal static string get_Argument_InvalidToken();
    internal static string get_Argument_InvalidTypeForDynamicMethod();
    internal static string get_Argument_InvalidTypeName();
    internal static string get_Argument_InvalidTypeWithPointersNotSupported();
    internal static string get_Argument_InvalidUnity();
    internal static string get_Argument_LabelUnmarked();
    internal static string get_Argument_MethodBodyMustBelongToType();
    internal static string get_Argument_MethodDeclaringTypeGeneric();
    internal static string get_Argument_MethodNeedGenericDeclaringType();
    internal static string get_Argument_MinMaxValue();
    internal static string get_Argument_MismatchedArrays();
    internal static string get_Argument_MustBeFalse();
    internal static string get_Argument_MustBeRuntimeAssembly();
    internal static string get_Argument_MustBeRuntimeFieldInfo();
    internal static string get_Argument_MustBeRuntimeConstructorInfo();
    internal static string get_Argument_MustBeRuntimeMethodInfo();
    internal static string get_Argument_MustBeRuntimeMethod();
    internal static string get_Argument_MustBeRuntimeType();
    internal static string get_Argument_MustBeTypeBuilder();
    internal static string get_Argument_MustHaveAttributeBaseClass();
    internal static string get_Argument_NativeOverlappedAlreadyFree();
    internal static string get_Argument_NativeOverlappedWrongBoundHandle();
    internal static string get_Argument_NeedGenericMethodDefinition();
    internal static string get_Argument_NeedNonGenericType();
    internal static string get_Argument_NeedStructWithNoRefs();
    internal static string get_Argument_NegativeFieldOffsetNotPermitted();
    internal static string get_Argument_NeverValidGenericArgument();
    internal static string get_Argument_NoEra();
    internal static string get_Argument_NoRegionInvariantCulture();
    internal static string get_Argument_NotEnoughBytesToRead();
    internal static string get_Argument_NotEnoughBytesToWrite();
    internal static string get_Argument_NotEnoughGenArguments();
    internal static string get_Argument_NotExceptionType();
    internal static string get_Argument_NotInExceptionBlock();
    internal static string get_Argument_NotMethodCallOpcode();
    internal static string get_Argument_OffsetAndCapacityOutOfBounds();
    internal static string get_Argument_OffsetLocalMismatch();
    internal static string get_Argument_OffsetOutOfRange();
    internal static string get_Argument_OffsetPrecision();
    internal static string get_Argument_OffsetUtcMismatch();
    internal static string get_Argument_OneOfCulturesNotSupported();
    internal static string get_Argument_OnlyMscorlib();
    internal static string get_Argument_OutOfOrderDateTimes();
    internal static string get_Argument_PathEmpty();
    internal static string get_Argument_ParameterHasUnmatchedArgumentValue();
    internal static string get_Argument_ParameterInvalidType();
    internal static string get_Argument_ParameterInvalidValue();
    internal static string get_Argument_TypeParseError();
    internal static string get_Argument_PreAllocatedAlreadyAllocated();
    internal static string get_Argument_RecursiveFallback();
    internal static string get_Argument_RecursiveFallbackBytes();
    internal static string get_Argument_RedefinedLabel();
    internal static string get_Argument_ResolveType();
    internal static string get_Argument_ResultCalendarRange();
    internal static string get_Argument_SemaphoreInitialMaximum();
    internal static string get_Argument_ShouldNotSpecifyExceptionType();
    internal static string get_Argument_ShouldOnlySetVisibilityFlags();
    internal static string get_Argument_StreamNotReadable();
    internal static string get_Argument_StreamNotWritable();
    internal static string get_Argument_StringFirstCharIsZero();
    internal static string get_Argument_TimeSpanHasSeconds();
    internal static string get_Argument_TimeZoneInfoBadTZif();
    internal static string get_Argument_TimeZoneInfoInvalidTZif();
    internal static string get_Argument_ToExclusiveLessThanFromExclusive();
    internal static string get_Argument_TransitionTimesAreIdentical();
    internal static string get_Argument_TypedReferenceInvalidField();
    internal static string get_Argument_TypeMustNotBeComImport();
    internal static string get_Argument_UnclosedAssemblyQualifiedTypeName();
    internal static string get_Argument_UnmanagedMemAccessorWrapAround();
    internal static string get_Argument_UnmanagedTypeOnlyValidOnFields();
    internal static string get_Argument_UnmatchedFieldValueAndType();
    internal static string get_Argument_UnmatchedMethodForLocal();
    internal static string get_Argument_UnmatchedSquareBracketWhileParsingGenericArgAssemblyName();
    internal static string get_Argument_UTCOutOfRange();
    internal static string get_ArgumentException_BufferNotFromPool();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_ArgumentException_NotIsomorphic();
    internal static string get_ArgumentException_TupleIncorrectType();
    internal static string get_ArgumentException_TupleLastArgumentNotATuple();
    internal static string get_ArgumentException_ValueTupleIncorrectType();
    internal static string get_ArgumentException_ValueTupleLastArgumentNotAValueTuple();
    internal static string get_ArgumentNull_Array();
    internal static string get_ArgumentNull_ArrayElement();
    internal static string get_ArgumentNull_ArrayValue();
    internal static string get_ArgumentNull_Child();
    internal static string get_ArgumentNull_Generic();
    internal static string get_ArgumentNull_SafeHandle();
    internal static string get_ArgumentNull_String();
    internal static string get_ArgumentOutOfRange_ActualValue();
    internal static string get_ArgumentOutOfRange_AddValue();
    internal static string get_ArgumentOutOfRange_ArrayLB();
    internal static string get_ArgumentOutOfRange_BadHourMinuteSecond();
    internal static string get_ArgumentOutOfRange_BadYearMonthDay();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_BinaryReaderFillBuffer();
    internal static string get_ArgumentOutOfRange_Bounds_Lower_Upper();
    internal static string get_ArgumentOutOfRange_CalendarRange();
    internal static string get_ArgumentOutOfRange_Capacity();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_DateArithmetic();
    internal static string get_ArgumentOutOfRange_DateTimeBadMonths();
    internal static string get_ArgumentOutOfRange_DateTimeBadTicks();
    internal static string get_ArgumentOutOfRange_TimeOnlyBadTicks();
    internal static string get_ArgumentOutOfRange_DateTimeBadYears();
    internal static string get_ArgumentOutOfRange_Day();
    internal static string get_ArgumentOutOfRange_DayOfWeek();
    internal static string get_ArgumentOutOfRange_DayParam();
    internal static string get_ArgumentOutOfRange_DecimalRound();
    internal static string get_ArgumentOutOfRange_EndIndexStartIndex();
    internal static string get_ArgumentOutOfRange_Enum();
    internal static string get_ArgumentOutOfRange_Era();
    internal static string get_ArgumentOutOfRange_FileLengthTooBig();
    internal static string get_ArgumentOutOfRange_FileTimeInvalid();
    internal static string get_ArgumentOutOfRange_GetByteCountOverflow();
    internal static string get_ArgumentOutOfRange_GetCharCountOverflow();
    internal static string get_ArgumentOutOfRange_HashtableLoadFactor();
    internal static string get_ArgumentOutOfRange_HugeArrayNotSupported();
    internal static string get_ArgumentOutOfRange_IndexMustBeLess();
    internal static string get_ArgumentOutOfRange_IndexMustBeLessOrEqual();
    internal static string get_ArgumentOutOfRange_IndexCount();
    internal static string get_ArgumentOutOfRange_IndexCountBuffer();
    internal static string get_ArgumentOutOfRange_IndexLength();
    internal static string get_ArgumentOutOfRange_IndexString();
    internal static string get_ArgumentOutOfRange_InvalidEraValue();
    internal static string get_ArgumentOutOfRange_InvalidHighSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidLowSurrogate();
    internal static string get_ArgumentOutOfRange_InvalidUTF32();
    internal static string get_ArgumentOutOfRange_LengthGreaterThanCapacity();
    internal static string get_ArgumentOutOfRange_LessEqualToIntegerMaxVal();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_Month();
    internal static string get_ArgumentOutOfRange_DayNumber();
    internal static string get_ArgumentOutOfRange_MonthParam();
    internal static string get_ArgumentOutOfRange_MustBeNonNegNum();
    internal static string get_ArgumentOutOfRange_MustBePositive();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedNonNegOrNegative1();
    internal static string get_ArgumentOutOfRange_NeedValidId();
    internal static string get_ArgumentOutOfRange_OffsetLength();
    internal static string get_ArgumentOutOfRange_OffsetOut();
    internal static string get_ArgumentOutOfRange_ParamSequence();
    internal static string get_ArgumentOutOfRange_PartialWCHAR();
    internal static string get_ArgumentOutOfRange_PositionLessThanCapacityRequired();
    internal static string get_ArgumentOutOfRange_Range();
    internal static string get_ArgumentOutOfRange_RoundingDigits();
    internal static string get_ArgumentOutOfRange_RoundingDigits_MathF();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_ArgumentOutOfRange_StartIndex();
    internal static string get_ArgumentOutOfRange_StartIndexLargerThanLength();
    internal static string get_ArgumentOutOfRange_StreamLength();
    internal static string get_ArgumentOutOfRange_UIntPtrMax();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamLength();
    internal static string get_ArgumentOutOfRange_UnmanagedMemStreamWrapAround();
    internal static string get_ArgumentOutOfRange_UtcOffset();
    internal static string get_ArgumentOutOfRange_UtcOffsetAndDaylightDelta();
    internal static string get_ArgumentOutOfRange_Week();
    internal static string get_ArgumentOutOfRange_Year();
    internal static string get_ArgumentOutOfRange_Generic_MustBeNonZero();
    internal static string get_ArgumentOutOfRange_Generic_MustBeNonNegative();
    internal static string get_ArgumentOutOfRange_Generic_MustBeNonNegativeNonZero();
    internal static string get_ArgumentOutOfRange_Generic_MustBeLessOrEqual();
    internal static string get_ArgumentOutOfRange_Generic_MustBeLess();
    internal static string get_ArgumentOutOfRange_Generic_MustBeGreaterOrEqual();
    internal static string get_ArgumentOutOfRange_Generic_MustBeGreater();
    internal static string get_ArgumentOutOfRange_Generic_MustBeEqual();
    internal static string get_ArgumentOutOfRange_Generic_MustBeNotEqual();
    internal static string get_Arithmetic_NaN();
    internal static string get_ArrayTypeMismatch_CantAssignType();
    internal static string get_AssemblyLoadContext_Unload_CannotUnloadIfNotCollectible();
    internal static string get_AssemblyLoadContext_Verify_NotUnloading();
    internal static string get_AssertionFailed();
    internal static string get_AssertionFailed_Cnd();
    internal static string get_AssumptionFailed();
    internal static string get_AssumptionFailed_Cnd();
    internal static string get_AsyncMethodBuilder_InstanceNotInitialized();
    internal static string get_BadImageFormat_BadILFormat();
    internal static string get_BadImageFormat_InvalidType();
    internal static string get_BadImageFormat_NegativeStringLength();
    internal static string get_BadImageFormat_ResType_SerBlobMismatch();
    internal static string get_BadImageFormat_ResourceDataLengthInvalid();
    internal static string get_BadImageFormat_ResourceNameCorrupted();
    internal static string get_BadImageFormat_ResourceNameCorrupted_NameIndex();
    internal static string get_BadImageFormat_ResourcesDataInvalidOffset();
    internal static string get_BadImageFormat_ResourcesHeaderCorrupted();
    internal static string get_BadImageFormat_ResourcesIndexTooLong();
    internal static string get_BadImageFormat_ResourcesNameInvalidOffset();
    internal static string get_BadImageFormat_ResourcesNameTooLong();
    internal static string get_BadImageFormat_TypeMismatch();
    internal static string get_CancellationToken_CreateLinkedToken_TokensIsEmpty();
    internal static string get_CancellationTokenSource_Disposed();
    internal static string get_ConcurrentCollection_SyncRoot_NotSupported();
    internal static string get_CustomMarshaler_MultipleGetInstanceMethods();
    internal static string get_CustomMarshaler_NoGetInstanceMethod();
    internal static string get_CustomMarshaler_UnassignedGenericParams();
    internal static string get_CustomMarshaler_NullReturnForGetInstance();
    internal static string get_EventSource_AbstractMustNotDeclareEventMethods();
    internal static string get_EventSource_AbstractMustNotDeclareKTOC();
    internal static string get_EventSource_AddScalarOutOfRange();
    internal static string get_EventSource_BadHexDigit();
    internal static string get_EventSource_ChannelTypeDoesNotMatchEventChannelValue();
    internal static string get_EventSource_CouldNotEnableEventPipe();
    internal static string get_EventSource_DataDescriptorsOutOfRange();
    internal static string get_EventSource_DuplicateStringKey();
    internal static string get_EventSource_EnumKindMismatch();
    internal static string get_EventSource_EvenHexDigits();
    internal static string get_EventSource_EventChannelOutOfRange();
    internal static string get_EventSource_EventIdReused();
    internal static string get_EventSource_EventMustHaveTaskIfNonDefaultOpcode();
    internal static string get_EventSource_EventMustNotBeExplicitImplementation();
    internal static string get_EventSource_EventNameReused();
    internal static string get_EventSource_EventParametersMismatch();
    internal static string get_EventSource_EventSourceGuidInUse();
    internal static string get_EventSource_EventTooBig();
    internal static string get_EventSource_EventWithAdminChannelMustHaveMessage();
    internal static string get_EventSource_IllegalKeywordsValue();
    internal static string get_EventSource_IllegalOpcodeValue();
    internal static string get_EventSource_IllegalTaskValue();
    internal static string get_EventSource_IllegalValue();
    internal static string get_EventSource_IncorrentlyAuthoredTypeInfo();
    internal static string get_EventSource_InvalidCommand();
    internal static string get_EventSource_InvalidEventFormat();
    internal static string get_EventSource_KeywordCollision();
    internal static string get_EventSource_KeywordNeedPowerOfTwo();
    internal static string get_EventSource_ListenerCreatedInsideCallback();
    internal static string get_EventSource_ListenerNotFound();
    internal static string get_EventSource_ListenerWriteFailure();
    internal static string get_EventSource_MaxChannelExceeded();
    internal static string get_EventSource_MismatchIdToWriteEvent();
    internal static string get_EventSource_NeedGuid();
    internal static string get_EventSource_NeedName();
    internal static string get_EventSource_NeedPositiveId();
    internal static string get_EventSource_NoFreeBuffers();
    internal static string get_EventSource_NonCompliantTypeError();
    internal static string get_EventSource_NoRelatedActivityId();
    internal static string get_EventSource_NotSupportedArrayOfBinary();
    internal static string get_EventSource_NotSupportedArrayOfNil();
    internal static string get_EventSource_NotSupportedArrayOfNullTerminatedString();
    internal static string get_EventSource_NotSupportedNestedArraysEnums();
    internal static string get_EventSource_NullInput();
    internal static string get_EventSource_OpcodeCollision();
    internal static string get_EventSource_PinArrayOutOfRange();
    internal static string get_EventSource_RecursiveTypeDefinition();
    internal static string get_EventSource_StopsFollowStarts();
    internal static string get_EventSource_TaskCollision();
    internal static string get_EventSource_TaskOpcodePairReused();
    internal static string get_EventSource_TooManyArgs();
    internal static string get_EventSource_TooManyFields();
    internal static string get_EventSource_ToString();
    internal static string get_EventSource_TraitEven();
    internal static string get_EventSource_TypeMustBeSealedOrAbstract();
    internal static string get_EventSource_TypeMustDeriveFromEventSource();
    internal static string get_EventSource_UndefinedChannel();
    internal static string get_EventSource_UndefinedKeyword();
    internal static string get_EventSource_UndefinedOpcode();
    internal static string get_EventSource_UnknownEtwTrait();
    internal static string get_EventSource_UnsupportedEventTypeInManifest();
    internal static string get_EventSource_UnsupportedMessageProperty();
    internal static string get_EventSource_VarArgsParameterMismatch();
    internal static string get_Exception_EmptyFieldForCustomAttributeType();
    internal static string get_Exception_EndOfInnerExceptionStack();
    internal static string get_Exception_EndStackTraceFromPreviousThrow();
    internal static string get_Exception_InvalidCustomAttributeLength();
    internal static string get_Exception_InvalidProlog();
    internal static string get_Exception_UnknownNamedType();
    internal static string get_Exception_UnknownMarshalAsAttributeField();
    internal static string get_Exception_UnhandledSubType();
    internal static string get_Exception_WasThrown();
    internal static string get_ExecutionContext_ExceptionInAsyncLocalNotification();
    internal static string get_FileNotFound_ResolveAssembly();
    internal static string get_FileNotFound_LoadFile();
    internal static string get_Format_AttributeUsage();
    internal static string get_Format_Bad7BitInt();
    internal static string get_Format_BadBase64Char();
    internal static string get_Format_BadBoolean();
    internal static string get_Format_BadDatePattern();
    internal static string get_Format_BadDateTime();
    internal static string get_Format_BadDateOnly();
    internal static string get_Format_BadTimeOnly();
    internal static string get_Format_DateTimeOnlyContainsNoneDateParts();
    internal static string get_Format_BadDateTimeCalendar();
    internal static string get_Format_BadDayOfWeek();
    internal static string get_Format_BadFormatSpecifier();
    internal static string get_Format_NoFormatSpecifier();
    internal static string get_Format_BadHexChar();
    internal static string get_Format_BadHexLength();
    internal static string get_Format_BadQuote();
    internal static string get_Format_BadTimeSpan();
    internal static string get_Format_DateOutOfRange();
    internal static string get_Format_EmptyInputString();
    internal static string get_Format_ExtraJunkAtEnd();
    internal static string get_Format_GuidBrace();
    internal static string get_Format_GuidBraceAfterLastNumber();
    internal static string get_Format_GuidComma();
    internal static string get_Format_GuidDashes();
    internal static string get_Format_GuidEndBrace();
    internal static string get_Format_GuidHexPrefix();
    internal static string get_Format_GuidInvalidChar();
    internal static string get_Format_GuidInvLen();
    internal static string get_Format_GuidUnrecognized();
    internal static string get_Format_IndexOutOfRange();
    internal static string get_Format_InvalidEnumFormatSpecification();
    internal static string get_Format_InvalidGuidFormatSpecification();
    internal static string get_Format_InvalidString();
    internal static string get_Format_InvalidStringWithValue();
    internal static string get_Format_InvalidStringWithOffsetAndReason();
    internal static string get_Format_UnexpectedClosingBrace();
    internal static string get_Format_UnclosedFormatItem();
    internal static string get_Format_ExpectedAsciiDigit();
    internal static string get_Format_MissingIncompleteDate();
    internal static string get_Format_NeedSingleChar();
    internal static string get_Format_NoParsibleDigits();
    internal static string get_Format_OffsetOutOfRange();
    internal static string get_Format_RepeatDateTimePattern();
    internal static string get_Format_StringZeroLength();
    internal static string get_Format_UnknownDateTimeWord();
    internal static string get_Format_UTCOutOfRange();
    internal static string get_Globalization_cp_1200();
    internal static string get_Globalization_cp_12000();
    internal static string get_Globalization_cp_12001();
    internal static string get_Globalization_cp_1201();
    internal static string get_Globalization_cp_20127();
    internal static string get_Globalization_cp_28591();
    internal static string get_Globalization_cp_65000();
    internal static string get_Globalization_cp_65001();
    internal static string get_IndexOutOfRange_UMSPosition();
    internal static string get_InsufficientMemory_MemFailPoint();
    internal static string get_InsufficientMemory_MemFailPoint_TooBig();
    internal static string get_InsufficientMemory_MemFailPoint_VAFrag();
    internal static string get_InvalidCast_CannotCastNullToValueType();
    internal static string get_InvalidCast_DBNull();
    internal static string get_InvalidCast_DownCastArrayElement();
    internal static string get_InvalidCast_Empty();
    internal static string get_InvalidCast_FromDBNull();
    internal static string get_InvalidCast_FromTo();
    internal static string get_InvalidCast_IConvertible();
    internal static string get_InvalidOperation_AbstractMethod();
    internal static string get_InvalidOperation_AsyncFlowCtrlCtxMismatch();
    internal static string get_InvalidOperation_AsyncIOInProgress();
    internal static string get_InvalidOperation_BadEmptyMethodBody();
    internal static string get_InvalidOperation_BadInstructionOrIndexOutOfBound();
    internal static string get_InvalidOperation_BadInterfaceNotAbstract();
    internal static string get_InvalidOperation_BadInterfaceNotAbstractAndVirtual();
    internal static string get_InvalidOperation_CalledTwice();
    internal static string get_InvalidOperation_CannotRegisterSecondResolver();
    internal static string get_InvalidOperation_CannotRestoreUnsuppressedFlow();
    internal static string get_InvalidOperation_CannotUseAFCOtherThread();
    internal static string get_InvalidOperation_CollectionCorrupted();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_DateTimeParsing();
    internal static string get_InvalidOperation_EnumEnded();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumNotStarted();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_GlobalsHaveBeenCreated();
    internal static string get_InvalidOperation_HandleIsNotInitialized();
    internal static string get_InvalidOperation_HandleIsNotPinned();
    internal static string get_InvalidOperation_InvalidUtf8();
    internal static string get_InvalidOperation_HashInsertFailed();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_InvalidOperation_MethodBaked();
    internal static string get_InvalidOperation_ModuleFieldsMethodsRelyOnCreateGlobalFunctionsMethod();
    internal static string get_InvalidOperation_MustCallInitialize();
    internal static string get_InvalidOperation_NativeOverlappedReused();
    internal static string get_InvalidOperation_NoMultiModuleAssembly();
    internal static string get_InvalidOperation_NoPublicAddMethod();
    internal static string get_InvalidOperation_NoPublicRemoveMethod();
    internal static string get_InvalidOperation_NotAllowedInDynamicMethod();
    internal static string get_InvalidOperation_NotAVarArgCallingConvention();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_InvalidOperation_NotWithConcurrentGC();
    internal static string get_InvalidOperation_NoValue();
    internal static string get_InvalidOperation_NullArray();
    internal static string get_InvalidOperation_NullContext();
    internal static string get_InvalidOperation_Overlapped_Pack();
    internal static string get_InvalidOperation_ReadOnly();
    internal static string get_InvalidOperation_ResMgrBadResSet_Type();
    internal static string get_InvalidOperation_ResourceNotStream_Name();
    internal static string get_InvalidOperation_ResourceNotString_Name();
    internal static string get_InvalidOperation_ResourceNotString_Type();
    internal static string get_InvalidOperation_SetLatencyModeNoGC();
    internal static string get_InvalidOperation_ShouldNotHaveMethodBody();
    internal static string get_InvalidOperation_ThreadWrongThreadStart();
    internal static string get_InvalidOperation_TimeoutsNotSupported();
    internal static string get_InvalidOperation_TimerAlreadyClosed();
    internal static string get_InvalidOperation_TypeHasBeenCreated();
    internal static string get_InvalidOperation_TypeNotCreated();
    internal static string get_InvalidOperation_UnderlyingArrayListChanged();
    internal static string get_InvalidOperation_UnknownEnumType();
    internal static string get_InvalidOperation_WrongAsyncResultOrEndCalledMultiple();
    internal static string get_InvalidProgram_Default();
    internal static string get_InvalidTimeZone_InvalidFileData();
    internal static string get_InvalidTimeZone_InvalidJulianDay();
    internal static string get_InvalidTimeZone_NoTTInfoStructures();
    internal static string get_InvalidTimeZone_UnparsablePosixMDateString();
    internal static string get_InvariantFailed();
    internal static string get_InvariantFailed_Cnd();
    internal static string get_IO_NoFileTableInInMemoryAssemblies();
    internal static string get_IO_EOF_ReadBeyondEOF();
    internal static string get_IO_FileLoad();
    internal static string get_IO_FileName_Name();
    internal static string get_IO_FileNotFound();
    internal static string get_IO_FileNotFound_FileName();
    internal static string get_IO_AlreadyExists_Name();
    internal static string get_IO_DiskFull_Path_AllocationSize();
    internal static string get_IO_FileTooLarge_Path_AllocationSize();
    internal static string get_IO_FileExists_Name();
    internal static string get_IO_FileTooLong2GB();
    internal static string get_IO_FixedCapacity();
    internal static string get_IO_InvalidStringLen_Len();
    internal static string get_IO_SeekAppendOverwrite();
    internal static string get_IO_SeekBeforeBegin();
    internal static string get_IO_SetLengthAppendTruncate();
    internal static string get_IO_SharingViolation_File();
    internal static string get_IO_SharingViolation_NoFileName();
    internal static string get_IO_StreamTooLong();
    internal static string get_IO_PathNotFound_NoPathName();
    internal static string get_IO_PathNotFound_Path();
    internal static string get_IO_PathTooLong();
    internal static string get_IO_PathTooLong_Path();
    internal static string get_IO_TooManySymbolicLinkLevels();
    internal static string get_IO_UnknownFileName();
    internal static string get_Lazy_CreateValue_NoParameterlessCtorForT();
    internal static string get_Lazy_ctor_ModeInvalid();
    internal static string get_Lazy_StaticInit_InvalidOperation();
    internal static string get_Lazy_ToString_ValueNotCreated();
    internal static string get_Lazy_Value_RecursiveCallsToValue();
    internal static string get_ManualResetEventSlim_ctor_TooManyWaiters();
    internal static string get_MissingConstructor_Name();
    internal static string get_MissingField();
    internal static string get_MissingField_Name();
    internal static string get_MissingManifestResource_MultipleBlobs();
    internal static string get_MissingManifestResource_NoNeutralAsm();
    internal static string get_MissingManifestResource_NoNeutralDisk();
    internal static string get_MissingMember();
    internal static string get_MissingMember_Name();
    internal static string get_MissingMemberNestErr();
    internal static string get_MissingMemberTypeRef();
    internal static string get_MissingMethod_Name();
    internal static string get_MissingSatelliteAssembly_Culture_Name();
    internal static string get_MissingSatelliteAssembly_Default();
    internal static string get_Multicast_Combine();
    internal static string get_MustUseCCRewrite();
    internal static string get_NotSupported_AbstractNonCLS();
    internal static string get_NotSupported_ActivAttr();
    internal static string get_NotSupported_AssemblyLoadFromHash();
    internal static string get_NotSupported_ByRefLike();
    internal static string get_NotSupported_ByRefToByRefLikeReturn();
    internal static string get_NotSupported_ByRefToVoidReturn();
    internal static string get_NotSupported_CallToVarArg();
    internal static string get_NotSupported_CannotCallEqualsOnSpan();
    internal static string get_NotSupported_CannotCallGetHashCodeOnSpan();
    internal static string get_NotSupported_ChangeType();
    internal static string get_NotSupported_ContainsStackPtr();
    internal static string get_NotSupported_CreateInstanceWithTypeBuilder();
    internal static string get_NotSupported_DynamicAssembly();
    internal static string get_NotSupported_DynamicMethodFlags();
    internal static string get_NotSupported_DynamicModule();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_InvalidOperation_SpanOverlappedOperation();
    internal static string get_InvalidOperation_TimeProviderNullLocalTimeZone();
    internal static string get_InvalidOperation_TimeProviderInvalidTimestampFrequency();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_MaxWaitHandles();
    internal static string get_NotSupported_MemStreamNotExpandable();
    internal static string get_NotSupported_MustBeModuleBuilder();
    internal static string get_NotSupported_NoCodepageData();
    internal static string get_InvalidOperation_FunctionMissingUnmanagedCallersOnly();
    internal static string get_NotSupported_NonReflectedType();
    internal static string get_NotImplemented_NoSupportForModOpt();
    internal static string get_NotSupported_NoParentDefaultConstructor();
    internal static string get_NotSupported_NoTypeInfo();
    internal static string get_NotSupported_NYI();
    internal static string get_NotSupported_ObsoleteResourcesFile();
    internal static string get_NotSupported_OutputStreamUsingTypeBuilder();
    internal static string get_NotSupported_RangeCollection();
    internal static string get_NotSupported_Reading();
    internal static string get_NotSupported_ReadOnlyCollection();
    internal static string get_NotSupported_ResourceObjectSerialization();
    internal static string get_NotSupported_StringComparison();
    internal static string get_NotSupported_SubclassOverride();
    internal static string get_NotSupported_Type();
    internal static string get_NotSupported_UmsSafeBuffer();
    internal static string get_NotSupported_UnitySerHolder();
    internal static string get_NotSupported_UnreadableStream();
    internal static string get_NotSupported_UnseekableStream();
    internal static string get_NotSupported_UnwritableStream();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_NotSupported_Writing();
    internal static string get_NotSupported_WrongResourceReader_Type();
    internal static string get_ObjectDisposed_FileClosed();
    internal static string get_ObjectDisposed_Generic();
    internal static string get_ObjectDisposed_ObjectName_Name();
    internal static string get_ObjectDisposed_WriterClosed();
    internal static string get_ObjectDisposed_ReaderClosed();
    internal static string get_ObjectDisposed_ResourceSet();
    internal static string get_ObjectDisposed_StreamClosed();
    internal static string get_ObjectDisposed_ViewAccessorClosed();
    internal static string get_OperationCanceled();
    internal static string get_Overflow_Byte();
    internal static string get_Overflow_Char();
    internal static string get_Overflow_Currency();
    internal static string get_Overflow_Decimal();
    internal static string get_Overflow_Duration();
    internal static string get_Overflow_Int16();
    internal static string get_Overflow_Int32();
    internal static string get_Overflow_Int64();
    internal static string get_Overflow_Int128();
    internal static string get_Overflow_MutexReacquireCount();
    internal static string get_Overflow_NegateTwosCompNum();
    internal static string get_Overflow_NegativeUnsigned();
    internal static string get_Overflow_SByte();
    internal static string get_Overflow_TimeSpanElementTooLarge();
    internal static string get_Overflow_TimeSpanTooLong();
    internal static string get_Overflow_UInt16();
    internal static string get_Overflow_UInt32();
    internal static string get_Overflow_UInt64();
    internal static string get_Overflow_UInt128();
    internal static string get_PlatformNotSupported_ComInterop();
    internal static string get_PlatformNotSupported_NamedSynchronizationPrimitives();
    internal static string get_PlatformNotSupported_ReflectionOnly();
    internal static string get_PlatformNotSupported_Remoting();
    internal static string get_PlatformNotSupported_SecureBinarySerialization();
    internal static string get_PlatformNotSupported_StrongNameSigning();
    internal static string get_PlatformNotSupported_OverlappedIO();
    internal static string get_PlatformNotSupported_AppDomains();
    internal static string get_PlatformNotSupported_CAS();
    internal static string get_PlatformNotSupported_Principal();
    internal static string get_PlatformNotSupported_ThreadAbort();
    internal static string get_PlatformNotSupported_ThreadSuspend();
    internal static string get_PlatformNotSupported_UserDefinedSubclassesOfType();
    internal static string get_PostconditionFailed();
    internal static string get_PostconditionFailed_Cnd();
    internal static string get_PostconditionOnExceptionFailed();
    internal static string get_PostconditionOnExceptionFailed_Cnd();
    internal static string get_PreconditionFailed();
    internal static string get_PreconditionFailed_Cnd();
    internal static string get_Rank_MultiDimNotSupported();
    internal static string get_ResourceReaderIsClosed();
    internal static string get_Resources_StreamNotValid();
    internal static string get_InvalidFilterCriteriaException_CritInt();
    internal static string get_InvalidFilterCriteriaException_CritString();
    internal static string get_RFLCT_Targ_ITargMismatch();
    internal static string get_RFLCT_Targ_StatFldReqTarg();
    internal static string get_RFLCT_Targ_StatMethReqTarg();
    internal static string get_RuntimeWrappedException();
    internal static string get_Security_CannotReadFileData();
    internal static string get_SemaphoreSlim_ctor_InitialCountWrong();
    internal static string get_SemaphoreSlim_ctor_MaxCountWrong();
    internal static string get_SemaphoreSlim_Release_CountWrong();
    internal static string get_SemaphoreSlim_Wait_TimeoutWrong();
    internal static string get_Serialization_BadParameterInfo();
    internal static string get_Serialization_CorruptField();
    internal static string get_Serialization_DateTimeTicksOutOfRange();
    internal static string get_Serialization_DelegatesNotSupported();
    internal static string get_Serialization_InsufficientState();
    internal static string get_Serialization_InvalidData();
    internal static string get_Serialization_InvalidEscapeSequence();
    internal static string get_Serialization_InvalidOnDeser();
    internal static string get_Serialization_InvalidType();
    internal static string get_Serialization_KeyValueDifferentSizes();
    internal static string get_Serialization_MissingDateTimeData();
    internal static string get_Serialization_MissingKeys();
    internal static string get_Serialization_MissingValues();
    internal static string get_Serialization_NoParameterInfo();
    internal static string get_Serialization_NotFound();
    internal static string get_Serialization_NullKey();
    internal static string get_Serialization_OptionalFieldVersionValue();
    internal static string get_Serialization_SameNameTwice();
    internal static string get_Serialization_StringBuilderCapacity();
    internal static string get_Serialization_StringBuilderMaxCapacity();
    internal static string get_SetterHasNoParams();
    internal static string get_SpinLock_Exit_SynchronizationLockException();
    internal static string get_SpinLock_IsHeldByCurrentThread();
    internal static string get_SpinLock_TryEnter_ArgumentOutOfRange();
    internal static string get_SpinLock_TryEnter_LockRecursionException();
    internal static string get_SpinLock_TryReliableEnter_ArgumentException();
    internal static string get_SpinWait_SpinUntil_TimeoutWrong();
    internal static string get_StackTrace_InFileILOffset();
    internal static string get_StackTrace_InFileLineNumber();
    internal static string get_TargetInvocation_MethodCannotBeInvoked();
    internal static string get_Task_ContinueWith_ESandLR();
    internal static string get_Task_ContinueWith_NotOnAnything();
    internal static string get_Task_InvalidTimerTimeSpan();
    internal static string get_Task_Delay_InvalidMillisecondsDelay();
    internal static string get_Task_Dispose_NotCompleted();
    internal static string get_Task_FromAsync_LongRunning();
    internal static string get_Task_FromAsync_PreferFairness();
    internal static string get_Task_MultiTaskContinuation_EmptyTaskList();
    internal static string get_Task_MultiTaskContinuation_FireOptions();
    internal static string get_Task_MultiTaskContinuation_NullTask();
    internal static string get_Task_RunSynchronously_AlreadyStarted();
    internal static string get_Task_RunSynchronously_Continuation();
    internal static string get_Task_RunSynchronously_Promise();
    internal static string get_Task_RunSynchronously_TaskCompleted();
    internal static string get_Task_Start_AlreadyStarted();
    internal static string get_Task_Start_ContinuationTask();
    internal static string get_Task_Start_Promise();
    internal static string get_Task_Start_TaskCompleted();
    internal static string get_Task_ThrowIfDisposed();
    internal static string get_Task_WaitMulti_NullTask();
    internal static string get_TaskT_ConfigureAwait_InvalidOptions();
    internal static string get_TaskCanceledException_ctor_DefaultMessage();
    internal static string get_TaskCompletionSourceT_TrySetException_NoExceptions();
    internal static string get_TaskCompletionSourceT_TrySetException_NullException();
    internal static string get_TaskExceptionHolder_UnhandledException();
    internal static string get_TaskExceptionHolder_UnknownExceptionType();
    internal static string get_TaskScheduler_ExecuteTask_WrongTaskScheduler();
    internal static string get_TaskScheduler_FromCurrentSynchronizationContext_NoCurrent();
    internal static string get_TaskScheduler_InconsistentStateAfterTryExecuteTaskInline();
    internal static string get_TaskSchedulerException_ctor_DefaultMessage();
    internal static string get_TaskT_DebuggerNoResult();
    internal static string get_TaskT_TransitionToFinal_AlreadyCompleted();
    internal static string get_Thread_GetSetCompressedStack_NotSupported();
    internal static string get_Thread_Operation_RequiresCurrentThread();
    internal static string get_Threading_AbandonedMutexException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException();
    internal static string get_Threading_WaitHandleCannotBeOpenedException_InvalidHandle();
    internal static string get_Threading_WaitHandleTooManyPosts();
    internal static string get_Threading_SemaphoreFullException();
    internal static string get_Threading_ThreadInterrupted();
    internal static string get_ThreadLocal_Value_RecursiveCallsToValue();
    internal static string get_ThreadLocal_ValuesNotAvailable();
    internal static string get_TimeZoneNotFound_MissingData();
    internal static string get_TypeInitialization_Type();
    internal static string get_TypeLoad_AssemblyEnumContainsMethodsError();
    internal static string get_TypeLoad_AssemblyInaccessibleInterfaceError();
    internal static string get_TypeLoad_AssemblySealedParentTypeError();
    internal static string get_TypeLoad_ResolveNestedType();
    internal static string get_TypeLoad_ResolveType();
    internal static string get_TypeLoad_ResolveTypeFromAssembly();
    internal static string get_UnauthorizedAccess_IODenied_NoPathName();
    internal static string get_UnauthorizedAccess_IODenied_Path();
    internal static string get_UnauthorizedAccess_MemStreamBuffer();
    internal static string get_Verification_Exception();
    internal static string get_Word_At();
    internal static string get_DebugAssertBanner();
    internal static string get_DebugAssertLongMessage();
    internal static string get_DebugAssertShortMessage();
    internal static string get_LockRecursionException_ReadAfterWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveReadNotAllowed();
    internal static string get_LockRecursionException_RecursiveWriteNotAllowed();
    internal static string get_LockRecursionException_RecursiveUpgradeNotAllowed();
    internal static string get_LockRecursionException_WriteAfterReadNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedUpgrade();
    internal static string get_SynchronizationLockException_MisMatchedRead();
    internal static string get_SynchronizationLockException_IncorrectDispose();
    internal static string get_LockRecursionException_UpgradeAfterReadNotAllowed();
    internal static string get_LockRecursionException_UpgradeAfterWriteNotAllowed();
    internal static string get_SynchronizationLockException_MisMatchedWrite();
    internal static string get_NotSupported_SignatureType();
    internal static string get_HashCode_HashCodeNotSupported();
    internal static string get_HashCode_EqualityNotSupported();
    internal static string get_Arg_TypeNotSupported();
    internal static string get_IO_InvalidReadLength();
    internal static string get_Arg_BasePathNotFullyQualified();
    internal static string get_Argument_OverlapAlignmentMismatch();
    internal static string get_Arg_MustBeNullTerminatedString();
    internal static string get_ArgumentOutOfRange_Week_ISO();
    internal static string get_Argument_BadPInvokeMethod();
    internal static string get_Argument_BadPInvokeOnInterface();
    internal static string get_Argument_BadTypeDef();
    internal static string get_Argument_CannotExtractScalar();
    internal static string get_Argument_CannotParsePrecision();
    internal static string get_Argument_GWithPrecisionNotSupported();
    internal static string get_Argument_PrecisionTooLarge();
    internal static string get_Argument_PropertyClassUnmatchedWithConstructor();
    internal static string get_Argument_PropertyInvalidType();
    internal static string get_Argument_PropertyInvalidValue();
    internal static string get_Argument_PropertyMissingSetter();
    internal static string get_Argument_PropertyUnmatchingPropertyType();
    internal static string get_Argument_StructArrayTooLarge();
    internal static string get_IndexOutOfRange_ArrayWithOffset();
    internal static string get_Serialization_DangerousDeserialization_Switch();
    internal static string get_Argument_InvalidStartupHookSimpleAssemblyName();
    internal static string get_Argument_StartupHookAssemblyLoadFailed();
    internal static string get_InvalidOperation_InvalidHandle();
    internal static string get_Argument_SpansMustHaveSameLength();
    internal static string get_NotSupported_CannotWriteToBufferedStreamIfReadBufferCannotBeFlushed();
    internal static string get_GenericInvalidData();
    internal static string get_Argument_ResourceScopeWrongDirection();
    internal static string get_ArgumentNull_TypeRequiredByResourceScope();
    internal static string get_Argument_BadResourceScopeTypeBits();
    internal static string get_Argument_BadResourceScopeVisibilityBits();
    internal static string get_Argument_EmptyString();
    internal static string get_Argument_EmptyOrWhiteSpaceString();
    internal static string get_Argument_FrameworkNameInvalid();
    internal static string get_Argument_FrameworkNameInvalidVersion();
    internal static string get_Argument_FrameworkNameMissingVersion();
    internal static string get_Argument_FrameworkNameTooShort();
    internal static string get_Arg_SwitchExpressionException();
    internal static string get_Arg_ContextMarshalException();
    internal static string get_Arg_AppDomainUnloadedException();
    internal static string get_SwitchExpressionException_UnmatchedValue();
    internal static string get_Encoding_UTF7_Disabled();
    internal static string get_Arg_MustBeHalf();
    internal static string get_Arg_MustBeRune();
    internal static string get_BinaryFormatter_SerializationDisallowed();
    internal static string get_ResourceManager_ReflectionNotAllowed();
    internal static string get_InvalidOperation_AssemblyNotEditable();
    internal static string get_InvalidOperation_EmptyQueue();
    internal static string get_Arg_FileIsDirectory_Name();
    internal static string get_Arg_InvalidFileAttrs();
    internal static string get_Arg_InvalidUnixFileMode();
    internal static string get_Arg_Path2IsRooted();
    internal static string get_Argument_InvalidSubPath();
    internal static string get_IO_CannotReplaceSameFile();
    internal static string get_IO_NotAFile();
    internal static string get_IO_SourceDestMustBeDifferent();
    internal static string get_PlatformNotSupported_FileEncryption();
    internal static string get_Arg_MemberInfoNotFound();
    internal static string get_InvalidOperation_BadTZHeader();
    internal static string get_InvalidOperation_ReadTZError();
    internal static string get_InvalidOperation_BadIndexLength();
    internal static string get_TimeZoneNotFound_ValidTimeZoneFileMissing();
    internal static string get_NullabilityInfoContext_NotSupported();
    internal static string get_ThreadState_Dead_State();
    internal static string get_NullReference_InvokeNullRefReturned();
    internal static string get_PlatformNotSupported_ReflectionEmit();
    internal static string get_NotSupported_IncompleteTypes();
    internal static string get_Security_InvalidAssemblyPublicKey();
    internal static string get_ClassLoad_General();
    internal static string get_ClassLoad_General_Hex();
    internal static string get_ArgumentOutOfRange_NotGreaterThanBufferLength();
    internal static string get_NoMetadataTokenAvailable();
    internal static string get_ArgumentException_InvalidTypeArgument();
    internal static string get_Argument_CannotBeByRefType();
    internal static string get_CannotCreateByRefOfByRef();
    internal static string get_CannotCreatePointerOfByRef();
    internal static string get_TypeLoad_MethodOverrideNotVirtual();
    internal static string get_Argument_DirectorySeparatorInvalid();
    internal static string get_InvalidOperation_NotFunctionPointer();
    internal static string get_NotSupported_ModifiedType();
    internal static string get_Argument_UnexpectedStateForKnownCallback();
    internal static string get_OutOfMemory_StringTooLong();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private StackOverflowException(SerializationInfo info, StreamingContext context);
}
internal static class System.StartupHookProvider : object {
    private static bool IsSupported { get; }
    private static bool get_IsSupported();
    private static void ProcessStartupHooks(string diagnosticStartupHooks);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode")]
private static void CallStartupHook(Char* pStartupHookPart);
    private static void ParseStartupHook(StartupHookNameOrPath& startupHook, string startupHookPart);
    [RequiresUnreferencedCodeAttribute("The StartupHookSupport feature switch has been enabled for this app which is being trimmed. Startup hook code is not observable by the trimmer and so required assemblies, types and members may be removed")]
private static void CallStartupHook(StartupHookNameOrPath startupHook);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Chars")]
[NonVersionableAttribute]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.String : object {
    [IntrinsicAttribute]
public static string Empty;
    private int _stringLength;
    private char _firstChar;
    public char Chars { get; }
    public int Length { get; }
    [NullableContextAttribute("2")]
[DynamicDependencyAttribute("Ctor(System.Char[])")]
public String(Char[] value);
    [DynamicDependencyAttribute("Ctor(System.Char[],System.Int32,System.Int32)")]
public String(Char[] value, int startIndex, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[DynamicDependencyAttribute("Ctor(System.Char*)")]
public String(Char* value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[DynamicDependencyAttribute("Ctor(System.Char*,System.Int32,System.Int32)")]
public String(Char* value, int startIndex, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[DynamicDependencyAttribute("Ctor(System.SByte*)")]
public String(SByte* value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[DynamicDependencyAttribute("Ctor(System.SByte*,System.Int32,System.Int32)")]
public String(SByte* value, int startIndex, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[DynamicDependencyAttribute("Ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    [DynamicDependencyAttribute("Ctor(System.Char,System.Int32)")]
public String(char c, int count);
    [NullableContextAttribute("0")]
[DynamicDependencyAttribute("Ctor(System.ReadOnlySpan{System.Char})")]
public String(ReadOnlySpan`1<char> value);
    public static string Intern(string str);
    public static string IsInterned(string str);
    internal static string FastAllocateString(int length);
    private static string InternalIsInterned(string str);
    private static string InternalIntern(string str);
    private static void memset(Byte* dest, int val, int len);
    private static void memcpy(Byte* dest, Byte* src, int size);
    internal static void bzero(Byte* dest, int len);
    internal static void bzero_aligned_1(Byte* dest, int len);
    internal static void bzero_aligned_2(Byte* dest, int len);
    internal static void bzero_aligned_4(Byte* dest, int len);
    internal static void bzero_aligned_8(Byte* dest, int len);
    internal static void memcpy_aligned_1(Byte* dest, Byte* src, int size);
    internal static void memcpy_aligned_2(Byte* dest, Byte* src, int size);
    internal static void memcpy_aligned_4(Byte* dest, Byte* src, int size);
    internal static void memcpy_aligned_8(Byte* dest, Byte* src, int size);
    private static bool EqualsHelper(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, int indexA, int countA, string strB, int indexB, int countB);
    internal static bool EqualsOrdinalIgnoreCase(string strA, string strB);
    private static bool EqualsOrdinalIgnoreCaseNoLengthCheck(string strA, string strB);
    private static int CompareOrdinalHelper(string strA, string strB);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, bool ignoreCase);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static int CompareOrdinal(string strA, string strB);
    internal static int CompareOrdinal(ReadOnlySpan`1<char> strA, ReadOnlySpan`1<char> strB);
    [NullableContextAttribute("2")]
public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(string strB);
    public bool EndsWith(string value);
    public bool EndsWith(string value, StringComparison comparisonType);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(char value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public sealed virtual bool Equals(string value);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public bool Equals(string value, StringComparison comparisonType);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool Equals(string a, string b);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool Equals(string a, string b, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static bool op_Equality(string a, string b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(string a, string b);
    public virtual int GetHashCode();
    public int GetHashCode(StringComparison comparisonType);
    internal int GetHashCodeOrdinalIgnoreCase();
    [NullableContextAttribute("0")]
public static int GetHashCode(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public static int GetHashCode(ReadOnlySpan`1<char> value, StringComparison comparisonType);
    internal static int GetHashCodeOrdinalIgnoreCase(ReadOnlySpan`1<char> value);
    internal int GetNonRandomizedHashCode();
    internal int GetNonRandomizedHashCodeOrdinalIgnoreCase();
    public bool StartsWith(string value);
    [IntrinsicAttribute]
public bool StartsWith(string value, StringComparison comparisonType);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(char value);
    internal static void CheckStringComparison(StringComparison comparisonType);
    internal static CompareOptions GetCaseCompareOfComparisonCulture(StringComparison comparisonType);
    private static CompareOptions GetCompareOptionsFromOrdinalStringComparison(StringComparison comparisonType);
    private static string Ctor(Char[] value);
    private static string Ctor(Char[] value, int startIndex, int length);
    private static string Ctor(Char* ptr);
    private static string Ctor(Char* ptr, int startIndex, int length);
    private static string Ctor(SByte* value);
    private static string Ctor(SByte* value, int startIndex, int length);
    private static string CreateStringForSByteConstructor(Byte* pb, int numBytes);
    private static string Ctor(SByte* value, int startIndex, int length, Encoding enc);
    private static string Ctor(char c, int count);
    private static string Ctor(ReadOnlySpan`1<char> value);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    public static string Create(IFormatProvider provider, DefaultInterpolatedStringHandler& handler);
    [NullableContextAttribute("0")]
public static string Create(IFormatProvider provider, Span`1<char> initialBuffer, DefaultInterpolatedStringHandler& handler);
    [NullableContextAttribute("0")]
[IntrinsicAttribute]
public static ReadOnlySpan`1<char> op_Implicit(string value);
    internal bool TryGetSpan(int startIndex, int count, ReadOnlySpan`1& slice);
    public sealed virtual object Clone();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")]
public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [NullableContextAttribute("0")]
public void CopyTo(Span`1<char> destination);
    [NullableContextAttribute("0")]
public bool TryCopyTo(Span`1<char> destination);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [NullableContextAttribute("2")]
public static bool IsNullOrWhiteSpace(string value);
    [EditorBrowsableAttribute("1")]
[NonVersionableAttribute]
public Char& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    internal Char& GetRawStringData();
    internal UInt16& GetRawStringDataAsUInt16();
    internal static string CreateStringFromEncoding(Byte* bytes, int byteLength, Encoding encoding);
    internal static string CreateFromChar(char c);
    internal static string CreateFromChar(char c1, char c2);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public CharEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public StringRuneEnumerator EnumerateRunes();
    internal static int wcslen(Char* ptr);
    internal static int strlen(Byte* ptr);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    [IntrinsicAttribute]
public char get_Chars(int index);
    [IntrinsicAttribute]
public int get_Length();
    private static override string System.IParsable<System.String>.Parse(string s, IFormatProvider provider);
    private static override bool System.IParsable<System.String>.TryParse(string s, IFormatProvider provider, String& result);
    private static override string System.ISpanParsable<System.String>.Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    private static override bool System.ISpanParsable<System.String>.TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, String& result);
    private static void CopyStringContent(string dest, int destPos, string src);
    public static string Concat(object arg0);
    [NullableContextAttribute("2")]
public static string Concat(object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    public static string Concat(IEnumerable`1<T> values);
    public static string Concat(IEnumerable`1<string> values);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1, string str2);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1, string str2, string str3);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2, ReadOnlySpan`1<char> str3);
    internal static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2, ReadOnlySpan`1<char> str3, ReadOnlySpan`1<char> str4);
    public static string Concat(String[] values);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public static string Format(IFormatProvider provider, string format, object arg0);
    [NullableContextAttribute("2")]
public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    private static string FormatHelper(IFormatProvider provider, string format, ReadOnlySpan`1<object> args);
    public static string Format(IFormatProvider provider, CompositeFormat format, TArg0 arg0);
    public static string Format(IFormatProvider provider, CompositeFormat format, TArg0 arg0, TArg1 arg1);
    public static string Format(IFormatProvider provider, CompositeFormat format, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    public static string Format(IFormatProvider provider, CompositeFormat format, Object[] args);
    public static string Format(IFormatProvider provider, CompositeFormat format, ReadOnlySpan`1<object> args);
    private static string Format(IFormatProvider provider, CompositeFormat format, TArg0 arg0, TArg1 arg1, TArg2 arg2, ReadOnlySpan`1<object> args);
    public string Insert(int startIndex, string value);
    public static string Join(char separator, String[] value);
    public static string Join(string separator, String[] value);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, String[] value, int startIndex, int count);
    private static string JoinCore(ReadOnlySpan`1<char> separator, String[] value, int startIndex, int count);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(char separator, Object[] values);
    public static string Join(string separator, Object[] values);
    private static string JoinCore(ReadOnlySpan`1<char> separator, Object[] values);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<T> values);
    private static string JoinCore(ReadOnlySpan`1<char> separator, IEnumerable`1<T> values);
    private static string JoinCore(ReadOnlySpan`1<char> separator, ReadOnlySpan`1<string> values);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex, int count);
    public string Remove(int startIndex);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    private string ReplaceCore(string oldValue, string newValue, CompareInfo ci, CompareOptions options);
    private static string ReplaceCore(ReadOnlySpan`1<char> searchSpace, ReadOnlySpan`1<char> oldValue, ReadOnlySpan`1<char> newValue, CompareInfo compareInfo, CompareOptions options);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    private string ReplaceHelper(int oldValueLength, string newValue, ReadOnlySpan`1<int> indices);
    public string ReplaceLineEndings();
    public string ReplaceLineEndings(string replacementText);
    private string ReplaceLineEndingsCore(string replacementText);
    private static int IndexOfNewlineChar(ReadOnlySpan`1<char> text, string replacementText, Int32& stride);
    private string ReplaceLineEndingsWithLineFeed();
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(ReadOnlySpan`1<char> separators, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    private String[] SplitInternal(string separator, String[] separators, int count, StringSplitOptions options);
    private String[] CreateSplitArrayOfThisAsSoleValue(StringSplitOptions options, int count);
    private String[] SplitInternal(string separator, int count, StringSplitOptions options);
    private String[] SplitWithoutPostProcessing(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count);
    private String[] SplitWithPostProcessing(ReadOnlySpan`1<int> sepList, ReadOnlySpan`1<int> lengthList, int defaultLength, int count, StringSplitOptions options);
    internal static void MakeSeparatorListAny(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> separators, ValueListBuilder`1& sepListBuilder);
    private static void MakeSeparatorListVectorized(ReadOnlySpan`1<char> sourceSpan, ValueListBuilder`1& sepListBuilder, char c, char c2, char c3);
    internal static void MakeSeparatorList(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> separator, ValueListBuilder`1& sepListBuilder);
    internal static void MakeSeparatorListAny(ReadOnlySpan`1<char> source, ReadOnlySpan`1<string> separators, ValueListBuilder`1& sepListBuilder, ValueListBuilder`1& lengthListBuilder);
    internal static void CheckStringSplitOptions(StringSplitOptions options);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    [DoesNotReturnAttribute]
private void ThrowSubstringArgumentOutOfRange(int startIndex, int length);
    private string InternalSubString(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    private string TrimWhiteSpaceHelper(TrimType trimType);
    private string TrimHelper(Char* trimChars, int trimCharsLength, TrimType trimType);
    private string CreateTrimmedString(int start, int end);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, StringComparison comparisonType);
    private int IndexOfCharOrdinalIgnoreCase(char value);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    [CompilerGeneratedAttribute]
internal static int <GetNonRandomizedHashCodeOrdinalIgnoreCase>g__GetNonRandomizedHashCodeOrdinalIgnoreCaseSlow|55_0(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.StringComparer : object {
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    public static StringComparer FromComparison(StringComparison comparisonType);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static bool IsWellKnownOrdinalComparer(IEqualityComparer`1<string> comparer, Boolean& ignoreCase);
    private protected virtual bool IsWellKnownOrdinalComparerCore(Boolean& ignoreCase);
    [NullableContextAttribute("2")]
public static bool IsWellKnownCultureAwareComparer(IEqualityComparer`1<string> comparer, CompareInfo& compareInfo, CompareOptions& compareOptions);
    private protected virtual bool IsWellKnownCultureAwareComparerCore(CompareInfo& compareInfo, CompareOptions& compareOptions);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object x, object y);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    [NullableContextAttribute("2")]
public abstract virtual int Compare(string x, string y);
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(string x, string y);
    public abstract virtual int GetHashCode(string obj);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string strInput);
    [ExtensionAttribute]
public static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string strInput);
    [ExtensionAttribute]
public static string Normalize(string strInput, NormalizationForm normalizationForm);
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
    public static StringSplitOptions TrimEntries;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.SystemException : Exception {
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SystemException(SerializationInfo info, StreamingContext context);
}
internal class System.SZGenericArrayEnumerator`1 : SZGenericArrayEnumeratorBase {
    private T[] _array;
    internal static SZGenericArrayEnumerator`1<T> Empty;
    public T Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal SZGenericArrayEnumerator`1(T[] array, int endIndex);
    private static SZGenericArrayEnumerator`1();
    public sealed virtual T get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
internal abstract class System.SZGenericArrayEnumeratorBase : object {
    protected int _index;
    protected int _endIndex;
    protected SZGenericArrayEnumeratorBase(int endIndex);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
}
public static class System.Text.Ascii : object {
    public static bool IsValid(ReadOnlySpan`1<byte> value);
    public static bool IsValid(ReadOnlySpan`1<char> value);
    public static bool IsValid(byte value);
    public static bool IsValid(char value);
    private static bool IsValidCore(T& searchSpace, int length);
    public static OperationStatus ToUpper(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static OperationStatus ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsWritten);
    public static OperationStatus ToUpper(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& charsWritten);
    public static OperationStatus ToUpper(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& bytesWritten);
    public static OperationStatus ToLower(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public static OperationStatus ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, Int32& charsWritten);
    public static OperationStatus ToLower(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& charsWritten);
    public static OperationStatus ToLower(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& bytesWritten);
    public static OperationStatus ToLowerInPlace(Span`1<byte> value, Int32& bytesWritten);
    public static OperationStatus ToLowerInPlace(Span`1<char> value, Int32& charsWritten);
    public static OperationStatus ToUpperInPlace(Span`1<byte> value, Int32& bytesWritten);
    public static OperationStatus ToUpperInPlace(Span`1<char> value, Int32& charsWritten);
    private static OperationStatus ChangeCase(ReadOnlySpan`1<TFrom> source, Span`1<TTo> destination, Int32& destinationElementsWritten);
    private static OperationStatus ChangeCase(Span`1<T> buffer, Int32& elementsWritten);
    private static UIntPtr ChangeCase(TFrom* pSrc, TTo* pDest, UIntPtr elementCount);
    private static void ChangeWidthAndWriteTo(Vector128`1<TFrom> vector, TTo* pDest, UIntPtr elementOffset);
    private static Vector128`1<T> SignedLessThan(Vector128`1<T> left, Vector128`1<T> right);
    public static bool Equals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static bool Equals(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<char> right);
    public static bool Equals(ReadOnlySpan`1<char> left, ReadOnlySpan`1<byte> right);
    public static bool Equals(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    private static bool Equals(TLeft& left, TRight& right, UIntPtr length);
    public static bool EqualsIgnoreCase(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<byte> right);
    public static bool EqualsIgnoreCase(ReadOnlySpan`1<byte> left, ReadOnlySpan`1<char> right);
    public static bool EqualsIgnoreCase(ReadOnlySpan`1<char> left, ReadOnlySpan`1<byte> right);
    public static bool EqualsIgnoreCase(ReadOnlySpan`1<char> left, ReadOnlySpan`1<char> right);
    private static bool EqualsIgnoreCase(TLeft& left, TRight& right, UIntPtr length);
    public static OperationStatus ToUtf16(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& charsWritten);
    public static OperationStatus FromUtf16(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& bytesWritten);
    public static Range Trim(ReadOnlySpan`1<byte> value);
    public static Range Trim(ReadOnlySpan`1<char> value);
    public static Range TrimStart(ReadOnlySpan`1<byte> value);
    public static Range TrimStart(ReadOnlySpan`1<char> value);
    public static Range TrimEnd(ReadOnlySpan`1<byte> value);
    public static Range TrimEnd(ReadOnlySpan`1<char> value);
    private static Range TrimHelper(ReadOnlySpan`1<T> value, TrimType trimType);
    private static bool AllBytesInUInt64AreAscii(ulong value);
    private static bool AllCharsInUInt32AreAscii(UInt32 value);
    private static bool AllCharsInUInt64AreAscii(ulong value);
    private static bool AllCharsInUInt64AreAscii(ulong value);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
private static int GetIndexOfFirstNonAsciiByteInLane_AdvSimd(Vector128`1<byte> value, Vector128`1<byte> bitmask);
    private static bool FirstCharInUInt32IsAscii(UInt32 value);
    internal static UIntPtr GetIndexOfFirstNonAsciiByte(Byte* pBuffer, UIntPtr bufferLength);
    private static UIntPtr GetIndexOfFirstNonAsciiByte_Vector(Byte* pBuffer, UIntPtr bufferLength);
    private static bool ContainsNonAsciiByte_AdvSimd(UInt32 advSimdIndex);
    private static UIntPtr GetIndexOfFirstNonAsciiByte_Intrinsified(Byte* pBuffer, UIntPtr bufferLength);
    internal static UIntPtr GetIndexOfFirstNonAsciiChar(Char* pBuffer, UIntPtr bufferLength);
    private static UIntPtr GetIndexOfFirstNonAsciiChar_Vector(Char* pBuffer, UIntPtr bufferLength);
    private static UIntPtr GetIndexOfFirstNonAsciiChar_Intrinsified(Char* pBuffer, UIntPtr bufferLength);
    private static void NarrowFourUtf16CharsToAsciiAndWriteToBuffer(Byte& outputBuffer, ulong value);
    private static void NarrowTwoUtf16CharsToAsciiAndWriteToBuffer(Byte& outputBuffer, UInt32 value);
    internal static UIntPtr NarrowUtf16ToAscii(Char* pUtf16Buffer, Byte* pAsciiBuffer, UIntPtr elementCount);
    private static bool VectorContainsNonAsciiChar(Vector128`1<byte> asciiVector);
    private static bool VectorContainsNonAsciiChar(Vector128`1<ushort> utf16Vector);
    private static bool VectorContainsNonAsciiChar(Vector128`1<T> vector);
    private static bool AllCharsInVectorAreAscii(Vector128`1<T> vector);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.X86.Avx")]
private static bool AllCharsInVectorAreAscii(Vector256`1<T> vector);
    private static bool AllCharsInVectorAreAscii(Vector512`1<T> vector);
    private static Vector128`1<byte> ExtractAsciiVector(Vector128`1<ushort> vectorFirst, Vector128`1<ushort> vectorSecond);
    private static UIntPtr NarrowUtf16ToAscii_Intrinsified(Char* pUtf16Buffer, Byte* pAsciiBuffer, UIntPtr elementCount);
    internal static UIntPtr WidenAsciiToUtf16(Byte* pAsciiBuffer, Char* pUtf16Buffer, UIntPtr elementCount);
    internal static void WidenFourAsciiBytesToUtf16AndWriteToBuffer(Char& outputBuffer, UInt32 value);
    internal static bool AllBytesInUInt32AreAscii(UInt32 value);
    internal static UInt32 CountNumberOfLeadingAsciiBytesFromUInt32WithSomeNonAsciiData(UInt32 value);
}
public class System.Text.ASCIIEncoding : Encoding {
    internal static ASCIIEncodingSealed s_default;
    public bool IsSingleByte { get; }
    private static ASCIIEncoding();
    internal sealed virtual void SetDefaultFallbacks();
    [NullableContextAttribute("1")]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    private int GetByteCountCommon(Char* pChars, int charCount);
    private protected sealed virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    [NullableContextAttribute("1")]
public virtual int GetBytes(string chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("1")]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual bool TryGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private int GetBytesCommon(Char* pChars, int charCount, Byte* pBytes, int byteCount, bool throwForDestinationOverflow);
    private protected sealed virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    private protected sealed virtual int GetBytesWithFallback(ReadOnlySpan`1<char> chars, int originalCharsLength, Span`1<byte> bytes, int originalBytesLength, EncoderNLS encoder, bool throwForDestinationOverflow);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    private int GetCharCountCommon(Byte* pBytes, int byteCount);
    private protected sealed virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual bool TryGetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten);
    private int GetCharsCommon(Byte* pBytes, int byteCount, Char* pChars, int charCount, bool throwForDestinationOverflow);
    private protected sealed virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    private protected sealed virtual int GetCharsWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, Span`1<char> chars, int originalCharsLength, DecoderNLS decoder, bool throwForDestinationOverflow);
    [NullableContextAttribute("1")]
public virtual string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal sealed virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal sealed virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal sealed virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual bool get_IsSingleByte();
    [NullableContextAttribute("1")]
public virtual Decoder GetDecoder();
    [NullableContextAttribute("1")]
public virtual Encoder GetEncoder();
}
internal class System.Text.CodePageDataItem : object {
    [CompilerGeneratedAttribute]
private int <UIFamilyCodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BodyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Flags>k__BackingField;
    public int UIFamilyCodePage { get; }
    public string WebName { get; }
    public string HeaderName { get; }
    public string BodyName { get; }
    public string DisplayName { get; }
    public UInt32 Flags { get; }
    internal CodePageDataItem(int uiFamilyCodePage, string webName, string headerName, string bodyName, string displayName, UInt32 flags);
    [CompilerGeneratedAttribute]
public int get_UIFamilyCodePage();
    [CompilerGeneratedAttribute]
public string get_WebName();
    [CompilerGeneratedAttribute]
public string get_HeaderName();
    [CompilerGeneratedAttribute]
public string get_BodyName();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public UInt32 get_Flags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Format}")]
public class System.Text.CompositeFormat : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ValueTuple`4[] _segments;
    internal int _literalLength;
    internal int _formattedCount;
    internal int _argsRequired;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; }
    public int MinimumArgumentCount { get; }
    private CompositeFormat(string format, ValueTuple`4[] segments);
    public static CompositeFormat Parse(string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    public int get_MinimumArgumentCount();
    internal void ValidateNumberOfArgs(int numArgs);
    private static bool TryParseLiterals(ReadOnlySpan`1<char> format, List`1<ValueTuple`4<string, int, int, string>> segments, Int32& failureOffset, ExceptionResource& failureReason);
    [CompilerGeneratedAttribute]
internal static bool <TryParseLiterals>g__TryMoveNext|12_0(ReadOnlySpan`1<char> format, Int32& pos, Char& nextChar);
}
public abstract class System.Text.Decoder : object {
    internal DecoderFallback _fallback;
    internal DecoderFallbackBuffer _fallbackBuffer;
    [NullableAttribute("2")]
public DecoderFallback Fallback { get; public set; }
    [NullableAttribute("1")]
public DecoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    [NullableContextAttribute("2")]
public DecoderFallback get_Fallback();
    [NullableContextAttribute("2")]
public void set_Fallback(DecoderFallback value);
    [NullableContextAttribute("1")]
public DecoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    [NullableContextAttribute("1")]
public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    [NullableContextAttribute("1")]
public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    internal static DecoderExceptionFallback s_default;
    public int MaxCharCount { get; }
    private static DecoderExceptionFallback();
    [NullableContextAttribute("1")]
public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    [DoesNotReturnAttribute]
private static void Throw(Byte[] bytesUnknown, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.DecoderFallback : object {
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback get_ReplacementFallback();
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    internal Byte* byteStart;
    internal Char* charEnd;
    internal Encoding _encoding;
    internal DecoderNLS _decoder;
    private int _originalByteCount;
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Byte* byteStart, Char* charEnd);
    internal static DecoderFallbackBuffer CreateAndInitialize(Encoding encoding, DecoderNLS decoder, int originalByteCount);
    internal virtual bool InternalFallback(Byte[] bytes, Byte* pBytes, Char*& chars);
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
    internal int InternalFallbackGetCharCount(ReadOnlySpan`1<byte> remainingBytes, int fallbackLength);
    internal bool TryInternalFallbackGetChars(ReadOnlySpan`1<byte> remainingBytes, int fallbackLength, Span`1<char> chars, Int32& charsWritten);
    private Rune GetNextRune();
    internal int DrainRemainingDataForGetCharCount();
    internal bool TryDrainRemainingDataForGetChars(Span`1<char> chars, Int32& charsWritten);
    [DoesNotReturnAttribute]
internal static void ThrowLastBytesRecursive(Byte[] bytesUnknown);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.DecoderFallbackException : ArgumentException {
    private Byte[] _bytesUnknown;
    private int _index;
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Exception innerException);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private DecoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
internal class System.Text.DecoderNLS : Decoder {
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _bytesUsed;
    private int _leftoverBytes;
    private int _leftoverByteCount;
    public bool MustFlush { get; }
    internal bool HasState { get; }
    internal bool HasLeftoverData { get; }
    internal DecoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public bool get_MustFlush();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
    internal ReadOnlySpan`1<byte> GetLeftoverData();
    internal void SetLeftoverData(ReadOnlySpan`1<byte> bytes);
    internal bool get_HasLeftoverData();
    internal void ClearLeftoverData();
    internal int DrainLeftoverDataForGetCharCount(ReadOnlySpan`1<byte> bytes, Int32& bytesConsumed);
    internal int DrainLeftoverDataForGetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& bytesConsumed);
    private static int ConcatInto(ReadOnlySpan`1<byte> srcLeft, ReadOnlySpan`1<byte> srcRight, Span`1<byte> dest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    internal static DecoderReplacementFallback s_default;
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    private static DecoderReplacementFallback();
    public string get_DefaultString();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    internal virtual int InternalFallback(Byte[] bytes, Byte* pBytes);
}
public abstract class System.Text.Encoder : object {
    internal EncoderFallback _fallback;
    internal EncoderFallbackBuffer _fallbackBuffer;
    [NullableAttribute("2")]
public EncoderFallback Fallback { get; public set; }
    [NullableAttribute("1")]
public EncoderFallbackBuffer FallbackBuffer { get; }
    internal bool InternalHasFallbackBuffer { get; }
    [NullableContextAttribute("2")]
public EncoderFallback get_Fallback();
    [NullableContextAttribute("2")]
public void set_Fallback(EncoderFallback value);
    [NullableContextAttribute("1")]
public EncoderFallbackBuffer get_FallbackBuffer();
    internal bool get_InternalHasFallbackBuffer();
    public virtual void Reset();
    [NullableContextAttribute("1")]
public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    [NullableContextAttribute("1")]
public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    internal static EncoderExceptionFallback s_default;
    public int MaxCharCount { get; }
    private static EncoderExceptionFallback();
    [NullableContextAttribute("1")]
public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.EncoderFallback : object {
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback get_ReplacementFallback();
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public abstract virtual int get_MaxCharCount();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    internal Char* charStart;
    internal Char* charEnd;
    internal EncoderNLS encoder;
    internal bool setEncoder;
    internal bool bUsedEncoder;
    internal bool bFallingBack;
    internal int iRecursionCount;
    private Encoding encoding;
    private int originalCharCount;
    public int Remaining { get; }
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public abstract virtual int get_Remaining();
    public virtual void Reset();
    internal void InternalReset();
    internal void InternalInitialize(Char* charStart, Char* charEnd, EncoderNLS encoder, bool setEncoder);
    internal static EncoderFallbackBuffer CreateAndInitialize(Encoding encoding, EncoderNLS encoder, int originalCharCount);
    internal char InternalGetNextChar();
    private bool InternalFallback(ReadOnlySpan`1<char> chars, Int32& charsConsumed);
    internal int InternalFallbackGetByteCount(ReadOnlySpan`1<char> chars, Int32& charsConsumed);
    internal bool TryInternalFallbackGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsConsumed, Int32& bytesWritten);
    internal bool TryDrainRemainingDataForGetBytes(Span`1<byte> bytes, Int32& bytesWritten);
    internal int DrainRemainingDataForGetByteCount();
    private Rune GetNextRune();
    internal virtual bool InternalFallback(char ch, Char*& chars);
    [DoesNotReturnAttribute]
internal static void ThrowLastCharRecursive(int charRecursive);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.EncoderFallbackException : ArgumentException {
    private char _charUnknown;
    private char _charUnknownHigh;
    private char _charUnknownLow;
    private int _index;
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    internal EncoderFallbackException(string message, char charUnknown, int index);
    internal EncoderFallbackException(string message, char charUnknownHigh, char charUnknownLow, int index);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private EncoderFallbackException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
internal class System.Text.EncoderLatin1BestFitFallback : EncoderFallback {
    internal static EncoderLatin1BestFitFallback SingletonInstance;
    public int MaxCharCount { get; }
    private static EncoderLatin1BestFitFallback();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
}
internal class System.Text.EncoderLatin1BestFitFallbackBuffer : EncoderFallbackBuffer {
    private char _cBestFit;
    private int _iCount;
    private int _iSize;
    public int Remaining { get; }
    private static ReadOnlySpan`1<char> ArrayCharBestFit { get; }
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
    private static char TryBestFit(char cUnknown);
    private static ReadOnlySpan`1<char> get_ArrayCharBestFit();
}
internal class System.Text.EncoderNLS : Encoder {
    internal char _charLeftOver;
    private Encoding _encoding;
    private bool _mustFlush;
    internal bool _throwOnOverflow;
    internal int _charsUsed;
    public Encoding Encoding { get; }
    public bool MustFlush { get; }
    internal bool HasLeftoverData { get; }
    internal bool HasState { get; }
    internal EncoderNLS(Encoding encoding);
    public virtual void Reset();
    public virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(Char* chars, int count, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public Encoding get_Encoding();
    public bool get_MustFlush();
    internal bool get_HasLeftoverData();
    internal virtual bool get_HasState();
    internal void ClearMustFlush();
    internal int DrainLeftoverDataForGetByteCount(ReadOnlySpan`1<char> chars, Int32& charsConsumed);
    internal bool TryDrainLeftoverDataForGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& charsConsumed, Int32& bytesWritten);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    internal static EncoderReplacementFallback s_default;
    private string _strDefault;
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    private static EncoderReplacementFallback();
    public string get_DefaultString();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    private string _strDefault;
    private int _fallbackCount;
    private int _fallbackIndex;
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual int get_Remaining();
    public virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Encoding : object {
    private static UTF8EncodingSealed s_defaultEncoding;
    internal int _codePage;
    internal CodePageDataItem _dataItem;
    [OptionalFieldAttribute]
private bool _isReadOnly;
    internal EncoderFallback encoderFallback;
    internal DecoderFallback decoderFallback;
    public static Encoding Default { get; }
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public string BodyName { get; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsSingleByte { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public DecoderFallback DecoderFallback { get; public set; }
    public bool IsReadOnly { get; private protected set; }
    public static Encoding ASCII { get; }
    public static Encoding Latin1 { get; }
    public int CodePage { get; }
    internal bool IsUTF8CodePage { get; }
    public static Encoding Unicode { get; }
    public static Encoding BigEndianUnicode { get; }
    [ObsoleteAttribute("The UTF-7 encoding is insecure and should not be used. Consider using UTF-8 instead.")]
public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public static Encoding UTF32 { get; }
    private static Encoding BigEndianUTF32 { get; }
    protected Encoding(int codePage);
    [NullableContextAttribute("2")]
protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    private static Encoding();
    public static Encoding get_Default();
    [MemberNotNullAttribute("encoderFallback")]
[MemberNotNullAttribute("decoderFallback")]
internal virtual void SetDefaultFallbacks();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public static void RegisterProvider(EncodingProvider provider);
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    private static Encoding FilterDisallowedEncodings(Encoding encoding);
    public static EncodingInfo[] GetEncodings();
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    private void GetDataItem();
    public virtual string get_BodyName();
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public virtual bool get_IsSingleByte();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public virtual object Clone();
    public bool get_IsReadOnly();
    private protected void set_IsReadOnly(bool value);
    public static Encoding get_ASCII();
    public static Encoding get_Latin1();
    public virtual int GetByteCount(Char[] chars);
    public virtual int GetByteCount(string s);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    public int GetByteCount(string s, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    [NullableContextAttribute("0")]
public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    [NullableContextAttribute("0")]
public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    [NullableContextAttribute("0")]
public virtual bool TryGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    [NullableContextAttribute("0")]
public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    [NullableContextAttribute("0")]
public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    [NullableContextAttribute("0")]
public virtual bool TryGetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    [NullableContextAttribute("0")]
public string GetString(ReadOnlySpan`1<byte> bytes);
    public virtual int get_CodePage();
    internal bool get_IsUTF8CodePage();
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    public static Encoding get_Unicode();
    public static Encoding get_BigEndianUnicode();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public static Encoding get_UTF32();
    private static Encoding get_BigEndianUTF32();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static Stream CreateTranscodingStream(Stream innerStream, Encoding innerStreamEncoding, Encoding outerStreamEncoding, bool leaveOpen);
    [DoesNotReturnAttribute]
internal void ThrowBytesOverflow();
    internal void ThrowBytesOverflow(EncoderNLS encoder, bool nothingEncoded);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
internal static void ThrowConversionOverflow();
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
internal void ThrowCharsOverflow();
    internal void ThrowCharsOverflow(DecoderNLS decoder, bool nothingDecoded);
    internal virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    internal virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal virtual int GetByteCount(Char* pChars, int charCount, EncoderNLS encoder);
    private protected virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    private protected int GetByteCountWithFallback(Char* pCharsOriginal, int originalCharCount, int charsConsumedSoFar);
    private int GetByteCountWithFallback(Char* pOriginalChars, int originalCharCount, int charsConsumedSoFar, EncoderNLS encoder);
    private protected virtual int GetByteCountWithFallback(ReadOnlySpan`1<char> chars, int originalCharsLength, EncoderNLS encoder);
    internal virtual int GetBytes(Char* pChars, int charCount, Byte* pBytes, int byteCount, EncoderNLS encoder);
    private protected virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    private protected int GetBytesWithFallback(Char* pOriginalChars, int originalCharCount, Byte* pOriginalBytes, int originalByteCount, int charsConsumedSoFar, int bytesWrittenSoFar, bool throwForDestinationOverflow);
    private int GetBytesWithFallback(Char* pOriginalChars, int originalCharCount, Byte* pOriginalBytes, int originalByteCount, int charsConsumedSoFar, int bytesWrittenSoFar, EncoderNLS encoder);
    private protected virtual int GetBytesWithFallback(ReadOnlySpan`1<char> chars, int originalCharsLength, Span`1<byte> bytes, int originalBytesLength, EncoderNLS encoder, bool throwForDestinationOverflow);
    internal virtual int GetCharCount(Byte* pBytes, int byteCount, DecoderNLS decoder);
    private protected virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    private protected int GetCharCountWithFallback(Byte* pBytesOriginal, int originalByteCount, int bytesConsumedSoFar);
    private int GetCharCountWithFallback(Byte* pOriginalBytes, int originalByteCount, int bytesConsumedSoFar, DecoderNLS decoder);
    private int GetCharCountWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, DecoderNLS decoder);
    internal virtual int GetChars(Byte* pBytes, int byteCount, Char* pChars, int charCount, DecoderNLS decoder);
    private protected virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    private protected int GetCharsWithFallback(Byte* pOriginalBytes, int originalByteCount, Char* pOriginalChars, int originalCharCount, int bytesConsumedSoFar, int charsWrittenSoFar, bool throwForDestinationOverflow);
    private protected int GetCharsWithFallback(Byte* pOriginalBytes, int originalByteCount, Char* pOriginalChars, int originalCharCount, int bytesConsumedSoFar, int charsWrittenSoFar, DecoderNLS decoder);
    private protected virtual int GetCharsWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, Span`1<char> chars, int originalCharsLength, DecoderNLS decoder, bool throwForDestinationOverflow);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.EncodingInfo : object {
    [CompilerGeneratedAttribute]
private int <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private EncodingProvider <Provider>k__BackingField;
    public int CodePage { get; }
    public string Name { get; }
    public string DisplayName { get; }
    [NullableAttribute("2")]
internal EncodingProvider Provider { get; }
    public EncodingInfo(EncodingProvider provider, int codePage, string name, string displayName);
    internal EncodingInfo(int codePage, string name, string displayName);
    [CompilerGeneratedAttribute]
public int get_CodePage();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    public Encoding GetEncoding();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal EncodingProvider get_Provider();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.EncodingProvider : object {
    private static EncodingProvider[] modreq(System.Runtime.CompilerServices.IsVolatile) s_providers;
    public abstract virtual Encoding GetEncoding(string name);
    [NullableContextAttribute("2")]
public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual IEnumerable`1<EncodingInfo> GetEncodings();
    internal static void AddProvider(EncodingProvider provider);
    internal static Encoding GetEncodingFromProvider(int codepage);
    internal static Dictionary`2<int, EncodingInfo> GetEncodingListFromProviders();
    internal static Encoding GetEncodingFromProvider(string encodingName);
    internal static Encoding GetEncodingFromProvider(int codepage, EncoderFallback enc, DecoderFallback dec);
    internal static Encoding GetEncodingFromProvider(string encodingName, EncoderFallback enc, DecoderFallback dec);
}
internal static class System.Text.EncodingTable : object {
    private static Hashtable s_nameToCodePage;
    private static CodePageDataItem[] s_codePageToCodePageData;
    private static ReadOnlySpan`1<int> EncodingNameIndices { get; }
    private static ReadOnlySpan`1<ushort> CodePagesByName { get; }
    private static ReadOnlySpan`1<ushort> MappedCodePages { get; }
    private static ReadOnlySpan`1<int> UiFamilyCodePages { get; }
    private static ReadOnlySpan`1<int> WebNameIndices { get; }
    private static ReadOnlySpan`1<UInt32> Flags { get; }
    private static EncodingTable();
    private static ReadOnlySpan`1<int> get_EncodingNameIndices();
    private static ReadOnlySpan`1<ushort> get_CodePagesByName();
    private static ReadOnlySpan`1<ushort> get_MappedCodePages();
    private static ReadOnlySpan`1<int> get_UiFamilyCodePages();
    private static ReadOnlySpan`1<int> get_WebNameIndices();
    private static ReadOnlySpan`1<UInt32> get_Flags();
    internal static int GetCodePageFromName(string name);
    private static int InternalGetCodePageFromName(string name);
    internal static EncodingInfo[] GetEncodings();
    internal static EncodingInfo[] GetEncodings(Dictionary`2<int, EncodingInfo> encodingInfoList);
    internal static CodePageDataItem GetCodePageDataItem(int codePage);
    private static CodePageDataItem InternalGetCodePageDataItem(int codePage, int index);
    private static string GetDisplayName(int codePage);
}
internal class System.Text.Latin1Encoding : Encoding {
    internal static Latin1EncodingSealed s_default;
    public ReadOnlySpan`1<byte> Preamble { get; }
    public bool IsSingleByte { get; }
    private static Latin1Encoding();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetByteCount(string s);
    private int GetByteCountCommon(Char* pChars, int charCount);
    private protected sealed virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual bool TryGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    private int GetBytesCommon(Char* pChars, int charCount, Byte* pBytes, int byteCount, bool throwForDestinationOverflow);
    private protected sealed virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    private protected virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual bool TryGetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    private int GetCharsCommon(Byte* pBytes, int byteCount, Char* pChars, int charCount);
    private protected sealed virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    internal sealed virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal sealed virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal sealed virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    public virtual bool get_IsSingleByte();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    private static bool FallbackSupportsFastGetByteCount(EncoderFallback fallback);
}
internal static class System.Text.Latin1Utility : object {
    public static UIntPtr GetIndexOfFirstNonLatin1Char(Char* pBuffer, UIntPtr bufferLength);
    private static UIntPtr GetIndexOfFirstNonLatin1Char_Default(Char* pBuffer, UIntPtr bufferLength);
    public static UIntPtr NarrowUtf16ToLatin1(Char* pUtf16Buffer, Byte* pLatin1Buffer, UIntPtr elementCount);
    public static void WidenLatin1ToUtf16(Byte* pLatin1Buffer, Char* pUtf16Buffer, UIntPtr elementCount);
    private static void WidenLatin1ToUtf16_Fallback(Byte* pLatin1Buffer, Char* pUtf16Buffer, UIntPtr elementCount);
    private static bool AllCharsInUInt32AreLatin1(UInt32 value);
    private static bool AllCharsInUInt64AreLatin1(ulong value);
    private static bool FirstCharInUInt32IsLatin1(UInt32 value);
    private static void NarrowFourUtf16CharsToLatin1AndWriteToBuffer(Byte& outputBuffer, ulong value);
    private static void NarrowTwoUtf16CharsToLatin1AndWriteToBuffer(Byte& outputBuffer, UInt32 value);
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    [UnsupportedOSPlatformAttribute("browser")]
public static NormalizationForm FormKC;
    [UnsupportedOSPlatformAttribute("browser")]
public static NormalizationForm FormKD;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Rune : ValueType {
    private UInt32 _value;
    private static ReadOnlySpan`1<byte> AsciiCharInfo { get; }
    [NullableAttribute("1")]
private string DebuggerDisplay { get; }
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    [CLSCompliantAttribute("False")]
public Rune(UInt32 value);
    private Rune(UInt32 scalarValue, bool _);
    private static ReadOnlySpan`1<byte> get_AsciiCharInfo();
    public static bool op_Equality(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    [CLSCompliantAttribute("False")]
public static Rune op_Explicit(UInt32 value);
    public static Rune op_Explicit(int value);
    private string get_DebuggerDisplay();
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    private static Rune ChangeCaseCultureAware(Rune rune, TextInfo textInfo, bool toUpper);
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public static Rune GetRuneAt(string input, int index);
    public static bool IsValid(int value);
    [CLSCompliantAttribute("False")]
public static bool IsValid(UInt32 value);
    internal static int ReadFirstRuneFromUtf16Buffer(ReadOnlySpan`1<char> input);
    private static int ReadRuneFromString(string input, int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private sealed virtual override bool System.IUtf8SpanFormattable.TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    [CLSCompliantAttribute("False")]
public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    private static bool TryEncodeToUtf16(Rune value, Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    private static bool TryEncodeToUtf8(Rune value, Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool TryGetRuneAt(string input, int index, Rune& value);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
    public static double GetNumericValue(Rune value);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    private static UnicodeCategory GetUnicodeCategoryNonAscii(Rune value);
    private static bool IsCategoryLetter(UnicodeCategory category);
    private static bool IsCategoryLetterOrDecimalDigit(UnicodeCategory category);
    private static bool IsCategoryNumber(UnicodeCategory category);
    private static bool IsCategoryPunctuation(UnicodeCategory category);
    private static bool IsCategorySeparator(UnicodeCategory category);
    private static bool IsCategorySymbol(UnicodeCategory category);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsWhiteSpace(Rune value);
    [NullableContextAttribute("1")]
public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    [NullableContextAttribute("1")]
public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.Text.SpanLineEnumerator : ValueType {
    private ReadOnlySpan`1<char> _remaining;
    private ReadOnlySpan`1<char> _current;
    private bool _isEnumeratorActive;
    public ReadOnlySpan`1<char> Current { get; }
    internal SpanLineEnumerator(ReadOnlySpan`1<char> buffer);
    public ReadOnlySpan`1<char> get_Current();
    public SpanLineEnumerator GetEnumerator();
    public bool MoveNext();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.Text.SpanRuneEnumerator : ValueType {
    private ReadOnlySpan`1<char> _remaining;
    private Rune _current;
    public Rune Current { get; }
    internal SpanRuneEnumerator(ReadOnlySpan`1<char> buffer);
    public Rune get_Current();
    public SpanRuneEnumerator GetEnumerator();
    public bool MoveNext();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Chars")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Text.StringBuilder : object {
    internal Char[] m_ChunkChars;
    internal StringBuilder m_ChunkPrevious;
    internal int m_ChunkLength;
    internal int m_ChunkOffset;
    internal int m_MaxCapacity;
    public int Capacity { get; public set; }
    public int MaxCapacity { get; }
    public int Length { get; public set; }
    public char Chars { get; public set; }
    [NullableAttribute("0")]
private Span`1<char> RemainingCurrentChunk { get; }
    public StringBuilder(int capacity);
    [NullableContextAttribute("2")]
public StringBuilder(string value);
    [NullableContextAttribute("2")]
public StringBuilder(string value, int capacity);
    [NullableContextAttribute("2")]
public StringBuilder(string value, int startIndex, int length, int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    private StringBuilder(SerializationInfo info, StreamingContext context);
    private StringBuilder(StringBuilder from);
    private StringBuilder(int size, int maxCapacity, StringBuilder previousBlock);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public int get_Capacity();
    public void set_Capacity(int value);
    public int get_MaxCapacity();
    public int EnsureCapacity(int capacity);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
    public StringBuilder Clear();
    public int get_Length();
    public void set_Length(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public ChunkEnumerator GetChunks();
    public StringBuilder Append(char value, int repeatCount);
    private void AppendWithExpansion(char value, int repeatCount);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    private StringBuilder AppendCore(StringBuilder value, int startIndex, int count);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(string value);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [NullableContextAttribute("0")]
public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public StringBuilder Insert(int index, string value, int count);
    private StringBuilder Insert(int index, ReadOnlySpan`1<char> value, int count);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Append(bool value);
    public StringBuilder Append(char value);
    private void AppendWithExpansion(char value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(float value);
    public StringBuilder Append(double value);
    public StringBuilder Append(decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    private StringBuilder AppendSpanFormattable(T value);
    public StringBuilder Append(object value);
    public StringBuilder Append(Char[] value);
    [NullableContextAttribute("0")]
public StringBuilder Append(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public StringBuilder Append(ReadOnlyMemory`1<char> value);
    public StringBuilder Append(AppendInterpolatedStringHandler& handler);
    public StringBuilder Append(IFormatProvider provider, AppendInterpolatedStringHandler& handler);
    public StringBuilder AppendLine(AppendInterpolatedStringHandler& handler);
    public StringBuilder AppendLine(IFormatProvider provider, AppendInterpolatedStringHandler& handler);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(char separator, String[] values);
    private StringBuilder AppendJoinCore(Char& separator, int separatorLength, IEnumerable`1<T> values);
    private StringBuilder AppendJoinCore(Char& separator, int separatorLength, T[] values);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, bool value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, decimal value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Insert(int index, object value);
    [NullableContextAttribute("0")]
public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    private StringBuilder InsertSpanFormattable(int index, T value);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    internal StringBuilder AppendFormatHelper(IFormatProvider provider, string format, ReadOnlySpan`1<object> args);
    public StringBuilder AppendFormat(IFormatProvider provider, CompositeFormat format, TArg0 arg0);
    public StringBuilder AppendFormat(IFormatProvider provider, CompositeFormat format, TArg0 arg0, TArg1 arg1);
    public StringBuilder AppendFormat(IFormatProvider provider, CompositeFormat format, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, CompositeFormat format, Object[] args);
    public StringBuilder AppendFormat(IFormatProvider provider, CompositeFormat format, ReadOnlySpan`1<object> args);
    private StringBuilder AppendFormat(IFormatProvider provider, CompositeFormat format, TArg0 arg0, TArg1 arg1, TArg2 arg2, ReadOnlySpan`1<object> args);
    public StringBuilder Replace(string oldValue, string newValue);
    [NullableContextAttribute("2")]
public bool Equals(StringBuilder sb);
    [NullableContextAttribute("0")]
public bool Equals(ReadOnlySpan`1<char> span);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    private void Append(Char& value, int valueCount);
    private void AppendWithExpansion(Char& value, int valueCount);
    private void Insert(int index, Char& value, int valueCount);
    private void ReplaceAllInChunk(ReadOnlySpan`1<int> replacements, StringBuilder sourceChunk, int removeCount, string value);
    private bool StartsWith(StringBuilder chunk, int indexInChunk, int count, string value);
    private void ReplaceInPlaceAtChunk(StringBuilder& chunk, Int32& indexInChunk, Char& value, int count);
    private StringBuilder FindChunkForIndex(int index);
    private Span`1<char> get_RemainingCurrentChunk();
    private StringBuilder Next(StringBuilder chunk);
    private void ExpandByABlock(int minBlockCharCount);
    private void MakeRoom(int index, int count, StringBuilder& chunk, Int32& indexInChunk, bool doNotMoveFollowingChars);
    private void Remove(int startIndex, int count, StringBuilder& chunk, Int32& indexInChunk);
    [CompilerGeneratedAttribute]
internal static char <AppendFormatHelper>g__MoveNext|111_0(string format, Int32& pos);
}
internal static class System.Text.StringBuilderCache : object {
    [ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
public class System.Text.StringRuneEnumerator : ValueType {
    private string _string;
    private Rune _current;
    private int _nextIndex;
    public Rune Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    internal StringRuneEnumerator(string value);
    public sealed virtual Rune get_Current();
    public StringRuneEnumerator GetEnumerator();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<Rune> System.Collections.Generic.IEnumerable<System.Text.Rune>.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
internal class System.Text.TranscodingStream : Stream {
    private Encoding _innerEncoding;
    private Encoding _thisEncoding;
    private Stream _innerStream;
    private bool _leaveOpen;
    private Encoder _innerEncoder;
    private Decoder _thisDecoder;
    private Encoder _thisEncoder;
    private Decoder _innerDecoder;
    private int _readCharBufferMaxSize;
    private Byte[] _readBuffer;
    private int _readBufferOffset;
    private int _readBufferCount;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal TranscodingStream(Stream innerStream, Encoding innerEncoding, Encoding thisEncoding, bool leaveOpen);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsurePreReadConditions();
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsurePreWriteConditions();
    private ArraySegment`1<byte> FinalFlushWriteBuffers();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [StackTraceHiddenAttribute]
private void ThrowIfDisposed();
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
private void ThrowObjectDisposedException();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("System.Text.TranscodingStream/<<DisposeAsync>g__DisposeAsyncCore|30_0>d")]
[CompilerGeneratedAttribute]
private ValueTask <DisposeAsync>g__DisposeAsyncCore|30_0(ArraySegment`1<byte> pendingData);
    [CompilerGeneratedAttribute]
private void <EnsurePreReadConditions>g__InitializeReadDataStructures|33_0();
    [CompilerGeneratedAttribute]
private void <EnsurePreWriteConditions>g__InitializeReadDataStructures|34_0();
    [AsyncStateMachineAttribute("System.Text.TranscodingStream/<<ReadAsync>g__ReadAsyncCore|41_0>d")]
[CompilerGeneratedAttribute]
private ValueTask`1<int> <ReadAsync>g__ReadAsyncCore|41_0(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.TranscodingStream/<<WriteAsync>g__WriteAsyncCore|50_0>d")]
[CompilerGeneratedAttribute]
private ValueTask <WriteAsync>g__WriteAsyncCore|50_0(ReadOnlyMemory`1<byte> remainingOuterEncodedBytes, CancellationToken cancellationToken);
}
[FlagsAttribute]
internal enum System.Text.TrimType : Enum {
    public int value__;
    public static TrimType Head;
    public static TrimType Tail;
    public static TrimType Both;
}
internal enum System.Text.Unicode.GraphemeClusterBreakType : Enum {
    public int value__;
    public static GraphemeClusterBreakType Other;
    public static GraphemeClusterBreakType CR;
    public static GraphemeClusterBreakType LF;
    public static GraphemeClusterBreakType Control;
    public static GraphemeClusterBreakType Extend;
    public static GraphemeClusterBreakType ZWJ;
    public static GraphemeClusterBreakType Regional_Indicator;
    public static GraphemeClusterBreakType Prepend;
    public static GraphemeClusterBreakType SpacingMark;
    public static GraphemeClusterBreakType L;
    public static GraphemeClusterBreakType V;
    public static GraphemeClusterBreakType T;
    public static GraphemeClusterBreakType LV;
    public static GraphemeClusterBreakType LVT;
    public static GraphemeClusterBreakType Extended_Pictograph;
}
internal static class System.Text.Unicode.TextSegmentationUtility : object {
    private static DecodeFirstRune`1<char> _utf16Decoder;
    private static TextSegmentationUtility();
    private static int GetLengthOfFirstExtendedGraphemeCluster(ReadOnlySpan`1<T> input, DecodeFirstRune`1<T> decoder);
    public static int GetLengthOfFirstUtf16ExtendedGraphemeCluster(ReadOnlySpan`1<char> input);
}
internal static class System.Text.Unicode.Utf16Utility : object {
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool AllCharsInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToUppercase(UInt32 value);
    internal static ulong ConvertAllAsciiCharsInUInt64ToUppercase(ulong value);
    internal static ulong ConvertAllAsciiCharsInUInt64ToLowercase(ulong value);
    internal static bool UInt32ContainsAnyLowercaseAsciiChar(UInt32 value);
    internal static bool UInt32ContainsAnyUppercaseAsciiChar(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
    internal static bool AllCharsInVector128AreAscii(Vector128`1<ushort> vec);
    internal static bool Vector128OrdinalIgnoreCaseAscii(Vector128`1<ushort> vec1, Vector128`1<ushort> vec2);
    public static Char* GetPointerToFirstInvalidChar(Char* pInputBuffer, int inputLength, Int64& utf8CodeUnitCountAdjustment, Int32& scalarCountAdjustment);
}
public static class System.Text.Unicode.Utf8 : object {
    public static OperationStatus FromUtf16(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& charsRead, Int32& bytesWritten, bool replaceInvalidSequences, bool isFinalBlock);
    public static OperationStatus ToUtf16(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& bytesRead, Int32& charsWritten, bool replaceInvalidSequences, bool isFinalBlock);
    internal static OperationStatus ToUtf16PreservingReplacement(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& bytesRead, Int32& charsWritten, bool replaceInvalidSequences, bool isFinalBlock);
    public static bool TryWrite(Span`1<byte> destination, TryWriteInterpolatedStringHandler& handler, Int32& bytesWritten);
    public static bool TryWrite(Span`1<byte> destination, IFormatProvider provider, TryWriteInterpolatedStringHandler& handler, Int32& bytesWritten);
    public static bool IsValid(ReadOnlySpan`1<byte> value);
}
internal static class System.Text.Unicode.Utf8Utility : object {
    public static int GetIndexOfFirstInvalidUtf8Sequence(ReadOnlySpan`1<byte> utf8Data, Boolean& isAscii);
    internal static bool AllBytesInUInt32AreAscii(UInt32 value);
    internal static bool AllBytesInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiBytesInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiBytesInUInt32ToUppercase(UInt32 value);
    internal static ulong ConvertAllAsciiBytesInUInt64ToUppercase(ulong value);
    internal static ulong ConvertAllAsciiBytesInUInt64ToLowercase(ulong value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
    internal static bool AllBytesInVector128AreAscii(Vector128`1<byte> vec);
    internal static bool Vector128OrdinalIgnoreCaseAscii(Vector128`1<byte> vec1, Vector128`1<byte> vec2);
    private static UInt32 ExtractCharFromFirstThreeByteSequence(UInt32 value);
    private static UInt32 ExtractCharFromFirstTwoByteSequence(UInt32 value);
    private static UInt32 ExtractCharsFromFourByteSequence(UInt32 value);
    private static UInt32 ExtractFourUtf8BytesFromSurrogatePair(UInt32 value);
    private static UInt32 ExtractTwoCharsPackedFromTwoAdjacentTwoByteSequences(UInt32 value);
    private static UInt32 ExtractTwoUtf8TwoByteSequencesFromTwoPackedUtf16Chars(UInt32 value);
    private static UInt32 ExtractUtf8TwoByteSequenceFromFirstUtf16Char(UInt32 value);
    private static bool IsFirstCharAscii(UInt32 value);
    private static bool IsFirstCharAtLeastThreeUtf8Bytes(UInt32 value);
    private static bool IsFirstCharSurrogate(UInt32 value);
    private static bool IsFirstCharTwoUtf8Bytes(UInt32 value);
    private static bool IsLowByteUtf8ContinuationByte(UInt32 value);
    private static bool IsSecondCharAscii(UInt32 value);
    private static bool IsSecondCharAtLeastThreeUtf8Bytes(UInt32 value);
    private static bool IsSecondCharSurrogate(UInt32 value);
    private static bool IsSecondCharTwoUtf8Bytes(UInt32 value);
    internal static bool IsUtf8ContinuationByte(Byte& value);
    private static bool IsWellFormedUtf16SurrogatePair(UInt32 value);
    private static UInt32 ToLittleEndian(UInt32 value);
    private static bool UInt32BeginsWithOverlongUtf8TwoByteSequence(UInt32 value);
    private static bool UInt32BeginsWithUtf8FourByteMask(UInt32 value);
    private static bool UInt32BeginsWithUtf8ThreeByteMask(UInt32 value);
    private static bool UInt32BeginsWithUtf8TwoByteMask(UInt32 value);
    private static bool UInt32BeginsWithValidUtf8TwoByteSequenceLittleEndian(UInt32 value);
    private static bool UInt32EndsWithValidUtf8TwoByteSequenceLittleEndian(UInt32 value);
    private static bool UInt32FirstByteIsAscii(UInt32 value);
    private static bool UInt32FourthByteIsAscii(UInt32 value);
    private static bool UInt32SecondByteIsAscii(UInt32 value);
    private static bool UInt32ThirdByteIsAscii(UInt32 value);
    private static void WriteTwoUtf16CharsAsTwoUtf8ThreeByteSequences(Byte& outputBuffer, UInt32 value);
    private static void WriteFirstUtf16CharAsUtf8ThreeByteSequence(Byte& outputBuffer, UInt32 value);
    public static OperationStatus TranscodeToUtf16(Byte* pInputBuffer, int inputLength, Char* pOutputBuffer, int outputCharsRemaining, Byte*& pInputBufferRemaining, Char*& pOutputBufferRemaining);
    public static OperationStatus TranscodeToUtf8(Char* pInputBuffer, int inputLength, Byte* pOutputBuffer, int outputBytesRemaining, Char*& pInputBufferRemaining, Byte*& pOutputBufferRemaining);
    public static Byte* GetPointerToFirstInvalidByte(Byte* pInputBuffer, int inputLength, Int32& utf16CodeUnitCountAdjustment, Int32& scalarCountAdjustment);
    [CompExactlyDependsOnAttribute("System.Runtime.Intrinsics.Arm.AdvSimd/Arm64")]
private static ulong GetNonAsciiBytes(Vector128`1<byte> value, Vector128`1<byte> bitMask128);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.UnicodeEncoding : Encoding {
    internal static UnicodeEncoding s_bigEndianDefault;
    internal static UnicodeEncoding s_littleEndianDefault;
    private bool isThrowException;
    private bool bigEndian;
    private bool byteOrderMark;
    public static int CharSize;
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark);
    public UnicodeEncoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidBytes);
    private static UnicodeEncoding();
    internal sealed virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Encoder GetEncoder();
    public virtual Decoder GetDecoder();
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
internal static class System.Text.UnicodeUtility : object {
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidCodePoint(UInt32 codePoint);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.UTF32Encoding : Encoding {
    internal static UTF32Encoding s_default;
    internal static UTF32Encoding s_bigEndianDefault;
    private bool _emitUTF32ByteOrderMark;
    private bool _isThrowException;
    private bool _bigEndian;
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF32Encoding(bool bigEndian, bool byteOrderMark);
    public UTF32Encoding(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);
    private static UTF32Encoding();
    internal virtual void SetDefaultFallbacks();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal virtual int GetByteCount(Char* chars, int count, EncoderNLS encoder);
    internal virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS encoder);
    internal virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    private static UInt32 GetSurrogate(char cHigh, char cLow);
    private static char GetHighSurrogate(UInt32 iChar);
    private static char GetLowSurrogate(UInt32 iChar);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.UTF7Encoding : Encoding {
    internal static UTF7Encoding s_default;
    private Byte[] _base64Bytes;
    private SByte[] _base64Values;
    private Boolean[] _directEncode;
    private bool _allowOptionals;
    [ObsoleteAttribute("The UTF-7 encoding is insecure and should not be used. Consider using UTF-8 instead.")]
public UTF7Encoding(bool allowOptionals);
    private static UTF7Encoding();
    [MemberNotNullAttribute("_base64Bytes")]
[MemberNotNullAttribute("_base64Values")]
[MemberNotNullAttribute("_directEncode")]
private void MakeTables();
    internal sealed virtual void SetDefaultFallbacks();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual string GetString(Byte[] bytes, int index, int count);
    internal sealed virtual int GetByteCount(Char* chars, int count, EncoderNLS baseEncoder);
    internal sealed virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, EncoderNLS baseEncoder);
    internal sealed virtual int GetCharCount(Byte* bytes, int count, DecoderNLS baseDecoder);
    internal sealed virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, DecoderNLS baseDecoder);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
public class System.Text.UTF8Encoding : Encoding {
    internal static UTF8EncodingSealed s_default;
    private bool _emitUTF8Identifier;
    private bool _isThrowException;
    internal static ReadOnlySpan`1<byte> PreambleSpan { get; }
    public ReadOnlySpan`1<byte> Preamble { get; }
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier);
    public UTF8Encoding(bool encoderShouldEmitUTF8Identifier, bool throwOnInvalidBytes);
    private static UTF8Encoding();
    internal static ReadOnlySpan`1<byte> get_PreambleSpan();
    internal sealed virtual void SetDefaultFallbacks();
    [NullableContextAttribute("1")]
public virtual int GetByteCount(Char[] chars, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetByteCount(string chars);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    private int GetByteCountCommon(Char* pChars, int charCount);
    private protected sealed virtual int GetByteCountFast(Char* pChars, int charsLength, EncoderFallback fallback, Int32& charsConsumed);
    [NullableContextAttribute("1")]
public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("1")]
public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual bool TryGetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    private int GetBytesCommon(Char* pChars, int charCount, Byte* pBytes, int byteCount, bool throwForDestinationOverflow);
    private protected sealed virtual int GetBytesFast(Char* pChars, int charsLength, Byte* pBytes, int bytesLength, Int32& charsConsumed);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual bool TryGetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten);
    private int GetCharsCommon(Byte* pBytes, int byteCount, Char* pChars, int charCount, bool throwForDestinationOverflow);
    private protected sealed virtual int GetCharsFast(Byte* pBytes, int bytesLength, Char* pChars, int charsLength, Int32& bytesConsumed);
    private protected sealed virtual int GetCharsWithFallback(ReadOnlySpan`1<byte> bytes, int originalBytesLength, Span`1<char> chars, int originalCharsLength, DecoderNLS decoder, bool throwForDestinationOverflow);
    [NullableContextAttribute("1")]
public virtual string GetString(Byte[] bytes, int index, int count);
    private int GetCharCountCommon(Byte* pBytes, int byteCount);
    private protected sealed virtual int GetCharCountFast(Byte* pBytes, int bytesLength, DecoderFallback fallback, Int32& bytesConsumed);
    [NullableContextAttribute("1")]
public virtual Decoder GetDecoder();
    [NullableContextAttribute("1")]
public virtual Encoder GetEncoder();
    internal sealed virtual bool TryGetByteCount(Rune value, Int32& byteCount);
    internal sealed virtual OperationStatus EncodeRune(Rune value, Span`1<byte> bytes, Int32& bytesWritten);
    internal sealed virtual OperationStatus DecodeFirstRune(ReadOnlySpan`1<byte> bytes, Rune& value, Int32& bytesConsumed);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    [NullableContextAttribute("1")]
public virtual Byte[] GetPreamble();
    public virtual ReadOnlySpan`1<byte> get_Preamble();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class System.Text.ValueStringBuilder : ValueType {
    private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; public set; }
    public Char& Item { get; }
    public ValueStringBuilder(Span`1<char> initialBuffer);
    public ValueStringBuilder(int initialCapacity);
    internal void AppendFormatHelper(IFormatProvider provider, string format, ReadOnlySpan`1<object> args);
    public int get_Length();
    public void set_Length(int value);
    public void EnsureCapacity(int capacity);
    public Char& get_Item(int index);
    public virtual string ToString();
    public ReadOnlySpan`1<char> AsSpan();
    public void Append(char c);
    public void Append(string s);
    private void AppendSlow(string s);
    public void Append(char c, int count);
    public void Append(ReadOnlySpan`1<char> value);
    public Span`1<char> AppendSpan(int length);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
    internal void AppendSpanFormattable(T value, string format, IFormatProvider provider);
    [CompilerGeneratedAttribute]
internal static char <AppendFormatHelper>g__MoveNext|0_0(string format, Int32& pos);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class System.Text.ValueUtf8Converter : ValueType {
    private Byte[] _arrayToReturnToPool;
    private Span`1<byte> _bytes;
    public ValueUtf8Converter(Span`1<byte> initialBuffer);
    public Span`1<byte> ConvertAndTerminateString(ReadOnlySpan`1<char> value);
    public void Dispose();
}
internal class System.Threading._ThreadPoolWaitOrTimerCallback : object {
    private WaitOrTimerCallback _waitOrTimerCallback;
    private ExecutionContext _executionContext;
    private object _state;
    private static ContextCallback _ccbt;
    private static ContextCallback _ccbf;
    internal _ThreadPoolWaitOrTimerCallback(WaitOrTimerCallback waitOrTimerCallback, object state, bool flowExecutionContext);
    private static _ThreadPoolWaitOrTimerCallback();
    private static void WaitOrTimerCallback_Context_t(object state);
    private static void WaitOrTimerCallback_Context_f(object state);
    private static void WaitOrTimerCallback_Context(object state, bool timedOut);
    internal static void PerformWaitOrTimerCallback(_ThreadPoolWaitOrTimerCallback helper, bool timedOut);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.AbandonedMutexException : SystemException {
    private int _mutexIndex;
    private Mutex _mutex;
    public Mutex Mutex { get; }
    public int MutexIndex { get; }
    public AbandonedMutexException(string message);
    public AbandonedMutexException(string message, Exception inner);
    public AbandonedMutexException(int location, WaitHandle handle);
    public AbandonedMutexException(string message, int location, WaitHandle handle);
    public AbandonedMutexException(string message, Exception inner, int location, WaitHandle handle);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected AbandonedMutexException(SerializationInfo info, StreamingContext context);
    private void SetupException(int location, WaitHandle handle);
    public Mutex get_Mutex();
    public int get_MutexIndex();
}
public enum System.Threading.ApartmentState : Enum {
    public int value__;
    public static ApartmentState STA;
    public static ApartmentState MTA;
    public static ApartmentState Unknown;
}
public class System.Threading.AsyncFlowControl : ValueType {
    private Thread _thread;
    internal void Initialize(Thread currentThread);
    public void Undo();
    public sealed virtual void Dispose();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AsyncFlowControl obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AsyncFlowControl a, AsyncFlowControl b);
    public static bool op_Inequality(AsyncFlowControl a, AsyncFlowControl b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.AsyncLocal`1 : object {
    private Action`1<AsyncLocalValueChangedArgs`1<T>> _valueChangedHandler;
    public T Value { get; public set; }
    public AsyncLocal`1(Action`1<AsyncLocalValueChangedArgs`1<T>> valueChangedHandler);
    public T get_Value();
    public void set_Value(T value);
    private sealed virtual override void System.Threading.IAsyncLocal.OnValueChanged(object previousValueObj, object currentValueObj, bool contextChanged);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Threading.AsyncLocalValueChangedArgs`1 : ValueType {
    [CompilerGeneratedAttribute]
private T <PreviousValue>k__BackingField;
    [CompilerGeneratedAttribute]
private T <CurrentValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThreadContextChanged>k__BackingField;
    public T PreviousValue { get; }
    public T CurrentValue { get; }
    public bool ThreadContextChanged { get; }
    internal AsyncLocalValueChangedArgs`1(T previousValue, T currentValue, bool contextChanged);
    [CompilerGeneratedAttribute]
public T get_PreviousValue();
    [CompilerGeneratedAttribute]
public T get_CurrentValue();
    [CompilerGeneratedAttribute]
public bool get_ThreadContextChanged();
}
internal static class System.Threading.AsyncLocalValueMap : object {
    [CompilerGeneratedAttribute]
private static IAsyncLocalValueMap <Empty>k__BackingField;
    public static IAsyncLocalValueMap Empty { get; }
    private static AsyncLocalValueMap();
    [CompilerGeneratedAttribute]
public static IAsyncLocalValueMap get_Empty();
    public static bool IsEmpty(IAsyncLocalValueMap asyncLocalValueMap);
    public static IAsyncLocalValueMap Create(IAsyncLocal key, object value, bool treatNullValueAsNonexistent);
}
public class System.Threading.AutoResetEvent : EventWaitHandle {
    public AutoResetEvent(bool initialState);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("IsCancellationRequested = {IsCancellationRequested}")]
public class System.Threading.CancellationToken : ValueType {
    private CancellationTokenSource _source;
    public static CancellationToken None { get; }
    public bool IsCancellationRequested { get; }
    public bool CanBeCanceled { get; }
    [NullableAttribute("1")]
public WaitHandle WaitHandle { get; }
    internal CancellationToken(CancellationTokenSource source);
    public CancellationToken(bool canceled);
    public static CancellationToken get_None();
    public bool get_IsCancellationRequested();
    public bool get_CanBeCanceled();
    [NullableContextAttribute("1")]
public WaitHandle get_WaitHandle();
    [NullableContextAttribute("1")]
public CancellationTokenRegistration Register(Action callback);
    [NullableContextAttribute("1")]
public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`2<object, CancellationToken> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    public CancellationTokenRegistration UnsafeRegister(Action`1<object> callback, object state);
    public CancellationTokenRegistration UnsafeRegister(Action`2<object, CancellationToken> callback, object state);
    private CancellationTokenRegistration Register(Delegate callback, object state, bool useSynchronizationContext, bool useExecutionContext);
    public sealed virtual bool Equals(CancellationToken other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    public void ThrowIfCancellationRequested();
    [DoesNotReturnAttribute]
private void ThrowOperationCanceledException();
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private long _id;
    private CallbackNode _node;
    public CancellationToken Token { get; }
    internal CancellationTokenRegistration(long id, CallbackNode node);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    public CancellationToken get_Token();
    public bool Unregister();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static void <Dispose>g__WaitForCallbackIfNecessary|3_0(long id, CallbackNode node);
    [CompilerGeneratedAttribute]
internal static ValueTask <DisposeAsync>g__WaitForCallbackIfNecessaryAsync|4_0(long id, CallbackNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.CancellationTokenSource : object {
    internal static CancellationTokenSource s_canceledSource;
    internal static CancellationTokenSource s_neverCanceledSource;
    private static TimerCallback s_timerCallback;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private bool _disposed;
    private ITimer modreq(System.Runtime.CompilerServices.IsVolatile) _timer;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) _kernelEvent;
    private Registrations _registrations;
    public bool IsCancellationRequested { get; }
    internal bool IsCancellationCompleted { get; }
    public CancellationToken Token { get; }
    internal WaitHandle WaitHandle { get; }
    public CancellationTokenSource(TimeSpan delay);
    public CancellationTokenSource(TimeSpan delay, TimeProvider timeProvider);
    public CancellationTokenSource(int millisecondsDelay);
    private static CancellationTokenSource();
    private static void TimerCallback(object state);
    public bool get_IsCancellationRequested();
    internal bool get_IsCancellationCompleted();
    public CancellationToken get_Token();
    internal WaitHandle get_WaitHandle();
    private void InitializeWithTimer(TimeSpan millisecondsDelay, TimeProvider timeProvider);
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public Task CancelAsync();
    public void CancelAfter(TimeSpan delay);
    public void CancelAfter(int millisecondsDelay);
    private void CancelAfter(UInt32 millisecondsDelay);
    public bool TryReset();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    internal CancellationTokenRegistration Register(Delegate callback, object stateForCallback, SynchronizationContext syncContext, ExecutionContext executionContext);
    private void NotifyCancellation(bool throwOnFirstException);
    private bool TransitionToCancellationRequested();
    private void ExecuteCallbackHandlers(bool throwOnFirstException);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    private static void Invoke(Delegate d, object state, CancellationTokenSource source);
}
internal class System.Threading.CompleteWaitThreadPoolWorkItem : object {
    private RegisteredWaitHandle _registeredWaitHandle;
    private bool _timedOut;
    public CompleteWaitThreadPoolWorkItem(RegisteredWaitHandle registeredWaitHandle, bool timedOut);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.CompressedStack : object {
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static CompressedStack Capture();
    public CompressedStack CreateCopy();
    public static CompressedStack GetCompressedStack();
    public static void Run(CompressedStack compressedStack, ContextCallback callback, object state);
}
public class System.Threading.ContextCallback : MulticastDelegate {
    public ContextCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.DeferredDisposableLifetime`1 : ValueType {
    private int _count;
    public bool AddRef();
    public void Release(T obj);
    public void Dispose(T obj);
}
public enum System.Threading.EventResetMode : Enum {
    public int value__;
    public static EventResetMode AutoReset;
    public static EventResetMode ManualReset;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.EventWaitHandle : WaitHandle {
    public EventWaitHandle(bool initialState, EventResetMode mode);
    [NullableContextAttribute("2")]
public EventWaitHandle(bool initialState, EventResetMode mode, string name);
    [NullableContextAttribute("2")]
public EventWaitHandle(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    [SupportedOSPlatformAttribute("windows")]
public static EventWaitHandle OpenExisting(string name);
    [SupportedOSPlatformAttribute("windows")]
public static bool TryOpenExisting(string name, EventWaitHandle& result);
    private void CreateEventCore(bool initialState, EventResetMode mode, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, EventWaitHandle& result);
    public bool Reset();
    public bool Set();
    internal static bool Set(SafeWaitHandle waitHandle);
    private SafeWaitHandle ValidateHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.ExecutionContext : object {
    internal static ExecutionContext Default;
    private static ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultFlowSuppressed;
    private IAsyncLocalValueMap m_localValues;
    private IAsyncLocal[] m_localChangeNotifications;
    private bool m_isFlowSuppressed;
    private bool m_isDefault;
    internal bool HasChangeNotifications { get; }
    internal bool IsDefault { get; }
    private ExecutionContext(IAsyncLocalValueMap localValues, IAsyncLocal[] localChangeNotifications, bool isFlowSuppressed);
    private static ExecutionContext();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public static ExecutionContext Capture();
    internal static ExecutionContext CaptureForRestore();
    private ExecutionContext ShallowClone(bool isFlowSuppressed);
    public static AsyncFlowControl SuppressFlow();
    public static void RestoreFlow();
    public static bool IsFlowSuppressed();
    internal bool get_HasChangeNotifications();
    internal bool get_IsDefault();
    public static void Run(ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunInternal(ExecutionContext executionContext, ContextCallback callback, object state);
    public static void Restore(ExecutionContext executionContext);
    internal static void RestoreInternal(ExecutionContext executionContext);
    internal static void RunFromThreadPoolDispatchLoop(Thread threadPoolThread, ExecutionContext executionContext, ContextCallback callback, object state);
    internal static void RunForThreadPoolUnsafe(ExecutionContext executionContext, Action`1<TState> callback, TState& state);
    internal static void RestoreChangedContextToThread(Thread currentThread, ExecutionContext contextToRestore, ExecutionContext currentContext);
    internal static void ResetThreadPoolThread(Thread currentThread);
    internal static void OnValuesChanged(ExecutionContext previousExecutionCtx, ExecutionContext nextExecutionCtx);
    [DoesNotReturnAttribute]
[StackTraceHiddenAttribute]
private static void ThrowNullContext();
    internal static object GetLocalValue(IAsyncLocal local);
    internal static void SetLocalValue(IAsyncLocal local, object newValue, bool needChangeNotifications);
    public ExecutionContext CreateCopy();
    public sealed virtual void Dispose();
}
internal interface System.Threading.IAsyncLocal {
    public abstract virtual void OnValueChanged(object previousValue, object currentValue, bool contextChanged);
}
internal interface System.Threading.IAsyncLocalValueMap {
    public abstract virtual bool TryGetValue(IAsyncLocal key, Object& value);
    public abstract virtual IAsyncLocalValueMap Set(IAsyncLocal key, object value, bool treatNullValueAsNonexistent);
}
internal interface System.Threading.IDeferredDisposable {
    public abstract virtual void OnFinalRelease(bool disposed);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.Interlocked : object {
    [IntrinsicAttribute]
public static int CompareExchange(Int32& location1, int value, int comparand);
    [IntrinsicAttribute]
private static void CompareExchange(Object& location1, Object& value, Object& comparand, Object& result);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static object CompareExchange(Object& location1, object value, object comparand);
    [IntrinsicAttribute]
public static int Decrement(Int32& location);
    [IntrinsicAttribute]
public static long Decrement(Int64& location);
    [IntrinsicAttribute]
public static int Increment(Int32& location);
    [IntrinsicAttribute]
public static long Increment(Int64& location);
    [IntrinsicAttribute]
public static int Exchange(Int32& location1, int value);
    private static void Exchange(Object& location1, Object& value, Object& result);
    [NullableContextAttribute("2")]
public static object Exchange(Object& location1, object value);
    public static long CompareExchange(Int64& location1, long value, long comparand);
    [IntrinsicAttribute]
public static T CompareExchange(T& location1, T value, T comparand);
    [IntrinsicAttribute]
public static long Exchange(Int64& location1, long value);
    [IntrinsicAttribute]
public static T Exchange(T& location1, T value);
    [IntrinsicAttribute]
public static long Read(Int64& location);
    [IntrinsicAttribute]
public static int Add(Int32& location1, int value);
    [IntrinsicAttribute]
public static long Add(Int64& location1, long value);
    public static void MemoryBarrierProcessWide();
    [CLSCompliantAttribute("False")]
public static UInt32 Increment(UInt32& location);
    [CLSCompliantAttribute("False")]
public static ulong Increment(UInt64& location);
    [CLSCompliantAttribute("False")]
public static UInt32 Decrement(UInt32& location);
    [CLSCompliantAttribute("False")]
public static ulong Decrement(UInt64& location);
    [CLSCompliantAttribute("False")]
public static UInt32 Exchange(UInt32& location1, UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong Exchange(UInt64& location1, ulong value);
    public static float Exchange(Single& location1, float value);
    public static double Exchange(Double& location1, double value);
    public static IntPtr Exchange(IntPtr& location1, IntPtr value);
    [CLSCompliantAttribute("False")]
public static UIntPtr Exchange(UIntPtr& location1, UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt32 CompareExchange(UInt32& location1, UInt32 value, UInt32 comparand);
    [CLSCompliantAttribute("False")]
public static ulong CompareExchange(UInt64& location1, ulong value, ulong comparand);
    public static float CompareExchange(Single& location1, float value, float comparand);
    public static double CompareExchange(Double& location1, double value, double comparand);
    public static IntPtr CompareExchange(IntPtr& location1, IntPtr value, IntPtr comparand);
    [CLSCompliantAttribute("False")]
public static UIntPtr CompareExchange(UIntPtr& location1, UIntPtr value, UIntPtr comparand);
    [CLSCompliantAttribute("False")]
public static UInt32 Add(UInt32& location1, UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong Add(UInt64& location1, ulong value);
    [CLSCompliantAttribute("False")]
public static ulong Read(UInt64& location);
    [IntrinsicAttribute]
public static int And(Int32& location1, int value);
    [CLSCompliantAttribute("False")]
public static UInt32 And(UInt32& location1, UInt32 value);
    [IntrinsicAttribute]
public static long And(Int64& location1, long value);
    [CLSCompliantAttribute("False")]
public static ulong And(UInt64& location1, ulong value);
    [IntrinsicAttribute]
public static int Or(Int32& location1, int value);
    [CLSCompliantAttribute("False")]
public static UInt32 Or(UInt32& location1, UInt32 value);
    [IntrinsicAttribute]
public static long Or(Int64& location1, long value);
    [CLSCompliantAttribute("False")]
public static ulong Or(UInt64& location1, ulong value);
    [IntrinsicAttribute]
public static void MemoryBarrier();
}
[CLSCompliantAttribute("False")]
public class System.Threading.IOCompletionCallback : MulticastDelegate {
    public IOCompletionCallback(object object, IntPtr method);
    public virtual void Invoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP);
    public virtual IAsyncResult BeginInvoke(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* pOVERLAP, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.IOCompletionCallbackHelper : object {
    private IOCompletionCallback _ioCompletionCallback;
    private ExecutionContext _executionContext;
    private UInt32 _errorCode;
    private UInt32 _numBytes;
    private NativeOverlapped* _pNativeOverlapped;
    private static ContextCallback IOCompletionCallback_Context_Delegate;
    public IOCompletionCallbackHelper(IOCompletionCallback ioCompletionCallback, ExecutionContext executionContext);
    private static IOCompletionCallbackHelper();
    private static void IOCompletionCallback_Context(object state);
}
internal interface System.Threading.IThreadPoolTypedWorkItemQueueCallback`1 {
    public static abstract virtual void Invoke(T item);
}
public interface System.Threading.IThreadPoolWorkItem {
    public abstract virtual void Execute();
}
public interface System.Threading.ITimer {
    public abstract virtual bool Change(TimeSpan dueTime, TimeSpan period);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.LazyInitializer : object {
    public static T EnsureInitialized(T& target);
    private static T EnsureInitializedCore(T& target);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock);
    public static T EnsureInitialized(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Boolean& initialized, Object& syncLock, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static T EnsureInitializedCore(T& target, Object& syncLock, Func`1<T> valueFactory);
    private static object EnsureLockInitialized(Object& syncLock);
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.LockRecursionException : Exception {
    public LockRecursionException(string message);
    public LockRecursionException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected LockRecursionException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.LockRecursionPolicy : Enum {
    public int value__;
    public static LockRecursionPolicy NoRecursion;
    public static LockRecursionPolicy SupportsRecursion;
}
internal class System.Threading.LowLevelLifoSemaphore : LowLevelLifoSemaphoreBase {
    private IntPtr lifo_semaphore;
    public LowLevelLifoSemaphore(int initialSignalCount, int maximumSignalCount, int spinCount, Action onWait);
    private static IntPtr InitInternal();
    private void Create(int maximumSignalCount);
    private static void DeleteInternal(IntPtr semaphore);
    public sealed virtual void Dispose();
    private static int TimedWaitInternal(IntPtr semaphore, int timeoutMs);
    private bool WaitCore(int timeoutMs);
    private static void ReleaseInternal(IntPtr semaphore, int count);
    protected virtual void ReleaseCore(int count);
    public bool Wait(int timeoutMs, bool spinWait);
    private bool WaitForSignal(int timeoutMs);
}
internal abstract class System.Threading.LowLevelLifoSemaphoreBase : object {
    protected CacheLineSeparatedCounts _separated;
    protected int _maximumSignalCount;
    protected int _spinCount;
    protected Action _onWait;
    public LowLevelLifoSemaphoreBase(int initialSignalCount, int maximumSignalCount, int spinCount, Action onWait);
    protected abstract virtual void ReleaseCore(int count);
    public void Release(int releaseCount);
}
internal class System.Threading.LowLevelLock : object {
    private static Func`2<object, bool> s_spinWaitTryAcquireCallback;
    private int _state;
    private bool _isAnyWaitingThreadSignaled;
    private LowLevelSpinWaiter _spinWaiter;
    private LowLevelMonitor _monitor;
    private static LowLevelLock();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public bool TryAcquire();
    private bool TryAcquire_NoFastPath(int state);
    private static bool SpinWaitTryAcquireCallback(object state);
    public void Acquire();
    private void WaitAndAcquire();
    public void Release();
    private void SignalWaiter();
}
internal class System.Threading.LowLevelMonitor : ValueType {
    private IntPtr _nativeMonitor;
    public void Dispose();
    public void Acquire();
    public void Release();
    public void Wait();
    public bool Wait(int timeoutMilliseconds);
    public void Signal_Release();
    public void Initialize();
    private void DisposeCore();
    private void AcquireCore();
    private void ReleaseCore();
    private void WaitCore();
    private bool WaitCore(int timeoutMilliseconds);
    private void Signal_ReleaseCore();
}
internal class System.Threading.LowLevelSpinWaiter : ValueType {
    private int _spinningThreadCount;
    public bool SpinWaitForCondition(Func`2<object, bool> condition, object state, int spinCount, int sleep0Threshold);
    public static void Wait(int spinIndex, int sleep0Threshold, int processorCount);
}
public class System.Threading.ManualResetEvent : EventWaitHandle {
    public ManualResetEvent(bool initialState);
}
[DebuggerDisplayAttribute("Set = {IsSet}")]
public class System.Threading.ManualResetEventSlim : object {
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_lock;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_eventObj;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_combinedState;
    private static Action`1<object> s_cancellationTokenCallback;
    [NullableAttribute("1")]
public WaitHandle WaitHandle { get; }
    public bool IsSet { get; private set; }
    public int SpinCount { get; private set; }
    private int Waiters { get; private set; }
    private bool IsDisposed { get; }
    public ManualResetEventSlim(bool initialState);
    public ManualResetEventSlim(bool initialState, int spinCount);
    private static ManualResetEventSlim();
    [NullableContextAttribute("1")]
public WaitHandle get_WaitHandle();
    public bool get_IsSet();
    private void set_IsSet(bool value);
    public int get_SpinCount();
    private void set_SpinCount(int value);
    private int get_Waiters();
    private void set_Waiters(int value);
    private void Initialize(bool initialState, int spinCount);
    private void EnsureLockObjectCreated();
    private void LazyInitializeEvent();
    public void Set();
    private void Set(bool duringCancellation);
    public void Reset();
    [UnsupportedOSPlatformAttribute("browser")]
public void Wait();
    [UnsupportedOSPlatformAttribute("browser")]
public void Wait(CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(TimeSpan timeout);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(int millisecondsTimeout);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private bool get_IsDisposed();
    private static void CancellationTokenCallback(object obj);
    private void UpdateStateAtomically(int newBits, int updateBitsMask);
    private static int ExtractStatePortionAndShiftRight(int state, int mask, int rightBitShiftCount);
    private static int ExtractStatePortion(int state, int mask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.Monitor : object {
    public static long LockContentionCount { get; }
    [IntrinsicAttribute]
public static void Enter(object obj);
    [IntrinsicAttribute]
public static void Enter(object obj, Boolean& lockTaken);
    private static void InternalExit(object obj);
    public static void Exit(object obj);
    public static bool TryEnter(object obj);
    public static void TryEnter(object obj, Boolean& lockTaken);
    public static bool TryEnter(object obj, int millisecondsTimeout);
    public static void TryEnter(object obj, int millisecondsTimeout, Boolean& lockTaken);
    public static bool IsEntered(object obj);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool Wait(object obj, int millisecondsTimeout);
    public static void Pulse(object obj);
    public static void PulseAll(object obj);
    private static void Monitor_pulse(object obj);
    private static void ObjPulse(object obj);
    private static void Monitor_pulse_all(object obj);
    private static void ObjPulseAll(object obj);
    internal static bool Monitor_wait(object obj, int ms, bool allowInterruption);
    private static bool ObjWait(int millisecondsTimeout, object obj);
    internal static void try_enter_with_atomic_var(object obj, int millisecondsTimeout, bool allowInterruption, Boolean& lockTaken);
    private static void ReliableEnterTimeout(object obj, int timeout, Boolean& lockTaken);
    public static long get_LockContentionCount();
    public static bool TryEnter(object obj, TimeSpan timeout);
    public static void TryEnter(object obj, TimeSpan timeout, Boolean& lockTaken);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool Wait(object obj, TimeSpan timeout);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool Wait(object obj);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool Wait(object obj, int millisecondsTimeout, bool exitContext);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool Wait(object obj, TimeSpan timeout, bool exitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Mutex : WaitHandle {
    [NullableContextAttribute("2")]
public Mutex(bool initiallyOwned, string name, Boolean& createdNew);
    [NullableContextAttribute("2")]
public Mutex(bool initiallyOwned, string name);
    public Mutex(bool initiallyOwned);
    private Mutex(SafeWaitHandle handle);
    public static Mutex OpenExisting(string name);
    public static bool TryOpenExisting(string name, Mutex& result);
    private void CreateMutexCore(bool initiallyOwned, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Mutex& result);
    public void ReleaseMutex();
}
public class System.Threading.NativeOverlapped : ValueType {
    public IntPtr InternalLow;
    public IntPtr InternalHigh;
    public int OffsetLow;
    public int OffsetHigh;
    public IntPtr EventHandle;
}
internal static class System.Threading.ObjectHeader : object {
    private static LockWord GetLockWord(ObjectHeaderOnStack h);
    private static IntPtr LockWordCompareExchange(ObjectHeaderOnStack h, LockWord nlw, LockWord expected);
    public static bool TryGetHashCode(object o, Int32& hash);
    private static bool TryEnterInflatedFast(MonoThreadsSync& mon, int small_id);
    public static bool TryEnterFast(object o);
    public static bool IsEntered(object obj);
    public static bool HasOwner(object obj);
    private static bool TryExitInflated(MonoThreadsSync& mon);
    private static bool TryExitFlat(ObjectHeaderOnStack h, LockWord lw);
    public static bool TryExitChecked(object obj);
}
internal enum System.Threading.OpenExistingResult : Enum {
    public int value__;
    public static OpenExistingResult Success;
    public static OpenExistingResult NameNotFound;
    public static OpenExistingResult PathNotFound;
    public static OpenExistingResult NameInvalid;
}
public class System.Threading.Overlapped : object {
    private IAsyncResult _asyncResult;
    internal object _callback;
    private NativeOverlapped* _pNativeOverlapped;
    private IntPtr _eventHandle;
    private int _offsetLow;
    private int _offsetHigh;
    [NullableAttribute("1")]
public IAsyncResult AsyncResult { get; public set; }
    public int OffsetLow { get; public set; }
    public int OffsetHigh { get; public set; }
    [ObsoleteAttribute("Overlapped.EventHandle is not 64-bit compatible and has been deprecated. Use EventHandleIntPtr instead.")]
public int EventHandle { get; public set; }
    public IntPtr EventHandleIntPtr { get; public set; }
    [NullableContextAttribute("2")]
public Overlapped(int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor is not 64-bit compatible and has been deprecated. Use the constructor that accepts an IntPtr for the event handle instead.")]
public Overlapped(int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);
    [NullableContextAttribute("1")]
public IAsyncResult get_AsyncResult();
    [NullableContextAttribute("1")]
public void set_AsyncResult(IAsyncResult value);
    public int get_OffsetLow();
    public void set_OffsetLow(int value);
    public int get_OffsetHigh();
    public void set_OffsetHigh(int value);
    public int get_EventHandle();
    public void set_EventHandle(int value);
    public IntPtr get_EventHandleIntPtr();
    public void set_EventHandleIntPtr(IntPtr value);
    [ObsoleteAttribute("This overload is not safe and has been deprecated. Use Pack(IOCompletionCallback?, object?) instead.")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* Pack(IOCompletionCallback iocb, object userData);
    [ObsoleteAttribute("This overload is not safe and has been deprecated. Use UnsafePack(IOCompletionCallback?, object?) instead.")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafePack(IOCompletionCallback iocb, object userData);
    [CLSCompliantAttribute("False")]
public static Overlapped Unpack(NativeOverlapped* nativeOverlappedPtr);
    [CLSCompliantAttribute("False")]
public static void Free(NativeOverlapped* nativeOverlappedPtr);
    private NativeOverlapped* AllocateNativeOverlapped(object userData);
    internal static void FreeNativeOverlapped(NativeOverlapped* pNativeOverlapped);
    private static UIntPtr& GCHandleCountRef(NativeOverlapped* pNativeOverlapped);
    private static GCHandle& GCHandleRef(NativeOverlapped* pNativeOverlapped, UIntPtr index);
    internal static Overlapped GetOverlappedFromNative(NativeOverlapped* pNativeOverlapped);
}
public class System.Threading.ParameterizedThreadStart : MulticastDelegate {
    public ParameterizedThreadStart(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Threading.PeriodicTimer : object {
    private ITimer _timer;
    private State _state;
    private TimeSpan _period;
    public TimeSpan Period { get; public set; }
    public PeriodicTimer(TimeSpan period);
    [NullableContextAttribute("1")]
public PeriodicTimer(TimeSpan period, TimeProvider timeProvider);
    public TimeSpan get_Period();
    public void set_Period(TimeSpan value);
    private static bool TryGetMilliseconds(TimeSpan value, UInt32& milliseconds);
    public ValueTask`1<bool> WaitForNextTickAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class System.Threading.PortableThreadPool : object {
    private static short ForcedMinWorkerThreads;
    private static short ForcedMaxWorkerThreads;
    private static int ThreadPoolThreadTimeoutMs;
    [ThreadStaticAttribute]
private static object t_completionCountObject;
    public static PortableThreadPool ThreadPoolInstance;
    private int _cpuUtilization;
    private short _minThreads;
    private short _maxThreads;
    private short _legacy_minIOCompletionThreads;
    private short _legacy_maxIOCompletionThreads;
    private long _currentSampleStartTime;
    private ThreadInt64PersistentCounter _completionCounter;
    private int _threadAdjustmentIntervalMs;
    private short _numBlockedThreads;
    private short _numThreadsAddedDueToBlocking;
    private PendingBlockingAdjustment _pendingBlockingAdjustment;
    private long _memoryUsageBytes;
    private long _memoryLimitBytes;
    private LowLevelLock _threadAdjustmentLock;
    private CacheLineSeparated _separated;
    private WaitThreadNode _waitThreadsHead;
    private LowLevelLock _waitThreadLock;
    private int _numThreadsBeingKeptAlive;
    private CountsOfThreadsProcessingUserCallbacks _countsOfThreadsProcessingUserCallbacks;
    private static bool HasForcedMinThreads { get; }
    private static bool HasForcedMaxThreads { get; }
    public int ThreadCount { get; }
    public long CompletedWorkItemCount { get; }
    public short MinThreadsGoal { get; }
    private short TargetThreadsGoalForBlockingAdjustment { get; }
    private static PortableThreadPool();
    private static int DetermineThreadPoolThreadTimeoutMs();
    private static bool get_HasForcedMinThreads();
    private static bool get_HasForcedMaxThreads();
    public bool SetMinThreads(int workerThreads, int ioCompletionThreads);
    public void GetMinThreads(Int32& workerThreads, Int32& ioCompletionThreads);
    public bool SetMaxThreads(int workerThreads, int ioCompletionThreads);
    public void GetMaxThreads(Int32& workerThreads, Int32& ioCompletionThreads);
    public void GetAvailableThreads(Int32& workerThreads, Int32& ioCompletionThreads);
    public int get_ThreadCount();
    public long get_CompletedWorkItemCount();
    public object GetOrCreateThreadLocalCompletionCountObject();
    private object CreateThreadLocalCompletionCountObject();
    private void NotifyWorkItemProgress(object threadLocalCompletionCountObject, int currentTimeMs);
    internal void NotifyWorkItemProgress();
    internal bool NotifyWorkItemComplete(object threadLocalCompletionCountObject, int currentTimeMs);
    private void AdjustMaxWorkersActive();
    private bool ShouldAdjustMaxWorkersActive(int currentTimeMs);
    internal void RequestWorker();
    private bool OnGen2GCCallback();
    internal static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, bool flowExecutionContext);
    public short get_MinThreadsGoal();
    private short get_TargetThreadsGoalForBlockingAdjustment();
    public bool NotifyThreadBlocked();
    public void NotifyThreadUnblocked();
    private UInt32 PerformBlockingAdjustment(bool previousDelayElapsed);
    private UInt32 PerformBlockingAdjustment(bool previousDelayElapsed, Boolean& addWorker);
    internal void RegisterWaitHandle(RegisteredWaitHandle handle);
    internal static void CompleteWait(RegisteredWaitHandle handle, bool timedOut);
    private bool TryRemoveWaitThread(WaitThread thread);
    private void RemoveWaitThread(WaitThread thread);
    public void ReportThreadStatus(bool isProcessingUserCallback);
    private short GetAndResetHighWatermarkCountOfThreadsProcessingUserCallbacks();
}
public class System.Threading.PreAllocatedOverlapped : object {
    private DeferredDisposableLifetime`1<PreAllocatedOverlapped> _lifetime;
    internal ThreadPoolBoundHandleOverlapped _overlappedPortableCore;
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData);
    private PreAllocatedOverlapped(IOCompletionCallback callback, object state, object pinData, bool flowExecutionContext);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static PreAllocatedOverlapped UnsafeCreate(IOCompletionCallback callback, object state, object pinData);
    internal bool AddRef();
    public sealed virtual void Dispose();
    internal void Release();
    private sealed virtual override void System.Threading.IDeferredDisposable.OnFinalRelease(bool disposed);
    private static PreAllocatedOverlapped UnsafeCreatePortableCore(IOCompletionCallback callback, object state, object pinData);
    private bool AddRefPortableCore();
    private void ReleasePortableCore();
    private void DisposePortableCore();
    private void IDeferredDisposableOnFinalReleasePortableCore(bool disposed);
}
internal static class System.Threading.ProcessorIdCache : object {
    [ThreadStaticAttribute]
private static int t_currentProcessorIdCache;
    private static int s_processorIdRefreshRate;
    private static int RefreshCurrentProcessorId();
    internal static int GetCurrentProcessorId();
    internal static bool ProcessorNumberSpeedCheck();
    internal static int UninlinedThreadStatic();
}
internal class System.Threading.QueueUserWorkItemCallback : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    private ExecutionContext _context;
    private static Action`1<QueueUserWorkItemCallback> s_executionContextShim;
    internal QueueUserWorkItemCallback(WaitCallback callback, object state, ExecutionContext context);
    private static QueueUserWorkItemCallback();
    public virtual void Execute();
}
internal class System.Threading.QueueUserWorkItemCallback`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    private ExecutionContext _context;
    internal QueueUserWorkItemCallback`1(Action`1<TState> callback, TState state, ExecutionContext context);
    public virtual void Execute();
}
internal abstract class System.Threading.QueueUserWorkItemCallbackBase : object {
    public virtual void Execute();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext : QueueUserWorkItemCallbackBase {
    private WaitCallback _callback;
    private object _state;
    internal QueueUserWorkItemCallbackDefaultContext(WaitCallback callback, object state);
    public virtual void Execute();
}
internal class System.Threading.QueueUserWorkItemCallbackDefaultContext`1 : QueueUserWorkItemCallbackBase {
    private Action`1<TState> _callback;
    private TState _state;
    internal QueueUserWorkItemCallbackDefaultContext`1(Action`1<TState> callback, TState state);
    public virtual void Execute();
}
internal class System.Threading.ReaderWriterCount : object {
    public long lockID;
    public int readercount;
    public int writercount;
    public int upgradecount;
    public ReaderWriterCount next;
}
public class System.Threading.ReaderWriterLockSlim : object {
    private bool _fIsReentrant;
    private SpinLock _spinLock;
    private UInt32 _numWriteWaiters;
    private UInt32 _numReadWaiters;
    private UInt32 _numWriteUpgradeWaiters;
    private UInt32 _numUpgradeWaiters;
    private WaiterStates _waiterStates;
    private int _upgradeLockOwnerId;
    private int _writeLockOwnerId;
    private EventWaitHandle _writeEvent;
    private EventWaitHandle _readEvent;
    private EventWaitHandle _upgradeEvent;
    private EventWaitHandle _waitUpgradeEvent;
    private static long s_nextLockID;
    private long _lockID;
    [ThreadStaticAttribute]
private static ReaderWriterCount t_rwc;
    private bool _fUpgradeThreadHoldingRead;
    private UInt32 _owners;
    private bool _fDisposed;
    private bool HasNoWaiters { get; private set; }
    public bool IsReadLockHeld { get; }
    public bool IsUpgradeableReadLockHeld { get; }
    public bool IsWriteLockHeld { get; }
    public LockRecursionPolicy RecursionPolicy { get; }
    public int CurrentReadCount { get; }
    public int RecursiveReadCount { get; }
    public int RecursiveUpgradeCount { get; }
    public int RecursiveWriteCount { get; }
    public int WaitingReadCount { get; }
    public int WaitingUpgradeCount { get; }
    public int WaitingWriteCount { get; }
    public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy);
    private void InitializeThreadCounts();
    private bool get_HasNoWaiters();
    private void set_HasNoWaiters(bool value);
    private static bool IsRWEntryEmpty(ReaderWriterCount rwc);
    private bool IsRwHashEntryChanged(ReaderWriterCount lrwc);
    private ReaderWriterCount GetThreadRWCount(bool dontAllocate);
    public void EnterReadLock();
    public bool TryEnterReadLock(TimeSpan timeout);
    public bool TryEnterReadLock(int millisecondsTimeout);
    private bool TryEnterReadLock(TimeoutTracker timeout);
    private bool TryEnterReadLockCore(TimeoutTracker timeout);
    public void EnterWriteLock();
    public bool TryEnterWriteLock(TimeSpan timeout);
    public bool TryEnterWriteLock(int millisecondsTimeout);
    private bool TryEnterWriteLock(TimeoutTracker timeout);
    private bool TryEnterWriteLockCore(TimeoutTracker timeout);
    public void EnterUpgradeableReadLock();
    public bool TryEnterUpgradeableReadLock(TimeSpan timeout);
    public bool TryEnterUpgradeableReadLock(int millisecondsTimeout);
    private bool TryEnterUpgradeableReadLock(TimeoutTracker timeout);
    private bool TryEnterUpgradeableReadLockCore(TimeoutTracker timeout);
    public void ExitReadLock();
    public void ExitWriteLock();
    public void ExitUpgradeableReadLock();
    private void LazyCreateEvent(EventWaitHandle& waitEvent, EnterLockType enterLockType);
    private bool WaitOnEvent(EventWaitHandle waitEvent, UInt32& numWaiters, TimeoutTracker timeout, EnterLockType enterLockType);
    private void ExitAndWakeUpAppropriateWaiters();
    private void ExitAndWakeUpAppropriateWaitersPreferringWriters();
    private void ExitAndWakeUpAppropriateReadWaiters();
    private bool IsWriterAcquired();
    private void SetWriterAcquired();
    private void ClearWriterAcquired();
    private void SetWritersWaiting();
    private void ClearWritersWaiting();
    private void SetUpgraderWaiting();
    private void ClearUpgraderWaiting();
    private UInt32 GetNumReaders();
    private bool ShouldSpinForEnterAnyRead();
    private bool ShouldSpinForEnterAnyWrite(bool isUpgradeToWrite);
    private static void SpinWait(int spinCount);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public bool get_IsReadLockHeld();
    public bool get_IsUpgradeableReadLockHeld();
    public bool get_IsWriteLockHeld();
    public LockRecursionPolicy get_RecursionPolicy();
    public int get_CurrentReadCount();
    public int get_RecursiveReadCount();
    public int get_RecursiveUpgradeCount();
    public int get_RecursiveWriteCount();
    public int get_WaitingReadCount();
    public int get_WaitingUpgradeCount();
    public int get_WaitingWriteCount();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[UnsupportedOSPlatformAttribute("browser")]
public class System.Threading.RegisteredWaitHandle : MarshalByRefObject {
    private SafeWaitHandle _waitHandle;
    private _ThreadPoolWaitOrTimerCallback _callbackHelper;
    private int _signedMillisecondsTimeout;
    private bool _repeating;
    [CompilerGeneratedAttribute]
private int <TimeoutTimeMs>k__BackingField;
    private static AutoResetEvent s_cachedEvent;
    private static LowLevelLock s_callbackLock;
    [CompilerGeneratedAttribute]
private SafeWaitHandle <UserUnregisterWaitHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <UserUnregisterWaitHandleValue>k__BackingField;
    private int _numRequestedCallbacks;
    private bool _signalAfterCallbacksComplete;
    private bool _unregisterCalled;
    private bool _unregistered;
    private AutoResetEvent _callbacksComplete;
    private AutoResetEvent _removed;
    [CompilerGeneratedAttribute]
private WaitThread <WaitThread>k__BackingField;
    internal _ThreadPoolWaitOrTimerCallback Callback { get; }
    [NullableAttribute("1")]
internal SafeWaitHandle Handle { get; }
    internal int TimeoutTimeMs { get; private set; }
    internal int TimeoutDurationMs { get; }
    internal bool IsInfiniteTimeout { get; }
    internal bool Repeating { get; }
    private SafeWaitHandle UserUnregisterWaitHandle { get; private set; }
    private IntPtr UserUnregisterWaitHandleValue { get; private set; }
    private static IntPtr InvalidHandleValue { get; }
    internal bool IsBlocking { get; }
    internal WaitThread WaitThread { get; internal set; }
    internal RegisteredWaitHandle(WaitHandle waitHandle, _ThreadPoolWaitOrTimerCallback callbackHelper, int millisecondsTimeout, bool repeating);
    private static RegisteredWaitHandle();
    internal _ThreadPoolWaitOrTimerCallback get_Callback();
    internal SafeWaitHandle get_Handle();
    [CompilerGeneratedAttribute]
internal int get_TimeoutTimeMs();
    [CompilerGeneratedAttribute]
private void set_TimeoutTimeMs(int value);
    internal int get_TimeoutDurationMs();
    internal bool get_IsInfiniteTimeout();
    internal bool get_Repeating();
    [NullableContextAttribute("1")]
public bool Unregister(WaitHandle waitObject);
    internal void PerformCallback(bool timedOut);
    [CompilerGeneratedAttribute]
private SafeWaitHandle get_UserUnregisterWaitHandle();
    [CompilerGeneratedAttribute]
private void set_UserUnregisterWaitHandle(SafeWaitHandle value);
    [CompilerGeneratedAttribute]
private IntPtr get_UserUnregisterWaitHandleValue();
    [CompilerGeneratedAttribute]
private void set_UserUnregisterWaitHandleValue(IntPtr value);
    private static IntPtr get_InvalidHandleValue();
    internal bool get_IsBlocking();
    [CompilerGeneratedAttribute]
internal WaitThread get_WaitThread();
    [CompilerGeneratedAttribute]
internal void set_WaitThread(WaitThread value);
    private static AutoResetEvent RentEvent();
    private static void ReturnEvent(AutoResetEvent resetEvent);
    internal void RestartTimeout();
    private bool UnregisterPortableCore(WaitHandle waitObject);
    private void SignalUserWaitHandle();
    internal void PerformCallbackPortableCore(bool timedOut);
    internal void RequestCallback();
    internal void OnRemoveWait();
    private void CompleteCallbackRequest();
    internal void WaitForCallbacks();
    internal void WaitForRemoval();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Semaphore : WaitHandle {
    public Semaphore(int initialCount, int maximumCount);
    [NullableContextAttribute("2")]
public Semaphore(int initialCount, int maximumCount, string name);
    [NullableContextAttribute("2")]
public Semaphore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    [SupportedOSPlatformAttribute("windows")]
public static Semaphore OpenExisting(string name);
    [SupportedOSPlatformAttribute("windows")]
public static bool TryOpenExisting(string name, Semaphore& result);
    public int Release();
    public int Release(int releaseCount);
    private void CreateSemaphoreCore(int initialCount, int maximumCount, string name, Boolean& createdNew);
    private static OpenExistingResult OpenExistingWorker(string name, Semaphore& result);
    private int ReleaseCore(int releaseCount);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SemaphoreFullException : SystemException {
    public SemaphoreFullException(string message);
    public SemaphoreFullException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SemaphoreFullException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Current Count = {m_currentCount}")]
public class System.Threading.SemaphoreSlim : object {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_currentCount;
    private int m_maxCount;
    private int m_waitCount;
    private int m_countOfWaitersPulsedToWake;
    private StrongBox`1<bool> m_lockObjAndDisposed;
    private ManualResetEvent modreq(System.Runtime.CompilerServices.IsVolatile) m_waitHandle;
    private TaskNode m_asyncHead;
    private TaskNode m_asyncTail;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    public int CurrentCount { get; }
    public WaitHandle AvailableWaitHandle { get; }
    public SemaphoreSlim(int initialCount);
    public SemaphoreSlim(int initialCount, int maxCount);
    private static SemaphoreSlim();
    public int get_CurrentCount();
    public WaitHandle get_AvailableWaitHandle();
    [UnsupportedOSPlatformAttribute("browser")]
public void Wait();
    [UnsupportedOSPlatformAttribute("browser")]
public void Wait(CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(TimeSpan timeout);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(int millisecondsTimeout);
    [UnsupportedOSPlatformAttribute("browser")]
public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
private bool WaitUntilCountOrTimeout(int millisecondsTimeout, UInt32 startTime, CancellationToken cancellationToken);
    public Task WaitAsync();
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout);
    public Task`1<bool> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<bool> WaitAsync(int millisecondsTimeout, CancellationToken cancellationToken);
    private TaskNode CreateAndAddAsyncWaiter();
    private bool RemoveAsyncWaiter(TaskNode task);
    [AsyncStateMachineAttribute("System.Threading.SemaphoreSlim/<WaitUntilCountOrTimeoutAsync>d__31")]
private Task`1<bool> WaitUntilCountOrTimeoutAsync(TaskNode asyncWaiter, int millisecondsTimeout, CancellationToken cancellationToken);
    public int Release();
    public int Release(int releaseCount);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private static void CancellationTokenCanceledEventHandler(object obj);
    private void CheckDispose();
}
public class System.Threading.SendOrPostCallback : MulticastDelegate {
    public SendOrPostCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DebuggerTypeProxyAttribute("System.Threading.SpinLock/SystemThreading_SpinLockDebugView")]
[DebuggerDisplayAttribute("IsHeld = {IsHeld}")]
public class System.Threading.SpinLock : ValueType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owner;
    public bool IsHeld { get; }
    public bool IsHeldByCurrentThread { get; }
    public bool IsThreadOwnerTrackingEnabled { get; }
    public SpinLock(bool enableThreadOwnerTracking);
    private static int CompareExchange(Int32& location, int value, int comparand, Boolean& success);
    public void Enter(Boolean& lockTaken);
    public void TryEnter(Boolean& lockTaken);
    public void TryEnter(TimeSpan timeout, Boolean& lockTaken);
    public void TryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void ContinueTryEnter(int millisecondsTimeout, Boolean& lockTaken);
    private void DecrementWaiters();
    private void ContinueTryEnterWithThreadTracking(int millisecondsTimeout, UInt32 startTime, Boolean& lockTaken);
    public void Exit();
    public void Exit(bool useMemoryBarrier);
    private void ExitSlowPath(bool useMemoryBarrier);
    public bool get_IsHeld();
    public bool get_IsHeldByCurrentThread();
    public bool get_IsThreadOwnerTrackingEnabled();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.SpinWait : ValueType {
    internal static int SpinCountforSpinBeforeWait;
    private int _count;
    public int Count { get; internal set; }
    public bool NextSpinWillYield { get; }
    private static SpinWait();
    public int get_Count();
    internal void set_Count(int value);
    public bool get_NextSpinWillYield();
    public void SpinOnce();
    public void SpinOnce(int sleep1Threshold);
    private void SpinOnceCore(int sleep1Threshold);
    public void Reset();
    public static void SpinUntil(Func`1<bool> condition);
    public static bool SpinUntil(Func`1<bool> condition, TimeSpan timeout);
    public static bool SpinUntil(Func`1<bool> condition, int millisecondsTimeout);
}
internal enum System.Threading.StackCrawlMark : Enum {
    public int value__;
    public static StackCrawlMark LookForMe;
    public static StackCrawlMark LookForMyCaller;
    public static StackCrawlMark LookForMyCallersCaller;
    public static StackCrawlMark LookForThread;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.SynchronizationContext : object {
    private bool _requireWaitNotification;
    [NullableAttribute("2")]
public static SynchronizationContext Current { get; }
    [NullableContextAttribute("2")]
public static SynchronizationContext get_Current();
    protected void SetWaitNotificationRequired();
    public bool IsWaitNotificationRequired();
    public virtual void Send(SendOrPostCallback d, object state);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void OperationStarted();
    public virtual void OperationCompleted();
    [CLSCompliantAttribute("False")]
public virtual int Wait(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [CLSCompliantAttribute("False")]
protected static int WaitHelper(IntPtr[] waitHandles, bool waitAll, int millisecondsTimeout);
    [NullableContextAttribute("2")]
public static void SetSynchronizationContext(SynchronizationContext syncContext);
    public virtual SynchronizationContext CreateCopy();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.SynchronizationLockException : SystemException {
    public SynchronizationLockException(string message);
    public SynchronizationLockException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected SynchronizationLockException(SerializationInfo info, StreamingContext context);
}
internal class System.Threading.SystemThreading_ThreadLocalDebugView`1 : object {
    private ThreadLocal`1<T> _tlocal;
    public bool IsValueCreated { get; }
    public T Value { get; }
    public List`1<T> Values { get; }
    public SystemThreading_ThreadLocalDebugView`1(ThreadLocal`1<T> tlocal);
    public bool get_IsValueCreated();
    public T get_Value();
    public List`1<T> get_Values();
}
internal enum System.Threading.Tasks.AsyncCausalityStatus : Enum {
    public int value__;
    public static AsyncCausalityStatus Started;
    public static AsyncCausalityStatus Completed;
    public static AsyncCausalityStatus Canceled;
    public static AsyncCausalityStatus Error;
}
internal class System.Threading.Tasks.AwaitTaskContinuation : TaskContinuation {
    private ExecutionContext m_capturedContext;
    protected Action m_action;
    protected int m_continuationId;
    private static ContextCallback s_invokeContextCallback;
    private static Action`1<Action> s_invokeAction;
    internal static bool IsValidLocationForInlining { get; }
    internal AwaitTaskContinuation(Action action, bool flowExecutionContext);
    private static AwaitTaskContinuation();
    protected Task CreateTask(Action`1<object> action, object state, TaskScheduler scheduler);
    internal virtual void Run(Task task, bool canInlineContinuationTask);
    internal static bool get_IsValidLocationForInlining();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    protected static ContextCallback GetInvokeActionCallback();
    protected void RunCallback(ContextCallback callback, object state, Task& currentTask);
    internal static void RunOrScheduleAction(Action action, bool allowInlining);
    internal static void RunOrScheduleAction(IAsyncStateMachineBox box, bool allowInlining);
    internal static void UnsafeScheduleAction(Action action, Task task);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
internal class System.Threading.Tasks.CachedCompletedInt32Task : ValueType {
    private Task`1<int> _task;
    public Task`1<int> GetTask(int result);
}
internal enum System.Threading.Tasks.CausalityRelation : Enum {
    public int value__;
    public static CausalityRelation AssignDelegate;
    public static CausalityRelation Join;
    public static CausalityRelation Choice;
    public static CausalityRelation Cancel;
    public static CausalityRelation Error;
}
internal enum System.Threading.Tasks.CausalitySynchronousWork : Enum {
    public int value__;
    public static CausalitySynchronousWork CompletionNotification;
    public static CausalitySynchronousWork ProgressNotification;
    public static CausalitySynchronousWork Execution;
}
internal class System.Threading.Tasks.CompletionActionInvoker : object {
    private ITaskCompletionAction m_action;
    private Task m_completingTask;
    internal CompletionActionInvoker(ITaskCompletionAction action, Task completingTask);
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Concurrent = {ConcurrentTaskCountForDebugger}, Exclusive = {ExclusiveTaskCountForDebugger}, Mode = {ModeForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.ConcurrentExclusiveSchedulerPair/DebugView")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    private ThreadLocal`1<ProcessingMode> m_threadProcessingMode;
    private ConcurrentExclusiveTaskScheduler m_concurrentTaskScheduler;
    private ConcurrentExclusiveTaskScheduler m_exclusiveTaskScheduler;
    private TaskScheduler m_underlyingTaskScheduler;
    private int m_maxConcurrencyLevel;
    private int m_maxItemsPerTask;
    private int m_processingCount;
    private CompletionState m_completionState;
    private SchedulerWorkItem m_threadPoolWorkItem;
    private static int DefaultMaxConcurrencyLevel { get; }
    private object ValueLock { get; }
    public Task Completion { get; }
    private bool CompletionRequested { get; }
    private bool ReadyToComplete { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    private int ConcurrentTaskCountForDebugger { get; }
    private int ExclusiveTaskCountForDebugger { get; }
    private ProcessingMode ModeForDebugger { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    private static int get_DefaultMaxConcurrencyLevel();
    private object get_ValueLock();
    public void Complete();
    public Task get_Completion();
    private CompletionState EnsureCompletionStateInitialized();
    private bool get_CompletionRequested();
    private void RequestCompletion();
    private void CleanupStateIfCompletingAndQuiesced();
    private bool get_ReadyToComplete();
    private void CompleteTaskAsync();
    private void FaultWithTask(Task faultedTask);
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    private int get_ConcurrentTaskCountForDebugger();
    private int get_ExclusiveTaskCountForDebugger();
    private void ProcessAsyncIfNecessary(bool fairly);
    private bool TryQueueThreadPoolWorkItem(bool fairly);
    private void ProcessExclusiveTasks();
    private void ProcessConcurrentTasks();
    private ProcessingMode get_ModeForDebugger();
    internal static TaskCreationOptions GetCreationOptionsForTask(bool isReplacementReplica);
    [CompilerGeneratedAttribute]
private CompletionState <EnsureCompletionStateInitialized>g__InitializeCompletionState|23_0();
}
[FlagsAttribute]
public enum System.Threading.Tasks.ConfigureAwaitOptions : Enum {
    public int value__;
    public static ConfigureAwaitOptions None;
    public static ConfigureAwaitOptions ContinueOnCapturedContext;
    public static ConfigureAwaitOptions SuppressThrowing;
    public static ConfigureAwaitOptions ForceYielding;
}
internal class System.Threading.Tasks.ContinuationResultTaskFromResultTask`2 : Task`1<TResult> {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationResultTaskFromResultTask`2(Task`1<TAntecedentResult> antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationResultTaskFromTask`1 : Task`1<TResult> {
    private Task m_antecedent;
    public ContinuationResultTaskFromTask`1(Task antecedent, Delegate function, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromResultTask`1 : Task {
    private Task`1<TAntecedentResult> m_antecedent;
    public ContinuationTaskFromResultTask`1(Task`1<TAntecedentResult> antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinuationTaskFromTask : Task {
    private Task m_antecedent;
    public ContinuationTaskFromTask(Task antecedent, Delegate action, object state, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions);
    internal virtual void InnerInvoke();
}
internal class System.Threading.Tasks.ContinueWithTaskContinuation : TaskContinuation {
    internal Task m_task;
    internal TaskContinuationOptions m_options;
    private TaskScheduler m_taskScheduler;
    internal ContinueWithTaskContinuation(Task task, TaskContinuationOptions options, TaskScheduler scheduler);
    internal virtual void Run(Task completedTask, bool canInlineContinuationTask);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
internal enum System.Threading.Tasks.InternalTaskOptions : Enum {
    public int value__;
    public static InternalTaskOptions None;
    public static InternalTaskOptions InternalOptionsMask;
    public static InternalTaskOptions ContinuationTask;
    public static InternalTaskOptions PromiseTask;
    public static InternalTaskOptions HiddenState;
    public static InternalTaskOptions LazyCancellation;
    public static InternalTaskOptions QueuedByRuntime;
    public static InternalTaskOptions DoNotDispose;
}
internal interface System.Threading.Tasks.ITaskCompletionAction {
    public bool InvokeMayRunArbitraryCode { get; }
    public abstract virtual void Invoke(Task completingTask);
    public abstract virtual bool get_InvokeMayRunArbitraryCode();
}
internal class System.Threading.Tasks.Sources.CapturedSchedulerAndExecutionContext : object {
    internal object _scheduler;
    internal ExecutionContext _executionContext;
    public CapturedSchedulerAndExecutionContext(object scheduler, ExecutionContext executionContext);
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public abstract virtual void GetResult(short token);
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    [NullableContextAttribute("1")]
public abstract virtual TResult GetResult(short token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1 : ValueType {
    private Action`1<object> _continuation;
    private object _continuationState;
    private object _capturedContext;
    private ExceptionDispatchInfo _error;
    private TResult _result;
    private short _version;
    private bool _completed;
    private bool _runContinuationsAsynchronously;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    public bool get_RunContinuationsAsynchronously();
    public void set_RunContinuationsAsynchronously(bool value);
    public void Reset();
    public void SetResult(TResult result);
    public void SetException(Exception error);
    public short get_Version();
    public ValueTaskSourceStatus GetStatus(short token);
    [StackTraceHiddenAttribute]
public TResult GetResult(short token);
    [StackTraceHiddenAttribute]
private void ThrowForFailedGetResult();
    [NullableContextAttribute("2")]
public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    private void ValidateToken(short token);
    private void SignalCompletion();
}
internal static class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCoreShared : object {
    internal static Action`1<object> s_sentinel;
    private static ManualResetValueTaskSourceCoreShared();
    private static void CompletionSentinel(object _);
    internal static void ScheduleCapturedContext(object context, Action`1<object> continuation, object state);
    internal static void InvokeContinuationWithContext(object capturedContext, Action`1<object> continuation, object continuationState, bool runContinuationsAsynchronously);
    [CompilerGeneratedAttribute]
internal static void <ScheduleCapturedContext>g__ScheduleSynchronizationContext|2_0(SynchronizationContext sc, Action`1<object> continuation, object state);
    [CompilerGeneratedAttribute]
internal static void <ScheduleCapturedContext>g__ScheduleTaskScheduler|2_1(TaskScheduler scheduler, Action`1<object> continuation, object state);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
internal class System.Threading.Tasks.SynchronizationContextAwaitTaskContinuation : AwaitTaskContinuation {
    private static SendOrPostCallback s_postCallback;
    private static ContextCallback s_postActionCallback;
    private SynchronizationContext m_syncContext;
    internal SynchronizationContextAwaitTaskContinuation(SynchronizationContext context, Action action, bool flowExecutionContext);
    private static SynchronizationContextAwaitTaskContinuation();
    internal sealed virtual void Run(Task task, bool canInlineContinuationTask);
    private static void PostAction(object state);
    private static Action GetActionLogDelegate(int continuationId, Action action);
    private static ContextCallback GetPostActionCallback();
}
internal class System.Threading.Tasks.SynchronizationContextTaskScheduler : TaskScheduler {
    private SynchronizationContext m_synchronizationContext;
    private static SendOrPostCallback s_postCallback;
    public int MaximumConcurrencyLevel { get; }
    private static SynchronizationContextTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
}
internal class System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1 : object {
    private Task`1<TResult> m_task;
    public TResult Result { get; }
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_FutureDebugView`1(Task`1<TResult> task);
    public TResult get_Result();
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
internal class System.Threading.Tasks.SystemThreadingTasks_TaskDebugView : object {
    private Task m_task;
    public object AsyncState { get; }
    public TaskCreationOptions CreationOptions { get; }
    public Exception Exception { get; }
    public int Id { get; }
    public bool CancellationPending { get; }
    public TaskStatus Status { get; }
    public SystemThreadingTasks_TaskDebugView(Task task);
    public object get_AsyncState();
    public TaskCreationOptions get_CreationOptions();
    public Exception get_Exception();
    public int get_Id();
    public bool get_CancellationPending();
    public TaskStatus get_Status();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_TaskDebugView")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}")]
public class System.Threading.Tasks.Task : object {
    [ThreadStaticAttribute]
internal static Task t_currentTask;
    private static int s_taskIdCounter;
    private int m_taskId;
    internal Delegate m_action;
    private protected object m_stateObject;
    internal TaskScheduler m_taskScheduler;
    internal Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_stateFlags;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) m_continuationObject;
    private static object s_taskCompletionSentinel;
    internal static bool s_asyncDebuggingEnabled;
    private static Dictionary`2<int, Task> s_currentActiveTasks;
    internal ContingentProperties m_contingentProperties;
    [CompilerGeneratedAttribute]
private static TaskFactory <Factory>k__BackingField;
    internal static Task`1<VoidTaskResult> s_cachedCompleted;
    private static ContextCallback s_ecCallback;
    [NullableAttribute("2")]
private Task ParentForDebugger { get; }
    private int StateFlagsForDebugger { get; }
    private TaskStateFlags StateFlags { get; }
    private string DebuggerDisplayMethodDescription { get; }
    internal TaskCreationOptions Options { get; }
    internal bool IsWaitNotificationEnabledOrNotRanToCompletion { get; }
    private protected bool ShouldNotifyDebuggerOfWaitCompletion { get; }
    internal bool IsWaitNotificationEnabled { get; }
    public int Id { get; }
    public static Nullable`1<int> CurrentId { get; }
    [NullableAttribute("2")]
internal static Task InternalCurrent { get; }
    [NullableAttribute("2")]
public AggregateException Exception { get; }
    public TaskStatus Status { get; }
    public bool IsCanceled { get; }
    internal bool IsCancellationRequested { get; }
    internal CancellationToken CancellationToken { get; }
    internal bool IsCancellationAcknowledged { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public TaskCreationOptions CreationOptions { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    [NullableAttribute("2")]
public object AsyncState { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    [NullableAttribute("2")]
internal TaskScheduler ExecutingTaskScheduler { get; }
    public static TaskFactory Factory { get; }
    public static Task CompletedTask { get; }
    internal ManualResetEventSlim CompletedEvent { get; }
    internal bool ExceptionRecorded { get; }
    [MemberNotNullWhenAttribute("True", "Exception")]
public bool IsFaulted { get; }
    [NullableAttribute("2")]
internal ExecutionContext CapturedContext { get; internal set; }
    internal bool IsExceptionObservedByParent { get; }
    internal bool IsDelegateInvoked { get; }
    internal Task(bool canceled, TaskCreationOptions creationOptions, CancellationToken ct);
    internal Task(object state, TaskCreationOptions creationOptions, bool promiseStyle);
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, TaskCreationOptions creationOptions);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task(Delegate action, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task();
    private Task get_ParentForDebugger();
    private int get_StateFlagsForDebugger();
    private TaskStateFlags get_StateFlags();
    internal static bool AddToActiveTasks(Task task);
    internal static void RemoveFromActiveTasks(Task task);
    internal void TaskConstructorCore(Delegate action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private void AssignCancellationToken(CancellationToken cancellationToken, Task antecedent, TaskContinuation continuation);
    private string get_DebuggerDisplayMethodDescription();
    internal TaskCreationOptions get_Options();
    internal static TaskCreationOptions OptionsMethod(int flags);
    internal bool AtomicStateUpdate(int newBits, int illegalBits);
    private bool AtomicStateUpdateSlow(int newBits, int illegalBits);
    internal bool AtomicStateUpdate(int newBits, int illegalBits, Int32& oldFlags);
    internal void SetNotificationForWaitCompletion(bool enabled);
    internal bool NotifyDebuggerOfWaitCompletionIfNecessary();
    internal static bool AnyTaskRequiresNotifyDebuggerOfWaitCompletion(Task[] tasks);
    internal bool get_IsWaitNotificationEnabledOrNotRanToCompletion();
    private protected virtual bool get_ShouldNotifyDebuggerOfWaitCompletion();
    internal bool get_IsWaitNotificationEnabled();
    private void NotifyDebuggerOfWaitCompletion();
    internal bool MarkStarted();
    internal void FireTaskScheduledIfNeeded(TaskScheduler ts);
    internal void AddNewChild();
    internal void DisregardChild();
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    internal void InternalRunSynchronously(TaskScheduler scheduler, bool waitForCompletion);
    internal static Task InternalStartNew(Task creatingTask, Delegate action, object state, CancellationToken cancellationToken, TaskScheduler scheduler, TaskCreationOptions options, InternalTaskOptions internalOptions);
    internal static int NewId();
    public int get_Id();
    public static Nullable`1<int> get_CurrentId();
    internal static Task get_InternalCurrent();
    internal static Task InternalCurrentIfAttached(TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public AggregateException get_Exception();
    public TaskStatus get_Status();
    public bool get_IsCanceled();
    internal bool get_IsCancellationRequested();
    internal ContingentProperties EnsureContingentPropertiesInitialized();
    internal ContingentProperties EnsureContingentPropertiesInitializedUnsafe();
    internal CancellationToken get_CancellationToken();
    internal bool get_IsCancellationAcknowledged();
    public sealed virtual bool get_IsCompleted();
    private static bool IsCompletedMethod(int flags);
    public bool get_IsCompletedSuccessfully();
    public TaskCreationOptions get_CreationOptions();
    internal void SpinUntilCompleted();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    [NullableContextAttribute("2")]
public sealed virtual object get_AsyncState();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    internal TaskScheduler get_ExecutingTaskScheduler();
    [CompilerGeneratedAttribute]
public static TaskFactory get_Factory();
    public static Task get_CompletedTask();
    internal ManualResetEventSlim get_CompletedEvent();
    internal bool get_ExceptionRecorded();
    [MemberNotNullWhenAttribute("True", "Exception")]
public bool get_IsFaulted();
    internal ExecutionContext get_CapturedContext();
    internal void set_CapturedContext(ExecutionContext value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void ScheduleAndStart(bool needsProtection);
    internal void AddException(object exceptionObject);
    internal void AddException(object exceptionObject, bool representsCancellation);
    private AggregateException GetExceptions(bool includeTaskCanceledExceptions);
    internal List`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
    internal void MarkExceptionsAsHandled();
    internal void ThrowIfExceptional(bool includeTaskCanceledExceptions);
    internal static void ThrowAsync(Exception exception, SynchronizationContext targetContext);
    internal void UpdateExceptionObservedStatus();
    internal bool get_IsExceptionObservedByParent();
    internal bool get_IsDelegateInvoked();
    internal void Finish(bool userDelegateExecute);
    private void FinishSlow(bool userDelegateExecute);
    private void FinishStageTwo();
    internal void FinishStageThree();
    internal void NotifyParentIfPotentiallyAttachedTask();
    internal void ProcessChildCompletion(Task childTask);
    internal void AddExceptionsFromChildren(ContingentProperties props);
    internal bool ExecuteEntry();
    internal virtual void ExecuteFromThreadPool(Thread threadPoolThread);
    internal void ExecuteEntryUnsafe(Thread threadPoolThread);
    internal void ExecuteEntryCancellationRequestedOrCanceled();
    private void ExecuteWithThreadLocal(Task& currentTaskSlot, Thread threadPoolThread);
    internal virtual void InnerInvoke();
    private void HandleException(Exception unhandledException);
    public TaskAwaiter GetAwaiter();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    public ConfiguredTaskAwaitable ConfigureAwait(ConfigureAwaitOptions options);
    internal void SetContinuationForAwait(Action continuationAction, bool continueOnCapturedContext, bool flowExecutionContext);
    internal void UnsafeSetContinuationForAwait(IAsyncStateMachineBox stateMachineBox, bool continueOnCapturedContext);
    public static YieldAwaitable Yield();
    public void Wait();
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task WaitAsync(TimeSpan timeout);
    public Task WaitAsync(TimeSpan timeout, TimeProvider timeProvider);
    public Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task WaitAsync(TimeSpan timeout, TimeProvider timeProvider, CancellationToken cancellationToken);
    private Task WaitAsync(UInt32 millisecondsTimeout, TimeProvider timeProvider, CancellationToken cancellationToken);
    private bool WrappedTryRunInline();
    internal bool InternalWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool InternalWaitCore(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinThenBlockingWait(int millisecondsTimeout, CancellationToken cancellationToken);
    private bool SpinWait(int millisecondsTimeout);
    internal void InternalCancel();
    internal void InternalCancelContinueWithInitialState();
    internal void RecordInternalCancellationRequest();
    internal void RecordInternalCancellationRequest(CancellationToken tokenToRecord, object cancellationException);
    internal void CancellationCleanupLogic();
    private void SetCancellationAcknowledged();
    internal bool TrySetResult();
    internal bool TrySetException(object exceptionObject);
    internal bool TrySetCanceled(CancellationToken tokenToRecord);
    internal bool TrySetCanceled(CancellationToken tokenToRecord, object cancellationException);
    internal void FinishContinuations();
    private void RunContinuations(object continuationObject);
    private void RunOrQueueCompletionAction(ITaskCompletionAction completionAction, bool allowInlining);
    private static void LogFinishCompletionNotification();
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    internal static void CreationOptionsFromContinuationOptions(TaskContinuationOptions continuationOptions, TaskCreationOptions& creationOptions, InternalTaskOptions& internalOptions);
    internal void ContinueWithCore(Task continuationTask, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions options);
    internal void AddCompletionAction(ITaskCompletionAction action, bool addBeforeOthers);
    private bool AddTaskContinuationComplex(object tc, bool addBeforeOthers);
    private bool AddTaskContinuation(object tc, bool addBeforeOthers);
    internal void RemoveContinuation(object continuationObject);
    [UnsupportedOSPlatformAttribute("browser")]
public static void WaitAll(Task[] tasks);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    [UnsupportedOSPlatformAttribute("browser")]
public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
private static bool WaitAllCore(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static void AddToList(T item, List`1& list, int initSize);
    [UnsupportedOSPlatformAttribute("browser")]
private static bool WaitAllBlockingCore(List`1<Task> tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    internal static void AddExceptionsForCompletedTask(List`1& exceptions, Task t);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    private static int WaitAnyCore(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static Task`1<TResult> FromResult(TResult result);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    internal static Task FromCanceled(OperationCanceledException exception);
    internal static Task`1<TResult> FromCanceled(OperationCanceledException exception);
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, TimeProvider timeProvider);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay, TimeProvider timeProvider, CancellationToken cancellationToken);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    private static Task Delay(UInt32 millisecondsDelay, TimeProvider timeProvider, CancellationToken cancellationToken);
    internal static UInt32 ValidateTimeout(TimeSpan timeout, ExceptionArgument argument);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    internal static Task WhenAll(ReadOnlySpan`1<Task> tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    private static Task`1<TResult[]> InternalWhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(Task[] tasks);
    private static Task`1<TTask> WhenAny(ReadOnlySpan`1<TTask> tasks);
    public static Task`1<Task> WhenAny(Task task1, Task task2);
    private static Task`1<TTask> WhenAny(TTask task1, TTask task2);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    private static Task`1<TTask> WhenAny(IEnumerable`1<TTask> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1<TResult> task1, Task`1<TResult> task2);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    internal static Task`1<TResult> CreateUnwrapPromise(Task outerTask, bool lookForOce);
    internal virtual Delegate[] GetDelegateContinuationsForDebugger();
    private static Delegate[] GetDelegatesFromContinuationObject(object continuationObject);
    private static Task GetActiveTaskFromId(int taskId);
    [CompilerGeneratedAttribute]
private ContingentProperties <EnsureContingentPropertiesInitialized>g__InitializeContingentProperties|81_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.SystemThreadingTasks_FutureDebugView`1")]
[DebuggerDisplayAttribute("Id = {Id}, Status = {Status}, Method = {DebuggerDisplayMethodDescription}, Result = {DebuggerDisplayResultDescription}")]
public class System.Threading.Tasks.Task`1 : Task {
    internal static Task`1<TResult> s_defaultResultTask;
    private static TaskFactory`1<TResult> s_Factory;
    internal TResult m_result;
    private string DebuggerDisplayResultDescription { get; }
    private string DebuggerDisplayMethodDescription { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    internal TResult ResultOnSuccess { get; }
    public static TaskFactory`1<TResult> Factory { get; }
    internal Task`1(object state, TaskCreationOptions options);
    internal Task`1(TResult result);
    internal Task`1(bool canceled, TResult result, TaskCreationOptions creationOptions, CancellationToken ct);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    internal Task`1(Func`1<TResult> valueSelector, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal Task`1(Delegate valueSelector, object state, Task parent, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private static Task`1();
    internal static Task`1<TResult> StartNew(Task parent, Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> StartNew(Task parent, Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, InternalTaskOptions internalOptions, TaskScheduler scheduler);
    private string get_DebuggerDisplayResultDescription();
    private string get_DebuggerDisplayMethodDescription();
    internal bool TrySetResult(TResult result);
    internal void DangerousSetResult(TResult result);
    public TResult get_Result();
    internal TResult get_ResultOnSuccess();
    internal TResult GetResultCore(bool waitCompletionNotification);
    public static TaskFactory`1<TResult> get_Factory();
    internal virtual void InnerInvoke();
    public TaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(ConfigureAwaitOptions options);
    public Task`1<TResult> WaitAsync(CancellationToken cancellationToken);
    public Task`1<TResult> WaitAsync(TimeSpan timeout);
    public Task`1<TResult> WaitAsync(TimeSpan timeout, TimeProvider timeProvider);
    public Task`1<TResult> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public Task`1<TResult> WaitAsync(TimeSpan timeout, TimeProvider timeProvider, CancellationToken cancellationToken);
    private Task`1<TResult> WaitAsync(UInt32 millisecondsTimeout, TimeProvider timeProvider, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions);
    [CompilerGeneratedAttribute]
internal static void <ConfigureAwait>g__ThrowForInvalidOptions|36_0(ConfigureAwaitOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskAsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredAsyncDisposable ConfigureAwait(IAsyncDisposable source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(IAsyncEnumerable`1<T> source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("System.Threading.Tasks.TaskAsyncEnumerableExtensions/<ToBlockingEnumerable>d__3`1")]
[ExtensionAttribute]
[UnsupportedOSPlatformAttribute("browser")]
public static IEnumerable`1<T> ToBlockingEnumerable(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
internal static class System.Threading.Tasks.TaskCache : object {
    internal static Task`1<bool> s_trueTask;
    internal static Task`1<bool> s_falseTask;
    internal static Task`1[] s_int32Tasks;
    private static TaskCache();
    internal static Task`1<TResult> CreateCacheableTask(TResult result);
    private static Task`1[] CreateInt32Tasks();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    private Task _canceledTask;
    public Task Task { get; }
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public Task get_Task();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskCompletionSource : object {
    private Task _task;
    public Task Task { get; }
    public TaskCompletionSource(TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public TaskCompletionSource(object state);
    [NullableContextAttribute("2")]
public TaskCompletionSource(object state, TaskCreationOptions creationOptions);
    public Task get_Task();
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetResult();
    public bool TrySetResult();
    public void SetCanceled();
    public void SetCanceled(CancellationToken cancellationToken);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    private Task`1<TResult> _task;
    public Task`1<TResult> Task { get; }
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public TaskCompletionSource`1(object state);
    [NullableContextAttribute("2")]
public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    public void SetException(Exception exception);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetException(Exception exception);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public void SetResult(TResult result);
    public bool TrySetResult(TResult result);
    public void SetCanceled();
    public void SetCanceled(CancellationToken cancellationToken);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
}
internal abstract class System.Threading.Tasks.TaskContinuation : object {
    internal abstract virtual void Run(Task completedTask, bool canInlineContinuationTask);
    protected static void InlineIfPossibleOrElseQueue(Task task, bool needsProtection);
    internal abstract virtual Delegate[] GetDelegateContinuationsForDebugger();
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
internal class System.Threading.Tasks.TaskExceptionHolder : object {
    private Task m_task;
    private List`1 modreq(System.Runtime.CompilerServices.IsVolatile) m_faultExceptions;
    private ExceptionDispatchInfo m_cancellationException;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isHandled;
    internal bool ContainsFaultList { get; }
    internal TaskExceptionHolder(Task task);
    protected virtual override void Finalize();
    internal bool get_ContainsFaultList();
    internal void Add(object exceptionObject, bool representsCancellation);
    private void SetCancellationException(object exceptionObject);
    private void AddFaultException(object exceptionObject);
    private void MarkAsUnhandled();
    internal void MarkAsHandled(bool calledFromFinalizer);
    internal AggregateException CreateExceptionObject(bool calledFromFinalizer, Exception includeThisException);
    internal List`1<ExceptionDispatchInfo> GetExceptionDispatchInfos();
    internal ExceptionDispatchInfo GetCancellationExceptionDispatchInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskFactory : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    [NullableAttribute("2")]
public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TaskFactory(TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    internal static void CheckCreationOptions(TaskCreationOptions creationOptions);
    public CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static void CheckFromAsyncOptions(TaskCreationOptions creationOptions, bool hasBeginMethod);
    internal static Task`1<Task[]> CommonCWAllLogic(Task[] tasksCopy);
    internal static Task`1<Task`1[]> CommonCWAllLogic(Task`1[] tasksCopy);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TTask> CommonCWAnyLogic(IList`1<TTask> tasks, bool isSyncBlocking);
    internal static void CommonCWAnyLogicCleanup(Task`1<Task> continuation);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task[] CheckMultiContinuationTasksAndCopy(Task[] tasks);
    internal static Task`1[] CheckMultiContinuationTasksAndCopy(Task`1[] tasks);
    internal static void CheckMultiTaskContinuationOptions(TaskContinuationOptions continuationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskFactory`1 : object {
    private CancellationToken m_defaultCancellationToken;
    private TaskScheduler m_defaultScheduler;
    private TaskCreationOptions m_defaultCreationOptions;
    private TaskContinuationOptions m_defaultContinuationOptions;
    private TaskScheduler DefaultScheduler { get; }
    public CancellationToken CancellationToken { get; }
    [NullableAttribute("2")]
public TaskScheduler Scheduler { get; }
    public TaskCreationOptions CreationOptions { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TaskFactory`1(TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    private TaskScheduler get_DefaultScheduler();
    private TaskScheduler GetDefaultScheduler(Task currTask);
    public CancellationToken get_CancellationToken();
    [NullableContextAttribute("2")]
public TaskScheduler get_Scheduler();
    public TaskCreationOptions get_CreationOptions();
    public TaskContinuationOptions get_ContinuationOptions();
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    private static void FromAsyncCoreLogic(IAsyncResult iar, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, Task`1<TResult> promise, bool requiresSynchronization);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> FromAsyncImpl(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncImpl(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endFunction, Action`1<IAsyncResult> endAction, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    internal static Task`1<TResult> FromAsyncTrim(TInstance thisRef, TArgs args, Func`5<TInstance, TArgs, AsyncCallback, object, IAsyncResult> beginMethod, Func`3<TInstance, IAsyncResult, TResult> endMethod);
    private static Task`1<TResult> CreateCanceledTask(TaskContinuationOptions continuationOptions, CancellationToken ct);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAllImpl(Task[] tasks, Func`2<Task[], TResult> continuationFunction, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task[] tasks, Func`2<Task, TResult> continuationFunction, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
    internal static Task`1<TResult> ContinueWhenAnyImpl(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Id = {Id}")]
[DebuggerTypeProxyAttribute("System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    private static ConditionalWeakTable`2<TaskScheduler, object> s_activeTaskSchedulers;
    private static TaskScheduler s_defaultTaskScheduler;
    internal static int s_taskSchedulerIdCounter;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) m_taskSchedulerId;
    [CompilerGeneratedAttribute]
private static EventHandler`1<UnobservedTaskExceptionEventArgs> UnobservedTaskException;
    public int MaximumConcurrencyLevel { get; }
    public static TaskScheduler Default { get; }
    public static TaskScheduler Current { get; }
    [NullableAttribute("2")]
internal static TaskScheduler InternalCurrent { get; }
    public int Id { get; }
    private static TaskScheduler();
    protected internal abstract virtual void QueueTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    public virtual int get_MaximumConcurrencyLevel();
    internal bool TryRunInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    internal virtual void NotifyWorkItemProgress();
    internal void InternalQueueTask(Task task);
    public static TaskScheduler get_Default();
    public static TaskScheduler get_Current();
    internal static TaskScheduler get_InternalCurrent();
    public static TaskScheduler FromCurrentSynchronizationContext();
    public int get_Id();
    protected bool TryExecuteTask(Task task);
    [CompilerGeneratedAttribute]
public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    internal static void PublishUnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs ueea);
    internal Task[] GetScheduledTasksForDebugger();
    internal static TaskScheduler[] GetTaskSchedulersForDebugger();
}
internal class System.Threading.Tasks.TaskSchedulerAwaitTaskContinuation : AwaitTaskContinuation {
    private TaskScheduler m_scheduler;
    internal TaskSchedulerAwaitTaskContinuation(TaskScheduler scheduler, Action action, bool flowExecutionContext);
    internal sealed virtual void Run(Task ignored, bool canInlineContinuationTask);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(string message);
    public TaskSchedulerException(Exception innerException);
    public TaskSchedulerException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.Tasks.TaskToAsyncResult : object {
    public static IAsyncResult Begin(Task task, AsyncCallback callback, object state);
    public static void End(IAsyncResult asyncResult);
    public static TResult End(IAsyncResult asyncResult);
    public static Task Unwrap(IAsyncResult asyncResult);
    public static Task`1<TResult> Unwrap(IAsyncResult asyncResult);
}
internal class System.Threading.Tasks.ThreadPoolTaskScheduler : TaskScheduler {
    private static ParameterizedThreadStart s_longRunningThreadWork;
    private static ThreadPoolTaskScheduler();
    protected internal virtual void QueueTask(Task task);
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    protected internal virtual bool TryDequeue(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    [IteratorStateMachineAttribute("System.Threading.Tasks.ThreadPoolTaskScheduler/<FilterTasksFromWorkItems>d__6")]
private static IEnumerable`1<Task> FilterTasksFromWorkItems(IEnumerable`1<object> tpwItems);
    internal virtual void NotifyWorkItemProgress();
}
[EventSourceAttribute]
[GeneratedCodeAttribute("System.Private.CoreLib.Generators", "8.0.10.36612")]
internal class System.Threading.Tasks.TplEventSource : EventSource {
    private static string EventSourceSuppressMessage;
    internal bool TasksSetActivityIds;
    internal bool Debug;
    private bool DebugActivityId;
    private static int DefaultAppDomainID;
    public static TplEventSource Log;
    private static int TASKSCHEDULED_ID;
    private static int TASKSTARTED_ID;
    private static int TASKCOMPLETED_ID;
    private static int TASKWAITBEGIN_ID;
    private static int TASKWAITEND_ID;
    private static int AWAITTASKCONTINUATIONSCHEDULED_ID;
    private static int TASKWAITCONTINUATIONCOMPLETE_ID;
    private static int TASKWAITCONTINUATIONSTARTED_ID;
    private static int TRACEOPERATIONSTART_ID;
    private static int TRACEOPERATIONSTOP_ID;
    private static int TRACEOPERATIONRELATION_ID;
    private static int TRACESYNCHRONOUSWORKSTART_ID;
    private static int TRACESYNCHRONOUSWORKSTOP_ID;
    private protected ReadOnlySpan`1<byte> ProviderMetadata { get; }
    private TplEventSource(int _);
    private static TplEventSource();
    protected virtual void OnEventCommand(EventCommandEventArgs command);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("7")]
public void TaskScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, int CreatingTaskID, int TaskCreationOptions, int appDomain);
    [EventAttribute("8")]
public void TaskStarted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("9")]
public void TaskCompleted(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, bool IsExceptional);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("10")]
public void TaskWaitBegin(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID, TaskWaitBehavior Behavior, int ContinueWithTaskID);
    [EventAttribute("11")]
public void TaskWaitEnd(int OriginatingTaskSchedulerID, int OriginatingTaskID, int TaskID);
    [EventAttribute("13")]
public void TaskWaitContinuationComplete(int TaskID);
    [EventAttribute("19")]
public void TaskWaitContinuationStarted(int TaskID);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("12")]
public void AwaitTaskContinuationScheduled(int OriginatingTaskSchedulerID, int OriginatingTaskID, int ContinueWithTaskId);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("14")]
public void TraceOperationBegin(int TaskID, string OperationName, long RelatedContext);
    [EventAttribute("16")]
public void TraceOperationRelation(int TaskID, CausalityRelation Relation);
    [EventAttribute("15")]
public void TraceOperationEnd(int TaskID, AsyncCausalityStatus Status);
    [EventAttribute("17")]
public void TraceSynchronousWorkBegin(int TaskID, CausalitySynchronousWork Work);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2026:UnrecognizedReflectionPattern")]
[EventAttribute("18")]
public void TraceSynchronousWorkEnd(CausalitySynchronousWork Work);
    [NonEventAttribute]
public void RunningContinuation(int TaskID, object Object);
    [EventAttribute("20")]
private void RunningContinuation(int TaskID, long Object);
    [NonEventAttribute]
public void RunningContinuationList(int TaskID, int Index, object Object);
    [EventAttribute("21")]
public void RunningContinuationList(int TaskID, int Index, long Object);
    [EventAttribute("23")]
public void DebugFacilityMessage(string Facility, string Message);
    [EventAttribute("24")]
public void DebugFacilityMessage1(string Facility, string Message, string Value1);
    [EventAttribute("25")]
public void SetActivityId(Guid NewId);
    [EventAttribute("26")]
public void NewID(int TaskID);
    [NonEventAttribute]
public void IncompleteAsyncMethod(IAsyncStateMachineBox stateMachineBox);
    [EventAttribute("27")]
private void IncompleteAsyncMethod(string stateMachineDescription);
    internal static Guid CreateGuidForTaskID(int taskID);
    private protected virtual ReadOnlySpan`1<byte> get_ProviderMetadata();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    private AggregateException m_exception;
    internal bool m_observed;
    public bool Observed { get; }
    public AggregateException Exception { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public void SetObserved();
    public bool get_Observed();
    public AggregateException get_Exception();
}
internal class System.Threading.Tasks.UnwrapPromise`1 : Task`1<TResult> {
    private byte _state;
    private bool _lookForOce;
    public bool InvokeMayRunArbitraryCode { get; }
    public UnwrapPromise`1(Task outerTask, bool lookForOce);
    public sealed virtual void Invoke(Task completingTask);
    private void InvokeCore(Task completingTask);
    private void InvokeCoreAsync(Task completingTask);
    private void ProcessCompletedOuterTask(Task task);
    private bool TrySetFromTask(Task task, bool lookForOce);
    private void ProcessInnerTask(Task task);
    public sealed virtual bool get_InvokeMayRunArbitraryCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private static Task modreq(System.Runtime.CompilerServices.IsVolatile) s_canceledTask;
    internal object _obj;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public static ValueTask CompletedTask { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    public ValueTask(Task task);
    public ValueTask(IValueTaskSource source, short token);
    private ValueTask(object obj, short token, bool continueOnCapturedContext);
    public static ValueTask get_CompletedTask();
    public static ValueTask`1<TResult> FromResult(TResult result);
    public static ValueTask FromCanceled(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static ValueTask`1<TResult> FromCanceled(CancellationToken cancellationToken);
    public static ValueTask FromException(Exception exception);
    public static ValueTask`1<TResult> FromException(Exception exception);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public Task AsTask();
    public ValueTask Preserve();
    private Task GetTaskForValueTaskSource(IValueTaskSource t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    internal void ThrowIfCompletedUnsuccessfully();
    internal static ValueTask DangerousCreateFromTypedValueTask(ValueTask`1<TResult> valueTask);
    public ValueTaskAwaiter GetAwaiter();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private static Task`1 modreq(System.Runtime.CompilerServices.IsVolatile) s_canceledTask;
    internal object _obj;
    internal TResult _result;
    internal short _token;
    internal bool _continueOnCapturedContext;
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public bool IsCanceled { get; }
    [DebuggerBrowsableAttribute("0")]
public TResult Result { get; }
    public ValueTask`1(TResult result);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    private ValueTask`1(object obj, TResult result, short token, bool continueOnCapturedContext);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public Task`1<TResult> AsTask();
    public ValueTask`1<TResult> Preserve();
    private Task`1<TResult> GetTaskForValueTaskSource(IValueTaskSource`1<TResult> t);
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public bool get_IsCanceled();
    public TResult get_Result();
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    [NullableContextAttribute("2")]
public virtual string ToString();
}
[IsReadOnlyAttribute]
internal class System.Threading.Tasks.VoidTaskResult : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Thread : CriticalFinalizerObject {
    private int lock_thread_id;
    private IntPtr handle;
    private IntPtr native_handle;
    private IntPtr name;
    private int name_free;
    private int name_length;
    private ThreadState state;
    private object abort_exc;
    private int abort_state_handle;
    internal long thread_id;
    private IntPtr debugger_thread;
    private UIntPtr static_data;
    private IntPtr runtime_thread_info;
    private int interruption_requested;
    private IntPtr longlived;
    internal bool threadpool_thread;
    internal bool external_eventloop;
    internal byte apartment_state;
    internal int managed_id;
    private int small_id;
    private IntPtr manage_callback;
    private IntPtr flags;
    private IntPtr thread_pinning_ref;
    private int priority;
    private IntPtr owned_mutex;
    private IntPtr suspended_event;
    private int self_suspended;
    private IntPtr thread_state;
    private Thread self;
    private object pending_exception;
    private IntPtr last;
    private string _name;
    private StartHelper _startHelper;
    internal ExecutionContext _executionContext;
    internal SynchronizationContext _synchronizationContext;
    internal ThreadWaitInfo _waitInfo;
    private bool _mayNeedResetForThreadPool;
    private static AsyncLocal`1<IPrincipal> s_asyncLocalPrincipal;
    [ThreadStaticAttribute]
private static Thread t_currentThread;
    private static bool s_isProcessorNumberReallyFast;
    public bool IsAlive { get; }
    public bool IsBackground { get; public set; }
    public bool IsThreadPoolThread { get; internal set; }
    public int ManagedThreadId { get; }
    internal ThreadWaitInfo WaitInfo { get; }
    public ThreadPriority Priority { get; public set; }
    public ThreadState ThreadState { get; }
    public CultureInfo CurrentCulture { get; public set; }
    public CultureInfo CurrentUICulture { get; public set; }
    [NullableAttribute("2")]
public static IPrincipal CurrentPrincipal { get; public set; }
    public static Thread CurrentThread { get; }
    internal static ulong CurrentOSThreadId { get; }
    [NullableAttribute("2")]
public ExecutionContext ExecutionContext { get; }
    [NullableAttribute("2")]
public string Name { get; public set; }
    [ObsoleteAttribute("The ApartmentState property has been deprecated. Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.")]
public ApartmentState ApartmentState { get; public set; }
    public Thread(ThreadStart start);
    public Thread(ThreadStart start, int maxStackSize);
    public Thread(ParameterizedThreadStart start);
    public Thread(ParameterizedThreadStart start, int maxStackSize);
    private static Thread();
    protected virtual override void Finalize();
    public bool get_IsAlive();
    public bool get_IsBackground();
    public void set_IsBackground(bool value);
    public bool get_IsThreadPoolThread();
    internal void set_IsThreadPoolThread(bool value);
    public int get_ManagedThreadId();
    internal ThreadWaitInfo get_WaitInfo();
    public ThreadPriority get_Priority();
    public void set_Priority(ThreadPriority value);
    public ThreadState get_ThreadState();
    public ApartmentState GetApartmentState();
    public void DisableComObjectEagerCleanup();
    public void Interrupt();
    public bool Join(int millisecondsTimeout);
    [DynamicDependencyAttribute("OnThreadExiting")]
private void Initialize();
    public static void SpinWait(int iterations);
    internal void StartCallback();
    internal static void ThrowThreadStartException(Exception ex);
    private void StartCore();
    [DynamicDependencyAttribute("StartCallback")]
[DynamicDependencyAttribute("ThrowThreadStartException")]
private static void StartInternal(Thread runtimeThread, int stackSize);
    public static bool Yield();
    private static bool SetApartmentStateUnchecked(ApartmentState state, bool throwOnError);
    private ThreadState ValidateThreadState();
    internal void SetWaitSleepJoinState();
    internal void ClearWaitSleepJoinState();
    private static void OnThreadExiting(Thread thread);
    private static ulong GetCurrentOSThreadId();
    [MemberNotNullAttribute("self")]
private static void InitInternal(Thread thread);
    private static Thread GetCurrentThread();
    private static Thread InitializeCurrentThread();
    private void FreeInternal();
    private static ThreadState GetState(Thread thread);
    private static void SetState(Thread thread, ThreadState set);
    private static void ClrState(Thread thread, ThreadState clr);
    private static void SetName_icall(Thread thread, Char* name, int nameLength);
    private static void SetName(Thread thread, string name);
    private static bool YieldInternal();
    [IntrinsicAttribute]
private static void SpinWait_nop();
    private static bool JoinInternal(Thread thread, int millisecondsTimeout);
    private static void InterruptInternal(Thread thread);
    private static void SetPriority(Thread thread, int priority);
    internal int GetSmallId();
    internal static void ThrowIfNoThreadStart(bool internalThread);
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public void Start(object parameter);
    [NullableContextAttribute("2")]
[UnsupportedOSPlatformAttribute("browser")]
public void UnsafeStart(object parameter);
    private void Start(object parameter, bool captureContext, bool internalThread);
    [UnsupportedOSPlatformAttribute("browser")]
public void Start();
    [UnsupportedOSPlatformAttribute("browser")]
public void UnsafeStart();
    internal void InternalUnsafeStart();
    private void Start(bool captureContext, bool internalThread);
    private void RequireCurrentThread();
    private void SetCultureOnUnstartedThread(CultureInfo value, bool uiCulture);
    private void ThreadNameChanged(string value);
    public CultureInfo get_CurrentCulture();
    public void set_CurrentCulture(CultureInfo value);
    public CultureInfo get_CurrentUICulture();
    public void set_CurrentUICulture(CultureInfo value);
    [NullableContextAttribute("2")]
public static IPrincipal get_CurrentPrincipal();
    [NullableContextAttribute("2")]
public static void set_CurrentPrincipal(IPrincipal value);
    [IntrinsicAttribute]
public static Thread get_CurrentThread();
    public static void Sleep(int millisecondsTimeout);
    internal static ulong get_CurrentOSThreadId();
    [NullableContextAttribute("2")]
public ExecutionContext get_ExecutionContext();
    [NullableContextAttribute("2")]
public string get_Name();
    [NullableContextAttribute("2")]
public void set_Name(string value);
    internal void SetThreadPoolWorkerThreadName();
    internal void ResetThreadPoolThread();
    private void ResetThreadPoolThreadSlow();
    [ObsoleteAttribute("Thread.Abort is not supported and throws PlatformNotSupportedException.")]
public void Abort();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Thread.Abort is not supported and throws PlatformNotSupportedException.")]
public void Abort(object stateInfo);
    [ObsoleteAttribute("Thread.ResetAbort is not supported and throws PlatformNotSupportedException.")]
public static void ResetAbort();
    [ObsoleteAttribute("Thread.Suspend has been deprecated. Use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.")]
public void Suspend();
    [ObsoleteAttribute("Thread.Resume has been deprecated. Use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.")]
public void Resume();
    public static void BeginCriticalRegion();
    public static void EndCriticalRegion();
    public static void BeginThreadAffinity();
    public static void EndThreadAffinity();
    public static LocalDataStoreSlot AllocateDataSlot();
    public static LocalDataStoreSlot AllocateNamedDataSlot(string name);
    public static LocalDataStoreSlot GetNamedDataSlot(string name);
    public static void FreeNamedDataSlot(string name);
    public static object GetData(LocalDataStoreSlot slot);
    public static void SetData(LocalDataStoreSlot slot, object data);
    public ApartmentState get_ApartmentState();
    public void set_ApartmentState(ApartmentState value);
    [SupportedOSPlatformAttribute("windows")]
public void SetApartmentState(ApartmentState state);
    public bool TrySetApartmentState(ApartmentState state);
    private bool SetApartmentState(ApartmentState state, bool throwOnError);
    [ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public CompressedStack GetCompressedStack();
    [ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public void SetCompressedStack(CompressedStack stack);
    public static AppDomain GetDomain();
    public static int GetDomainID();
    public virtual int GetHashCode();
    public void Join();
    public bool Join(TimeSpan timeout);
    public static void MemoryBarrier();
    public static void Sleep(TimeSpan timeout);
    public static byte VolatileRead(Byte& address);
    public static double VolatileRead(Double& address);
    public static short VolatileRead(Int16& address);
    public static int VolatileRead(Int32& address);
    public static long VolatileRead(Int64& address);
    public static IntPtr VolatileRead(IntPtr& address);
    [NullableContextAttribute("2")]
public static object VolatileRead(Object& address);
    [CLSCompliantAttribute("False")]
public static sbyte VolatileRead(SByte& address);
    public static float VolatileRead(Single& address);
    [CLSCompliantAttribute("False")]
public static ushort VolatileRead(UInt16& address);
    [CLSCompliantAttribute("False")]
public static UInt32 VolatileRead(UInt32& address);
    [CLSCompliantAttribute("False")]
public static ulong VolatileRead(UInt64& address);
    [CLSCompliantAttribute("False")]
public static UIntPtr VolatileRead(UIntPtr& address);
    public static void VolatileWrite(Byte& address, byte value);
    public static void VolatileWrite(Double& address, double value);
    public static void VolatileWrite(Int16& address, short value);
    public static void VolatileWrite(Int32& address, int value);
    public static void VolatileWrite(Int64& address, long value);
    public static void VolatileWrite(IntPtr& address, IntPtr value);
    [NullableContextAttribute("2")]
public static void VolatileWrite(Object& address, object value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(SByte& address, sbyte value);
    public static void VolatileWrite(Single& address, float value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt16& address, ushort value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt32& address, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UInt64& address, ulong value);
    [CLSCompliantAttribute("False")]
public static void VolatileWrite(UIntPtr& address, UIntPtr value);
    public static int GetCurrentProcessorId();
    internal static void UninterruptibleSleep0();
    private static void SleepInternal(int millisecondsTimeout);
    internal static int GetCurrentProcessorNumber();
    [CompilerGeneratedAttribute]
private ThreadWaitInfo <get_WaitInfo>g__AllocateWaitInfo|52_0();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadAbortException : SystemException {
    public object ExceptionState { get; }
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private ThreadAbortException(SerializationInfo info, StreamingContext context);
    public object get_ExceptionState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.ThreadExceptionEventArgs : EventArgs {
    private Exception m_exception;
    public Exception Exception { get; }
    public ThreadExceptionEventArgs(Exception t);
    public Exception get_Exception();
}
public class System.Threading.ThreadExceptionEventHandler : MulticastDelegate {
    public ThreadExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, ThreadExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ThreadExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.ThreadInt64PersistentCounter : object {
    private LowLevelLock _lock;
    [ThreadStaticAttribute]
private static List`1<ThreadLocalNodeFinalizationHelper> t_nodeFinalizationHelpers;
    private long _overflowCount;
    private ThreadLocalNode _nodes;
    public long Count { get; }
    public static void Increment(object threadLocalCountObject);
    public object CreateThreadLocalCountObject();
    public long get_Count();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadInterruptedException : SystemException {
    public ThreadInterruptedException(string message);
    public ThreadInterruptedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ThreadInterruptedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("System.Threading.SystemThreading_ThreadLocalDebugView`1")]
[DebuggerDisplayAttribute("IsValueCreated = {IsValueCreated}, Value = {ValueForDebugDisplay}, Count = {ValuesCountForDebugDisplay}")]
public class System.Threading.ThreadLocal`1 : object {
    private Func`1<T> _valueFactory;
    [ThreadStaticAttribute]
private static LinkedSlotVolatile[] ts_slotArray;
    [ThreadStaticAttribute]
private static FinalizationHelper<T> ts_finalizationHelper;
    private int _idComplement;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _initialized;
    private static IdManager<T> s_idManager;
    private LinkedSlot<T> _linkedSlot;
    private bool _trackAllValues;
    [DebuggerBrowsableAttribute("0")]
public T Value { get; public set; }
    public IList`1<T> Values { get; }
    private int ValuesCountForDebugDisplay { get; }
    public bool IsValueCreated { get; }
    [NullableAttribute("2")]
internal T ValueForDebugDisplay { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<T> ValuesForDebugDisplay { get; }
    public ThreadLocal`1(bool trackAllValues);
    public ThreadLocal`1(Func`1<T> valueFactory);
    public ThreadLocal`1(Func`1<T> valueFactory, bool trackAllValues);
    private static ThreadLocal`1();
    private void Initialize(Func`1<T> valueFactory, bool trackAllValues);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("2")]
public virtual string ToString();
    public T get_Value();
    public void set_Value(T value);
    private T GetValueSlow();
    private void SetValueSlow(T value, LinkedSlotVolatile[] slotArray);
    private void CreateLinkedSlot(LinkedSlotVolatile[] slotArray, int id, T value);
    public IList`1<T> get_Values();
    private List`1<T> GetValuesAsList();
    private int get_ValuesCountForDebugDisplay();
    public bool get_IsValueCreated();
    internal T get_ValueForDebugDisplay();
    internal List`1<T> get_ValuesForDebugDisplay();
    private static void GrowTable(LinkedSlotVolatile[]& table, int minLength);
    private static int GetNewTableSize(int minSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.ThreadPool : object {
    internal static ThreadPoolWorkQueue s_workQueue;
    internal static Action`1<object> s_invokeAsyncStateMachineBox;
    private static bool IsWorkerTrackingEnabledInConfig;
    internal static bool EnableWorkerTracking { get; }
    public static long PendingWorkItemCount { get; }
    public static int ThreadCount { get; }
    public static long CompletedWorkItemCount { get; }
    private static ThreadPool();
    internal static bool get_EnableWorkerTracking();
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
[CLSCompliantAttribute("False")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
public static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    [UnsupportedOSPlatformAttribute("browser")]
public static RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);
    public static bool QueueUserWorkItem(WaitCallback callBack);
    public static bool QueueUserWorkItem(WaitCallback callBack, object state);
    public static bool QueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(Action`1<TState> callBack, TState state, bool preferLocal);
    public static bool UnsafeQueueUserWorkItem(WaitCallback callBack, object state);
    public static bool UnsafeQueueUserWorkItem(IThreadPoolWorkItem callBack, bool preferLocal);
    internal static void UnsafeQueueUserWorkItemInternal(object callBack, bool preferLocal);
    internal static void UnsafeQueueHighPriorityWorkItemInternal(IThreadPoolWorkItem callBack);
    internal static bool TryPopCustomWorkItem(object workItem);
    [IteratorStateMachineAttribute("System.Threading.ThreadPool/<GetQueuedWorkItems>d__22")]
internal static IEnumerable`1<object> GetQueuedWorkItems();
    public static long get_PendingWorkItemCount();
    internal static object GetOrCreateThreadLocalCompletionCountObject();
    public static bool SetMaxThreads(int workerThreads, int completionPortThreads);
    public static void GetMaxThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static bool SetMinThreads(int workerThreads, int completionPortThreads);
    public static void GetMinThreads(Int32& workerThreads, Int32& completionPortThreads);
    public static void GetAvailableThreads(Int32& workerThreads, Int32& completionPortThreads);
    internal static void NotifyWorkItemProgress();
    internal static bool NotifyThreadBlocked();
    internal static void NotifyThreadUnblocked();
    internal static bool NotifyWorkItemComplete(object threadLocalCompletionCountObject, int currentTimeMs);
    internal static void RequestWorkerThread();
    internal static void ReportThreadStatus(bool isWorking);
    internal static RegisteredWaitHandle RegisterWaitForSingleObject(WaitHandle waitObject, WaitOrTimerCallback callBack, object state, UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce, bool flowExecutionContext);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
[SupportedOSPlatformAttribute("windows")]
public static bool UnsafeQueueNativeOverlapped(NativeOverlapped* overlapped);
    [ObsoleteAttribute("ThreadPool.BindHandle(IntPtr) has been deprecated. Use ThreadPool.BindHandle(SafeHandle) instead.")]
[SupportedOSPlatformAttribute("windows")]
public static bool BindHandle(IntPtr osHandle);
    [SupportedOSPlatformAttribute("windows")]
public static bool BindHandle(SafeHandle osHandle);
    public static int get_ThreadCount();
    public static long get_CompletedWorkItemCount();
}
public class System.Threading.ThreadPoolBoundHandle : object {
    private SafeHandle _handle;
    private bool _isDisposed;
    [NullableAttribute("1")]
public SafeHandle Handle { get; }
    private ThreadPoolBoundHandle(SafeHandle handle);
    private NativeOverlapped* AllocateNativeOverlappedPortableCore(IOCompletionCallback callback, object state, object pinData);
    private NativeOverlapped* UnsafeAllocateNativeOverlappedPortableCore(IOCompletionCallback callback, object state, object pinData);
    private NativeOverlapped* AllocateNativeOverlappedPortableCore(IOCompletionCallback callback, object state, object pinData, bool flowExecutionContext);
    private NativeOverlapped* AllocateNativeOverlappedPortableCore(PreAllocatedOverlapped preAllocated);
    private void FreeNativeOverlappedPortableCore(NativeOverlapped* overlapped);
    private static object GetNativeOverlappedStatePortableCore(NativeOverlapped* overlapped);
    private static ThreadPoolBoundHandleOverlapped GetOverlappedWrapper(NativeOverlapped* overlapped);
    private void DisposePortableCore();
    [NullableContextAttribute("1")]
public SafeHandle get_Handle();
    [NullableContextAttribute("1")]
public static ThreadPoolBoundHandle BindHandle(SafeHandle handle);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public NativeOverlapped* UnsafeAllocateNativeOverlapped(IOCompletionCallback callback, object state, object pinData);
    [CLSCompliantAttribute("False")]
public NativeOverlapped* AllocateNativeOverlapped(PreAllocatedOverlapped preAllocated);
    [CLSCompliantAttribute("False")]
public void FreeNativeOverlapped(NativeOverlapped* overlapped);
    [CLSCompliantAttribute("False")]
public static object GetNativeOverlappedState(NativeOverlapped* overlapped);
    public sealed virtual void Dispose();
}
internal class System.Threading.ThreadPoolBoundHandleOverlapped : Overlapped {
    private static IOCompletionCallback s_completionCallback;
    private IOCompletionCallback _userCallback;
    internal object _userState;
    internal PreAllocatedOverlapped _preAllocated;
    internal NativeOverlapped* _nativeOverlapped;
    internal ThreadPoolBoundHandle _boundHandle;
    internal bool _completed;
    public ThreadPoolBoundHandleOverlapped(IOCompletionCallback callback, object state, object pinData, PreAllocatedOverlapped preAllocated, bool flowExecutionContext);
    private static ThreadPoolBoundHandleOverlapped();
    private static void CompletionCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
}
internal class System.Threading.ThreadPoolWorkQueue : object {
    private static int s_assignableWorkItemQueueCount;
    private bool _loggingEnabled;
    private bool _dispatchNormalPriorityWorkFirst;
    private int _mayHaveHighPriorityWorkItems;
    internal ConcurrentQueue`1<object> workItems;
    internal ConcurrentQueue`1<object> highPriorityWorkItems;
    internal ConcurrentQueue`1[] _assignableWorkItemQueues;
    private LowLevelLock _queueAssignmentLock;
    private Int32[] _assignedWorkItemQueueThreadCounts;
    private CacheLineSeparated _separated;
    public static long LocalCount { get; }
    public long GlobalCount { get; }
    private static ThreadPoolWorkQueue();
    private void AssignWorkItemQueue(ThreadPoolWorkQueueThreadLocals tl);
    private void TryReassignWorkItemQueue(ThreadPoolWorkQueueThreadLocals tl);
    private void UnassignWorkItemQueue(ThreadPoolWorkQueueThreadLocals tl);
    public ThreadPoolWorkQueueThreadLocals GetOrCreateThreadLocals();
    private ThreadPoolWorkQueueThreadLocals CreateThreadLocals();
    public void RefreshLoggingEnabled();
    public void RefreshLoggingEnabledFull();
    internal void EnsureThreadRequested();
    internal void MarkThreadRequestSatisfied();
    public void Enqueue(object callback, bool forceGlobal);
    public void EnqueueAtHighPriority(object workItem);
    internal static bool LocalFindAndPop(object callback);
    public object Dequeue(ThreadPoolWorkQueueThreadLocals tl, Boolean& missedSteal);
    private bool TryStartProcessingHighPriorityWorkItemsAndDequeue(ThreadPoolWorkQueueThreadLocals tl, Object& workItem);
    public static long get_LocalCount();
    public long get_GlobalCount();
    internal static bool Dispatch();
    private static void DispatchWorkItemWithWorkerTracking(object workItem, Thread currentThread);
    private static void DispatchWorkItem(object workItem, Thread currentThread);
}
internal class System.Threading.ThreadPoolWorkQueueThreadLocals : object {
    [ThreadStaticAttribute]
public static ThreadPoolWorkQueueThreadLocals threadLocals;
    public bool isProcessingHighPriorityWorkItems;
    public int queueIndex;
    public ConcurrentQueue`1<object> assignedGlobalWorkItemQueue;
    public ThreadPoolWorkQueue workQueue;
    public WorkStealingQueue workStealingQueue;
    public Thread currentThread;
    public object threadLocalCompletionCountObject;
    public XoshiroImpl random;
    public ThreadPoolWorkQueueThreadLocals(ThreadPoolWorkQueue tpq);
    public void TransferLocalWork();
    protected virtual override void Finalize();
}
public enum System.Threading.ThreadPriority : Enum {
    public int value__;
    public static ThreadPriority Lowest;
    public static ThreadPriority BelowNormal;
    public static ThreadPriority Normal;
    public static ThreadPriority AboveNormal;
    public static ThreadPriority Highest;
}
public class System.Threading.ThreadStart : MulticastDelegate {
    public ThreadStart(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStartException : SystemException {
    internal ThreadStartException(Exception reason);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private ThreadStartException(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Threading.ThreadState : Enum {
    public int value__;
    public static ThreadState Running;
    public static ThreadState StopRequested;
    public static ThreadState SuspendRequested;
    public static ThreadState Background;
    public static ThreadState Unstarted;
    public static ThreadState Stopped;
    public static ThreadState WaitSleepJoin;
    public static ThreadState Suspended;
    public static ThreadState AbortRequested;
    public static ThreadState Aborted;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.ThreadStateException : SystemException {
    public ThreadStateException(string message);
    public ThreadStateException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected ThreadStateException(SerializationInfo info, StreamingContext context);
}
public static class System.Threading.Timeout : object {
    public static TimeSpan InfiniteTimeSpan;
    public static int Infinite;
    private static Timeout();
}
internal static class System.Threading.TimeoutHelper : object {
    public static UInt32 GetTime();
    public static int UpdateTimeOut(UInt32 startTime, int originalWaitMillisecondsTimeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.TimerQueueTimer/TimerDebuggerTypeProxy")]
public class System.Threading.Timer : MarshalByRefObject {
    internal TimerHolder _timer;
    public static long ActiveCount { get; }
    private string DisplayString { get; }
    private static IEnumerable`1<TimerQueueTimer> AllTimers { get; }
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    internal Timer(TimerCallback callback, object state, int dueTime, int period, bool flowExecutionContext);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback);
    [MemberNotNullAttribute("_timer")]
private void TimerSetup(TimerCallback callback, object state, UInt32 dueTime, UInt32 period, bool flowExecutionContext);
    public bool Change(int dueTime, int period);
    public sealed virtual bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public bool Change(long dueTime, long period);
    public static long get_ActiveCount();
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    private string get_DisplayString();
    private static IEnumerable`1<TimerQueueTimer> get_AllTimers();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Threading.TimerHolder : object {
    internal TimerQueueTimer _timer;
    public TimerHolder(TimerQueueTimer timer);
    protected virtual override void Finalize();
    public void Dispose();
    public bool Dispose(WaitHandle notifyObject);
    public ValueTask DisposeAsync();
}
[DebuggerDisplayAttribute("Count = {CountForDebugger}")]
[DebuggerTypeProxyAttribute("System.Threading.TimerQueue/TimerQueueDebuggerTypeProxy")]
internal class System.Threading.TimerQueue : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ValueTuple`2<long, DateTime> s_tickCountToTimeMap;
    [CompilerGeneratedAttribute]
private static TimerQueue[] <Instances>k__BackingField;
    private bool _isTimerScheduled;
    private long _currentTimerStartTicks;
    private UInt32 _currentTimerDuration;
    private TimerQueueTimer _shortTimers;
    private TimerQueueTimer _longTimers;
    private long _currentAbsoluteThreshold;
    [CompilerGeneratedAttribute]
private long <ActiveCount>k__BackingField;
    private static List`1<TimerQueue> s_scheduledTimers;
    private static List`1<TimerQueue> s_scheduledTimersToFire;
    private static AutoResetEvent s_timerEvent;
    private bool _isScheduled;
    private long _scheduledDueTimeMs;
    public static TimerQueue[] Instances { get; }
    private int CountForDebugger { get; }
    public long ActiveCount { get; private set; }
    private static long TickCount64 { get; }
    private TimerQueue(int id);
    private static TimerQueue();
    [CompilerGeneratedAttribute]
public static TimerQueue[] get_Instances();
    private static TimerQueue[] CreateTimerQueues();
    private int get_CountForDebugger();
    [IteratorStateMachineAttribute("System.Threading.TimerQueue/<GetTimersForDebugger>d__7")]
internal IEnumerable`1<TimerQueueTimer> GetTimersForDebugger();
    private bool EnsureTimerFiresBy(UInt32 requestedDuration);
    private void FireNextTimers();
    [CompilerGeneratedAttribute]
public long get_ActiveCount();
    [CompilerGeneratedAttribute]
private void set_ActiveCount(long value);
    public bool UpdateTimer(TimerQueueTimer timer, UInt32 dueTime, UInt32 period);
    public void MoveTimerToCorrectList(TimerQueueTimer timer, bool shortList);
    private void LinkTimer(TimerQueueTimer timer);
    private void UnlinkTimer(TimerQueueTimer timer);
    public void DeleteTimer(TimerQueueTimer timer);
    private static List`1<TimerQueue> InitializeScheduledTimerManager_Locked();
    private bool SetTimerPortable(UInt32 actualDuration);
    private static void TimerThread();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    private static long get_TickCount64();
    private bool SetTimer(UInt32 actualDuration);
}
[DebuggerDisplayAttribute("{DisplayString,nq}")]
[DebuggerTypeProxyAttribute("System.Threading.TimerQueueTimer/TimerDebuggerTypeProxy")]
internal class System.Threading.TimerQueueTimer : object {
    private TimerQueue _associatedTimerQueue;
    internal TimerQueueTimer _next;
    internal TimerQueueTimer _prev;
    internal bool _short;
    internal long _startTicks;
    internal UInt32 _dueTime;
    internal UInt32 _period;
    private TimerCallback _timerCallback;
    private object _state;
    private ExecutionContext _executionContext;
    private int _callbacksRunning;
    private bool _canceled;
    internal bool _everQueued;
    private object _notifyWhenNoCallbacksRunning;
    private static ContextCallback s_callCallbackInContext;
    internal string DisplayString { get; }
    internal TimerQueueTimer(TimerCallback timerCallback, object state, TimeSpan dueTime, TimeSpan period, bool flowExecutionContext);
    internal TimerQueueTimer(TimerCallback timerCallback, object state, UInt32 dueTime, UInt32 period, bool flowExecutionContext);
    private static TimerQueueTimer();
    private static UInt32 GetMilliseconds(TimeSpan time, string parameter);
    internal string get_DisplayString();
    public sealed virtual bool Change(TimeSpan dueTime, TimeSpan period);
    internal bool Change(UInt32 dueTime, UInt32 period);
    public sealed virtual void Dispose();
    public bool Dispose(WaitHandle toSignal);
    public sealed virtual ValueTask DisposeAsync();
    private sealed virtual override void System.Threading.IThreadPoolWorkItem.Execute();
    internal void Fire(bool isThreadPool);
    internal void SignalNoCallbacksRunning();
    internal void CallCallback(bool isThreadPool);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Threading.Volatile : object {
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static bool Read(Boolean& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Boolean& location, bool value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static byte Read(Byte& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Byte& location, byte value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static double Read(Double& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Double& location, double value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static short Read(Int16& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Int16& location, short value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static int Read(Int32& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Int32& location, int value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static long Read(Int64& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Int64& location, long value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static IntPtr Read(IntPtr& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(IntPtr& location, IntPtr value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static sbyte Read(SByte& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(SByte& location, sbyte value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static float Read(Single& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(Single& location, float value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static ushort Read(UInt16& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(UInt16& location, ushort value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static UInt32 Read(UInt32& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(UInt32& location, UInt32 value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static ulong Read(UInt64& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(UInt64& location, ulong value);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static UIntPtr Read(UIntPtr& location);
    [CLSCompliantAttribute("False")]
[IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(UIntPtr& location, UIntPtr value);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static T Read(T& location);
    [IntrinsicAttribute]
[NonVersionableAttribute]
public static void Write(T& location, T value);
}
public class System.Threading.WaitCallback : MulticastDelegate {
    public WaitCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    protected static IntPtr InvalidHandle;
    private SafeWaitHandle _waitHandle;
    [ThreadStaticAttribute]
private static SafeWaitHandle[] t_safeWaitHandlesForRent;
    public static int WaitTimeout;
    [ObsoleteAttribute("WaitHandle.Handle has been deprecated. Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    private static WaitHandle();
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    internal static int ToTimeoutMilliseconds(TimeSpan timeout);
    public virtual void Close();
    protected virtual void Dispose(bool explicitDisposing);
    public sealed virtual void Dispose();
    public virtual bool WaitOne(int millisecondsTimeout);
    private bool WaitOneNoCheck(int millisecondsTimeout);
    private static SafeWaitHandle[] RentSafeWaitHandleArray(int capacity);
    private static void ReturnSafeWaitHandleArray(SafeWaitHandle[] safeWaitHandles);
    private static void ObtainSafeWaitHandles(ReadOnlySpan`1<WaitHandle> waitHandles, Span`1<SafeWaitHandle> safeWaitHandles, Span`1<IntPtr> unsafeWaitHandles);
    private static int WaitMultiple(WaitHandle[] waitHandles, bool waitAll, int millisecondsTimeout);
    private static int WaitMultiple(ReadOnlySpan`1<WaitHandle> waitHandles, bool waitAll, int millisecondsTimeout);
    private static int WaitAnyMultiple(ReadOnlySpan`1<SafeWaitHandle> safeWaitHandles, int millisecondsTimeout);
    private static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout);
    internal static void ThrowInvalidHandleException();
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    internal static int WaitAny(ReadOnlySpan`1<SafeWaitHandle> safeWaitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    private static int WaitOneCore(IntPtr handle, int millisecondsTimeout);
    internal static int WaitMultipleIgnoringSyncContext(Span`1<IntPtr> handles, bool waitAll, int millisecondsTimeout);
    private static int SignalAndWaitCore(IntPtr handleToSignal, IntPtr handleToWaitOn, int millisecondsTimeout);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Threading.WaitHandleCannotBeOpenedException : ApplicationException {
    public WaitHandleCannotBeOpenedException(string message);
    public WaitHandleCannotBeOpenedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected WaitHandleCannotBeOpenedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.WaitHandleExtensions : object {
    [ExtensionAttribute]
public static SafeWaitHandle GetSafeWaitHandle(WaitHandle waitHandle);
    [ExtensionAttribute]
public static void SetSafeWaitHandle(WaitHandle waitHandle, SafeWaitHandle value);
}
public class System.Threading.WaitOrTimerCallback : MulticastDelegate {
    public WaitOrTimerCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(object state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Threading.WaitSubsystem : object {
    private static LowLevelLock s_lock;
    private static WaitSubsystem();
    private static SafeWaitHandle NewHandle(WaitableObject waitableObject);
    public static SafeWaitHandle NewEvent(bool initiallySignaled, EventResetMode resetMode);
    public static SafeWaitHandle NewSemaphore(int initialSignalCount, int maximumSignalCount);
    public static SafeWaitHandle NewMutex(bool initiallyOwned);
    public static SafeWaitHandle CreateNamedMutex(bool initiallyOwned, string name, Boolean& createdNew);
    public static OpenExistingResult OpenNamedMutex(string name, SafeWaitHandle& result);
    public static void DeleteHandle(IntPtr handle);
    public static void SetEvent(IntPtr handle);
    public static void SetEvent(WaitableObject waitableObject);
    public static void ResetEvent(IntPtr handle);
    public static void ResetEvent(WaitableObject waitableObject);
    public static int ReleaseSemaphore(IntPtr handle, int count);
    public static int ReleaseSemaphore(WaitableObject waitableObject, int count);
    public static void ReleaseMutex(IntPtr handle);
    public static void ReleaseMutex(WaitableObject waitableObject);
    public static int Wait(IntPtr handle, int timeoutMilliseconds, bool interruptible);
    public static int Wait(WaitableObject waitableObject, int timeoutMilliseconds, bool interruptible, bool prioritize);
    public static int Wait(Span`1<IntPtr> waitHandles, bool waitForAll, int timeoutMilliseconds);
    public static int SignalAndWait(IntPtr handleToSignal, IntPtr handleToWaitOn, int timeoutMilliseconds);
    public static int SignalAndWait(WaitableObject waitableObjectToSignal, WaitableObject waitableObjectToWaitOn, int timeoutMilliseconds, bool interruptible, bool prioritize);
    public static void Sleep(int timeoutMilliseconds, bool interruptible);
    public static void Interrupt(Thread thread);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
[InlineArrayAttribute("3")]
internal class System.ThreeObjects : ValueType {
    internal object Arg0;
    public ThreeObjects(object arg0, object arg1, object arg2);
}
[StackTraceHiddenAttribute]
internal static class System.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowAccessViolationException();
    [DoesNotReturnAttribute]
internal static void ThrowArrayTypeMismatchException();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidTypeWithPointersNotSupported(Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_DestinationTooShort();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_OverlapAlignmentMismatch();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_CannotExtractScalar(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_TupleIncorrectType(object obj);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexMustBeLessException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexMustBeLessOrEqualException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_BadComparer(object comparer);
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowValueArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_IndexMustBeLessOrEqual();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_IndexMustBeLess();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_Year();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_Month(int month);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_DayNumber(int dayNumber);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_BadYearMonthDay();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_BadHourMinuteSecond();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_TimeSpanTooLong();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_Range(string parameterName, T value, T minInclusive, T maxInclusive);
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException();
    [DoesNotReturnAttribute]
internal static void ThrowOverflowException_TimeSpanTooLong();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Arg_CannotBeNaN();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource, ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_HandleNotSync(string paramName);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_HandleNotAsync(string paramName);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowEndOfFileException();
    internal static Exception CreateEndOfFileException();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowSerializationException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowRankException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException_UnseekableStream();
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException_UnreadableStream();
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException_UnwritableStream();
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException(object instance);
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException(Type type);
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException_StreamClosed(string objectName);
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException_FileClosed();
    [DoesNotReturnAttribute]
internal static void ThrowObjectDisposedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException();
    [DoesNotReturnAttribute]
internal static void ThrowAggregateException(List`1<Exception> exceptions);
    [DoesNotReturnAttribute]
internal static void ThrowOutOfMemoryException();
    [DoesNotReturnAttribute]
internal static void ThrowOutOfMemoryException_StringTooLong();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_IncompatibleArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_InvalidHandle(string paramName);
    [DoesNotReturnAttribute]
internal static void ThrowUnexpectedStateForKnownCallback(object state);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumNotStarted();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumEnded();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_EnumCurrent(int index);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_NoValue();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_HandleIsNotInitialized();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_HandleIsNotPinned();
    [DoesNotReturnAttribute]
internal static void ThrowArraySegmentCtorValidationFailedExceptions(Array array, int offset, int count);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidUtf8();
    [DoesNotReturnAttribute]
internal static void ThrowFormatException_BadFormatSpecifier();
    [DoesNotReturnAttribute]
internal static void ThrowFormatException_NeedSingleChar();
    [DoesNotReturnAttribute]
internal static void ThrowFormatException_BadBoolean(ReadOnlySpan`1<char> value);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_PrecisionTooLarge();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_SymbolDoesNotFit();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException_NeedNonNegNum(string paramName);
    [DoesNotReturnAttribute]
internal static void ArgumentOutOfRangeException_Enum_Value();
    [DoesNotReturnAttribute]
internal static void ThrowFormatInvalidString();
    [DoesNotReturnAttribute]
internal static void ThrowFormatInvalidString(int offset, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowFormatIndexOutOfRange();
    internal static AmbiguousMatchException GetAmbiguousMatchException(MemberInfo memberInfo);
    internal static AmbiguousMatchException GetAmbiguousMatchException(Attribute attribute);
    private static Exception GetArraySegmentCtorValidationFailedException(Array array, int offset, int count);
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    private static ArgumentException GetArgumentException(ExceptionResource resource, ExceptionArgument argument);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, int paramNumber, ExceptionResource resource);
    private static InvalidOperationException GetInvalidOperationException_EnumCurrent(int index);
    internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    internal static void ThrowForUnsupportedNumericsVectorBaseType();
    internal static void ThrowForUnsupportedIntrinsicsVector64BaseType();
    internal static void ThrowForUnsupportedIntrinsicsVector128BaseType();
    internal static void ThrowForUnsupportedIntrinsicsVector256BaseType();
    internal static void ThrowForUnsupportedIntrinsicsVector512BaseType();
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
[IsReadOnlyAttribute]
public class System.TimeOnly : ValueType {
    private long _ticks;
    public static TimeOnly MinValue { get; }
    public static TimeOnly MaxValue { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int Microsecond { get; }
    public int Nanosecond { get; }
    public long Ticks { get; }
    public TimeOnly(int hour, int minute);
    public TimeOnly(int hour, int minute, int second);
    public TimeOnly(int hour, int minute, int second, int millisecond);
    public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond);
    public TimeOnly(long ticks);
    internal TimeOnly(ulong ticks);
    public static TimeOnly get_MinValue();
    public static TimeOnly get_MaxValue();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_Microsecond();
    public int get_Nanosecond();
    public long get_Ticks();
    private TimeOnly AddTicks(long ticks);
    private TimeOnly AddTicks(long ticks, Int32& wrappedDays);
    public TimeOnly Add(TimeSpan value);
    public TimeOnly Add(TimeSpan value, Int32& wrappedDays);
    public TimeOnly AddHours(double value);
    public TimeOnly AddHours(double value, Int32& wrappedDays);
    public TimeOnly AddMinutes(double value);
    public TimeOnly AddMinutes(double value, Int32& wrappedDays);
    public bool IsBetween(TimeOnly start, TimeOnly end);
    public static bool op_Equality(TimeOnly left, TimeOnly right);
    public static bool op_Inequality(TimeOnly left, TimeOnly right);
    public static bool op_GreaterThan(TimeOnly left, TimeOnly right);
    public static bool op_GreaterThanOrEqual(TimeOnly left, TimeOnly right);
    public static bool op_LessThan(TimeOnly left, TimeOnly right);
    public static bool op_LessThanOrEqual(TimeOnly left, TimeOnly right);
    public static TimeSpan op_Subtraction(TimeOnly t1, TimeOnly t2);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& hour, Int32& minute);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& hour, Int32& minute, Int32& second);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& hour, Int32& minute, Int32& second, Int32& millisecond);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Int32& hour, Int32& minute, Int32& second, Int32& millisecond, Int32& microsecond);
    public static TimeOnly FromTimeSpan(TimeSpan timeSpan);
    public static TimeOnly FromDateTime(DateTime dateTime);
    public TimeSpan ToTimeSpan();
    internal DateTime ToDateTime();
    public sealed virtual int CompareTo(TimeOnly value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(TimeOnly value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static TimeOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style);
    public static TimeOnly ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static TimeOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats);
    public static TimeOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static TimeOnly Parse(string s);
    [NullableContextAttribute("1")]
public static TimeOnly Parse(string s, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, string format);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, String[] formats);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeOnly& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    private static ParseFailureKind TryParseInternal(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, TimeOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    private static ParseFailureKind TryParseExactInternal(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    private static ParseFailureKind TryParseExactInternal(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    private static void ThrowOnError(ParseFailureKind result, ReadOnlySpan`1<char> s);
    [NullableContextAttribute("1")]
public string ToLongTimeString();
    [NullableContextAttribute("1")]
public string ToShortTimeString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private bool TryFormatCore(Span`1<TChar> destination, Int32& written, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override TimeOnly Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, TimeOnly& result);
    public static override TimeOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, TimeOnly& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeoutException : SystemException {
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TimeoutException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.TimeProvider : object {
    [CompilerGeneratedAttribute]
private static TimeProvider <System>k__BackingField;
    private static long s_minDateTicks;
    private static long s_maxDateTicks;
    public static TimeProvider System { get; }
    public TimeZoneInfo LocalTimeZone { get; }
    public long TimestampFrequency { get; }
    private static TimeProvider();
    [CompilerGeneratedAttribute]
public static TimeProvider get_System();
    public virtual DateTimeOffset GetUtcNow();
    public DateTimeOffset GetLocalNow();
    public virtual TimeZoneInfo get_LocalTimeZone();
    public virtual long get_TimestampFrequency();
    public virtual long GetTimestamp();
    public TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp);
    public TimeSpan GetElapsedTime(long startingTimestamp);
    public virtual ITimer CreateTimer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
}
[IsReadOnlyAttribute]
public class System.TimeSpan : ValueType {
    public static long NanosecondsPerTick;
    public static long TicksPerMicrosecond;
    public static long TicksPerMillisecond;
    public static long TicksPerSecond;
    public static long TicksPerMinute;
    public static long TicksPerHour;
    public static long TicksPerDay;
    public static TimeSpan Zero;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    internal long _ticks;
    public long Ticks { get; }
    public int Days { get; }
    public int Hours { get; }
    public int Milliseconds { get; }
    public int Microseconds { get; }
    public int Nanoseconds { get; }
    public int Minutes { get; }
    public int Seconds { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMilliseconds { get; }
    public double TotalMicroseconds { get; }
    public double TotalNanoseconds { get; }
    public double TotalMinutes { get; }
    public double TotalSeconds { get; }
    public TimeSpan(long ticks);
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds);
    private static TimeSpan();
    public long get_Ticks();
    public int get_Days();
    public int get_Hours();
    public int get_Milliseconds();
    public int get_Microseconds();
    public int get_Nanoseconds();
    public int get_Minutes();
    public int get_Seconds();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMilliseconds();
    public double get_TotalMicroseconds();
    public double get_TotalNanoseconds();
    public double get_TotalMinutes();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public static TimeSpan FromDays(double value);
    public TimeSpan Duration();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public virtual int GetHashCode();
    public static TimeSpan FromHours(double value);
    private static TimeSpan Interval(double value, double scale);
    private static TimeSpan IntervalFromDoubleTicks(double ticks);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMicroseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public TimeSpan Negate();
    public static TimeSpan FromSeconds(double value);
    public TimeSpan Subtract(TimeSpan ts);
    public TimeSpan Multiply(double factor);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public static TimeSpan FromTicks(long value);
    internal static long TimeToTicks(int hour, int minute, int second);
    private static void ValidateStyles(TimeSpanStyles style, string parameterName);
    [NullableContextAttribute("1")]
public static TimeSpan Parse(string s);
    [NullableContextAttribute("1")]
public static override TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static override TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    public static override bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("System.TimeZone has been deprecated. Investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    private static TimeZone modreq(System.Runtime.CompilerServices.IsVolatile) currentTimeZone;
    private static object s_InternalSyncObject;
    private static object InternalSyncObject { get; }
    public static TimeZone CurrentTimeZone { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    private static object get_InternalSyncObject();
    public static TimeZone get_CurrentTimeZone();
    internal static void ResetTimeZone();
    public abstract virtual string get_StandardName();
    public abstract virtual string get_DaylightName();
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
    public virtual DateTime ToLocalTime(DateTime time);
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    internal static TimeSpan CalculateUtcOffset(DateTime time, DaylightTime daylightTimes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneInfo : object {
    private string _id;
    private string _displayName;
    private string _standardDisplayName;
    private string _daylightDisplayName;
    private TimeSpan _baseUtcOffset;
    private bool _supportsDaylightSavingTime;
    private AdjustmentRule[] _adjustmentRules;
    private List`1<TimeZoneInfo> _equivalentZones;
    private static TimeZoneInfo s_utcTimeZone;
    private static CachedData s_cachedData;
    private static DateTime s_maxDateOnly;
    private static DateTime s_minDateOnly;
    [CompilerGeneratedAttribute]
private bool <HasIanaId>k__BackingField;
    private static TimeSpan MaxOffset;
    private static TimeSpan MinOffset;
    private string _standardAbbrevName;
    private string _daylightAbbrevName;
    private static TransitionTime s_daylightRuleMarker;
    private static AndroidTzData s_tzData;
    private static String[] s_ZonesThatUseLocationName;
    private static CultureInfo _uiCulture;
    public string Id { get; }
    public bool HasIanaId { get; }
    public string DisplayName { get; }
    public string StandardName { get; }
    public string DaylightName { get; }
    public TimeSpan BaseUtcOffset { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Local { get; }
    public static TimeZoneInfo Utc { get; }
    private static AndroidTzData AndroidTzDataInstance { get; }
    private static CultureInfo UICulture { get; }
    private TimeZoneInfo(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime, bool hasIanaId);
    private TimeZoneInfo(SerializationInfo info, StreamingContext context);
    private TimeZoneInfo(Byte[] data, string id, bool dstDisabled);
    private static TimeZoneInfo();
    public string get_Id();
    [CompilerGeneratedAttribute]
public bool get_HasIanaId();
    public string get_DisplayName();
    public string get_StandardName();
    public string get_DaylightName();
    public TimeSpan get_BaseUtcOffset();
    public bool get_SupportsDaylightSavingTime();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    private AdjustmentRule GetAdjustmentRuleForAmbiguousOffsets(DateTime adjustedTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetPreviousAdjustmentRule(AdjustmentRule rule, Nullable`1<int> ruleIndex);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public TimeSpan GetUtcOffset(DateTime dateTime);
    internal static TimeSpan GetLocalUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    internal TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags);
    private TimeSpan GetUtcOffset(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsAmbiguousTime(DateTime dateTime);
    internal bool IsAmbiguousTime(DateTime dateTime, TimeZoneInfoOptions flags);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    internal bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags);
    private bool IsDaylightSavingTime(DateTime dateTime, TimeZoneInfoOptions flags, CachedData cachedData);
    public bool IsInvalidTime(DateTime dateTime);
    public static void ClearCachedData();
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    public static bool TryFindSystemTimeZoneById(string id, TimeZoneInfo& timeZoneInfo);
    private static TimeZoneInfoResult TryFindSystemTimeZoneById(string id, TimeZoneInfo& timeZone, Exception& e);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    internal static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags);
    private static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone, TimeZoneInfoOptions flags, CachedData cachedData);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    internal static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfoOptions flags);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TimeZoneInfo other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static TimeZoneInfo FromSerializedString(string source);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones(bool skipSorting);
    public bool HasSameRules(TimeZoneInfo other);
    public static TimeZoneInfo get_Local();
    public string ToSerializedString();
    public virtual string ToString();
    public static TimeZoneInfo get_Utc();
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    [NullableContextAttribute("2")]
public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    [NullableContextAttribute("2")]
public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    public static bool TryConvertIanaIdToWindowsId(string ianaId, String& windowsId);
    public static bool TryConvertWindowsIdToIanaId(string windowsId, String& ianaId);
    [NullableContextAttribute("2")]
public static bool TryConvertWindowsIdToIanaId(string windowsId, string region, String& ianaId);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, Nullable`1& ruleIndex);
    private AdjustmentRule GetAdjustmentRuleForTime(DateTime dateTime, bool dateTimeisUtc, Nullable`1& ruleIndex);
    private int CompareAdjustmentRuleToDateTime(AdjustmentRule rule, AdjustmentRule previousRule, DateTime dateTime, DateTime dateOnly, bool dateTimeisUtc);
    private DateTime ConvertToUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta);
    private DateTime ConvertToFromUtc(DateTime dateTime, TimeSpan daylightDelta, TimeSpan baseUtcOffsetDelta, bool convertToUtc);
    private static DateTime ConvertUtcToTimeZone(long ticks, TimeZoneInfo destinationTimeZone, Boolean& isAmbiguousLocalDst);
    private DaylightTimeStruct GetDaylightTime(int year, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static bool GetIsDaylightSavings(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private TimeSpan GetDaylightSavingsStartOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule, Nullable`1<int> ruleIndex);
    private static TimeSpan GetDaylightSavingsEndOffsetFromUtc(TimeSpan baseUtcOffset, AdjustmentRule rule);
    private static bool GetIsDaylightSavingsFromUtc(DateTime time, int year, TimeSpan utc, AdjustmentRule rule, Nullable`1<int> ruleIndex, Boolean& isAmbiguousLocalDst, TimeZoneInfo zone);
    private static bool TryGetEndOfDstIfYearStartWithDst(int nextYear, TimeSpan utc, TimeZoneInfo zone, DateTime& dstEnd);
    private static bool TryGetStartOfDstIfYearEndWithDst(int previousYear, TimeSpan utc, TimeZoneInfo zone, DateTime& dstStart);
    private static bool CheckIsDst(DateTime startTime, DateTime time, DateTime endTime, bool ignoreYearAdjustment, AdjustmentRule rule);
    private static bool GetIsAmbiguousTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static bool GetIsInvalidTime(DateTime time, AdjustmentRule rule, DaylightTimeStruct daylightTime);
    private static TimeSpan GetUtcOffset(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone);
    private static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings);
    internal static TimeSpan GetUtcOffsetFromUtc(DateTime time, TimeZoneInfo zone, Boolean& isDaylightSavings, Boolean& isAmbiguousLocalDst);
    internal static DateTime TransitionTimeToDateTime(int year, TransitionTime transitionTime);
    private static TimeZoneInfoResult TryGetTimeZone(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneUsingId(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData, bool alwaysFallbackToLocalMachine);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, bool dstDisabled, TimeZoneInfo& value, Exception& e, CachedData cachedData);
    private static void ValidateTimeZoneInfo(string id, TimeSpan baseUtcOffset, AdjustmentRule[] adjustmentRules, Boolean& adjustmentRulesSupportDst);
    internal static bool UtcOffsetOutOfRange(TimeSpan offset);
    private static TimeSpan GetUtcOffset(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static bool IsValidAdjustmentRuleOffset(TimeSpan baseUtcOffset, AdjustmentRule adjustmentRule);
    private static TimeZoneInfo CreateUtcTimeZone();
    private static bool TryConvertIanaIdToWindowsId(string ianaId, bool allocate, String& windowsId);
    private static bool TryConvertWindowsIdToIanaId(string windowsId, string region, bool allocate, String& ianaId);
    private static bool IsUtcAlias(string id);
    private static DateTime GetTimeOnlyInMillisecondsPrecision(DateTime input);
    public AdjustmentRule[] GetAdjustmentRules();
    private string PopulateDisplayName();
    private string PopulateStandardDisplayName();
    private string PopulateDaylightDisplayName();
    private static void PopulateAllSystemTimeZones(CachedData cachedData);
    private static TimeZoneInfo GetLocalTimeZone(CachedData cachedData);
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachine(string id, TimeZoneInfo& value, Exception& e);
    private static TimeZoneInfo GetTimeZoneFromTzData(Byte[] rawData, string id);
    private static TimeZoneInfoResult TryGetTimeZone(string id, TimeZoneInfo& timeZone, Exception& e, CachedData cachedData);
    internal static TimeSpan GetDateTimeNowUtcOffsetFromUtc(DateTime time, Boolean& isAmbiguousLocalDst);
    private static void TZif_GenerateAdjustmentRules(AdjustmentRule[]& rules, TimeSpan baseUtcOffset, DateTime[] dts, Byte[] typeOfLocalTime, TZifType[] transitionType, string futureTransitionsPosixFormat);
    private static void TZif_GenerateAdjustmentRule(Int32& index, TimeSpan timeZoneBaseUtcOffset, List`1<AdjustmentRule> rulesList, DateTime[] dts, Byte[] typeOfLocalTime, TZifType[] transitionTypes, string futureTransitionsPosixFormat);
    private static TimeSpan TZif_CalculateTransitionOffsetFromBase(TimeSpan transitionOffset, TimeSpan timeZoneBaseUtcOffset);
    private static TZifType TZif_GetEarlyDateTransitionType(TZifType[] transitionTypes);
    private static AdjustmentRule TZif_CreateAdjustmentRuleForPosixFormat(string posixFormat, DateTime startTransitionDate, TimeSpan timeZoneBaseUtcOffset);
    private static Nullable`1<TimeSpan> TZif_ParseOffsetString(ReadOnlySpan`1<char> offset);
    private static DateTime ParseTimeOfDay(ReadOnlySpan`1<char> time);
    private static Nullable`1<TransitionTime> TZif_CreateTransitionTimeFromPosixRule(ReadOnlySpan`1<char> date, ReadOnlySpan`1<char> time);
    private static void TZif_ParseJulianDay(ReadOnlySpan`1<char> date, Int32& month, Int32& day);
    private static bool TZif_ParseMDateRule(ReadOnlySpan`1<char> dateRule, Int32& month, Int32& week, DayOfWeek& dayOfWeek);
    private static bool TZif_ParsePosixFormat(ReadOnlySpan`1<char> posixFormat, ReadOnlySpan`1& standardName, ReadOnlySpan`1& standardOffset, ReadOnlySpan`1& daylightSavingsName, ReadOnlySpan`1& daylightSavingsOffset, ReadOnlySpan`1& start, ReadOnlySpan`1& startTime, ReadOnlySpan`1& end, ReadOnlySpan`1& endTime);
    private static ReadOnlySpan`1<char> TZif_ParsePosixName(ReadOnlySpan`1<char> posixFormat, Int32& index);
    private static ReadOnlySpan`1<char> TZif_ParsePosixOffset(ReadOnlySpan`1<char> posixFormat, Int32& index);
    private static void TZif_ParsePosixDateTime(ReadOnlySpan`1<char> posixFormat, Int32& index, ReadOnlySpan`1& date, ReadOnlySpan`1& time);
    private static ReadOnlySpan`1<char> TZif_ParsePosixDate(ReadOnlySpan`1<char> posixFormat, Int32& index);
    private static ReadOnlySpan`1<char> TZif_ParsePosixTime(ReadOnlySpan`1<char> posixFormat, Int32& index);
    private static ReadOnlySpan`1<char> TZif_ParsePosixString(ReadOnlySpan`1<char> posixFormat, Int32& index, Func`2<char, bool> breakCondition);
    private static string TZif_GetZoneAbbreviation(string zoneAbbreviations, int index);
    private static short TZif_ToInt16(ReadOnlySpan`1<byte> value);
    private static int TZif_ToInt32(Byte[] value, int startIndex);
    private static int TZif_ToInt32(ReadOnlySpan`1<byte> value);
    private static long TZif_ToInt64(Byte[] value, int startIndex);
    private static long TZif_ToUnixTime(Byte[] value, int startIndex, TZVersion version);
    private static DateTime TZif_UnixTimeToDateTime(long unixTime);
    private static void TZif_ParseRaw(Byte[] data, DateTime[]& dts, Byte[]& typeOfLocalTime, TZifType[]& transitionType, String& zoneAbbreviations, String& futureTransitionsPosixFormat);
    private static void NormalizeAdjustmentRuleOffset(TimeSpan baseUtcOffset, AdjustmentRule& adjustmentRule);
    private static bool StringArrayContains(string value, String[] source, StringComparison comparison);
    private static AndroidTzData get_AndroidTzDataInstance();
    private static int ParseGMTNumericZone(string name);
    private static TimeZoneInfo GetTimeZone(string id, string name);
    private static TimeZoneInfo GetLocalTimeZoneCore();
    private static TimeZoneInfoResult TryGetTimeZoneFromLocalMachineCore(string id, TimeZoneInfo& value, Exception& e);
    private static String[] GetTimeZoneIds();
    private static string GetUtcStandardDisplayName();
    private static string GetUtcFullDisplayName(string timeZoneId, string standardDisplayName);
    private static CultureInfo get_UICulture();
    private static void GetStandardDisplayName(string timeZoneId, String& displayName);
    private static void GetDaylightDisplayName(string timeZoneId, String& displayName);
    private static void GetDisplayName(string timeZoneId, TimeZoneDisplayNameType nameType, string uiCulture, String& displayName);
    private static void GetFullValueForDisplayNameField(string timeZoneId, TimeSpan baseUtcOffset, String& displayName);
    private static string GetExemplarCityName(string timeZoneId, string uiCultureName);
    private static string GetAlternativeId(string id, Boolean& idIsIana);
}
[FlagsAttribute]
internal enum System.TimeZoneInfoOptions : Enum {
    public int value__;
    public static TimeZoneInfoOptions None;
    public static TimeZoneInfoOptions NoThrowOnInvalidTime;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("System.Core, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TimeZoneNotFoundException : Exception {
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
}
internal enum System.TokenType : Enum {
    public int value__;
    public static TokenType NumberToken;
    public static TokenType YearNumberToken;
    public static TokenType Am;
    public static TokenType Pm;
    public static TokenType MonthToken;
    public static TokenType EndOfString;
    public static TokenType DayOfWeekToken;
    public static TokenType TimeZoneToken;
    public static TokenType EraToken;
    public static TokenType DateWordToken;
    public static TokenType UnknownToken;
    public static TokenType HebrewNumber;
    public static TokenType JapaneseEraToken;
    public static TokenType TEraToken;
    public static TokenType IgnorableSymbol;
    public static TokenType SEP_Unk;
    public static TokenType SEP_End;
    public static TokenType SEP_Space;
    public static TokenType SEP_Am;
    public static TokenType SEP_Pm;
    public static TokenType SEP_Date;
    public static TokenType SEP_Time;
    public static TokenType SEP_YearSuff;
    public static TokenType SEP_MonthSuff;
    public static TokenType SEP_DaySuff;
    public static TokenType SEP_HourSuff;
    public static TokenType SEP_MinuteSuff;
    public static TokenType SEP_SecondSuff;
    public static TokenType SEP_LocalTimeMark;
    public static TokenType SEP_DateOrOffset;
    public static TokenType RegularTokenMask;
    public static TokenType SeparatorTokenMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`1 : object {
    private T1 m_Item1;
    [NullableAttribute("1")]
public T1 Item1 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public Tuple`1(T1 item1);
    [NullableContextAttribute("1")]
public T1 get_Item1();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`2 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    [NullableAttribute("1")]
public T1 Item1 { get; }
    [NullableAttribute("1")]
public T2 Item2 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public Tuple`2(T1 item1, T2 item2);
    [NullableContextAttribute("1")]
public T1 get_Item1();
    [NullableContextAttribute("1")]
public T2 get_Item2();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`3 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`4 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`5 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`6 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`7 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Tuple`8 : object {
    private T1 m_Item1;
    private T2 m_Item2;
    private T3 m_Item3;
    private T4 m_Item4;
    private T5 m_Item5;
    private T6 m_Item6;
    private T7 m_Item7;
    private TRest m_Rest;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private bool Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private int CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.ITupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.ITupleInternal.ToString(StringBuilder sb);
    private string ToString(StringBuilder sb);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    private static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLong(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private static Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> CreateLongRef(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
}
internal class System.TupleSlim`2 : object {
    public T1 Item1;
    public T2 Item2;
    public TupleSlim`2(T1 item1, T2 item2);
}
internal class System.TupleSlim`3 : object {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public TupleSlim`3(T1 item1, T2 item2, T3 item3);
}
internal class System.TupleSlim`4 : object {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public TupleSlim`4(T1 item1, T2 item2, T3 item3, T4 item4);
}
[InlineArrayAttribute("2")]
internal class System.TwoObjects : ValueType {
    internal object Arg0;
    public TwoObjects(object arg0, object arg1);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Type : MemberInfo {
    internal RuntimeTypeHandle _impl;
    internal LoaderAllocator m_keepalive;
    private static Binder modreq(System.Runtime.CompilerServices.IsVolatile) s_defaultBinder;
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static object Missing;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public bool IsInterface { get; }
    internal bool IsUserType { get; }
    public MemberTypes MemberType { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public bool IsNested { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    [NullableAttribute("2")]
public MethodBase DeclaringMethod { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsArray { get; }
    public bool IsByRef { get; }
    public bool IsPointer { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsByRefLike { get; }
    public bool IsFunctionPointer { get; }
    public bool IsUnmanagedFunctionPointer { get; }
    public bool HasElementType { get; }
    public Type[] GenericTypeArguments { get; }
    public int GenericParameterPosition { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public TypeAttributes Attributes { get; }
    public bool IsAbstract { get; }
    public bool IsImport { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsClass { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPublic { get; }
    public bool IsAutoLayout { get; }
    public bool IsExplicitLayout { get; }
    public bool IsLayoutSequential { get; }
    public bool IsAnsiClass { get; }
    public bool IsAutoClass { get; }
    public bool IsUnicodeClass { get; }
    public bool IsCOMObject { get; }
    public bool IsContextful { get; }
    public bool IsEnum { get; }
    public bool IsMarshalByRef { get; }
    public bool IsPrimitive { get; }
    public bool IsValueType { get; }
    public bool IsSignatureType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    [NullableAttribute("2")]
public StructLayoutAttribute StructLayoutAttribute { get; }
    [NullableAttribute("2")]
public ConstructorInfo TypeInitializer { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Guid GUID { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public static Binder DefaultBinder { get; }
    [ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public bool IsSerializable { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsVisible { get; }
    private static Type();
    internal IntPtr GetUnderlyingNativeHandle();
    internal virtual bool IsTypeBuilder();
    public bool get_IsInterface();
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, bool throwOnError);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
private static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase, StackCrawlMark& stackMark);
    [NullableContextAttribute("2")]
public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    internal virtual Type InternalResolve();
    internal virtual Type RuntimeResolve();
    internal virtual bool get_IsUserType();
    internal virtual MethodInfo GetMethod(MethodInfo fromNoninstanciated);
    internal virtual ConstructorInfo GetConstructor(ConstructorInfo fromNoninstanciated);
    internal virtual FieldInfo GetField(FieldInfo fromNoninstanciated);
    private static Type internal_from_handle(IntPtr handle);
    public virtual MemberTypes get_MemberType();
    public Type GetType();
    [NullableContextAttribute("2")]
public abstract virtual string get_Namespace();
    [NullableContextAttribute("2")]
public abstract virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public abstract virtual string get_FullName();
    public abstract virtual Assembly get_Assembly();
    public abstract virtual Module get_Module();
    public bool get_IsNested();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    [NullableContextAttribute("2")]
public virtual MethodBase get_DeclaringMethod();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    public abstract virtual Type get_UnderlyingSystemType();
    public virtual bool get_IsTypeDefinition();
    public bool get_IsArray();
    protected abstract virtual bool IsArrayImpl();
    public bool get_IsByRef();
    protected abstract virtual bool IsByRefImpl();
    public bool get_IsPointer();
    protected abstract virtual bool IsPointerImpl();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsVariableBoundArray();
    [IntrinsicAttribute]
public virtual bool get_IsByRefLike();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsUnmanagedFunctionPointer();
    public bool get_HasElementType();
    protected abstract virtual bool HasElementTypeImpl();
    [NullableContextAttribute("2")]
public abstract virtual Type GetElementType();
    public virtual int GetArrayRank();
    public virtual Type GetGenericTypeDefinition();
    public virtual Type[] get_GenericTypeArguments();
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual int get_GenericParameterPosition();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Type[] GetGenericParameterConstraints();
    public TypeAttributes get_Attributes();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    public bool get_IsAbstract();
    public bool get_IsImport();
    public bool get_IsSealed();
    public bool get_IsSpecialName();
    public bool get_IsClass();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPublic();
    public bool get_IsAutoLayout();
    public bool get_IsExplicitLayout();
    public bool get_IsLayoutSequential();
    public bool get_IsAnsiClass();
    public bool get_IsAutoClass();
    public bool get_IsUnicodeClass();
    public bool get_IsCOMObject();
    protected abstract virtual bool IsCOMObjectImpl();
    public bool get_IsContextful();
    protected virtual bool IsContextfulImpl();
    [IntrinsicAttribute]
public virtual bool get_IsEnum();
    public bool get_IsMarshalByRef();
    protected virtual bool IsMarshalByRefImpl();
    public bool get_IsPrimitive();
    protected abstract virtual bool IsPrimitiveImpl();
    [IntrinsicAttribute]
public bool get_IsValueType();
    protected virtual bool IsValueTypeImpl();
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public bool IsAssignableTo(Type targetType);
    public virtual bool get_IsSignatureType();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    [NullableContextAttribute("2")]
public virtual StructLayoutAttribute get_StructLayoutAttribute();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo get_TypeInitializer();
    [DynamicallyAccessedMembersAttribute("3")]
public ConstructorInfo GetConstructor(Type[] types);
    [DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Type[] types);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("3")]
public ConstructorInfo[] GetConstructors();
    [DynamicallyAccessedMembersAttribute("7")]
public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public EventInfo GetEvent(string name);
    [DynamicallyAccessedMembersAttribute("6144")]
public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("6144")]
public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("32")]
public FieldInfo GetField(string name);
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("32")]
public FieldInfo[] GetFields();
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetFunctionPointerCallingConventions();
    public virtual Type GetFunctionPointerReturnType();
    public virtual Type[] GetFunctionPointerParameterTypes();
    [DynamicallyAccessedMembersAttribute("2731")]
public MemberInfo[] GetMember(string name);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2731")]
public MemberInfo[] GetMembers();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
public virtual MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member);
    private protected static ArgumentException CreateGetMemberWithSameMetadataDefinitionAsNotFoundException(MemberInfo member);
    [DynamicallyAccessedMembersAttribute("8191")]
public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name);
    [DynamicallyAccessedMembersAttribute("24")]
public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Type[] types);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, Type[] types);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo[] GetMethods();
    [DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("128")]
public Type GetNestedType(string name);
    [DynamicallyAccessedMembersAttribute("384")]
public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("128")]
public Type[] GetNestedTypes();
    [DynamicallyAccessedMembersAttribute("384")]
public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name);
    [DynamicallyAccessedMembersAttribute("1536")]
public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("512")]
[UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
public PropertyInfo GetProperty(string name, Type returnType);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type[] types);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo[] GetProperties();
    [DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2731")]
public virtual MemberInfo[] GetDefaultMembers();
    [IntrinsicAttribute]
public virtual RuntimeTypeHandle get_TypeHandle();
    public static RuntimeTypeHandle GetTypeHandle(object o);
    public static Type[] GetTypeArray(Object[] args);
    [NullableContextAttribute("2")]
public static TypeCode GetTypeCode(Type type);
    internal static TypeCode GetRuntimeTypeCode(RuntimeType type);
    protected virtual TypeCode GetTypeCodeImpl();
    public abstract virtual Guid get_GUID();
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid, string server);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    [SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID);
    [SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID, bool throwOnError);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID, string server);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    [NullableContextAttribute("2")]
public abstract virtual Type get_BaseType();
    [NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[DynamicallyAccessedMembersAttribute("-1")]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [NullableContextAttribute("2")]
[DebuggerHiddenAttribute]
[DebuggerStepThroughAttribute]
[DynamicallyAccessedMembersAttribute("-1")]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    [DynamicallyAccessedMembersAttribute("8192")]
public Type GetInterface(string name);
    [DynamicallyAccessedMembersAttribute("8192")]
public abstract virtual Type GetInterface(string name, bool ignoreCase);
    [DynamicallyAccessedMembersAttribute("8192")]
public abstract virtual Type[] GetInterfaces();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [NullableContextAttribute("2")]
public virtual bool IsInstanceOfType(object o);
    [NullableContextAttribute("2")]
public virtual bool IsEquivalentTo(Type other);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
[IntrinsicAttribute]
public virtual Type GetEnumUnderlyingType();
    [RequiresDynamicCodeAttribute("It might not be possible to create an array of the enum type at runtime. Use Enum.GetValues<T> or the GetEnumValuesAsUnderlyingType method instead.")]
public virtual Array GetEnumValues();
    public virtual Array GetEnumValuesAsUnderlyingType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    public static Type MakeGenericSignatureType(Type genericTypeDefinition, Type[] typeArguments);
    public static Type MakeGenericMethodParameter(int position);
    internal string FormatTypeName();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(Type o);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool op_Equality(Type left, Type right);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public static bool op_Inequality(Type left, Type right);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public static Binder get_DefaultBinder();
    public virtual bool IsEnumDefined(object value);
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    private Array GetEnumRawConstantValues();
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
private void GetEnumData(String[]& enumNames, Array& enumValues);
    private static int BinarySearch(Array array, object value);
    internal static bool IsIntegerType(Type t);
    public virtual bool get_IsSerializable();
    public virtual bool get_ContainsGenericParameters();
    internal Type GetRootElementType();
    public bool get_IsVisible();
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual bool IsSubclassOf(Type c);
    [NullableContextAttribute("2")]
[IntrinsicAttribute]
public virtual bool IsAssignableFrom(Type c);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2085:UnrecognizedReflectionPattern")]
internal bool ImplementInterface(Type ifaceType);
    private static bool FilterAttributeImpl(MemberInfo m, object filterCriteria);
    private static bool FilterNameImpl(MemberInfo m, object filterCriteria, StringComparison comparison);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeAccessException : TypeLoadException {
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TypeAccessException(SerializationInfo info, StreamingContext context);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    private RuntimeTypeHandle type;
    private Byte& _value;
    private IntPtr _type;
    internal bool IsNull { get; }
    public static object ToObject(TypedReference value);
    internal static object InternalToObject(Void* value);
    [NullableContextAttribute("1")]
public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    private static void InternalMakeTypedReference(Void* result, object target, IntPtr[] flds, RuntimeType lastFieldType);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    internal bool get_IsNull();
    [NullableContextAttribute("1")]
public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    public static void SetTypedReference(TypedReference target, object value);
}
internal static class System.TypeIdentifiers : object {
    internal static ITypeIdentifier FromDisplay(string displayName);
    internal static ITypeIdentifier FromInternal(string internalName);
    internal static ITypeIdentifier FromInternal(string internalNameSpace, ITypeIdentifier typeName);
    internal static ITypeIdentifier WithoutEscape(string simpleName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeInitializationException : SystemException {
    private string _typeName;
    public string TypeName { get; }
    [NullableContextAttribute("2")]
public TypeInitializationException(string fullTypeName, Exception innerException);
    internal TypeInitializationException(string message);
    internal TypeInitializationException(string fullTypeName, string message, Exception innerException);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
private TypeInitializationException(SerializationInfo info, StreamingContext context);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_TypeName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeLoadException : SystemException {
    private string _className;
    private string _assemblyName;
    private string _messageArg;
    private int _resourceId;
    public string Message { get; }
    public string TypeName { get; }
    internal TypeLoadException(string className, string assemblyName);
    [NullableContextAttribute("2")]
public TypeLoadException(string message);
    [NullableContextAttribute("2")]
public TypeLoadException(string message, Exception inner);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TypeLoadException(SerializationInfo info, StreamingContext context);
    private void SetMessageField();
    public virtual string get_Message();
    public string get_TypeName();
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
internal static class System.TypeNames : object {
    internal static ITypeName FromDisplay(string displayName);
}
internal class System.TypeSpec : object {
    private ITypeIdentifier name;
    private string assembly_name;
    private List`1<ITypeIdentifier> nested;
    private List`1<TypeSpec> generic_params;
    private List`1<IModifierSpec> modifier_spec;
    private bool is_byref;
    private string display_fullname;
    internal bool HasModifiers { get; }
    internal bool IsNested { get; }
    internal bool IsByRef { get; }
    internal ITypeName Name { get; }
    internal IEnumerable`1<ITypeName> Nested { get; }
    internal IEnumerable`1<IModifierSpec> Modifiers { get; }
    internal string DisplayFullName { get; }
    internal ITypeName TypeName { get; }
    internal bool get_HasModifiers();
    internal bool get_IsNested();
    internal bool get_IsByRef();
    internal ITypeName get_Name();
    internal IEnumerable`1<ITypeName> get_Nested();
    internal IEnumerable`1<IModifierSpec> get_Modifiers();
    private string GetDisplayFullName(DisplayNameFormat flags);
    private StringBuilder GetModifierString(StringBuilder sb);
    internal string get_DisplayFullName();
    internal static TypeSpec Parse(string typeName);
    internal static string EscapeDisplayName(string internalName);
    internal static string UnescapeInternalName(string displayName);
    private void AddName(string type_name);
    private void AddModifier(IModifierSpec md);
    private static void SkipSpace(string name, Int32& pos);
    private static void BoundCheck(int idx, string s);
    private static ITypeIdentifier ParsedTypeIdentifier(string displayName);
    private static TypeSpec Parse(string name, Int32& p, bool is_recurse, bool allow_aqn);
    internal ITypeName TypeNameWithoutModifiers();
    internal ITypeName get_TypeName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.TypeUnloadedException : SystemException {
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[IntrinsicAttribute]
public class System.UInt128 : ValueType {
    private ulong _lower;
    private ulong _upper;
    internal ulong Lower { get; }
    internal ulong Upper { get; }
    private static UInt128 System.Numerics.IAdditiveIdentity<System.UInt128,System.UInt128>.AdditiveIdentity { get; }
    private static UInt128 System.Numerics.IBinaryNumber<System.UInt128>.AllBitsSet { get; }
    public static UInt128 MinValue { get; }
    public static UInt128 MaxValue { get; }
    private static UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128,System.UInt128>.MultiplicativeIdentity { get; }
    public static UInt128 One { get; }
    private static int System.Numerics.INumberBase<System.UInt128>.Radix { get; }
    public static UInt128 Zero { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.MaxHexDigitCount { get; }
    private static UInt128 System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.OverflowMessage { get; }
    [CLSCompliantAttribute("False")]
public UInt128(ulong upper, ulong lower);
    internal ulong get_Lower();
    internal ulong get_Upper();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt128 value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt128 other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static UInt128 Parse(string s);
    [NullableContextAttribute("1")]
public static UInt128 Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override UInt128 Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override UInt128 Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override UInt128 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt128& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt128& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, UInt128& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt128& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt128& result);
    public static byte op_Explicit(UInt128 value);
    public static byte op_CheckedExplicit(UInt128 value);
    public static char op_Explicit(UInt128 value);
    public static char op_CheckedExplicit(UInt128 value);
    public static decimal op_Explicit(UInt128 value);
    public static double op_Explicit(UInt128 value);
    public static Half op_Explicit(UInt128 value);
    public static short op_Explicit(UInt128 value);
    public static short op_CheckedExplicit(UInt128 value);
    public static int op_Explicit(UInt128 value);
    public static int op_CheckedExplicit(UInt128 value);
    public static long op_Explicit(UInt128 value);
    public static long op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static Int128 op_CheckedExplicit(UInt128 value);
    public static IntPtr op_Explicit(UInt128 value);
    public static IntPtr op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(UInt128 value);
    public static float op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(UInt128 value);
    public static UInt128 op_Explicit(decimal value);
    public static UInt128 op_Explicit(double value);
    public static UInt128 op_CheckedExplicit(double value);
    internal static UInt128 ToUInt128(double value);
    public static UInt128 op_Explicit(short value);
    public static UInt128 op_CheckedExplicit(short value);
    public static UInt128 op_Explicit(int value);
    public static UInt128 op_CheckedExplicit(int value);
    public static UInt128 op_Explicit(long value);
    public static UInt128 op_CheckedExplicit(long value);
    public static UInt128 op_Explicit(IntPtr value);
    public static UInt128 op_CheckedExplicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(sbyte value);
    public static UInt128 op_Explicit(float value);
    public static UInt128 op_CheckedExplicit(float value);
    public static UInt128 op_Implicit(byte value);
    public static UInt128 op_Implicit(char value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(UIntPtr value);
    private void WriteLittleEndianUnsafe(Span`1<byte> destination);
    public static override UInt128 op_Addition(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedAddition(UInt128 left, UInt128 right);
    private static override UInt128 System.Numerics.IAdditiveIdentity<System.UInt128,System.UInt128>.get_AdditiveIdentity();
    public static override ValueTuple`2<UInt128, UInt128> DivRem(UInt128 left, UInt128 right);
    public static override UInt128 LeadingZeroCount(UInt128 value);
    public static override UInt128 PopCount(UInt128 value);
    public static override UInt128 RotateLeft(UInt128 value, int rotateAmount);
    public static override UInt128 RotateRight(UInt128 value, int rotateAmount);
    public static override UInt128 TrailingZeroCount(UInt128 value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt128>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt128& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt128>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt128& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt128>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt128>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override UInt128 System.Numerics.IBinaryNumber<System.UInt128>.get_AllBitsSet();
    public static override bool IsPow2(UInt128 value);
    public static override UInt128 Log2(UInt128 value);
    public static override UInt128 op_BitwiseAnd(UInt128 left, UInt128 right);
    public static override UInt128 op_BitwiseOr(UInt128 left, UInt128 right);
    public static override UInt128 op_ExclusiveOr(UInt128 left, UInt128 right);
    public static override UInt128 op_OnesComplement(UInt128 value);
    public static override bool op_LessThan(UInt128 left, UInt128 right);
    public static override bool op_LessThanOrEqual(UInt128 left, UInt128 right);
    public static override bool op_GreaterThan(UInt128 left, UInt128 right);
    public static override bool op_GreaterThanOrEqual(UInt128 left, UInt128 right);
    public static override UInt128 op_Decrement(UInt128 value);
    public static override UInt128 op_CheckedDecrement(UInt128 value);
    public static override UInt128 op_Division(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedDivision(UInt128 left, UInt128 right);
    public static override bool op_Equality(UInt128 left, UInt128 right);
    public static override bool op_Inequality(UInt128 left, UInt128 right);
    public static override UInt128 op_Increment(UInt128 value);
    public static override UInt128 op_CheckedIncrement(UInt128 value);
    public static override UInt128 get_MinValue();
    public static override UInt128 get_MaxValue();
    public static override UInt128 op_Modulus(UInt128 left, UInt128 right);
    private static override UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128,System.UInt128>.get_MultiplicativeIdentity();
    public static override UInt128 op_Multiply(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedMultiply(UInt128 left, UInt128 right);
    internal static UInt128 BigMul(UInt128 left, UInt128 right, UInt128& lower);
    public static override UInt128 Clamp(UInt128 value, UInt128 min, UInt128 max);
    private static override UInt128 System.Numerics.INumber<System.UInt128>.CopySign(UInt128 value, UInt128 sign);
    public static override UInt128 Max(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumber<System.UInt128>.MaxNumber(UInt128 x, UInt128 y);
    public static override UInt128 Min(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumber<System.UInt128>.MinNumber(UInt128 x, UInt128 y);
    public static override int Sign(UInt128 value);
    public static override UInt128 get_One();
    private static override int System.Numerics.INumberBase<System.UInt128>.get_Radix();
    public static override UInt128 get_Zero();
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.Abs(UInt128 value);
    [NullableContextAttribute("1")]
public static override UInt128 CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override UInt128 CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override UInt128 CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsCanonical(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsComplexNumber(UInt128 value);
    public static override bool IsEvenInteger(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsFinite(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsImaginaryNumber(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsInfinity(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsInteger(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNaN(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNegative(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNegativeInfinity(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNormal(UInt128 value);
    public static override bool IsOddInteger(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsPositive(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsPositiveInfinity(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsRealNumber(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsSubnormal(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsZero(UInt128 value);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MaxMagnitude(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MaxMagnitudeNumber(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MinMagnitude(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MinMagnitudeNumber(UInt128 x, UInt128 y);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromChecked(TOther value, UInt128& result);
    private static bool TryConvertFromChecked(TOther value, UInt128& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromSaturating(TOther value, UInt128& result);
    private static bool TryConvertFromSaturating(TOther value, UInt128& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromTruncating(TOther value, UInt128& result);
    private static bool TryConvertFromTruncating(TOther value, UInt128& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertToChecked(UInt128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertToSaturating(UInt128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertToTruncating(UInt128 value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt128& result);
    public static override UInt128 op_LeftShift(UInt128 value, int shiftAmount);
    public static override UInt128 op_RightShift(UInt128 value, int shiftAmount);
    public static override UInt128 op_UnsignedRightShift(UInt128 value, int shiftAmount);
    public static override UInt128 Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt128& result);
    public static override UInt128 op_Subtraction(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedSubtraction(UInt128 left, UInt128 right);
    public static override UInt128 op_UnaryNegation(UInt128 value);
    public static override UInt128 op_CheckedUnaryNegation(UInt128 value);
    public static override UInt128 op_UnaryPlus(UInt128 value);
    public static override UInt128 Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, UInt128& result);
    public static override UInt128 Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, UInt128& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.get_MaxHexDigitCount();
    private static override UInt128 System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.IsGreaterThanAsUnsigned(UInt128 left, UInt128 right);
    private static override UInt128 System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.MultiplyBy10(UInt128 value);
    private static override UInt128 System.IBinaryIntegerParseAndFormatInfo<System.UInt128>.MultiplyBy16(UInt128 value);
    [CompilerGeneratedAttribute]
internal static UInt32 <op_Division>g__AddDivisor|110_0(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right);
    [CompilerGeneratedAttribute]
internal static bool <op_Division>g__DivideGuessTooBig|110_1(ulong q, ulong valHi, UInt32 valLo, UInt32 divHi, UInt32 divLo);
    [CompilerGeneratedAttribute]
internal static UInt128 <op_Division>g__DivideSlow|110_2(UInt128 quotient, UInt128 divisor);
    [CompilerGeneratedAttribute]
internal static UInt32 <op_Division>g__SubtractDivisor|110_3(Span`1<UInt32> left, ReadOnlySpan`1<UInt32> right, ulong q);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt16 : ValueType {
    private ushort m_value;
    public static ushort MaxValue;
    public static ushort MinValue;
    private static ushort System.Numerics.IAdditiveIdentity<System.UInt16,System.UInt16>.AdditiveIdentity { get; }
    private static ushort System.Numerics.IBinaryNumber<System.UInt16>.AllBitsSet { get; }
    private static ushort System.Numerics.IMinMaxValue<System.UInt16>.MinValue { get; }
    private static ushort System.Numerics.IMinMaxValue<System.UInt16>.MaxValue { get; }
    private static ushort System.Numerics.IMultiplicativeIdentity<System.UInt16,System.UInt16>.MultiplicativeIdentity { get; }
    private static ushort System.Numerics.INumberBase<System.UInt16>.One { get; }
    private static int System.Numerics.INumberBase<System.UInt16>.Radix { get; }
    private static ushort System.Numerics.INumberBase<System.UInt16>.Zero { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.MaxHexDigitCount { get; }
    private static ushort System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static ushort Parse(string s);
    [NullableContextAttribute("1")]
public static ushort Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override ushort Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, UInt16& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override ushort System.Numerics.IAdditionOperators<System.UInt16,System.UInt16,System.UInt16>.op_Addition(ushort left, ushort right);
    private static override ushort System.Numerics.IAdditionOperators<System.UInt16,System.UInt16,System.UInt16>.op_CheckedAddition(ushort left, ushort right);
    private static override ushort System.Numerics.IAdditiveIdentity<System.UInt16,System.UInt16>.get_AdditiveIdentity();
    public static override ValueTuple`2<ushort, ushort> DivRem(ushort left, ushort right);
    public static override ushort LeadingZeroCount(ushort value);
    public static override ushort PopCount(ushort value);
    public static override ushort RotateLeft(ushort value, int rotateAmount);
    public static override ushort RotateRight(ushort value, int rotateAmount);
    public static override ushort TrailingZeroCount(ushort value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt16>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt16& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt16>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt16& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt16>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt16>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt16>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt16>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override ushort System.Numerics.IBinaryNumber<System.UInt16>.get_AllBitsSet();
    public static override bool IsPow2(ushort value);
    public static override ushort Log2(ushort value);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_BitwiseAnd(ushort left, ushort right);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_BitwiseOr(ushort left, ushort right);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_ExclusiveOr(ushort left, ushort right);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_OnesComplement(ushort value);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_LessThan(ushort left, ushort right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_LessThanOrEqual(ushort left, ushort right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_GreaterThan(ushort left, ushort right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_GreaterThanOrEqual(ushort left, ushort right);
    private static override ushort System.Numerics.IDecrementOperators<System.UInt16>.op_Decrement(ushort value);
    private static override ushort System.Numerics.IDecrementOperators<System.UInt16>.op_CheckedDecrement(ushort value);
    private static override ushort System.Numerics.IDivisionOperators<System.UInt16,System.UInt16,System.UInt16>.op_Division(ushort left, ushort right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt16,System.UInt16,System.Boolean>.op_Equality(ushort left, ushort right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt16,System.UInt16,System.Boolean>.op_Inequality(ushort left, ushort right);
    private static override ushort System.Numerics.IIncrementOperators<System.UInt16>.op_Increment(ushort value);
    private static override ushort System.Numerics.IIncrementOperators<System.UInt16>.op_CheckedIncrement(ushort value);
    private static override ushort System.Numerics.IMinMaxValue<System.UInt16>.get_MinValue();
    private static override ushort System.Numerics.IMinMaxValue<System.UInt16>.get_MaxValue();
    private static override ushort System.Numerics.IModulusOperators<System.UInt16,System.UInt16,System.UInt16>.op_Modulus(ushort left, ushort right);
    private static override ushort System.Numerics.IMultiplicativeIdentity<System.UInt16,System.UInt16>.get_MultiplicativeIdentity();
    private static override ushort System.Numerics.IMultiplyOperators<System.UInt16,System.UInt16,System.UInt16>.op_Multiply(ushort left, ushort right);
    private static override ushort System.Numerics.IMultiplyOperators<System.UInt16,System.UInt16,System.UInt16>.op_CheckedMultiply(ushort left, ushort right);
    public static override ushort Clamp(ushort value, ushort min, ushort max);
    private static override ushort System.Numerics.INumber<System.UInt16>.CopySign(ushort value, ushort sign);
    public static override ushort Max(ushort x, ushort y);
    private static override ushort System.Numerics.INumber<System.UInt16>.MaxNumber(ushort x, ushort y);
    public static override ushort Min(ushort x, ushort y);
    private static override ushort System.Numerics.INumber<System.UInt16>.MinNumber(ushort x, ushort y);
    public static override int Sign(ushort value);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.get_One();
    private static override int System.Numerics.INumberBase<System.UInt16>.get_Radix();
    private static override ushort System.Numerics.INumberBase<System.UInt16>.get_Zero();
    private static override ushort System.Numerics.INumberBase<System.UInt16>.Abs(ushort value);
    [NullableContextAttribute("1")]
public static override ushort CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override ushort CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override ushort CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsCanonical(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsComplexNumber(ushort value);
    public static override bool IsEvenInteger(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsFinite(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsImaginaryNumber(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsInfinity(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsInteger(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNaN(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNegative(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNegativeInfinity(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNormal(ushort value);
    public static override bool IsOddInteger(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsPositive(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsPositiveInfinity(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsRealNumber(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsSubnormal(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsZero(ushort value);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MaxMagnitude(ushort x, ushort y);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MaxMagnitudeNumber(ushort x, ushort y);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MinMagnitude(ushort x, ushort y);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MinMagnitudeNumber(ushort x, ushort y);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromChecked(TOther value, UInt16& result);
    private static bool TryConvertFromChecked(TOther value, UInt16& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromSaturating(TOther value, UInt16& result);
    private static bool TryConvertFromSaturating(TOther value, UInt16& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromTruncating(TOther value, UInt16& result);
    private static bool TryConvertFromTruncating(TOther value, UInt16& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertToChecked(ushort value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertToSaturating(ushort value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertToTruncating(ushort value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt16& result);
    private static override ushort System.Numerics.IShiftOperators<System.UInt16,System.Int32,System.UInt16>.op_LeftShift(ushort value, int shiftAmount);
    private static override ushort System.Numerics.IShiftOperators<System.UInt16,System.Int32,System.UInt16>.op_RightShift(ushort value, int shiftAmount);
    private static override ushort System.Numerics.IShiftOperators<System.UInt16,System.Int32,System.UInt16>.op_UnsignedRightShift(ushort value, int shiftAmount);
    public static override ushort Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt16& result);
    private static override ushort System.Numerics.ISubtractionOperators<System.UInt16,System.UInt16,System.UInt16>.op_Subtraction(ushort left, ushort right);
    private static override ushort System.Numerics.ISubtractionOperators<System.UInt16,System.UInt16,System.UInt16>.op_CheckedSubtraction(ushort left, ushort right);
    private static override ushort System.Numerics.IUnaryNegationOperators<System.UInt16,System.UInt16>.op_UnaryNegation(ushort value);
    private static override ushort System.Numerics.IUnaryNegationOperators<System.UInt16,System.UInt16>.op_CheckedUnaryNegation(ushort value);
    private static override ushort System.Numerics.IUnaryPlusOperators<System.UInt16,System.UInt16>.op_UnaryPlus(ushort value);
    public static override ushort Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, UInt16& result);
    public static override ushort Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, UInt16& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.get_MaxHexDigitCount();
    private static override ushort System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.IsGreaterThanAsUnsigned(ushort left, ushort right);
    private static override ushort System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.MultiplyBy10(ushort value);
    private static override ushort System.IBinaryIntegerParseAndFormatInfo<System.UInt16>.MultiplyBy16(ushort value);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt32 : ValueType {
    private UInt32 m_value;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    private static UInt32 System.Numerics.IAdditiveIdentity<System.UInt32,System.UInt32>.AdditiveIdentity { get; }
    private static UInt32 System.Numerics.IBinaryNumber<System.UInt32>.AllBitsSet { get; }
    private static UInt32 System.Numerics.IMinMaxValue<System.UInt32>.MinValue { get; }
    private static UInt32 System.Numerics.IMinMaxValue<System.UInt32>.MaxValue { get; }
    private static UInt32 System.Numerics.IMultiplicativeIdentity<System.UInt32,System.UInt32>.MultiplicativeIdentity { get; }
    private static UInt32 System.Numerics.INumberBase<System.UInt32>.One { get; }
    private static int System.Numerics.INumberBase<System.UInt32>.Radix { get; }
    private static UInt32 System.Numerics.INumberBase<System.UInt32>.Zero { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.MaxHexDigitCount { get; }
    private static UInt32 System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static UInt32 Parse(string s);
    [NullableContextAttribute("1")]
public static UInt32 Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override UInt32 Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, UInt32& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override UInt32 System.Numerics.IAdditionOperators<System.UInt32,System.UInt32,System.UInt32>.op_Addition(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IAdditionOperators<System.UInt32,System.UInt32,System.UInt32>.op_CheckedAddition(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IAdditiveIdentity<System.UInt32,System.UInt32>.get_AdditiveIdentity();
    public static override ValueTuple`2<UInt32, UInt32> DivRem(UInt32 left, UInt32 right);
    [IntrinsicAttribute]
public static override UInt32 LeadingZeroCount(UInt32 value);
    [IntrinsicAttribute]
public static override UInt32 PopCount(UInt32 value);
    [IntrinsicAttribute]
public static override UInt32 RotateLeft(UInt32 value, int rotateAmount);
    [IntrinsicAttribute]
public static override UInt32 RotateRight(UInt32 value, int rotateAmount);
    [IntrinsicAttribute]
public static override UInt32 TrailingZeroCount(UInt32 value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt32>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt32& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt32>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt32& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt32>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt32>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt32>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt32>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override UInt32 System.Numerics.IBinaryNumber<System.UInt32>.get_AllBitsSet();
    public static override bool IsPow2(UInt32 value);
    [IntrinsicAttribute]
public static override UInt32 Log2(UInt32 value);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_BitwiseAnd(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_BitwiseOr(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_ExclusiveOr(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_OnesComplement(UInt32 value);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_LessThan(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_LessThanOrEqual(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_GreaterThan(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_GreaterThanOrEqual(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IDecrementOperators<System.UInt32>.op_Decrement(UInt32 value);
    private static override UInt32 System.Numerics.IDecrementOperators<System.UInt32>.op_CheckedDecrement(UInt32 value);
    private static override UInt32 System.Numerics.IDivisionOperators<System.UInt32,System.UInt32,System.UInt32>.op_Division(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt32,System.UInt32,System.Boolean>.op_Equality(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt32,System.UInt32,System.Boolean>.op_Inequality(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IIncrementOperators<System.UInt32>.op_Increment(UInt32 value);
    private static override UInt32 System.Numerics.IIncrementOperators<System.UInt32>.op_CheckedIncrement(UInt32 value);
    private static override UInt32 System.Numerics.IMinMaxValue<System.UInt32>.get_MinValue();
    private static override UInt32 System.Numerics.IMinMaxValue<System.UInt32>.get_MaxValue();
    private static override UInt32 System.Numerics.IModulusOperators<System.UInt32,System.UInt32,System.UInt32>.op_Modulus(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IMultiplicativeIdentity<System.UInt32,System.UInt32>.get_MultiplicativeIdentity();
    private static override UInt32 System.Numerics.IMultiplyOperators<System.UInt32,System.UInt32,System.UInt32>.op_Multiply(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IMultiplyOperators<System.UInt32,System.UInt32,System.UInt32>.op_CheckedMultiply(UInt32 left, UInt32 right);
    public static override UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    private static override UInt32 System.Numerics.INumber<System.UInt32>.CopySign(UInt32 value, UInt32 sign);
    public static override UInt32 Max(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumber<System.UInt32>.MaxNumber(UInt32 x, UInt32 y);
    public static override UInt32 Min(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumber<System.UInt32>.MinNumber(UInt32 x, UInt32 y);
    public static override int Sign(UInt32 value);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.get_One();
    private static override int System.Numerics.INumberBase<System.UInt32>.get_Radix();
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.get_Zero();
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.Abs(UInt32 value);
    [NullableContextAttribute("1")]
public static override UInt32 CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override UInt32 CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override UInt32 CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsCanonical(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsComplexNumber(UInt32 value);
    public static override bool IsEvenInteger(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsFinite(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsImaginaryNumber(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsInfinity(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsInteger(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNaN(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNegative(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNegativeInfinity(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNormal(UInt32 value);
    public static override bool IsOddInteger(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsPositive(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsPositiveInfinity(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsRealNumber(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsSubnormal(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsZero(UInt32 value);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MaxMagnitude(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MaxMagnitudeNumber(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MinMagnitude(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MinMagnitudeNumber(UInt32 x, UInt32 y);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromChecked(TOther value, UInt32& result);
    private static bool TryConvertFromChecked(TOther value, UInt32& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromSaturating(TOther value, UInt32& result);
    private static bool TryConvertFromSaturating(TOther value, UInt32& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromTruncating(TOther value, UInt32& result);
    private static bool TryConvertFromTruncating(TOther value, UInt32& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertToChecked(UInt32 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertToSaturating(UInt32 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertToTruncating(UInt32 value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt32& result);
    private static override UInt32 System.Numerics.IShiftOperators<System.UInt32,System.Int32,System.UInt32>.op_LeftShift(UInt32 value, int shiftAmount);
    private static override UInt32 System.Numerics.IShiftOperators<System.UInt32,System.Int32,System.UInt32>.op_RightShift(UInt32 value, int shiftAmount);
    private static override UInt32 System.Numerics.IShiftOperators<System.UInt32,System.Int32,System.UInt32>.op_UnsignedRightShift(UInt32 value, int shiftAmount);
    public static override UInt32 Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt32& result);
    private static override UInt32 System.Numerics.ISubtractionOperators<System.UInt32,System.UInt32,System.UInt32>.op_Subtraction(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.ISubtractionOperators<System.UInt32,System.UInt32,System.UInt32>.op_CheckedSubtraction(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IUnaryNegationOperators<System.UInt32,System.UInt32>.op_UnaryNegation(UInt32 value);
    private static override UInt32 System.Numerics.IUnaryNegationOperators<System.UInt32,System.UInt32>.op_CheckedUnaryNegation(UInt32 value);
    private static override UInt32 System.Numerics.IUnaryPlusOperators<System.UInt32,System.UInt32>.op_UnaryPlus(UInt32 value);
    public static override UInt32 Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, UInt32& result);
    public static override UInt32 Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, UInt32& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.get_MaxHexDigitCount();
    private static override UInt32 System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.IsGreaterThanAsUnsigned(UInt32 left, UInt32 right);
    private static override UInt32 System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.MultiplyBy10(UInt32 value);
    private static override UInt32 System.IBinaryIntegerParseAndFormatInfo<System.UInt32>.MultiplyBy16(UInt32 value);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UInt64 : ValueType {
    private ulong m_value;
    public static ulong MaxValue;
    public static ulong MinValue;
    private static ulong System.Numerics.IAdditiveIdentity<System.UInt64,System.UInt64>.AdditiveIdentity { get; }
    private static ulong System.Numerics.IBinaryNumber<System.UInt64>.AllBitsSet { get; }
    private static ulong System.Numerics.IMinMaxValue<System.UInt64>.MinValue { get; }
    private static ulong System.Numerics.IMinMaxValue<System.UInt64>.MaxValue { get; }
    private static ulong System.Numerics.IMultiplicativeIdentity<System.UInt64,System.UInt64>.MultiplicativeIdentity { get; }
    private static ulong System.Numerics.INumberBase<System.UInt64>.One { get; }
    private static int System.Numerics.INumberBase<System.UInt64>.Radix { get; }
    private static ulong System.Numerics.INumberBase<System.UInt64>.Zero { get; }
    private static bool System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.IsSigned { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.MaxDigitCount { get; }
    private static int System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.MaxHexDigitCount { get; }
    private static ulong System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.MaxValueDiv10 { get; }
    [NullableAttribute("1")]
private static string System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.OverflowMessage { get; }
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NonVersionableAttribute]
public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static ulong Parse(string s);
    [NullableContextAttribute("1")]
public static ulong Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override ulong Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, UInt64& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private static override ulong System.Numerics.IAdditionOperators<System.UInt64,System.UInt64,System.UInt64>.op_Addition(ulong left, ulong right);
    private static override ulong System.Numerics.IAdditionOperators<System.UInt64,System.UInt64,System.UInt64>.op_CheckedAddition(ulong left, ulong right);
    private static override ulong System.Numerics.IAdditiveIdentity<System.UInt64,System.UInt64>.get_AdditiveIdentity();
    public static override ValueTuple`2<ulong, ulong> DivRem(ulong left, ulong right);
    [IntrinsicAttribute]
public static override ulong LeadingZeroCount(ulong value);
    [IntrinsicAttribute]
public static override ulong PopCount(ulong value);
    [IntrinsicAttribute]
public static override ulong RotateLeft(ulong value, int rotateAmount);
    [IntrinsicAttribute]
public static override ulong RotateRight(ulong value, int rotateAmount);
    [IntrinsicAttribute]
public static override ulong TrailingZeroCount(ulong value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt64>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt64& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt64>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt64& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt64>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt64>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt64>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt64>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override ulong System.Numerics.IBinaryNumber<System.UInt64>.get_AllBitsSet();
    public static override bool IsPow2(ulong value);
    [IntrinsicAttribute]
public static override ulong Log2(ulong value);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_BitwiseAnd(ulong left, ulong right);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_BitwiseOr(ulong left, ulong right);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_ExclusiveOr(ulong left, ulong right);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_OnesComplement(ulong value);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_LessThan(ulong left, ulong right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_LessThanOrEqual(ulong left, ulong right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_GreaterThan(ulong left, ulong right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_GreaterThanOrEqual(ulong left, ulong right);
    private static override ulong System.Numerics.IDecrementOperators<System.UInt64>.op_Decrement(ulong value);
    private static override ulong System.Numerics.IDecrementOperators<System.UInt64>.op_CheckedDecrement(ulong value);
    private static override ulong System.Numerics.IDivisionOperators<System.UInt64,System.UInt64,System.UInt64>.op_Division(ulong left, ulong right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt64,System.UInt64,System.Boolean>.op_Equality(ulong left, ulong right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt64,System.UInt64,System.Boolean>.op_Inequality(ulong left, ulong right);
    private static override ulong System.Numerics.IIncrementOperators<System.UInt64>.op_Increment(ulong value);
    private static override ulong System.Numerics.IIncrementOperators<System.UInt64>.op_CheckedIncrement(ulong value);
    private static override ulong System.Numerics.IMinMaxValue<System.UInt64>.get_MinValue();
    private static override ulong System.Numerics.IMinMaxValue<System.UInt64>.get_MaxValue();
    private static override ulong System.Numerics.IModulusOperators<System.UInt64,System.UInt64,System.UInt64>.op_Modulus(ulong left, ulong right);
    private static override ulong System.Numerics.IMultiplicativeIdentity<System.UInt64,System.UInt64>.get_MultiplicativeIdentity();
    private static override ulong System.Numerics.IMultiplyOperators<System.UInt64,System.UInt64,System.UInt64>.op_Multiply(ulong left, ulong right);
    private static override ulong System.Numerics.IMultiplyOperators<System.UInt64,System.UInt64,System.UInt64>.op_CheckedMultiply(ulong left, ulong right);
    public static override ulong Clamp(ulong value, ulong min, ulong max);
    private static override ulong System.Numerics.INumber<System.UInt64>.CopySign(ulong value, ulong sign);
    public static override ulong Max(ulong x, ulong y);
    private static override ulong System.Numerics.INumber<System.UInt64>.MaxNumber(ulong x, ulong y);
    public static override ulong Min(ulong x, ulong y);
    private static override ulong System.Numerics.INumber<System.UInt64>.MinNumber(ulong x, ulong y);
    public static override int Sign(ulong value);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.get_One();
    private static override int System.Numerics.INumberBase<System.UInt64>.get_Radix();
    private static override ulong System.Numerics.INumberBase<System.UInt64>.get_Zero();
    private static override ulong System.Numerics.INumberBase<System.UInt64>.Abs(ulong value);
    [NullableContextAttribute("1")]
public static override ulong CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override ulong CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override ulong CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsCanonical(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsComplexNumber(ulong value);
    public static override bool IsEvenInteger(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsFinite(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsImaginaryNumber(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsInfinity(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsInteger(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNaN(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNegative(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNegativeInfinity(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNormal(ulong value);
    public static override bool IsOddInteger(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsPositive(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsPositiveInfinity(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsRealNumber(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsSubnormal(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsZero(ulong value);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MaxMagnitude(ulong x, ulong y);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MaxMagnitudeNumber(ulong x, ulong y);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MinMagnitude(ulong x, ulong y);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MinMagnitudeNumber(ulong x, ulong y);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromChecked(TOther value, UInt64& result);
    private static bool TryConvertFromChecked(TOther value, UInt64& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromSaturating(TOther value, UInt64& result);
    private static bool TryConvertFromSaturating(TOther value, UInt64& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromTruncating(TOther value, UInt64& result);
    private static bool TryConvertFromTruncating(TOther value, UInt64& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertToChecked(ulong value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertToSaturating(ulong value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertToTruncating(ulong value, TOther& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt64& result);
    private static override ulong System.Numerics.IShiftOperators<System.UInt64,System.Int32,System.UInt64>.op_LeftShift(ulong value, int shiftAmount);
    private static override ulong System.Numerics.IShiftOperators<System.UInt64,System.Int32,System.UInt64>.op_RightShift(ulong value, int shiftAmount);
    private static override ulong System.Numerics.IShiftOperators<System.UInt64,System.Int32,System.UInt64>.op_UnsignedRightShift(ulong value, int shiftAmount);
    public static override ulong Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt64& result);
    private static override ulong System.Numerics.ISubtractionOperators<System.UInt64,System.UInt64,System.UInt64>.op_Subtraction(ulong left, ulong right);
    private static override ulong System.Numerics.ISubtractionOperators<System.UInt64,System.UInt64,System.UInt64>.op_CheckedSubtraction(ulong left, ulong right);
    private static override ulong System.Numerics.IUnaryNegationOperators<System.UInt64,System.UInt64>.op_UnaryNegation(ulong value);
    private static override ulong System.Numerics.IUnaryNegationOperators<System.UInt64,System.UInt64>.op_CheckedUnaryNegation(ulong value);
    private static override ulong System.Numerics.IUnaryPlusOperators<System.UInt64,System.UInt64>.op_UnaryPlus(ulong value);
    public static override ulong Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, UInt64& result);
    public static override ulong Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, UInt64& result);
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.get_IsSigned();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.get_MaxDigitCount();
    private static override int System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.get_MaxHexDigitCount();
    private static override ulong System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.get_MaxValueDiv10();
    private static override string System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.get_OverflowMessage();
    private static override bool System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.IsGreaterThanAsUnsigned(ulong left, ulong right);
    private static override ulong System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.MultiplyBy10(ulong value);
    private static override ulong System.IBinaryIntegerParseAndFormatInfo<System.UInt64>.MultiplyBy16(ulong value);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UIntPtr : ValueType {
    private UIntPtr _value;
    [IntrinsicAttribute]
public static UIntPtr Zero;
    public static int Size { get; }
    public static UIntPtr MaxValue { get; }
    public static UIntPtr MinValue { get; }
    private static UIntPtr System.Numerics.IAdditiveIdentity<nuint,nuint>.AdditiveIdentity { get; }
    private static UIntPtr System.Numerics.IBinaryNumber<nuint>.AllBitsSet { get; }
    private static UIntPtr System.Numerics.IMinMaxValue<nuint>.MinValue { get; }
    private static UIntPtr System.Numerics.IMinMaxValue<nuint>.MaxValue { get; }
    private static UIntPtr System.Numerics.IMultiplicativeIdentity<nuint,nuint>.MultiplicativeIdentity { get; }
    private static UIntPtr System.Numerics.INumberBase<nuint>.One { get; }
    private static int System.Numerics.INumberBase<nuint>.Radix { get; }
    private static UIntPtr System.Numerics.INumberBase<nuint>.Zero { get; }
    [NonVersionableAttribute]
public UIntPtr(UInt32 value);
    [NonVersionableAttribute]
public UIntPtr(ulong value);
    [NonVersionableAttribute]
public UIntPtr(Void* value);
    private UIntPtr(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NonVersionableAttribute]
public UInt32 ToUInt32();
    [NonVersionableAttribute]
public ulong ToUInt64();
    [NonVersionableAttribute]
public static UIntPtr op_Explicit(UInt32 value);
    [NonVersionableAttribute]
public static UIntPtr op_Explicit(ulong value);
    [NonVersionableAttribute]
public static UIntPtr op_Explicit(Void* value);
    [NonVersionableAttribute]
public static Void* op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
public static UInt32 op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
public static ulong op_Explicit(UIntPtr value);
    [NonVersionableAttribute]
public static override bool op_Equality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static override bool op_Inequality(UIntPtr value1, UIntPtr value2);
    [NonVersionableAttribute]
public static UIntPtr Add(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr Subtract(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    [NonVersionableAttribute]
public static int get_Size();
    [NonVersionableAttribute]
public Void* ToPointer();
    [NonVersionableAttribute]
public static UIntPtr get_MaxValue();
    [NonVersionableAttribute]
public static UIntPtr get_MinValue();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UIntPtr value);
    [NonVersionableAttribute]
public sealed virtual bool Equals(UIntPtr other);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static UIntPtr Parse(string s);
    [NullableContextAttribute("1")]
public static UIntPtr Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override UIntPtr Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override UIntPtr Parse(string s, NumberStyles style, IFormatProvider provider);
    public static override UIntPtr Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static override UIntPtr Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UIntPtr& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UIntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UIntPtr& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UIntPtr& result);
    public static bool TryParse(ReadOnlySpan`1<byte> utf8Text, UIntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UIntPtr& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UIntPtr& result);
    private static override UIntPtr System.Numerics.IAdditionOperators<nuint,nuint,nuint>.op_Addition(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IAdditionOperators<nuint,nuint,nuint>.op_CheckedAddition(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IAdditiveIdentity<nuint,nuint>.get_AdditiveIdentity();
    public static override ValueTuple`2<UIntPtr, UIntPtr> DivRem(UIntPtr left, UIntPtr right);
    [IntrinsicAttribute]
public static override UIntPtr LeadingZeroCount(UIntPtr value);
    [IntrinsicAttribute]
public static override UIntPtr PopCount(UIntPtr value);
    [IntrinsicAttribute]
public static override UIntPtr RotateLeft(UIntPtr value, int rotateAmount);
    [IntrinsicAttribute]
public static override UIntPtr RotateRight(UIntPtr value, int rotateAmount);
    [IntrinsicAttribute]
public static override UIntPtr TrailingZeroCount(UIntPtr value);
    private static override bool System.Numerics.IBinaryInteger<nuint>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UIntPtr& value);
    private static override bool System.Numerics.IBinaryInteger<nuint>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UIntPtr& value);
    private sealed virtual override int System.Numerics.IBinaryInteger<nuint>.GetShortestBitLength();
    private sealed virtual override int System.Numerics.IBinaryInteger<nuint>.GetByteCount();
    private sealed virtual override bool System.Numerics.IBinaryInteger<nuint>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<nuint>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NonVersionableAttribute]
private static override UIntPtr System.Numerics.IBinaryNumber<nuint>.get_AllBitsSet();
    public static override bool IsPow2(UIntPtr value);
    [IntrinsicAttribute]
public static override UIntPtr Log2(UIntPtr value);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_BitwiseAnd(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_BitwiseOr(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_ExclusiveOr(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_OnesComplement(UIntPtr value);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_LessThan(UIntPtr left, UIntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_LessThanOrEqual(UIntPtr left, UIntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_GreaterThan(UIntPtr left, UIntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_GreaterThanOrEqual(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IDecrementOperators<nuint>.op_Decrement(UIntPtr value);
    private static override UIntPtr System.Numerics.IDecrementOperators<nuint>.op_CheckedDecrement(UIntPtr value);
    private static override UIntPtr System.Numerics.IDivisionOperators<nuint,nuint,nuint>.op_Division(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IIncrementOperators<nuint>.op_Increment(UIntPtr value);
    private static override UIntPtr System.Numerics.IIncrementOperators<nuint>.op_CheckedIncrement(UIntPtr value);
    private static override UIntPtr System.Numerics.IMinMaxValue<nuint>.get_MinValue();
    private static override UIntPtr System.Numerics.IMinMaxValue<nuint>.get_MaxValue();
    private static override UIntPtr System.Numerics.IModulusOperators<nuint,nuint,nuint>.op_Modulus(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IMultiplicativeIdentity<nuint,nuint>.get_MultiplicativeIdentity();
    private static override UIntPtr System.Numerics.IMultiplyOperators<nuint,nuint,nuint>.op_Multiply(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IMultiplyOperators<nuint,nuint,nuint>.op_CheckedMultiply(UIntPtr left, UIntPtr right);
    public static override UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);
    private static override UIntPtr System.Numerics.INumber<nuint>.CopySign(UIntPtr value, UIntPtr sign);
    public static override UIntPtr Max(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumber<nuint>.MaxNumber(UIntPtr x, UIntPtr y);
    public static override UIntPtr Min(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumber<nuint>.MinNumber(UIntPtr x, UIntPtr y);
    public static override int Sign(UIntPtr value);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.get_One();
    private static override int System.Numerics.INumberBase<nuint>.get_Radix();
    private static override UIntPtr System.Numerics.INumberBase<nuint>.get_Zero();
    private static override UIntPtr System.Numerics.INumberBase<nuint>.Abs(UIntPtr value);
    [NullableContextAttribute("1")]
public static override UIntPtr CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override UIntPtr CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override UIntPtr CreateTruncating(TOther value);
    private static override bool System.Numerics.INumberBase<nuint>.IsCanonical(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsComplexNumber(UIntPtr value);
    public static override bool IsEvenInteger(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsFinite(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsImaginaryNumber(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsInfinity(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsInteger(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNaN(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNegative(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNegativeInfinity(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNormal(UIntPtr value);
    public static override bool IsOddInteger(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsPositive(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsPositiveInfinity(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsRealNumber(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsSubnormal(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsZero(UIntPtr value);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MaxMagnitude(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MaxMagnitudeNumber(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MinMagnitude(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MinMagnitudeNumber(UIntPtr x, UIntPtr y);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertFromChecked(TOther value, UIntPtr& result);
    private static bool TryConvertFromChecked(TOther value, UIntPtr& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertFromSaturating(TOther value, UIntPtr& result);
    private static bool TryConvertFromSaturating(TOther value, UIntPtr& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertFromTruncating(TOther value, UIntPtr& result);
    private static bool TryConvertFromTruncating(TOther value, UIntPtr& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertToChecked(UIntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertToSaturating(UIntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertToTruncating(UIntPtr value, TOther& result);
    private static override UIntPtr System.Numerics.IShiftOperators<nuint,System.Int32,nuint>.op_LeftShift(UIntPtr value, int shiftAmount);
    private static override UIntPtr System.Numerics.IShiftOperators<nuint,System.Int32,nuint>.op_RightShift(UIntPtr value, int shiftAmount);
    private static override UIntPtr System.Numerics.IShiftOperators<nuint,System.Int32,nuint>.op_UnsignedRightShift(UIntPtr value, int shiftAmount);
    private static override UIntPtr System.Numerics.ISubtractionOperators<nuint,nuint,nuint>.op_Subtraction(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.ISubtractionOperators<nuint,nuint,nuint>.op_CheckedSubtraction(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IUnaryNegationOperators<nuint,nuint>.op_UnaryNegation(UIntPtr value);
    private static override UIntPtr System.Numerics.IUnaryNegationOperators<nuint,nuint>.op_CheckedUnaryNegation(UIntPtr value);
    private static override UIntPtr System.Numerics.IUnaryPlusOperators<nuint,nuint>.op_UnaryPlus(UIntPtr value);
    public static override UIntPtr Parse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, NumberStyles style, IFormatProvider provider, UIntPtr& result);
    public static override UIntPtr Parse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<byte> utf8Text, IFormatProvider provider, UIntPtr& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.UnauthorizedAccessException : SystemException {
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.UnhandledExceptionEventArgs : EventArgs {
    private object _exception;
    private bool _isTerminating;
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ObsoleteAttribute("Formatter-based serialization is obsolete and should not be used.")]
public class System.UnitySerializationHolder : object {
    private int _unityType;
    private string _data;
    [NullableContextAttribute("1")]
public UnitySerializationHolder(SerializationInfo info, StreamingContext context);
    internal static void GetUnitySerializationInfo(SerializationInfo info, int unityType);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public sealed virtual object GetRealObject(StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple : ValueType {
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`1 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`1(T1 item1);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`2 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`2(T1 item1, T2 item2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`3 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    [NullableAttribute("1")]
public T3 Item3;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`4 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    [NullableAttribute("1")]
public T3 Item3;
    [NullableAttribute("1")]
public T4 Item4;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    [NullableContextAttribute("1")]
public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    [NullableAttribute("0")]
public TRest Rest;
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private int GetHashCodeCore(IEqualityComparer comparer);
    private sealed virtual override int System.IValueTupleInternal.GetHashCode(IEqualityComparer comparer);
    public virtual string ToString();
    private sealed virtual override string System.IValueTupleInternal.ToStringEnd();
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public abstract class System.ValueType : object {
    internal static bool DefaultEquals(object o1, object o2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static int InternalGetHashCode(object o, Object[]& fields);
    private static bool InternalEquals(object o1, object o2, Object[]& fields);
}
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Version : object {
    private int _Major;
    private int _Minor;
    private int _Build;
    private int _Revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public short MajorRevision { get; }
    public short MinorRevision { get; }
    private int DefaultFormatFieldCount { get; }
    public Version(int major, int minor, int build, int revision);
    public Version(int major, int minor, int build);
    public Version(int major, int minor);
    [NullableContextAttribute("1")]
public Version(string version);
    private Version(Version version);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    public short get_MajorRevision();
    public short get_MinorRevision();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object version);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(Version value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(int fieldCount);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    public bool TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten);
    public bool TryFormat(Span`1<byte> utf8Destination, int fieldCount, Int32& bytesWritten);
    private bool TryFormatCore(Span`1<TChar> destination, int fieldCount, Int32& charsWritten);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private sealed virtual override bool System.IUtf8SpanFormattable.TryFormat(Span`1<byte> utf8Destination, Int32& bytesWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private int get_DefaultFormatFieldCount();
    [NullableContextAttribute("1")]
public static Version Parse(string input);
    public static Version Parse(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, Version& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    private static Version ParseVersion(ReadOnlySpan`1<char> input, bool throwOnFailure);
    private static bool TryParseComponent(ReadOnlySpan`1<char> component, string componentName, bool throwOnFailure, Int32& parsedComponent);
    [NullableContextAttribute("2")]
public static bool op_Equality(Version v1, Version v2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Version v1, Version v2);
    [NullableContextAttribute("2")]
public static bool op_LessThan(Version v1, Version v2);
    [NullableContextAttribute("2")]
public static bool op_LessThanOrEqual(Version v1, Version v2);
    [NullableContextAttribute("2")]
public static bool op_GreaterThan(Version v1, Version v2);
    [NullableContextAttribute("2")]
public static bool op_GreaterThanOrEqual(Version v1, Version v2);
    [CompilerGeneratedAttribute]
internal static void <TryFormatCore>g__ThrowArgumentException|35_0(string failureUpperBound);
}
public class System.Void : ValueType {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference : object {
    private IntPtr _taggedHandle;
    public bool TrackResurrection { get; }
    internal IntPtr WeakHandle { get; }
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
protected WeakReference(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual bool get_TrackResurrection();
    private void Create(object target, bool trackResurrection);
    private bool IsTrackResurrection();
    internal IntPtr get_WeakHandle();
    public virtual bool get_IsAlive();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[TypeForwardedFromAttribute("mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.WeakReference`1 : object {
    private IntPtr _taggedHandle;
    [NullableAttribute("2")]
private T Target { get; }
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    private WeakReference`1(SerializationInfo info, StreamingContext context);
    public bool TryGetTarget(T& target);
    [ObsoleteAttribute("This API supports obsolete formatter-based serialization. It should not be called or extended by application code.")]
[EditorBrowsableAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private bool IsTrackResurrection();
    private void Create(T target, bool trackResurrection);
    public void SetTarget(T target);
    private T get_Target();
    protected virtual override void Finalize();
}
